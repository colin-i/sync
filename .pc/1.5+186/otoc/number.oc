
#aftercalli

#N structure

function number(sv pbuffer,sd outfile)
include "number.h"
	charx item#1;call get_char(pbuffer,#item)
	while item!=(Xfile_numbers_done)
		#this coresponds to number.pre.oc line
		value functions^normal;               value  *^neg;            value  *^not;            value  *^notneg;            value  *^open;                 value  *^close;                 value *^add;                value *^sub;                value *^mul;                value *^div;                value *^divu;                value *^and;                value *^or;                value *^xor;                value *^pow;                value *^rem;                value *^remu;                value *^shl;                value *^sar;                value *^shr;                value *^equal;                value *^inequal;                value *^less;                value *^greater;                value *^lessequal;                value *^greaterequal;                value *^logicaland;                value *^logicalor;                value *^unsignedless;                value *^unsignedgreater;                value *^unsignedlessequal;                value *^unsignedgreaterequal;                value *^parity;                value *^odd;
		#if item>^(Xfile_numbers_last);callret aftercallenable();end
		ss n;set n #data
		add n item
		sv f;set f n#
		#if f=(Xfile_numbers_notmapped);callret aftercallenable();end
		mult f :
		add f #functions
		set f f#
		call f(outfile,pbuffer)
		call get_char(pbuffer,#item)
	end
end

function numbertype(sv pbuffer,sd outfile)
	value functions^number_int_long
	value         *^number_int_data
	value         *^number_int_datax
	value         *^number_text_dec
	value         *^number_text_oct
	value         *^number_text_hex
	value         *^number_text_const
	value         *^number_func_size
	value         *^number_func_sizex
	value         *^number_var_size
	value         *^number_var_offset
	charx type#1;call get_char(pbuffer,#type)
	mult type :
	sv f^functions
	add f type
	set f f#
	callg f(pbuffer,outfile)
end

function number_int_long();end
function number_int_data();end
function number_int_datax();end
function number_text_dec(sv pbuffer,sd outfile)
	datax sz#1;valuex pointer#1
	call get_string(pbuffer,#sz,#pointer)
	callg write(outfile,pointer,sz)
end
function number_text_oct(sv pbuffer,sd outfile)
	callg number_text_dec(pbuffer,outfile)
end
function number_text_hex(sv pbuffer,sd outfile)
	callg number_text_dec(pbuffer,outfile)
end
function number_text_const(sv pbuffer,sd outfile)
	callg number_text_dec(pbuffer,outfile)
end
function number_func_size(sv pbuffer)
	datax sz#1;valuex pointer#1
	call get_string(pbuffer,#sz,#pointer)
end
function number_func_sizex(sv pbuffer)
	datax sz#1;valuex pointer#1
	call get_string(pbuffer,#sz,#pointer)
end
function number_var_size(sv pbuffer,sd outfile)
	callg dot(pbuffer,outfile)
end
function number_var_offset(sv pbuffer,sd outfile)
	callg dot(pbuffer,outfile)
end

function normal(sd outfile,sv pbuffer)
	callg numbertype(pbuffer,outfile)
end
function neg(sd outfile,sv pbuffer)
	call write(outfile,#action_tdec.a,1)
	callg numbertype(pbuffer,outfile)
end
function not(sd outfile,sv pbuffer)
	call write(outfile,#action_tnot.a,1)
	callg numbertype(pbuffer,outfile)
end
function notneg(sd outfile,sv pbuffer)
	call write(outfile,#action_tnot.a,2)
	callg numbertype(pbuffer,outfile)
end
function open()
#	writel
end
function close()
#	writer
end
function add(sd outfile)
	callg write(outfile,#action_tinc.a,1)
end
function sub(sd outfile)
	callg write(outfile,#action_tdec.a,1)
end
function mul()
#	write_long.point
end
function div()
#	comment.a
end
function divu()
#	div
end
function and()
#	asciiand,
end
function or()
#	asciior,
end
function xor()
#	asciicirc
end
function pow()
#	unimplemented
end
function rem()
#	asciipercent
end
function remu()
#	rem
end
function shl()
#	action_tshl1
end
function sar()
#	action_tshr1
end
function shr()
#	action_tshr1
end
function equal()
#	cond.eq
end
function inequal()
#	cond.ne
end
function less()
#	action_tshl1
end
function greater()
#	action_tshr1
end
function lessequal()
#	cond.le
end
function greaterequal()
#	cond.ge
end
function logicaland()
#	and
end
function logicalor()
#	or
end
function unsignedless()
#	less
end
function unsignedgreater()
#	greater
end
function unsignedlessequal()
#	lessequal
end
function unsignedgreaterequal()
#	greaterequal
end
function parity()
#	unimplemented
end
function odd()
#	unimplemented
end
