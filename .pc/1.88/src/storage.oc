Format ElfObj64

include "../include/prog.h"

#win32 with _
importx "strlen" strlen
importx "memcpy" memcpy

#this is throwless here
import "struct_ids" struct_ids

#
function identifiers()
    data id#1
    return #id
endfunction
function identifiers_set(sd value)
    sd id
    setcall id identifiers()
    set id# value
endfunction

#p
function exportsId()
    data exports=not_an_id
    return #exports
endfunction

function swf_frames_reg()
	data main_id#1
#set reg for later
	value reg#1
	sd block
	set block struct_ids((ids_get),main_id)
	set reg block_get_size(block)
	sub reg (WORD)
end
#p
function swf_frames_pointer()
	sd block
	set block struct_ids((ids_get),swf_frames_reg.main_id)
	set block block_get_mem(block)
	add block swf_frames_reg.reg
	return block
end
#p
function swf_sprite_frames_pointer(sd spriteid)
	sd block
	setcall block struct_ids((ids_get),spriteid)
	setcall block block_get_mem(block)
	add block (WORD)
	return block
end

function frames_as_shows(datax flag)
	and flag (flag_framesAsShows)
end

import "mem_free" mem_free
import "action_code_values_free" action_code_values_free
import "file_close" file_close
import "block_get_mem" block_get_mem
import "block_get_mem_size" block_get_mem_size
import "bits_packs" bits_packs
import "word_swap_arg" word_swap_arg
import "block_get_size" block_get_size
import "block_reset_size" block_reset_size

import "actionpoolid" actionpoolid;import "actionpoolid_root" actionpoolid_root
import "actionpool_currentblock" actionpool_currentblock

import "action_size" action_size
import "stack_to_word_arg" stack_to_word_arg
import "word_arg_to_stack" word_arg_to_stack



#aftercallimport ebool



import "dtitles_frame" dtitles_frame

#id
function identifiers_get()
	sd id
	setcall id identifiers()
	if id#=(maxuint16) #from swf specitifactions, example, id field for a DefineSprite
		call error("max uint16 at identifiers")
	end
	inc id#
	return id#
endfunction

function free_sprite_id(sd id,sd finalId_or_containerId) #containerId for buttons
    call struct_ids((ids_free),id)
#these two are ok throwless
	callg struct_ids_action((ids_free),id)
	callg struct_ids_actionpool((ids_free),id)
#
	import "debug_spritedone" debug_spritedone
	call debug_spritedone(id,finalId_or_containerId)
endfunction

import "error" error
import "struct_ids_actionpool" struct_ids_actionpool
import "struct_ids_action" struct_ids_action
import "mem_block_add" mem_block_add
import "def_mem" def_mem
import "debug_show" debug_show

function swf_mem(sd proc,sd arg,sd len)
    vdata path_mem=NULL
    #4-7 is 0
    data path_size#1
    data filelength_offset#1
    data file_out=fd_error

    data id#1
	#data main_id#1 #was moved to a throwless location
    value call_struct#1;vdata c_main^struct_ids;vdata c_pool^struct_ids_actionpool

    data id_stack#1

	if proc=(mem_exp_change_back)
        set id swf_frames_reg.main_id
        set call_struct c_main
        ret
	endif
	if proc=(mem_exp_change_pool)  #this can be stackable, at debug titles, at normal usage is back at the main id
	#is after action_code_values_init
		set id_stack id
		set id arg
		set call_struct c_pool
		ret
	endif
	if proc=(mem_exp_change_back_pool)
		set id id_stack
		set call_struct c_main
		ret
	endif
	if proc=(mem_exp_init)
    #arg is file
    #len is filelength offset
        if path_mem!=(NULL)
            call error("The previous swf was not ended.")
        endif
        #0
        import "memalloc" memalloc
        setcall path_size strlen(arg);inc path_size
        setcall path_mem memalloc(path_size)
        call memcpy(path_mem,arg,path_size)
        #1
        setcall swf_frames_reg.main_id def_mem()
        set id swf_frames_reg.main_id
        call swf_actionblock((mem_exp_init),swf_frames_reg.main_id)
        set call_struct c_main
        #2
        call exports_init()
        #3
        import "action_code_values_init" action_code_values_init
        call action_code_values_init()
        #
        set filelength_offset len
        #
        ret
	endif
	if proc=(mem_exp_free)
        if path_mem!=(NULL)
            #0
            call mem_free(#path_mem)
            #1 freeing all ids(main(exports,root+sprites),acs,pools)
            call struct_ids((ids_all_free))
            #2 exports
            sd exports
            setcall exports exportsId()
            set exports# (not_an_id)
            #3 set of values
            call action_code_values_free()
            #file
            if file_out!=(fd_error)
                call file_close(#file_out)
            endif
        endif
        ret
	endif
    if path_mem=(NULL)
    #swf_(placeobject...)->mem_exp_add;swf_sprite_(placeobject...)->mem_exp_change;swf_done->mem_exp_done
        call error("there isn't a swf started")
    endif
    if proc=(mem_exp_add)
        #blockMain blockPool
        sv p_block
        setcall p_block call_struct((ids_get_pointer),id)
        call mem_block_add(p_block,arg,len)
    elseif proc=(mem_exp_change)
		set id arg
		set call_struct c_main
    else
    #if proc==(mem_exp_done)
        call swf_tag_end()

        sd block
        setcall block call_struct((ids_get),swf_frames_reg.main_id)
        sd mem;sd size;call block_get_mem_size(block,#mem,#size)

        sd pointer
        set pointer mem
        add pointer filelength_offset
        set pointer# size

        import "file_open" file_open
        setcall file_out file_open(path_mem,(_open_write))
        import "file_write" file_write
        call file_write(file_out,mem,size)
    endelse
endfunction
function swf_mem_add(ss dest,sd size)
    call swf_mem((mem_exp_add),dest,size)
endfunction
function swf_tag_end()
    call swf_tag_recordheader_entry((End),0)
endfunction
function swf_tag_recordheader_entry(sd tag,sd size)
    if size<(recordheader_long_mark)
        sd tag_plus_size
        call swf_tag_recordheader(#tag_plus_size,tag,size)
    else
        call swf_tag_recordheader_long_entry(tag,size)
    endelse
endfunction
function swf_tag_recordheader_long_entry(sd tag,sd size)
    sd tag_plus_size
    call swf_tag_recordheader(#tag_plus_size,tag,(recordheader_long_mark))
    call swf_mem_add(#size,(DWORD))
endfunction
const short_header=2
function swf_tag_recordheader(ss dest,sd tag,sd size)
    call bits_packs(dest,2,tag,10,size,6)
    call word_swap_arg(dest)
    call swf_mem((mem_exp_add),dest,(short_header))
endfunction
function swf_tag(ss dest,sd tag,sd size)
    call swf_tag_recordheader(dest,tag,size)
    add dest (short_header)
    call swf_mem((mem_exp_add),dest,size)
endfunction

function swf_frames_inc(sd frames,sw pointer)
	if frames=(maxuint16)  #example, frame count at DefineSprite
		call error("max uint16 at frames")
	end
	inc frames      ##even if is not a ShowFrame in the swf, is action that resides in a frame, ffdec is saying same
	call stack_to_word_arg(frames,pointer)
end

#
function swf_actionblock(sd proc,sd arg,sd arg2)
    data id#1
    data id_back#1
    sd poolid
	if proc=(mem_exp_change)
        #must verify to be a valid user input id
        call struct_ids_actionpool((ids_get_pointer),id)
        #
        set id arg
        #
        setcall poolid actionpoolid()
        set poolid# id
        ret
	endif
	if proc=(mem_exp_change_back)
        set id id_back
        #
        sd root_poolid
        setcall root_poolid actionpoolid_root()
        setcall poolid actionpoolid()
        set poolid# root_poolid#
        ret
	endif
	if proc=(mem_exp_init)
        set id arg
        set id_back id
        call struct_ids_action((ids_set),id)
        call struct_ids_actionpool((ids_set),id)
        sd p_poolid;setcall p_poolid actionpoolid();set p_poolid# id
        sd p_poolrootid;setcall p_poolrootid actionpoolid_root();set p_poolrootid# id
        ret
	endif
    sv p_block
    setcall p_block struct_ids_action((ids_get_pointer),id)
    if proc=(mem_exp_add)
        call mem_block_add(p_block,arg,arg2)
    elseif proc=(mem_exp_part_done)
		sd frames
		setcall frames word_arg_to_stack(arg2)

		sd block
		set block p_block#
		sd size
		setcall size block_get_size(block)
		if size!=0  #here is an ending from show or done with size
			if arg=(from_show) #example: two action() and one show here
				call debug_show(id) #id is 0/spriteid, this is good at debugger to keep the count of frames
			end

			#more at dtitles
			call dtitles_frame(frames)

			if frames_as_shows.flag=0
				call swf_frames_inc(frames,arg2)
			elseif arg=(from_show)
				call swf_frames_inc(frames,arg2)
			end

			import "write_action" write_action
			sd tagsz
			setcall tagsz action_size(id)
			call swf_tag_recordheader_entry((DoAction),tagsz)
			call write_action(id)
			sd poolblock
			setcall poolblock actionpool_currentblock()
			call block_reset_size(poolblock)
			call block_reset_size(block)
		elseif arg=(from_show)  #here is an ending from show with no size
			call debug_show(id) #to keep the count of frames at debugger
			call swf_frames_inc(frames,arg2)
		elseif frames=0    #here is an ending from done with no size and no previous show
			if frames_as_shows.flag=0
				call swf_frames_inc(frames,arg2) #a default frame, how was before at root, and at sprite is ok
			end
		endelseif
    else
    #if proc==(mem_exp_get_block)
        return p_block#
    endelse
endfunction

function swf_actionblock_add(sd value,sd size)
    call swf_actionblock((mem_exp_add),value,size)
endfunction
function actionrecordheader(sd tag,sd size)
	char t#actionrecordheader_tag_size
	char length#actionrecordheader_length_size
	set t tag
	call stack_to_word_arg(size,#length)
	call swf_actionblock_add(#t,(actionrecordheader_size))
	import "debug_phase_code_add" debug_phase_code_add
	call debug_phase_code_add((TRUE),#length)
endfunction
function swf_actionrecordheader(sd tag,sd size)
    char t#1
    char length#2
    set t tag
    call stack_to_word_arg(size,#length)
    call swf_mem_add(#t,3)
endfunction

#preid
function new_sprite_id()
    sd id
    setcall id def_mem()
    call struct_ids_action((ids_set),id)
    call struct_ids_actionpool((ids_set),id)
    return id
endfunction

#
function exports_init()
    sd exports
    setcall exports exportsId()
    sd id
    setcall id def_mem()
    set exports# id
endfunction
#id
function exportsId_get()
    sd e
    setcall e exportsId()
    if e#=(not_an_id);call error("Do not call the exports at this moment.");endif
    return e#
endfunction

function swf_showframe_base(sd frames_pointer)
#showframe tag
	call swf_actionblock((mem_exp_part_done),(from_show),frames_pointer)
	call swf_tag_recordheader_entry((ShowFrame),0)
endfunction
