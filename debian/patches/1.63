Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 actionswf (1-63) bionic; urgency=medium
 .
   * fix gotoand...
Author: bc <bc@bc-Type1ProductConfigId>

---
The information above should follow the Patch Tagging Guidelines, please
checkout https://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: (upstream|backport|vendor|other), (<patch-url>|commit:<commit-id>)
Bug: <upstream-bugtracker-url>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: (no|not-needed|<patch-forwarded-url>)
Applied-Upstream: <version>, (<commit-url>|commit:<commid-id>)
Reviewed-By: <name and email of someone who approved/reviewed the patch>
Last-Update: 2023-12-31

--- actionswf-1.orig/arh/pub
+++ actionswf-1/arh/pub
@@ -20,6 +20,4 @@ last=$(curl https://api.github.com/repos
 
 #plans:
 
-#another project: ffdec -export script folder file , and debug curated code, .dbg file; get ffdec and compile , get from swf/get from swfdump -d/recompile .log , compare
-
 #if builtin more than one param then is not a builtin (is only for gotoAnd...)
--- actionswf-1.orig/dev/build.bat
+++ actionswf-1/dev/build.bat
@@ -1,4 +1,4 @@
-o.exe "shared/action_dllmain.s"
+o.exe "shared/action_dllmain.oc"
 
 set files_src=./src/
 
@@ -8,7 +8,7 @@ goto go
 :sub1
 if "%1"=="" exit /b
 
-o.exe %files_src%%1.s
+o.exe %files_src%%1.oc
 
 shift
 goto :sub1
--- actionswf-1.orig/example/Makefile
+++ actionswf-1/example/Makefile
@@ -29,7 +29,7 @@ all: build exe
 build: ${name} uns lib link
 
 uns:
-	${OLINK} ${name}.s.log
+	${OLINK} ${name}.oc.log
 
 lib:
 	if [ "${platform}" = "win" ]; then \
@@ -58,14 +58,14 @@ link:
 
 exe:
 	if [ "${platform}" = "lin" ]; then \
-		export LD_LIBRARY_PATH=../src; ./example; \
+		export LD_LIBRARY_PATH=../src; ./${name} 1; \
 	fi
 
-%: %.s
+%: %.oc
 	${OCOMP} $< ${OFLAGS}
 
 clean:
-	-rm -f ${name}.s.log
+	-rm -f ${name}.oc.log
 	-rm -f ${name}.o
 	-rm -f ${name}
 	-rm -f ${name}.exe
@@ -85,4 +85,4 @@ test:
 
 .NOTPARALLEL:
 
-#LD_LIBRARY_PATH=/home/bc/s/actionswf-1/src ./example
+#LD_LIBRARY_PATH=/home/bc/s/actionswf-1/src ./${name} 0
--- actionswf-1.orig/example/change_format.c
+++ actionswf-1/example/change_format.c
@@ -30,7 +30,7 @@ void files(int x){
 	for(i=0;i<length;i++){
 		if(content[i]==','){
 			content[i]=0;
-			sprintf(z,"%s.s",&content[p]);fwr(z);
+			sprintf(z,"%s.oc",&content[p]);fwr(z);
 			p=i+1;
 		}
 	}
@@ -44,7 +44,7 @@ void main(int argc,char** argv)
 	format=argv[1];
 
 	_chdir("../");_chdir("shared");
-	fwr("action_dllmain.s");
+	fwr("action_dllmain.oc");
 
 	_chdir("../");_chdir("src");
 	files(1);files(2);
--- actionswf-1.orig/example/example.bat
+++ actionswf-1/example/example.bat
@@ -10,7 +10,7 @@ call 64\build.bat
 
 cd example
 
-o example.s
+o example.oc
 objcopy --input-target=elf32-i386 example.o --output-target=elf64-x86-64 exampleX.o
 
 cd ..
--- /dev/null
+++ actionswf-1/example/example.oc
@@ -0,0 +1,67 @@
+format elfobj64
+
+#a simple shape moving on the stage example
+
+#win32 with _
+importx "sprintf" sprintf
+
+einclude "../dev/import.h"
+
+const width=640
+const height=480
+const shape_lat=40
+
+
+
+####################
+
+entry main(sd argc,sv argv)
+
+incst argv;ss argv1;set argv1 argv#;sub argv1# 0x30
+
+call swf_new_ex("example.swf",(width),(height),0x001100,24,argv1#)
+
+sd shape
+setcall shape swf_shape_basic((shape_lat),(shape_lat),0xffeeFEff,0x11FF22ff)
+
+sd movie_preid
+setcall movie_preid swf_sprite_new()
+
+call swf_sprite_placeobject(movie_preid,shape,1)
+call swf_sprite_showframe(movie_preid)
+
+char data#512
+vstr ac^data
+vstr vars="var move=20;var width=%u;var height=%u;var lat=%u;var left=move;var top=move;var right=width-lat-move;var bottom=height-lat-move"
+call sprintf(ac,vars,(width),(height),(shape_lat))
+call action_sprite(movie_preid,ac)
+
+call action_sprite(movie_preid,"
+if(this._x>=right)_root.x_coef=_root.x_coef*-1;
+else if(this._x<=left)_root.x_coef=_root.x_coef*-1;
+this._x=move*_root.x_coef+this._x;
+if(this._y>=bottom)_root.y_coef=_root.y_coef*-1;
+else if(this._y<=top)_root.y_coef=_root.y_coef*-1;
+this._y=move*_root.y_coef+this._y;
+")
+
+call swf_sprite_showframe(movie_preid)
+
+sd movie
+setcall movie swf_sprite_done(movie_preid)
+
+call swf_exports_add(movie,"movie")
+call swf_exports_done()
+
+call action("
+var x_coef=1;
+var y_coef=1;
+this.attachMovie('movie','_movie',1);
+_movie._x=100;
+_movie._y=100;
+")
+
+call swf_showframe()
+call swf_done()
+
+return 0
--- actionswf-1.orig/example/example.s
+++ /dev/null
@@ -1,64 +0,0 @@
-format elfobj64
-
-#a simple shape moving on the stage example
-
-#win32 with _
-importx "sprintf" sprintf
-
-einclude "../dev/import.h"
-
-const width=640
-const height=480
-const shape_lat=40
-
-
-
-####################
-
-entry main()
-call swf_new_ex("example.swf",(width),(height),0x001100,24,1)
-
-sd shape
-setcall shape swf_shape_basic((shape_lat),(shape_lat),0xffeeFEff,0x11FF22ff)
-
-sd movie_preid
-setcall movie_preid swf_sprite_new()
-
-call swf_sprite_placeobject(movie_preid,shape,1)
-call swf_sprite_showframe(movie_preid)
-
-char data#512
-vstr ac^data
-vstr vars="var move=20;var width=%u;var height=%u;var lat=%u;var left=move;var top=move;var right=width-lat-move;var bottom=height-lat-move"
-call sprintf(ac,vars,(width),(height),(shape_lat))
-call action_sprite(movie_preid,ac)
-
-call action_sprite(movie_preid,"
-if(this._x>=right)_root.x_coef=_root.x_coef*-1;
-else if(this._x<=left)_root.x_coef=_root.x_coef*-1;
-this._x=move*_root.x_coef+this._x;
-if(this._y>=bottom)_root.y_coef=_root.y_coef*-1;
-else if(this._y<=top)_root.y_coef=_root.y_coef*-1;
-this._y=move*_root.y_coef+this._y;
-")
-
-call swf_sprite_showframe(movie_preid)
-
-sd movie
-setcall movie swf_sprite_done(movie_preid)
-
-call swf_exports_add(movie,"movie")
-call swf_exports_done()
-
-call action("
-var x_coef=1;
-var y_coef=1;
-this.attachMovie('movie','_movie',1);
-_movie._x=100;
-_movie._y=100;
-")
-
-call swf_showframe()
-call swf_done()
-
-return 0
--- actionswf-1.orig/example/example32.bat
+++ actionswf-1/example/example32.bat
@@ -13,7 +13,7 @@ call dev\build.bat
 cd example
 change_format.exe "Format ElfObj64"
 
-o example32.s
+o example32.oc
 
 cd ..
 
--- /dev/null
+++ actionswf-1/example/example32.oc
@@ -0,0 +1,61 @@
+format elfobj
+
+importx "sprintf" sprintf
+
+#a simple shape moving on the stage example
+
+orphan off
+include "../dev/import.h"
+orphan on
+
+const width=640
+const height=480
+
+const shape_lat=40
+
+####################
+entry example_main()
+
+call swf_new("example32.swf",(width),(height),0x001100,24)
+
+sd shape
+setcall shape swf_shape_basic((shape_lat),(shape_lat),0xffeeFEff,0x11FF22ff)
+
+sd movie_preid
+setcall movie_preid swf_sprite_new()
+
+call swf_sprite_placeobject(movie_preid,shape,1)
+call swf_sprite_showframe(movie_preid)
+
+char data#512
+str ac^data
+str vars="var move=20;var width=%u;var height=%u;var lat=%u;var left=move;var top=move;var right=width-lat-move;var bottom=height-lat-move"
+call sprintf(ac,vars,(width),(height),(shape_lat))
+call action_sprite(movie_preid,ac)
+
+call action_sprite(movie_preid,"
+if(this._x>=right)_root.x_coef=_root.x_coef*-1;
+else if(this._x<=left)_root.x_coef=_root.x_coef*-1;
+this._x=move*_root.x_coef+this._x;
+if(this._y>=bottom)_root.y_coef=_root.y_coef*-1;
+else if(this._y<=top)_root.y_coef=_root.y_coef*-1;
+this._y=move*_root.y_coef+this._y;
+")
+call swf_sprite_showframe(movie_preid)
+sd movie
+setcall movie swf_sprite_done(movie_preid)
+
+call swf_exports_add(movie,"movie")
+call swf_exports_done()
+
+call action("
+var x_coef=1;
+var y_coef=1;
+this.attachMovie('movie','_movie',1);
+_movie._x=100;
+_movie._y=100;
+")
+
+call swf_showframe()
+call swf_done()
+return 1
--- actionswf-1.orig/example/example32.s
+++ /dev/null
@@ -1,61 +0,0 @@
-format elfobj
-
-importx "sprintf" sprintf
-
-#a simple shape moving on the stage example
-
-orphan off
-include "../dev/import.h"
-orphan on
-
-const width=640
-const height=480
-
-const shape_lat=40
-
-####################
-entry example_main()
-
-call swf_new("example32.swf",(width),(height),0x001100,24)
-
-sd shape
-setcall shape swf_shape_basic((shape_lat),(shape_lat),0xffeeFEff,0x11FF22ff)
-
-sd movie_preid
-setcall movie_preid swf_sprite_new()
-
-call swf_sprite_placeobject(movie_preid,shape,1)
-call swf_sprite_showframe(movie_preid)
-
-char data#512
-str ac^data
-str vars="var move=20;var width=%u;var height=%u;var lat=%u;var left=move;var top=move;var right=width-lat-move;var bottom=height-lat-move"
-call sprintf(ac,vars,(width),(height),(shape_lat))
-call action_sprite(movie_preid,ac)
-
-call action_sprite(movie_preid,"
-if(this._x>=right)_root.x_coef=_root.x_coef*-1;
-else if(this._x<=left)_root.x_coef=_root.x_coef*-1;
-this._x=move*_root.x_coef+this._x;
-if(this._y>=bottom)_root.y_coef=_root.y_coef*-1;
-else if(this._y<=top)_root.y_coef=_root.y_coef*-1;
-this._y=move*_root.y_coef+this._y;
-")
-call swf_sprite_showframe(movie_preid)
-sd movie
-setcall movie swf_sprite_done(movie_preid)
-
-call swf_exports_add(movie,"movie")
-call swf_exports_done()
-
-call action("
-var x_coef=1;
-var y_coef=1;
-this.attachMovie('movie','_movie',1);
-_movie._x=100;
-_movie._y=100;
-")
-
-call swf_showframe()
-call swf_done()
-return 1
--- actionswf-1.orig/include/action.h
+++ actionswf-1/include/action.h
@@ -82,9 +82,9 @@ const ifElse_start=0xfe0EE0e0
 
 const brace_blocks_function=0x7fFFffFF
 
-const to_flags=0x100*0x100*0x100
-const consecutive_flag=0x80*to_flags
-const else_flag=0x40*to_flags
+const to_flags=24
+const consecutive_flag=0x80<<to_flags
+const else_flag=0x40<<to_flags
 #const all_flags=consecutive_flag|else_flag
 const normal_marker=0x01010202
 const if_marker=0x03030404
--- actionswf-1.orig/include/prog.h
+++ actionswf-1/include/prog.h
@@ -47,7 +47,7 @@ const ids_get_pointer=3
 const ids_all_free=4
 const ids_counter=5
 
-const negative_means_action_sprite_pool=0x80*0x100*0x100*0x100
+const negative_means_action_sprite_pool=0x80<<8<<8<<8
 const fd_error=-1
 const fd_none=fd_error
 const not_an_id=-1
@@ -103,3 +103,8 @@ Const _open_write_base=_O_WRONLY|flag_O_
 Const _open_write=_open_write_base|_O_TRUNC
 
 const fprintf_min=2  #file,format plus ...
+
+const from_show=0
+const from_done=1
+
+const debug_none=0
--- actionswf-1.orig/readme.txt
+++ actionswf-1/readme.txt
@@ -11,10 +11,13 @@ TextLinesNumber
 TextLines
 {NumberA,NumberB}
 
-Or
+SpriteId
+(here is a blank row)
+(another one, here is a ShowFrame)
 
 SpriteId
-(here is a blank row, not TextLinesNumber, representing a ShowFrame, to differentiate DoAction tags)
+(blank row)
+FinalSpriteId
 
 Where:
 SpriteId or 0 for root.
@@ -22,3 +25,4 @@ TextLinesNumber is the number of lines t
 TextLines is the text like in action[_sprite] call.
 NumberA lines, then NumberA1+...+NumberAN<=TextLinesNumber, less only when last line(s) is/are blank(s).
 NumberB is the number of actions encountered in NumberA
+FinalSpriteId is the if from the swf
--- /dev/null
+++ actionswf-1/shared/action_dllmain.e.oc
@@ -0,0 +1,5 @@
+Format ElfObj64
+
+functionx DllMain()
+	return 1
+endfunction
--- actionswf-1.orig/shared/action_dllmain.es
+++ /dev/null
@@ -1,5 +0,0 @@
-Format ElfObj64
-
-functionx DllMain()
-	return 1
-endfunction
--- actionswf-1.orig/src/Makefile
+++ actionswf-1/src/Makefile
@@ -16,7 +16,7 @@ OLINK=ounused
 endif
 
 ifndef linkerflags
-linkerflags=-s
+linkerflags=-O3 -s
 #-O0 to 3 is same at .so here
 endif
 
@@ -53,11 +53,11 @@ libname=${restofname}${name}
 
 $(eval obs = )
 $(eval eobs = )
-$(foreach var,$(expitems),$(eval eobs += ${items_prefix}${var}.o))
+$(foreach var,$(expitems),$(eval eobs += ${items_prefix}${var}.e.o))
 $(foreach var,$(items),$(eval obs += ${items_prefix}${var}.o))
 $(eval logs = )
-$(foreach var,$(expitems),$(eval logs += ${items_prefix}${var}.es.log))
-$(foreach var,$(items),$(eval logs += ${items_prefix}${var}.s.log))
+$(foreach var,$(expitems),$(eval logs += ${items_prefix}${var}.e.oc.log))
+$(foreach var,$(items),$(eval logs += ${items_prefix}${var}.oc.log))
 
 strippy=ostriputil
 
@@ -91,8 +91,8 @@ ${libname}: ${name}
 else
 ${libname}: ${name}
 	$(eval strp = )
-	$(foreach var,$(expitems),$(eval strp += ${items_prefix}${var}.es.log ${items_prefix}${var}.o))
-	$(foreach var,$(items),$(eval strp += ${items_prefix}${var}.s.log ${items_prefix}${var}.o))
+	$(foreach var,$(expitems),$(eval strp += ${items_prefix}${var}.e.oc.log ${items_prefix}${var}.o))
+	$(foreach var,$(items),$(eval strp += ${items_prefix}${var}.oc.log ${items_prefix}${var}.o))
 	${OSTRIP} ${name} ${strp}
 	#if [ ! -e "./strip.py" ]; then wget https://raw.githubusercontent.com/colin-i/o/master/ostrip/strip.py; fi
 	${strippy} ${name} ${libname}
@@ -107,9 +107,9 @@ ${name}: ${obs} ${eobs}
 	${ATLDCOM}
 endif
 
-%.o: %.s
+%.o: %.oc
 	${OCOMP} $< ${OFLAGS}
-%.o: %.es
+%.o: %.e.oc
 	${OCOMP} $< ${OFLAGS}
 
 ounused:
--- /dev/null
+++ actionswf-1/src/action.e.oc
@@ -0,0 +1,48 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+#this has throws but for mem_exp_change and back are not required
+import "swf_actionblock" swf_actionblock
+
+
+aftercallimport ebool
+
+#this/an action
+
+import "action_base" action_base
+import "action_format" action_format
+import "debug_base" debug_base
+
+functionX action(ss ac)
+#ss ac       actionscript string to be parsed
+	call debug_base(0)
+	call action_base(ac)
+endfunction
+functionXx actionf(ss buffer,ss *format)
+#ss buffer   the buffer where to sprintf the format and the arguments
+#ss format   the format
+#...         % arguments here
+	call debug_base(0)
+	call action_format(#buffer)
+endfunction
+
+#sprite
+
+functionX action_sprite(sd sprite,ss actions)
+#sd sprite    sprite id
+#ss actions   same as action
+	call debug_base(sprite)
+    call swf_actionblock((mem_exp_change),sprite)
+    call action_base(actions)
+    call swf_actionblock((mem_exp_change_back))
+endfunction
+functionXx actionf_sprite(sd sprite,ss buffer,ss *format)
+#sd sprite    sprite id
+#ss buffer    same as actionf
+#ss format    same as actionf
+	call debug_base(sprite)
+    call swf_actionblock((mem_exp_change),sprite)
+    call action_format(#buffer)
+    call swf_actionblock((mem_exp_change_back))
+endfunction
--- actionswf-1.orig/src/action.es
+++ /dev/null
@@ -1,48 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-#this has throws but for mem_exp_change and back are not required
-import "swf_actionblock" swf_actionblock
-
-
-importaftercall ebool
-
-#this/an action
-
-import "action_base" action_base
-import "action_format" action_format
-import "debug_base" debug_base
-
-functionX action(ss ac)
-#ss ac       actionscript string to be parsed
-	call debug_base(0)
-	call action_base(ac)
-endfunction
-functionXx actionf(ss buffer,ss *format)
-#ss buffer   the buffer where to sprintf the format and the arguments
-#ss format   the format
-#...         % arguments here
-	call debug_base(0)
-	call action_format(#buffer)
-endfunction
-
-#sprite
-
-functionX action_sprite(sd sprite,ss actions)
-#sd sprite    sprite id
-#ss actions   same as action
-	call debug_base(sprite)
-    call swf_actionblock((mem_exp_change),sprite)
-    call action_base(actions)
-    call swf_actionblock((mem_exp_change_back))
-endfunction
-functionXx actionf_sprite(sd sprite,ss buffer,ss *format)
-#sd sprite    sprite id
-#ss buffer    same as actionf
-#ss format    same as actionf
-	call debug_base(sprite)
-    call swf_actionblock((mem_exp_change),sprite)
-    call action_format(#buffer)
-    call swf_actionblock((mem_exp_change_back))
-endfunction
--- /dev/null
+++ actionswf-1/src/actioncode.oc
@@ -0,0 +1,874 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+#win32 with _
+importx "strcmp" strcmp
+importx "strlen" strlen
+
+const totalvalues=65535
+function action_code_values_container()
+    value setofvalues=NULL
+    return #setofvalues
+endfunction
+function action_code_values()
+    sv m
+    setcall m action_code_values_container()
+    return m#
+endfunction
+
+import "mem_free" mem_free
+
+function action_code_values_free()
+    sv p
+    setcall p action_code_values_container()
+    if p#!=(NULL);call mem_free(p);endif
+endfunction
+function action_code_values_index()
+    data nr#1
+    return #nr
+endfunction
+#pointer
+function action_code_get()
+    sd nr
+    setcall nr action_code_values_index()
+    sd x
+    set x nr#
+    sv pointer
+    setcall pointer action_code_values()
+    mult x (DWORD)
+    add pointer x
+    return pointer
+endfunction
+
+import "brace_blocks_get_memblock" brace_blocks_get_memblock
+import "block_get_size" block_get_size
+
+import "cond_blocks" cond_blocks
+import "brace_blocks_counter" brace_blocks_counter
+
+function get_nr_of_forIn_statements()
+    sd block;setcall block cond_blocks()
+    sd counter;sd c;setcall c brace_blocks_counter();set counter c#
+    sd nr=0
+    while counter>0
+        dec counter
+        sub block (DWORD)
+        if block#=(brace_blocks_function)
+            return nr
+        elseif block#=(for_marker)
+            inc nr
+        endelseif
+    endwhile
+    return nr
+endfunction
+
+#name/null
+function action_code_write_builtin_names(sv codepointer,sv p_action) #action is value only because is working with stack
+	set codepointer codepointer#
+	sd compare
+	vstr int="int"
+	setcall compare strcmp(codepointer,int)
+	if compare=0
+		set p_action# (ActionToInteger)
+		return int
+	endif
+	vstr rnd="random"
+	setcall compare strcmp(codepointer,rnd)
+	if compare=0
+	#0�(maximum-1)
+		set p_action# (ActionRandomNumber)
+		return rnd
+	endif
+	vstr ascii="ord"
+	setcall compare strcmp(codepointer,ascii)
+	if compare=0
+		set p_action# (ActionCharToAscii)
+		return ascii
+	endif
+	vstr chr="chr"
+	setcall compare strcmp(codepointer,chr)
+	if compare=0
+		set p_action# (ActionAsciiToChar)
+		return chr
+	endif
+	vstr typeOf="typeof"
+	setcall compare strcmp(codepointer,typeOf)
+	if compare=0
+		set p_action# (ActionTypeOf)
+		return typeOf
+	endif
+	vstr stop="stop"
+	setcall compare strcmp(codepointer,stop)
+	if compare=0
+		set p_action# (ActionStop)
+		return stop
+	endif
+	vstr play="play"
+	setcall compare strcmp(codepointer,play)
+	if compare=0
+		set p_action# (ActionPlay)
+		return play
+	endif
+	vstr nframe="nextFrame"
+	setcall compare strcmp(codepointer,nframe)
+	if compare=0
+		set p_action# (ActionNextFrame)
+		return nframe
+	endif
+	vstr pframe="prevFrame"
+	setcall compare strcmp(codepointer,pframe)
+	if compare=0
+		set p_action# (ActionPreviousFrame)
+		return pframe
+	endif
+	vstr goto="gotoAndStop"
+	setcall compare strcmp(codepointer,goto)
+	if compare=0
+		set p_action# (ActionGotoFrame)
+		incst p_action
+		set p_action# (ActionEndFlag)   #even if it's playing, it will stop, no ActionStop here
+		return goto
+	endif
+	vstr gotop="gotoAndPlay"
+	setcall compare strcmp(codepointer,gotop)
+	if compare=0
+		set p_action# (ActionGotoFrame)
+		incst p_action
+		set p_action# (ActionPlay)
+		return gotop
+	endif
+	vstr trace="trace"
+	setcall compare strcmp(codepointer,trace)
+	if compare=0
+		set p_action# (ActionTrace)
+		return trace
+	endif
+	return (NULL)
+endfunction
+
+
+
+aftercallimport ebool
+
+import "debug_phase_code" debug_phase_code
+
+function action_code_values_init()
+    import "memalloc" memalloc
+    sv m
+    setcall m action_code_values_container()
+    setcall m# memalloc((totalvalues*DWORD))
+endfunction
+function action_code_set(sd value)
+	call action_code_set_ex(value,1)
+endfunction
+function action_code_set_pointer(sd value)
+	call action_code_set_ex(value,(:/DWORD))
+endfunction
+function action_code_set_ex(sd value,sd size)
+	sd nr
+	setcall nr action_code_values_index()
+	sd x
+	set x nr#
+	sd to=DWORD
+	mult to x
+	add x size
+	if x>=(totalvalues)
+		import "error" error
+		call error("size error")
+	endif
+	sd pointer
+	setcall pointer action_code_values()
+	add pointer to
+	if size=1
+		set pointer# value
+	else
+		set pointer#v^ value
+	endelse
+	set nr# x
+endfunction
+function forward_values_expand(sv forward,sd data)
+    sd currentnr
+    sd p_currentnr
+    setcall p_currentnr action_code_values_index()
+    set currentnr p_currentnr#
+    sv values
+    setcall values action_code_get()
+    #
+    call forward(values,data)
+    #
+    set p_currentnr# currentnr
+endfunction
+
+
+
+#entries write
+
+import "action_push" action_push
+import "action_one" action_one
+import "action_member_loop" action_member_loop
+import "brace_blocks_add_write" brace_blocks_add_write
+import "brace_blocks_remove_write" brace_blocks_remove_write
+#position
+function action__code_row(sd codepointer)
+	setcall codepointer action__code_row_ex(codepointer)
+	call debug_phase_code(codepointer)
+	return codepointer
+endfunction
+#position
+function action__code_row_ex(sd codepointer)
+    sd pointer
+    set pointer codepointer
+    setcall pointer action_code_write_conditions(codepointer)
+    if pointer!=codepointer
+        return pointer
+    endif
+    setcall pointer action_code_write_function(codepointer)
+    if pointer!=codepointer
+        return pointer
+    endif
+    sd attrib
+    set attrib codepointer#
+    if attrib=(ActionReturn)
+        add codepointer (DWORD)
+        call close_scope_forIn_statements()
+        setcall codepointer action_code_right_util(codepointer)
+        call action_one((ActionReturn))
+        return codepointer
+    elseif attrib=(block_end)
+        add codepointer (DWORD)
+        if codepointer#=(else_flag)
+            call action_code_else_add()
+            add codepointer (DWORD)
+        else
+            call brace_blocks_remove_write()
+        endelse
+        return codepointer
+    elseif attrib=(block_else_end)
+        setcall codepointer action_code_conditions_end(codepointer)
+        return codepointer
+    elseif attrib=(whileblock_end)
+        import "brace_blocks_remove_write_jump" brace_blocks_remove_write_jump
+        call brace_blocks_remove_write_jump()
+        add codepointer (DWORD)
+        return codepointer
+    elseif attrib=(break_flag)
+        call action_code_break()
+        add codepointer (DWORD);return codepointer
+    elseif attrib=(continue_flag)
+        call action_code_continue()
+        add codepointer (DWORD);return codepointer
+    endelseif
+    setcall codepointer action_code_pack(codepointer)
+    return codepointer
+endfunction
+function action_code_pack(sd codepointer)
+    sd attrib
+    set attrib codepointer#
+    add codepointer (DWORD)
+    #
+    sd is_member=FALSE
+    sd need_right=TRUE
+    sd need_pop=FALSE
+    if attrib=(ActionSetMember)
+        set is_member (TRUE)
+    elseif attrib=(ActionDelete)
+        set is_member (TRUE)
+        set need_right (FALSE)
+        set need_pop (TRUE)
+    elseif attrib=(ActionDefineLocal2)
+        set need_right (FALSE)
+    elseif attrib=(ActionDelete2)
+        set need_right (FALSE)
+        set need_pop (TRUE)
+    endelseif
+    #
+    if is_member=(TRUE)
+        setcall codepointer action_member_loop(codepointer,:)   #to pass the pointer
+    else
+    #definelocal or setvariable or delete2
+        call action_push((ap_Constant8),codepointer#v^,-1)
+        add codepointer :  #to pass the pointer
+    endelse
+    if need_right=(TRUE)
+        if codepointer#=(ActionIncrement)
+            add codepointer (DWORD)
+            call action_code_inc_dec((ActionIncrement),attrib)
+        elseif codepointer#=(ActionDecrement)
+            add codepointer (DWORD)
+            call action_code_inc_dec((ActionDecrement),attrib)
+        elseif codepointer#=(mixt_equal)
+            #+= .. ^= ..
+            add codepointer (DWORD)
+            sd mixt_op;set mixt_op codepointer#;add codepointer (DWORD)
+            if attrib=(ActionSetVariable);call action_code_dupGet_var()
+            else;call action_code_dupGet_member();endelse
+            setcall codepointer action_code_right(codepointer)
+            call action_one(mixt_op)
+        else
+            setcall codepointer action_code_right(codepointer)
+        endelse
+    endif
+    call action_one(attrib)
+    if need_pop=(TRUE)
+        call action_one((ActionPop))
+    endif
+    return codepointer
+endfunction
+import "actionrecordheader" actionrecordheader
+import "swf_actionblock_add" swf_actionblock_add
+function action_code_inc_dec(sd inc_dec,sd setvar_or_setmember)
+    if setvar_or_setmember=(ActionSetVariable)
+        call action_code_dupGet_var()
+        call action_one(inc_dec)
+    else
+        call action_code_dupGet_member()
+        call action_one(inc_dec)
+    endelse
+endfunction
+function action_code_dupGet_var()
+    call action_one((ActionPushDuplicate))
+    call action_one((ActionGetVariable))
+endfunction
+function action_code_dupGet_member()
+    sd second_reg=1
+    call actionrecordheader((ActionStoreRegister),1)
+        call swf_actionblock_add(#second_reg,1)
+    call action_one((ActionPop))
+    sd first_reg=0
+    call actionrecordheader((ActionStoreRegister),1)
+        call swf_actionblock_add(#first_reg,1)
+    call action_push((ap_RegisterNumber),second_reg,-1)
+    call action_push((ap_RegisterNumber),first_reg,-1)
+    call action_push((ap_RegisterNumber),second_reg,-1)
+    call action_one((ActionGetMember))
+endfunction
+import "brace_blocks_add_write_current" brace_blocks_add_write_current
+
+import "add_dummy_jump" add_dummy_jump
+import "resolve_dummy_jump" resolve_dummy_jump
+
+#next/same
+function action_code_write_conditions(sd codepointer)
+    #verify for condition tag
+    sd cond;set cond codepointer#
+    if cond=(for_marker)
+        add codepointer (DWORD)
+        if codepointer#!=(for_three)
+            call action_push((ap_Constant8),codepointer#v^,-1);add codepointer :   #to pass the pointer
+            call action_one((ActionEnumerate))
+            #
+            call add_while_top_off((for_marker))
+            #
+            sd first_reg=0
+            call actionrecordheader((ActionStoreRegister),1)
+            call swf_actionblock_add(#first_reg,1)
+            #
+            call action_push((ap_Null),-1)
+            call action_one((ActionEquals2))
+            #write the jump offset
+            call write_ifjump_addTo_braceBlocks()
+            #
+            sd attr2;set attr2 codepointer#;add codepointer (DWORD)
+            #
+            if attr2=(ActionSetMember)
+                setcall codepointer action_member_loop(codepointer,:)  #to pass the pointer
+            else
+                #var or set variable
+                call action_push((ap_Constant8),codepointer#v^,-1)
+                add codepointer :   #to pass the pointer
+            endelse
+            #
+            call action_push((ap_RegisterNumber),first_reg,-1)
+            call action_one(attr2)
+            return codepointer
+        endif
+        add codepointer (DWORD)
+        if codepointer#!=(inter_for);setcall codepointer action_code_pack(codepointer);endif
+        add codepointer (DWORD)
+        #
+        call add_dummy_jump()
+        sd memblock;setcall memblock brace_blocks_get_memblock()
+        sd sizeOff;setcall sizeOff block_get_size(memblock)
+        #
+        call add_while_top_off((while_marker))
+        #
+        if codepointer#!=(inter_for);setcall codepointer action_code_pack(codepointer);endif
+        add codepointer (DWORD)
+        #
+        import "write_forward_offset" write_forward_offset
+        sub sizeOff (WORD)
+        call write_forward_offset(sizeOff)
+    elseif cond=(while_marker)
+        call add_while_top_off((while_marker))
+        add codepointer (DWORD)
+    elseif cond=(ActionIf)
+        add codepointer (DWORD)
+    else
+        return codepointer
+    endelse
+    #using the operations function
+    setcall codepointer action_code_right_util(codepointer)
+    call write_ifjump_withNot()
+    #return the current pointer
+    return codepointer
+endfunction
+function write_ifjump_withNot()
+    #set to be not for entering the block
+    call action_one((ActionNot))
+    #write the jump offset
+    call write_ifjump_addTo_braceBlocks()
+endfunction
+import "brace_blocks_counter_inc" brace_blocks_counter_inc
+function add_while_top_off(sd typeOfLoop)
+    call brace_blocks_add_write_current()
+    sd block
+    setcall block cond_blocks()
+    set block# typeOfLoop
+    call brace_blocks_counter_inc();add block (DWORD)
+    set block# 0
+    call brace_blocks_counter_inc()
+endfunction
+const forIn_ifBreak_size=3+1+1+3+2
+function action_code_break()
+    sd c_block;setcall c_block prepare_space_for_break()
+    sd p_type;set p_type c_block;sub p_type (2*DWORD)
+    if p_type#=(while_marker)
+        call write_jump(0)
+    else
+        call action_push((ap_Null),-1)
+        call action_one((ActionEquals2))
+        call write_ifjump()
+    endelse
+    #
+    sd memblock
+    setcall memblock brace_blocks_get_memblock()
+    setcall c_block# block_get_size(memblock);sub c_block# (WORD)
+    #
+    if p_type#=(for_marker);call write_jump((-2-3-forIn_ifBreak_size));endif
+    #
+    call brace_blocks_counter_inc()
+endfunction
+function remove_forIn_stack()
+    call action_push((ap_Null),-1)
+    call action_one((ActionEquals2))
+    call action_one((ActionNot))
+    call actionrecordheader((ActionIf),2)
+    #minus ActionNot
+    sd sz=-1-forIn_ifBreak_size
+    call swf_actionblock_add(#sz,2)
+endfunction
+function close_scope_forIn_statements()
+    sd nr_of_forIn_statements;setcall nr_of_forIn_statements get_nr_of_forIn_statements()
+    while nr_of_forIn_statements>0
+        call remove_forIn_stack()
+        dec nr_of_forIn_statements
+    endwhile
+endfunction
+function write_jump(sd size)
+    call actionrecordheader((ActionJump),2)
+    call swf_actionblock_add(#size,2)
+endfunction
+#cond_blocks top pointer
+function prepare_space_for_break()
+    sd c_blocks;setcall c_blocks cond_blocks()
+    sd c;setcall c brace_blocks_counter();sd counter;set counter c#
+    sd copy_cursor;set copy_cursor c_blocks
+    while counter>0
+        sub c_blocks (DWORD)
+        if c_blocks#=0
+            add c_blocks (DWORD)
+            sd cursor;set cursor copy_cursor;sub cursor (DWORD)
+            while copy_cursor!=c_blocks
+                set copy_cursor# cursor#
+                sub copy_cursor (DWORD)
+                sub cursor (DWORD)
+            endwhile
+            return c_blocks
+        endif
+        dec counter
+    endwhile
+    call error("it is not the right place for Break")
+endfunction
+function write_ifjump_addTo_braceBlocks()
+    call write_ifjump()
+    call brace_blocks_add_write()
+endfunction
+function write_ifjump()
+    call actionrecordheader((ActionIf),2)
+    data dummyoffset=0
+    call swf_actionblock_add(#dummyoffset,2)
+endfunction
+
+function action_code_continue()
+    sd c_blocks;setcall c_blocks cond_blocks()
+    sd c;setcall c brace_blocks_counter();sd counter;set counter c#
+    while counter>0
+        sub c_blocks (DWORD)
+        if c_blocks#=0
+            #the loop type and to the offset to jump from here
+            sub c_blocks (2*DWORD)
+            sd off_to_jump;set off_to_jump c_blocks#
+            #
+            call add_dummy_jump()
+            call resolve_dummy_jump(off_to_jump)
+            return (void)
+        endif
+        dec counter
+    endwhile
+    call error("Continue without a loop error")
+endfunction
+
+function action_code_else_add()
+    #write dummy jump
+    call actionrecordheader((ActionJump),2)
+    sd dummyjump
+    call swf_actionblock_add(#dummyjump,2)
+    #end previous if
+    call brace_blocks_remove_write()
+    #add current offset
+    call brace_blocks_add_write()
+endfunction
+function action_code_conditions_end(sd codepointer)
+    add codepointer (DWORD)
+    sd number_of_unclosed
+    set number_of_unclosed codepointer#
+    add codepointer (DWORD)
+    while number_of_unclosed>0
+        call brace_blocks_remove_write()
+        dec number_of_unclosed
+    endwhile
+    return codepointer
+endfunction
+
+#codepointer
+function action_code_write_function(sd codepointer)
+	sd pointer
+	setcall pointer action_definefunction(codepointer)
+	if pointer!=codepointer
+		return pointer
+	endif
+	if codepointer#!=(call_action_left)
+		return codepointer
+	endif
+	sd want_return=FALSE
+	setcall codepointer action_code_write_function_call(codepointer,#want_return)
+	if want_return=(FALSE)  #can be modified inside
+		call action_one((ActionPop))
+	endif
+	return codepointer
+endfunction
+
+#codepointer
+function action_code_write_function_call(sv codepointer,sd pwant_return)
+    add codepointer (DWORD)
+    sd pointer
+    setcall pointer action_code_write_builtin_function(codepointer,pwant_return)
+    if pointer!=codepointer
+        return pointer
+    endif
+    sd member
+    set member codepointer#
+    setcall codepointer action_code_new_or_call(codepointer)
+    if member=0
+        call action_one((ActionCallFunction))
+    else
+        call action_one((ActionCallMethod))
+    endelse
+    return codepointer
+endfunction
+#codepointer
+function action_code_write_builtin_function(sv codepointer,sd pwant_return)
+    sv pointer
+    set pointer codepointer
+    if pointer#!=(no_pointer)
+        #no builtin at members
+        return codepointer
+    endif
+    add pointer :  #to pass the pointer
+    #
+    sd cursor
+    setcall cursor action_code_write_builtin_set(pointer,pwant_return)
+    if cursor=pointer
+        return codepointer
+    endif
+    return cursor
+endfunction
+#codepointer
+function action_code_write_builtin_set(sd codepointer,sd pwant_return)
+	ss name
+	#these acts must stay on stack, can be builtin inside builtin
+	sd act
+	sd act2
+	setcall name action_code_write_builtin_names(codepointer,#act)
+	if name!=(NULL)
+		sd test;set test codepointer
+		add test :   #to pass the pointer
+		if test#!=(args_end)
+			if act!=(ActionGotoFrame)
+				if act=(ActionTrace)
+					if pwant_return#=(TRUE)  #same like at gotoAndStop
+						return codepointer
+					endif
+				endif
+				setcall test action_code_right_util(test)
+				if test#=(args_end)
+					call action_one(act)
+					if act=(ActionTrace)
+						set pwant_return# (TRUE)  #to skip pop
+					endif
+					add test (DWORD)
+					return test
+				endif
+				#this is not ok but is lazy and mc overrides are not a must for builtin functions
+				vstr builtin="builtin function expects at most one parameter"
+				call error(builtin)
+			endif
+			#here is another format, if the first is not unsigned 16 then call movie clip function instead of actiongotoframe
+			if test#=(ap_Integer)
+				add test (DWORD)
+				if test#<=^0xffFF #attention at negative numbers, ignoring gotoandstop mc behaviour
+					sd val;set val test#
+					add test (DWORD)
+					if test#=(math_end)
+						add test (DWORD)
+						if test#=(args_end)
+							if pwant_return#=(FALSE)   #can be in a ...=gotoAndStop+... attribution and add extra code there
+								#                      because ActionGotoFrame is not pushing a return value
+								call actionrecordheader(act,(WORD))
+								call swf_actionblock_add(#val,(WORD))
+								set pwant_return# (TRUE)   #no ActionPop required
+								#
+								if act2!=(ActionEndFlag)
+									#ActionPlay
+									call swf_actionblock_add(#act2,(BYTE))
+								endif
+								#
+								add test (DWORD)
+								return test
+							endif
+						endif
+					endif
+				endif
+			endif
+		elseif act<=(ActionStop)  #this is skipping 1,2,3 but there are no actions in the model
+			if pwant_return#=(FALSE)  #same like at gotoAndStop
+				call action_one(act)
+				set pwant_return# (TRUE)  #to skip pop
+				add test (DWORD)
+				return test
+			endif
+		endelseif
+	endif
+	return codepointer
+endfunction
+#codepointer
+function action_code_new_or_call(sv codepointer)
+    sd member
+    set member codepointer#
+    #
+    add codepointer :  #to pass the pointer
+    sd fname
+    set fname codepointer#
+    #
+    import "action_caller" action_caller
+    add codepointer :  #to pass the pointer
+    setcall codepointer action_caller(fname,member,codepointer)
+    return codepointer
+endfunction
+#codepointer
+function action_code_right(sd codepointer)
+    sd pointer
+    setcall pointer action_definefunction(codepointer)
+    if pointer!=codepointer
+        return pointer
+    endif
+    setcall codepointer action_code_right_util(codepointer)
+    return codepointer
+endfunction
+#codepointer
+function action_code_right_util(sd codepointer)
+    if codepointer#=(new_action)
+        add codepointer (DWORD)
+        sd member
+        set member codepointer#v^
+        setcall codepointer action_code_new_or_call(codepointer)
+        if member=0
+            call action_one((ActionNewObject))
+        else
+            call action_one((ActionNewMethod))
+        endelse
+        return codepointer
+    endif
+    sd compare_op_1
+    sd compare_op_2
+    setcall codepointer action_code_right_number(codepointer)
+    while codepointer#!=(math_end)
+        sd operation
+        set operation codepointer#
+        add codepointer (DWORD)
+        if operation=(compare_action)
+            set compare_op_1 codepointer#
+            add codepointer (DWORD)
+            set compare_op_2 codepointer#
+            add codepointer (DWORD)
+        elseif operation=(ifElse_start)
+            call write_ifjump_withNot()
+            setcall codepointer action_code_right_util(codepointer)
+            call action_code_else_add()
+            setcall codepointer action_code_right_util(codepointer)
+            call brace_blocks_remove_write()
+            return codepointer
+        endelseif
+        setcall codepointer action_code_right_number(codepointer)
+        if operation!=(compare_action)
+            call action_one(operation)
+        else
+            call action_one(compare_op_1)
+            if compare_op_2!=0;call action_one(compare_op_2);endif
+        endelse
+    endwhile
+    add codepointer (DWORD)
+    return codepointer
+endfunction
+
+#codepointer
+function action_code_right_number(sd codepointer)
+    if codepointer#=(parenthesis_start)
+        add codepointer (DWORD)
+        setcall codepointer action_code_right_util(codepointer)
+        return codepointer
+    endif
+    if codepointer#=(call_action_right)
+		sd want_return=TRUE
+        setcall codepointer action_code_write_function_call(codepointer,#want_return)
+        return codepointer
+    endif
+    sd attrib
+    set attrib codepointer#
+    add codepointer (DWORD)
+    if attrib=(ActionGetMember)
+        setcall codepointer action_member_loop(codepointer,(get_member))
+    else
+        if attrib=(ActionGetVariable)
+            call action_one_command(codepointer#v^)
+            add codepointer (pointer_rest)
+        elseif attrib=(ap_double)
+            sd low;set low codepointer#;add codepointer (DWORD)
+            call action_push(attrib,low,codepointer#,-1)
+        elseif attrib=(ap_Integer)
+            call action_push(attrib,codepointer#,-1)
+        else
+        #ap_Constant8
+            call action_push(attrib,codepointer#v^,-1)
+            add codepointer (pointer_rest)
+        endelse
+        add codepointer (DWORD)
+    endelse
+    return codepointer
+endfunction
+function action_one_command(ss command)
+    sd compare
+    #
+    setcall compare strcmp("null",command)
+    if compare=0
+        call action_push((ap_Null),-1)
+        return (void)
+    endif
+    setcall compare strcmp("undefined",command)
+    if compare=0
+        call action_push((ap_Undefined),-1)
+        return (void)
+    endif
+    setcall compare strcmp("true",command)
+    if compare=0
+        call action_push((ap_Boolean),1,-1)
+        return (void)
+    endif
+    setcall compare strcmp("false",command)
+    if compare=0
+        call action_push((ap_Boolean),0,-1)
+        return (void)
+    endif
+    call action_get_one(command)
+endfunction
+function action_get_one(ss variable)
+    call action_push((ap_Constant8),variable,-1)
+    call action_one((ActionGetVariable))
+endfunction
+
+#codepointer
+function action_definefunction(sd codepointer)
+    if codepointer#!=(function_action)
+        return codepointer
+    endif
+    add codepointer (DWORD)
+    setcall codepointer action_deffunction(codepointer)
+
+	#all previous codes must pe catched at this phase, this place for this function is tested, example: "function(){" on one row
+	call debug_phase_code(codepointer)
+
+    #a function marker for return and for..in case
+    sd block;setcall block cond_blocks();set block# (brace_blocks_function);call brace_blocks_counter_inc()
+    #
+    call brace_blocks_add_write()
+    #
+    sd index_atstart
+    setcall index_atstart brace_blocks_counter()
+    set index_atstart index_atstart#
+    #
+    sd index_current=0x7fFFffFF
+    while index_atstart<=index_current
+        setcall codepointer action__code_row(codepointer)
+        setcall index_current brace_blocks_counter()
+        set index_current index_current#
+    endwhile
+    #close function marker for return and for..in case
+    import "brace_blocks_counter_dec" brace_blocks_counter_dec
+    call brace_blocks_counter_dec()
+    #
+    return codepointer
+endfunction
+#codepointer
+function action_deffunction(sv codepointer)
+    ss fn_name
+    set fn_name codepointer#
+    add codepointer :  #to pass the pointer
+    sd fn_name_size
+    setcall fn_name_size strlen(fn_name)
+    inc fn_name_size
+    #
+    sd fn_size
+    set fn_size fn_name_size
+    const NumParams_size=2
+    const codeSize_size=2
+    add fn_size (NumParams_size+codeSize_size)
+    #
+    sd NumParams=0
+    sv args
+    set args codepointer
+    while codepointer#!=(no_pointer)
+        addcall fn_size strlen(codepointer#)
+        inc fn_size
+        inc NumParams
+        add codepointer :  #to pass the pointer
+    endwhile
+    add codepointer :  #to pass the pointer
+    #
+    call actionrecordheader((ActionDefineFunction),fn_size)
+    call swf_actionblock_add(fn_name,fn_name_size)
+    call swf_actionblock_add(#NumParams,(NumParams_size))
+    #
+    sd wr_size
+    while args#!=(no_pointer)
+        setcall wr_size strlen(args#)
+        inc wr_size
+        call swf_actionblock_add(args#,wr_size)
+        add args :  #to pass the pointer
+    endwhile
+    #
+    data dummyoffset=0
+    call swf_actionblock_add(#dummyoffset,(WORD))
+    #
+    return codepointer
+endfunction
--- actionswf-1.orig/src/actioncode.s
+++ /dev/null
@@ -1,874 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-#win32 with _
-importx "strcmp" strcmp
-importx "strlen" strlen
-
-const totalvalues=65535
-function action_code_values_container()
-    value setofvalues=NULL
-    return #setofvalues
-endfunction
-function action_code_values()
-    sv m
-    setcall m action_code_values_container()
-    return m#
-endfunction
-
-import "mem_free" mem_free
-
-function action_code_values_free()
-    sv p
-    setcall p action_code_values_container()
-    if p#!=(NULL);call mem_free(p);endif
-endfunction
-function action_code_values_index()
-    data nr#1
-    return #nr
-endfunction
-#pointer
-function action_code_get()
-    sd nr
-    setcall nr action_code_values_index()
-    sd x
-    set x nr#
-    sv pointer
-    setcall pointer action_code_values()
-    mult x (DWORD)
-    add pointer x
-    return pointer
-endfunction
-
-import "brace_blocks_get_memblock" brace_blocks_get_memblock
-import "block_get_size" block_get_size
-
-import "cond_blocks" cond_blocks
-import "brace_blocks_counter" brace_blocks_counter
-
-function get_nr_of_forIn_statements()
-    sd block;setcall block cond_blocks()
-    sd counter;sd c;setcall c brace_blocks_counter();set counter c#
-    sd nr=0
-    while counter>0
-        dec counter
-        sub block (DWORD)
-        if block#=(brace_blocks_function)
-            return nr
-        elseif block#=(for_marker)
-            inc nr
-        endelseif
-    endwhile
-    return nr
-endfunction
-
-#name/null
-function action_code_write_builtin_names(sv codepointer,sv p_action)
-	set codepointer codepointer#
-	sd compare
-	vstr int="int"
-	setcall compare strcmp(codepointer,int)
-	if compare=0
-		set p_action# (ActionToInteger)
-		return int
-	endif
-	vstr rnd="random"
-	setcall compare strcmp(codepointer,rnd)
-	if compare=0
-	#0�(maximum-1)
-		set p_action# (ActionRandomNumber)
-		return rnd
-	endif
-	vstr ascii="ord"
-	setcall compare strcmp(codepointer,ascii)
-	if compare=0
-		set p_action# (ActionCharToAscii)
-		return ascii
-	endif
-	vstr chr="chr"
-	setcall compare strcmp(codepointer,chr)
-	if compare=0
-		set p_action# (ActionAsciiToChar)
-		return chr
-	endif
-	vstr typeOf="typeof"
-	setcall compare strcmp(codepointer,typeOf)
-	if compare=0
-		set p_action# (ActionTypeOf)
-		return typeOf
-	endif
-	vstr stop="stop"
-	setcall compare strcmp(codepointer,stop)
-	if compare=0
-		set p_action# (ActionStop)
-		return stop
-	endif
-	vstr play="play"
-	setcall compare strcmp(codepointer,play)
-	if compare=0
-		set p_action# (ActionPlay)
-		return play
-	endif
-	vstr nframe="nextFrame"
-	setcall compare strcmp(codepointer,nframe)
-	if compare=0
-		set p_action# (ActionNextFrame)
-		return nframe
-	endif
-	vstr pframe="prevFrame"
-	setcall compare strcmp(codepointer,pframe)
-	if compare=0
-		set p_action# (ActionPreviousFrame)
-		return pframe
-	endif
-	vstr goto="gotoAndStop"
-	setcall compare strcmp(codepointer,goto)
-	if compare=0
-		set p_action# (ActionGotoFrame)
-		inc p_action
-		set p_action# (ActionEndFlag)   #even if it's playing, it will stop, no ActionStop here
-		return goto
-	endif
-	vstr gotop="gotoAndPlay"
-	setcall compare strcmp(codepointer,gotop)
-	if compare=0
-		set p_action# (ActionGotoFrame)
-		inc p_action
-		set p_action# (ActionPlay)
-		return gotop
-	endif
-	vstr trace="trace"
-	setcall compare strcmp(codepointer,trace)
-	if compare=0
-		set p_action# (ActionTrace)
-		return trace
-	endif
-	return (NULL)
-endfunction
-
-
-
-importaftercall ebool
-
-import "debug_phase_code" debug_phase_code
-
-function action_code_values_init()
-    import "memalloc" memalloc
-    sv m
-    setcall m action_code_values_container()
-    setcall m# memalloc((totalvalues*DWORD))
-endfunction
-function action_code_set(sd value)
-	call action_code_set_ex(value,1)
-endfunction
-function action_code_set_pointer(sd value)
-	call action_code_set_ex(value,(:/DWORD))
-endfunction
-function action_code_set_ex(sd value,sd size)
-	sd nr
-	setcall nr action_code_values_index()
-	sd x
-	set x nr#
-	sd to=DWORD
-	mult to x
-	add x size
-	if x>=(totalvalues)
-		import "error" error
-		call error("size error")
-	endif
-	sd pointer
-	setcall pointer action_code_values()
-	add pointer to
-	if size=1
-		set pointer# value
-	else
-		set pointer#v^ value
-	endelse
-	set nr# x
-endfunction
-function forward_values_expand(sd forward,sd data)
-    sd currentnr
-    sd p_currentnr
-    setcall p_currentnr action_code_values_index()
-    set currentnr p_currentnr#
-    sv values
-    setcall values action_code_get()
-    #
-    call forward(values,data)
-    #
-    set p_currentnr# currentnr
-endfunction
-
-
-
-#entries write
-
-import "action_push" action_push
-import "action_one" action_one
-import "action_member_loop" action_member_loop
-import "brace_blocks_add_write" brace_blocks_add_write
-import "brace_blocks_remove_write" brace_blocks_remove_write
-#position
-function action__code_row(sd codepointer)
-	setcall codepointer action__code_row_ex(codepointer)
-	call debug_phase_code(codepointer)
-	return codepointer
-endfunction
-#position
-function action__code_row_ex(sd codepointer)
-    sd pointer
-    set pointer codepointer
-    setcall pointer action_code_write_conditions(codepointer)
-    if pointer!=codepointer
-        return pointer
-    endif
-    setcall pointer action_code_write_function(codepointer)
-    if pointer!=codepointer
-        return pointer
-    endif
-    sd attrib
-    set attrib codepointer#
-    if attrib=(ActionReturn)
-        add codepointer (DWORD)
-        call close_scope_forIn_statements()
-        setcall codepointer action_code_right_util(codepointer)
-        call action_one((ActionReturn))
-        return codepointer
-    elseif attrib=(block_end)
-        add codepointer (DWORD)
-        if codepointer#=(else_flag)
-            call action_code_else_add()
-            add codepointer (DWORD)
-        else
-            call brace_blocks_remove_write()
-        endelse
-        return codepointer
-    elseif attrib=(block_else_end)
-        setcall codepointer action_code_conditions_end(codepointer)
-        return codepointer
-    elseif attrib=(whileblock_end)
-        import "brace_blocks_remove_write_jump" brace_blocks_remove_write_jump
-        call brace_blocks_remove_write_jump()
-        add codepointer (DWORD)
-        return codepointer
-    elseif attrib=(break_flag)
-        call action_code_break()
-        add codepointer (DWORD);return codepointer
-    elseif attrib=(continue_flag)
-        call action_code_continue()
-        add codepointer (DWORD);return codepointer
-    endelseif
-    setcall codepointer action_code_pack(codepointer)
-    return codepointer
-endfunction
-function action_code_pack(sd codepointer)
-    sd attrib
-    set attrib codepointer#
-    add codepointer (DWORD)
-    #
-    sd is_member=FALSE
-    sd need_right=TRUE
-    sd need_pop=FALSE
-    if attrib=(ActionSetMember)
-        set is_member (TRUE)
-    elseif attrib=(ActionDelete)
-        set is_member (TRUE)
-        set need_right (FALSE)
-        set need_pop (TRUE)
-    elseif attrib=(ActionDefineLocal2)
-        set need_right (FALSE)
-    elseif attrib=(ActionDelete2)
-        set need_right (FALSE)
-        set need_pop (TRUE)
-    endelseif
-    #
-    if is_member=(TRUE)
-        setcall codepointer action_member_loop(codepointer,:)   #to pass the pointer
-    else
-    #definelocal or setvariable or delete2
-        call action_push((ap_Constant8),codepointer#v^,-1)
-        add codepointer :  #to pass the pointer
-    endelse
-    if need_right=(TRUE)
-        if codepointer#=(ActionIncrement)
-            add codepointer (DWORD)
-            call action_code_inc_dec((ActionIncrement),attrib)
-        elseif codepointer#=(ActionDecrement)
-            add codepointer (DWORD)
-            call action_code_inc_dec((ActionDecrement),attrib)
-        elseif codepointer#=(mixt_equal)
-            #+= .. ^= ..
-            add codepointer (DWORD)
-            sd mixt_op;set mixt_op codepointer#;add codepointer (DWORD)
-            if attrib=(ActionSetVariable);call action_code_dupGet_var()
-            else;call action_code_dupGet_member();endelse
-            setcall codepointer action_code_right(codepointer)
-            call action_one(mixt_op)
-        else
-            setcall codepointer action_code_right(codepointer)
-        endelse
-    endif
-    call action_one(attrib)
-    if need_pop=(TRUE)
-        call action_one((ActionPop))
-    endif
-    return codepointer
-endfunction
-import "actionrecordheader" actionrecordheader
-import "swf_actionblock_add" swf_actionblock_add
-function action_code_inc_dec(sd inc_dec,sd setvar_or_setmember)
-    if setvar_or_setmember=(ActionSetVariable)
-        call action_code_dupGet_var()
-        call action_one(inc_dec)
-    else
-        call action_code_dupGet_member()
-        call action_one(inc_dec)
-    endelse
-endfunction
-function action_code_dupGet_var()
-    call action_one((ActionPushDuplicate))
-    call action_one((ActionGetVariable))
-endfunction
-function action_code_dupGet_member()
-    sd second_reg=1
-    call actionrecordheader((ActionStoreRegister),1)
-        call swf_actionblock_add(#second_reg,1)
-    call action_one((ActionPop))
-    sd first_reg=0
-    call actionrecordheader((ActionStoreRegister),1)
-        call swf_actionblock_add(#first_reg,1)
-    call action_push((ap_RegisterNumber),second_reg,-1)
-    call action_push((ap_RegisterNumber),first_reg,-1)
-    call action_push((ap_RegisterNumber),second_reg,-1)
-    call action_one((ActionGetMember))
-endfunction
-import "brace_blocks_add_write_current" brace_blocks_add_write_current
-
-import "add_dummy_jump" add_dummy_jump
-import "resolve_dummy_jump" resolve_dummy_jump
-
-#next/same
-function action_code_write_conditions(sd codepointer)
-    #verify for condition tag
-    sd cond;set cond codepointer#
-    if cond=(for_marker)
-        add codepointer (DWORD)
-        if codepointer#!=(for_three)
-            call action_push((ap_Constant8),codepointer#v^,-1);add codepointer :   #to pass the pointer
-            call action_one((ActionEnumerate))
-            #
-            call add_while_top_off((for_marker))
-            #
-            sd first_reg=0
-            call actionrecordheader((ActionStoreRegister),1)
-            call swf_actionblock_add(#first_reg,1)
-            #
-            call action_push((ap_Null),-1)
-            call action_one((ActionEquals2))
-            #write the jump offset
-            call write_ifjump_addTo_braceBlocks()
-            #
-            sd attr2;set attr2 codepointer#;add codepointer (DWORD)
-            #
-            if attr2=(ActionSetMember)
-                setcall codepointer action_member_loop(codepointer,:)  #to pass the pointer
-            else
-                #var or set variable
-                call action_push((ap_Constant8),codepointer#v^,-1)
-                add codepointer :   #to pass the pointer
-            endelse
-            #
-            call action_push((ap_RegisterNumber),first_reg,-1)
-            call action_one(attr2)
-            return codepointer
-        endif
-        add codepointer (DWORD)
-        if codepointer#!=(inter_for);setcall codepointer action_code_pack(codepointer);endif
-        add codepointer (DWORD)
-        #
-        call add_dummy_jump()
-        sd memblock;setcall memblock brace_blocks_get_memblock()
-        sd sizeOff;setcall sizeOff block_get_size(memblock)
-        #
-        call add_while_top_off((while_marker))
-        #
-        if codepointer#!=(inter_for);setcall codepointer action_code_pack(codepointer);endif
-        add codepointer (DWORD)
-        #
-        import "write_forward_offset" write_forward_offset
-        sub sizeOff (WORD)
-        call write_forward_offset(sizeOff)
-    elseif cond=(while_marker)
-        call add_while_top_off((while_marker))
-        add codepointer (DWORD)
-    elseif cond=(ActionIf)
-        add codepointer (DWORD)
-    else
-        return codepointer
-    endelse
-    #using the operations function
-    setcall codepointer action_code_right_util(codepointer)
-    call write_ifjump_withNot()
-    #return the current pointer
-    return codepointer
-endfunction
-function write_ifjump_withNot()
-    #set to be not for entering the block
-    call action_one((ActionNot))
-    #write the jump offset
-    call write_ifjump_addTo_braceBlocks()
-endfunction
-import "brace_blocks_counter_inc" brace_blocks_counter_inc
-function add_while_top_off(sd typeOfLoop)
-    call brace_blocks_add_write_current()
-    sd block
-    setcall block cond_blocks()
-    set block# typeOfLoop
-    call brace_blocks_counter_inc();add block (DWORD)
-    set block# 0
-    call brace_blocks_counter_inc()
-endfunction
-const forIn_ifBreak_size=3+1+1+3+2
-function action_code_break()
-    sd c_block;setcall c_block prepare_space_for_break()
-    sd p_type;set p_type c_block;sub p_type (2*DWORD)
-    if p_type#=(while_marker)
-        call write_jump(0)
-    else
-        call action_push((ap_Null),-1)
-        call action_one((ActionEquals2))
-        call write_ifjump()
-    endelse
-    #
-    sd memblock
-    setcall memblock brace_blocks_get_memblock()
-    setcall c_block# block_get_size(memblock);sub c_block# (WORD)
-    #
-    if p_type#=(for_marker);call write_jump((-2-3-forIn_ifBreak_size));endif
-    #
-    call brace_blocks_counter_inc()
-endfunction
-function remove_forIn_stack()
-    call action_push((ap_Null),-1)
-    call action_one((ActionEquals2))
-    call action_one((ActionNot))
-    call actionrecordheader((ActionIf),2)
-    #minus ActionNot
-    sd sz=-1-forIn_ifBreak_size
-    call swf_actionblock_add(#sz,2)
-endfunction
-function close_scope_forIn_statements()
-    sd nr_of_forIn_statements;setcall nr_of_forIn_statements get_nr_of_forIn_statements()
-    while nr_of_forIn_statements>0
-        call remove_forIn_stack()
-        dec nr_of_forIn_statements
-    endwhile
-endfunction
-function write_jump(sd size)
-    call actionrecordheader((ActionJump),2)
-    call swf_actionblock_add(#size,2)
-endfunction
-#cond_blocks top pointer
-function prepare_space_for_break()
-    sd c_blocks;setcall c_blocks cond_blocks()
-    sd c;setcall c brace_blocks_counter();sd counter;set counter c#
-    sd copy_cursor;set copy_cursor c_blocks
-    while counter>0
-        sub c_blocks (DWORD)
-        if c_blocks#=0
-            add c_blocks (DWORD)
-            sd cursor;set cursor copy_cursor;sub cursor (DWORD)
-            while copy_cursor!=c_blocks
-                set copy_cursor# cursor#
-                sub copy_cursor (DWORD)
-                sub cursor (DWORD)
-            endwhile
-            return c_blocks
-        endif
-        dec counter
-    endwhile
-    call error("it is not the right place for Break")
-endfunction
-function write_ifjump_addTo_braceBlocks()
-    call write_ifjump()
-    call brace_blocks_add_write()
-endfunction
-function write_ifjump()
-    call actionrecordheader((ActionIf),2)
-    data dummyoffset=0
-    call swf_actionblock_add(#dummyoffset,2)
-endfunction
-
-function action_code_continue()
-    sd c_blocks;setcall c_blocks cond_blocks()
-    sd c;setcall c brace_blocks_counter();sd counter;set counter c#
-    while counter>0
-        sub c_blocks (DWORD)
-        if c_blocks#=0
-            #the loop type and to the offset to jump from here
-            sub c_blocks (2*DWORD)
-            sd off_to_jump;set off_to_jump c_blocks#
-            #
-            call add_dummy_jump()
-            call resolve_dummy_jump(off_to_jump)
-            return (void)
-        endif
-        dec counter
-    endwhile
-    call error("Continue without a loop error")
-endfunction
-
-function action_code_else_add()
-    #write dummy jump
-    call actionrecordheader((ActionJump),2)
-    sd dummyjump
-    call swf_actionblock_add(#dummyjump,2)
-    #end previous if
-    call brace_blocks_remove_write()
-    #add current offset
-    call brace_blocks_add_write()
-endfunction
-function action_code_conditions_end(sd codepointer)
-    add codepointer (DWORD)
-    sd number_of_unclosed
-    set number_of_unclosed codepointer#
-    add codepointer (DWORD)
-    while number_of_unclosed>0
-        call brace_blocks_remove_write()
-        dec number_of_unclosed
-    endwhile
-    return codepointer
-endfunction
-
-#codepointer
-function action_code_write_function(sd codepointer)
-	sd pointer
-	setcall pointer action_definefunction(codepointer)
-	if pointer!=codepointer
-		return pointer
-	endif
-	if codepointer#!=(call_action_left)
-		return codepointer
-	endif
-	sd want_return=FALSE
-	setcall codepointer action_code_write_function_call(codepointer,#want_return)
-	if want_return=(FALSE)  #can be modified inside
-		call action_one((ActionPop))
-	endif
-	return codepointer
-endfunction
-
-#codepointer
-function action_code_write_function_call(sv codepointer,sd pwant_return)
-    add codepointer (DWORD)
-    sd pointer
-    setcall pointer action_code_write_builtin_function(codepointer,pwant_return)
-    if pointer!=codepointer
-        return pointer
-    endif
-    sd member
-    set member codepointer#
-    setcall codepointer action_code_new_or_call(codepointer)
-    if member=0
-        call action_one((ActionCallFunction))
-    else
-        call action_one((ActionCallMethod))
-    endelse
-    return codepointer
-endfunction
-#codepointer
-function action_code_write_builtin_function(sv codepointer,sd pwant_return)
-    sv pointer
-    set pointer codepointer
-    if pointer#!=(no_pointer)
-        #no builtin at members
-        return codepointer
-    endif
-    add pointer :  #to pass the pointer
-    #
-    sd cursor
-    setcall cursor action_code_write_builtin_set(pointer,pwant_return)
-    if cursor=pointer
-        return codepointer
-    endif
-    return cursor
-endfunction
-#codepointer
-function action_code_write_builtin_set(sd codepointer,sd pwant_return)
-	ss name
-	#these acts must stay on stack, can be builtin inside builtin
-	sd act
-	sd act2
-	setcall name action_code_write_builtin_names(codepointer,#act)
-	if name!=(NULL)
-		sd test;set test codepointer
-		add test :   #to pass the pointer
-		if test#!=(args_end)
-			if act!=(ActionGotoFrame)
-				if act=(ActionTrace)
-					if pwant_return#=(TRUE)  #same like at gotoAndStop
-						return codepointer
-					endif
-				endif
-				setcall test action_code_right_util(test)
-				if test#=(args_end)
-					call action_one(act)
-					if act=(ActionTrace)
-						set pwant_return# (TRUE)  #to skip pop
-					endif
-					add test (DWORD)
-					return test
-				endif
-				#this is not ok but is lazy and mc overrides are not a must for builtin functions
-				vstr builtin="builtin function expects at most one parameter"
-				call error(builtin)
-			endif
-			#here is another format, if the first is not unsigned 16 then call movie clip function instead of actiongotoframe
-			if test#=(ap_Integer)
-				add test (DWORD)
-				if test#<=^0xffFF #attention at negative numbers, ignoring gotoandstop mc behaviour
-					sd val;set val test#
-					add test (DWORD)
-					if test#=(math_end)
-						add test (DWORD)
-						if test#=(args_end)
-							if pwant_return#=(FALSE)   #can be in a ...=gotoAndStop+... attribution and add extra code there
-								#                      because ActionGotoFrame is not pushing a return value
-								call actionrecordheader(act,(WORD))
-								call swf_actionblock_add(#val,(WORD))
-								set pwant_return# (TRUE)   #no ActionPop required
-								#
-								if act2!=(ActionEndFlag)
-									#ActionPlay
-									call swf_actionblock_add(#act2,(BYTE))
-								endif
-								#
-								add test (DWORD)
-								return test
-							endif
-						endif
-					endif
-				endif
-			endif
-		elseif act<=(ActionStop)  #this is skipping 1,2,3 but there are no actions in the model
-			if pwant_return#=(FALSE)  #same like at gotoAndStop
-				call action_one(act)
-				set pwant_return# (TRUE)  #to skip pop
-				add test (DWORD)
-				return test
-			endif
-		endelseif
-	endif
-	return codepointer
-endfunction
-#codepointer
-function action_code_new_or_call(sv codepointer)
-    sd member
-    set member codepointer#
-    #
-    add codepointer :  #to pass the pointer
-    sd fname
-    set fname codepointer#
-    #
-    import "action_caller" action_caller
-    add codepointer :  #to pass the pointer
-    setcall codepointer action_caller(fname,member,codepointer)
-    return codepointer
-endfunction
-#codepointer
-function action_code_right(sd codepointer)
-    sd pointer
-    setcall pointer action_definefunction(codepointer)
-    if pointer!=codepointer
-        return pointer
-    endif
-    setcall codepointer action_code_right_util(codepointer)
-    return codepointer
-endfunction
-#codepointer
-function action_code_right_util(sd codepointer)
-    if codepointer#=(new_action)
-        add codepointer (DWORD)
-        sd member
-        set member codepointer#v^
-        setcall codepointer action_code_new_or_call(codepointer)
-        if member=0
-            call action_one((ActionNewObject))
-        else
-            call action_one((ActionNewMethod))
-        endelse
-        return codepointer
-    endif
-    sd compare_op_1
-    sd compare_op_2
-    setcall codepointer action_code_right_number(codepointer)
-    while codepointer#!=(math_end)
-        sd operation
-        set operation codepointer#
-        add codepointer (DWORD)
-        if operation=(compare_action)
-            set compare_op_1 codepointer#
-            add codepointer (DWORD)
-            set compare_op_2 codepointer#
-            add codepointer (DWORD)
-        elseif operation=(ifElse_start)
-            call write_ifjump_withNot()
-            setcall codepointer action_code_right_util(codepointer)
-            call action_code_else_add()
-            setcall codepointer action_code_right_util(codepointer)
-            call brace_blocks_remove_write()
-            return codepointer
-        endelseif
-        setcall codepointer action_code_right_number(codepointer)
-        if operation!=(compare_action)
-            call action_one(operation)
-        else
-            call action_one(compare_op_1)
-            if compare_op_2!=0;call action_one(compare_op_2);endif
-        endelse
-    endwhile
-    add codepointer (DWORD)
-    return codepointer
-endfunction
-
-#codepointer
-function action_code_right_number(sd codepointer)
-    if codepointer#=(parenthesis_start)
-        add codepointer (DWORD)
-        setcall codepointer action_code_right_util(codepointer)
-        return codepointer
-    endif
-    if codepointer#=(call_action_right)
-		sd want_return=TRUE
-        setcall codepointer action_code_write_function_call(codepointer,#want_return)
-        return codepointer
-    endif
-    sd attrib
-    set attrib codepointer#
-    add codepointer (DWORD)
-    if attrib=(ActionGetMember)
-        setcall codepointer action_member_loop(codepointer,(get_member))
-    else
-        if attrib=(ActionGetVariable)
-            call action_one_command(codepointer#v^)
-            add codepointer (pointer_rest)
-        elseif attrib=(ap_double)
-            sd low;set low codepointer#;add codepointer (DWORD)
-            call action_push(attrib,low,codepointer#,-1)
-        elseif attrib=(ap_Integer)
-            call action_push(attrib,codepointer#,-1)
-        else
-        #ap_Constant8
-            call action_push(attrib,codepointer#v^,-1)
-            add codepointer (pointer_rest)
-        endelse
-        add codepointer (DWORD)
-    endelse
-    return codepointer
-endfunction
-function action_one_command(ss command)
-    sd compare
-    #
-    setcall compare strcmp("null",command)
-    if compare=0
-        call action_push((ap_Null),-1)
-        return (void)
-    endif
-    setcall compare strcmp("undefined",command)
-    if compare=0
-        call action_push((ap_Undefined),-1)
-        return (void)
-    endif
-    setcall compare strcmp("true",command)
-    if compare=0
-        call action_push((ap_Boolean),1,-1)
-        return (void)
-    endif
-    setcall compare strcmp("false",command)
-    if compare=0
-        call action_push((ap_Boolean),0,-1)
-        return (void)
-    endif
-    call action_get_one(command)
-endfunction
-function action_get_one(ss variable)
-    call action_push((ap_Constant8),variable,-1)
-    call action_one((ActionGetVariable))
-endfunction
-
-#codepointer
-function action_definefunction(sd codepointer)
-    if codepointer#!=(function_action)
-        return codepointer
-    endif
-    add codepointer (DWORD)
-    setcall codepointer action_deffunction(codepointer)
-
-	#all previous codes must pe catched at this phase, this place for this function is tested, example: "function(){" on one row
-	call debug_phase_code(codepointer)
-
-    #a function marker for return and for..in case
-    sd block;setcall block cond_blocks();set block# (brace_blocks_function);call brace_blocks_counter_inc()
-    #
-    call brace_blocks_add_write()
-    #
-    sd index_atstart
-    setcall index_atstart brace_blocks_counter()
-    set index_atstart index_atstart#
-    #
-    sd index_current=0x7fFFffFF
-    while index_atstart<=index_current
-        setcall codepointer action__code_row(codepointer)
-        setcall index_current brace_blocks_counter()
-        set index_current index_current#
-    endwhile
-    #close function marker for return and for..in case
-    import "brace_blocks_counter_dec" brace_blocks_counter_dec
-    call brace_blocks_counter_dec()
-    #
-    return codepointer
-endfunction
-#codepointer
-function action_deffunction(sv codepointer)
-    ss fn_name
-    set fn_name codepointer#
-    add codepointer :  #to pass the pointer
-    sd fn_name_size
-    setcall fn_name_size strlen(fn_name)
-    inc fn_name_size
-    #
-    sd fn_size
-    set fn_size fn_name_size
-    const NumParams_size=2
-    const codeSize_size=2
-    add fn_size (NumParams_size+codeSize_size)
-    #
-    sd NumParams=0
-    sv args
-    set args codepointer
-    while codepointer#!=(no_pointer)
-        addcall fn_size strlen(codepointer#)
-        inc fn_size
-        inc NumParams
-        add codepointer :  #to pass the pointer
-    endwhile
-    add codepointer :  #to pass the pointer
-    #
-    call actionrecordheader((ActionDefineFunction),fn_size)
-    call swf_actionblock_add(fn_name,fn_name_size)
-    call swf_actionblock_add(#NumParams,(NumParams_size))
-    #
-    sd wr_size
-    while args#!=(no_pointer)
-        setcall wr_size strlen(args#)
-        inc wr_size
-        call swf_actionblock_add(args#,wr_size)
-        add args :  #to pass the pointer
-    endwhile
-    #
-    data dummyoffset=0
-    call swf_actionblock_add(#dummyoffset,(WORD))
-    #
-    return codepointer
-endfunction
--- /dev/null
+++ actionswf-1/src/actionparse.oc
@@ -0,0 +1,1305 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+#win32 with _
+importx "strcspn" strcspn
+importx "strchr" strchr
+importx "memcpy" memcpy
+importx "sscanf" sscanf
+importx "strpbrk" strpbrk
+
+import "str_next" str_next
+import "str_expression_at_start" str_expression_at_start
+
+import "debug_code" debug_code
+import "spaces" spaces
+
+import "str_expression_at_start_withEndCare" str_expression_at_start_withEndCare
+
+#operations str
+function get_operations()
+    const operations_begin=\
+    char operations="+-*/%&|^<>?"
+    #subtract 1 is for the string termination
+    const operations_size=\-operations_begin-1
+    return #operations
+endfunction
+
+#bool
+function action_parse_utilEndTypes(sd op,sv p_op,sd endtype1,sd endtype2)  #p_op is pointing at a stack variable
+    #when p_op is set, is to store the multiple kind of endtypes
+    if p_op!=0
+        set p_op# op
+        if op=endtype2
+            return (TRUE)
+        endif
+    endif
+    if op=endtype1;return (TRUE);endif
+    return (FALSE)
+endfunction
+
+import "is_numeric" is_numeric
+
+#strpbrk
+function action_code_membersplit(ss ac)
+    char delims=".["
+    ss next
+    setcall next strpbrk(ac,#delims)
+    return next
+endfunction
+
+#str
+function compares_signs()
+    return "<>=!"
+endfunction
+function compare_bool_pointer()
+    data compare_bool=FALSE;return #compare_bool
+endfunction
+
+const cond_block_size=DWORD
+const brace_blocks_max=100*cond_block_size
+function brace_blocks_counter()
+    data counter#1
+    return #counter
+endfunction
+function brace_blocks_counter_init()
+    sd c
+    setcall c brace_blocks_counter()
+    set c# 0
+endfunction
+
+function cond_blocks()
+    sd p_i
+    setcall p_i brace_blocks_counter()
+    sd blocks
+    setcall blocks cond_blocks_at_index(p_i#)
+    return blocks
+endfunction
+function cond_blocks_at_index(sd i)
+    data blocks_mem#brace_blocks_max
+    sd blocks^blocks_mem
+    #
+    mult i (cond_block_size)
+    add blocks i
+    return blocks
+endfunction
+
+import "swf_actionblock" swf_actionblock
+function brace_blocks_get_memblock()
+    sd memblock
+    setcall memblock swf_actionblock((mem_exp_get_block))
+    return memblock
+endfunction
+
+import "action_code_get" action_code_get
+import "action_code_values_index" action_code_values_index
+
+
+
+
+
+aftercallimport ebool
+
+import "action_code_set" action_code_set
+import "action_code_set_pointer" action_code_set_pointer
+import "error" error
+const add=Plus
+const sub=Hyphen
+const mlt=Asterisk
+const div=Slash
+const modulo=Percent
+const and=Ampersand
+const or=Verticalbar
+const xor=Caret
+const shl=Lessthan
+const sar_shr=Greaterthan
+const ifElse_sign=Questionmark
+#pointer
+function action_code_row(ss ac,sd a_block_detected)
+	setcall ac action_code_row_ex(ac,a_block_detected,-1)
+    return ac
+endfunction
+#pointer
+function action_code_row_ex(ss ac,sd a_block_detected,sd else_index)
+    sv p_c
+    setcall p_c debug_code()
+    set p_c# ac
+    ss atstart=NULL
+    while atstart!=ac
+        sd flags
+        sd for_detected=0
+        set atstart ac
+        setcall ac action_parse_conditions(ac,#flags,#for_detected)
+        if atstart!=ac
+            if for_detected=0
+                if ac#!=(Openparenthesis)
+                    call error("open parenthesis sign expected")
+                endif
+                #using the operations function
+                inc ac
+                char closecompare=")"
+                setcall ac action_code_row_parse_tool(ac,closecompare)
+                #if ac#!=closecompare
+                #    call error("close parenthesis expected")
+                #endif
+            endif
+            #important settings
+            if a_block_detected=(TRUE)
+                or flags (consecutive_flag)
+            endif
+            call brace_blocks_add_parse(flags)
+            set a_block_detected (TRUE)
+        endif
+    endwhile
+    setcall ac action_code_row_parse(ac,a_block_detected,else_index)
+	import "debug_phase_parse" debug_phase_parse
+	#around: else if(2==2){return 2;}else{return 3;}, 4 breakpoints, with \n-s,this here and not at action_code_row,1 breakpoint
+	call debug_phase_parse(ac)
+    return ac
+endfunction
+#pointer
+function action_parse_conditions(ss ac,sd p_flags,sd p_for_detected)
+    #if
+    ss pointer
+    setcall pointer str_expression_at_start(ac,"if")
+    if pointer!=ac
+        set p_flags# (if_marker)
+        call action_code_set((ActionIf))
+        return pointer
+    endif
+    #while
+    setcall pointer str_expression_at_start(ac,"while")
+    if pointer!=ac
+        call action_code_set((while_marker))
+        set p_flags# (while_marker)
+        return pointer
+    else
+    #for
+        setcall pointer str_expression_at_start(ac,"for")
+        if pointer=ac;return pointer;endif
+        #
+        call action_code_set((for_marker))
+        set p_flags# (while_marker)
+        set p_for_detected# 1
+        #
+        if pointer#!=(Openparenthesis)
+            call error("expecting Open Parenthesis at for loop")
+        endif
+        inc pointer
+        set ac pointer
+        #
+        ss cursor;ss marker
+        #forIn or for x;x;x
+        sd pos1;setcall pos1 strcspn(pointer,")")
+        sd pos2;setcall pos2 strcspn(pointer,";")
+        if pos2<pos1
+            #for x;x;x
+            call action_code_set((for_three))
+            #ac X;x;x
+            set cursor pointer;add cursor pos2
+            if cursor#=0
+                call error("expecting ';' at for loop, first part")
+            endif
+                            #is for for(;x;x) the !=
+            if cursor!=ac;call action_parse_pack(ac,(Semicolon));endif
+                            #is for for(;x;x)
+            call action_code_set((inter_for))
+            inc cursor
+            #pointer x;X;x
+            set pointer cursor
+            setcall pos2 strcspn(pointer,";")
+            add cursor pos2
+            if cursor#=0
+                call error("expecting ';' at for loop, second part")
+            endif
+            #cursor x;x;X
+            inc cursor
+            #not let for(x;x;heatMaker), heatMaker will be ignored and violation will come
+            if cursor#!=(Closeparenthesis);setcall cursor action_parse_pack(cursor,(Closeparenthesis))
+            else;inc cursor;endelse
+            call action_code_set((inter_for))
+            call action_code_row_parse_tool(pointer,(Semicolon))
+            return cursor
+        endif
+        #
+        setcall pointer str_expression_at_start(pointer,"var")
+        setcall pos1 strcspn(pointer," ")
+        set cursor pointer;add cursor pos1
+        if cursor#=0
+            call error("expecting 'space' at for loop")
+        endif
+        set cursor# 0
+        inc cursor;setcall cursor spaces(cursor)
+        setcall marker str_expression_at_start(cursor,"in")
+        if marker=cursor
+            call error("expecting 'in' at for loop")
+        endif
+        setcall pos1 strcspn(marker,")")
+        set cursor marker
+        add cursor pos1
+        if cursor#=0
+            call error("expecting Close Parenthesis at for loop")
+        endif
+        set cursor# 0
+        #
+        #enum can take ActionEnumerate(x.x[z])
+        call action_code_set_pointer(marker)
+        #
+        if pointer!=ac
+            call action_code_set((ActionDefineLocal))
+            call action_code_set_pointer(pointer)
+        else
+            call action_parse_left_holder(pointer,(ActionSetVariable),(ActionSetMember))
+        endelse
+        inc cursor
+        return cursor
+    endelse
+endfunction
+#pointer
+function action_code_row_parse(ss ac,sd a_block_detected,sd else_index)
+    if ac#=(Openingbrace)
+        if a_block_detected=(FALSE)
+            call brace_blocks_add_parse((normal_marker))
+        endif
+        inc ac
+        return ac
+    elseif ac#=(Closingbrace)
+        if a_block_detected=(TRUE)
+            call error("unexpected closing brace sign after code block opened")
+        endif
+        inc ac
+        setcall ac else_verify(ac,else_index)
+        return ac
+    endelseif
+    setcall ac action_code_row_parse_instrument(ac)
+    if a_block_detected=(TRUE)
+    #ex: if(a==b)x=3;
+        setcall ac else_verify(ac,else_index)
+    endif
+    return ac
+endfunction
+#pointer
+function else_verify(ss ac,sd else_index)
+    sd p_ind
+    sd c_ind
+
+    setcall p_ind brace_blocks_counter()
+    set c_ind p_ind#
+    #this condition for: else >expression<
+    if c_ind>else_index
+        call brace_blocks_remove_parse()
+    endif
+    setcall p_ind brace_blocks_counter()
+    set c_ind p_ind#
+    #opened else index same with current index: return at else
+    if else_index=c_ind
+        return ac
+    endif
+
+    sd bool_is_elseif
+
+    ss pointer
+    setcall pointer else_elseif_expression(ac,#bool_is_elseif)
+    if pointer=ac
+        return ac
+    endif
+    while pointer!=ac
+        call action_code_set((else_flag))
+        call brace_blocks_add_parse((else_flag))
+        sd ind
+        setcall p_ind brace_blocks_counter()
+        set ind p_ind#
+        #c_ind is lower
+        while ind!=c_ind
+			ss the_new_pointer;set the_new_pointer pointer
+            setcall the_new_pointer action_code_row_ex(pointer,(FALSE),ind)
+			if the_new_pointer=pointer;call error("Else not closed");endif
+			set pointer the_new_pointer
+            #
+            setcall p_ind brace_blocks_counter()
+            set c_ind p_ind#
+        endwhile
+        set ac pointer
+        sd prev_else_elseif;set prev_else_elseif bool_is_elseif
+        setcall pointer else_elseif_expression(ac,#bool_is_elseif)
+        if prev_else_elseif=(FALSE);if bool_is_elseif=(TRUE)
+            call error("not expecting Else and then Else If")
+        endif;endif
+    endwhile
+    call brace_blocks_remove_parse_else()
+    return ac
+endfunction
+#next/same
+function else_elseif_expression(ss ac,sd p_elseif)
+    set p_elseif# (FALSE)
+    ss pointer
+    setcall pointer str_expression_at_start(ac,"else")
+    if pointer=ac
+        return ac
+    endif
+    setcall ac str_expression_at_start(pointer,"if")
+    if pointer=ac
+        return pointer
+    endif
+    set p_elseif# (TRUE)
+    return pointer
+endfunction
+#pointer
+function action_code_row_parse_instrument(ss ac)
+    ss pointer
+    setcall pointer action_code_parse_leftfunction(ac)
+    if pointer!=ac
+        return pointer
+    endif
+    setcall pointer str_expression_at_start(ac,"return")
+    if pointer!=ac
+        call action_code_set((ActionReturn))
+        char an_end=";"
+        setcall ac action_code_row_parse_tool(pointer,an_end)
+        return ac
+    endif
+    setcall pointer str_expression_at_start_withEndCare(ac,"break")
+    if pointer!=ac
+        call action_code_set((break_flag))
+        return pointer
+    endif
+    setcall pointer str_expression_at_start_withEndCare(ac,"continue")
+    if pointer!=ac
+        call action_code_set((continue_flag))
+        return pointer
+    endif
+    #
+    setcall pointer action_parse_pack(ac,(Semicolon))
+    return pointer
+endfunction
+#pointer
+function action_parse_pack(ss ac,sd endChar)
+    ss pointer
+    sd isnewvar=FALSE
+    sd isdelete
+    setcall pointer str_expression_at_start(ac,"var")
+    if pointer!=ac
+        set isnewvar (TRUE)
+    else
+        set isdelete (FALSE)
+        setcall pointer str_expression_at_start(ac,"delete")
+        if pointer!=ac
+            set isdelete (TRUE)
+        endif
+    endelse
+    sd op
+    char set={Equals}
+    char secondChar#1
+    char *term=0
+    set secondChar endChar
+    ss delims^set
+
+    setcall ac str_next(pointer,delims,#op)
+    if isnewvar=(TRUE)
+        if op=set
+            call action_code_set((ActionDefineLocal))
+            call action_code_set_pointer(pointer)
+        else
+            call action_code_set((ActionDefineLocal2))
+            call action_code_set_pointer(pointer)
+            return ac
+        endelse
+    else
+        if isdelete=(FALSE)
+            sd inc_dec
+            if op!=set
+                set inc_dec 0
+                ss test
+                set test ac
+                if op!=0
+                    sub test 3
+                else
+                    sub test 2
+                endelse
+                sd another_test
+                set another_test test
+                sub another_test pointer
+                #test for some size for ++ or --
+                if another_test>0
+                    if test#=(Plus)
+                        inc test
+                        if test#=(Plus)
+                            set inc_dec (ActionIncrement)
+                            dec test
+                            set test# 0
+                        endif
+                    elseif test#=(Hyphen)
+                        inc test
+                        if test#=(Hyphen)
+                            set inc_dec (ActionDecrement)
+                            dec test
+                            set test# 0
+                        endif
+                    endelseif
+                endif
+                #if not ++ or -- return the current location (x;heatMaker;)
+                if inc_dec=0
+                    return ac
+                endif
+            else
+                #test for += .. |= ..
+                sd mixt_action;setcall mixt_action action_parse_test_mixt_equal(pointer,ac)
+            endelse
+            call action_parse_left_holder(pointer,(ActionSetVariable),(ActionSetMember))
+            if op=set
+            #mixt or not mixt
+                if mixt_action!=0
+                    call action_code_set((mixt_equal))
+                    call action_code_set(mixt_action)
+                endif
+            else
+                #is inc dec case
+                call action_code_set(inc_dec)
+                return ac
+            endelse
+        else
+            call action_parse_left_holder(pointer,(ActionDelete2),(ActionDelete))
+            return ac
+        endelse
+    endelse
+    setcall ac action_parse_right(ac,endChar)
+    return ac
+endfunction
+function action_parse_left_holder(ss pointer,sd ac1,sd ac2)
+    ss test
+    setcall test action_code_membersplit(pointer)
+    if test=(NULL)
+        call action_code_set(ac1)
+        call action_code_set_pointer(pointer)
+    else
+        call action_code_set(ac2)
+        call action_code_member(pointer)
+    endelse
+endfunction
+#0/action
+function action_parse_test_mixt_equal(ss start,ss ac)
+    dec ac
+    ss pointer;set pointer ac
+    dec ac
+    ss dif;set dif ac;sub dif start
+    if dif<=0
+        return 0
+    endif
+    if ac#=0
+        #0 can be set(qw['z']=x will be 00x) and at strchr will not be NULL
+        return 0
+    endif
+    ss operations;setcall operations get_operations()
+    ss p_op;setcall p_op strchr(operations,ac#)
+    if p_op=(NULL);return 0;endif;sd op;set op p_op#
+    if op=(shl);ss missing_shl="expecting value and <<"
+        dec ac
+        if ac=start
+            call error(missing_shl)
+        elseif ac#!=(shl)
+            call error(missing_shl)
+        endelseif
+    elseif op=(sar_shr);ss missing_sar_shr="expecting value and >>"
+        dec ac
+        if ac=start
+            call error(missing_sar_shr)
+        elseif ac#!=(sar_shr)
+            call error(missing_sar_shr)
+        endelseif
+        dec ac
+        if ac#!=(sar_shr)
+            inc ac
+        endif
+    endelseif
+    set ac# 0
+    sd action;setcall action action_parse_take_action(op,pointer)
+    return action
+endfunction
+#pointer
+function action_parse_right(ss ac,sd endChar)
+    ss pointer
+    #can be a function definition
+    setcall pointer action_code_parse_deffunction(ac)
+    if pointer!=ac
+        return pointer
+    endif
+    #
+    setcall ac action_code_row_parse_tool(ac,endChar)
+    return ac
+endfunction
+#pointer
+function action_code_row_parse_tool(ss ac,sd endtype)
+    setcall ac action_code_row_parse_tool_util(ac,0,endtype,0)
+    return ac
+endfunction
+
+#pointer
+function action_code_row_parse_tool_util(ss ac,sd p_op,sd endtype1,sd endtype2)
+    if ac#=0
+        call error("expeting a number, variables operations")
+    endif
+    #a new object
+    ss pointer
+    setcall pointer str_expression_at_start(ac,"new")
+    if pointer!=ac
+        setcall ac action_code_parse_new_or_call(pointer,(new_action))
+        sd bool;setcall bool action_parse_utilEndTypes(ac#,p_op,endtype1,endtype2)
+        if bool=(TRUE);inc ac;endif
+        return ac
+    endif
+    sd ifElse_bool=FALSE
+    setcall ac action_parse_loop(ac,p_op,endtype1,endtype2,#ifElse_bool)
+    if ifElse_bool=(FALSE)
+        call action_code_set((math_end))
+    endif
+    return ac
+endfunction
+#pointer
+function action_parse_loop(ss ac,sv p_op,sd endtype1,sd endtype2,sd p_ifElse_bool)  #p_op is pointing at a stack variable
+    sd bool
+    #can be on the stack but char is low value; ends are set again when recursivity
+    char oprs#operations_size
+    char *=Openingbracket
+    char *=Exclamationmark
+    char *=Equals
+    char end#1
+    char end2#1
+    char *term=0
+    #
+    sd is_compare_ptr
+    setcall is_compare_ptr compare_bool_pointer()
+    #
+    vstr op_set^oprs
+    ss ops;setcall ops get_operations();call memcpy(op_set,ops,(operations_size))
+    while 1=1
+        sd op
+        sd was_parenthesis=0
+        if ac#=(Openparenthesis)
+            call action_code_set((parenthesis_start))
+            inc ac
+            setcall ac action_code_row_parse_tool(ac,(Closeparenthesis))
+            #0 is the marker after op set; used at strings; and logicalAnd logicalOr shr and sar are not needing 0 but it's faster for strings, and are comparing with !=sign(0 is used); used at action_parse_take_action
+            set op ac#;set ac# 0
+            set was_parenthesis 1
+        endif
+        #set end: is static variable and can be mod again inside previous function
+        set end endtype1
+        set end2 endtype2
+        #
+        if was_parenthesis=0
+            setcall ac action_code_take_main(ac,#op,op_set)
+            if op=(ifElse_sign)
+                inc ac
+                call action_code_set((ifElse_start))
+                set p_ifElse_bool# (TRUE)
+                setcall ac action_code_row_parse_tool(ac,(Colon))
+                setcall ac action_code_row_parse_tool_util(ac,p_op,endtype1,endtype2)
+                return ac
+            endif
+        endif
+        #
+        setcall ac action_code_extended_operations(ac,op)
+        if is_compare_ptr#=(TRUE)
+            set is_compare_ptr# (FALSE)
+        else
+            if op=0
+                if p_op!=0
+                    set p_op# op
+                endif
+                return ac
+            else
+                setcall bool action_parse_utilEndTypes(op,p_op,endtype1,endtype2)
+                if bool=(TRUE);return ac;endif
+            endelse
+            sd x;setcall x action_parse_take_action(op,ac)
+            call action_code_set(x)
+        endelse
+    endwhile
+endfunction
+#action
+function action_parse_take_action(sd op,ss ac)
+    sd x
+    ss test
+    if op=(add);set x (ActionAdd2)
+    elseif op=(sub);set x (ActionSubtract)
+    elseif op=(mlt);set x (ActionMultiply)
+    elseif op=(div);set x (ActionDivide)
+    elseif op=(modulo);set x (ActionModulo)
+    elseif op=(and)
+        set test ac;dec test
+        if test#=(and);set x (ActionAnd);else;set x (ActionBitAnd);endelse
+    elseif op=(or)
+        set test ac;dec test
+        if test#=(or);set x (ActionOr);else;set x (ActionBitOr);endelse
+    elseif op=(xor);set x (ActionBitXor)
+    elseif op=(shl);set x (ActionBitLShift)
+    elseif op=(sar_shr)
+        set test ac
+        sub test 2
+        if test#=0;set x (ActionBitRShift)
+        else;set x (ActionBitURShift);endelse
+    else
+        #at "qwer"x can be x
+        call error("unrecognized actionscript operation")
+    endelse
+    return x
+endfunction
+#pointer
+function action_code_extended_operations(ss pointer,sd op)
+    #comparison
+    sd compareaction
+    setcall compareaction action_compare(op,(NULL))
+    if compareaction!=(NULL)
+        inc pointer
+        sd oneSign_two_or_noCompare;setcall oneSign_two_or_noCompare action_compare(pointer#,compareaction)
+        dec pointer
+        if oneSign_two_or_noCompare!=2
+            sd compare_bool_ptr;setcall compare_bool_ptr compare_bool_pointer();set compare_bool_ptr# (TRUE)
+            add pointer oneSign_two_or_noCompare
+            inc pointer
+            return pointer
+        endif
+    endif
+
+    #shl/shr/sar / && ||
+    if op=(shl)
+        inc pointer
+        if pointer#!=(shl);call error("expecting <<");endif
+    elseif op=(sar_shr)
+        inc pointer
+        if pointer#!=(sar_shr);call error("expecting >>");endif
+        inc pointer
+        if pointer#!=(sar_shr)
+        #not >>> case
+            dec pointer
+        endif
+    elseif op=(and)
+        inc pointer;if pointer#!=(and);dec pointer;endif
+    elseif op=(or)
+        inc pointer;if pointer#!=(or);dec pointer;endif
+    endelseif
+
+    if op!=0
+        inc pointer
+    endif
+
+    return pointer
+endfunction
+#pointer
+function action_code_take_main(ss ac,sv p_op,ss delims) #p_op is pointing at a stack variable
+    #a string
+    ss pointer
+    setcall pointer action_code_str(ac)
+    if pointer!=0
+        set p_op# pointer#;set pointer# 0
+        return pointer
+    endif
+    #a function
+    setcall pointer action_code_parse_new_or_call(ac,(call_action_right))
+    if pointer!=ac
+        set p_op# pointer#;set pointer# 0
+        return pointer
+    endif
+    #a variable(a.b.c[1+d])
+    char neg="-"
+    if pointer#=neg
+        inc pointer
+    endif
+    sd pos
+    setcall pos strcspn(pointer,delims)
+    add pointer pos
+    while pointer#=(Openingbracket)
+        setcall pointer brackets_test(pointer)
+        #continue with the member
+        setcall pos strcspn(pointer,delims)
+        add pointer pos
+    endwhile
+    sd op
+    set op pointer#
+    set p_op# op;set pointer# 0
+    call action_code_take(ac)
+    return pointer
+endfunction
+#pointer
+function brackets_test(ss pointer)
+    sd multidim=1
+    while multidim=1
+        sd openedbrackets=1
+        while openedbrackets>0
+            inc pointer
+            if pointer#=(Openingbracket)
+                inc openedbrackets
+            elseif pointer#=(Closingbracket)
+                dec openedbrackets
+            elseif pointer#=0
+                call error("unclosed bracket detected")
+            endelseif
+        endwhile
+        inc pointer
+        if pointer#!=(Openingbracket)
+            set multidim 0
+        endif
+    endwhile
+    return pointer
+endfunction
+
+import "str_escape" str_escape
+#next/0
+function action_code_str(ss ac)
+    sd delim
+    char stringdelim="\""
+    char stringdelim2="'"
+    set delim stringdelim
+    if ac#!=stringdelim
+        if ac#!=stringdelim2
+            return 0
+        else
+            set delim stringdelim2
+        endelse
+    endif
+    ss next
+    ss dest
+    set dest ac
+    inc dest
+    setcall next str_escape(ac,dest,delim)
+    call action_code_set((ap_Constant8))
+    call action_code_set_pointer(dest)
+    return next
+endfunction
+function action_code_take(ss ac)
+    sd b;setcall b numeric_code(ac)
+    if b=(TRUE)
+        return (void)
+    endif
+    ss test
+    setcall test action_code_membersplit(ac)
+    if test=0
+        call action_code_set((ActionGetVariable))
+        call action_code_set_pointer(ac)
+    else
+        call action_code_set((ActionGetMember))
+        call action_code_member(ac)
+    endelse
+endfunction
+#bool
+function numeric_code(ss ac)
+    ss pointer;set pointer ac
+    char neg="-"
+    if pointer#=neg
+        inc pointer
+    endif
+    sd bool
+    setcall bool is_numeric(pointer#)
+    if bool!=(TRUE);return (FALSE);endif
+    #
+    data value_low#1;data value_high#1
+    #
+    ss decimal_symbol_test
+    char dot="."
+    setcall decimal_symbol_test strchr(pointer,dot)
+    if decimal_symbol_test!=(NULL)
+        call action_code_set((ap_double))
+        call sscanf(ac,"%lf",#value_low)
+        call action_code_set(value_high)
+        call action_code_set(value_low)
+        return (TRUE)
+    endif
+    #
+    call action_code_set((ap_Integer))
+    #
+    ss hextest
+    set hextest pointer
+    inc hextest
+    char hex="x"
+    if hextest#=hex
+        call sscanf(ac,"%x",#value_low)
+    else
+        call sscanf(ac,"%u",#value_low)
+    endelse
+    call action_code_set(value_low)
+    return (TRUE)
+endfunction
+function action_code_member(ss ac)
+    vstr delims=".["
+    char dot=".";char sqbrace_start="["
+    char sqbrace_end="]"
+    while ac#!=0
+        sd pos
+        setcall pos strcspn(ac,delims)
+        ss pointer
+        set pointer ac
+        if pos!=0
+        #0 is at second+ multi-dimensional arrays levels
+            add pointer pos
+            call action_code_set_pointer(ac)
+        endif
+        if pointer#=sqbrace_start
+            set pointer# 0
+            inc pointer
+            call action_code_set((square_bracket_start))
+            setcall pointer action_code_row_parse_tool(pointer,sqbrace_end)
+        endif
+        if pointer#=dot
+            set pointer# 0
+            inc pointer
+        endif
+        set ac pointer
+    endwhile
+    call action_code_set_pointer((no_pointer))
+endfunction
+
+
+#condition
+
+
+#firstcompare==NULL:action code/NULL;else oneSign_two_or_noCompare 0/1/2
+function action_compare(sd value,sd firstcompare)
+    #
+    ss compares
+    setcall compares compares_signs()
+    #<
+    if compares#=value
+        if firstcompare!=(NULL)
+                                           #is shl
+            if firstcompare=(ActionLess2);return 2
+            else;call error("not expeting < here");endelse
+        endif
+        return (ActionLess2)
+    endif
+    #>
+    inc compares
+    if compares#=value
+        if firstcompare!=(NULL)
+                                             #is sar_shr
+            if firstcompare=(ActionGreater);return 2
+            else;call error("not expeting > here");endelse
+        endif
+        return (ActionGreater)
+    endif
+    #
+    if firstcompare!=(NULL)
+        call action_code_set((compare_action))
+    endif
+    #=
+    inc compares
+    if compares#=value
+        if firstcompare=(ActionLess2)
+            call action_code_set((ActionGreater))
+            call action_code_set((ActionNot))
+            return 1
+        elseif firstcompare=(ActionGreater)
+            call action_code_set((ActionLess2))
+            call action_code_set((ActionNot))
+            return 1
+        elseif firstcompare=(ActionEquals2)
+            call action_code_set((ActionEquals2))
+            call action_code_set(0)
+            return 1
+        elseif firstcompare=(ActionNot)
+            call action_code_set((ActionEquals2))
+            call action_code_set((ActionNot))
+            return 1
+        endelseif
+        return (ActionEquals2)
+    endif
+    # !
+    inc compares
+    if compares#=value
+        if firstcompare!=(NULL)
+            call error("not expecting ! here")
+        endif
+        return (ActionNot)
+    endif
+    #another char
+    if firstcompare=(NULL)
+        #call error("expecting a comparison")
+        return (NULL)
+    elseif firstcompare=(ActionEquals2)
+        call error("expecting a == comparison")
+    elseif firstcompare=(ActionNot)
+        call error("expecting a != comparison")
+    endelseif
+    if firstcompare=(ActionLess2)
+        call action_code_set((ActionLess2))
+        call action_code_set(0)
+    else
+    #if firstcompare==(ActionGreater)
+        call action_code_set((ActionGreater))
+        call action_code_set(0)
+    endelse
+    return 0
+endfunction
+
+#{} blocks
+
+function brace_blocks_counter_inc()
+    sd c
+    setcall c brace_blocks_counter()
+    if c#=(brace_blocks_max)
+    #was >=
+        call error("too many blocks: {}")
+    endif
+    inc c#
+endfunction
+function brace_blocks_counter_dec()
+    sd c
+    setcall c brace_blocks_counter()
+    if c#<=0
+        call error("unexpected end block: }")
+    endif
+    dec c#
+endfunction
+#
+function brace_blocks_add_parse(sd type)
+    sd block
+    setcall block cond_blocks()
+    set block# type
+    call brace_blocks_counter_inc()
+endfunction
+function brace_blocks_remove_parse_else()
+    sd p_type
+    sd type
+    #
+    sd p_i
+    setcall p_i brace_blocks_counter()
+    sd i
+    set i p_i#
+    dec i
+    setcall p_type cond_blocks_at_index(i)
+    set type p_type#
+    if type=(else_flag)
+        sd else_number=0
+        while type=(else_flag)
+            inc else_number
+            dec p_i#
+            if i!=0
+                dec i
+                setcall p_type cond_blocks_at_index(i)
+                set type p_type#
+            else
+                set type 0
+            endelse
+        endwhile
+        call action_code_set((block_else_end))
+        call action_code_set(else_number)
+    endif
+endfunction
+function brace_blocks_remove_parse()
+    sd p_type
+    sd type
+    sd consecutive=consecutive_flag
+    while consecutive=(consecutive_flag)
+        call brace_blocks_counter_dec()
+        #
+        setcall p_type cond_blocks()
+        setcall type type_consecutive(p_type#,#consecutive)
+        if type!=(normal_marker)
+            if type=(while_marker)
+                call action_code_set((whileblock_end))
+            else
+                call action_code_set((block_end))
+            endelse
+        endif
+    endwhile
+endfunction
+#type
+function type_consecutive(sd type,sd p_consecutive)
+    and p_consecutive# type
+    and type (~consecutive_flag)
+    return type
+endfunction
+function brace_blocks_end()
+    sd c
+    setcall c brace_blocks_counter()
+    if c#!=0
+        call error("unclosed block(s): {}")
+    endif
+endfunction
+#
+import "block_get_size" block_get_size
+function brace_blocks_add_write()
+    call brace_blocks_add_write_offset(-2)
+endfunction
+function brace_blocks_add_write_current()
+    call brace_blocks_add_write_offset(0)
+endfunction
+function brace_blocks_add_write_offset(sd offset)
+    sd block
+    setcall block cond_blocks()
+    sd memblock
+    setcall memblock brace_blocks_get_memblock()
+    setcall block# block_get_size(memblock)
+    add block# offset
+    call brace_blocks_counter_inc()
+endfunction
+    #
+import "block_get_mem_size" block_get_mem_size
+function brace_blocks_remove_write()
+    sd offset
+    setcall offset brace_blocks_remove_write_offset()
+    call write_forward_offset(offset)
+endfunction
+function write_forward_offset(sd offset)
+    sd mem
+    sd size
+    sd memblock
+    setcall memblock brace_blocks_get_memblock()
+    call block_get_mem_size(memblock,#mem,#size)
+    #
+    add mem offset
+    add offset (WORD)
+    sub size offset
+    #
+    if size>0x7fFF
+        call error("offset>(signed word size) error")
+    endif
+    #
+    import "dword_to_word_arg" dword_to_word_arg
+    call dword_to_word_arg(size,mem)
+endfunction
+#offset
+function brace_blocks_remove_write_offset()
+    call brace_blocks_counter_dec()
+    sd block
+    setcall block cond_blocks()
+    return block#
+endfunction
+
+function brace_blocks_remove_write_jump()
+    call add_dummy_jump()
+    #
+    call brace_blocks_remove_write_loopIfJumps_at_current_offset()
+    #
+    sd jumpoffset
+    setcall jumpoffset brace_blocks_remove_write_offset()
+    call resolve_dummy_jump(jumpoffset)
+endfunction
+function add_dummy_jump()
+    import "actionrecordheader" actionrecordheader
+    call actionrecordheader((ActionJump),2)
+    import "swf_actionblock_add" swf_actionblock_add
+    sd dummy_size=0
+    call swf_actionblock_add(#dummy_size,2)
+endfunction
+function resolve_dummy_jump(sd jumpoffset)
+    sd memblock
+    ss mem
+    sd size
+    setcall memblock brace_blocks_get_memblock()
+    call block_get_mem_size(memblock,#mem,#size)
+    add mem size;sub mem (WORD)
+    #
+    sub size jumpoffset
+    mult size -1
+    if size<0xFFff8000
+        call error("offset>(signed word size) error (at jump back)")
+    endif
+    #
+    set mem# size
+    sd byte=0x0000ff00;and byte size;div byte 0x100
+    inc mem;set mem# byte
+endfunction
+function brace_blocks_remove_write_loopIfJumps_at_current_offset()
+    while 1=1
+        sd ifoffset
+        setcall ifoffset brace_blocks_remove_write_offset()
+        if ifoffset=0
+            #also remove the type of loop
+            call brace_blocks_counter_dec()
+            return (void)
+        endif
+        call write_forward_offset(ifoffset)
+    endwhile
+endfunction
+
+#function
+
+#pointer
+function action_code_parse_leftfunction(ss ac)
+    #function definition
+    ss pointer
+    setcall pointer action_code_parse_deffunction(ac)
+    if pointer!=ac
+        return pointer
+    endif
+    #a call
+    setcall ac action_code_parse_new_or_call(ac,(call_action_left))
+    char end=";"
+    if ac#=end
+        inc ac
+    endif
+    return ac
+endfunction
+#pointer
+function action_code_parse_new_or_call(ss ac,sd type)
+    ss pointer
+    set pointer ac
+    import "part_of_variable" part_of_variable
+    ss last_dot=0
+    sd bool
+    setcall bool part_of_variable(pointer#)
+    while bool=(TRUE)
+        inc pointer
+        setcall bool part_of_variable(pointer#)
+        if bool=(FALSE)
+            if pointer#=(Openingbracket)
+                setcall pointer brackets_test(pointer)
+            endif
+            if pointer#=(Period)
+                set last_dot pointer
+                set bool (TRUE)
+            elseif pointer#=(Openparenthesis)
+                setcall pointer action_code_parse_function_detected(ac,last_dot,pointer,type)
+                return pointer
+            endelseif
+        endif
+    endwhile
+    return ac
+endfunction
+#pointer
+function action_code_parse_function_detected(ss start,ss last_dot,ss pointer,sd type)
+    #function mark
+    call action_code_set(type)
+    set pointer# 0
+    #function name + member
+    if last_dot!=0
+        set last_dot# 0
+        inc last_dot
+        call action_code_set_pointer(start)
+        call action_code_set_pointer(last_dot)
+    else
+        call action_code_set_pointer((no_pointer))
+        call action_code_set_pointer(start)
+    endelse
+    setcall pointer action_code_parse_function_arguments(pointer)
+    call action_code_set((args_end))
+    return pointer
+endfunction
+#pointer
+function action_code_parse_function_arguments(ss pointer)
+    #arguments
+    # this was for what? sd math_values
+    # setcall math_values action_code_get()
+    char comma=","
+    char close=")"
+    inc pointer
+    if pointer#=close
+        inc pointer
+        return pointer
+    endif
+    #
+        #need to swap the arguments for the call function
+    const swapdata_max=128
+    sd swapdata#swapdata_max
+    sd cursor^swapdata
+    sd all_nr=swapdata_max*:
+    sd nr
+    set nr all_nr
+    add cursor nr
+    sd start_data
+    sd data
+    setcall start_data action_code_get()
+    set data start_data
+    sd sizemark
+    setcall sizemark action_code_values_index()
+    sd sizepointer
+    set sizepointer sizemark#
+    #
+    sd op=0
+    while op!=close
+        setcall pointer action_code_row_parse_tool_util(pointer,#op,comma,close)
+        if op=0
+            call error("close the function arguments sign expected: )")
+        endif
+        #
+        sd dif
+        set dif sizemark#
+        sub dif sizepointer
+        set sizepointer sizemark#
+        mult dif (DWORD)
+            #
+        sub nr dif
+        if nr<0
+            call error("too many function arguments")
+        endif
+        sub cursor dif
+        call memcpy(cursor,data,dif)
+        add data dif
+        #
+    endwhile
+    #
+    sub all_nr nr
+    call memcpy(start_data,cursor,all_nr)
+    #
+    return pointer
+endfunction
+
+#
+
+#pointer
+function action_code_parse_deffunction(ss ac)
+    ss pointer
+    setcall pointer str_expression_at_start(ac,"function")
+    if pointer=ac
+        return ac
+    endif
+    call action_code_set((function_action))
+    ss name_start
+    set name_start pointer
+    char startsign="("
+    ss args
+    setcall args strchr(pointer,startsign)
+    if args=(NULL)
+        call error("start sign expected at function definition: (")
+    endif
+    set args# 0
+    call action_code_set_pointer(name_start)
+    setcall pointer action_code_parse_function_defarguments(args)
+    call action_code_set_pointer((no_pointer))
+    #
+    call brace_blocks_add_parse((function_marker))
+    #loop until the function code is over
+    sd index_atstart
+    setcall index_atstart brace_blocks_counter()
+    set index_atstart index_atstart#
+    #
+    setcall pointer action_code_row(pointer,(TRUE))
+    sd index_current
+    setcall index_current brace_blocks_counter()
+    set index_current index_current#
+    while index_atstart<=index_current
+        if pointer#=0
+            call error("A define function was unclosed")
+        endif
+        setcall pointer action_code_row(pointer,(FALSE))
+        setcall index_current brace_blocks_counter()
+        set index_current index_current#
+    endwhile
+    return pointer
+endfunction
+#pointer
+function action_code_parse_function_defarguments(ss ac)
+    vstr argsdelims=",)"
+    char close=")"
+    inc ac
+    if ac#=close
+        inc ac
+        return ac
+    endif
+    sd op=0
+    while op!=close
+        sd pos
+        setcall pos strcspn(ac,argsdelims)
+        call action_code_set_pointer(ac)
+        add ac pos
+        if ac#=0
+            call error("close the function arguments sign expected: )")
+        endif
+        set op ac#
+        set ac# 0
+        inc ac
+    endwhile
+    return ac
+endfunction
+
--- actionswf-1.orig/src/actionparse.s
+++ /dev/null
@@ -1,1305 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-#win32 with _
-importx "strcspn" strcspn
-importx "strchr" strchr
-importx "memcpy" memcpy
-importx "sscanf" sscanf
-importx "strpbrk" strpbrk
-
-import "str_next" str_next
-import "str_expression_at_start" str_expression_at_start
-
-import "debug_code" debug_code
-import "spaces" spaces
-
-import "str_expression_at_start_withEndCare" str_expression_at_start_withEndCare
-
-#operations str
-function get_operations()
-    const operations_begin=!
-    char operations="+-*/%&|^<>?"
-    #subtract 1 is for the string termination
-    const operations_size=!-operations_begin-1
-    return #operations
-endfunction
-
-#bool
-function action_parse_utilEndTypes(sd op,sv p_op,sd endtype1,sd endtype2)  #p_op is pointing at a stack variable
-    #when p_op is set, is to store the multiple kind of endtypes
-    if p_op!=0
-        set p_op# op
-        if op=endtype2
-            return (TRUE)
-        endif
-    endif
-    if op=endtype1;return (TRUE);endif
-    return (FALSE)
-endfunction
-
-import "is_numeric" is_numeric
-
-#strpbrk
-function action_code_membersplit(ss ac)
-    char delims=".["
-    ss next
-    setcall next strpbrk(ac,#delims)
-    return next
-endfunction
-
-#str
-function compares_signs()
-    return "<>=!"
-endfunction
-function compare_bool_pointer()
-    data compare_bool=FALSE;return #compare_bool
-endfunction
-
-const cond_block_size=DWORD
-const brace_blocks_max=100*cond_block_size
-function brace_blocks_counter()
-    data counter#1
-    return #counter
-endfunction
-function brace_blocks_counter_init()
-    sd c
-    setcall c brace_blocks_counter()
-    set c# 0
-endfunction
-
-function cond_blocks()
-    sd p_i
-    setcall p_i brace_blocks_counter()
-    sd blocks
-    setcall blocks cond_blocks_at_index(p_i#)
-    return blocks
-endfunction
-function cond_blocks_at_index(sd i)
-    data blocks_mem#brace_blocks_max
-    sd blocks^blocks_mem
-    #
-    mult i (cond_block_size)
-    add blocks i
-    return blocks
-endfunction
-
-import "swf_actionblock" swf_actionblock
-function brace_blocks_get_memblock()
-    sd memblock
-    setcall memblock swf_actionblock((mem_exp_get_block))
-    return memblock
-endfunction
-
-import "action_code_get" action_code_get
-import "action_code_values_index" action_code_values_index
-
-
-
-
-
-importaftercall ebool
-
-import "action_code_set" action_code_set
-import "action_code_set_pointer" action_code_set_pointer
-import "error" error
-const add=Plus
-const sub=Hyphen
-const mlt=Asterisk
-const div=Slash
-const modulo=Percent
-const and=Ampersand
-const or=Verticalbar
-const xor=Caret
-const shl=Lessthan
-const sar_shr=Greaterthan
-const ifElse_sign=Questionmark
-#pointer
-function action_code_row(ss ac,sd a_block_detected)
-	setcall ac action_code_row_ex(ac,a_block_detected,-1)
-    return ac
-endfunction
-#pointer
-function action_code_row_ex(ss ac,sd a_block_detected,sd else_index)
-    sv p_c
-    setcall p_c debug_code()
-    set p_c# ac
-    ss atstart=NULL
-    while atstart!=ac
-        sd flags
-        sd for_detected=0
-        set atstart ac
-        setcall ac action_parse_conditions(ac,#flags,#for_detected)
-        if atstart!=ac
-            if for_detected=0
-                if ac#!=(Openparenthesis)
-                    call error("open parenthesis sign expected")
-                endif
-                #using the operations function
-                inc ac
-                char closecompare=")"
-                setcall ac action_code_row_parse_tool(ac,closecompare)
-                #if ac#!=closecompare
-                #    call error("close parenthesis expected")
-                #endif
-            endif
-            #important settings
-            if a_block_detected=(TRUE)
-                or flags (consecutive_flag)
-            endif
-            call brace_blocks_add_parse(flags)
-            set a_block_detected (TRUE)
-        endif
-    endwhile
-    setcall ac action_code_row_parse(ac,a_block_detected,else_index)
-	import "debug_phase_parse" debug_phase_parse
-	#around: else if(2==2){return 2;}else{return 3;}, 4 breakpoints, with \n-s,this here and not at action_code_row,1 breakpoint
-	call debug_phase_parse(ac)
-    return ac
-endfunction
-#pointer
-function action_parse_conditions(ss ac,sd p_flags,sd p_for_detected)
-    #if
-    ss pointer
-    setcall pointer str_expression_at_start(ac,"if")
-    if pointer!=ac
-        set p_flags# (if_marker)
-        call action_code_set((ActionIf))
-        return pointer
-    endif
-    #while
-    setcall pointer str_expression_at_start(ac,"while")
-    if pointer!=ac
-        call action_code_set((while_marker))
-        set p_flags# (while_marker)
-        return pointer
-    else
-    #for
-        setcall pointer str_expression_at_start(ac,"for")
-        if pointer=ac;return pointer;endif
-        #
-        call action_code_set((for_marker))
-        set p_flags# (while_marker)
-        set p_for_detected# 1
-        #
-        if pointer#!=(Openparenthesis)
-            call error("expecting Open Parenthesis at for loop")
-        endif
-        inc pointer
-        set ac pointer
-        #
-        ss cursor;ss marker
-        #forIn or for x;x;x
-        sd pos1;setcall pos1 strcspn(pointer,")")
-        sd pos2;setcall pos2 strcspn(pointer,";")
-        if pos2<pos1
-            #for x;x;x
-            call action_code_set((for_three))
-            #ac X;x;x
-            set cursor pointer;add cursor pos2
-            if cursor#=0
-                call error("expecting ';' at for loop, first part")
-            endif
-                            #is for for(;x;x) the !=
-            if cursor!=ac;call action_parse_pack(ac,(Semicolon));endif
-                            #is for for(;x;x)
-            call action_code_set((inter_for))
-            inc cursor
-            #pointer x;X;x
-            set pointer cursor
-            setcall pos2 strcspn(pointer,";")
-            add cursor pos2
-            if cursor#=0
-                call error("expecting ';' at for loop, second part")
-            endif
-            #cursor x;x;X
-            inc cursor
-            #not let for(x;x;heatMaker), heatMaker will be ignored and violation will come
-            if cursor#!=(Closeparenthesis);setcall cursor action_parse_pack(cursor,(Closeparenthesis))
-            else;inc cursor;endelse
-            call action_code_set((inter_for))
-            call action_code_row_parse_tool(pointer,(Semicolon))
-            return cursor
-        endif
-        #
-        setcall pointer str_expression_at_start(pointer,"var")
-        setcall pos1 strcspn(pointer," ")
-        set cursor pointer;add cursor pos1
-        if cursor#=0
-            call error("expecting 'space' at for loop")
-        endif
-        set cursor# 0
-        inc cursor;setcall cursor spaces(cursor)
-        setcall marker str_expression_at_start(cursor,"in")
-        if marker=cursor
-            call error("expecting 'in' at for loop")
-        endif
-        setcall pos1 strcspn(marker,")")
-        set cursor marker
-        add cursor pos1
-        if cursor#=0
-            call error("expecting Close Parenthesis at for loop")
-        endif
-        set cursor# 0
-        #
-        #enum can take ActionEnumerate(x.x[z])
-        call action_code_set_pointer(marker)
-        #
-        if pointer!=ac
-            call action_code_set((ActionDefineLocal))
-            call action_code_set_pointer(pointer)
-        else
-            call action_parse_left_holder(pointer,(ActionSetVariable),(ActionSetMember))
-        endelse
-        inc cursor
-        return cursor
-    endelse
-endfunction
-#pointer
-function action_code_row_parse(ss ac,sd a_block_detected,sd else_index)
-    if ac#=(Openingbrace)
-        if a_block_detected=(FALSE)
-            call brace_blocks_add_parse((normal_marker))
-        endif
-        inc ac
-        return ac
-    elseif ac#=(Closingbrace)
-        if a_block_detected=(TRUE)
-            call error("unexpected closing brace sign after code block opened")
-        endif
-        inc ac
-        setcall ac else_verify(ac,else_index)
-        return ac
-    endelseif
-    setcall ac action_code_row_parse_instrument(ac)
-    if a_block_detected=(TRUE)
-    #ex: if(a==b)x=3;
-        setcall ac else_verify(ac,else_index)
-    endif
-    return ac
-endfunction
-#pointer
-function else_verify(ss ac,sd else_index)
-    sd p_ind
-    sd c_ind
-
-    setcall p_ind brace_blocks_counter()
-    set c_ind p_ind#
-    #this condition for: else >expression<
-    if c_ind>else_index
-        call brace_blocks_remove_parse()
-    endif
-    setcall p_ind brace_blocks_counter()
-    set c_ind p_ind#
-    #opened else index same with current index: return at else
-    if else_index=c_ind
-        return ac
-    endif
-
-    sd bool_is_elseif
-
-    ss pointer
-    setcall pointer else_elseif_expression(ac,#bool_is_elseif)
-    if pointer=ac
-        return ac
-    endif
-    while pointer!=ac
-        call action_code_set((else_flag))
-        call brace_blocks_add_parse((else_flag))
-        sd ind
-        setcall p_ind brace_blocks_counter()
-        set ind p_ind#
-        #c_ind is lower
-        while ind!=c_ind
-			ss the_new_pointer;set the_new_pointer pointer
-            setcall the_new_pointer action_code_row_ex(pointer,(FALSE),ind)
-			if the_new_pointer=pointer;call error("Else not closed");endif
-			set pointer the_new_pointer
-            #
-            setcall p_ind brace_blocks_counter()
-            set c_ind p_ind#
-        endwhile
-        set ac pointer
-        sd prev_else_elseif;set prev_else_elseif bool_is_elseif
-        setcall pointer else_elseif_expression(ac,#bool_is_elseif)
-        if prev_else_elseif=(FALSE);if bool_is_elseif=(TRUE)
-            call error("not expecting Else and then Else If")
-        endif;endif
-    endwhile
-    call brace_blocks_remove_parse_else()
-    return ac
-endfunction
-#next/same
-function else_elseif_expression(ss ac,sd p_elseif)
-    set p_elseif# (FALSE)
-    ss pointer
-    setcall pointer str_expression_at_start(ac,"else")
-    if pointer=ac
-        return ac
-    endif
-    setcall ac str_expression_at_start(pointer,"if")
-    if pointer=ac
-        return pointer
-    endif
-    set p_elseif# (TRUE)
-    return pointer
-endfunction
-#pointer
-function action_code_row_parse_instrument(ss ac)
-    ss pointer
-    setcall pointer action_code_parse_leftfunction(ac)
-    if pointer!=ac
-        return pointer
-    endif
-    setcall pointer str_expression_at_start(ac,"return")
-    if pointer!=ac
-        call action_code_set((ActionReturn))
-        char an_end=";"
-        setcall ac action_code_row_parse_tool(pointer,an_end)
-        return ac
-    endif
-    setcall pointer str_expression_at_start_withEndCare(ac,"break")
-    if pointer!=ac
-        call action_code_set((break_flag))
-        return pointer
-    endif
-    setcall pointer str_expression_at_start_withEndCare(ac,"continue")
-    if pointer!=ac
-        call action_code_set((continue_flag))
-        return pointer
-    endif
-    #
-    setcall pointer action_parse_pack(ac,(Semicolon))
-    return pointer
-endfunction
-#pointer
-function action_parse_pack(ss ac,sd endChar)
-    ss pointer
-    sd isnewvar=FALSE
-    sd isdelete
-    setcall pointer str_expression_at_start(ac,"var")
-    if pointer!=ac
-        set isnewvar (TRUE)
-    else
-        set isdelete (FALSE)
-        setcall pointer str_expression_at_start(ac,"delete")
-        if pointer!=ac
-            set isdelete (TRUE)
-        endif
-    endelse
-    sd op
-    char set={Equals}
-    char secondChar#1
-    char *term=0
-    set secondChar endChar
-    ss delims^set
-
-    setcall ac str_next(pointer,delims,#op)
-    if isnewvar=(TRUE)
-        if op=set
-            call action_code_set((ActionDefineLocal))
-            call action_code_set_pointer(pointer)
-        else
-            call action_code_set((ActionDefineLocal2))
-            call action_code_set_pointer(pointer)
-            return ac
-        endelse
-    else
-        if isdelete=(FALSE)
-            sd inc_dec
-            if op!=set
-                set inc_dec 0
-                ss test
-                set test ac
-                if op!=0
-                    sub test 3
-                else
-                    sub test 2
-                endelse
-                sd another_test
-                set another_test test
-                sub another_test pointer
-                #test for some size for ++ or --
-                if another_test>0
-                    if test#=(Plus)
-                        inc test
-                        if test#=(Plus)
-                            set inc_dec (ActionIncrement)
-                            dec test
-                            set test# 0
-                        endif
-                    elseif test#=(Hyphen)
-                        inc test
-                        if test#=(Hyphen)
-                            set inc_dec (ActionDecrement)
-                            dec test
-                            set test# 0
-                        endif
-                    endelseif
-                endif
-                #if not ++ or -- return the current location (x;heatMaker;)
-                if inc_dec=0
-                    return ac
-                endif
-            else
-                #test for += .. |= ..
-                sd mixt_action;setcall mixt_action action_parse_test_mixt_equal(pointer,ac)
-            endelse
-            call action_parse_left_holder(pointer,(ActionSetVariable),(ActionSetMember))
-            if op=set
-            #mixt or not mixt
-                if mixt_action!=0
-                    call action_code_set((mixt_equal))
-                    call action_code_set(mixt_action)
-                endif
-            else
-                #is inc dec case
-                call action_code_set(inc_dec)
-                return ac
-            endelse
-        else
-            call action_parse_left_holder(pointer,(ActionDelete2),(ActionDelete))
-            return ac
-        endelse
-    endelse
-    setcall ac action_parse_right(ac,endChar)
-    return ac
-endfunction
-function action_parse_left_holder(ss pointer,sd ac1,sd ac2)
-    ss test
-    setcall test action_code_membersplit(pointer)
-    if test=(NULL)
-        call action_code_set(ac1)
-        call action_code_set_pointer(pointer)
-    else
-        call action_code_set(ac2)
-        call action_code_member(pointer)
-    endelse
-endfunction
-#0/action
-function action_parse_test_mixt_equal(ss start,ss ac)
-    dec ac
-    ss pointer;set pointer ac
-    dec ac
-    ss dif;set dif ac;sub dif start
-    if dif<=0
-        return 0
-    endif
-    if ac#=0
-        #0 can be set(qw['z']=x will be 00x) and at strchr will not be NULL
-        return 0
-    endif
-    ss operations;setcall operations get_operations()
-    ss p_op;setcall p_op strchr(operations,ac#)
-    if p_op=(NULL);return 0;endif;sd op;set op p_op#
-    if op=(shl);ss missing_shl="expecting value and <<"
-        dec ac
-        if ac=start
-            call error(missing_shl)
-        elseif ac#!=(shl)
-            call error(missing_shl)
-        endelseif
-    elseif op=(sar_shr);ss missing_sar_shr="expecting value and >>"
-        dec ac
-        if ac=start
-            call error(missing_sar_shr)
-        elseif ac#!=(sar_shr)
-            call error(missing_sar_shr)
-        endelseif
-        dec ac
-        if ac#!=(sar_shr)
-            inc ac
-        endif
-    endelseif
-    set ac# 0
-    sd action;setcall action action_parse_take_action(op,pointer)
-    return action
-endfunction
-#pointer
-function action_parse_right(ss ac,sd endChar)
-    ss pointer
-    #can be a function definition
-    setcall pointer action_code_parse_deffunction(ac)
-    if pointer!=ac
-        return pointer
-    endif
-    #
-    setcall ac action_code_row_parse_tool(ac,endChar)
-    return ac
-endfunction
-#pointer
-function action_code_row_parse_tool(ss ac,sd endtype)
-    setcall ac action_code_row_parse_tool_util(ac,0,endtype,0)
-    return ac
-endfunction
-
-#pointer
-function action_code_row_parse_tool_util(ss ac,sd p_op,sd endtype1,sd endtype2)
-    if ac#=0
-        call error("expeting a number, variables operations")
-    endif
-    #a new object
-    ss pointer
-    setcall pointer str_expression_at_start(ac,"new")
-    if pointer!=ac
-        setcall ac action_code_parse_new_or_call(pointer,(new_action))
-        sd bool;setcall bool action_parse_utilEndTypes(ac#,p_op,endtype1,endtype2)
-        if bool=(TRUE);inc ac;endif
-        return ac
-    endif
-    sd ifElse_bool=FALSE
-    setcall ac action_parse_loop(ac,p_op,endtype1,endtype2,#ifElse_bool)
-    if ifElse_bool=(FALSE)
-        call action_code_set((math_end))
-    endif
-    return ac
-endfunction
-#pointer
-function action_parse_loop(ss ac,sv p_op,sd endtype1,sd endtype2,sd p_ifElse_bool)  #p_op is pointing at a stack variable
-    sd bool
-    #can be on the stack but char is low value; ends are set again when recursivity
-    char oprs#operations_size
-    char *=Openingbracket
-    char *=Exclamationmark
-    char *=Equals
-    char end#1
-    char end2#1
-    char *term=0
-    #
-    sd is_compare_ptr
-    setcall is_compare_ptr compare_bool_pointer()
-    #
-    vstr op_set^oprs
-    ss ops;setcall ops get_operations();call memcpy(op_set,ops,(operations_size))
-    while 1=1
-        sd op
-        sd was_parenthesis=0
-        if ac#=(Openparenthesis)
-            call action_code_set((parenthesis_start))
-            inc ac
-            setcall ac action_code_row_parse_tool(ac,(Closeparenthesis))
-            #0 is the marker after op set; used at strings; and logicalAnd logicalOr shr and sar are not needing 0 but it's faster for strings, and are comparing with !=sign(0 is used); used at action_parse_take_action
-            set op ac#;set ac# 0
-            set was_parenthesis 1
-        endif
-        #set end: is static variable and can be mod again inside previous function
-        set end endtype1
-        set end2 endtype2
-        #
-        if was_parenthesis=0
-            setcall ac action_code_take_main(ac,#op,op_set)
-            if op=(ifElse_sign)
-                inc ac
-                call action_code_set((ifElse_start))
-                set p_ifElse_bool# (TRUE)
-                setcall ac action_code_row_parse_tool(ac,(Colon))
-                setcall ac action_code_row_parse_tool_util(ac,p_op,endtype1,endtype2)
-                return ac
-            endif
-        endif
-        #
-        setcall ac action_code_extended_operations(ac,op)
-        if is_compare_ptr#=(TRUE)
-            set is_compare_ptr# (FALSE)
-        else
-            if op=0
-                if p_op!=0
-                    set p_op# op
-                endif
-                return ac
-            else
-                setcall bool action_parse_utilEndTypes(op,p_op,endtype1,endtype2)
-                if bool=(TRUE);return ac;endif
-            endelse
-            sd x;setcall x action_parse_take_action(op,ac)
-            call action_code_set(x)
-        endelse
-    endwhile
-endfunction
-#action
-function action_parse_take_action(sd op,ss ac)
-    sd x
-    ss test
-    if op=(add);set x (ActionAdd2)
-    elseif op=(sub);set x (ActionSubtract)
-    elseif op=(mlt);set x (ActionMultiply)
-    elseif op=(div);set x (ActionDivide)
-    elseif op=(modulo);set x (ActionModulo)
-    elseif op=(and)
-        set test ac;dec test
-        if test#=(and);set x (ActionAnd);else;set x (ActionBitAnd);endelse
-    elseif op=(or)
-        set test ac;dec test
-        if test#=(or);set x (ActionOr);else;set x (ActionBitOr);endelse
-    elseif op=(xor);set x (ActionBitXor)
-    elseif op=(shl);set x (ActionBitLShift)
-    elseif op=(sar_shr)
-        set test ac
-        sub test 2
-        if test#=0;set x (ActionBitRShift)
-        else;set x (ActionBitURShift);endelse
-    else
-        #at "qwer"x can be x
-        call error("unrecognized actionscript operation")
-    endelse
-    return x
-endfunction
-#pointer
-function action_code_extended_operations(ss pointer,sd op)
-    #comparison
-    sd compareaction
-    setcall compareaction action_compare(op,(NULL))
-    if compareaction!=(NULL)
-        inc pointer
-        sd oneSign_two_or_noCompare;setcall oneSign_two_or_noCompare action_compare(pointer#,compareaction)
-        dec pointer
-        if oneSign_two_or_noCompare!=2
-            sd compare_bool_ptr;setcall compare_bool_ptr compare_bool_pointer();set compare_bool_ptr# (TRUE)
-            add pointer oneSign_two_or_noCompare
-            inc pointer
-            return pointer
-        endif
-    endif
-
-    #shl/shr/sar / && ||
-    if op=(shl)
-        inc pointer
-        if pointer#!=(shl);call error("expecting <<");endif
-    elseif op=(sar_shr)
-        inc pointer
-        if pointer#!=(sar_shr);call error("expecting >>");endif
-        inc pointer
-        if pointer#!=(sar_shr)
-        #not >>> case
-            dec pointer
-        endif
-    elseif op=(and)
-        inc pointer;if pointer#!=(and);dec pointer;endif
-    elseif op=(or)
-        inc pointer;if pointer#!=(or);dec pointer;endif
-    endelseif
-
-    if op!=0
-        inc pointer
-    endif
-
-    return pointer
-endfunction
-#pointer
-function action_code_take_main(ss ac,sv p_op,ss delims) #p_op is pointing at a stack variable
-    #a string
-    ss pointer
-    setcall pointer action_code_str(ac)
-    if pointer!=0
-        set p_op# pointer#;set pointer# 0
-        return pointer
-    endif
-    #a function
-    setcall pointer action_code_parse_new_or_call(ac,(call_action_right))
-    if pointer!=ac
-        set p_op# pointer#;set pointer# 0
-        return pointer
-    endif
-    #a variable(a.b.c[1+d])
-    char neg="-"
-    if pointer#=neg
-        inc pointer
-    endif
-    sd pos
-    setcall pos strcspn(pointer,delims)
-    add pointer pos
-    while pointer#=(Openingbracket)
-        setcall pointer brackets_test(pointer)
-        #continue with the member
-        setcall pos strcspn(pointer,delims)
-        add pointer pos
-    endwhile
-    sd op
-    set op pointer#
-    set p_op# op;set pointer# 0
-    call action_code_take(ac)
-    return pointer
-endfunction
-#pointer
-function brackets_test(ss pointer)
-    sd multidim=1
-    while multidim=1
-        sd openedbrackets=1
-        while openedbrackets>0
-            inc pointer
-            if pointer#=(Openingbracket)
-                inc openedbrackets
-            elseif pointer#=(Closingbracket)
-                dec openedbrackets
-            elseif pointer#=0
-                call error("unclosed bracket detected")
-            endelseif
-        endwhile
-        inc pointer
-        if pointer#!=(Openingbracket)
-            set multidim 0
-        endif
-    endwhile
-    return pointer
-endfunction
-
-import "str_escape" str_escape
-#next/0
-function action_code_str(ss ac)
-    sd delim
-    char stringdelim="\""
-    char stringdelim2="'"
-    set delim stringdelim
-    if ac#!=stringdelim
-        if ac#!=stringdelim2
-            return 0
-        else
-            set delim stringdelim2
-        endelse
-    endif
-    ss next
-    ss dest
-    set dest ac
-    inc dest
-    setcall next str_escape(ac,dest,delim)
-    call action_code_set((ap_Constant8))
-    call action_code_set_pointer(dest)
-    return next
-endfunction
-function action_code_take(ss ac)
-    sd b;setcall b numeric_code(ac)
-    if b=(TRUE)
-        return (void)
-    endif
-    ss test
-    setcall test action_code_membersplit(ac)
-    if test=0
-        call action_code_set((ActionGetVariable))
-        call action_code_set_pointer(ac)
-    else
-        call action_code_set((ActionGetMember))
-        call action_code_member(ac)
-    endelse
-endfunction
-#bool
-function numeric_code(ss ac)
-    ss pointer;set pointer ac
-    char neg="-"
-    if pointer#=neg
-        inc pointer
-    endif
-    sd bool
-    setcall bool is_numeric(pointer#)
-    if bool!=(TRUE);return (FALSE);endif
-    #
-    data value_low#1;data value_high#1
-    #
-    ss decimal_symbol_test
-    char dot="."
-    setcall decimal_symbol_test strchr(pointer,dot)
-    if decimal_symbol_test!=(NULL)
-        call action_code_set((ap_double))
-        call sscanf(ac,"%lf",#value_low)
-        call action_code_set(value_high)
-        call action_code_set(value_low)
-        return (TRUE)
-    endif
-    #
-    call action_code_set((ap_Integer))
-    #
-    ss hextest
-    set hextest pointer
-    inc hextest
-    char hex="x"
-    if hextest#=hex
-        call sscanf(ac,"%x",#value_low)
-    else
-        call sscanf(ac,"%u",#value_low)
-    endelse
-    call action_code_set(value_low)
-    return (TRUE)
-endfunction
-function action_code_member(ss ac)
-    vstr delims=".["
-    char dot=".";char sqbrace_start="["
-    char sqbrace_end="]"
-    while ac#!=0
-        sd pos
-        setcall pos strcspn(ac,delims)
-        ss pointer
-        set pointer ac
-        if pos!=0
-        #0 is at second+ multi-dimensional arrays levels
-            add pointer pos
-            call action_code_set_pointer(ac)
-        endif
-        if pointer#=sqbrace_start
-            set pointer# 0
-            inc pointer
-            call action_code_set((square_bracket_start))
-            setcall pointer action_code_row_parse_tool(pointer,sqbrace_end)
-        endif
-        if pointer#=dot
-            set pointer# 0
-            inc pointer
-        endif
-        set ac pointer
-    endwhile
-    call action_code_set_pointer((no_pointer))
-endfunction
-
-
-#condition
-
-
-#firstcompare==NULL:action code/NULL;else oneSign_two_or_noCompare 0/1/2
-function action_compare(sd value,sd firstcompare)
-    #
-    ss compares
-    setcall compares compares_signs()
-    #<
-    if compares#=value
-        if firstcompare!=(NULL)
-                                           #is shl
-            if firstcompare=(ActionLess2);return 2
-            else;call error("not expeting < here");endelse
-        endif
-        return (ActionLess2)
-    endif
-    #>
-    inc compares
-    if compares#=value
-        if firstcompare!=(NULL)
-                                             #is sar_shr
-            if firstcompare=(ActionGreater);return 2
-            else;call error("not expeting > here");endelse
-        endif
-        return (ActionGreater)
-    endif
-    #
-    if firstcompare!=(NULL)
-        call action_code_set((compare_action))
-    endif
-    #=
-    inc compares
-    if compares#=value
-        if firstcompare=(ActionLess2)
-            call action_code_set((ActionGreater))
-            call action_code_set((ActionNot))
-            return 1
-        elseif firstcompare=(ActionGreater)
-            call action_code_set((ActionLess2))
-            call action_code_set((ActionNot))
-            return 1
-        elseif firstcompare=(ActionEquals2)
-            call action_code_set((ActionEquals2))
-            call action_code_set(0)
-            return 1
-        elseif firstcompare=(ActionNot)
-            call action_code_set((ActionEquals2))
-            call action_code_set((ActionNot))
-            return 1
-        endelseif
-        return (ActionEquals2)
-    endif
-    # !
-    inc compares
-    if compares#=value
-        if firstcompare!=(NULL)
-            call error("not expecting ! here")
-        endif
-        return (ActionNot)
-    endif
-    #another char
-    if firstcompare=(NULL)
-        #call error("expecting a comparison")
-        return (NULL)
-    elseif firstcompare=(ActionEquals2)
-        call error("expecting a == comparison")
-    elseif firstcompare=(ActionNot)
-        call error("expecting a != comparison")
-    endelseif
-    if firstcompare=(ActionLess2)
-        call action_code_set((ActionLess2))
-        call action_code_set(0)
-    else
-    #if firstcompare==(ActionGreater)
-        call action_code_set((ActionGreater))
-        call action_code_set(0)
-    endelse
-    return 0
-endfunction
-
-#{} blocks
-
-function brace_blocks_counter_inc()
-    sd c
-    setcall c brace_blocks_counter()
-    if c#=(brace_blocks_max)
-    #was >=
-        call error("too many blocks: {}")
-    endif
-    inc c#
-endfunction
-function brace_blocks_counter_dec()
-    sd c
-    setcall c brace_blocks_counter()
-    if c#<=0
-        call error("unexpected end block: }")
-    endif
-    dec c#
-endfunction
-#
-function brace_blocks_add_parse(sd type)
-    sd block
-    setcall block cond_blocks()
-    set block# type
-    call brace_blocks_counter_inc()
-endfunction
-function brace_blocks_remove_parse_else()
-    sd p_type
-    sd type
-    #
-    sd p_i
-    setcall p_i brace_blocks_counter()
-    sd i
-    set i p_i#
-    dec i
-    setcall p_type cond_blocks_at_index(i)
-    set type p_type#
-    if type=(else_flag)
-        sd else_number=0
-        while type=(else_flag)
-            inc else_number
-            dec p_i#
-            if i!=0
-                dec i
-                setcall p_type cond_blocks_at_index(i)
-                set type p_type#
-            else
-                set type 0
-            endelse
-        endwhile
-        call action_code_set((block_else_end))
-        call action_code_set(else_number)
-    endif
-endfunction
-function brace_blocks_remove_parse()
-    sd p_type
-    sd type
-    sd consecutive=consecutive_flag
-    while consecutive=(consecutive_flag)
-        call brace_blocks_counter_dec()
-        #
-        setcall p_type cond_blocks()
-        setcall type type_consecutive(p_type#,#consecutive)
-        if type!=(normal_marker)
-            if type=(while_marker)
-                call action_code_set((whileblock_end))
-            else
-                call action_code_set((block_end))
-            endelse
-        endif
-    endwhile
-endfunction
-#type
-function type_consecutive(sd type,sd p_consecutive)
-    and p_consecutive# type
-    and type (~consecutive_flag)
-    return type
-endfunction
-function brace_blocks_end()
-    sd c
-    setcall c brace_blocks_counter()
-    if c#!=0
-        call error("unclosed block(s): {}")
-    endif
-endfunction
-#
-import "block_get_size" block_get_size
-function brace_blocks_add_write()
-    call brace_blocks_add_write_offset(-2)
-endfunction
-function brace_blocks_add_write_current()
-    call brace_blocks_add_write_offset(0)
-endfunction
-function brace_blocks_add_write_offset(sd offset)
-    sd block
-    setcall block cond_blocks()
-    sd memblock
-    setcall memblock brace_blocks_get_memblock()
-    setcall block# block_get_size(memblock)
-    add block# offset
-    call brace_blocks_counter_inc()
-endfunction
-    #
-import "block_get_mem_size" block_get_mem_size
-function brace_blocks_remove_write()
-    sd offset
-    setcall offset brace_blocks_remove_write_offset()
-    call write_forward_offset(offset)
-endfunction
-function write_forward_offset(sd offset)
-    sd mem
-    sd size
-    sd memblock
-    setcall memblock brace_blocks_get_memblock()
-    call block_get_mem_size(memblock,#mem,#size)
-    #
-    add mem offset
-    add offset (WORD)
-    sub size offset
-    #
-    if size>0x7fFF
-        call error("offset>(signed word size) error")
-    endif
-    #
-    import "dword_to_word_arg" dword_to_word_arg
-    call dword_to_word_arg(size,mem)
-endfunction
-#offset
-function brace_blocks_remove_write_offset()
-    call brace_blocks_counter_dec()
-    sd block
-    setcall block cond_blocks()
-    return block#
-endfunction
-
-function brace_blocks_remove_write_jump()
-    call add_dummy_jump()
-    #
-    call brace_blocks_remove_write_loopIfJumps_at_current_offset()
-    #
-    sd jumpoffset
-    setcall jumpoffset brace_blocks_remove_write_offset()
-    call resolve_dummy_jump(jumpoffset)
-endfunction
-function add_dummy_jump()
-    import "actionrecordheader" actionrecordheader
-    call actionrecordheader((ActionJump),2)
-    import "swf_actionblock_add" swf_actionblock_add
-    sd dummy_size=0
-    call swf_actionblock_add(#dummy_size,2)
-endfunction
-function resolve_dummy_jump(sd jumpoffset)
-    sd memblock
-    ss mem
-    sd size
-    setcall memblock brace_blocks_get_memblock()
-    call block_get_mem_size(memblock,#mem,#size)
-    add mem size;sub mem (WORD)
-    #
-    sub size jumpoffset
-    mult size -1
-    if size<0xFFff8000
-        call error("offset>(signed word size) error (at jump back)")
-    endif
-    #
-    set mem# size
-    sd byte=0x0000ff00;and byte size;div byte 0x100
-    inc mem;set mem# byte
-endfunction
-function brace_blocks_remove_write_loopIfJumps_at_current_offset()
-    while 1=1
-        sd ifoffset
-        setcall ifoffset brace_blocks_remove_write_offset()
-        if ifoffset=0
-            #also remove the type of loop
-            call brace_blocks_counter_dec()
-            return (void)
-        endif
-        call write_forward_offset(ifoffset)
-    endwhile
-endfunction
-
-#function
-
-#pointer
-function action_code_parse_leftfunction(ss ac)
-    #function definition
-    ss pointer
-    setcall pointer action_code_parse_deffunction(ac)
-    if pointer!=ac
-        return pointer
-    endif
-    #a call
-    setcall ac action_code_parse_new_or_call(ac,(call_action_left))
-    char end=";"
-    if ac#=end
-        inc ac
-    endif
-    return ac
-endfunction
-#pointer
-function action_code_parse_new_or_call(ss ac,sd type)
-    ss pointer
-    set pointer ac
-    import "part_of_variable" part_of_variable
-    ss last_dot=0
-    sd bool
-    setcall bool part_of_variable(pointer#)
-    while bool=(TRUE)
-        inc pointer
-        setcall bool part_of_variable(pointer#)
-        if bool=(FALSE)
-            if pointer#=(Openingbracket)
-                setcall pointer brackets_test(pointer)
-            endif
-            if pointer#=(Period)
-                set last_dot pointer
-                set bool (TRUE)
-            elseif pointer#=(Openparenthesis)
-                setcall pointer action_code_parse_function_detected(ac,last_dot,pointer,type)
-                return pointer
-            endelseif
-        endif
-    endwhile
-    return ac
-endfunction
-#pointer
-function action_code_parse_function_detected(ss start,ss last_dot,ss pointer,sd type)
-    #function mark
-    call action_code_set(type)
-    set pointer# 0
-    #function name + member
-    if last_dot!=0
-        set last_dot# 0
-        inc last_dot
-        call action_code_set_pointer(start)
-        call action_code_set_pointer(last_dot)
-    else
-        call action_code_set_pointer((no_pointer))
-        call action_code_set_pointer(start)
-    endelse
-    setcall pointer action_code_parse_function_arguments(pointer)
-    call action_code_set((args_end))
-    return pointer
-endfunction
-#pointer
-function action_code_parse_function_arguments(ss pointer)
-    #arguments
-    # this was for what? sd math_values
-    # setcall math_values action_code_get()
-    char comma=","
-    char close=")"
-    inc pointer
-    if pointer#=close
-        inc pointer
-        return pointer
-    endif
-    #
-        #need to swap the arguments for the call function
-    const swapdata_max=128
-    sd swapdata#swapdata_max
-    sd cursor^swapdata
-    sd all_nr=swapdata_max*:
-    sd nr
-    set nr all_nr
-    add cursor nr
-    sd start_data
-    sd data
-    setcall start_data action_code_get()
-    set data start_data
-    sd sizemark
-    setcall sizemark action_code_values_index()
-    sd sizepointer
-    set sizepointer sizemark#
-    #
-    sd op=0
-    while op!=close
-        setcall pointer action_code_row_parse_tool_util(pointer,#op,comma,close)
-        if op=0
-            call error("close the function arguments sign expected: )")
-        endif
-        #
-        sd dif
-        set dif sizemark#
-        sub dif sizepointer
-        set sizepointer sizemark#
-        mult dif (DWORD)
-            #
-        sub nr dif
-        if nr<0
-            call error("too many function arguments")
-        endif
-        sub cursor dif
-        call memcpy(cursor,data,dif)
-        add data dif
-        #
-    endwhile
-    #
-    sub all_nr nr
-    call memcpy(start_data,cursor,all_nr)
-    #
-    return pointer
-endfunction
-
-#
-
-#pointer
-function action_code_parse_deffunction(ss ac)
-    ss pointer
-    setcall pointer str_expression_at_start(ac,"function")
-    if pointer=ac
-        return ac
-    endif
-    call action_code_set((function_action))
-    ss name_start
-    set name_start pointer
-    char startsign="("
-    ss args
-    setcall args strchr(pointer,startsign)
-    if args=(NULL)
-        call error("start sign expected at function definition: (")
-    endif
-    set args# 0
-    call action_code_set_pointer(name_start)
-    setcall pointer action_code_parse_function_defarguments(args)
-    call action_code_set_pointer((no_pointer))
-    #
-    call brace_blocks_add_parse((function_marker))
-    #loop until the function code is over
-    sd index_atstart
-    setcall index_atstart brace_blocks_counter()
-    set index_atstart index_atstart#
-    #
-    setcall pointer action_code_row(pointer,(TRUE))
-    sd index_current
-    setcall index_current brace_blocks_counter()
-    set index_current index_current#
-    while index_atstart<=index_current
-        if pointer#=0
-            call error("A define function was unclosed")
-        endif
-        setcall pointer action_code_row(pointer,(FALSE))
-        setcall index_current brace_blocks_counter()
-        set index_current index_current#
-    endwhile
-    return pointer
-endfunction
-#pointer
-function action_code_parse_function_defarguments(ss ac)
-    vstr argsdelims=",)"
-    char close=")"
-    inc ac
-    if ac#=close
-        inc ac
-        return ac
-    endif
-    sd op=0
-    while op!=close
-        sd pos
-        setcall pos strcspn(ac,argsdelims)
-        call action_code_set_pointer(ac)
-        add ac pos
-        if ac#=0
-            call error("close the function arguments sign expected: )")
-        endif
-        set op ac#
-        set ac# 0
-        inc ac
-    endwhile
-    return ac
-endfunction
-
--- /dev/null
+++ actionswf-1/src/actionpool.oc
@@ -0,0 +1,104 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+#win32 with _
+importx "strlen" strlen
+importx "memcmp" memcmp
+
+function actionpoolid_root()
+    data id#1
+    return #id
+endfunction
+function actionpoolid()
+    data id#1
+    return #id
+endfunction
+function actionpoolid_get()
+    sd p_id
+    setcall p_id actionpoolid()
+    return p_id#
+endfunction
+
+import "struct_ids_actionpool" struct_ids_actionpool
+#block
+function actionpool_currentblock()
+    sd poolid;sd block
+    setcall poolid actionpoolid_get()
+    setcall block struct_ids_actionpool((ids_get),poolid)
+    return block
+endfunction
+
+import "block_get_mem" block_get_mem
+import "block_get_size" block_get_size
+import "dword_to_word_arg" dword_to_word_arg
+import "word_arg_to_dword" word_arg_to_dword
+
+import "swf_mem" swf_mem
+
+
+
+
+aftercallimport ebool
+
+
+
+
+
+#pool id
+function actionpool_value(ss value)
+    sd poolid
+    setcall poolid actionpoolid_get()
+    or poolid (negative_means_action_sprite_pool)
+    sd nr
+    call swf_mem((mem_exp_change),poolid)
+    setcall nr actionpool_getvalue(value)
+    call swf_mem((mem_exp_change_back))
+    return nr
+endfunction
+import "swf_mem_add" swf_mem_add
+#pool id
+function actionpool_getvalue(ss value)
+    sd block
+    setcall block actionpool_currentblock()
+    sd size
+    setcall size block_get_size(block)
+    sd nr
+    sd newlen
+    setcall newlen strlen(value)
+    if size=0
+    #add the pools header and count=1, later add value for count=1
+        sd onevalue=1
+        call swf_mem_add(#onevalue,2)
+        set nr 0
+    else
+        sd mem
+        sd count
+        setcall mem block_get_mem(block)
+        setcall count word_arg_to_dword(mem)
+        add mem (WORD)
+        set nr count
+        while count!=0
+            sd len
+            setcall len strlen(mem)
+            if len=newlen
+                sd comp
+                setcall comp memcmp(mem,value,len)
+                if comp=0
+                    sub nr count
+                    return nr
+                endif
+            endif
+            inc len
+            add mem len
+            dec count
+        endwhile
+        setcall mem block_get_mem(block)
+        set count nr
+        inc count
+        call dword_to_word_arg(count,mem)
+    endelse
+    inc newlen
+    call swf_mem_add(value,newlen)
+    return nr
+endfunction
--- actionswf-1.orig/src/actionpool.s
+++ /dev/null
@@ -1,104 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-#win32 with _
-importx "strlen" strlen
-importx "memcmp" memcmp
-
-function actionpoolid_root()
-    data id#1
-    return #id
-endfunction
-function actionpoolid()
-    data id#1
-    return #id
-endfunction
-function actionpoolid_get()
-    sd p_id
-    setcall p_id actionpoolid()
-    return p_id#
-endfunction
-
-import "struct_ids_actionpool" struct_ids_actionpool
-#block
-function actionpool_currentblock()
-    sd poolid;sd block
-    setcall poolid actionpoolid_get()
-    setcall block struct_ids_actionpool((ids_get),poolid)
-    return block
-endfunction
-
-import "block_get_mem" block_get_mem
-import "block_get_size" block_get_size
-import "dword_to_word_arg" dword_to_word_arg
-import "word_arg_to_dword" word_arg_to_dword
-
-import "swf_mem" swf_mem
-
-
-
-
-importaftercall ebool
-
-
-
-
-
-#pool id
-function actionpool_value(ss value)
-    sd poolid
-    setcall poolid actionpoolid_get()
-    or poolid (negative_means_action_sprite_pool)
-    sd nr
-    call swf_mem((mem_exp_change),poolid)
-    setcall nr actionpool_getvalue(value)
-    call swf_mem((mem_exp_change_back))
-    return nr
-endfunction
-import "swf_mem_add" swf_mem_add
-#pool id
-function actionpool_getvalue(ss value)
-    sd block
-    setcall block actionpool_currentblock()
-    sd size
-    setcall size block_get_size(block)
-    sd nr
-    sd newlen
-    setcall newlen strlen(value)
-    if size=0
-    #add the pools header and count=1, later add value for count=1
-        sd onevalue=1
-        call swf_mem_add(#onevalue,2)
-        set nr 0
-    else
-        sd mem
-        sd count
-        setcall mem block_get_mem(block)
-        setcall count word_arg_to_dword(mem)
-        add mem (WORD)
-        set nr count
-        while count!=0
-            sd len
-            setcall len strlen(mem)
-            if len=newlen
-                sd comp
-                setcall comp memcmp(mem,value,len)
-                if comp=0
-                    sub nr count
-                    return nr
-                endif
-            endif
-            inc len
-            add mem len
-            dec count
-        endwhile
-        setcall mem block_get_mem(block)
-        set count nr
-        inc count
-        call dword_to_word_arg(count,mem)
-    endelse
-    inc newlen
-    call swf_mem_add(value,newlen)
-    return nr
-endfunction
--- /dev/null
+++ actionswf-1/src/actionutil.oc
@@ -0,0 +1,426 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+#win32 with _
+importx "strlen" strlen
+importx "memcpy" memcpy
+importx "sprintf" sprintf
+
+import "spaces" spaces
+
+#strings
+
+#0 yes  1 no
+function row_termination(sv p_ac,sv p_row)
+	ss ac;set ac p_ac#
+	if ac#=(LineFeed)
+		inc p_row#
+		return 0
+	elseif ac#=(CarriageReturn)
+		inc ac;if ac#=0xa;set p_ac# ac;endif
+		inc p_row#
+		return 0
+	endelseif
+	return 1
+endfunction
+#error_row
+function escape_action(ss ac,ss pointer,ss stop_pointer)
+    sd row=1
+    sd loop1=1
+    sd error_row=0
+    #
+    sd comments=0
+    char lines_com_c1="*";char lines_com_c2="/";ss test
+    const line_comment=1
+    const multiLine_comment=2
+    #
+    while loop1=1
+        sd loop2=1
+        setcall ac spaces(ac)
+        #
+        if comments!=(multiLine_comment)
+            set comments 0
+            if ac#=(Slash)
+                set test ac
+                inc test
+                if test#=(Slash)
+                    set comments (line_comment)
+                    add ac 2
+                elseif test#=lines_com_c1
+                    set comments (multiLine_comment)
+                    add ac 2
+                endelseif
+            endif
+        endif
+        #
+	import "debug_phase_init" debug_phase_init
+        while loop2=1
+		setcall loop2 row_termination(#ac,#row)
+		if loop2=1
+			if ac#=0
+				set loop2 0
+				set loop1 0
+				set pointer# 0
+				call debug_phase_init(pointer)
+			else
+				if comments=0
+				    if pointer=stop_pointer
+				        set error_row row
+				    else
+				        set pointer# ac#
+				    endelse
+				    inc pointer
+				elseif comments=(multiLine_comment)
+				    if ac#=lines_com_c1
+				        set test ac;inc test;if test#=lines_com_c2;set comments 0;inc ac;endif
+				    endif
+				endelseif
+			endelse
+		else
+			call debug_phase_init(pointer)
+		endelse
+            inc ac
+        endwhile
+	if error_row!=0
+            set pointer# 0
+            set loop1 0
+        endif
+    endwhile
+    return error_row
+endfunction
+#nr
+function escape_count(ss string,sd escape)
+    sd nr=0
+    sd escaped=0
+    while string#!=0
+        if string#=escape
+            xor escaped 1
+        elseif escaped=1
+		inc nr
+            set escaped 0
+
+		#this is not working nowadays, printf is searching for floats on xmm registers, kept as legacy
+		char l="l"
+		if string#=l
+			char f="f";
+			ss double_test=1
+			add double_test string
+			if double_test#=f
+				inc nr
+			endif
+		endif
+
+        endelseif
+        inc string
+    endwhile
+    return nr
+endfunction
+
+#debug
+
+function action_debug(sd is_on)
+    data action_errors=FALSE
+    vstr *#1
+    vstr m=NULL
+    if is_on=(FALSE)
+        #set there and here, here good at errors and comeback
+        set action_errors (FALSE)
+        import "mem_free" mem_free
+        if m!=(NULL);call mem_free(#m);endif
+    else
+        return #action_errors
+    endelse
+endfunction
+function action_debug_free()
+    call action_debug((FALSE))
+endfunction
+
+function debug_code()
+    value code#1
+    return #code
+endfunction
+
+function action_error()
+    sd p_action_errors
+    setcall p_action_errors action_debug((TRUE))
+    if p_action_errors#=(FALSE)
+        return (void)
+    endif
+
+    vstr ac#1
+    vstr mem#1
+    add p_action_errors (DWORD);call memcpy(#ac,p_action_errors,(2*:))
+
+    import "printEr" printEr
+    call printEr("Row: ")
+    sv p_c
+    setcall p_c debug_code()
+    sd row
+    setcall row escape_action(ac,mem,p_c#)
+    import "string_nl_print" string_nl_print
+    #a small reserve for a number like 2 000 000 000
+    char row_nr#dword_to_string_char
+    call sprintf(#row_nr,"%u",row)
+    call string_nl_print(#row_nr)
+    call string_nl_print(p_c#)
+endfunction
+
+#size
+function action_size(sd id)
+    import "block_get_size" block_get_size
+    sd block
+    setcall block struct_ids_action((ids_get),id)
+    sd size
+    setcall size block_get_size(block)
+    addcall size pool_size(id)
+    #add termination
+    add size 1
+    return size
+endfunction
+
+import "block_get_mem" block_get_mem
+
+#these ids are get only, is safe at throwless
+import "struct_ids_action" struct_ids_action
+import "struct_ids_actionpool" struct_ids_actionpool
+
+#size
+function pool_size(sd id)
+    sd poolblock
+    setcall poolblock struct_ids_actionpool((ids_get),id)
+    sd poolsize
+    setcall poolsize block_get_size(poolblock)
+    #detected at button actions="", swfdump giving error without "if poolsize!=0"
+    if poolsize=0;return 0;endif
+    #add header
+    add poolsize (1+2)
+    return poolsize
+endfunction
+
+
+
+
+
+aftercallimport ebool
+
+import "action_base" action_base
+
+import "swf_actionblock_add" swf_actionblock_add
+import "actionrecordheader" actionrecordheader
+import "actionpool_value" actionpool_value
+
+#tags
+
+function action_push(sd factors)
+	sd iter^factors
+	sd size=0
+	while iter#!=-1
+		inc size
+		if iter#=(ap_Integer)
+			add size (DWORD)
+			incst iter
+		elseif iter#=(ap_double)
+			add size (QWORD)
+			add iter (2*:)
+		elseif iter#=(ap_Null)
+		#skip
+		elseif iter#=(ap_Undefined)
+		#skip
+		else
+		#if iter#==(ap_RegisterNumber)
+		#if iter#==(ap_Boolean)
+		#if iter#==(ap_Constant8)
+			add size (BYTE)
+			sd value
+			set value iter#
+			incst iter
+			if value=(ap_Constant8)
+			#set the action pool(if isn't) and verify to add +1size if 8 will go to ap_Constant16
+				sd translated_id
+				setcall translated_id actionpool_value(iter#v^)
+				if translated_id>0xff
+					inc size
+				endif
+			endif
+		endelse
+		incst iter
+	endwhile
+
+	call actionrecordheader((ActionPush),size)
+
+	sd cursor^factors
+	while cursor#!=-1
+		#test here Constant8 to Constant16
+		if cursor#=(ap_Constant8)
+			sv pointer
+			set pointer cursor
+			incst pointer
+			#call actionpool_getvalue, the pool already exists(actionpool_value if not)
+			import "actionpool_getvalue" actionpool_getvalue
+			setcall translated_id actionpool_getvalue(pointer#)
+			sd const_sz=BYTE
+			if translated_id>0xff
+				inc const_sz
+				set cursor# (ap_Constant16)
+			endif
+		endif
+
+		call swf_actionblock_add(cursor,1)
+
+		if cursor#=(ap_Integer)
+			incst cursor
+			call swf_actionblock_add(cursor,(DWORD))
+		elseif cursor#=(ap_double)
+			incst cursor
+			call swf_actionblock_add(cursor,(DWORD))
+			incst cursor
+			call swf_actionblock_add(cursor,(DWORD))
+		elseif cursor#=(ap_RegisterNumber)
+			incst cursor
+			call swf_actionblock_add(cursor,(BYTE))
+		elseif cursor#=(ap_Boolean)
+			incst cursor
+			call swf_actionblock_add(cursor,(BYTE))
+		elseif cursor#=(ap_Null)
+		#skip
+		elseif cursor#=(ap_Undefined)
+		#skip
+		else
+		#if cursor#==(ap_Constant8)
+		#or was modified to (ap_Constant16)
+			call swf_actionblock_add(#translated_id,const_sz)
+			incst cursor
+		endelse
+		incst cursor
+	endwhile
+endfunction
+
+function action_one(sd tag)
+    call swf_actionblock_add(#tag,1)
+      import "debug_phase_code_add" debug_phase_code_add
+      call debug_phase_code_add()
+endfunction
+
+import "action_code_right_util" action_code_right_util
+#codepointer
+function action_caller(ss name,ss member,sd args_pointer)
+    sd nrargs=0
+    while args_pointer#!=(args_end)
+        setcall args_pointer action_code_right_util(args_pointer)
+        inc nrargs
+    endwhile
+    add args_pointer (DWORD)
+    call action_push((ap_Integer),nrargs,-1)
+    #
+    if member!=0
+        call action_member_write(member)
+    endif
+    call action_push((ap_Constant8),name,-1)
+    return args_pointer
+endfunction
+
+#member
+
+import "action_get_one" action_get_one
+#the position where the mathpointer reachs
+function action_member_loop(sd mathpointer,sd endoffset)
+    call action_get_one(mathpointer#v^)
+    while 1=1
+        add mathpointer :  #to pass the pointer
+        #
+        while mathpointer#=(square_bracket_start)
+        #multi-dim arrays
+            add mathpointer (DWORD)
+            setcall mathpointer action_code_right_util(mathpointer)
+            if endoffset=(get_member)
+                call action_one((ActionGetMember))
+            else
+                if mathpointer#v^!=(no_pointer)
+                    call action_one((ActionGetMember))
+                else
+                    add mathpointer :  #to pass the pointer
+                    return mathpointer
+                endelse
+            endelse
+        endwhile
+        sv endtest
+        set endtest mathpointer
+        add endtest endoffset
+        #
+        if endtest#=(no_pointer)
+            if endoffset!=(no_pointer)
+                #push to set later
+                call action_push((ap_Constant8),mathpointer#v^,-1)
+                add mathpointer :  #to pass the pointer
+            endif
+            add mathpointer :  #to pass the pointer
+            return mathpointer
+        endif
+        call action_push((ap_Constant8),mathpointer#v^,-1)
+        call action_one((ActionGetMember))
+    endwhile
+endfunction
+import "action_code_member" action_code_member
+import "error" error
+import "forward_values_expand" forward_values_expand
+function action_member_write(ss member)
+    const dup_member=256
+    char dup_data#dup_member
+    vstr code^dup_data
+    sd len
+    setcall len strlen(member)
+    inc len
+    if len>(dup_member)
+        call error("actionscript code limit exceeded")
+    endif
+    call memcpy(code,member,len)
+    call forward_values_expand(action_member_write_tool,code)
+endfunction
+function action_member_write_tool(sd values,ss names)
+    call action_code_member(names)
+    call action_member_loop(values,(get_member))
+endfunction
+
+#action
+
+import "swf_actionrecordheader" swf_actionrecordheader
+import "swf_mem_add" swf_mem_add
+function write_action(sd id)
+    sd block
+    setcall block struct_ids_action((ids_get),id)
+    sd mem
+    setcall mem block_get_mem(block)
+    sd size
+    setcall size block_get_size(block)
+    call pool_wr(id)
+    call swf_mem_add(mem,size)
+    #this is ActionEndFlag after ACTIONRECORD [zero or more]
+    data end=0
+    call swf_mem_add(#end,1)
+endfunction
+#void
+function pool_wr(sd id)
+    sd poolblock
+    setcall poolblock struct_ids_actionpool((ids_get),id)
+    sd poolsize
+    setcall poolsize block_get_size(poolblock)
+    #detected at button actions="", swfdump giving error without "if poolsize!=0"
+    if poolsize=0;return 0;endif
+    sd poolmem
+    setcall poolmem block_get_mem(poolblock)
+    call swf_actionrecordheader((ActionConstantPool),poolsize)
+    call swf_mem_add(poolmem,poolsize)
+endfunction
+
+#format
+
+function action_format(sv args)
+    sd args_nr=2
+    sv args_format
+    set args_format args;incst args_format
+    char e="%"
+    addcall args_nr escape_count(args_format#,e)
+    callex sprintf args args_nr
+    call action_base(args#)
+endfunction
--- actionswf-1.orig/src/actionutil.s
+++ /dev/null
@@ -1,426 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-#win32 with _
-importx "strlen" strlen
-importx "memcpy" memcpy
-importx "sprintf" sprintf
-
-import "spaces" spaces
-
-#strings
-
-#0 yes  1 no
-function row_termination(sv p_ac,sv p_row)
-	ss ac;set ac p_ac#
-	if ac#=(LineFeed)
-		inc p_row#
-		return 0
-	elseif ac#=(CarriageReturn)
-		inc ac;if ac#=0xa;set p_ac# ac;endif
-		inc p_row#
-		return 0
-	endelseif
-	return 1
-endfunction
-#error_row
-function escape_action(ss ac,ss pointer,ss stop_pointer)
-    sd row=1
-    sd loop1=1
-    sd error_row=0
-    #
-    sd comments=0
-    char lines_com_c1="*";char lines_com_c2="/";ss test
-    const line_comment=1
-    const multiLine_comment=2
-    #
-    while loop1=1
-        sd loop2=1
-        setcall ac spaces(ac)
-        #
-        if comments!=(multiLine_comment)
-            set comments 0
-            if ac#=(Slash)
-                set test ac
-                inc test
-                if test#=(Slash)
-                    set comments (line_comment)
-                    add ac 2
-                elseif test#=lines_com_c1
-                    set comments (multiLine_comment)
-                    add ac 2
-                endelseif
-            endif
-        endif
-        #
-	import "debug_phase_init" debug_phase_init
-        while loop2=1
-		setcall loop2 row_termination(#ac,#row)
-		if loop2=1
-			if ac#=0
-				set loop2 0
-				set loop1 0
-				set pointer# 0
-				call debug_phase_init(pointer)
-			else
-				if comments=0
-				    if pointer=stop_pointer
-				        set error_row row
-				    else
-				        set pointer# ac#
-				    endelse
-				    inc pointer
-				elseif comments=(multiLine_comment)
-				    if ac#=lines_com_c1
-				        set test ac;inc test;if test#=lines_com_c2;set comments 0;inc ac;endif
-				    endif
-				endelseif
-			endelse
-		else
-			call debug_phase_init(pointer)
-		endelse
-            inc ac
-        endwhile
-	if error_row!=0
-            set pointer# 0
-            set loop1 0
-        endif
-    endwhile
-    return error_row
-endfunction
-#nr
-function escape_count(ss string,sd escape)
-    sd nr=0
-    sd escaped=0
-    while string#!=0
-        if string#=escape
-            xor escaped 1
-        elseif escaped=1
-		inc nr
-            set escaped 0
-
-		#this is not working nowadays, printf is searching for floats on xmm registers, kept as legacy
-		char l="l"
-		if string#=l
-			char f="f";
-			ss double_test=1
-			add double_test string
-			if double_test#=f
-				inc nr
-			endif
-		endif
-
-        endelseif
-        inc string
-    endwhile
-    return nr
-endfunction
-
-#debug
-
-function action_debug(sd is_on)
-    data action_errors=FALSE
-    vstr *#1
-    vstr m=NULL
-    if is_on=(FALSE)
-        #set there and here, here good at errors and comeback
-        set action_errors (FALSE)
-        import "mem_free" mem_free
-        if m!=(NULL);call mem_free(#m);endif
-    else
-        return #action_errors
-    endelse
-endfunction
-function action_debug_free()
-    call action_debug((FALSE))
-endfunction
-
-function debug_code()
-    value code#1
-    return #code
-endfunction
-
-function action_error()
-    sd p_action_errors
-    setcall p_action_errors action_debug((TRUE))
-    if p_action_errors#=(FALSE)
-        return (void)
-    endif
-
-    vstr ac#1
-    vstr mem#1
-    add p_action_errors (DWORD);call memcpy(#ac,p_action_errors,(2*:))
-
-    import "printEr" printEr
-    call printEr("Row: ")
-    sv p_c
-    setcall p_c debug_code()
-    sd row
-    setcall row escape_action(ac,mem,p_c#)
-    import "string_nl_print" string_nl_print
-    #a small reserve for a number like 2 000 000 000
-    char row_nr#dword_to_string_char
-    call sprintf(#row_nr,"%u",row)
-    call string_nl_print(#row_nr)
-    call string_nl_print(p_c#)
-endfunction
-
-#size
-function action_size(sd id)
-    import "block_get_size" block_get_size
-    sd block
-    setcall block struct_ids_action((ids_get),id)
-    sd size
-    setcall size block_get_size(block)
-    addcall size pool_size(id)
-    #add termination
-    add size 1
-    return size
-endfunction
-
-import "block_get_mem" block_get_mem
-
-#these ids are get only, is safe at throwless
-import "struct_ids_action" struct_ids_action
-import "struct_ids_actionpool" struct_ids_actionpool
-
-#size
-function pool_size(sd id)
-    sd poolblock
-    setcall poolblock struct_ids_actionpool((ids_get),id)
-    sd poolsize
-    setcall poolsize block_get_size(poolblock)
-    #detected at button actions="", swfdump giving error without "if poolsize!=0"
-    if poolsize=0;return 0;endif
-    #add header
-    add poolsize (1+2)
-    return poolsize
-endfunction
-
-
-
-
-
-importaftercall ebool
-
-import "action_base" action_base
-
-import "swf_actionblock_add" swf_actionblock_add
-import "actionrecordheader" actionrecordheader
-import "actionpool_value" actionpool_value
-
-#tags
-
-function action_push(sd factors)
-	sd iter^factors
-	sd size=0
-	while iter#!=-1
-		inc size
-		if iter#=(ap_Integer)
-			add size (DWORD)
-			incst iter
-		elseif iter#=(ap_double)
-			add size (QWORD)
-			add iter (2*:)
-		elseif iter#=(ap_Null)
-		#skip
-		elseif iter#=(ap_Undefined)
-		#skip
-		else
-		#if iter#==(ap_RegisterNumber)
-		#if iter#==(ap_Boolean)
-		#if iter#==(ap_Constant8)
-			add size (BYTE)
-			sd value
-			set value iter#
-			incst iter
-			if value=(ap_Constant8)
-			#set the action pool(if isn't) and verify to add +1size if 8 will go to ap_Constant16
-				sd translated_id
-				setcall translated_id actionpool_value(iter#v^)
-				if translated_id>0xff
-					inc size
-				endif
-			endif
-		endelse
-		incst iter
-	endwhile
-
-	call actionrecordheader((ActionPush),size)
-
-	sd cursor^factors
-	while cursor#!=-1
-		#test here Constant8 to Constant16
-		if cursor#=(ap_Constant8)
-			sv pointer
-			set pointer cursor
-			incst pointer
-			#call actionpool_getvalue, the pool already exists(actionpool_value if not)
-			import "actionpool_getvalue" actionpool_getvalue
-			setcall translated_id actionpool_getvalue(pointer#)
-			sd const_sz=BYTE
-			if translated_id>0xff
-				inc const_sz
-				set cursor# (ap_Constant16)
-			endif
-		endif
-
-		call swf_actionblock_add(cursor,1)
-
-		if cursor#=(ap_Integer)
-			incst cursor
-			call swf_actionblock_add(cursor,(DWORD))
-		elseif cursor#=(ap_double)
-			incst cursor
-			call swf_actionblock_add(cursor,(DWORD))
-			incst cursor
-			call swf_actionblock_add(cursor,(DWORD))
-		elseif cursor#=(ap_RegisterNumber)
-			incst cursor
-			call swf_actionblock_add(cursor,(BYTE))
-		elseif cursor#=(ap_Boolean)
-			incst cursor
-			call swf_actionblock_add(cursor,(BYTE))
-		elseif cursor#=(ap_Null)
-		#skip
-		elseif cursor#=(ap_Undefined)
-		#skip
-		else
-		#if cursor#==(ap_Constant8)
-		#or was modified to (ap_Constant16)
-			call swf_actionblock_add(#translated_id,const_sz)
-			incst cursor
-		endelse
-		incst cursor
-	endwhile
-endfunction
-
-function action_one(sd tag)
-    call swf_actionblock_add(#tag,1)
-      import "debug_phase_code_add" debug_phase_code_add
-      call debug_phase_code_add()
-endfunction
-
-import "action_code_right_util" action_code_right_util
-#codepointer
-function action_caller(ss name,ss member,sd args_pointer)
-    sd nrargs=0
-    while args_pointer#!=(args_end)
-        setcall args_pointer action_code_right_util(args_pointer)
-        inc nrargs
-    endwhile
-    add args_pointer (DWORD)
-    call action_push((ap_Integer),nrargs,-1)
-    #
-    if member!=0
-        call action_member_write(member)
-    endif
-    call action_push((ap_Constant8),name,-1)
-    return args_pointer
-endfunction
-
-#member
-
-import "action_get_one" action_get_one
-#the position where the mathpointer reachs
-function action_member_loop(sd mathpointer,sd endoffset)
-    call action_get_one(mathpointer#v^)
-    while 1=1
-        add mathpointer :  #to pass the pointer
-        #
-        while mathpointer#=(square_bracket_start)
-        #multi-dim arrays
-            add mathpointer (DWORD)
-            setcall mathpointer action_code_right_util(mathpointer)
-            if endoffset=(get_member)
-                call action_one((ActionGetMember))
-            else
-                if mathpointer#v^!=(no_pointer)
-                    call action_one((ActionGetMember))
-                else
-                    add mathpointer :  #to pass the pointer
-                    return mathpointer
-                endelse
-            endelse
-        endwhile
-        sv endtest
-        set endtest mathpointer
-        add endtest endoffset
-        #
-        if endtest#=(no_pointer)
-            if endoffset!=(no_pointer)
-                #push to set later
-                call action_push((ap_Constant8),mathpointer#v^,-1)
-                add mathpointer :  #to pass the pointer
-            endif
-            add mathpointer :  #to pass the pointer
-            return mathpointer
-        endif
-        call action_push((ap_Constant8),mathpointer#v^,-1)
-        call action_one((ActionGetMember))
-    endwhile
-endfunction
-import "action_code_member" action_code_member
-import "error" error
-import "forward_values_expand" forward_values_expand
-function action_member_write(ss member)
-    const dup_member=256
-    char dup_data#dup_member
-    vstr code^dup_data
-    sd len
-    setcall len strlen(member)
-    inc len
-    if len>(dup_member)
-        call error("actionscript code limit exceeded")
-    endif
-    call memcpy(code,member,len)
-    call forward_values_expand(action_member_write_tool,code)
-endfunction
-function action_member_write_tool(sd values,ss names)
-    call action_code_member(names)
-    call action_member_loop(values,(get_member))
-endfunction
-
-#action
-
-import "swf_actionrecordheader" swf_actionrecordheader
-import "swf_mem_add" swf_mem_add
-function write_action(sd id)
-    sd block
-    setcall block struct_ids_action((ids_get),id)
-    sd mem
-    setcall mem block_get_mem(block)
-    sd size
-    setcall size block_get_size(block)
-    call pool_wr(id)
-    call swf_mem_add(mem,size)
-    #this is ActionEndFlag after ACTIONRECORD [zero or more]
-    data end=0
-    call swf_mem_add(#end,1)
-endfunction
-#void
-function pool_wr(sd id)
-    sd poolblock
-    setcall poolblock struct_ids_actionpool((ids_get),id)
-    sd poolsize
-    setcall poolsize block_get_size(poolblock)
-    #detected at button actions="", swfdump giving error without "if poolsize!=0"
-    if poolsize=0;return 0;endif
-    sd poolmem
-    setcall poolmem block_get_mem(poolblock)
-    call swf_actionrecordheader((ActionConstantPool),poolsize)
-    call swf_mem_add(poolmem,poolsize)
-endfunction
-
-#format
-
-function action_format(sv args)
-    sd args_nr=2
-    sv args_format
-    set args_format args;incst args_format
-    char e="%"
-    addcall args_nr escape_count(args_format#,e)
-    callex sprintf args args_nr
-    call action_base(args#)
-endfunction
--- /dev/null
+++ actionswf-1/src/bits.oc
@@ -0,0 +1,151 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+function bits_packs(ss dest,sd packs)
+    sd i=0
+    sd pos=0x80
+    sd value
+    sd size
+    sd src^packs
+    while i<packs
+        incst src
+        set value src#
+        incst src
+        set size src#
+        call bits_bigendian(value,size,#dest,#pos)
+        inc i
+    endwhile
+endfunction
+function bits_bigendian(sd value,sd size,sv p_dest,sd p_pos)
+    ss dest
+    sd pos
+    set dest p_dest#
+    set pos p_pos#
+    sd iter=-1
+    while size!=0
+        mult iter 2
+        dec size
+    endwhile
+    not iter
+    inc iter
+    div iter 2
+    while iter!=0
+        if pos=0x80
+            set dest# 0
+        endif
+        sd test
+        set test iter
+        and test value
+        if test!=0
+            or dest# pos
+        endif
+        div pos 2
+        if pos=0
+            set pos 0x80
+            inc dest
+        endif
+        div iter 2
+    endwhile
+    set p_dest# dest
+    set p_pos# pos
+endfunction
+
+
+function num_bits(sd value)
+    sd sign=~0x7fFFffFF
+    and sign value
+    sd mask=~0x7fFFffFF
+    sd i=32
+    while i!=0
+        dec i
+        div mask 2
+        sd test
+        set test mask
+        and test value
+        if sign=0
+            if test!=0
+                return i
+            endif
+        else
+            if test!=mask
+                return i
+            endif
+        endelse
+    endwhile
+    return i
+endfunction
+
+function numbitsMax(sd width,sd height)
+    sd value1
+    setcall value1 num_bits(width)
+    sd value2
+    setcall value2 num_bits(height)
+    sd NBits
+    set NBits value1
+    if value2>value1
+        set NBits value2
+    endif
+    #is signed
+    inc NBits
+    return NBits
+endfunction
+
+function rect_prepare(sv p_out,sv p_size,sd width,sd height)  #p_size is a stack variable
+    sd NBits
+    mult width 20
+    mult height 20
+    setcall NBits numbitsMax(width,height)
+    char rect#31*4+5
+    call bits_packs(#rect,5,NBits,(NBits_size),0,NBits,width,NBits,0,NBits,height,NBits)
+    sd size=4
+    mult size NBits
+    add size 5
+        #to bytes
+        add size 7
+        div size 8
+    set p_out# #rect
+    set p_size# size
+endfunction
+function matrix_translate(sv p_dest,sd p_size,sd x,sd y)
+    char matrix#1+4+4
+    set p_dest# #matrix
+    if x=0
+        if y=0
+            set matrix 0
+            set p_size# 1
+            return (void)
+        endif
+    endif
+    sd NBits
+    mult x 20
+    mult y 20
+    setcall NBits numbitsMax(x,y)
+    call bits_packs(#matrix,(3+2),0,1,0,1,NBits,(NBits_size),x,NBits,y,NBits)
+    sd size=2
+    mult size NBits
+    add size (1+1+5)
+        #to bytes
+        add size 7
+        div size 8
+
+	#this is no more than char matrix
+    set p_size# size
+endfunction
+
+
+
+
+
+aftercallimport ebool
+
+
+
+#
+import "swf_mem_add" swf_mem_add
+function rect_add(sd width,sd height)
+    sd mem
+    sd sz
+    call rect_prepare(#mem,#sz,width,height)
+    call swf_mem_add(mem,sz)
+endfunction
--- actionswf-1.orig/src/bits.s
+++ /dev/null
@@ -1,151 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-function bits_packs(ss dest,sd packs)
-    sd i=0
-    sd pos=0x80
-    sd value
-    sd size
-    sd src^packs
-    while i<packs
-        incst src
-        set value src#
-        incst src
-        set size src#
-        call bits_bigendian(value,size,#dest,#pos)
-        inc i
-    endwhile
-endfunction
-function bits_bigendian(sd value,sd size,sv p_dest,sd p_pos)
-    ss dest
-    sd pos
-    set dest p_dest#
-    set pos p_pos#
-    sd iter=-1
-    while size!=0
-        mult iter 2
-        dec size
-    endwhile
-    not iter
-    inc iter
-    div iter 2
-    while iter!=0
-        if pos=0x80
-            set dest# 0
-        endif
-        sd test
-        set test iter
-        and test value
-        if test!=0
-            or dest# pos
-        endif
-        div pos 2
-        if pos=0
-            set pos 0x80
-            inc dest
-        endif
-        div iter 2
-    endwhile
-    set p_dest# dest
-    set p_pos# pos
-endfunction
-
-
-function num_bits(sd value)
-    sd sign=~0x7fFFffFF
-    and sign value
-    sd mask=~0x7fFFffFF
-    sd i=32
-    while i!=0
-        dec i
-        div mask 2
-        sd test
-        set test mask
-        and test value
-        if sign=0
-            if test!=0
-                return i
-            endif
-        else
-            if test!=mask
-                return i
-            endif
-        endelse
-    endwhile
-    return i
-endfunction
-
-function numbitsMax(sd width,sd height)
-    sd value1
-    setcall value1 num_bits(width)
-    sd value2
-    setcall value2 num_bits(height)
-    sd NBits
-    set NBits value1
-    if value2>value1
-        set NBits value2
-    endif
-    #is signed
-    inc NBits
-    return NBits
-endfunction
-
-function rect_prepare(sv p_out,sv p_size,sd width,sd height)  #p_size is a stack variable
-    sd NBits
-    mult width 20
-    mult height 20
-    setcall NBits numbitsMax(width,height)
-    char rect#31*4+5
-    call bits_packs(#rect,5,NBits,(NBits_size),0,NBits,width,NBits,0,NBits,height,NBits)
-    sd size=4
-    mult size NBits
-    add size 5
-        #to bytes
-        add size 7
-        div size 8
-    set p_out# #rect
-    set p_size# size
-endfunction
-function matrix_translate(sv p_dest,sd p_size,sd x,sd y)
-    char matrix#1+4+4
-    set p_dest# #matrix
-    if x=0
-        if y=0
-            set matrix 0
-            set p_size# 1
-            return (void)
-        endif
-    endif
-    sd NBits
-    mult x 20
-    mult y 20
-    setcall NBits numbitsMax(x,y)
-    call bits_packs(#matrix,(3+2),0,1,0,1,NBits,(NBits_size),x,NBits,y,NBits)
-    sd size=2
-    mult size NBits
-    add size (1+1+5)
-        #to bytes
-        add size 7
-        div size 8
-
-	#this is no more than char matrix
-    set p_size# size
-endfunction
-
-
-
-
-
-importaftercall ebool
-
-
-
-#
-import "swf_mem_add" swf_mem_add
-function rect_add(sd width,sd height)
-    sd mem
-    sd sz
-    call rect_prepare(#mem,#sz,width,height)
-    call swf_mem_add(mem,sz)
-endfunction
--- /dev/null
+++ actionswf-1/src/character.oc
@@ -0,0 +1,450 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+import "identifiers_get" identifiers_get
+import "dword_to_word_arg" dword_to_word_arg
+
+#value
+function args_advance(sv p_args)
+    sd value
+    set value p_args#
+    add p_args# (DWORD)
+    return value#
+endfunction
+const max_char_records=256
+function shapewithstyle_records()
+    char shapewithstyle_record#max_char_records
+    return #shapewithstyle_record
+endfunction
+
+import "bits_bigendian" bits_bigendian
+import "numbitsMax" numbitsMax
+
+#n
+function shape_records_NumBits(sd p_val)
+    sd val=-2;add val p_val#
+    if val<0
+        mult val -1;add p_val# val
+        return 0
+    endif
+    return val
+endfunction
+#get:fill/lin
+function NumFill_NumLin(sd set_get,sd fill,sd lin)
+    data NFill_NLin#1
+    if set_get=0
+        set NFill_NLin lin;mult fill 0x10;or NFill_NLin fill
+    else
+        if fill=(FALSE);set lin NFill_NLin;and lin 0x0F;return lin
+        else;set fill NFill_NLin;div fill 0x10;return fill;endelse
+    endelse
+endfunction
+
+#edittext
+
+const sim64pointerSize=pointer_rest
+#struct
+function edittext_struct()
+    data fontid#1
+    data *font_height#1
+    str *fontclassname#1;char *sim64pointer#sim64pointerSize
+    data *rgba#1
+    data *maxlength#1
+    str *initialtext#1;char *sim64pointer#sim64pointerSize
+    data *layout_align#1
+    data *layout_leftmargin#1
+    data *layout_rightmargin#1
+    data *layout_indent#1
+    data *layout_leading#1
+    return #fontid
+endfunction
+function edittext_font(sd fontid,sd fontheight)
+    sd s
+    setcall s edittext_struct()
+    set s# fontid
+    add s (DWORD)
+    set s# fontheight
+endfunction
+function edittext_rgba(sd val)
+    sd ed_str
+    setcall ed_str edittext_struct()
+    add ed_str (3*DWORD+sim64pointerSize);set ed_str# val
+endfunction
+function edittext_layout(sd in_args)
+    sd s
+    setcall s edittext_struct()
+    add s (6*DWORD+sim64pointerSize+sim64pointerSize)
+    set s# in_args#
+    add s (DWORD);add in_args (DWORD);set s# in_args#
+    add s (DWORD);add in_args (DWORD);set s# in_args#
+    add s (DWORD);add in_args (DWORD);set s# in_args#
+    add s (DWORD);add in_args (DWORD);set s# in_args#
+endfunction
+function edittext_text(ss text)
+    sv s
+    setcall s edittext_struct()
+    add s (5*DWORD+sim64pointerSize)
+    set s# text
+endfunction
+
+function button_mem()
+    data up#1
+    data *over#1
+	data *hit#1
+
+    data *width#1
+    data *height#1
+
+    data *no_text#1
+    data *font_id#1
+    data *font_height#1
+    data *y#1
+    data *font_color#1
+
+    return #up
+endfunction
+
+import "free_sprite_id" free_sprite_id
+import "matrix_translate" matrix_translate
+
+import "action_size" action_size
+
+
+
+
+aftercallimport ebool
+
+importx "swf_text" swf_text
+importx "swf_shape" swf_shape
+
+importx "action_sprite" action_sprite
+
+
+#shape
+
+import "error" error
+function shape_records_bits(sd value,sd size,sv p_dest_pos)
+    #why was this here? data start#1
+    #and this, this is called through shape_records_add    if p_dest_pos==0
+    #	set start value
+    #	return (void)
+    #endif
+    sd pointer
+    set pointer p_dest_pos#
+    subcall pointer shapewithstyle_records()
+    if pointer=(max_char_records)
+    #was >=
+        call error("too many arguments at shape")
+    endif
+    sd p_pos
+    set p_pos p_dest_pos
+    add p_pos :
+    call bits_bigendian(value,size,p_dest_pos,p_pos)
+endfunction
+function shape_records_add(sd p_dest_pos,sd p_args)
+    sd edge
+    setcall edge args_advance(p_args)
+    call shape_records_bits(edge,1,p_dest_pos)
+    if edge=0
+    #StyleChangeRecord,#EndShapeRecord
+        sd flags
+        setcall flags args_advance(p_args)
+        call shape_records_bits(flags,5,p_dest_pos)
+        if flags=0
+        #EndShapeRecord
+            return (void)
+        endif
+        #StateMoveTo
+        call shape_records_add_moveto(p_dest_pos,flags,p_args)
+        #
+        sd f_l_bits
+        sd fill
+        #StateFillStyle0
+        set fill flags;and fill (StateFillStyle0)
+        if fill!=0
+            setcall f_l_bits NumFill_NumLin(1,(TRUE));call shape_records_bits(1,f_l_bits,p_dest_pos)
+        endif
+        #StateFillStyle1
+        set fill flags;and fill (StateFillStyle1)
+        if fill!=0
+            setcall f_l_bits NumFill_NumLin(1,(TRUE));call shape_records_bits(1,f_l_bits,p_dest_pos)
+        endif
+        #StateLineStyle
+        and flags (StateLineStyle)
+        if flags!=0
+            setcall f_l_bits NumFill_NumLin(1,(FALSE))
+            call shape_records_bits(1,f_l_bits,p_dest_pos)
+        endif
+        return (void)
+    endif
+    call shape_records_add_edge(p_dest_pos,p_args)
+endfunction
+function shape_records_add_moveto(sd p_dest_pos,sd flags,sd p_args)
+    and flags (StateMoveTo)
+    if flags=0
+        return (void)
+    endif
+    sd x
+    setcall x args_advance(p_args)
+    sd y
+    setcall y args_advance(p_args)
+    sd numbits
+    mult x 20
+    mult y 20
+    setcall numbits numbitsMax(x,y)
+    call shape_records_bits(numbits,(NBits_size),p_dest_pos)
+    call shape_records_bits(x,numbits,p_dest_pos)
+    call shape_records_bits(y,numbits,p_dest_pos)
+endfunction
+function shape_records_add_edge(sd p_dest_pos,sd p_args)
+    sd straight_edge
+    setcall straight_edge args_advance(p_args)
+    call shape_records_bits(straight_edge,1,p_dest_pos)
+    if straight_edge=1
+        call shape_records_add_edge_straight(p_dest_pos,p_args)
+    else
+        call shape_records_add_edge_curved(p_dest_pos,p_args)
+    endelse
+endfunction
+function shape_records_add_edge_straight(sd p_dest_pos,sd p_args)
+    sd width=20;multCall width args_advance(p_args)
+    sd height=20;multCall height args_advance(p_args)
+    sd counter;setcall counter numbitsMax(width,height)
+    #NumBits(UB[4])
+    sd NumBits;setcall NumBits shape_records_NumBits(#counter)
+    call shape_records_bits(NumBits,4,p_dest_pos)
+    #GeneralLineFlag
+    sd GeneralLineFlag=0
+    if width!=0;if height!=0;set GeneralLineFlag 1;endif;endif
+    call shape_records_bits(GeneralLineFlag,1,p_dest_pos)
+    #Vert(1)/Horz(0)
+    if GeneralLineFlag=0
+        sd vertical=1;if width!=0;set vertical 0;endif
+        call shape_records_bits(vertical,1,p_dest_pos)
+    endif
+    #DeltaX SB[NumBits+2]
+    sd DeltaX=TRUE;if GeneralLineFlag=0;if vertical=1;set DeltaX (FALSE);endif;endif
+    if DeltaX=(TRUE);call shape_records_bits(width,counter,p_dest_pos);endif
+    #DeltaY SB[NumBits+2]
+    sd DeltaY=TRUE;if GeneralLineFlag=0;if vertical=0;set DeltaY (FALSE);endif;endif
+    if DeltaY=(TRUE);call shape_records_bits(height,counter,p_dest_pos);endif
+endfunction
+function shape_records_add_edge_curved(sd p_dest_pos,sd p_args)
+    sd control_x
+    setcall control_x args_advance(p_args)
+    sd control_y
+    setcall control_y args_advance(p_args)
+    sd anchor_x
+    setcall anchor_x args_advance(p_args)
+    sd anchor_y
+    setcall anchor_y args_advance(p_args)
+    mult control_x 20
+    mult control_y 20
+    mult anchor_x 20
+    mult anchor_y 20
+    sd numbits
+    sd numbits2
+    setcall numbits numbitsMax(control_x,control_y)
+    setcall numbits2 numbitsMax(anchor_x,anchor_y)
+    if numbits2>numbits
+        set numbits numbits2
+    endif
+    #NumBits(UB[4])
+    sd Num_Bits;setcall Num_Bits shape_records_NumBits(#numbits)
+    call shape_records_bits(Num_Bits,4,p_dest_pos)
+    #SB[NumBits+2]
+    call shape_records_bits(control_x,numbits,p_dest_pos)
+    call shape_records_bits(control_y,numbits,p_dest_pos)
+    call shape_records_bits(anchor_x,numbits,p_dest_pos)
+    call shape_records_bits(anchor_y,numbits,p_dest_pos)
+endfunction
+#id
+function swf_shape_simple(sd width,sd height,sd fillcolor,sd lineheight,sd linecolor,sd xcurve,sd ycurve)
+    sd wd;set wd width;sub wd lineheight
+    sd hg;set hg height;sub hg lineheight
+    sd test
+    set test lineheight;mult test 2;if test>width;call error("lineheight value against width is too high for shape");endif
+    set test lineheight;mult test 2;if test>height;call error("lineheight value against height is too high for shape");endif
+    set test wd;div test 2;if xcurve>wd;call error("xcurve value is too high for shape");endif
+    set test hg;div test 2;if ycurve>hg;call error("ycurve value is too high for shape");endif
+    sd lineheight_hf;set lineheight_hf lineheight;div lineheight_hf 2
+
+    sd width_variable
+    sd height_variable
+    set width_variable wd
+    set height_variable hg
+    sub width_variable xcurve
+    sub width_variable xcurve
+    sub height_variable ycurve
+    sub height_variable ycurve
+
+    data header#4
+    sd struct^header;if lineheight=0;add struct (DWORD);endif
+    sd cursor;set cursor struct
+    set cursor# (solid_fill)
+    add cursor (DWORD);set cursor# fillcolor
+    add cursor (DWORD);set cursor# lineheight
+    if lineheight!=0;add cursor (DWORD);set cursor# linecolor;endif
+    #the header is connected with the part below
+    data *=0
+    data styles#1;set styles (StateFillStyle0|StateMoveTo);if lineheight!=0;or styles (StateLineStyle);endif
+        data x_move#1;set x_move lineheight_hf;add x_move xcurve
+        data y_move#1;set y_move lineheight_hf
+
+    data *={1,1}
+        data w1#1;data *=0
+        set w1 width_variable
+    data *={1,0}
+        data xNE#1
+        set xNE xcurve
+        data *={0,0}
+        data yNE#1
+        set yNE ycurve
+    data *={1,1}
+        data *=0;data h1#1
+        set h1 height_variable
+    data *={1,0}
+        data *=0
+        data ySE#1
+        set ySE ycurve
+        data xSE#1
+        mult xcurve -1
+        set xSE xcurve
+        data *=0
+    data *={1,1}
+        data w2#1;data *=0
+        mult width_variable -1
+        set w2 width_variable
+    data *={1,0}
+        data xSV#1
+        set xSV xcurve
+        data *={0,0}
+        mult ycurve -1
+        data ySV#1
+        set ySV ycurve
+    data *={1,1}
+        data *=0;data h2#1
+        mult height_variable -1
+        set h2 height_variable
+    data *={1,0}
+        data *=0
+        data yNV#1
+        set yNV ycurve
+        data xNV#1
+        mult xcurve -1
+        set xNV xcurve
+        data *=0
+    data *=-1
+    sd id
+    setcall id swf_shape(width,height,struct)
+    return id
+endfunction
+
+#id
+function swf_text_initial_font_centered(sd width,sd height,ss text,sd font_id,sd font_height,sd font_color)
+    call edittext_font(font_id,font_height)
+    call edittext_rgba(font_color)
+    data layout={layout_align_center,0,0,0,0}
+    call edittext_layout(#layout)
+    call edittext_text(text)
+    sd e_struct
+    setcall e_struct edittext_struct()
+    sd text_id
+    setcall text_id swf_text(width,height,"",(HasFont|HasText|HasTextColor|HasLayout|ReadOnly|NoSelect),e_struct)
+    return text_id
+endfunction
+
+#button
+
+import "swf_tag_recordheader_entry" swf_tag_recordheader_entry
+import "swf_mem_add" swf_mem_add
+#id
+function swf_button_base(sd state_def_id,sd state_over_id,sd state_down_id,sd noText,sd text_id,sd y,ss actions)
+    sd size=2+1+2;#ButtonId,TrackAsMenu,ActionOffset
+
+    sd Characters_CharacterEndFlag_size
+    setcall Characters_CharacterEndFlag_size buttonrecord(0,0,0)
+    mult Characters_CharacterEndFlag_size 3
+    if noText=(FALSE)
+        addcall Characters_CharacterEndFlag_size buttonrecord(0,0,y)
+    endif
+    inc Characters_CharacterEndFlag_size
+
+    add size Characters_CharacterEndFlag_size
+
+    char BUTTONCONDACTION={0,0};#CondActionSize
+    char *={8,0};#CondOverDownToOverUp
+    const BUTTONCONDACTION_header_size=2+2
+    #is action,pool and sprite, it's more code to get action,pool only
+    import "new_sprite_id" new_sprite_id
+    sd id
+    setcall id new_sprite_id()
+    call action_sprite(id,actions)
+
+    add size (BUTTONCONDACTION_header_size)
+    addcall size action_size(id)
+
+    call swf_tag_recordheader_entry((DefineButton2),size)
+    sd ButtonId
+    setcall ButtonId identifiers_get()
+    call swf_mem_add(#ButtonId,2)
+    char TrackAsMenu=0
+    call swf_mem_add(#TrackAsMenu,(BYTE))
+    sd ActionOffset=2;add ActionOffset Characters_CharacterEndFlag_size
+    call swf_mem_add(#ActionOffset,(WORD))
+
+    call buttonrecord(1,0,0,(ButtonStateUp),state_def_id,1)
+    call buttonrecord(1,0,0,(ButtonStateOver),state_over_id,2)
+	call buttonrecord(1,0,0,(ButtonStateDown|ButtonStateHitTest),state_down_id,3)
+    if noText=(FALSE)
+        call buttonrecord(1,0,y,(ButtonStateUp|ButtonStateOver|ButtonStateDown|ButtonStateHitTest),text_id,4)
+    endif
+    char CharacterEndFlag=0
+    call swf_mem_add(#CharacterEndFlag,1)
+    import "write_action" write_action
+    call swf_mem_add(#BUTTONCONDACTION,(BUTTONCONDACTION_header_size))
+    call write_action(id)
+
+    call free_sprite_id(id)
+    return ButtonId
+endfunction
+
+#size/void
+function buttonrecord(sd writeflag,sd x,sd y,sd states,sd id,sd depth)
+    #ButtonReserved[2]=0,ButtonHasBlendMode[1]=0,ButtonHasFilterList[1]=0
+    #states[4]
+    char bits#1
+    char CharacterID#2
+    char PlaceDepth#2
+
+    sd size=1+2+2
+
+    if writeflag=1
+        set bits states
+        call dword_to_word_arg(id,#CharacterID)
+        call dword_to_word_arg(depth,#PlaceDepth)
+        call swf_mem_add(#bits,size)
+    endif
+
+    #PlaceMatrix
+    sd matrix
+    datax matrixsz#1
+    call matrix_translate(#matrix,#matrixsz,x,y)
+    if writeflag=1
+        call swf_mem_add(matrix,matrixsz)
+    else
+        add size matrixsz
+    endelse
+
+    char CXFORMWITHALPHA=0
+    if writeflag=1
+        call swf_mem_add(#CXFORMWITHALPHA,(BYTE))
+    else
+        add size (BYTE)
+    endelse
+
+    if writeflag=0
+        return size
+    endif
+endfunction
--- actionswf-1.orig/src/character.s
+++ /dev/null
@@ -1,450 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-import "identifiers_get" identifiers_get
-import "dword_to_word_arg" dword_to_word_arg
-
-#value
-function args_advance(sv p_args)
-    sd value
-    set value p_args#
-    add p_args# (DWORD)
-    return value#
-endfunction
-const max_char_records=256
-function shapewithstyle_records()
-    char shapewithstyle_record#max_char_records
-    return #shapewithstyle_record
-endfunction
-
-import "bits_bigendian" bits_bigendian
-import "numbitsMax" numbitsMax
-
-#n
-function shape_records_NumBits(sd p_val)
-    sd val=-2;add val p_val#
-    if val<0
-        mult val -1;add p_val# val
-        return 0
-    endif
-    return val
-endfunction
-#get:fill/lin
-function NumFill_NumLin(sd set_get,sd fill,sd lin)
-    data NFill_NLin#1
-    if set_get=0
-        set NFill_NLin lin;mult fill 0x10;or NFill_NLin fill
-    else
-        if fill=(FALSE);set lin NFill_NLin;and lin 0x0F;return lin
-        else;set fill NFill_NLin;div fill 0x10;return fill;endelse
-    endelse
-endfunction
-
-#edittext
-
-const sim64pointerSize=pointer_rest
-#struct
-function edittext_struct()
-    data fontid#1
-    data *font_height#1
-    str *fontclassname#1;char *sim64pointer#sim64pointerSize
-    data *rgba#1
-    data *maxlength#1
-    str *initialtext#1;char *sim64pointer#sim64pointerSize
-    data *layout_align#1
-    data *layout_leftmargin#1
-    data *layout_rightmargin#1
-    data *layout_indent#1
-    data *layout_leading#1
-    return #fontid
-endfunction
-function edittext_font(sd fontid,sd fontheight)
-    sd s
-    setcall s edittext_struct()
-    set s# fontid
-    add s (DWORD)
-    set s# fontheight
-endfunction
-function edittext_rgba(sd val)
-    sd ed_str
-    setcall ed_str edittext_struct()
-    add ed_str (3*DWORD+sim64pointerSize);set ed_str# val
-endfunction
-function edittext_layout(sd in_args)
-    sd s
-    setcall s edittext_struct()
-    add s (6*DWORD+sim64pointerSize+sim64pointerSize)
-    set s# in_args#
-    add s (DWORD);add in_args (DWORD);set s# in_args#
-    add s (DWORD);add in_args (DWORD);set s# in_args#
-    add s (DWORD);add in_args (DWORD);set s# in_args#
-    add s (DWORD);add in_args (DWORD);set s# in_args#
-endfunction
-function edittext_text(ss text)
-    sv s
-    setcall s edittext_struct()
-    add s (5*DWORD+sim64pointerSize)
-    set s# text
-endfunction
-
-function button_mem()
-    data up#1
-    data *over#1
-	data *hit#1
-
-    data *width#1
-    data *height#1
-
-    data *no_text#1
-    data *font_id#1
-    data *font_height#1
-    data *y#1
-    data *font_color#1
-
-    return #up
-endfunction
-
-import "free_sprite_id" free_sprite_id
-import "matrix_translate" matrix_translate
-
-import "action_size" action_size
-
-
-
-
-importaftercall ebool
-
-importx "swf_text" swf_text
-importx "swf_shape" swf_shape
-
-importx "action_sprite" action_sprite
-
-
-#shape
-
-import "error" error
-function shape_records_bits(sd value,sd size,sv p_dest_pos)
-    #why was this here? data start#1
-    #and this, this is called through shape_records_add    if p_dest_pos==0
-    #	set start value
-    #	return (void)
-    #endif
-    sd pointer
-    set pointer p_dest_pos#
-    subcall pointer shapewithstyle_records()
-    if pointer=(max_char_records)
-    #was >=
-        call error("too many arguments at shape")
-    endif
-    sd p_pos
-    set p_pos p_dest_pos
-    add p_pos :
-    call bits_bigendian(value,size,p_dest_pos,p_pos)
-endfunction
-function shape_records_add(sd p_dest_pos,sd p_args)
-    sd edge
-    setcall edge args_advance(p_args)
-    call shape_records_bits(edge,1,p_dest_pos)
-    if edge=0
-    #StyleChangeRecord,#EndShapeRecord
-        sd flags
-        setcall flags args_advance(p_args)
-        call shape_records_bits(flags,5,p_dest_pos)
-        if flags=0
-        #EndShapeRecord
-            return (void)
-        endif
-        #StateMoveTo
-        call shape_records_add_moveto(p_dest_pos,flags,p_args)
-        #
-        sd f_l_bits
-        sd fill
-        #StateFillStyle0
-        set fill flags;and fill (StateFillStyle0)
-        if fill!=0
-            setcall f_l_bits NumFill_NumLin(1,(TRUE));call shape_records_bits(1,f_l_bits,p_dest_pos)
-        endif
-        #StateFillStyle1
-        set fill flags;and fill (StateFillStyle1)
-        if fill!=0
-            setcall f_l_bits NumFill_NumLin(1,(TRUE));call shape_records_bits(1,f_l_bits,p_dest_pos)
-        endif
-        #StateLineStyle
-        and flags (StateLineStyle)
-        if flags!=0
-            setcall f_l_bits NumFill_NumLin(1,(FALSE))
-            call shape_records_bits(1,f_l_bits,p_dest_pos)
-        endif
-        return (void)
-    endif
-    call shape_records_add_edge(p_dest_pos,p_args)
-endfunction
-function shape_records_add_moveto(sd p_dest_pos,sd flags,sd p_args)
-    and flags (StateMoveTo)
-    if flags=0
-        return (void)
-    endif
-    sd x
-    setcall x args_advance(p_args)
-    sd y
-    setcall y args_advance(p_args)
-    sd numbits
-    mult x 20
-    mult y 20
-    setcall numbits numbitsMax(x,y)
-    call shape_records_bits(numbits,(NBits_size),p_dest_pos)
-    call shape_records_bits(x,numbits,p_dest_pos)
-    call shape_records_bits(y,numbits,p_dest_pos)
-endfunction
-function shape_records_add_edge(sd p_dest_pos,sd p_args)
-    sd straight_edge
-    setcall straight_edge args_advance(p_args)
-    call shape_records_bits(straight_edge,1,p_dest_pos)
-    if straight_edge=1
-        call shape_records_add_edge_straight(p_dest_pos,p_args)
-    else
-        call shape_records_add_edge_curved(p_dest_pos,p_args)
-    endelse
-endfunction
-function shape_records_add_edge_straight(sd p_dest_pos,sd p_args)
-    sd width=20;multCall width args_advance(p_args)
-    sd height=20;multCall height args_advance(p_args)
-    sd counter;setcall counter numbitsMax(width,height)
-    #NumBits(UB[4])
-    sd NumBits;setcall NumBits shape_records_NumBits(#counter)
-    call shape_records_bits(NumBits,4,p_dest_pos)
-    #GeneralLineFlag
-    sd GeneralLineFlag=0
-    if width!=0;if height!=0;set GeneralLineFlag 1;endif;endif
-    call shape_records_bits(GeneralLineFlag,1,p_dest_pos)
-    #Vert(1)/Horz(0)
-    if GeneralLineFlag=0
-        sd vertical=1;if width!=0;set vertical 0;endif
-        call shape_records_bits(vertical,1,p_dest_pos)
-    endif
-    #DeltaX SB[NumBits+2]
-    sd DeltaX=TRUE;if GeneralLineFlag=0;if vertical=1;set DeltaX (FALSE);endif;endif
-    if DeltaX=(TRUE);call shape_records_bits(width,counter,p_dest_pos);endif
-    #DeltaY SB[NumBits+2]
-    sd DeltaY=TRUE;if GeneralLineFlag=0;if vertical=0;set DeltaY (FALSE);endif;endif
-    if DeltaY=(TRUE);call shape_records_bits(height,counter,p_dest_pos);endif
-endfunction
-function shape_records_add_edge_curved(sd p_dest_pos,sd p_args)
-    sd control_x
-    setcall control_x args_advance(p_args)
-    sd control_y
-    setcall control_y args_advance(p_args)
-    sd anchor_x
-    setcall anchor_x args_advance(p_args)
-    sd anchor_y
-    setcall anchor_y args_advance(p_args)
-    mult control_x 20
-    mult control_y 20
-    mult anchor_x 20
-    mult anchor_y 20
-    sd numbits
-    sd numbits2
-    setcall numbits numbitsMax(control_x,control_y)
-    setcall numbits2 numbitsMax(anchor_x,anchor_y)
-    if numbits2>numbits
-        set numbits numbits2
-    endif
-    #NumBits(UB[4])
-    sd Num_Bits;setcall Num_Bits shape_records_NumBits(#numbits)
-    call shape_records_bits(Num_Bits,4,p_dest_pos)
-    #SB[NumBits+2]
-    call shape_records_bits(control_x,numbits,p_dest_pos)
-    call shape_records_bits(control_y,numbits,p_dest_pos)
-    call shape_records_bits(anchor_x,numbits,p_dest_pos)
-    call shape_records_bits(anchor_y,numbits,p_dest_pos)
-endfunction
-#id
-function swf_shape_simple(sd width,sd height,sd fillcolor,sd lineheight,sd linecolor,sd xcurve,sd ycurve)
-    sd wd;set wd width;sub wd lineheight
-    sd hg;set hg height;sub hg lineheight
-    sd test
-    set test lineheight;mult test 2;if test>width;call error("lineheight value against width is too high for shape");endif
-    set test lineheight;mult test 2;if test>height;call error("lineheight value against height is too high for shape");endif
-    set test wd;div test 2;if xcurve>wd;call error("xcurve value is too high for shape");endif
-    set test hg;div test 2;if ycurve>hg;call error("ycurve value is too high for shape");endif
-    sd lineheight_hf;set lineheight_hf lineheight;div lineheight_hf 2
-
-    sd width_variable
-    sd height_variable
-    set width_variable wd
-    set height_variable hg
-    sub width_variable xcurve
-    sub width_variable xcurve
-    sub height_variable ycurve
-    sub height_variable ycurve
-
-    data header#4
-    sd struct^header;if lineheight=0;add struct (DWORD);endif
-    sd cursor;set cursor struct
-    set cursor# (solid_fill)
-    add cursor (DWORD);set cursor# fillcolor
-    add cursor (DWORD);set cursor# lineheight
-    if lineheight!=0;add cursor (DWORD);set cursor# linecolor;endif
-    #the header is connected with the part below
-    data *=0
-    data styles#1;set styles (StateFillStyle0|StateMoveTo);if lineheight!=0;or styles (StateLineStyle);endif
-        data x_move#1;set x_move lineheight_hf;add x_move xcurve
-        data y_move#1;set y_move lineheight_hf
-
-    data *={1,1}
-        data w1#1;data *=0
-        set w1 width_variable
-    data *={1,0}
-        data xNE#1
-        set xNE xcurve
-        data *={0,0}
-        data yNE#1
-        set yNE ycurve
-    data *={1,1}
-        data *=0;data h1#1
-        set h1 height_variable
-    data *={1,0}
-        data *=0
-        data ySE#1
-        set ySE ycurve
-        data xSE#1
-        mult xcurve -1
-        set xSE xcurve
-        data *=0
-    data *={1,1}
-        data w2#1;data *=0
-        mult width_variable -1
-        set w2 width_variable
-    data *={1,0}
-        data xSV#1
-        set xSV xcurve
-        data *={0,0}
-        mult ycurve -1
-        data ySV#1
-        set ySV ycurve
-    data *={1,1}
-        data *=0;data h2#1
-        mult height_variable -1
-        set h2 height_variable
-    data *={1,0}
-        data *=0
-        data yNV#1
-        set yNV ycurve
-        data xNV#1
-        mult xcurve -1
-        set xNV xcurve
-        data *=0
-    data *=-1
-    sd id
-    setcall id swf_shape(width,height,struct)
-    return id
-endfunction
-
-#id
-function swf_text_initial_font_centered(sd width,sd height,ss text,sd font_id,sd font_height,sd font_color)
-    call edittext_font(font_id,font_height)
-    call edittext_rgba(font_color)
-    data layout={layout_align_center,0,0,0,0}
-    call edittext_layout(#layout)
-    call edittext_text(text)
-    sd e_struct
-    setcall e_struct edittext_struct()
-    sd text_id
-    setcall text_id swf_text(width,height,"",(HasFont|HasText|HasTextColor|HasLayout|ReadOnly|NoSelect),e_struct)
-    return text_id
-endfunction
-
-#button
-
-import "swf_tag_recordheader_entry" swf_tag_recordheader_entry
-import "swf_mem_add" swf_mem_add
-#id
-function swf_button_base(sd state_def_id,sd state_over_id,sd state_down_id,sd noText,sd text_id,sd y,ss actions)
-    sd size=2+1+2;#ButtonId,TrackAsMenu,ActionOffset
-
-    sd Characters_CharacterEndFlag_size
-    setcall Characters_CharacterEndFlag_size buttonrecord(0,0,0)
-    mult Characters_CharacterEndFlag_size 3
-    if noText=(FALSE)
-        addcall Characters_CharacterEndFlag_size buttonrecord(0,0,y)
-    endif
-    inc Characters_CharacterEndFlag_size
-
-    add size Characters_CharacterEndFlag_size
-
-    char BUTTONCONDACTION={0,0};#CondActionSize
-    char *={8,0};#CondOverDownToOverUp
-    const BUTTONCONDACTION_header_size=2+2
-    #is action,pool and sprite, it's more code to get action,pool only
-    import "new_sprite_id" new_sprite_id
-    sd id
-    setcall id new_sprite_id()
-    call action_sprite(id,actions)
-
-    add size (BUTTONCONDACTION_header_size)
-    addcall size action_size(id)
-
-    call swf_tag_recordheader_entry((DefineButton2),size)
-    sd ButtonId
-    setcall ButtonId identifiers_get()
-    call swf_mem_add(#ButtonId,2)
-    char TrackAsMenu=0
-    call swf_mem_add(#TrackAsMenu,(BYTE))
-    sd ActionOffset=2;add ActionOffset Characters_CharacterEndFlag_size
-    call swf_mem_add(#ActionOffset,(WORD))
-
-    call buttonrecord(1,0,0,(ButtonStateUp),state_def_id,1)
-    call buttonrecord(1,0,0,(ButtonStateOver),state_over_id,2)
-	call buttonrecord(1,0,0,(ButtonStateDown|ButtonStateHitTest),state_down_id,3)
-    if noText=(FALSE)
-        call buttonrecord(1,0,y,(ButtonStateUp|ButtonStateOver|ButtonStateDown|ButtonStateHitTest),text_id,4)
-    endif
-    char CharacterEndFlag=0
-    call swf_mem_add(#CharacterEndFlag,1)
-    import "write_action" write_action
-    call swf_mem_add(#BUTTONCONDACTION,(BUTTONCONDACTION_header_size))
-    call write_action(id)
-
-    call free_sprite_id(id)
-    return ButtonId
-endfunction
-
-#size/void
-function buttonrecord(sd writeflag,sd x,sd y,sd states,sd id,sd depth)
-    #ButtonReserved[2]=0,ButtonHasBlendMode[1]=0,ButtonHasFilterList[1]=0
-    #states[4]
-    char bits#1
-    char CharacterID#2
-    char PlaceDepth#2
-
-    sd size=1+2+2
-
-    if writeflag=1
-        set bits states
-        call dword_to_word_arg(id,#CharacterID)
-        call dword_to_word_arg(depth,#PlaceDepth)
-        call swf_mem_add(#bits,size)
-    endif
-
-    #PlaceMatrix
-    sd matrix
-    datax matrixsz#1
-    call matrix_translate(#matrix,#matrixsz,x,y)
-    if writeflag=1
-        call swf_mem_add(matrix,matrixsz)
-    else
-        add size matrixsz
-    endelse
-
-    char CXFORMWITHALPHA=0
-    if writeflag=1
-        call swf_mem_add(#CXFORMWITHALPHA,(BYTE))
-    else
-        add size (BYTE)
-    endelse
-
-    if writeflag=0
-        return size
-    endif
-endfunction
--- /dev/null
+++ actionswf-1/src/debug.oc
@@ -0,0 +1,233 @@
+
+format elfobj64
+
+include "../include/prog.h"
+
+function debug_mark()
+	valuex row#1
+	return #row
+endfunction
+function debug_mark_start()
+	sv a;setcall a debug_mark()
+	set a# 0
+endfunction
+function debug_mark_add()
+	sv a;setcall a debug_mark()
+	add a# :
+endfunction
+function debug_mark_get()
+	value offsets=NULL
+	const p_offsets^offsets
+
+	sv a;setcall a debug_mark()
+	sv b;set b a#
+	add b offsets
+	return b
+endfunction
+
+function debug_target()
+	valuex a#1
+	return #a
+endfunction
+
+function debug_end()
+	valuex a#1
+	return #a
+endfunction
+function debug_actions()
+	datax a#1  #65535
+	return #a
+endfunction
+
+import "mem_free" mem_free
+import "f_close" f_close
+
+function debug_free()
+	sv of%p_offsets
+	if of#!=(NULL)
+		call mem_free(of)
+		value file=NULL
+		const p_debug_file^file
+		call f_close(#file)
+	endif
+endfunction
+
+function debug_phase_init(ss pointer)
+	sv of%p_offsets
+	if of#!=(NULL)
+		sv a;setcall a debug_mark_get()
+		set a# pointer
+		call debug_mark_add()
+	endif
+endfunction
+function debug_phase_parse(ss pointer)
+	sv of%p_offsets
+	if of#!=(NULL)
+		sv a
+		sv start;setcall start debug_mark_get()
+		sv target;setcall target debug_target()
+		if target#=(NULL)
+		#need to know empty rows
+			set a start
+			while pointer>a#
+				incst a
+			endwhile
+			set target# a
+		else
+			set a target#
+		endelse
+		#if pointer>=^a#  # and > ? it's not with spaces at end, therefore ";   \nabc" can go wrong
+		if pointer<^a#
+			ret
+		endif
+		import "action_code_get" action_code_get   #the pointer is not reallocated, can use offset but will be slower
+		sd x;setcall x action_code_get()
+		while start#<^pointer   #or a
+			set start# x
+			call debug_mark_add()
+			setcall start debug_mark_get()
+		endwhile
+		set start# x      ##also,set for this row, can be the only set
+		call debug_mark_add()
+		set target# (NULL)
+	endif
+endfunction
+function debug_phase_code_add()
+	sv of%p_offsets
+	if of#!=(NULL)
+		sd acts;setcall acts debug_actions()
+		inc acts#
+	endif
+endfunction
+
+function debug_action_phase()
+	sv of%p_offsets
+	if of#!=(NULL)
+		call debug_mark_start()  #second and third iteration
+	endif
+endfunction
+
+import "row_termination" row_termination
+
+importx "strlen" strlen
+importx "sprintf" sprintf
+importx "fwrite" fwrite
+
+
+
+aftercallimport ebool
+
+import "memalloc" memalloc
+import "f_open_mem" f_open_mem
+import "error" error
+
+function debug_init(sd flags,sd path)
+	sv of%p_offsets
+	if flags!=(debug_none)
+		setcall of# memalloc(0)
+
+		sd a;setcall a strlen(path)
+		add a 5
+		sd b;setcall b memalloc(a)
+		call sprintf(b,"%s.log",path)
+		sv file%p_debug_file
+		setcall file# f_open_mem(b,"wb")
+	endif
+endfunction
+
+import "f_printf" f_printf
+
+function debug_action_init(ss ac)
+	sv of%p_offsets
+	if of#!=(NULL)
+		sd start;set start ac
+
+		sd row=1     #at least one row, example: row 1,3 actions
+		while ac#!=0
+			call row_termination(#ac,#row)
+			inc ac
+		endwhile
+
+		#out rows\nac\n
+		sv file%p_debug_file
+		char f={Percent,l,u,LineFeed,Percent,s,LineFeed,Nullchar}
+		call f_printf((fprintf_min+2),file#,#f,row,start)
+
+		mult row :
+		import "memrealloc" memrealloc
+		setcall of# memrealloc(of#,row)
+
+		call debug_mark_start()  #prepare for first iteration
+
+		#set target to 0, for recognizing blank rows at second iteration
+		sv target;setcall target debug_target()
+		set target# (NULL)
+
+		add row of#
+		sv end;setcall end debug_end()   #at third iteration
+		set end# row
+		#
+		sd acts;setcall acts debug_actions()
+		set acts# 0
+	endif
+endfunction
+
+function debug_phase_code(sd codepointer)
+	sv of%p_offsets
+	if of#!=(NULL)
+		sv a;setcall a debug_mark_get()
+		if codepointer=a#   #can also be smaller
+			sv b;set b a
+			sv end;setcall end debug_end()
+			while codepointer=b#
+				call debug_mark_add()
+				setcall b debug_mark_get()
+				if b=end#
+					break
+				endif
+			endwhile
+			sub b a
+			div b :
+
+			#out rows,actions\n
+			sd acts;setcall acts debug_actions()
+			sv file%p_debug_file
+			char f={Percent,l,u,Comma,Percent,u,LineFeed,Nullchar}   #must escape \n or something
+			call f_printf((fprintf_min+2),file#,#f,b,acts#)
+			set acts# 0
+		endif
+	endif
+endfunction
+
+function debug_base_core(sd id)
+	sv file%p_debug_file
+	call f_printf((fprintf_min+1),file#,"%u\n",id) #swf_button is calling action_sprite
+end
+function debug_base(sd id)
+	sv of%p_offsets
+	if of#!=(NULL)
+		call debug_base_core(id)
+	end
+end
+function debug_show(sd id)
+	sv of%p_offsets
+	if of#!=(NULL)
+		call debug_base_core(id)
+		call debug_write("\n\n",2)
+	end
+end
+function debug_write(ss s,sd d)
+	sv file%p_debug_file
+	sd items;set items fwrite(s,d,1,file#) #...size,items...
+	if items!=1
+		call error("fwrite error")
+	end
+end
+function debug_spritedone(sd p,sd i)
+	sv of%p_offsets
+	if of#!=(NULL)
+		call debug_base_core(p)
+		call debug_write("\n",1)
+		call debug_base_core(i)
+	end
+end
--- actionswf-1.orig/src/debug.s
+++ /dev/null
@@ -1,222 +0,0 @@
-
-format elfobj64
-
-include "../include/prog.h"
-
-function debug_mark()
-	valuex row#1
-	return #row
-endfunction
-function debug_mark_start()
-	sv a;setcall a debug_mark()
-	set a# 0
-endfunction
-function debug_mark_add()
-	sv a;setcall a debug_mark()
-	add a# :
-endfunction
-function debug_mark_get()
-	value offsets=NULL
-	const p_offsets^offsets
-
-	sv a;setcall a debug_mark()
-	sv b;set b a#
-	add b offsets
-	return b
-endfunction
-
-function debug_target()
-	valuex a#1
-	return #a
-endfunction
-
-function debug_end()
-	valuex a#1
-	return #a
-endfunction
-function debug_actions()
-	datax a#1  #65535
-	return #a
-endfunction
-
-import "mem_free" mem_free
-import "f_close" f_close
-
-function debug_free()
-	sv of%p_offsets
-	if of#!=(NULL)
-		call mem_free(of)
-		value file=NULL
-		const p_debug_file^file
-		call f_close(#file)
-	endif
-endfunction
-
-function debug_phase_init(ss pointer)
-	sv of%p_offsets
-	if of#!=(NULL)
-		sv a;setcall a debug_mark_get()
-		set a# pointer
-		call debug_mark_add()
-	endif
-endfunction
-function debug_phase_parse(ss pointer)
-	sv of%p_offsets
-	if of#!=(NULL)
-		sv a
-		sv start;setcall start debug_mark_get()
-		sv target;setcall target debug_target()
-		if target#=(NULL)
-		#need to know empty rows
-			set a start
-			while pointer>a#
-				incst a
-			endwhile
-			set target# a
-		else
-			set a target#
-		endelse
-		#if pointer>=^a#  # and > ? it's not with spaces at end, therefore ";   \nabc" can go wrong
-		if pointer<^a#
-			ret
-		endif
-		import "action_code_get" action_code_get   #the pointer is not reallocated, can use offset but will be slower
-		sd x;setcall x action_code_get()
-		while start#<^pointer   #or a
-			set start# x
-			call debug_mark_add()
-			setcall start debug_mark_get()
-		endwhile
-		set start# x      ##also,set for this row, can be the only set
-		call debug_mark_add()
-		set target# (NULL)
-	endif
-endfunction
-function debug_phase_code_add()
-	sv of%p_offsets
-	if of#!=(NULL)
-		sd acts;setcall acts debug_actions()
-		inc acts#
-	endif
-endfunction
-
-function debug_action_phase()
-	sv of%p_offsets
-	if of#!=(NULL)
-		call debug_mark_start()  #second and third iteration
-	endif
-endfunction
-
-import "row_termination" row_termination
-
-importx "strlen" strlen
-importx "sprintf" sprintf
-importx "fwrite" fwrite
-
-
-
-importaftercall ebool
-
-import "memalloc" memalloc
-import "f_open_mem" f_open_mem
-import "error" error
-
-function debug_init(sd bool,sd path)
-	sv of%p_offsets
-	if bool=(TRUE)
-		setcall of# memalloc(0)
-
-		sd a;setcall a strlen(path)
-		add a 5
-		sd b;setcall b memalloc(a)
-		call sprintf(b,"%s.log",path)
-		sv file%p_debug_file
-		setcall file# f_open_mem(b,"wb")
-	endif
-endfunction
-
-import "f_printf" f_printf
-
-function debug_action_init(ss ac)
-	sv of%p_offsets
-	if of#!=(NULL)
-		sd start;set start ac
-
-		sd row=1     #at least one row, example: row 1,3 actions
-		while ac#!=0
-			call row_termination(#ac,#row)
-			inc ac
-		endwhile
-
-		#out rows\nac\n
-		sv file%p_debug_file
-		char f={Percent,l,u,LineFeed,Percent,s,LineFeed,Nullchar}
-		call f_printf((fprintf_min+2),file#,#f,row,start)
-
-		mult row :
-		import "memrealloc" memrealloc
-		setcall of# memrealloc(of#,row)
-
-		call debug_mark_start()  #prepare for first iteration
-
-		#set target to 0, for recognizing blank rows at second iteration
-		sv target;setcall target debug_target()
-		set target# (NULL)
-
-		add row of#
-		sv end;setcall end debug_end()   #at third iteration
-		set end# row
-		#
-		sd acts;setcall acts debug_actions()
-		set acts# 0
-	endif
-endfunction
-
-function debug_phase_code(sd codepointer)
-	sv of%p_offsets
-	if of#!=(NULL)
-		sv a;setcall a debug_mark_get()
-		if codepointer=a#   #can also be smaller
-			sv b;set b a
-			sv end;setcall end debug_end()
-			while codepointer=b#
-				call debug_mark_add()
-				setcall b debug_mark_get()
-				if b=end#
-					break
-				endif
-			endwhile
-			sub b a
-			div b :
-
-			#out rows,actions\n
-			sd acts;setcall acts debug_actions()
-			sv file%p_debug_file
-			char f={Percent,l,u,Comma,Percent,u,LineFeed,Nullchar}   #must escape \n or something
-			call f_printf((fprintf_min+2),file#,#f,b,acts#)
-			set acts# 0
-		endif
-	endif
-endfunction
-
-function debug_base_core(sd id)
-	sv file%p_debug_file
-	call f_printf((fprintf_min+1),file#,"%u\n",id) #swf_button is calling action_sprite
-end
-function debug_base(sd id)
-	sv of%p_offsets
-	if of#!=(NULL)
-		call debug_base_core(id)
-	end
-end
-function debug_show(sd id)
-	sv of%p_offsets
-	if of#!=(NULL)
-		call debug_base_core(id)
-		sv file%p_debug_file
-		sd items;set items fwrite("\n",1,1,file#) #...size,items...
-		if items!=1
-			call error("fwrite error")
-		end
-	end
-end
--- /dev/null
+++ actionswf-1/src/faction.oc
@@ -0,0 +1,69 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+import "action_debug" action_debug
+import "brace_blocks_counter_init" brace_blocks_counter_init
+import "action_code_values" action_code_values
+import "action_code_values_index" action_code_values_index
+import "escape_action" escape_action
+import "action_debug_free" action_debug_free
+
+
+
+aftercallimport ebool
+
+#this/an action
+
+import "action__code_row" action__code_row
+import "action_code_set" action_code_set
+import "action_code_row" action_code_row
+import "dupreserve_string" dupreserve_string
+import "brace_blocks_end" brace_blocks_end
+function action_base(ss ac)
+#ss ac       actionscript string to be parsed
+    sd p_values
+    setcall p_values action_code_values()
+    import "error" error
+    if p_values=(NULL);call error("Don't call the action now.");endif
+    #
+    sd nr
+    setcall nr action_code_values_index()
+    set nr# 0
+    call brace_blocks_counter_init()
+    #
+    ss mem
+    setcall mem dupreserve_string(ac)
+    sd p_action_errors
+    setcall p_action_errors action_debug((TRUE))
+    set p_action_errors# (TRUE)
+	sv cursor;set cursor p_action_errors;add cursor (DWORD);set cursor# ac;add cursor :;set cursor# mem
+
+	import "debug_action_init" debug_action_init
+	call debug_action_init(ac)
+
+    call escape_action(ac,mem,0)
+
+	import "debug_action_phase" debug_action_phase
+	call debug_action_phase()
+
+    while mem#!=0
+        setcall mem action_code_row(mem,(FALSE))
+    endwhile
+    call action_code_set((math_end))
+
+    #set false to stop adding row nr at errors
+    set p_action_errors# (FALSE)
+
+    call brace_blocks_end()
+
+	call debug_action_phase()
+
+	#                 code_values are not reallocated
+	while p_values#!=(math_end)
+		setcall p_values action__code_row(p_values)
+	endwhile
+
+    #free mem ok,another free can be at errors
+    call action_debug_free()
+endfunction
--- actionswf-1.orig/src/faction.s
+++ /dev/null
@@ -1,69 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-import "action_debug" action_debug
-import "brace_blocks_counter_init" brace_blocks_counter_init
-import "action_code_values" action_code_values
-import "action_code_values_index" action_code_values_index
-import "escape_action" escape_action
-import "action_debug_free" action_debug_free
-
-
-
-importaftercall ebool
-
-#this/an action
-
-import "action__code_row" action__code_row
-import "action_code_set" action_code_set
-import "action_code_row" action_code_row
-import "dupreserve_string" dupreserve_string
-import "brace_blocks_end" brace_blocks_end
-function action_base(ss ac)
-#ss ac       actionscript string to be parsed
-    sd p_values
-    setcall p_values action_code_values()
-    import "error" error
-    if p_values=(NULL);call error("Don't call the action now.");endif
-    #
-    sd nr
-    setcall nr action_code_values_index()
-    set nr# 0
-    call brace_blocks_counter_init()
-    #
-    ss mem
-    setcall mem dupreserve_string(ac)
-    sd p_action_errors
-    setcall p_action_errors action_debug((TRUE))
-    set p_action_errors# (TRUE)
-	sv cursor;set cursor p_action_errors;add cursor (DWORD);set cursor# ac;add cursor :;set cursor# mem
-
-	import "debug_action_init" debug_action_init
-	call debug_action_init(ac)
-
-    call escape_action(ac,mem,0)
-
-	import "debug_action_phase" debug_action_phase
-	call debug_action_phase()
-
-    while mem#!=0
-        setcall mem action_code_row(mem,(FALSE))
-    endwhile
-    call action_code_set((math_end))
-
-    #set false to stop adding row nr at errors
-    set p_action_errors# (FALSE)
-
-    call brace_blocks_end()
-
-	call debug_action_phase()
-
-	#                 code_values are not reallocated
-	while p_values#!=(math_end)
-		setcall p_values action__code_row(p_values)
-	endwhile
-
-    #free mem ok,another free can be at errors
-    call action_debug_free()
-endfunction
--- /dev/null
+++ actionswf-1/src/file.oc
@@ -0,0 +1,156 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+importx "_open" open
+importx "_read" read
+importx "_write" write
+importx "_lseek" lseek
+#importx tell   can't find it
+importx "_close" close
+
+import "printEr" printEr
+
+function file_get_content__resources(sd trueIsSet_falseIsFree,sd fileIn,sd memIn)
+    data file=fd_none;vdata mem=NULL
+    if trueIsSet_falseIsFree=(TRUE)
+        if fileIn!=(fd_none);set file fileIn
+        else;set mem memIn;endelse
+    else
+        if file!=(fd_none)
+            call file_close(#file)
+            if mem!=(NULL)
+                import "mem_free" mem_free
+                call mem_free(#mem)
+            endif
+        endif
+    endelse
+endfunction
+function file_get_content__resources_free()
+    call file_get_content__resources((FALSE))
+endfunction
+
+#close
+
+function file_close(sd p_file)
+    call close(p_file#)
+    set p_file# (fd_none)
+endfunction
+
+importx "fclose" fclose
+
+function f_close(sv p_file)
+	call fclose(p_file#)
+	set p_file# (NULL)
+endfunction
+
+importx "free" free
+
+importx "fopen" fopen
+importx "fprintf" fprintf
+
+function f_printf_in(sd p,sd nr)
+	callex fprintf p nr ##callexret
+end
+
+
+
+aftercallimport ebool
+
+import "error" error
+
+#file
+function file_open(ss filepath,sd flags)
+    sd file
+    sd permission
+    sd creat_test;set creat_test flags;and creat_test (flag_O_CREAT);if creat_test!=0
+        set permission (flag_pmode);endif
+    SetCall file open(filepath,flags,permission)
+    if file=(fd_error)
+        call printEr("File: \"")
+        call printEr(filepath)
+        call error("\" cannot be opened")
+    EndIf
+    return file
+endfunction
+function file_seek(sd file,sd off,sd method)
+    sd seekint
+    setcall seekint lseek(file,off,method)
+    If seekint=-1
+        vstr seekerr="File seek error"
+        call error(seekerr)
+    endif
+endfunction
+#sz
+function file_tell(sd file)
+    sd sz
+    setcall sz lseek(file,0,(SEEK_CUR))
+    if sz=-1
+        vstr tellerr="File tell error"
+        call error(tellerr)
+    endif
+    return sz
+endfunction
+#size
+function filesize(sd file)
+    call file_seek(file,0,(SEEK_END))
+    sd len
+    setcall len file_tell(file)
+    call file_seek(file,0,(SEEK_SET))
+    return len
+endfunction
+
+#read
+import "memalloc" memalloc
+#mem
+function file_get_content(ss filepath,sv p_size)  #size is a stack variable
+    sd file
+    setcall file file_open(filepath,(_open_read))
+    call file_get_content__resources((TRUE),file)
+    setcall p_size# filesize(file)
+    sd mem
+    setcall mem memalloc(p_size#)
+    call file_get_content__resources((TRUE),(fd_none),mem)
+    call file_read(file,mem,p_size#)
+    return mem
+endfunction
+function file_read(sd file,sd mem,sd size)
+    sd read_sz
+    setcall read_sz read(file,mem,size)
+    if read_sz!=size
+        call error("Read length is different or error")
+    endif
+endfunction
+
+#write
+
+function file_write(sd file,sd buffer,sd size)
+    if size=0
+        return (void)
+    endif
+    sd len
+    setcall len write(file,buffer,size)
+    if len=size
+        return (void)
+    endif
+    vstr er="File write error"
+    call error(er)
+endfunction
+
+
+function f_open_mem(sd path,sd format)
+	sd f;setcall f fopen(path,format)
+	if f=(NULL)
+		call free(path)
+		call error("fopen error")
+	endif
+	call free(path)
+	return f
+endfunction
+
+function f_printf(sd nr,sd file,sd format) #...
+	sd r;set r f_printf_in(#file,nr)
+	if r=-1
+		call error("fprintf error")
+	endif
+endfunction
--- actionswf-1.orig/src/file.s
+++ /dev/null
@@ -1,156 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-importx "_open" open
-importx "_read" read
-importx "_write" write
-importx "_lseek" lseek
-#importx tell   can't find it
-importx "_close" close
-
-import "printEr" printEr
-
-function file_get_content__resources(sd trueIsSet_falseIsFree,sd fileIn,sd memIn)
-    data file=fd_none;vdata mem=NULL
-    if trueIsSet_falseIsFree=(TRUE)
-        if fileIn!=(fd_none);set file fileIn
-        else;set mem memIn;endelse
-    else
-        if file!=(fd_none)
-            call file_close(#file)
-            if mem!=(NULL)
-                import "mem_free" mem_free
-                call mem_free(#mem)
-            endif
-        endif
-    endelse
-endfunction
-function file_get_content__resources_free()
-    call file_get_content__resources((FALSE))
-endfunction
-
-#close
-
-function file_close(sd p_file)
-    call close(p_file#)
-    set p_file# (fd_none)
-endfunction
-
-importx "fclose" fclose
-
-function f_close(sv p_file)
-	call fclose(p_file#)
-	set p_file# (NULL)
-endfunction
-
-importx "free" free
-
-importx "fopen" fopen
-importx "fprintf" fprintf
-
-function f_printf_in(sd p,sd nr)
-	callex fprintf p nr ##callexret
-end
-
-
-
-importaftercall ebool
-
-import "error" error
-
-#file
-function file_open(ss filepath,sd flags)
-    sd file
-    sd permission
-    sd creat_test;set creat_test flags;and creat_test (flag_O_CREAT);if creat_test!=0
-        set permission (flag_pmode);endif
-    SetCall file open(filepath,flags,permission)
-    if file=(fd_error)
-        call printEr("File: \"")
-        call printEr(filepath)
-        call error("\" cannot be opened")
-    EndIf
-    return file
-endfunction
-function file_seek(sd file,sd off,sd method)
-    sd seekint
-    setcall seekint lseek(file,off,method)
-    If seekint=-1
-        vstr seekerr="File seek error"
-        call error(seekerr)
-    endif
-endfunction
-#sz
-function file_tell(sd file)
-    sd sz
-    setcall sz lseek(file,0,(SEEK_CUR))
-    if sz=-1
-        vstr tellerr="File tell error"
-        call error(tellerr)
-    endif
-    return sz
-endfunction
-#size
-function filesize(sd file)
-    call file_seek(file,0,(SEEK_END))
-    sd len
-    setcall len file_tell(file)
-    call file_seek(file,0,(SEEK_SET))
-    return len
-endfunction
-
-#read
-import "memalloc" memalloc
-#mem
-function file_get_content(ss filepath,sv p_size)  #size is a stack variable
-    sd file
-    setcall file file_open(filepath,(_open_read))
-    call file_get_content__resources((TRUE),file)
-    setcall p_size# filesize(file)
-    sd mem
-    setcall mem memalloc(p_size#)
-    call file_get_content__resources((TRUE),(fd_none),mem)
-    call file_read(file,mem,p_size#)
-    return mem
-endfunction
-function file_read(sd file,sd mem,sd size)
-    sd read_sz
-    setcall read_sz read(file,mem,size)
-    if read_sz!=size
-        call error("Read length is different or error")
-    endif
-endfunction
-
-#write
-
-function file_write(sd file,sd buffer,sd size)
-    if size=0
-        return (void)
-    endif
-    sd len
-    setcall len write(file,buffer,size)
-    if len=size
-        return (void)
-    endif
-    vstr er="File write error"
-    call error(er)
-endfunction
-
-
-function f_open_mem(sd path,sd format)
-	sd f;setcall f fopen(path,format)
-	if f=(NULL)
-		call free(path)
-		call error("fopen error")
-	endif
-	call free(path)
-	return f
-endfunction
-
-function f_printf(sd nr,sd file,sd format) #...
-	sd r;set r f_printf_in(#file,nr)
-	if r=-1
-		call error("fprintf error")
-	endif
-endfunction
--- /dev/null
+++ actionswf-1/src/lin.oc
@@ -0,0 +1,9 @@
+
+format elfobj64
+
+Importx "stderr" stderr
+
+function platform_iob()
+	sv a^stderr
+	return a#
+endfunction
--- actionswf-1.orig/src/lin.s
+++ /dev/null
@@ -1,9 +0,0 @@
-
-format elfobj64
-
-Importx "stderr" stderr
-
-function platform_iob()
-	sv a^stderr
-	return a#
-endfunction
--- actionswf-1.orig/src/mw64d
+++ actionswf-1/src/mw64d
@@ -1,2 +1,2 @@
 
-OFLAGSEXTRA="function_name 1" ./makewin64 $@ && ./makewin64 linkerflags= link
+OFLAGSEXTRA="function_name 1 nul_res_pref 1" ./makewin64 $@ && ./makewin64 linkerflags= link
--- /dev/null
+++ actionswf-1/src/storage.oc
@@ -0,0 +1,347 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+#win32 with _
+importx "strlen" strlen
+importx "memcpy" memcpy
+
+#this is throwless here
+import "struct_ids" struct_ids
+
+function free_sprite_id(sd id)
+    call struct_ids((ids_free),id)
+#these two are ok throwless
+    call struct_ids_action((ids_free),id)
+    call struct_ids_actionpool((ids_free),id)
+#
+endfunction
+
+#
+function identifiers()
+    data id#1
+    return #id
+endfunction
+function identifiers_set(sd value)
+    sd id
+    setcall id identifiers()
+    set id# value
+endfunction
+#id
+function identifiers_get()
+    sd id
+    setcall id identifiers()
+    sd value
+    set value id#
+    inc id#
+    call identifiers_set(id#)
+    return value
+endfunction
+
+#p
+function exportsId()
+    data exports=not_an_id
+    return #exports
+endfunction
+
+function swf_frames_reg()
+	data main_id#1
+#set reg for later
+	value reg#1
+	sd block
+	set block struct_ids((ids_get),main_id)
+	set reg block_get_size(block)
+	sub reg (WORD)
+end
+#p
+function swf_frames_pointer()
+	sd block
+	set block struct_ids((ids_get),swf_frames_reg.main_id)
+	set block block_get_mem(block)
+	add block swf_frames_reg.reg
+	return block
+end
+#p
+function swf_sprite_frames_pointer(sd spriteid)
+	sd block
+	setcall block struct_ids((ids_get),spriteid)
+	setcall block block_get_mem(block)
+	add block (WORD)
+	return block
+end
+
+import "mem_free" mem_free
+import "action_code_values_free" action_code_values_free
+import "file_close" file_close
+import "block_get_mem" block_get_mem
+import "block_get_mem_size" block_get_mem_size
+import "bits_packs" bits_packs
+import "word_swap_arg" word_swap_arg
+import "block_get_size" block_get_size
+import "block_reset_size" block_reset_size
+
+import "actionpoolid" actionpoolid;import "actionpoolid_root" actionpoolid_root
+import "actionpool_currentblock" actionpool_currentblock
+
+import "action_size" action_size
+import "dword_to_word_arg" dword_to_word_arg
+import "word_arg_to_dword" word_arg_to_dword
+
+
+
+aftercallimport ebool
+
+
+
+import "error" error
+import "struct_ids_actionpool" struct_ids_actionpool
+import "struct_ids_action" struct_ids_action
+import "mem_block_add" mem_block_add
+import "def_mem" def_mem
+import "debug_show" debug_show
+
+function swf_mem(sd proc,sd arg,sd len)
+    vdata path_mem=NULL
+    #4-7 is 0
+    data path_size#1
+    data filelength_offset#1
+    data file_out=fd_error
+
+    data id#1
+	#data main_id#1 #was moved to a throwless location
+    value call_struct#1;vdata c_main^struct_ids;vdata c_pool^struct_ids_actionpool
+
+    if proc=(mem_exp_change_back)
+        set id swf_frames_reg.main_id
+        set call_struct c_main
+        return (void)
+    elseif proc=(mem_exp_init)
+    #arg is file
+    #len is filelength offset
+        if path_mem!=(NULL)
+            call error("The previous swf was not ended.")
+        endif
+        #0
+        import "memalloc" memalloc
+        setcall path_size strlen(arg);inc path_size
+        setcall path_mem memalloc(path_size)
+        call memcpy(path_mem,arg,path_size)
+        #1
+        setcall swf_frames_reg.main_id def_mem()
+        set id swf_frames_reg.main_id
+        call swf_actionblock((mem_exp_init),swf_frames_reg.main_id)
+        set call_struct c_main
+        #2
+        call exports_init()
+        #3
+        import "action_code_values_init" action_code_values_init
+        call action_code_values_init()
+        #
+        set filelength_offset len
+        #
+        return (void)
+    elseif proc=(mem_exp_free)
+        if path_mem!=(NULL)
+            #0
+            call mem_free(#path_mem)
+            #1 freeing all ids(main(exports,root+sprites),acs,pools)
+            call struct_ids((ids_all_free))
+            #2 exports
+            sd exports
+            setcall exports exportsId()
+            set exports# (not_an_id)
+            #3 set of values
+            call action_code_values_free()
+            #file
+            if file_out!=(fd_error)
+                call file_close(#file_out)
+            endif
+        endif
+        return (void)
+    endelseif
+    if path_mem=(NULL)
+    #swf_(placeobject...)->mem_exp_add;swf_sprite_(placeobject...)->mem_exp_change;swf_done->mem_exp_done
+        call error("there isn't a swf started")
+    endif
+    if proc=(mem_exp_add)
+        #blockMain blockPool
+        sv p_block
+        setcall p_block call_struct((ids_get_pointer),id)
+        call mem_block_add(p_block,arg,len)
+    elseif proc=(mem_exp_change)
+        if arg<0;set call_struct c_pool
+            xor arg (negative_means_action_sprite_pool)
+        else;set call_struct c_main;endelse
+        set id arg
+    else
+    #if proc==(mem_exp_done)
+        call swf_tag_end()
+
+        sd block
+        setcall block call_struct((ids_get),swf_frames_reg.main_id)
+        sd mem;sd size;call block_get_mem_size(block,#mem,#size)
+
+        sd pointer
+        set pointer mem
+        add pointer filelength_offset
+        set pointer# size
+
+        import "file_open" file_open
+        setcall file_out file_open(path_mem,(_open_write))
+        import "file_write" file_write
+        call file_write(file_out,mem,size)
+    endelse
+endfunction
+function swf_mem_add(ss dest,sd size)
+    call swf_mem((mem_exp_add),dest,size)
+endfunction
+function swf_tag_end()
+    call swf_tag_recordheader_entry((End),0)
+endfunction
+const recordheader_long_mark=0x3f
+function swf_tag_recordheader_entry(sd tag,sd size)
+    if size<(recordheader_long_mark)
+        sd tag_plus_size
+        call swf_tag_recordheader(#tag_plus_size,tag,size)
+    else
+        call swf_tag_recordheader_long_entry(tag,size)
+    endelse
+endfunction
+function swf_tag_recordheader_long_entry(sd tag,sd size)
+    sd tag_plus_size
+    call swf_tag_recordheader(#tag_plus_size,tag,(recordheader_long_mark))
+    call swf_mem_add(#size,(DWORD))
+endfunction
+const short_header=2
+function swf_tag_recordheader(ss dest,sd tag,sd size)
+    call bits_packs(dest,2,tag,10,size,6)
+    call word_swap_arg(dest)
+    call swf_mem((mem_exp_add),dest,(short_header))
+endfunction
+function swf_tag(ss dest,sd tag,sd size)
+    call swf_tag_recordheader(dest,tag,size)
+    add dest (short_header)
+    call swf_mem((mem_exp_add),dest,size)
+endfunction
+
+#
+function swf_actionblock(sd proc,sd arg,sd arg2)
+    data id#1
+    data id_back#1
+    sd poolid
+    if proc=(mem_exp_change)
+        #must verify to be a valid user input id
+        call struct_ids_actionpool((ids_get_pointer),id)
+        #
+        set id arg
+        #
+        setcall poolid actionpoolid()
+        set poolid# id
+        return (void)
+    elseif proc=(mem_exp_change_back)
+        set id id_back
+        #
+        sd root_poolid
+        setcall root_poolid actionpoolid_root()
+        setcall poolid actionpoolid()
+        set poolid# root_poolid#
+        return (void)
+    elseif proc=(mem_exp_init)
+        set id arg
+        set id_back id
+        call struct_ids_action((ids_set),id)
+        call struct_ids_actionpool((ids_set),id)
+        sd p_poolid;setcall p_poolid actionpoolid();set p_poolid# id
+        sd p_poolrootid;setcall p_poolrootid actionpoolid_root();set p_poolrootid# id
+        return (void)
+    endelseif
+    sv p_block
+    setcall p_block struct_ids_action((ids_get_pointer),id)
+    if proc=(mem_exp_add)
+        call mem_block_add(p_block,arg,arg2)
+    elseif proc=(mem_exp_part_done)
+		sd frames
+		if arg=(from_show)
+			#id is 0/spriteid
+			call debug_show(id)
+			setcall frames word_arg_to_dword(arg2)
+			inc frames
+			call dword_to_word_arg(frames,arg2)
+		endif
+		sd block
+		set block p_block#
+		sd size
+		setcall size block_get_size(block)
+		if size!=0
+			if arg=(from_done)
+				call debug_show(id)  #even if is not a ShowFrame in the swf, ffdec or player will frame index them
+				setcall frames word_arg_to_dword(arg2)
+				inc frames
+				call dword_to_word_arg(frames,arg2)
+			endif
+			import "write_action" write_action
+			sd tagsz
+			setcall tagsz action_size(id)
+			call swf_tag_recordheader_entry((DoAction),tagsz)
+			call write_action(id)
+			sd poolblock
+			setcall poolblock actionpool_currentblock()
+			call block_reset_size(poolblock)
+			call block_reset_size(block)
+		endif
+    else
+    #if proc==(mem_exp_get_block)
+        return p_block#
+    endelse
+endfunction
+
+function swf_actionblock_add(sd value,sd size)
+    call swf_actionblock((mem_exp_add),value,size)
+endfunction
+function actionrecordheader(sd tag,sd size)
+    char t#1
+    char length#2
+    set t tag
+    call dword_to_word_arg(size,#length)
+    call swf_actionblock_add(#t,3)
+	import "debug_phase_code_add" debug_phase_code_add
+	call debug_phase_code_add()
+endfunction
+function swf_actionrecordheader(sd tag,sd size)
+    char t#1
+    char length#2
+    set t tag
+    call dword_to_word_arg(size,#length)
+    call swf_mem_add(#t,3)
+endfunction
+
+#preid
+function new_sprite_id()
+    sd id
+    setcall id def_mem()
+    call struct_ids_action((ids_set),id)
+    call struct_ids_actionpool((ids_set),id)
+    return id
+endfunction
+
+#
+function exports_init()
+    sd exports
+    setcall exports exportsId()
+    sd id
+    setcall id def_mem()
+    set exports# id
+endfunction
+#id
+function exportsId_get()
+    sd e
+    setcall e exportsId()
+    if e#=(not_an_id);call error("Do not call the exports at this moment.");endif
+    return e#
+endfunction
+
+function swf_showframe_base(sd frames_pointer)
+#showframe tag
+	call swf_actionblock((mem_exp_part_done),(from_show),frames_pointer)
+	call swf_tag_recordheader_entry((ShowFrame),0)
+endfunction
--- actionswf-1.orig/src/storage.s
+++ /dev/null
@@ -1,303 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-#win32 with _
-importx "strlen" strlen
-importx "memcpy" memcpy
-
-#this is throwless here
-import "struct_ids" struct_ids
-
-function free_sprite_id(sd id)
-    call struct_ids((ids_free),id)
-#these two are ok throwless
-    call struct_ids_action((ids_free),id)
-    call struct_ids_actionpool((ids_free),id)
-#
-endfunction
-
-#
-function identifiers()
-    data id#1
-    return #id
-endfunction
-function identifiers_set(sd value)
-    sd id
-    setcall id identifiers()
-    set id# value
-endfunction
-#id
-function identifiers_get()
-    sd id
-    setcall id identifiers()
-    sd value
-    set value id#
-    inc id#
-    call identifiers_set(id#)
-    return value
-endfunction
-
-#p
-function exportsId()
-    data exports=not_an_id
-    return #exports
-endfunction
-
-import "mem_free" mem_free
-import "action_code_values_free" action_code_values_free
-import "file_close" file_close
-import "block_get_mem_size" block_get_mem_size
-import "bits_packs" bits_packs
-import "word_swap_arg" word_swap_arg
-import "block_get_size" block_get_size
-import "block_reset_size" block_reset_size
-
-import "actionpoolid" actionpoolid;import "actionpoolid_root" actionpoolid_root
-import "actionpool_currentblock" actionpool_currentblock
-
-import "action_size" action_size
-import "dword_to_word_arg" dword_to_word_arg
-
-
-
-importaftercall ebool
-
-
-
-import "error" error
-import "struct_ids_actionpool" struct_ids_actionpool
-import "struct_ids_action" struct_ids_action
-import "mem_block_add" mem_block_add
-import "def_mem" def_mem
-import "debug_show" debug_show
-
-function swf_mem(sd proc,sd arg,sd len)
-    vdata path_mem=NULL
-    #4-7 is 0
-    data path_size#1
-    data filelength_offset#1
-    data file_out=fd_error
-
-    data id#1
-    data main_id#1
-    vdata call_struct#1;vdata c_main^struct_ids;vdata c_pool^struct_ids_actionpool
-
-    if proc=(mem_exp_change_back)
-        set id main_id
-        set call_struct c_main
-        return (void)
-    elseif proc=(mem_exp_init)
-    #arg is file
-    #len is filelength offset
-        if path_mem!=(NULL)
-            call error("The previous swf was not ended.")
-        endif
-        #0
-        import "memalloc" memalloc
-        setcall path_size strlen(arg);inc path_size
-        setcall path_mem memalloc(path_size)
-        call memcpy(path_mem,arg,path_size)
-        #1
-        setcall main_id def_mem()
-        set id main_id
-        call swf_actionblock((mem_exp_init),main_id)
-        set call_struct c_main
-        #2
-        call exports_init()
-        #3
-        import "action_code_values_init" action_code_values_init
-        call action_code_values_init()
-        #
-        set filelength_offset len
-        #
-        return (void)
-    elseif proc=(mem_exp_free)
-        if path_mem!=(NULL)
-            #0
-            call mem_free(#path_mem)
-            #1 freeing all ids(main(exports,root+sprites),acs,pools)
-            call struct_ids((ids_all_free))
-            #2 exports
-            sd exports
-            setcall exports exportsId()
-            set exports# (not_an_id)
-            #3 set of values
-            call action_code_values_free()
-            #file
-            if file_out!=(fd_error)
-                call file_close(#file_out)
-            endif
-        endif
-        return (void)
-    endelseif
-    if path_mem=(NULL)
-    #swf_(placeobject...)->mem_exp_add;swf_sprite_(placeobject...)->mem_exp_change;swf_done->mem_exp_done
-        call error("there isn't a swf started")
-    endif
-    if proc=(mem_exp_add)
-        #blockMain blockPool
-        sv p_block
-        setcall p_block call_struct((ids_get_pointer),id)
-        call mem_block_add(p_block,arg,len)
-    elseif proc=(mem_exp_change)
-        if arg<0;set call_struct c_pool
-            xor arg (negative_means_action_sprite_pool)
-        else;set call_struct c_main;endelse
-        set id arg
-    else
-    #if proc==(mem_exp_done)
-        call swf_tag_end()
-
-        sd block
-        setcall block call_struct((ids_get),main_id)
-        sd mem;sd size;call block_get_mem_size(block,#mem,#size)
-
-        sd pointer
-        set pointer mem
-        add pointer filelength_offset
-        set pointer# size
-
-        import "file_open" file_open
-        setcall file_out file_open(path_mem,(_open_write))
-        import "file_write" file_write
-        call file_write(file_out,mem,size)
-    endelse
-endfunction
-function swf_mem_add(ss dest,sd size)
-    call swf_mem((mem_exp_add),dest,size)
-endfunction
-function swf_tag_end()
-    call swf_tag_recordheader_entry((End),0)
-endfunction
-const recordheader_long_mark=0x3f
-function swf_tag_recordheader_entry(sd tag,sd size)
-    if size<(recordheader_long_mark)
-        sd tag_plus_size
-        call swf_tag_recordheader(#tag_plus_size,tag,size)
-    else
-        call swf_tag_recordheader_long_entry(tag,size)
-    endelse
-endfunction
-function swf_tag_recordheader_long_entry(sd tag,sd size)
-    sd tag_plus_size
-    call swf_tag_recordheader(#tag_plus_size,tag,(recordheader_long_mark))
-    call swf_mem_add(#size,(DWORD))
-endfunction
-const short_header=2
-function swf_tag_recordheader(ss dest,sd tag,sd size)
-    call bits_packs(dest,2,tag,10,size,6)
-    call word_swap_arg(dest)
-    call swf_mem((mem_exp_add),dest,(short_header))
-endfunction
-function swf_tag(ss dest,sd tag,sd size)
-    call swf_tag_recordheader(dest,tag,size)
-    add dest (short_header)
-    call swf_mem((mem_exp_add),dest,size)
-endfunction
-
-#
-function swf_actionblock(sd proc,sd arg,sd newmem_len)
-    data id#1
-    data id_back#1
-    sd poolid
-    if proc=(mem_exp_change)
-        #must verify to be a valid user input id
-        call struct_ids_actionpool((ids_get_pointer),id)
-        #
-        set id arg
-        #
-        setcall poolid actionpoolid()
-        set poolid# id
-        return (void)
-    elseif proc=(mem_exp_change_back)
-        set id id_back
-        #
-        sd root_poolid
-        setcall root_poolid actionpoolid_root()
-        setcall poolid actionpoolid()
-        set poolid# root_poolid#
-        return (void)
-    elseif proc=(mem_exp_init)
-        set id arg
-        set id_back id
-        call struct_ids_action((ids_set),id)
-        call struct_ids_actionpool((ids_set),id)
-        sd p_poolid;setcall p_poolid actionpoolid();set p_poolid# id
-        sd p_poolrootid;setcall p_poolrootid actionpoolid_root();set p_poolrootid# id
-        return (void)
-    endelseif
-    sv p_block
-    setcall p_block struct_ids_action((ids_get_pointer),id)
-    if proc=(mem_exp_add)
-        call mem_block_add(p_block,arg,newmem_len)
-    elseif proc=(mem_exp_part_done)
-		#id is 0/spriteid
-		call debug_show(id)
-
-		sd block
-		set block p_block#
-		sd size
-		setcall size block_get_size(block)
-		if size!=0
-			import "write_action" write_action
-			sd tagsz
-			setcall tagsz action_size(id)
-			call swf_tag_recordheader_entry((DoAction),tagsz)
-			call write_action(id)
-			sd poolblock
-			setcall poolblock actionpool_currentblock()
-			call block_reset_size(poolblock)
-			call block_reset_size(block)
-		endif
-    else
-    #if proc==(mem_exp_get_block)
-        return p_block#
-    endelse
-endfunction
-
-function swf_actionblock_add(sd value,sd size)
-    call swf_actionblock((mem_exp_add),value,size)
-endfunction
-function actionrecordheader(sd tag,sd size)
-    char t#1
-    char length#2
-    set t tag
-    call dword_to_word_arg(size,#length)
-    call swf_actionblock_add(#t,3)
-	import "debug_phase_code_add" debug_phase_code_add
-	call debug_phase_code_add()
-endfunction
-function swf_actionrecordheader(sd tag,sd size)
-    char t#1
-    char length#2
-    set t tag
-    call dword_to_word_arg(size,#length)
-    call swf_mem_add(#t,3)
-endfunction
-
-#preid
-function new_sprite_id()
-    sd id
-    setcall id def_mem()
-    call struct_ids_action((ids_set),id)
-    call struct_ids_actionpool((ids_set),id)
-    return id
-endfunction
-
-#
-function exports_init()
-    sd exports
-    setcall exports exportsId()
-    sd id
-    setcall id def_mem()
-    set exports# id
-endfunction
-#id
-function exportsId_get()
-    sd e
-    setcall e exportsId()
-    if e#=(not_an_id);call error("Do not call the exports at this moment.");endif
-    return e#
-endfunction
-
--- /dev/null
+++ actionswf-1/src/swf.e.oc
@@ -0,0 +1,974 @@
+Format ElfObj64
+
+include "../include/prog.h"
+
+#win32 with _
+importx "memcpy" memcpy
+importx "strlen" strlen
+importx "memcmp" memcmp
+
+import "identifiers_set" identifiers_set
+import "identifiers_get" identifiers_get
+import "swf_frames_reg" swf_frames_reg
+import "swf_frames_pointer" swf_frames_pointer
+import "swf_sprite_frames_pointer" swf_sprite_frames_pointer
+
+import "printEr" printEr
+import "rect_prepare" rect_prepare
+import "button_mem" button_mem
+
+import "dword_to_word_arg" dword_to_word_arg
+import "dword_swap" dword_swap
+import "args_advance" args_advance
+import "bits_packs" bits_packs
+import "NumFill_NumLin" NFill_NLin
+import "shapewithstyle_records" shapewithstyle_records
+import "word_arg_to_dword" word_arg_to_dword
+import "file_get_content__resources_free" file_get_content__resources_free
+import "file_resources_set" file_resources_set
+import "file_resources_free" file_resources_free
+import "struct_ids" struct_ids
+import "matrix_translate" matrix_translate
+import "block_get_size" block_get_size
+import "block_get_mem" block_get_mem
+import "free_sprite_id" free_sprite_id
+import "block_reset_size" block_reset_size
+import "freereset" freereset   #..x with no args
+
+
+
+
+aftercallimport ebool
+
+import "swf_tag" swf_tag
+import "swf_mem" swf_mem
+import "swf_mem_add" swf_mem_add
+import "swf_actionblock" swf_actionblock
+import "rect_add" rect_add
+import "swf_tag_recordheader_entry" swf_tag_recordheader_entry
+import "error" error
+import "swf_shape_simple" swf_shape_simple
+
+import "swf_button_base" swf_button_base
+import "swf_text_initial_font_centered" swf_text_initial_font_centered
+#id
+functionX swf_button(sd width,sd height,sd ButtonData)
+data def_fill#1
+data def_line_h#1;#no pad
+data def_line#1
+
+data ov_fill#1;#no pad
+data ov_line_h#1
+data ov_line#1;#no pad
+
+data dn_fill#1;#no pad
+data dn_line_h#1
+data dn_line#1;#no pad
+
+data xcurve#1
+data ycurve#1;#no pad
+
+vstr text#1
+data font_id#1;data font_height#1;#no pad
+data font_vertical_offset#1;data font_color#1;#no pad
+
+vstr actions#1
+
+#width                  is the button width
+#height                 is the button height
+
+#def_fill               is the ButtonStateUp RGBA fill color
+#def_line_sz            line height in pixels
+#def_line               is the line RGBA
+#ov_fill                is the ButtonStateOver RGBA
+#ov_line_sz             line height
+#ov_line                RGBA
+#dn_fill                is the ButtonStateDown|ButtonStateHitTest RGBA
+#dn_line_sz             line height
+#dn_line                RGBA
+#x_curve                x curve shape value
+#y_curve                y curve shape value
+#text                   button text
+#font_id                a font created with swf_font
+#font_height            font height in pixels
+#font_vertical_offset   font y offset
+#font_color             font RGBA
+#actions                is a string with actionscript
+
+    const button_top_args=11*DWORD
+    call memcpy(#def_fill,ButtonData,(button_top_args))
+    add ButtonData (button_top_args);call memcpy(#text,ButtonData,:)
+    const button_font_args=4*DWORD
+    add ButtonData :;call memcpy(#font_id,ButtonData,(button_font_args))
+    add ButtonData (button_font_args);call memcpy(#actions,ButtonData,:)
+#
+    if font_height>height;call error("font_height>height error at button");endif
+    #
+    sd bmem
+    setcall bmem button_mem()
+    #
+    sd shape_up
+    sd shape_over
+	sd shape_down
+    setcall shape_up swf_shape_simple(width,height,def_fill,def_line_h,def_line,xcurve,ycurve)
+    setcall shape_over swf_shape_simple(width,height,ov_fill,ov_line_h,ov_line,xcurve,ycurve)
+	setcall shape_down swf_shape_simple(width,height,dn_fill,dn_line_h,dn_line,xcurve,ycurve)
+
+    set bmem# shape_up
+    add bmem (DWORD)
+    set bmem# shape_over
+    add bmem (DWORD)
+	set bmem# shape_down
+	add bmem (DWORD)
+
+    set bmem# width;add bmem (DWORD)
+    set bmem# height;add bmem (DWORD)
+
+    sd noText=FALSE;sd text_id
+    data t_null={0,0}
+    sd b;setcall b memcmp(#t_null,#text,:)
+    if b=0
+        set noText (TRUE)
+        set bmem# noText
+    else
+        sd text_y
+        set text_y height
+        sub text_y font_height
+        div text_y 2
+        add text_y font_vertical_offset
+
+        set bmem# noText;add bmem (DWORD)
+        set bmem# font_id;add bmem (DWORD)
+        set bmem# font_height;add bmem (DWORD)
+        set bmem# text_y;add bmem (DWORD)
+        set bmem# font_color
+
+        setcall text_id swf_text_initial_font_centered(width,height,text,font_id,font_height,font_color)
+    endelse
+
+    sd id
+    setcall id swf_button_base(shape_up,shape_over,shape_down,noText,text_id,text_y,actions)
+    return id
+endfunction
+#id
+functionX swf_button_last(ss newtext,ss actions)
+#ss newtext  is the new text for a new button with the attributes from the previous swf_button call
+#ss actions  button actions
+    data shape_up#1
+    data shape_over#1
+	data shape_down#1
+    data width#1
+    data height#1
+    data noText#1
+    data font_id#1
+    data font_height#1
+    data text_y#1
+    data font_color#1
+    sd bmem
+    setcall bmem button_mem()
+    call memcpy(#shape_up,bmem,(9*DWORD))
+
+    if noText=(FALSE)
+        sd newtext_id
+        setcall newtext_id swf_text_initial_font_centered(width,height,newtext,font_id,font_height,font_color)
+    endif
+
+    sd id
+    setcall id swf_button_base(shape_up,shape_over,shape_down,noText,newtext_id,text_y,actions)
+    return id
+endfunction
+
+#font
+
+#id
+functionX swf_font(ss fontname,sd font_flags)
+#ss fontname    = a string with the browser font, for example "_sans"
+#sd font_flags  = prog.h file is with the flags
+    const font_hd_start=\
+
+    char id#2
+    char Flags#1
+    char *Language=0
+    char FontNameLen#1
+
+    const font_hd_start_size=\-font_hd_start
+    vdata font_hd_start^id
+
+    data NumGlyphs=0
+
+    sd fontid
+    setcall fontid identifiers_get()
+    call dword_to_word_arg(fontid,#id)
+
+    set Flags font_flags
+
+    setcall FontNameLen strlen(fontname)
+
+    sd size=font_hd_start_size+2
+
+    sd has_layout=FontFlagsHasLayout
+    and has_layout font_flags
+    add size FontNameLen
+    if has_layout!=0
+        add size (2+2+2+2)
+    endif
+
+    call swf_tag_recordheader_entry((DefineFont2),size)
+    call swf_mem_add(font_hd_start,(font_hd_start_size))
+    call swf_mem_add(fontname,FontNameLen)
+    call swf_mem_add(#NumGlyphs,2)
+    if has_layout!=0
+        char FontAscent={0,0}
+        char *FontDescent={0,0}
+        char *FontLeading={0,0}
+        char *KerningCount={0,0}
+        call swf_mem_add(#FontAscent,(2+2+2+2))
+    endif
+    return fontid
+endfunction
+#id
+functionX swf_font_basic(ss fontname)
+#ss fontname    = a string with the browser font, for example "_sans"
+    sd id
+    setcall id swf_font(fontname,0)
+    return id
+endfunction
+
+#text
+
+#id
+functionX swf_text(sd bound_width,sd bound_height,ss variablename,sd flags,sv structure)
+#sd bound_width  width of the text
+#sd bound_height height
+#ss variablename to change it with actionscript
+#sd flags        see include/text.h
+#sv structure    see edittext_struct()  from character.oc, set the flags first
+    #CharacterID
+    sd size=2
+    #RECT
+    sd rect
+    sd rectsz
+    call rect_prepare(#rect,#rectsz,bound_width,bound_height)
+    add size rectsz
+    #flags
+    add size 2
+    #FontID
+    sd p_fontid
+    sd hasfont=HasFont
+    and hasfont flags
+    if hasfont!=0
+        set p_fontid structure
+        add size 2
+    endif
+    #FontClass
+    ss fontclassname
+    sd fontclasssize
+    sd hasfontclass=HasFontClass
+    and hasfontclass flags
+    add structure (2*DWORD)
+    if hasfontclass!=0
+        if hasfont!=0
+            call error("HasFontClass can't be true if HasFont is true.")
+        endif
+        set fontclassname structure#
+        setcall fontclasssize strlen(fontclassname)
+        inc fontclasssize
+        add size fontclasssize
+    endif
+    #FontHeight
+    sd p_font_height
+    sub structure (DWORD)
+    if hasfont!=0
+        set p_font_height structure
+        add size 2
+    endif
+    #TextColor
+    sd p_rgba
+    sd hastextcolor=HasTextColor
+    and hastextcolor flags
+    add structure (DWORD+:)
+    if hastextcolor!=0
+        set p_rgba structure
+        add size 4
+    endif
+    #MaxLength
+    sd p_maxlength
+    sd hasmaxlength=HasMaxLength
+    and hasmaxlength flags
+    add structure (DWORD)
+    if hasmaxlength!=0
+        set p_maxlength structure
+        add size 2
+    endif
+    #layout
+    sd p_layout
+    data layout_size=4*WORD+BYTE
+    sd haslayout=HasLayout
+    and haslayout flags
+    add structure (DWORD+:)
+    if haslayout!=0
+        set p_layout structure
+        add size layout_size
+    endif
+    #VariableName
+    sd vlen
+    setcall vlen strlen(variablename)
+    inc vlen
+    add size vlen
+    #InitialText
+    ss initialtext
+    sd initialtextsize
+    sd hastext=HasText
+    and hastext flags
+    sub structure :
+    if hastext!=0
+        set initialtext structure#
+        setcall initialtextsize strlen(initialtext)
+        inc initialtextsize
+        add size initialtextsize
+    endif
+
+    call swf_tag_recordheader_entry((DefineEditText),size)
+    sd id
+    setcall id identifiers_get()
+    call swf_mem_add(#id,2)
+    call swf_mem_add(rect,rectsz)
+    call swf_mem_add(#flags,2)
+    #
+    if hasfont!=0
+        call swf_mem_add(p_fontid,2)
+    endif
+    if hasfontclass!=0
+        call swf_mem_add(fontclassname,fontclasssize)
+    endif
+    if hasfont!=0
+        sd height
+        set height p_font_height#
+        mult height 20
+        call swf_mem_add(#height,2)
+    endif
+    if hastextcolor!=0
+        setcall p_rgba# dword_swap(p_rgba#)
+        call swf_mem_add(p_rgba,4)
+    endif
+    if hasmaxlength!=0
+        call swf_mem_add(p_maxlength,2)
+    endif
+    if haslayout!=0
+        data layout_align#1
+        data layout_leftmargin#1
+        data layout_rightmargin#1
+        data layout_indent#1
+        data layout_leading#1
+        call memcpy(#layout_align,p_layout,(5*DWORD))
+        mult layout_leftmargin 20
+        mult layout_rightmargin 20
+        mult layout_indent 20
+        mult layout_leading 20
+        char l_align#1
+        char l_leftmargin#2
+        char l_rightmargin#2
+        char l_indent#2
+        char l_leading#2
+        set l_align layout_align
+        call dword_to_word_arg(layout_leftmargin,#l_leftmargin)
+        call dword_to_word_arg(layout_rightmargin,#l_rightmargin)
+        call dword_to_word_arg(layout_indent,#l_indent)
+        call dword_to_word_arg(layout_leading,#l_leading)
+        call swf_mem_add(#l_align,layout_size)
+    endif
+    call swf_mem_add(variablename,vlen)
+    if hastext!=0
+        call swf_mem_add(initialtext,initialtextsize)
+    endif
+    return id
+endfunction
+
+import "shape_records_add" shape_records_add
+#id
+functionX swf_shape(sd width,sd height,sd args)
+#sd width
+#sd height
+#sd args        see swf_shape_basic or swf_image(last part) for example, or see shape_records_add and it's sub-functions to see how the swf SHAPERECORD is added
+    if width=0
+        call error("shape width 0 not allowed")
+    elseif height=0
+        call error("shape height 0 not allowed")
+    endelseif
+    sd fillstyle
+    sd fillarg
+    sd linewidth
+    sd linecolor
+
+    setcall fillstyle args_advance(#args)
+    if fillstyle!=(no_fill)
+        setcall fillarg args_advance(#args)
+    endif
+    setcall linewidth args_advance(#args)
+    if linewidth!=0
+        setcall linecolor args_advance(#args)
+    endif
+    ########
+    sd shape_size
+
+    #id
+    sd shape_id
+    setcall shape_id identifiers_get()
+    set shape_size (WORD)
+
+    #rect
+    sd rect
+    sd rect_size
+    call rect_prepare(#rect,#rect_size,width,height)
+    add shape_size rect_size
+
+    #SHAPEWITHSTYLE
+    char FillStyleCount#1
+        char FillStyleType#1
+    #
+        data data#3
+    vdata fillstyles^FillStyleCount
+    set FillStyleCount 0
+    sd fillstyles_size=1
+    if fillstyle!=(no_fill)
+        set FillStyleCount 1
+        set FillStyleType fillstyle
+        add fillstyles_size 1
+        if fillstyle=(solid_fill)
+            setcall data dword_swap(fillarg)
+            add fillstyles_size (DWORD)
+        else
+        #if fillstyle==(repeating_bitmap_fill)
+        #clipped bitmap fill,non-smoothed repeating bitmap or non-smoothed clipped bitmap
+            call dword_to_word_arg(fillarg,#data)
+            sd fill_pointer^data
+            add fill_pointer (WORD)
+            #matrix,scaleX=20,scaleY=20,translateX=0,translateY=0
+            #first bit: scaleX 0 and Y 0;or 1;=>0;else is 1
+            #const FIXEDBITS=16
+            #x and y=floor(scaleX*(1<<FIXEDBITS))=0x00140000
+            #Nbits is 0x15 + 1(sign)
+            const predef_nbits=0x16
+            const predef_XYscale=0x00140000
+            #rotate is 0
+            #translate nbits is 0
+            call bits_packs(fill_pointer,6,1,1,(predef_nbits),(NBits_size),(predef_XYscale),(predef_nbits),(predef_XYscale),(predef_nbits),0,1,0,(NBits_size))
+            #char ref_id#2
+            #char matrix#7
+            add fillstyles_size (2+7)
+        endelse
+    endif
+    add shape_size fillstyles_size
+    #
+    char LineStyleCount#1
+    char line_points#2
+    data color#1
+    vdata linestyles^LineStyleCount
+    sd linestyles_size=1
+    set LineStyleCount 0
+    if linewidth!=0
+        set LineStyleCount 1
+        mult linewidth 20
+        call dword_to_word_arg(linewidth,#line_points)
+        setcall color dword_swap(linecolor)
+        add linestyles_size (WORD+DWORD)
+    endif
+    add shape_size linestyles_size
+    #NumFillBits/NumLineBits
+    call NFill_NLin(0,FillStyleCount,LineStyleCount)
+    sd NumFill_NumLin;setcall NumFill_NumLin NFill_NLin(1,(TRUE));mult NumFill_NumLin 0x10;orcall NumFill_NumLin NFill_NLin(1,(FALSE))
+    inc shape_size
+    #shaperecord[n]
+    sd shapewithstyle_record_start
+    setcall shapewithstyle_record_start shapewithstyle_records()
+    value pointer#1;data pos#1
+    set pos 0x80
+    set pointer shapewithstyle_record_start
+    sd p_dest_pos^pointer
+    while args#!=-1
+        call shape_records_add(p_dest_pos,#args)
+    endwhile
+    data end={0,0}
+    sd end_record^end
+    call shape_records_add(p_dest_pos,#end_record)
+    if pos!=0x80
+        inc pointer
+    endif
+    sd records_sz
+    set records_sz pointer
+    sub records_sz shapewithstyle_record_start
+    add shape_size records_sz
+
+    call swf_tag_recordheader_entry((DefineShape3),shape_size)
+    call swf_mem_add(#shape_id,2)
+    call swf_mem_add(rect,rect_size)
+    call swf_mem_add(fillstyles,fillstyles_size)
+    call swf_mem_add(linestyles,linestyles_size)
+    call swf_mem_add(#NumFill_NumLin,1)
+    call swf_mem_add(shapewithstyle_record_start,records_sz)
+
+    return shape_id
+endfunction
+
+#id
+functionX swf_shape_basic(sd width,sd height,sd fillcolor,sd linecolor)
+#sd width
+#sd height
+#sd fillcolor       RGBA color to fill the shape
+#sd linecolor       RGBA line color around the shape
+    sd xcurve_value;set xcurve_value width;div xcurve_value 6
+    sd ycurve_value;set ycurve_value height;div ycurve_value 6
+    sd lineheight;set lineheight width;if lineheight>height;set lineheight height;endif;div lineheight 20
+    #xc width/6;yc..hg..;lh (min(w,h))/20
+    sd id
+    setcall id swf_shape_simple(width,height,fillcolor,lineheight,linecolor,xcurve_value,ycurve_value)
+    return id
+endfunction
+
+#id
+functionX swf_shape_bitmap(sd bitmapId,sd width,sd height)
+#sd bitmapId    id, e.g.: from swf_dbl
+    sd shape_id
+    sd width_variable
+    set width_variable width
+    sd height_variable
+    set height_variable height
+    data struct=repeating_bitmap_fill
+        data refid#1
+        set refid bitmapId
+    data *=0
+    data *={0,StateFillStyle0}
+    data *={1,1}
+        data w1#1;data *=0
+        set w1 width_variable
+    data *={1,1}
+        data *=0;data h1#1
+        set h1 height_variable
+    data *={1,1}
+        data w2#1;data *=0
+        mult width_variable -1
+        set w2 width_variable
+    data *={1,1}
+        data *=0;data h2#1
+        mult height_variable -1
+        set h2 height_variable
+    data *=-1
+    setcall shape_id swf_shape(width,height,#struct)
+    return shape_id
+endfunction
+#id
+functionX swf_shape_border(sd width,sd height,sd linesize,sd linecolor)
+#sd width      border width
+#sd height     border height
+#sd linesize  line size
+#sd linecolor  0xRGBA color
+    sd shape
+    sd neg_w=-1
+    sd neg_h=-1
+    mult neg_w width
+    mult neg_h height
+    #
+    if linesize=0;call error("is useless to call shape_border with linesize=0");endif
+    data border=no_fill
+    data l_w#1
+        set l_w linesize
+    data color#1;#linesize!=0
+        set color linecolor
+    #
+    data *={0,StateLineStyle}
+    data *={1,1}
+    data est#1;data *=0
+        set est width
+    data *={1,1}
+    data *=0;data sud#1
+        set sud height
+    data *={1,1}
+    data west#1;data *=0
+        set west neg_w
+    data *={1,1}
+    data *=0;data nord#1
+        set nord neg_h
+    data *=-1
+    setcall shape swf_shape(width,height,#border)
+    return shape
+endfunction
+
+#id
+functionX swf_image(ss imagepath)
+#ss imagepath = path name for the dbl image
+    data width#1;data *height#1
+    sd shape_id;setcall shape_id swf_image_ex(imagepath,#width)
+    return shape_id
+endfunction
+#id
+functionX swf_image_ex(ss imagepath,sd p_wh)
+#ss imagepath = path name for the dbl image
+#sd p_wh      = pointer width height
+    sd dbl_id
+    setcall dbl_id swf_dbl_ex(imagepath,p_wh)
+    #add dbl to a shape
+    sd shape_id
+    sd width;set width p_wh#;add p_wh (DWORD)
+    setcall shape_id swf_shape_bitmap(dbl_id,width,p_wh#)
+    return shape_id
+endfunction
+
+######################dbl
+#id
+functionX swf_dbl(ss imagepath)
+#ss imagepath = path name for the dbl image
+    sd id
+    setcall id swf_dbl_ex(imagepath,0)
+    return id
+endfunction
+import "file_get_content" file_get_content
+#id
+functionX swf_dbl_ex(ss imagepath,sd p_wh)
+#ss imagepath = path name for the dbl image
+#sd p_wh = pointer width a dword and height next dword
+    sd id
+    sd mem
+    sd size
+    sd cursor
+    setcall mem file_get_content(imagepath,#size)
+    if size<8
+        call error("missing image header")
+    endif
+    char hd_magic1={D,B,l,1};vdata magic1^hd_magic1
+    char hd_magic2={D,B,l,2};vdata magic2^hd_magic2
+    if mem#!=magic1#
+    if mem#!=magic2#
+        call printEr("expecting dbl(define bits lossless 1 or 2)header; filepath: ")
+        call error(imagepath)
+    endif;endif
+    sd header=DefineBitsLossless2
+    if mem#=magic1#
+        set header (DefineBitsLossless)
+    endif
+    set cursor mem
+    add cursor (DWORD)
+
+    sd image_size
+    setcall image_size dword_swap(cursor#)
+    add cursor (DWORD)
+    sub size (2*DWORD)
+    if image_size>size
+        call error("size error at dbl")
+    endif
+    #add the define bits lossless file to mem
+    add size (WORD)
+    import "swf_tag_recordheader_long_entry" swf_tag_recordheader_long_entry
+    call swf_tag_recordheader_long_entry(header,size)
+    setcall id identifiers_get()
+    call swf_mem_add(#id,(WORD))
+    if p_wh!=0
+        #get width and height;BitmapFormat UI8,BitmapWidth UI16,BitmapHeight UI16
+        if image_size<(2*WORD+BYTE)
+            call error("size error at dbl when looking for width/height")
+        endif
+        sd pointer
+        set pointer cursor
+        add pointer (BYTE)
+        setcall p_wh# word_arg_to_dword(pointer)
+        add pointer (WORD)
+        add p_wh (DWORD)
+        setcall p_wh# word_arg_to_dword(pointer)
+    endif
+    call swf_mem_add(cursor,image_size)
+    call file_get_content__resources_free()
+    return id
+endfunction
+import "file_open" file_open
+import "file_seek" file_seek
+import "file_read" file_read
+import "filesize" filesize
+
+#width
+functionX swf_dbl_width(ss imagepath)
+#ss imagepath = path name for the dbl image
+    sd file
+    setcall file file_open(imagepath,(_open_read))
+    call file_resources_set(file)
+    sd size
+    setcall size filesize(file)
+    if size<(4+4+1+2)
+        call error("invalid dbl file")
+    endif
+    call file_seek(file,(4+4+1),(SEEK_SET))
+    sd width=0
+    call file_read(file,#width,2)
+    call file_resources_free()
+    return width
+endfunction
+#height
+functionX swf_dbl_height(ss imagepath)
+#ss imagepath = path name for the dbl image
+    sd file
+    setcall file file_open(imagepath,(_open_read))
+    call file_resources_set(file)
+    sd size
+    setcall size filesize(file)
+    if size<(4+4+1+2+2)
+        call error("invalid dbl file")
+    endif
+    call file_seek(file,(4+4+1+2),(SEEK_SET))
+    sd height=0
+    call file_read(file,#height,2)
+    call file_resources_free()
+    return height
+endfunction
+
+##############
+import "exportsId_get" exportsId_get
+functionX swf_done()
+    call swf_exports_done();#remaining exports?
+
+	sd p;set p swf_frames_pointer()
+	call swf_actionblock((mem_exp_part_done),(from_done),p);#in case there are remaining actions
+
+#the swf is done and the total length is wrote and the memory is freed
+    call swf_mem((mem_exp_done))
+    call freereset()
+endfunction
+
+functionX swf_new(ss path,sd width,sd height,sd backgroundcolor,sd fps)
+	call swf_new_ex(path,width,height,backgroundcolor,fps,(debug_none))
+endfunction
+functionX swf_new_ex(ss path,sd width,sd height,sd backgroundcolor,sd fps,sd add_debug)
+#ss path             file out pathname
+#sd width
+#sd height
+#sd backgroundcolor  0xRRGGBB  value
+#sd fps              swf frames per second
+
+    #F=uncompressed, C=ZLib
+const hd_start=\
+    char *=F
+    char *={W,S}
+    char *version=8
+const file_sz_off=\
+    data *FileLength#1
+data size=\-hd_start
+vdata hd_pack%hd_start
+    #rect
+const hd2=\
+    char *FrameRate=0
+        char FrameRate#1
+    char *FrameCount={0,0}  #will be incremented at least once
+data size2=\-hd2
+vdata hd_pack2%hd2
+
+	import "debug_init" debug_init
+	call debug_init(add_debug,path)
+    call swf_mem((mem_exp_init),path,(file_sz_off-hd_start))
+
+    #identifiers for swf
+    call identifiers_set(1);#font with id 0 isn't visible in the placements
+
+    call swf_mem_add(hd_pack,size)
+    call rect_add(width,height)
+    #x.x format
+    set FrameRate fps
+    call swf_mem_add(hd_pack2,size2)
+    #
+
+	call swf_frames_reg() #is a rect with nbits above, ..., faster here
+
+    char setbackgroundtag#2
+    char red#1
+    char green#1
+    char blue#1
+
+    set blue backgroundcolor
+    sd g_color=0xff00;and g_color backgroundcolor;div g_color 0x100;set green g_color
+    sd r_color=0xff0000;and r_color backgroundcolor;div r_color (0x100*0x100);set red r_color
+    call swf_tag(#setbackgroundtag,(SetBackGroundColor),3)
+endfunction
+
+functionX swf_placeobject(sd refid,sd depth)
+#sd refid    the id
+#sd depth    depth value
+     call swf_placeobject_coords(refid,depth,0,0)
+endfunction
+#                                                  if not data here, then will conflict at c language where we talk about int
+functionX swf_placeobject_coords(sd refid,sd depth,datax x,datax y)
+#sd refid
+#sd depth
+#sd x         x coordinate
+#sd y         y coordinate
+#const PlaceFlagHasClipActions=0x80
+#const PlaceFlagHasClipDepth=0x40
+#const PlaceFlagHasName=0x20
+#const PlaceFlagHasRatio=0x10
+#const PlaceFlagHasColorTransform=0x8
+const PlaceFlagHasMatrix=0x4
+const PlaceFlagHasCharacter=0x2
+#const PlaceFlagMove=0x1
+    sd flags=PlaceFlagHasMatrix|PlaceFlagHasCharacter
+    sd matrix
+    datax matrixsz#1
+    call matrix_translate(#matrix,#matrixsz,x,y)
+
+    sd size=5
+    add size matrixsz
+    call swf_tag_recordheader_entry((PlaceObject2),size)
+    call swf_mem_add(#flags,1)
+    call swf_mem_add(#depth,2)
+    #character id
+    call swf_mem_add(#refid,2)
+    #matrix
+    call swf_mem_add(matrix,matrixsz)
+endfunction
+functionX swf_removeobject(sd depth)
+#sd depth        depth for the removeobject2 tag
+    call swf_tag_recordheader_entry((RemoveObject2),2)
+    #depth
+    call swf_mem_add(#depth,2)
+endfunction
+
+import "swf_showframe_base" swf_showframe_base
+
+functionX swf_showframe()
+	sd p;set p swf_frames_pointer()
+	call swf_showframe_base(p)
+endfunction
+
+######################
+
+#sprite
+
+#id
+functionX swf_sprite_done(sd spriteid)
+#sd spriteid        pre-id created with swf_sprite_new
+    call swf_mem((mem_exp_change),spriteid)
+    call swf_actionblock((mem_exp_change),spriteid)
+
+	sd p;setcall p swf_sprite_frames_pointer(spriteid)
+	call swf_actionblock((mem_exp_part_done),(from_done),p);#in case there are remaining actions
+
+    call swf_actionblock((mem_exp_change_back))
+    import "swf_tag_end" swf_tag_end
+    call swf_tag_end()
+    call swf_mem((mem_exp_change_back))
+
+    sd sprite
+    setcall sprite struct_ids((ids_get),spriteid)
+    sd mem
+    setcall mem block_get_mem(sprite)
+    sd size
+    setcall size block_get_size(sprite)
+    #
+    call swf_tag_recordheader_entry((DefineSprite),size)
+    sd id
+    setcall id identifiers_get()
+    call dword_to_word_arg(id,mem)
+    #
+
+    call swf_mem_add(mem,size)
+
+    call free_sprite_id(spriteid)
+
+	import "debug_spritedone" debug_spritedone
+	call debug_spritedone(spriteid,id)
+
+    return id
+endfunction
+import "new_sprite_id" new_sprite_id
+#pre-id
+functionX swf_sprite_new()
+#a pre-id to be used
+    sd id
+    setcall id new_sprite_id()
+    call swf_mem((mem_exp_change),id)
+    sd reserve;#set later
+    call swf_mem_add(#reserve,2)
+    sd frames=0
+    call swf_mem_add(#frames,2)
+    call swf_mem((mem_exp_change_back))
+    return id
+endfunction
+functionX swf_sprite_placeobject(sd spriteid,sd object,sd depth)
+#sd spriteid          pre-id
+#sd object,sd depth   same as swf_placeobject
+    call swf_mem((mem_exp_change),spriteid)
+    call swf_placeobject(object,depth)
+    call swf_mem((mem_exp_change_back))
+endfunction
+functionX swf_sprite_placeobject_coords(sd spriteid,sd object,sd depth,sd x,sd y)
+#sd spriteid                   pre-id
+#sd object,sd depth,sd x,sd y  same as swf_placeobject_coords
+    call swf_mem((mem_exp_change),spriteid)
+    call swf_placeobject_coords(object,depth,x,y)
+    call swf_mem((mem_exp_change_back))
+endfunction
+functionX swf_sprite_removeobject(sd spriteid,sd depth)
+#sd spriteid   pre-id
+#sd depth      same as swf_removeobject
+    call swf_mem((mem_exp_change),spriteid)
+    call swf_removeobject(depth)
+    call swf_mem((mem_exp_change_back))
+endfunction
+functionX swf_sprite_showframe(sd spriteid)
+#sd spriteid   pre-id
+    call swf_mem((mem_exp_change),spriteid)
+    call swf_actionblock((mem_exp_change),spriteid)
+	sd p;setcall p swf_sprite_frames_pointer(spriteid)
+	call swf_showframe_base(p)
+    call swf_actionblock((mem_exp_change_back))
+    call swf_mem((mem_exp_change_back))
+endfunction
+
+######################
+
+#exports
+
+functionX swf_exports_add(sd id,ss name)
+#sd id
+#ss name       name to be used at the actionscript
+    sd exports
+    setcall exports exportsId_get()
+    #
+    call swf_mem((mem_exp_change),exports)
+    #
+    sd block
+    setcall block struct_ids((ids_get),exports)
+    sd size
+    setcall size block_get_size(block)
+    sd counter
+    if size=0
+        set counter 1
+        call swf_mem_add(#counter,(WORD))
+    else
+        sd mem
+        setcall mem block_get_mem(block)
+        setcall counter word_arg_to_dword(mem)
+        inc counter
+        call dword_to_word_arg(counter,mem)
+    endelse
+    #
+    call swf_mem_add(#id,(WORD))
+    sd len
+    setcall len strlen(name)
+    inc len
+    call swf_mem_add(name,len)
+    #
+    call swf_mem((mem_exp_change_back))
+endfunction
+functionX swf_exports_done()
+#write all the exports to the swf
+    sd exports
+    setcall exports exportsId_get()
+    sd block
+    setcall block struct_ids((ids_get),exports)
+    sd size
+    setcall size block_get_size(block)
+    if size!=0
+        #
+        call swf_tag_recordheader_entry((ExportAssets),size)
+        #
+        sd exp
+        setcall exp block_get_mem(block)
+        call swf_mem_add(exp,size)
+        call block_reset_size(block)
+    endif
+endfunction
--- actionswf-1.orig/src/swf.es
+++ /dev/null
@@ -1,968 +0,0 @@
-Format ElfObj64
-
-include "../include/prog.h"
-
-#win32 with _
-importx "memcpy" memcpy
-importx "strlen" strlen
-importx "memcmp" memcmp
-
-import "printEr" printEr
-import "identifiers_set" identifiers_set
-import "identifiers_get" identifiers_get
-import "rect_prepare" rect_prepare
-import "button_mem" button_mem
-
-import "dword_to_word_arg" dword_to_word_arg
-import "dword_swap" dword_swap
-import "args_advance" args_advance
-import "bits_packs" bits_packs
-import "NumFill_NumLin" NFill_NLin
-import "shapewithstyle_records" shapewithstyle_records
-import "word_arg_to_dword" word_arg_to_dword
-import "file_get_content__resources_free" file_get_content__resources_free
-import "file_resources_set" file_resources_set
-import "file_resources_free" file_resources_free
-import "struct_ids" struct_ids
-import "matrix_translate" matrix_translate
-import "block_get_size" block_get_size
-import "block_get_mem" block_get_mem
-import "free_sprite_id" free_sprite_id
-import "block_reset_size" block_reset_size
-import "freereset" freereset   #..x with no args
-
-
-
-
-importaftercall ebool
-
-import "swf_tag" swf_tag
-import "swf_mem" swf_mem
-import "swf_mem_add" swf_mem_add
-import "swf_actionblock" swf_actionblock
-import "rect_add" rect_add
-import "swf_tag_recordheader_entry" swf_tag_recordheader_entry
-import "error" error
-import "swf_shape_simple" swf_shape_simple
-
-import "swf_button_base" swf_button_base
-import "swf_text_initial_font_centered" swf_text_initial_font_centered
-#id
-functionX swf_button(sd width,sd height,sd ButtonData)
-data def_fill#1
-data def_line_h#1;#no pad
-data def_line#1
-
-data ov_fill#1;#no pad
-data ov_line_h#1
-data ov_line#1;#no pad
-
-data dn_fill#1;#no pad
-data dn_line_h#1
-data dn_line#1;#no pad
-
-data xcurve#1
-data ycurve#1;#no pad
-
-vstr text#1
-data font_id#1;data font_height#1;#no pad
-data font_vertical_offset#1;data font_color#1;#no pad
-
-vstr actions#1
-
-#width                  is the button width
-#height                 is the button height
-
-#def_fill               is the ButtonStateUp RGBA fill color
-#def_line_sz            line height in pixels
-#def_line               is the line RGBA
-#ov_fill                is the ButtonStateOver RGBA
-#ov_line_sz             line height
-#ov_line                RGBA
-#dn_fill                is the ButtonStateDown|ButtonStateHitTest RGBA
-#dn_line_sz             line height
-#dn_line                RGBA
-#x_curve                x curve shape value
-#y_curve                y curve shape value
-#text                   button text
-#font_id                a font created with swf_font
-#font_height            font height in pixels
-#font_vertical_offset   font y offset
-#font_color             font RGBA
-#actions                is a string with actionscript
-
-    const button_top_args=11*DWORD
-    call memcpy(#def_fill,ButtonData,(button_top_args))
-    add ButtonData (button_top_args);call memcpy(#text,ButtonData,:)
-    const button_font_args=4*DWORD
-    add ButtonData :;call memcpy(#font_id,ButtonData,(button_font_args))
-    add ButtonData (button_font_args);call memcpy(#actions,ButtonData,:)
-#
-    if font_height>height;call error("font_height>height error at button");endif
-    #
-    sd bmem
-    setcall bmem button_mem()
-    #
-    sd shape_up
-    sd shape_over
-	sd shape_down
-    setcall shape_up swf_shape_simple(width,height,def_fill,def_line_h,def_line,xcurve,ycurve)
-    setcall shape_over swf_shape_simple(width,height,ov_fill,ov_line_h,ov_line,xcurve,ycurve)
-	setcall shape_down swf_shape_simple(width,height,dn_fill,dn_line_h,dn_line,xcurve,ycurve)
-
-    set bmem# shape_up
-    add bmem (DWORD)
-    set bmem# shape_over
-    add bmem (DWORD)
-	set bmem# shape_down
-	add bmem (DWORD)
-
-    set bmem# width;add bmem (DWORD)
-    set bmem# height;add bmem (DWORD)
-
-    sd noText=FALSE;sd text_id
-    data t_null={0,0}
-    sd b;setcall b memcmp(#t_null,#text,:)
-    if b=0
-        set noText (TRUE)
-        set bmem# noText
-    else
-        sd text_y
-        set text_y height
-        sub text_y font_height
-        div text_y 2
-        add text_y font_vertical_offset
-
-        set bmem# noText;add bmem (DWORD)
-        set bmem# font_id;add bmem (DWORD)
-        set bmem# font_height;add bmem (DWORD)
-        set bmem# text_y;add bmem (DWORD)
-        set bmem# font_color
-
-        setcall text_id swf_text_initial_font_centered(width,height,text,font_id,font_height,font_color)
-    endelse
-
-    sd id
-    setcall id swf_button_base(shape_up,shape_over,shape_down,noText,text_id,text_y,actions)
-    return id
-endfunction
-#id
-functionX swf_button_last(ss newtext,ss actions)
-#ss newtext  is the new text for a new button with the attributes from the previous swf_button call
-#ss actions  button actions
-    data shape_up#1
-    data shape_over#1
-	data shape_down#1
-    data width#1
-    data height#1
-    data noText#1
-    data font_id#1
-    data font_height#1
-    data text_y#1
-    data font_color#1
-    sd bmem
-    setcall bmem button_mem()
-    call memcpy(#shape_up,bmem,(9*DWORD))
-
-    if noText=(FALSE)
-        sd newtext_id
-        setcall newtext_id swf_text_initial_font_centered(width,height,newtext,font_id,font_height,font_color)
-    endif
-
-    sd id
-    setcall id swf_button_base(shape_up,shape_over,shape_down,noText,newtext_id,text_y,actions)
-    return id
-endfunction
-
-#font
-
-#id
-functionX swf_font(ss fontname,sd font_flags)
-#ss fontname    = a string with the browser font, for example "_sans"
-#sd font_flags  = prog.h file is with the flags
-    const font_hd_start=!
-
-    char id#2
-    char Flags#1
-    char *Language=0
-    char FontNameLen#1
-
-    const font_hd_start_size=!-font_hd_start
-    vdata font_hd_start^id
-
-    data NumGlyphs=0
-
-    sd fontid
-    setcall fontid identifiers_get()
-    call dword_to_word_arg(fontid,#id)
-
-    set Flags font_flags
-
-    setcall FontNameLen strlen(fontname)
-
-    sd size=font_hd_start_size+2
-
-    sd has_layout=FontFlagsHasLayout
-    and has_layout font_flags
-    add size FontNameLen
-    if has_layout!=0
-        add size (2+2+2+2)
-    endif
-
-    call swf_tag_recordheader_entry((DefineFont2),size)
-    call swf_mem_add(font_hd_start,(font_hd_start_size))
-    call swf_mem_add(fontname,FontNameLen)
-    call swf_mem_add(#NumGlyphs,2)
-    if has_layout!=0
-        char FontAscent={0,0}
-        char *FontDescent={0,0}
-        char *FontLeading={0,0}
-        char *KerningCount={0,0}
-        call swf_mem_add(#FontAscent,(2+2+2+2))
-    endif
-    return fontid
-endfunction
-#id
-functionX swf_font_basic(ss fontname)
-#ss fontname    = a string with the browser font, for example "_sans"
-    sd id
-    setcall id swf_font(fontname,0)
-    return id
-endfunction
-
-#text
-
-#id
-functionX swf_text(sd bound_width,sd bound_height,ss variablename,sd flags,sv structure)
-#sd bound_width  width of the text
-#sd bound_height height
-#ss variablename to change it with actionscript
-#sd flags        see include/text.h
-#sv structure    see edittext_struct()  from character.s, set the flags first
-    #CharacterID
-    sd size=2
-    #RECT
-    sd rect
-    sd rectsz
-    call rect_prepare(#rect,#rectsz,bound_width,bound_height)
-    add size rectsz
-    #flags
-    add size 2
-    #FontID
-    sd p_fontid
-    sd hasfont=HasFont
-    and hasfont flags
-    if hasfont!=0
-        set p_fontid structure
-        add size 2
-    endif
-    #FontClass
-    ss fontclassname
-    sd fontclasssize
-    sd hasfontclass=HasFontClass
-    and hasfontclass flags
-    add structure (2*DWORD)
-    if hasfontclass!=0
-        if hasfont!=0
-            call error("HasFontClass can't be true if HasFont is true.")
-        endif
-        set fontclassname structure#
-        setcall fontclasssize strlen(fontclassname)
-        inc fontclasssize
-        add size fontclasssize
-    endif
-    #FontHeight
-    sd p_font_height
-    sub structure (DWORD)
-    if hasfont!=0
-        set p_font_height structure
-        add size 2
-    endif
-    #TextColor
-    sd p_rgba
-    sd hastextcolor=HasTextColor
-    and hastextcolor flags
-    add structure (DWORD+:)
-    if hastextcolor!=0
-        set p_rgba structure
-        add size 4
-    endif
-    #MaxLength
-    sd p_maxlength
-    sd hasmaxlength=HasMaxLength
-    and hasmaxlength flags
-    add structure (DWORD)
-    if hasmaxlength!=0
-        set p_maxlength structure
-        add size 2
-    endif
-    #layout
-    sd p_layout
-    data layout_size=4*WORD+BYTE
-    sd haslayout=HasLayout
-    and haslayout flags
-    add structure (DWORD+:)
-    if haslayout!=0
-        set p_layout structure
-        add size layout_size
-    endif
-    #VariableName
-    sd vlen
-    setcall vlen strlen(variablename)
-    inc vlen
-    add size vlen
-    #InitialText
-    ss initialtext
-    sd initialtextsize
-    sd hastext=HasText
-    and hastext flags
-    sub structure :
-    if hastext!=0
-        set initialtext structure#
-        setcall initialtextsize strlen(initialtext)
-        inc initialtextsize
-        add size initialtextsize
-    endif
-
-    call swf_tag_recordheader_entry((DefineEditText),size)
-    sd id
-    setcall id identifiers_get()
-    call swf_mem_add(#id,2)
-    call swf_mem_add(rect,rectsz)
-    call swf_mem_add(#flags,2)
-    #
-    if hasfont!=0
-        call swf_mem_add(p_fontid,2)
-    endif
-    if hasfontclass!=0
-        call swf_mem_add(fontclassname,fontclasssize)
-    endif
-    if hasfont!=0
-        sd height
-        set height p_font_height#
-        mult height 20
-        call swf_mem_add(#height,2)
-    endif
-    if hastextcolor!=0
-        setcall p_rgba# dword_swap(p_rgba#)
-        call swf_mem_add(p_rgba,4)
-    endif
-    if hasmaxlength!=0
-        call swf_mem_add(p_maxlength,2)
-    endif
-    if haslayout!=0
-        data layout_align#1
-        data layout_leftmargin#1
-        data layout_rightmargin#1
-        data layout_indent#1
-        data layout_leading#1
-        call memcpy(#layout_align,p_layout,(5*DWORD))
-        mult layout_leftmargin 20
-        mult layout_rightmargin 20
-        mult layout_indent 20
-        mult layout_leading 20
-        char l_align#1
-        char l_leftmargin#2
-        char l_rightmargin#2
-        char l_indent#2
-        char l_leading#2
-        set l_align layout_align
-        call dword_to_word_arg(layout_leftmargin,#l_leftmargin)
-        call dword_to_word_arg(layout_rightmargin,#l_rightmargin)
-        call dword_to_word_arg(layout_indent,#l_indent)
-        call dword_to_word_arg(layout_leading,#l_leading)
-        call swf_mem_add(#l_align,layout_size)
-    endif
-    call swf_mem_add(variablename,vlen)
-    if hastext!=0
-        call swf_mem_add(initialtext,initialtextsize)
-    endif
-    return id
-endfunction
-
-import "shape_records_add" shape_records_add
-#id
-functionX swf_shape(sd width,sd height,sd args)
-#sd width
-#sd height
-#sd args        see swf_shape_basic or swf_image(last part) for example, or see shape_records_add and it's sub-functions to see how the swf SHAPERECORD is added
-    if width=0
-        call error("shape width 0 not allowed")
-    elseif height=0
-        call error("shape height 0 not allowed")
-    endelseif
-    sd fillstyle
-    sd fillarg
-    sd linewidth
-    sd linecolor
-
-    setcall fillstyle args_advance(#args)
-    if fillstyle!=(no_fill)
-        setcall fillarg args_advance(#args)
-    endif
-    setcall linewidth args_advance(#args)
-    if linewidth!=0
-        setcall linecolor args_advance(#args)
-    endif
-    ########
-    sd shape_size
-
-    #id
-    sd shape_id
-    setcall shape_id identifiers_get()
-    set shape_size (WORD)
-
-    #rect
-    sd rect
-    sd rect_size
-    call rect_prepare(#rect,#rect_size,width,height)
-    add shape_size rect_size
-
-    #SHAPEWITHSTYLE
-    char FillStyleCount#1
-        char FillStyleType#1
-    #
-        data data#3
-    vdata fillstyles^FillStyleCount
-    set FillStyleCount 0
-    sd fillstyles_size=1
-    if fillstyle!=(no_fill)
-        set FillStyleCount 1
-        set FillStyleType fillstyle
-        add fillstyles_size 1
-        if fillstyle=(solid_fill)
-            setcall data dword_swap(fillarg)
-            add fillstyles_size (DWORD)
-        else
-        #if fillstyle==(repeating_bitmap_fill)
-        #clipped bitmap fill,non-smoothed repeating bitmap or non-smoothed clipped bitmap
-            call dword_to_word_arg(fillarg,#data)
-            sd fill_pointer^data
-            add fill_pointer (WORD)
-            #matrix,scaleX=20,scaleY=20,translateX=0,translateY=0
-            #first bit: scaleX 0 and Y 0;or 1;=>0;else is 1
-            #const FIXEDBITS=16
-            #x and y=floor(scaleX*(1<<FIXEDBITS))=0x00140000
-            #Nbits is 0x15 + 1(sign)
-            const predef_nbits=0x16
-            const predef_XYscale=0x00140000
-            #rotate is 0
-            #translate nbits is 0
-            call bits_packs(fill_pointer,6,1,1,(predef_nbits),(NBits_size),(predef_XYscale),(predef_nbits),(predef_XYscale),(predef_nbits),0,1,0,(NBits_size))
-            #char ref_id#2
-            #char matrix#7
-            add fillstyles_size (2+7)
-        endelse
-    endif
-    add shape_size fillstyles_size
-    #
-    char LineStyleCount#1
-    char line_points#2
-    data color#1
-    vdata linestyles^LineStyleCount
-    sd linestyles_size=1
-    set LineStyleCount 0
-    if linewidth!=0
-        set LineStyleCount 1
-        mult linewidth 20
-        call dword_to_word_arg(linewidth,#line_points)
-        setcall color dword_swap(linecolor)
-        add linestyles_size (WORD+DWORD)
-    endif
-    add shape_size linestyles_size
-    #NumFillBits/NumLineBits
-    call NFill_NLin(0,FillStyleCount,LineStyleCount)
-    sd NumFill_NumLin;setcall NumFill_NumLin NFill_NLin(1,(TRUE));mult NumFill_NumLin 0x10;orcall NumFill_NumLin NFill_NLin(1,(FALSE))
-    inc shape_size
-    #shaperecord[n]
-    sd shapewithstyle_record_start
-    setcall shapewithstyle_record_start shapewithstyle_records()
-    value pointer#1;data pos#1
-    set pos 0x80
-    set pointer shapewithstyle_record_start
-    sd p_dest_pos^pointer
-    while args#!=-1
-        call shape_records_add(p_dest_pos,#args)
-    endwhile
-    data end={0,0}
-    sd end_record^end
-    call shape_records_add(p_dest_pos,#end_record)
-    if pos!=0x80
-        inc pointer
-    endif
-    sd records_sz
-    set records_sz pointer
-    sub records_sz shapewithstyle_record_start
-    add shape_size records_sz
-
-    call swf_tag_recordheader_entry((DefineShape3),shape_size)
-    call swf_mem_add(#shape_id,2)
-    call swf_mem_add(rect,rect_size)
-    call swf_mem_add(fillstyles,fillstyles_size)
-    call swf_mem_add(linestyles,linestyles_size)
-    call swf_mem_add(#NumFill_NumLin,1)
-    call swf_mem_add(shapewithstyle_record_start,records_sz)
-
-    return shape_id
-endfunction
-
-#id
-functionX swf_shape_basic(sd width,sd height,sd fillcolor,sd linecolor)
-#sd width
-#sd height
-#sd fillcolor       RGBA color to fill the shape
-#sd linecolor       RGBA line color around the shape
-    sd xcurve_value;set xcurve_value width;div xcurve_value 6
-    sd ycurve_value;set ycurve_value height;div ycurve_value 6
-    sd lineheight;set lineheight width;if lineheight>height;set lineheight height;endif;div lineheight 20
-    #xc width/6;yc..hg..;lh (min(w,h))/20
-    sd id
-    setcall id swf_shape_simple(width,height,fillcolor,lineheight,linecolor,xcurve_value,ycurve_value)
-    return id
-endfunction
-
-#id
-functionX swf_shape_bitmap(sd bitmapId,sd width,sd height)
-#sd bitmapId    id, e.g.: from swf_dbl
-    sd shape_id
-    sd width_variable
-    set width_variable width
-    sd height_variable
-    set height_variable height
-    data struct=repeating_bitmap_fill
-        data refid#1
-        set refid bitmapId
-    data *=0
-    data *={0,StateFillStyle0}
-    data *={1,1}
-        data w1#1;data *=0
-        set w1 width_variable
-    data *={1,1}
-        data *=0;data h1#1
-        set h1 height_variable
-    data *={1,1}
-        data w2#1;data *=0
-        mult width_variable -1
-        set w2 width_variable
-    data *={1,1}
-        data *=0;data h2#1
-        mult height_variable -1
-        set h2 height_variable
-    data *=-1
-    setcall shape_id swf_shape(width,height,#struct)
-    return shape_id
-endfunction
-#id
-functionX swf_shape_border(sd width,sd height,sd linesize,sd linecolor)
-#sd width      border width
-#sd height     border height
-#sd linesize  line size
-#sd linecolor  0xRGBA color
-    sd shape
-    sd neg_w=-1
-    sd neg_h=-1
-    mult neg_w width
-    mult neg_h height
-    #
-    if linesize=0;call error("is useless to call shape_border with linesize=0");endif
-    data border=no_fill
-    data l_w#1
-        set l_w linesize
-    data color#1;#linesize!=0
-        set color linecolor
-    #
-    data *={0,StateLineStyle}
-    data *={1,1}
-    data est#1;data *=0
-        set est width
-    data *={1,1}
-    data *=0;data sud#1
-        set sud height
-    data *={1,1}
-    data west#1;data *=0
-        set west neg_w
-    data *={1,1}
-    data *=0;data nord#1
-        set nord neg_h
-    data *=-1
-    setcall shape swf_shape(width,height,#border)
-    return shape
-endfunction
-
-#id
-functionX swf_image(ss imagepath)
-#ss imagepath = path name for the dbl image
-    data width#1;data *height#1
-    sd shape_id;setcall shape_id swf_image_ex(imagepath,#width)
-    return shape_id
-endfunction
-#id
-functionX swf_image_ex(ss imagepath,sd p_wh)
-#ss imagepath = path name for the dbl image
-#sd p_wh      = pointer width height
-    sd dbl_id
-    setcall dbl_id swf_dbl_ex(imagepath,p_wh)
-    #add dbl to a shape
-    sd shape_id
-    sd width;set width p_wh#;add p_wh (DWORD)
-    setcall shape_id swf_shape_bitmap(dbl_id,width,p_wh#)
-    return shape_id
-endfunction
-
-######################dbl
-#id
-functionX swf_dbl(ss imagepath)
-#ss imagepath = path name for the dbl image
-    sd id
-    setcall id swf_dbl_ex(imagepath,0)
-    return id
-endfunction
-import "file_get_content" file_get_content
-#id
-functionX swf_dbl_ex(ss imagepath,sd p_wh)
-#ss imagepath = path name for the dbl image
-#sd p_wh = pointer width a dword and height next dword
-    sd id
-    sd mem
-    sd size
-    sd cursor
-    setcall mem file_get_content(imagepath,#size)
-    if size<8
-        call error("missing image header")
-    endif
-    char hd_magic1={D,B,l,1};vdata magic1^hd_magic1
-    char hd_magic2={D,B,l,2};vdata magic2^hd_magic2
-    if mem#!=magic1#
-    if mem#!=magic2#
-        call printEr("expecting dbl(define bits lossless 1 or 2)header; filepath: ")
-        call error(imagepath)
-    endif;endif
-    sd header=DefineBitsLossless2
-    if mem#=magic1#
-        set header (DefineBitsLossless)
-    endif
-    set cursor mem
-    add cursor (DWORD)
-
-    sd image_size
-    setcall image_size dword_swap(cursor#)
-    add cursor (DWORD)
-    sub size (2*DWORD)
-    if image_size>size
-        call error("size error at dbl")
-    endif
-    #add the define bits lossless file to mem
-    add size (WORD)
-    import "swf_tag_recordheader_long_entry" swf_tag_recordheader_long_entry
-    call swf_tag_recordheader_long_entry(header,size)
-    setcall id identifiers_get()
-    call swf_mem_add(#id,(WORD))
-    if p_wh!=0
-        #get width and height;BitmapFormat UI8,BitmapWidth UI16,BitmapHeight UI16
-        if image_size<(2*WORD+BYTE)
-            call error("size error at dbl when looking for width/height")
-        endif
-        sd pointer
-        set pointer cursor
-        add pointer (BYTE)
-        setcall p_wh# word_arg_to_dword(pointer)
-        add pointer (WORD)
-        add p_wh (DWORD)
-        setcall p_wh# word_arg_to_dword(pointer)
-    endif
-    call swf_mem_add(cursor,image_size)
-    call file_get_content__resources_free()
-    return id
-endfunction
-import "file_open" file_open
-import "file_seek" file_seek
-import "file_read" file_read
-import "filesize" filesize
-
-#width
-functionX swf_dbl_width(ss imagepath)
-#ss imagepath = path name for the dbl image
-    sd file
-    setcall file file_open(imagepath,(_open_read))
-    call file_resources_set(file)
-    sd size
-    setcall size filesize(file)
-    if size<(4+4+1+2)
-        call error("invalid dbl file")
-    endif
-    call file_seek(file,(4+4+1),(SEEK_SET))
-    sd width=0
-    call file_read(file,#width,2)
-    call file_resources_free()
-    return width
-endfunction
-#height
-functionX swf_dbl_height(ss imagepath)
-#ss imagepath = path name for the dbl image
-    sd file
-    setcall file file_open(imagepath,(_open_read))
-    call file_resources_set(file)
-    sd size
-    setcall size filesize(file)
-    if size<(4+4+1+2+2)
-        call error("invalid dbl file")
-    endif
-    call file_seek(file,(4+4+1+2),(SEEK_SET))
-    sd height=0
-    call file_read(file,#height,2)
-    call file_resources_free()
-    return height
-endfunction
-
-##############
-import "exportsId_get" exportsId_get
-functionX swf_done()
-    call swf_exports_done();#remaining exports?
-    call swf_actionblock((mem_exp_part_done));#in case there are remaining actions
-#the swf is done and the total length is wrote and the memory is freed
-    call swf_mem((mem_exp_done))
-    call freereset()
-endfunction
-
-functionX swf_new(ss path,sd width,sd height,sd backgroundcolor,sd fps)
-	call swf_new_ex(path,width,height,backgroundcolor,fps,(FALSE))
-endfunction
-functionX swf_new_ex(ss path,sd width,sd height,sd backgroundcolor,sd fps,sd add_debug)
-#ss path             file out pathname
-#sd width
-#sd height
-#sd backgroundcolor  0xRRGGBB  value
-#sd fps              swf frames per second
-
-    #F=uncompressed, C=ZLib
-const hd_start=!
-    char *=F
-    char *={W,S}
-    char *version=8
-const file_sz_off=!
-    data *FileLength#1
-data size=!-hd_start
-vdata hd_pack%hd_start
-    #rect
-const hd2=!
-    char *FrameRate=0
-        char FrameRate#1
-    char *FrameCount={1,0}
-data size2=!-hd2
-vdata hd_pack2%hd2
-
-	import "debug_init" debug_init
-	call debug_init(add_debug,path)
-    call swf_mem((mem_exp_init),path,(file_sz_off-hd_start))
-
-    #identifiers for swf
-    call identifiers_set(1);#font with id 0 isn't visible in the placements
-
-    call swf_mem_add(hd_pack,size)
-    call rect_add(width,height)
-    #x.x format
-    set FrameRate fps
-    call swf_mem_add(hd_pack2,size2)
-    #
-
-    char setbackgroundtag#2
-    char red#1
-    char green#1
-    char blue#1
-
-    set blue backgroundcolor
-    sd g_color=0xff00;and g_color backgroundcolor;div g_color 0x100;set green g_color
-    sd r_color=0xff0000;and r_color backgroundcolor;div r_color (0x100*0x100);set red r_color
-    call swf_tag(#setbackgroundtag,(SetBackGroundColor),3)
-endfunction
-
-functionX swf_placeobject(sd refid,sd depth)
-#sd refid    the id
-#sd depth    depth value
-     call swf_placeobject_coords(refid,depth,0,0)
-endfunction
-#                                                  if not data here, then will conflict at c language where we talk about int
-functionX swf_placeobject_coords(sd refid,sd depth,datax x,datax y)
-#sd refid
-#sd depth
-#sd x         x coordinate
-#sd y         y coordinate
-#const PlaceFlagHasClipActions=0x80
-#const PlaceFlagHasClipDepth=0x40
-#const PlaceFlagHasName=0x20
-#const PlaceFlagHasRatio=0x10
-#const PlaceFlagHasColorTransform=0x8
-const PlaceFlagHasMatrix=0x4
-const PlaceFlagHasCharacter=0x2
-#const PlaceFlagMove=0x1
-    sd flags=PlaceFlagHasMatrix|PlaceFlagHasCharacter
-    sd matrix
-    datax matrixsz#1
-    call matrix_translate(#matrix,#matrixsz,x,y)
-
-    sd size=5
-    add size matrixsz
-    call swf_tag_recordheader_entry((PlaceObject2),size)
-    call swf_mem_add(#flags,1)
-    call swf_mem_add(#depth,2)
-    #character id
-    call swf_mem_add(#refid,2)
-    #matrix
-    call swf_mem_add(matrix,matrixsz)
-endfunction
-functionX swf_removeobject(sd depth)
-#sd depth        depth for the removeobject2 tag
-    call swf_tag_recordheader_entry((RemoveObject2),2)
-    #depth
-    call swf_mem_add(#depth,2)
-endfunction
-
-functionX swf_showframe()
-#showframe tag
-    call swf_actionblock((mem_exp_part_done))
-    call swf_tag_recordheader_entry((ShowFrame),0)
-endfunction
-
-######################
-
-#sprite
-
-#id
-functionX swf_sprite_done(sd spriteid)
-#sd spriteid        pre-id created with swf_sprite_new
-    call swf_mem((mem_exp_change),spriteid)
-    call swf_actionblock((mem_exp_change),spriteid)
-    call swf_actionblock((mem_exp_part_done));#in case there are remaining actions
-    call swf_actionblock((mem_exp_change_back))
-    import "swf_tag_end" swf_tag_end
-    call swf_tag_end()
-    call swf_mem((mem_exp_change_back))
-
-    sd sprite
-    setcall sprite struct_ids((ids_get),spriteid)
-    sd mem
-    setcall mem block_get_mem(sprite)
-    sd size
-    setcall size block_get_size(sprite)
-    #
-    call swf_tag_recordheader_entry((DefineSprite),size)
-    sd id
-    setcall id identifiers_get()
-    call dword_to_word_arg(id,mem)
-    #
-
-    call swf_mem_add(mem,size)
-
-    call free_sprite_id(spriteid)
-
-    return id
-endfunction
-import "new_sprite_id" new_sprite_id
-#pre-id
-functionX swf_sprite_new()
-#a pre-id to be used
-    sd id
-    setcall id new_sprite_id()
-    call swf_mem((mem_exp_change),id)
-    sd reserve;#set later
-    call swf_mem_add(#reserve,2)
-    sd frames=0
-    call swf_mem_add(#frames,2)
-    call swf_mem((mem_exp_change_back))
-    return id
-endfunction
-functionX swf_sprite_placeobject(sd spriteid,sd object,sd depth)
-#sd spriteid          pre-id
-#sd object,sd depth   same as swf_placeobject
-    call swf_mem((mem_exp_change),spriteid)
-    call swf_placeobject(object,depth)
-    call swf_mem((mem_exp_change_back))
-endfunction
-functionX swf_sprite_placeobject_coords(sd spriteid,sd object,sd depth,sd x,sd y)
-#sd spriteid                   pre-id
-#sd object,sd depth,sd x,sd y  same as swf_placeobject_coords
-    call swf_mem((mem_exp_change),spriteid)
-    call swf_placeobject_coords(object,depth,x,y)
-    call swf_mem((mem_exp_change_back))
-endfunction
-functionX swf_sprite_removeobject(sd spriteid,sd depth)
-#sd spriteid   pre-id
-#sd depth      same as swf_removeobject
-    call swf_mem((mem_exp_change),spriteid)
-    call swf_removeobject(depth)
-    call swf_mem((mem_exp_change_back))
-endfunction
-functionX swf_sprite_showframe(sd spriteid)
-#sd spriteid   pre-id
-    call swf_mem((mem_exp_change),spriteid)
-    #
-    sd sprite
-    setcall sprite struct_ids((ids_get),spriteid)
-    sd mem
-    setcall mem block_get_mem(sprite)
-    add mem (WORD)
-    sd frames
-    setcall frames word_arg_to_dword(mem)
-    inc frames
-    call dword_to_word_arg(frames,mem)
-    #
-    call swf_actionblock((mem_exp_change),spriteid)
-    call swf_showframe()
-    call swf_actionblock((mem_exp_change_back))
-    call swf_mem((mem_exp_change_back))
-endfunction
-
-######################
-
-#exports
-
-functionX swf_exports_add(sd id,ss name)
-#sd id
-#ss name       name to be used at the actionscript
-    sd exports
-    setcall exports exportsId_get()
-    #
-    call swf_mem((mem_exp_change),exports)
-    #
-    sd block
-    setcall block struct_ids((ids_get),exports)
-    sd size
-    setcall size block_get_size(block)
-    sd counter
-    if size=0
-        set counter 1
-        call swf_mem_add(#counter,(WORD))
-    else
-        sd mem
-        setcall mem block_get_mem(block)
-        setcall counter word_arg_to_dword(mem)
-        inc counter
-        call dword_to_word_arg(counter,mem)
-    endelse
-    #
-    call swf_mem_add(#id,(WORD))
-    sd len
-    setcall len strlen(name)
-    inc len
-    call swf_mem_add(name,len)
-    #
-    call swf_mem((mem_exp_change_back))
-endfunction
-functionX swf_exports_done()
-#write all the exports to the swf
-    sd exports
-    setcall exports exportsId_get()
-    sd block
-    setcall block struct_ids((ids_get),exports)
-    sd size
-    setcall size block_get_size(block)
-    if size!=0
-        #
-        call swf_tag_recordheader_entry((ExportAssets),size)
-        #
-        sd exp
-        setcall exp block_get_mem(block)
-        call swf_mem_add(exp,size)
-        call block_reset_size(block)
-    endif
-endfunction
--- /dev/null
+++ actionswf-1/src/tool.e.oc
@@ -0,0 +1,24 @@
+Format ElfObj64
+
+import "erbool" erbool
+functionx erbool_get()
+    ss p;setcall p erbool()
+    return p#
+endfunction
+
+functionx erbool_reset()
+    ss p;setcall p erbool()
+    set p# 0
+endfunction
+
+include "../include/prog.h"
+
+functionx freereset()
+#this is called by user only if want to abort after some calls
+#               and at some frees
+	import "debug_free" debug_free
+	call debug_free()
+	#free and set initial null/-1.....
+	import "swf_mem" swf_mem
+	call swf_mem((mem_exp_free))
+endfunction
--- actionswf-1.orig/src/tool.es
+++ /dev/null
@@ -1,24 +0,0 @@
-Format ElfObj64
-
-import "erbool" erbool
-functionx erbool_get()
-    ss p;setcall p erbool()
-    return p#
-endfunction
-
-functionx erbool_reset()
-    ss p;setcall p erbool()
-    set p# 0
-endfunction
-
-include "../include/prog.h"
-
-functionx freereset()
-#this is called by user only if want to abort after some calls
-#               and at some frees
-	import "debug_free" debug_free
-	call debug_free()
-	#free and set initial null/-1.....
-	import "swf_mem" swf_mem
-	call swf_mem((mem_exp_free))
-endfunction
--- /dev/null
+++ actionswf-1/src/util.oc
@@ -0,0 +1,550 @@
+Format ElfObj64
+
+#win32 with _
+importx "fwrite" fwrite
+importx "realloc" realloc
+importx "memcpy" memcpy
+importx "free" free
+importx "strcspn" strcspn
+importx "strlen" strlen
+importx "memcmp" memcmp
+
+import "platform_iob" platform_iob
+
+include "../include/prog.h"
+
+function printEr(ss msg)
+    sd len;setcall len strlen(msg)
+    call printEr_func(msg,(BYTE),len)
+endfunction
+#p
+function printEr_func(ss msg,sd *item_size,sd *count,sd stderr)
+#                                                    this argument is not passed, is structure last part
+    setcall stderr platform_iob()
+    callex fwrite #msg 4
+    #bytes written,error:sz!=return
+endfunction
+
+function word_swap_arg(ss word)
+    sd a
+    ss aux^a
+    set aux# word#
+    ss dest
+    set dest word
+    inc word
+    set dest# word#
+    set word# aux#
+endfunction
+function dword_to_word_arg(sd int,ss arg)
+    set arg# int
+    inc arg
+    div int 0x100
+    set arg# int
+endfunction
+function word_arg_to_dword(ss arg)
+    inc arg
+    sd value
+    set value arg#
+    mult value 0x100
+    dec arg
+    or value arg#
+    return value
+endfunction
+#swapped data
+function dword_swap(sd value)
+    sd al
+    sd ah
+    sd third
+    sd last
+
+    set al value
+    and al 0xff
+
+    set ah value
+    and ah 0xff00
+
+    set third value
+    and third (0xff00*0x100)
+
+    set last value
+    and last (0xff00<<8<<8)
+
+    sd res=0x100*0x100*0x100
+    mult res al
+    #
+    mult ah 0x100
+    or res ah
+    #
+    div third 0x100
+    or res third
+    #
+    div last (0x100*0x100*0x100)
+    #for negative division, the number can be negative
+    and last 0xff
+    or res last
+    #
+    return res
+endfunction
+function struct_off(sd struct,sd off)
+    add struct off
+    return struct#
+endfunction
+
+#util
+
+function string_nl_print(ss msg)
+    call printEr(msg)
+    char nl={0xa,0}
+    call printEr(#nl)
+endfunction
+
+#block
+
+function block_reset_size(sd block)
+    add block (mem_struct__size_off)
+    set block# (mem_struct_size)
+endfunction
+#size
+function block_get_size(sd block)
+    sd size
+    setcall size struct_off(block,(mem_struct__size_off))
+    sub size (mem_struct_size)
+    return size
+endfunction
+#size
+function block_get_fullsize(sd block)
+    sd size
+    setcall size struct_off(block,(mem_struct__size_off))
+    return size
+endfunction
+#mem
+function block_get_mem(sd block)
+    add block (mem_struct_size)
+    return block
+endfunction
+function block_get_mem_size(sd block,sv p_mem,sv p_size)  #size is a stack variable
+    setcall p_mem# block_get_mem(block)
+    setcall p_size# block_get_size(block)
+endfunction
+
+#mem procedures
+
+function mem_free(sv p_mem)
+    call free(p_mem#)
+    set p_mem# (NULL)
+endfunction
+
+#pointer
+
+function move_to_n_pointer(sd pointer,sd id)
+    mult id :
+    add pointer id
+    return pointer
+endfunction
+
+#strings/chars
+
+#chars
+
+#bool
+function is_numeric(sd char)
+    char min="0"
+    char max="9"
+    if char<min
+        return (FALSE)
+    elseif char<=max
+        return (TRUE)
+    endelseif
+    return (FALSE)
+endfunction
+#bool
+function part_of_variable(sd value)
+    sd bool
+    setcall bool is_numeric(value)
+    if bool=(TRUE)
+        return (TRUE)
+    endif
+    setcall bool is_letter(value)
+    return bool
+endfunction
+#bool
+function is_letter(sd value)
+    if value<(A)
+        return (FALSE)
+    elseif value<=(Z)
+        return (TRUE)
+    elseif value=(_)
+        return (TRUE)
+    elseif value<(a)
+        return (FALSE)
+    elseif value<=(z)
+        return (TRUE)
+    endelseif
+    return (FALSE)
+endfunction
+
+#strings
+
+#str
+function str_next(ss s,ss delims,sv p_op)  #p_op is pointing at a stack variable
+    sd pos
+    setcall pos strcspn(s,delims)
+    ss x
+    set x s
+    add x pos
+    set p_op# x#
+    if x#=0
+        return x
+    endif
+    set x# 0
+    inc x
+    return x
+endfunction
+#bool
+function str_at_str_start(ss s1,ss s2)
+    sd l1
+    sd l2
+    setcall l1 strlen(s1)
+    setcall l2 strlen(s2)
+    if l1<l2
+        return (FALSE)
+    endif
+    sd comp
+    setcall comp memcmp(s1,s2,l2)
+    if comp=0
+        return (TRUE)
+    endif
+    return (FALSE)
+endfunction
+
+#next/same
+function str_expression_at_start(ss string,ss expression)
+    sd bool
+    setcall bool str_at_str_start(string,expression)
+    if bool=(FALSE)
+        return string
+    endif
+    ss next
+    set next string
+    addcall next strlen(expression)
+    setcall bool part_of_variable(next#)
+    if bool=(TRUE)
+        return string
+    endif
+    setcall next spaces(next)
+    return next
+endfunction
+#next/same
+function str_expression_at_start_withEndCare(ss ac,ss expression)
+    ss pointer
+    setcall pointer str_expression_at_start(ac,expression)
+    if pointer=ac
+        return ac
+    endif
+    char term=";"
+    if pointer#=term
+        inc pointer
+    endif
+    return pointer
+endfunction
+
+#str
+function spaces(ss str)
+    while 1=1
+        if str#!=(Space)
+            if str#!=(HorizontalTab)
+                return str
+            endif
+        endif
+        inc str
+    endwhile
+endfunction
+
+
+#closings
+
+import "file_close" file_close
+function file_resources(sd trueIsSet_falseIsFree,sd fileIn)
+    data file=fd_none
+    if trueIsSet_falseIsFree=(TRUE)
+        set file fileIn
+    else
+        if file!=(fd_none)
+            call file_close(#file)
+        endif
+    endelse
+endfunction
+function file_resources_set(sd file)
+    call file_resources((TRUE),file)
+endfunction
+function file_resources_free()
+    call file_resources((FALSE))
+endfunction
+
+#
+
+function freelater()
+    #this can be after code_values(in last_free); but normal is this at action and last_free at swf_done(without this)
+    call action_debug_free()
+    #
+    call file_get_content__resources_free()
+
+    call file_resources_free()
+endfunction
+
+import "action_error" action_error
+
+import "freereset" freereset   #..x with no args
+
+import "action_debug_free" action_debug_free
+import "file_get_content__resources_free" file_get_content__resources_free
+
+
+
+
+
+
+
+
+function erbool()
+    aftercall ebool
+    return #ebool
+endfunction
+
+
+
+
+
+
+
+
+function error(ss msg)
+    call string_nl_print(msg)
+    call action_error()
+
+	call freereset()
+	call freelater()
+
+    ss p;setcall p erbool();set p# 1
+endfunction
+
+#
+function memrealloc(sd mem,sd size)
+#unele fisiere pot da eroare de la realocare; fara functia asta aftercall poate fi degeaba
+    sd ptr;sd n=NULL
+    setcall ptr realloc(mem,size)
+    sd comp;setcall comp memcmp(#ptr,#n,:)
+    if comp=0
+        call error("realloc failed")
+    endif
+    return ptr
+endfunction
+function memalloc(sd size)
+    sd mem
+    setcall mem memrealloc(0,size)
+    return mem
+endfunction
+
+#inits
+
+#id
+function def_mem()
+    sd id
+    setcall id struct_ids((ids_set))
+    return id
+endfunction
+#mem
+function def_data()
+	sd mem
+	setcall mem memalloc((block_size))
+	set mem# (block_size)
+	call block_reset_size(mem)
+	return mem
+endfunction
+
+#mem procedures
+
+function mem_block_add(sv p_block,ss newblock,sd newblock_size)
+    sd block
+    sd allsize
+    sd size
+
+    set block p_block#
+    sd sz_test
+    setcall size block_get_fullsize(block)
+    set allsize block#
+    set sz_test size
+    add sz_test newblock_size
+    if sz_test>allsize
+    #was >= but when >?, here and in another 2 places
+        div sz_test (block_size)
+        mult sz_test (block_size)
+        add sz_test (block_size)
+    #    set allsize sz_test
+        setcall block memrealloc(block,sz_test)  #allsize
+        set p_block# block
+        set block# sz_test  ##allsize
+    endif
+    sd pointer
+    set pointer block
+    add pointer size
+    call memcpy(pointer,newblock,newblock_size)
+    add size newblock_size
+    add block (mem_struct__size_off)
+    set block# size
+endfunction
+
+#structure ids
+
+const max_structures=100
+function struct_ids(sd proc,sd id)
+    vdata structures#max_structures
+    vdata strct^structures
+    data counter=0
+    sv ac_ptr
+    sv pointer
+    if proc=(ids_all_free)
+        #starting with ids_all_free:
+        #                #counter increment#, then null at ac,pools
+        #   mem_free at struct_ids_action_expand
+        #   can have errors at any point and here all are verified
+        set pointer :;mult pointer counter;add pointer strct
+        while strct!=pointer
+            sub pointer :;if pointer#!=(NULL);call free(pointer#);endif
+            dec counter
+            setcall ac_ptr struct_ids_action((ids_get),counter);if ac_ptr!=(NULL);call free(ac_ptr);endif
+            setcall ac_ptr struct_ids_actionpool((ids_get),counter);if ac_ptr!=(NULL);call free(ac_ptr);endif
+        endwhile
+        return (void)
+    elseif proc=(ids_counter)
+        return counter
+    endelseif
+
+    sd ident
+    if proc=(ids_set)
+        set ident counter
+    else
+        set ident id
+    endelse
+    setcall pointer move_to_n_pointer(strct,ident)
+    if proc=(ids_set)
+    #id
+        if counter=(max_structures)
+            call error("too many objects")
+        endif
+        sv iter
+        sd newblock
+        setcall newblock def_data()
+        set iter pointer
+        while iter!=strct
+        #can be in a free place
+            sub iter :
+            if iter#=0
+                set iter# newblock
+                sub iter strct
+                div iter :
+                return iter
+            endif
+        endwhile
+        set pointer# newblock
+        #counter increment#
+        #sd c; for counter verification inside
+        sd c;set c counter;inc counter
+        setcall ac_ptr struct_ids_action((ids_get_pointer),c);set ac_ptr# (NULL)
+        setcall ac_ptr struct_ids_actionpool((ids_get_pointer),c);set ac_ptr# (NULL)
+        #counter increment#
+        return ident
+    elseif proc=(ids_get_pointer)
+        if ident>=counter;call error("Unexistent input id.");endif
+        return pointer
+    elseif proc=(ids_get)
+        return pointer#
+    else
+    #if proc==(ids_free)
+        call mem_free(pointer)
+    endelse
+endfunction
+function struct_ids_action(sd proc,sd id)
+    vdata action_structures#max_structures
+    sd v;setcall v struct_ids_expand(proc,id,#action_structures)
+    return v
+endfunction
+function struct_ids_actionpool(sd proc,sd id)
+    vdata actionpool_structures#max_structures
+    sd v;setcall v struct_ids_expand(proc,id,#actionpool_structures)
+    return v
+endfunction
+function struct_ids_expand(sd proc,sd id,sd p_action_structures)
+    sv pointer;setcall pointer move_to_n_pointer(p_action_structures,id)
+    if proc=(ids_set)
+        setcall pointer# def_data()
+    elseif proc=(ids_get_pointer)
+        #call to verify if the user input has a wrong id
+        sd c;setcall c struct_ids((ids_counter))
+        if id>=c;call error("Unregistered input id.");endif
+        #
+        return pointer
+    elseif proc=(ids_get)
+        return pointer#
+    else
+    #if proc==(ids_free)
+        call mem_free(pointer)
+    endelse
+endfunction
+
+
+#strings
+
+#alloc
+function dupreserve_string(ss str)
+    sd len
+    setcall len strlen(str)
+    inc len
+    sd mem
+    setcall mem memalloc(len)
+    return mem
+endfunction
+
+#pointer after "abc"
+function str_escape(ss src,ss dest,sd delim)
+    sd loop=1
+    sd escapes=0
+    inc src
+    while loop=1
+    if src#=delim
+        set loop 0
+    #elseif src#==delim2
+    #    set loop 0
+    else
+        char escape="\\"
+        while src#=escape
+            if escapes=0
+                set escapes 1
+            else
+                set dest# src#
+                inc dest
+                set escapes 0
+            endelse
+            inc src
+        endwhile
+        if src#=0
+            call error("end string expected")
+        endif
+        if escapes=1
+            set dest# src#
+            inc src
+            inc dest
+            set escapes 0
+        elseif src#!=delim
+            #if src#!=delim2
+                set dest# src#
+                inc src
+                inc dest
+            #endif
+        endelseif
+    endelse
+    endwhile
+    set dest# 0
+    inc src
+    return src
+endfunction
--- actionswf-1.orig/src/util.s
+++ /dev/null
@@ -1,550 +0,0 @@
-Format ElfObj64
-
-#win32 with _
-importx "fwrite" fwrite
-importx "realloc" realloc
-importx "memcpy" memcpy
-importx "free" free
-importx "strcspn" strcspn
-importx "strlen" strlen
-importx "memcmp" memcmp
-
-import "platform_iob" platform_iob
-
-include "../include/prog.h"
-
-function printEr(ss msg)
-    sd len;setcall len strlen(msg)
-    call printEr_func(msg,(BYTE),len)
-endfunction
-#p
-function printEr_func(ss msg,sd *item_size,sd *count,sd stderr)
-#                                                    this argument is not passed, is structure last part
-    setcall stderr platform_iob()
-    callex fwrite #msg 4
-    #bytes written,error:sz!=return
-endfunction
-
-function word_swap_arg(ss word)
-    sd a
-    ss aux^a
-    set aux# word#
-    ss dest
-    set dest word
-    inc word
-    set dest# word#
-    set word# aux#
-endfunction
-function dword_to_word_arg(sd int,ss arg)
-    set arg# int
-    inc arg
-    div int 0x100
-    set arg# int
-endfunction
-function word_arg_to_dword(ss arg)
-    inc arg
-    sd value
-    set value arg#
-    mult value 0x100
-    dec arg
-    or value arg#
-    return value
-endfunction
-#swapped data
-function dword_swap(sd value)
-    sd al
-    sd ah
-    sd third
-    sd last
-
-    set al value
-    and al 0xff
-
-    set ah value
-    and ah 0xff00
-
-    set third value
-    and third (0xff00*0x100)
-
-    set last value
-    and last (0xff00*0x100*0x100)
-
-    sd res=0x100*0x100*0x100
-    mult res al
-    #
-    mult ah 0x100
-    or res ah
-    #
-    div third 0x100
-    or res third
-    #
-    div last (0x100*0x100*0x100)
-    #for negative division, the number can be negative
-    and last 0xff
-    or res last
-    #
-    return res
-endfunction
-function struct_off(sd struct,sd off)
-    add struct off
-    return struct#
-endfunction
-
-#util
-
-function string_nl_print(ss msg)
-    call printEr(msg)
-    char nl={0xa,0}
-    call printEr(#nl)
-endfunction
-
-#block
-
-function block_reset_size(sd block)
-    add block (mem_struct__size_off)
-    set block# (mem_struct_size)
-endfunction
-#size
-function block_get_size(sd block)
-    sd size
-    setcall size struct_off(block,(mem_struct__size_off))
-    sub size (mem_struct_size)
-    return size
-endfunction
-#size
-function block_get_fullsize(sd block)
-    sd size
-    setcall size struct_off(block,(mem_struct__size_off))
-    return size
-endfunction
-#mem
-function block_get_mem(sd block)
-    add block (mem_struct_size)
-    return block
-endfunction
-function block_get_mem_size(sd block,sv p_mem,sv p_size)  #size is a stack variable
-    setcall p_mem# block_get_mem(block)
-    setcall p_size# block_get_size(block)
-endfunction
-
-#mem procedures
-
-function mem_free(sv p_mem)
-    call free(p_mem#)
-    set p_mem# (NULL)
-endfunction
-
-#pointer
-
-function move_to_n_pointer(sd pointer,sd id)
-    mult id :
-    add pointer id
-    return pointer
-endfunction
-
-#strings/chars
-
-#chars
-
-#bool
-function is_numeric(sd char)
-    char min="0"
-    char max="9"
-    if char<min
-        return (FALSE)
-    elseif char<=max
-        return (TRUE)
-    endelseif
-    return (FALSE)
-endfunction
-#bool
-function part_of_variable(sd value)
-    sd bool
-    setcall bool is_numeric(value)
-    if bool=(TRUE)
-        return (TRUE)
-    endif
-    setcall bool is_letter(value)
-    return bool
-endfunction
-#bool
-function is_letter(sd value)
-    if value<(A)
-        return (FALSE)
-    elseif value<=(Z)
-        return (TRUE)
-    elseif value=(_)
-        return (TRUE)
-    elseif value<(a)
-        return (FALSE)
-    elseif value<=(z)
-        return (TRUE)
-    endelseif
-    return (FALSE)
-endfunction
-
-#strings
-
-#str
-function str_next(ss s,ss delims,sv p_op)  #p_op is pointing at a stack variable
-    sd pos
-    setcall pos strcspn(s,delims)
-    ss x
-    set x s
-    add x pos
-    set p_op# x#
-    if x#=0
-        return x
-    endif
-    set x# 0
-    inc x
-    return x
-endfunction
-#bool
-function str_at_str_start(ss s1,ss s2)
-    sd l1
-    sd l2
-    setcall l1 strlen(s1)
-    setcall l2 strlen(s2)
-    if l1<l2
-        return (FALSE)
-    endif
-    sd comp
-    setcall comp memcmp(s1,s2,l2)
-    if comp=0
-        return (TRUE)
-    endif
-    return (FALSE)
-endfunction
-
-#next/same
-function str_expression_at_start(ss string,ss expression)
-    sd bool
-    setcall bool str_at_str_start(string,expression)
-    if bool=(FALSE)
-        return string
-    endif
-    ss next
-    set next string
-    addcall next strlen(expression)
-    setcall bool part_of_variable(next#)
-    if bool=(TRUE)
-        return string
-    endif
-    setcall next spaces(next)
-    return next
-endfunction
-#next/same
-function str_expression_at_start_withEndCare(ss ac,ss expression)
-    ss pointer
-    setcall pointer str_expression_at_start(ac,expression)
-    if pointer=ac
-        return ac
-    endif
-    char term=";"
-    if pointer#=term
-        inc pointer
-    endif
-    return pointer
-endfunction
-
-#str
-function spaces(ss str)
-    while 1=1
-        if str#!=(Space)
-            if str#!=(HorizontalTab)
-                return str
-            endif
-        endif
-        inc str
-    endwhile
-endfunction
-
-
-#closings
-
-import "file_close" file_close
-function file_resources(sd trueIsSet_falseIsFree,sd fileIn)
-    data file=fd_none
-    if trueIsSet_falseIsFree=(TRUE)
-        set file fileIn
-    else
-        if file!=(fd_none)
-            call file_close(#file)
-        endif
-    endelse
-endfunction
-function file_resources_set(sd file)
-    call file_resources((TRUE),file)
-endfunction
-function file_resources_free()
-    call file_resources((FALSE))
-endfunction
-
-#
-
-function freelater()
-    #this can be after code_values(in last_free); but normal is this at action and last_free at swf_done(without this)
-    call action_debug_free()
-    #
-    call file_get_content__resources_free()
-
-    call file_resources_free()
-endfunction
-
-import "action_error" action_error
-
-import "freereset" freereset   #..x with no args
-
-import "action_debug_free" action_debug_free
-import "file_get_content__resources_free" file_get_content__resources_free
-
-
-
-
-
-
-
-
-function erbool()
-    aftercall ebool
-    return #ebool
-endfunction
-
-
-
-
-
-
-
-
-function error(ss msg)
-    call string_nl_print(msg)
-    call action_error()
-
-	call freereset()
-	call freelater()
-
-    ss p;setcall p erbool();set p# 1
-endfunction
-
-#
-function memrealloc(sd mem,sd size)
-#unele fisiere pot da eroare de la realocare; fara functia asta aftercall poate fi degeaba
-    sd ptr;sd n=NULL
-    setcall ptr realloc(mem,size)
-    sd comp;setcall comp memcmp(#ptr,#n,:)
-    if comp=0
-        call error("realloc failed")
-    endif
-    return ptr
-endfunction
-function memalloc(sd size)
-    sd mem
-    setcall mem memrealloc(0,size)
-    return mem
-endfunction
-
-#inits
-
-#id
-function def_mem()
-    sd id
-    setcall id struct_ids((ids_set))
-    return id
-endfunction
-#mem
-function def_data()
-	sd mem
-	setcall mem memalloc((block_size))
-	set mem# (block_size)
-	call block_reset_size(mem)
-	return mem
-endfunction
-
-#mem procedures
-
-function mem_block_add(sv p_block,ss newblock,sd newblock_size)
-    sd block
-    sd allsize
-    sd size
-
-    set block p_block#
-    sd sz_test
-    setcall size block_get_fullsize(block)
-    set allsize block#
-    set sz_test size
-    add sz_test newblock_size
-    if sz_test>allsize
-    #was >= but when >?, here and in another 2 places
-        div sz_test (block_size)
-        mult sz_test (block_size)
-        add sz_test (block_size)
-    #    set allsize sz_test
-        setcall block memrealloc(block,sz_test)  #allsize
-        set p_block# block
-        set block# sz_test  ##allsize
-    endif
-    sd pointer
-    set pointer block
-    add pointer size
-    call memcpy(pointer,newblock,newblock_size)
-    add size newblock_size
-    add block (mem_struct__size_off)
-    set block# size
-endfunction
-
-#structure ids
-
-const max_structures=100
-function struct_ids(sd proc,sd id)
-    vdata structures#max_structures
-    vdata strct^structures
-    data counter=0
-    sv ac_ptr
-    sv pointer
-    if proc=(ids_all_free)
-        #starting with ids_all_free:
-        #                #counter increment#, then null at ac,pools
-        #   mem_free at struct_ids_action_expand
-        #   can have errors at any point and here all are verified
-        set pointer :;mult pointer counter;add pointer strct
-        while strct!=pointer
-            sub pointer :;if pointer#!=(NULL);call free(pointer#);endif
-            dec counter
-            setcall ac_ptr struct_ids_action((ids_get),counter);if ac_ptr!=(NULL);call free(ac_ptr);endif
-            setcall ac_ptr struct_ids_actionpool((ids_get),counter);if ac_ptr!=(NULL);call free(ac_ptr);endif
-        endwhile
-        return (void)
-    elseif proc=(ids_counter)
-        return counter
-    endelseif
-
-    sd ident
-    if proc=(ids_set)
-        set ident counter
-    else
-        set ident id
-    endelse
-    setcall pointer move_to_n_pointer(strct,ident)
-    if proc=(ids_set)
-    #id
-        if counter=(max_structures)
-            call error("too many objects")
-        endif
-        sv iter
-        sd newblock
-        setcall newblock def_data()
-        set iter pointer
-        while iter!=strct
-        #can be in a free place
-            sub iter :
-            if iter#=0
-                set iter# newblock
-                sub iter strct
-                div iter :
-                return iter
-            endif
-        endwhile
-        set pointer# newblock
-        #counter increment#
-        #sd c; for counter verification inside
-        sd c;set c counter;inc counter
-        setcall ac_ptr struct_ids_action((ids_get_pointer),c);set ac_ptr# (NULL)
-        setcall ac_ptr struct_ids_actionpool((ids_get_pointer),c);set ac_ptr# (NULL)
-        #counter increment#
-        return ident
-    elseif proc=(ids_get_pointer)
-        if ident>=counter;call error("Unexistent input id.");endif
-        return pointer
-    elseif proc=(ids_get)
-        return pointer#
-    else
-    #if proc==(ids_free)
-        call mem_free(pointer)
-    endelse
-endfunction
-function struct_ids_action(sd proc,sd id)
-    vdata action_structures#max_structures
-    sd v;setcall v struct_ids_expand(proc,id,#action_structures)
-    return v
-endfunction
-function struct_ids_actionpool(sd proc,sd id)
-    vdata actionpool_structures#max_structures
-    sd v;setcall v struct_ids_expand(proc,id,#actionpool_structures)
-    return v
-endfunction
-function struct_ids_expand(sd proc,sd id,sd p_action_structures)
-    sv pointer;setcall pointer move_to_n_pointer(p_action_structures,id)
-    if proc=(ids_set)
-        setcall pointer# def_data()
-    elseif proc=(ids_get_pointer)
-        #call to verify if the user input has a wrong id
-        sd c;setcall c struct_ids((ids_counter))
-        if id>=c;call error("Unregistered input id.");endif
-        #
-        return pointer
-    elseif proc=(ids_get)
-        return pointer#
-    else
-    #if proc==(ids_free)
-        call mem_free(pointer)
-    endelse
-endfunction
-
-
-#strings
-
-#alloc
-function dupreserve_string(ss str)
-    sd len
-    setcall len strlen(str)
-    inc len
-    sd mem
-    setcall mem memalloc(len)
-    return mem
-endfunction
-
-#pointer after "abc"
-function str_escape(ss src,ss dest,sd delim)
-    sd loop=1
-    sd escapes=0
-    inc src
-    while loop=1
-    if src#=delim
-        set loop 0
-    #elseif src#==delim2
-    #    set loop 0
-    else
-        char escape="\\"
-        while src#=escape
-            if escapes=0
-                set escapes 1
-            else
-                set dest# src#
-                inc dest
-                set escapes 0
-            endelse
-            inc src
-        endwhile
-        if src#=0
-            call error("end string expected")
-        endif
-        if escapes=1
-            set dest# src#
-            inc src
-            inc dest
-            set escapes 0
-        elseif src#!=delim
-            #if src#!=delim2
-                set dest# src#
-                inc src
-                inc dest
-            #endif
-        endelseif
-    endelse
-    endwhile
-    set dest# 0
-    inc src
-    return src
-endfunction
--- /dev/null
+++ actionswf-1/src/win.oc
@@ -0,0 +1,30 @@
+
+format elfobj64
+
+include "../include/prog.h"
+
+#win32 with _
+importx "__iob_func" iob_func
+
+function platform_iob()
+#    const STDIN_FILENO=0
+#    const STDOUT_FILENO=1
+    const STDERR_FILENO=2
+    #typedef struct FILE{
+        #char *_ptr
+        #int _cnt
+        #char *_base;
+        #int _flag;#int _file;
+        #int _charbuf;#int _bufsiz;
+        #char *_tmpfname;
+    #}
+    sd stderr
+    setcall stderr iob_func()
+    const size_of_FILE_noPad=:+DWORD+:+DWORD+DWORD+DWORD+DWORD+:
+    const pad_align_calc1=:-1;const pad_align_calc2=~pad_align_calc1;const pad_align_calc3=size_of_FILE_noPad+pad_align_calc1
+    const size_of_FILE=pad_align_calc3&pad_align_calc2
+    #call add64(#stderr,(STDERR_FILENO*size_of_FILE))
+    add stderr (STDERR_FILENO*size_of_FILE)
+
+    return stderr
+endfunction
--- actionswf-1.orig/src/win.s
+++ /dev/null
@@ -1,30 +0,0 @@
-
-format elfobj64
-
-include "../include/prog.h"
-
-#win32 with _
-importx "__iob_func" iob_func
-
-function platform_iob()
-#    const STDIN_FILENO=0
-#    const STDOUT_FILENO=1
-    const STDERR_FILENO=2
-    #typedef struct FILE{
-        #char *_ptr
-        #int _cnt
-        #char *_base;
-        #int _flag;#int _file;
-        #int _charbuf;#int _bufsiz;
-        #char *_tmpfname;
-    #}
-    sd stderr
-    setcall stderr iob_func()
-    const size_of_FILE_noPad=:+DWORD+:+DWORD+DWORD+DWORD+DWORD+:
-    const pad_align_calc1=:-1;const pad_align_calc2=~pad_align_calc1;const pad_align_calc3=size_of_FILE_noPad+pad_align_calc1
-    const size_of_FILE=pad_align_calc3&pad_align_calc2
-    #call add64(#stderr,(STDERR_FILENO*size_of_FILE))
-    add stderr (STDERR_FILENO*size_of_FILE)
-
-    return stderr
-endfunction
