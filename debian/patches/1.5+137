Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ocompiler (1-5+137) xenial; urgency=medium
 .
   * ..call..g again
Author: bc <bc@bc-Type1ProductConfigId>

---
The information above should follow the Patch Tagging Guidelines, please
checkout https://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: (upstream|backport|vendor|other), (<patch-url>|commit:<commit-id>)
Bug: <upstream-bugtracker-url>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: (no|not-needed|<patch-forwarded-url>)
Applied-Upstream: <version>, (<commit-url>|commit:<commid-id>)
Reviewed-By: <name and email of someone who approved/reviewed the patch>
Last-Update: 2023-12-23

--- ocompiler-1.orig/o.html
+++ ocompiler-1/o.html
@@ -708,6 +708,8 @@
 	<b>CallExRet</b> (like <b>CallRet</b>, or <b>CallXRet</b>) can return from a function.
 	<br>
 	<b>CallX</b>, <b>...XCall</b>, <b>CallExX</b> will call like a <b>FunctionX</b>/<b>ImportX</b>.
+	<br>
+	<b>Call[X]G</b>, <b>...[X]G</b>, <b>CallEx[X]G</b> will skip aftercall.
 	<p>
 	Example:
 	<a class="code">
--- ocompiler-1.orig/old
+++ ocompiler-1/old
@@ -1,5 +1,6 @@
-File ID: 1eIb9HxzUBYHFtGW5mMWyj5MnoX5O1KxZ
+File ID: 1DmTIKJ-f-LqDsrN4TrrqKDEZlwtX-wef
 [{'id': 'anyoneWithLink', 'type': 'anyone', 'kind': 'drive#permission', 'role': 'reader', 'allowFileDiscovery': False}, {'id': '04979898612943849512', 'type': 'user', 'kind': 'drive#permission', 'role': 'owner'}]
+Found file: ocompiler-1-5+136.x86_64.rpm, 1DmTIKJ-f-LqDsrN4TrrqKDEZlwtX-wef, 2023-12-23T15:59:55.368Z, https://drive.google.com/uc?id=1DmTIKJ-f-LqDsrN4TrrqKDEZlwtX-wef&export=download
 Found file: ocompiler-1-5+135.x86_64.rpm, 1eIb9HxzUBYHFtGW5mMWyj5MnoX5O1KxZ, 2023-12-23T13:56:58.588Z, https://drive.google.com/uc?id=1eIb9HxzUBYHFtGW5mMWyj5MnoX5O1KxZ&export=download
 Found file: ocompiler-1-5+134.x86_64.rpm, 1dsoBW85egpSX1DLzLg0quGWy8-UPTxpa, 2023-12-23T10:21:30.371Z, https://drive.google.com/uc?id=1dsoBW85egpSX1DLzLg0quGWy8-UPTxpa&export=download
 Found file: ocompiler-1-5+133.x86_64.rpm, 1A_YjZQCguHQz03-CgP822HwdMcQmbdU1, 2023-12-23T04:36:44.076Z, https://drive.google.com/uc?id=1A_YjZQCguHQz03-CgP822HwdMcQmbdU1&export=download
--- ocompiler-1.orig/src/files/functions/actions/argstwo.s
+++ ocompiler-1/src/files/functions/actions/argstwo.s
@@ -101,9 +101,8 @@ Function twoargs_ex(sv ptrcontent,sd ptr
 			setcall subtype_test x_call_test(subtype,ptrcontent#,ptrsize#)
 			if subtype_test!=0
 				Set primcalltype true
-				set subtype_test subtype
-				#and subtype_test (x_callx_flag)  #call and callex are testing without and
-				and subtype ~primsec_flags
+				set subtype_test subtype  ##two more flags at parsefunc
+				and subtype ~x_call_flags
 			endif
 			sd xlog
 			if subtype=(cSET)
--- ocompiler-1.orig/src/files/functions/actions/fn.s
+++ ocompiler-1/src/files/functions/actions/fn.s
@@ -466,8 +466,8 @@ function write_function_call(sd ptrdata,
 					return (noerror)
 				endif
 			endif
-			setcall subtype callret_flag(subtype)
-			if subtype=0  #is useless if a RET will come
+			and subtype (call_ret_flag|x_callg_flag)
+			if subtype=0  #is useless if a RET will come  , or if was set to not throw
 				sd global_err_ptr;setcall global_err_ptr global_err_p()
 				Data ptrextra%%ptr_extra
 				If ptrobject#=(FALSE)
--- ocompiler-1.orig/src/files/functions/commons/getcommand.s
+++ ocompiler-1/src/files/functions/commons/getcommand.s
@@ -460,13 +460,17 @@ Const compointersloc^pointers
 Data pointersvars#numberofcommandsvars+1
 Const compointersvarsloc^pointersvars
 
+#at fn
 const x_func_flag=0x80000000   #at def, varargs
 
-const call_ret_flag=0x80000000 #at call
-const x_callx_flag=0x40000000  ;#at call and setcall..., call a variable/function/import like functionx/importx
-const x_call_flag=0x20000000   #at setcall... ,this can be 0x8.. why not 0x8 then? at write_func is asking about callret and anyway this comes And ~primsec_flags at that point
+#at ...call...
+const x_callx_flag=0x80000000  #call a variable function import like functionx importx
+const x_callg_flag=0x40000000  #skip aftercall
 
-const primsec_flags=x_call_flag|x_callx_flag
+const call_ret_flag=0x20000000 #at call
+const x_call_flag=0x10000000   #at setcall... . attention that at write_func is asking about callret and setcall does not have that
+
+const x_call_flags=x_call_flag|x_callx_flag|x_callg_flag
 
 #declare coresp
 function commandSubtypeDeclare_to_typenumber(sd subtype,sd p_is_expand)
@@ -514,6 +518,8 @@ Function getcommand(value pcontent,data
 		Char calldata="CALL"
 		vStr call^calldata
 		vstr xstr="X"
+		vstr skipaftercall="G"
+		value pointer#1;data sz#1
 
 		ss extstr=NULL
 
@@ -523,12 +529,13 @@ Function getcommand(value pcontent,data
 
 		If command=(cPRIMSEC)
 			Set extstr xstr
-			value pointer#1;data sz#1
 			set intercursors #pointer
 			set pointer pcontent#
 		elseif command=(cCALL)
 		vstr call_ret_str="RET"
 			set extstr call_ret_str
+			set intercursors #pointer
+			set pointer pcontent#
 		Elseif command=(cSTARTFUNCTION)
 			sd x_fn;setcall x_fn func_xfile(ptrsubtype#)
 			if x_fn!=(Xfile_function_not_x)
@@ -536,6 +543,8 @@ Function getcommand(value pcontent,data
 			endif
 		elseif command=(cCALLEX)
 			set extstr call_ret_str
+			set intercursors #pointer
+			set pointer pcontent#
 		endElseif
 
 		SetCall result stringsatmemspc(pcontent,psize,offset,spacebool,extstr,extbool,intercursors)
@@ -543,18 +552,26 @@ Function getcommand(value pcontent,data
 		#here firstAndSecond part was recognized
 			If command=(cPRIMSEC)
 				if result=(FALSE)
-				#here there was not a space, maybe is the deprecated ..xcall
+					#here there was not a space
+					setcall result stratmemspc(#pointer,#sz,skipaftercall,spacebool)
+					if result=(TRUE)
+						or ptrsubtype# (x_call_flag|x_callx_flag|x_callg_flag)
+						set pcontent# pointer
+						set psize# sz
+						Return command
+					endif
+					#maybe is the deprecated ..xcall
 					setcall result stratmemspc(#pointer,#sz,call,spacebool)
 					if result=(TRUE)
 						#or first byte at subcommand to recognize the xcall at two args
-						or ptrsubtype# (primsec_flags)
+						or ptrsubtype# (x_call_flag|x_callx_flag)
 						set pcontent# pointer
 						set psize# sz
 						Return command
 					endif
 				else
 				#setx
-					or ptrsubtype# (primsec_flags)
+					or ptrsubtype# (x_call_flag|x_callx_flag)
 					Return command
 				endelse
 			Elseif result=(TRUE)
@@ -576,9 +593,15 @@ Function getcommand(value pcontent,data
 		#here (first/onlyone)+-space was ok
 			Return command
 		elseif command=(cPRIMSEC)
-		#here first was ok but not the space
-			if pcontent#!=pointer
-				#here there was not extra x, maybe is the deprecated ..call
+			if pcontent#!=pointer  ##here first was ok, but not extra x
+				setcall result stratmemspc(#pointer,#sz,skipaftercall,spacebool)
+				if result=(TRUE)
+					or ptrsubtype# (x_call_flag|x_callg_flag)
+					set pcontent# pointer
+					set psize# sz
+					Return command
+				endif
+				#maybe is the deprecated ..call
 				setcall result stratmemspc(#pointer,#sz,call,spacebool)
 				if result=(TRUE)
 					or ptrsubtype# (x_call_flag)
@@ -588,13 +611,33 @@ Function getcommand(value pcontent,data
 				endif
 				#break #don't want to remember this when having something like addend command, and who will wrong here?
 			endif
+		elseif command=(cCALL)
+			if pcontent#!=pointer  ##here first was ok, but not extra ret
+				setcall result stratmemspc(#pointer,#sz,skipaftercall,spacebool)
+				if result=(TRUE)
+					or ptrsubtype# (x_callg_flag)
+					set pcontent# pointer
+					set psize# sz
+					Return command
+				endif
+			endif
+		elseif command=(cCALLEX)
+			if pcontent#!=pointer  ##here first was ok, but not extra ret
+				setcall result stratmemspc(#pointer,#sz,skipaftercall,spacebool)
+				if result=(TRUE)
+					or ptrsubtype# (x_callg_flag)
+					set pcontent# pointer
+					set psize# sz
+					Return command
+				endif
+			endif
 		endelseIf
 		Add pointercommands dsz
 		Set cursor pointercommands#
 	EndWhile
 
 	Char _unrecCom="Unrecognized command/declaration name."
-	Str unrecCom^_unrecCom
+	vStr unrecCom^_unrecCom
 	Set ptrerrormsg# unrecCom
 EndFunction
 
--- ocompiler-1.orig/src/files/functions/xfile_details.s
+++ ocompiler-1/src/files/functions/xfile_details.s
@@ -169,11 +169,16 @@ endfunction
 function xfile_add_call_if(sd content,sd size,sd subtype)
 	if main.xfile!=(openno)
 		sd err
-		setcall subtype callx_flag(subtype)  #this is tested if 64 in the normal place
+		and subtype (x_callx_flag|x_callg_flag)
 		if subtype=0
 			setcall err xfile_add_char((Xfile_arg_call_normal)) #not forced extern
-		else
+		elseif subtype=(x_callx_flag)
 			setcall err xfile_add_char((Xfile_arg_call_extern)) #forced extern
+		elseif subtype=(x_callg_flag)
+			setcall err xfile_add_char((Xfile_arg_call_skipaftercall))
+		else
+		#if subtype!0
+			setcall err xfile_add_char((Xfile_arg_call_extern|Xfile_arg_call_skipaftercall))
 		endelse
 		if err=(noerror)
 			setcall err xfile_add_string(content,size)
--- ocompiler-1.orig/src/files/headers/xfile.h
+++ ocompiler-1/src/files/headers/xfile.h
@@ -168,8 +168,10 @@ const Xfile_arg_varfn_colon_yes=1
 const Xfile_arg_varfn_dot_no=0
 const Xfile_arg_varfn_dot_yes=1
 
-const Xfile_arg_call_normal=0
-const Xfile_arg_call_extern=1
+#same ORing
+const Xfile_arg_call_normal=0x
+const Xfile_arg_call_extern=0x1
+const Xfile_arg_call_skipaftercall=0x2
 
 const Xfile_action2_set=0
 const Xfile_action2_add=1
--- /dev/null
+++ ocompiler-1/tests/call/callg.s
@@ -0,0 +1,26 @@
+
+format elfobj64
+
+aftercall z
+
+sv a
+
+hex 144,144
+call a()
+hex 144
+callg a()
+
+hex 144,144
+callex a a a
+hex 144
+callexg a a a
+
+hex 144,144
+set a a()
+hex 144
+setg a a()
+
+hex 144,144
+setx a a()
+hex 144
+setxg a a()
