Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ocompiler (1-5+140) xenial; urgency=medium
 .
   * start/end function optimizations
Author: bc <bc@bc-Type1ProductConfigId>

---
The information above should follow the Patch Tagging Guidelines, please
checkout https://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: (upstream|backport|vendor|other), (<patch-url>|commit:<commit-id>)
Bug: <upstream-bugtracker-url>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: (no|not-needed|<patch-forwarded-url>)
Applied-Upstream: <version>, (<commit-url>|commit:<commid-id>)
Reviewed-By: <name and email of someone who approved/reviewed the patch>
Last-Update: 2023-12-28

--- ocompiler-1.orig/Makefile
+++ ocompiler-1/Makefile
@@ -16,7 +16,7 @@ $(SUBDIRS):
 
 all:
 	#if ! [ -s ./src/obj.txt ];then
-	cd ./src; ../ounused/ounused ./linux/obj.s.log
+	cd ./src; ../ounused/ounused ./linux/obj.oc.log
 	#; fi
 	@echo
 
--- ocompiler-1.orig/docker/Dockerfile
+++ ocompiler-1/docker/Dockerfile
@@ -9,5 +9,5 @@ WORKDIR o/src/linux
 RUN add-apt-repository -y ppa:colin-i/ppa
 RUN apt-get update -y
 RUN apt-get install -y ocompiler
-RUN o obj.s
+RUN o obj.oc
 RUN base64 obj.o > ../obj.txt
--- ocompiler-1.orig/make
+++ ocompiler-1/make
@@ -2,7 +2,7 @@
 #use Makefile
 exit
 
-./o "./src/linux/o.s"
+./o "./src/linux/o.oc"
 
 mkdir ./build
 mv ./src/linux/o ./build/
--- ocompiler-1.orig/make.bat
+++ ocompiler-1/make.bat
@@ -3,6 +3,6 @@
 exit
 
 md build
-o.exe "src/windows/o.s"
+o.exe "src/windows/o.oc"
 move src\windows\o.exe build\
 copy .ocompiler.txt build\
\ No newline at end of file
--- ocompiler-1.orig/makewin32
+++ ocompiler-1/makewin32
@@ -9,13 +9,13 @@ fi
 
 #must also use mingw-w64-i686-dev
 
-${OCOMP} ./src/windows/obj32.s inplace_reloc 0 ${OFLAGS} && \
-#argc argv? more info at obj.s. _WinMain@16
+${OCOMP} ./src/windows/obj32.oc inplace_reloc 0 ${OFLAGS} && \
+#argc argv? more info at obj.oc. _WinMain@16
 i686-w64-mingw32-ld -s -entry=main ./src/windows/obj32.o -lmsvcrt -luser32 -lkernel32 -lcomdlg32 -lshell32 -o ./o.exe && \
-ounused ./src/windows/obj32.s.log && \
+ounused ./src/windows/obj32.oc.log && \
 \
 rm ./src/windows/obj32.o && \
-rm ./src/windows/obj32.s.log && \
+rm ./src/windows/obj32.oc.log && \
 \
 mkdir ocompiler && \
 mv o.exe ocompiler && \
--- ocompiler-1.orig/makewin64
+++ ocompiler-1/makewin64
@@ -38,7 +38,7 @@ x86_64-w64-mingw32-dlltool --no-leading-
 x86_64-w64-mingw32-dlltool --no-leading-underscore -d ./fix/comdlg.def -l ./fix/libcomdlg.a
 x86_64-w64-mingw32-dlltool --no-leading-underscore -d ./fix/c.def -l ./fix/libc.a
 
-./o ./src/windows/obj32_64code.s
+./o ./src/windows/obj32_64code.oc
 objcopy --input-target=elf32-i386 --output-target=elf64-x86-64 "./src/windows/obj32_64code.o" "./src/windows/obj64.o"
 mkdir ./buildg
 x86_64-w64-mingw32-ld --image-base=0 -s -nostdlib -entry _WinMain@16 "./src/windows/obj64.o" -L./fix -luser -l kernel -lcomdlg -lc -o "./buildg/o64.exe"
--- ocompiler-1.orig/o.html
+++ ocompiler-1/o.html
@@ -374,7 +374,7 @@
 	<br>
 	The <b>AfterCall</b> set a value to be tested with zero at the every call and to return if it is not zero.
 	<br>
-	<b>ImportAfterCall</b> is used in objects to import an extern defined AfterCall.
+	<b>AfterCallImport</b> is used in objects to import an extern defined AfterCall.
 	<br>
 	<b>AfterCallEnable</b>/<b>AfterCallDisable</b> automation commands (name is not used; if not imported, aftercall can be defined with unrefsign(*)).
 	<br>
--- ocompiler-1.orig/ocompiler.conf
+++ ocompiler-1/ocompiler.conf
@@ -24,17 +24,17 @@
 
 #6. Take the following action at FUNCTION entries at the object format that are not referred in the object and when the reference warning is enabled. This will also log import functions.
 #[if orphans is 1]
-#0 is Ignore them; 1 is Show warning; 2 [if logfile is 1] is Write them to the logfile, else take 1
+#0 is Ignore them; 1 is Show warning; 2 is [if logfile is 1] Write them to the logfile, else take 1
 #codeFnObj=2
 
 #7. CONST to unreferenced warnings, same as with FUNCTION. This will also log declared constants.
 #[if orphans is 1]
-#0 is Ignore them; 1 is Show warning; 2 [if logfile is 1] is Write them to the logfile, else take 1
+#0 is Ignore them; 1 is Show warning; 2 is [if logfile is 1] Write them to the logfile, else take 1
 #const_warn=2
 
 #8. Variables to unreferenced warnings, same as with CONST.
 #[if orphans is 1]
-#0 is Ignore them; 1 is Show warning; 2 [if logfile is 1] is Write them to the logfile, else take 1
+#0 is Ignore them; 1 is Show warning; 2 is [if logfile is 1] Write them to the logfile, else take 1
 #offset_warn=2
 
 #9. Include active folder. Change the active directory when including and stepping into a file.
@@ -81,8 +81,8 @@
 #0 is No; 1 is Yes
 #ignore_format_so=0
 
-#20. At 64, before a call, align stack. Cases for arguments and shadow(windows only).
-#0 is No; 1 is Yes; 2 is Yes for arguments and shadow; 3 is Yes for arguments
+#20. At 64, before a 64 call, align stack.
+#0 is No; 1 is Yes; 2 is Yes for pushed arguments only
 #call_align=1
 
 #21. Virtual data to a SHT_NOBITS at object
--- ocompiler-1.orig/old
+++ ocompiler-1/old
@@ -1,5 +1,6 @@
-File ID: 1GgN1yYhZSB8YL5EVERaNKtp_r6VIpTvl
+File ID: 1neBDKEBlwpDL-WajhK5bLyonyBuL7hVV
 [{'id': 'anyoneWithLink', 'type': 'anyone', 'kind': 'drive#permission', 'role': 'reader', 'allowFileDiscovery': False}, {'id': '04979898612943849512', 'type': 'user', 'kind': 'drive#permission', 'role': 'owner'}]
+Found file: ocompiler-1-5+139.x86_64.rpm, 1neBDKEBlwpDL-WajhK5bLyonyBuL7hVV, 2023-12-28T13:06:09.194Z, https://drive.google.com/uc?id=1neBDKEBlwpDL-WajhK5bLyonyBuL7hVV&export=download
 Found file: ocompiler-1-5+138.x86_64.rpm, 1GgN1yYhZSB8YL5EVERaNKtp_r6VIpTvl, 2023-12-24T11:55:41.262Z, https://drive.google.com/uc?id=1GgN1yYhZSB8YL5EVERaNKtp_r6VIpTvl&export=download
 Found file: ocompiler-1-5+137.x86_64.rpm, 1ra0VXgFWYbvaauEEQboNbR8OMTvhegUe, 2023-12-24T04:49:39.787Z, https://drive.google.com/uc?id=1ra0VXgFWYbvaauEEQboNbR8OMTvhegUe&export=download
 Found file: ocompiler-1-5+136.x86_64.rpm, 1DmTIKJ-f-LqDsrN4TrrqKDEZlwtX-wef, 2023-12-23T15:59:55.368Z, https://drive.google.com/uc?id=1DmTIKJ-f-LqDsrN4TrrqKDEZlwtX-wef&export=download
--- ocompiler-1.orig/ostrip/Makefile
+++ ocompiler-1/ostrip/Makefile
@@ -27,7 +27,7 @@ endif
 OBJ = ${OB}.o
 OBT = ${OB}.txt
 FULLOBJ = ./${OB}
-FULLOBJS = ${FULLOBJ}.s
+FULLOBJS = ${FULLOBJ}.oc
 FULLOBJO = ${FULLOBJ}.o
 FULLOBJLOG = ${FULLOBJS}.log
 OLINK=../ounused/ounused
--- /dev/null
+++ ocompiler-1/ostrip/after.oc
@@ -0,0 +1,114 @@
+
+#aftercall pointer (string)
+function aftercall_find(sv objects,sv poffset)
+	sd doffset=0
+	while objects#!=(NULL)
+		sv obj=to_symtab
+		add obj objects#
+		ss sym;set sym obj#
+		incst obj
+		sd end;set end obj#
+		add end sym
+		while sym!=end
+#Data elf64_sym_st_name#1
+#Char elf64_sym_st_info#1
+#Char *elf64_sym_st_other={0}
+#Char elf64_sym_st_shndx#2
+#Data elf64_sym_st_value#1;data *=0
+#Data elf64_sym_st_size#1;data *=0
+const sym__to_value=datasize+charize+charize+(2*charize)
+const sym_size=sym__to_value+:+:
+const sym__to_shndx=datasize+charize+charize
+			add sym (sym__to_shndx)
+			char d={dataind,0}
+			sd cmp;setcall cmp memcmp(sym,#d,2)
+			if cmp=0
+				sub sym (charize+charize)
+				char info=STB_GLOBAL*0x10|STT_NOTYPE   ;#global seems to always be here but there is too much code to separate
+				if info=sym#
+				#this is the aftercall,get string pointer from strtab
+					sub sym (datasize)
+					incst obj
+					sd mem;set mem obj#
+					add mem sym#d^
+
+					#and get offset in data
+					add sym (sym__to_value)
+					add doffset sym#v^
+					add poffset# doffset
+
+					return mem
+				else
+					add sym (sym_size-datasize)
+				endelse
+			else
+				add sym (sym_size-sym__to_shndx)
+			endelse
+		endwhile
+		add obj (from_symsize_to_voffset)
+		add doffset obj#d^
+		incst objects
+	endwhile
+	return (NULL)
+endfunction
+
+#bool
+function aftercall_replace(sv psym,sv pstr,ss astr,sv aoffset)
+	sd pos;setcall pos shnames_find_sec(pstr,astr)
+	if pos!=-1
+		sd sec;set sec psym#
+		incst psym
+		sd end;set end psym#
+		add end sec
+		while sec!=end
+			#name pos is first
+			if sec#=pos
+				add sec (sym__to_value)
+				set sec#v^ aoffset
+				call verbose((verbose_count))
+				call verbose((verbose_flush))
+				return (TRUE)
+			endif
+			add sec (sym_size)
+		endwhile
+	endif
+	return (FALSE)
+endfunction
+
+function aftercall_in_objects(sv objects,ss astr,sv aoffset,sd textinneroffset)
+	sv tphisic%%pexetext
+	set tphisic tphisic#
+	add tphisic textinneroffset
+	while objects#!=(NULL)
+		sv object;set object objects#
+		sv pointer=to_strtab;add pointer object
+		sd pos;setcall pos shnames_find_sec(pointer,astr)
+		if pos!=-1
+			sub pointer (from_strtab_to_symtab)
+
+			sd sympos;set sympos pointer#
+			sv end;set end pointer
+			incst end
+			set end end#
+			add end sympos
+			while sympos!=end
+				if sympos#=pos
+					break
+				endif
+				add sympos (sym_size)
+			endwhile
+			sub sympos pointer#
+			div sympos (sym_size)
+			#if not exists there is a problem, but who cares (since objects are our own scripts)
+
+			#in data is with dataind (and only in one object)
+			#sub pointer (to_symtab)
+			#call aftercall_object_section(pointer,sympos,aoffset)
+			sub pointer (from_text_to_symtab)
+			call reloc_item(pointer,sympos,aoffset,tphisic)
+		endif
+		add object (to_text_extra_a)
+		add tphisic object#
+		incst objects
+	endwhile
+endfunction
--- ocompiler-1.orig/ostrip/after.s
+++ /dev/null
@@ -1,114 +0,0 @@
-
-#aftercall pointer (string)
-function aftercall_find(sv objects,sv poffset)
-	sd doffset=0
-	while objects#!=(NULL)
-		sv obj=to_symtab
-		add obj objects#
-		ss sym;set sym obj#
-		incst obj
-		sd end;set end obj#
-		add end sym
-		while sym!=end
-#Data elf64_sym_st_name#1
-#Char elf64_sym_st_info#1
-#Char *elf64_sym_st_other={0}
-#Char elf64_sym_st_shndx#2
-#Data elf64_sym_st_value#1;data *=0
-#Data elf64_sym_st_size#1;data *=0
-const sym__to_value=datasize+charize+charize+(2*charize)
-const sym_size=sym__to_value+:+:
-const sym__to_shndx=datasize+charize+charize
-			add sym (sym__to_shndx)
-			char d={dataind,0}
-			sd cmp;setcall cmp memcmp(sym,#d,2)
-			if cmp=0
-				sub sym (charize+charize)
-				char info=STB_GLOBAL*0x10|STT_NOTYPE   ;#global seems to always be here but there is too much code to separate
-				if info=sym#
-				#this is the aftercall,get string pointer from strtab
-					sub sym (datasize)
-					incst obj
-					sd mem;set mem obj#
-					add mem sym#d^
-
-					#and get offset in data
-					add sym (sym__to_value)
-					add doffset sym#v^
-					add poffset# doffset
-
-					return mem
-				else
-					add sym (sym_size-datasize)
-				endelse
-			else
-				add sym (sym_size-sym__to_shndx)
-			endelse
-		endwhile
-		add obj (from_symsize_to_voffset)
-		add doffset obj#d^
-		incst objects
-	endwhile
-	return (NULL)
-endfunction
-
-#bool
-function aftercall_replace(sv psym,sv pstr,ss astr,sv aoffset)
-	sd pos;setcall pos shnames_find_sec(pstr,astr)
-	if pos!=-1
-		sd sec;set sec psym#
-		incst psym
-		sd end;set end psym#
-		add end sec
-		while sec!=end
-			#name pos is first
-			if sec#=pos
-				add sec (sym__to_value)
-				set sec#v^ aoffset
-				call verbose((verbose_count))
-				call verbose((verbose_flush))
-				return (TRUE)
-			endif
-			add sec (sym_size)
-		endwhile
-	endif
-	return (FALSE)
-endfunction
-
-function aftercall_in_objects(sv objects,ss astr,sv aoffset,sd textinneroffset)
-	sv tphisic%%pexetext
-	set tphisic tphisic#
-	add tphisic textinneroffset
-	while objects#!=(NULL)
-		sv object;set object objects#
-		sv pointer=to_strtab;add pointer object
-		sd pos;setcall pos shnames_find_sec(pointer,astr)
-		if pos!=-1
-			sub pointer (from_strtab_to_symtab)
-
-			sd sympos;set sympos pointer#
-			sv end;set end pointer
-			incst end
-			set end end#
-			add end sympos
-			while sympos!=end
-				if sympos#=pos
-					break
-				endif
-				add sympos (sym_size)
-			endwhile
-			sub sympos pointer#
-			div sympos (sym_size)
-			#if not exists there is a problem, but who cares (since objects are our own scripts)
-
-			#in data is with dataind (and only in one object)
-			#sub pointer (to_symtab)
-			#call aftercall_object_section(pointer,sympos,aoffset)
-			sub pointer (from_text_to_symtab)
-			call reloc_item(pointer,sympos,aoffset,tphisic)
-		endif
-		add object (to_text_extra_a)
-		add tphisic object#
-		incst objects
-	endwhile
-endfunction
--- /dev/null
+++ ocompiler-1/ostrip/file.oc
@@ -0,0 +1,242 @@
+
+include "mem.oc"
+
+#Data sh64_name#1
+#Data sh64_type#1
+#Data sh64_flags#1;data *=0
+#Data sh64_addr#1;data *=0
+#Data sh64_offset#1;data *=0
+#Data sh64_size#1;data *=0
+#Data sh64_link#1
+#Data sh64_info#1
+#Data sh64_addralign#1;data *=0
+#Data sh64_entsize#1;data *=0
+const sh64_to_addr=4+4+:	   ;#flags :?on 32 is ok
+const sh64_addr_to_offset=:
+const sh64_addr_to_size=sh64_addr_to_offset+:
+
+#data size
+function get_file(sd name,sv p_file,sv secN,sv p_secN,sd pnrsec,sd psecond_sec,sd only_at_exec)
+	setcall p_file# fopen(name,"rb")
+	sd file;set file p_file#
+	if file!=(NULL)
+		#at frees will check next
+		#set p_secN# (NULL)
+
+		char elf64_ehd_e_ident_sign={asciiDEL,asciiE,asciiL,asciiF}
+#char *elf64_ehd_e_ident_class={ELFCLASS64}
+#char *elf64_ehd_e_ident_data={ELFDATA2LSB}
+#char *elf64_ehd_e_ident_version={EV_CURRENT}
+#char *elf64_ehd_e_ident_osabi={ELFOSABI_NONE}
+#char *elf64_ehd_e_ident_abiversion={EI_ABIVERSION}
+#char *elf64_ehd_e_ident_pad={0,0,0,0,0,0,0}
+#Char *elf64_ehd_e_type={ET_REL,0}
+		const after_sign_to_machine=1+1+1+1+1+7+2
+		Char elf64_ehd_e_machine={EM_X86_64,0}
+#data *elf64_ehd_e_version=EV_CURRENT
+#data *elf64_ehd_e_entry={0,0}
+#data *elf64_ehd_e_phoff={0,0}
+		const after_machine_to_shoff=4+8+8
+#data elf64_ehd_e_shoff#1;data *=0
+#data *elf64_ehd_e_flags=0
+#char *elf64_ehd_e_ehsize={64,0}
+#char *elf64_ehd_e_phentsize={0,0}
+#char *elf64_ehd_e_phnum={0,0}
+		const after_shoff_to_shentsize=4+2+2+2
+#char *elf64_ehd_e_shentsize={64,0}
+#char elf64_ehd_e_shnum#2
+#char elf64_ehd_e_shstrndx#2
+#char *pad={0,0}
+		sd sz=4
+		sd sign;call read(file,#sign,sz)
+		sd c;setcall c memcmp(#sign,#elf64_ehd_e_ident_sign,sz)
+		if c=0
+			call seekc(file,(after_sign_to_machine))
+			sd wsz=2
+			sd w;call read(file,#w,wsz)
+			setcall c memcmp(#w,#elf64_ehd_e_machine,wsz)
+			if c=0
+				call seekc(file,(after_machine_to_shoff))
+				sd offset;call read(file,#offset,:)
+				call seekc(file,(after_shoff_to_shentsize))
+				data shentsize=0
+				data shnum=0
+				data shstrndx=0
+				call read(file,#shentsize,wsz)
+				call read(file,#shnum,wsz)
+				call read(file,#shstrndx,wsz)
+
+				sd return_value
+				sd size
+
+				#end for iterations
+				sd end;set end shnum;mult end shentsize;add end offset
+
+				if psecond_sec!=(NULL)
+					#get sec indexes from section names table
+					setcall return_value shnames(file,offset,shentsize,shstrndx,secN,pnrsec,psecond_sec)
+					#get data size
+					#set return_value 0    #0 can go right now(it is blank section at our objects), but that can be stripped, favorizing
+					call get_section_item(file,offset,end,#return_value,(sh64_addr_to_size),shentsize)
+					call get_section_item(file,offset,end,psecond_sec,(sh64_addr_to_size),shentsize)
+				else
+				#exec
+					#get sec indexes from section names table
+					sd reladyn
+					sd dynsym
+					sd dynstr
+					setcall return_value shnames(file,offset,shentsize,shstrndx,secN,pnrsec,(NULL),#reladyn)
+					call get_section_item(file,offset,end,#return_value,0,shentsize)
+					call write_symtab_offset(file,offset,end,shentsize,only_at_exec)
+					if reladyn!=-1
+						setcall frees.execreladynsize get_section_many(file,offset,end,shentsize,reladyn,#frees.execreladyn)
+					endif
+					if dynsym!=-1
+						if dynstr!=-1
+							setcall frees.execdynsymsize get_section_many(file,offset,end,shentsize,dynsym,#frees.execdynsym)
+							setcall frees.execdynstrsize get_section_many(file,offset,end,shentsize,dynstr,#frees.execdynstr)
+						endif
+					endif
+				endelse
+
+				#get sections
+				while secN#!=(NULL)
+					#next at frees
+					set p_secN# (NULL)  #this is extra only at first
+					setcall size get_section_many(file,offset,end,shentsize,pnrsec#,p_secN)
+					if p_secN#=(NULL)
+						return return_value
+					endif
+					add secN :
+					add pnrsec (datasize)
+					add p_secN :
+					set p_secN# size
+					add p_secN :
+				endwhile
+				return return_value
+			endif
+			call erMessages("wrong machine",name)
+		endif
+		call erMessages("not an elf",name)
+	endif
+	call fError(name)
+endfunction
+function fError(ss name)
+	call erMessages("fopen error for",name)
+endfunction
+
+function rError()
+	#pin that readed=size*1
+	call erMessage("fread error")
+endfunction
+function read(sd file,sd buf,sd size)
+	sd readed;setcall readed fread(buf,1,size,file)
+	if readed!=size
+		call rError()
+	endif
+endfunction
+
+function seekc(sd file,sd offset)
+	call seek(file,offset,(SEEK_CUR))
+endfunction
+function seeks(sd file,sd offset)
+	call seek(file,offset,(SEEK_SET))
+endfunction
+function seek(sd file,sd offset,sd whence)
+	sd return;SetCall return fseek(file,offset,whence)
+	#at lseek:
+	#	beyond seekable device limit is not our concerne, error check at seekc can go if seeks was not
+	#	at section headers offset, error can be demonstrated (bad offset)
+	if return!=0
+		call erMessage("fseek error")
+	endif
+endfunction
+
+#datasec
+function shnames(sd file,sd offset,sd shentsize,sd shstrndx,sv secN,sd pnrsec,sd psecond_sec,sd only_at_exec)  #nrsec is int
+	mult shstrndx shentsize
+	add offset shstrndx
+
+	sd mem;sd end;setcall end get_section(file,offset,#mem)
+	add end mem
+	#old remark:   count strings? safer than say it is the number of sections
+
+	while secN#!=(NULL)
+		setcall pnrsec# shnames_find(mem,end,secN#)
+		add secN :
+		add pnrsec (datasize)
+	endwhile
+
+	sd datasec;setcall datasec shnames_find(mem,end,".data")
+	if psecond_sec!=(NULL)
+		setcall psecond_sec# shnames_find(mem,end,".text")
+	else
+		setcall only_at_exec# shnames_find(mem,end,".rela.dyn")
+		incst only_at_exec
+		setcall only_at_exec# shnames_find(mem,end,".dynsym")
+		incst only_at_exec
+		setcall only_at_exec# shnames_find(mem,end,".dynstr")
+	endelse
+	#else set datasec firstnrsec
+
+	call free(mem)
+
+	return datasec
+endfunction
+
+#sz
+function get_section_many(sd file,sd offset,sd end,sd shentsize,sd nrsec,sv p_sec)
+	call seeks(file,offset)
+	sd rest=-datasize
+	add rest shentsize
+	while offset!=end
+		#the sh64_name is first
+		datax offs#1;call read(file,#offs,(datasize))
+		if offs=nrsec
+			sd sz;setcall sz get_section(file,offset,p_sec)
+			return sz   ##it's in use at rels,syms and can verify errors at data/text . and also at data/text
+		endif
+		call seekc(file,rest)
+		add offset shentsize
+	endwhile
+endfunction
+
+function get_section_loc(sd file,sd offset,sv prequired_value_offset)
+	sd off=sh64_to_addr
+	add off prequired_value_offset#
+	add off offset
+	call seeks(file,off)
+	call read(file,prequired_value_offset,:)
+endfunction
+#fread
+function get_section(sd file,sd offset,sv pmem)
+	sd off=sh64_addr_to_offset
+	call get_section_loc(file,offset,#off)
+	sd size=sh64_addr_to_size
+	call get_section_loc(file,offset,#size)
+	call seeks(file,off)
+	sd mem;setcall mem alloc(size)
+	sd readed;setcall readed fread(mem,1,size,file)
+	if readed=size
+		set pmem# mem
+		return size
+	endif
+	call free(mem)
+	call rError()
+endfunction
+function get_section_item(sd file,sd offset,sd end,sv p_in_out,sd itemoff,sd shentsize)
+	call seeks(file,offset)
+	sd rest=-datasize
+	add rest shentsize
+	while offset!=end
+		#the sh64_name is first
+		datax offs#1;call read(file,#offs,(datasize))
+		if offs=p_in_out#d^
+			set p_in_out# itemoff
+			call get_section_loc(file,offset,p_in_out)
+			ret
+		endif
+		call seekc(file,rest)
+		add offset shentsize
+	endwhile
+endfunction
--- ocompiler-1.orig/ostrip/file.s
+++ /dev/null
@@ -1,242 +0,0 @@
-
-include "mem.s"
-
-#Data sh64_name#1
-#Data sh64_type#1
-#Data sh64_flags#1;data *=0
-#Data sh64_addr#1;data *=0
-#Data sh64_offset#1;data *=0
-#Data sh64_size#1;data *=0
-#Data sh64_link#1
-#Data sh64_info#1
-#Data sh64_addralign#1;data *=0
-#Data sh64_entsize#1;data *=0
-const sh64_to_addr=4+4+:	   ;#flags :?on 32 is ok
-const sh64_addr_to_offset=:
-const sh64_addr_to_size=sh64_addr_to_offset+:
-
-#data size
-function get_file(sd name,sv p_file,sv secN,sv p_secN,sd pnrsec,sd psecond_sec,sd only_at_exec)
-	setcall p_file# fopen(name,"rb")
-	sd file;set file p_file#
-	if file!=(NULL)
-		#at frees will check next
-		#set p_secN# (NULL)
-
-		char elf64_ehd_e_ident_sign={asciiDEL,asciiE,asciiL,asciiF}
-#char *elf64_ehd_e_ident_class={ELFCLASS64}
-#char *elf64_ehd_e_ident_data={ELFDATA2LSB}
-#char *elf64_ehd_e_ident_version={EV_CURRENT}
-#char *elf64_ehd_e_ident_osabi={ELFOSABI_NONE}
-#char *elf64_ehd_e_ident_abiversion={EI_ABIVERSION}
-#char *elf64_ehd_e_ident_pad={0,0,0,0,0,0,0}
-#Char *elf64_ehd_e_type={ET_REL,0}
-		const after_sign_to_machine=1+1+1+1+1+7+2
-		Char elf64_ehd_e_machine={EM_X86_64,0}
-#data *elf64_ehd_e_version=EV_CURRENT
-#data *elf64_ehd_e_entry={0,0}
-#data *elf64_ehd_e_phoff={0,0}
-		const after_machine_to_shoff=4+8+8
-#data elf64_ehd_e_shoff#1;data *=0
-#data *elf64_ehd_e_flags=0
-#char *elf64_ehd_e_ehsize={64,0}
-#char *elf64_ehd_e_phentsize={0,0}
-#char *elf64_ehd_e_phnum={0,0}
-		const after_shoff_to_shentsize=4+2+2+2
-#char *elf64_ehd_e_shentsize={64,0}
-#char elf64_ehd_e_shnum#2
-#char elf64_ehd_e_shstrndx#2
-#char *pad={0,0}
-		sd sz=4
-		sd sign;call read(file,#sign,sz)
-		sd c;setcall c memcmp(#sign,#elf64_ehd_e_ident_sign,sz)
-		if c=0
-			call seekc(file,(after_sign_to_machine))
-			sd wsz=2
-			sd w;call read(file,#w,wsz)
-			setcall c memcmp(#w,#elf64_ehd_e_machine,wsz)
-			if c=0
-				call seekc(file,(after_machine_to_shoff))
-				sd offset;call read(file,#offset,:)
-				call seekc(file,(after_shoff_to_shentsize))
-				data shentsize=0
-				data shnum=0
-				data shstrndx=0
-				call read(file,#shentsize,wsz)
-				call read(file,#shnum,wsz)
-				call read(file,#shstrndx,wsz)
-
-				sd return_value
-				sd size
-
-				#end for iterations
-				sd end;set end shnum;mult end shentsize;add end offset
-
-				if psecond_sec!=(NULL)
-					#get sec indexes from section names table
-					setcall return_value shnames(file,offset,shentsize,shstrndx,secN,pnrsec,psecond_sec)
-					#get data size
-					#set return_value 0    #0 can go right now(it is blank section at our objects), but that can be stripped, favorizing
-					call get_section_item(file,offset,end,#return_value,(sh64_addr_to_size),shentsize)
-					call get_section_item(file,offset,end,psecond_sec,(sh64_addr_to_size),shentsize)
-				else
-				#exec
-					#get sec indexes from section names table
-					sd reladyn
-					sd dynsym
-					sd dynstr
-					setcall return_value shnames(file,offset,shentsize,shstrndx,secN,pnrsec,(NULL),#reladyn)
-					call get_section_item(file,offset,end,#return_value,0,shentsize)
-					call write_symtab_offset(file,offset,end,shentsize,only_at_exec)
-					if reladyn!=-1
-						setcall frees.execreladynsize get_section_many(file,offset,end,shentsize,reladyn,#frees.execreladyn)
-					endif
-					if dynsym!=-1
-						if dynstr!=-1
-							setcall frees.execdynsymsize get_section_many(file,offset,end,shentsize,dynsym,#frees.execdynsym)
-							setcall frees.execdynstrsize get_section_many(file,offset,end,shentsize,dynstr,#frees.execdynstr)
-						endif
-					endif
-				endelse
-
-				#get sections
-				while secN#!=(NULL)
-					#next at frees
-					set p_secN# (NULL)  #this is extra only at first
-					setcall size get_section_many(file,offset,end,shentsize,pnrsec#,p_secN)
-					if p_secN#=(NULL)
-						return return_value
-					endif
-					add secN :
-					add pnrsec (datasize)
-					add p_secN :
-					set p_secN# size
-					add p_secN :
-				endwhile
-				return return_value
-			endif
-			call erMessages("wrong machine",name)
-		endif
-		call erMessages("not an elf",name)
-	endif
-	call fError(name)
-endfunction
-function fError(ss name)
-	call erMessages("fopen error for",name)
-endfunction
-
-function rError()
-	#pin that readed=size*1
-	call erMessage("fread error")
-endfunction
-function read(sd file,sd buf,sd size)
-	sd readed;setcall readed fread(buf,1,size,file)
-	if readed!=size
-		call rError()
-	endif
-endfunction
-
-function seekc(sd file,sd offset)
-	call seek(file,offset,(SEEK_CUR))
-endfunction
-function seeks(sd file,sd offset)
-	call seek(file,offset,(SEEK_SET))
-endfunction
-function seek(sd file,sd offset,sd whence)
-	sd return;SetCall return fseek(file,offset,whence)
-	#at lseek:
-	#	beyond seekable device limit is not our concerne, error check at seekc can go if seeks was not
-	#	at section headers offset, error can be demonstrated (bad offset)
-	if return!=0
-		call erMessage("fseek error")
-	endif
-endfunction
-
-#datasec
-function shnames(sd file,sd offset,sd shentsize,sd shstrndx,sv secN,sd pnrsec,sd psecond_sec,sd only_at_exec)  #nrsec is int
-	mult shstrndx shentsize
-	add offset shstrndx
-
-	sd mem;sd end;setcall end get_section(file,offset,#mem)
-	add end mem
-	#old remark:   count strings? safer than say it is the number of sections
-
-	while secN#!=(NULL)
-		setcall pnrsec# shnames_find(mem,end,secN#)
-		add secN :
-		add pnrsec (datasize)
-	endwhile
-
-	sd datasec;setcall datasec shnames_find(mem,end,".data")
-	if psecond_sec!=(NULL)
-		setcall psecond_sec# shnames_find(mem,end,".text")
-	else
-		setcall only_at_exec# shnames_find(mem,end,".rela.dyn")
-		incst only_at_exec
-		setcall only_at_exec# shnames_find(mem,end,".dynsym")
-		incst only_at_exec
-		setcall only_at_exec# shnames_find(mem,end,".dynstr")
-	endelse
-	#else set datasec firstnrsec
-
-	call free(mem)
-
-	return datasec
-endfunction
-
-#sz
-function get_section_many(sd file,sd offset,sd end,sd shentsize,sd nrsec,sv p_sec)
-	call seeks(file,offset)
-	sd rest=-datasize
-	add rest shentsize
-	while offset!=end
-		#the sh64_name is first
-		datax offs#1;call read(file,#offs,(datasize))
-		if offs=nrsec
-			sd sz;setcall sz get_section(file,offset,p_sec)
-			return sz   ##it's in use at rels,syms and can verify errors at data/text . and also at data/text
-		endif
-		call seekc(file,rest)
-		add offset shentsize
-	endwhile
-endfunction
-
-function get_section_loc(sd file,sd offset,sv prequired_value_offset)
-	sd off=sh64_to_addr
-	add off prequired_value_offset#
-	add off offset
-	call seeks(file,off)
-	call read(file,prequired_value_offset,:)
-endfunction
-#fread
-function get_section(sd file,sd offset,sv pmem)
-	sd off=sh64_addr_to_offset
-	call get_section_loc(file,offset,#off)
-	sd size=sh64_addr_to_size
-	call get_section_loc(file,offset,#size)
-	call seeks(file,off)
-	sd mem;setcall mem alloc(size)
-	sd readed;setcall readed fread(mem,1,size,file)
-	if readed=size
-		set pmem# mem
-		return size
-	endif
-	call free(mem)
-	call rError()
-endfunction
-function get_section_item(sd file,sd offset,sd end,sv p_in_out,sd itemoff,sd shentsize)
-	call seeks(file,offset)
-	sd rest=-datasize
-	add rest shentsize
-	while offset!=end
-		#the sh64_name is first
-		datax offs#1;call read(file,#offs,(datasize))
-		if offs=p_in_out#d^
-			set p_in_out# itemoff
-			call get_section_loc(file,offset,p_in_out)
-			ret
-		endif
-		call seekc(file,rest)
-		add offset shentsize
-	endwhile
-endfunction
--- /dev/null
+++ ocompiler-1/ostrip/mem.oc
@@ -0,0 +1,12 @@
+
+#mem
+function alloc(sd size)
+	sd mem;setcall mem malloc(size)
+	if mem!=(NULL)
+		return mem
+	endif
+#	call mError()
+	call erMessage("malloc error")
+endfunction
+#function mError()
+#endfunction
--- ocompiler-1.orig/ostrip/mem.s
+++ /dev/null
@@ -1,12 +0,0 @@
-
-#mem
-function alloc(sd size)
-	sd mem;setcall mem malloc(size)
-	if mem!=(NULL)
-		return mem
-	endif
-#	call mError()
-	call erMessage("malloc error")
-endfunction
-#function mError()
-#endfunction
--- /dev/null
+++ ocompiler-1/ostrip/obj.oc
@@ -0,0 +1,163 @@
+
+#data extra align at realoffset,concat,reldyn then unaligned at reloc,reldyn
+#text extra aligned
+
+const object_nr_of_main_sections=2
+const object_nr_of_secondary_sections=2
+const object_nr_of_sections=object_nr_of_main_sections+object_nr_of_secondary_sections
+const section_alloc=:*section_nr_of_values
+const object_alloc_secs=object_nr_of_sections*section_alloc
+#data text sym str
+#8,8  8,8  8,8 8,8=0x40
+
+#const to_text=section_alloc
+const to_symtab=object_nr_of_main_sections*section_alloc
+const to_strtab=to_symtab+section_alloc
+const from_symsize_to_voffset=:+section_alloc
+const from_strtab_to_symtab=section_alloc
+const from_text_to_symtab=section_alloc
+const from_text_to_data_extra=section_alloc+(object_nr_of_secondary_sections*section_alloc)
+
+const to_data_extra=object_alloc_secs
+const from_data_extra_to_data_extra_sz=datasize
+const from_extra_sz_to_extra_sz_a=:
+const from_data_extra_to_data_extra_sz_a=from_data_extra_to_data_extra_sz+from_extra_sz_to_extra_sz_a
+const to_data_extra_sz=object_alloc_secs+from_data_extra_to_data_extra_sz
+const extra_sz=from_extra_sz_to_extra_sz_a+:
+const to_text_extra=to_data_extra_sz+extra_sz
+const to_text_extra_a=to_text_extra+from_extra_sz_to_extra_sz_a
+const object_alloc=to_text_extra+extra_sz
+#4,8,8                   8,8
+#Xlogoffset,sz,szaligned textsz,szaligned
+#0x64
+
+##stripped size
+function get_objs(sv pargs,sd end)
+	#find the number of objects to prepare the field
+	sd pointers;set pointers end
+	sub pointers pargs
+	div pointers 2
+	add pointers :  #for null end
+
+	#make a container
+	sv pobjects%%pobjects
+	setcall pobjects# alloc(pointers)
+
+	#set end
+	sv objects;set objects pobjects#
+	set objects# (NULL)
+
+	while pargs!=end
+		#alloc
+		setcall objects# alloc((object_alloc))
+
+		sv object;set object objects#
+		set object# (NULL)  #this is not like the first file, there is 1 more like this extra in get_file
+		add objects :
+		set objects# (NULL)
+
+		char o1=".rela.data";char o2=".rela.text";char o3=".symtab";char o4=".strtab"
+		const o1c^o1;const o2c^o2;const o3c^o3;const o4c^o4
+		value oN%{o1c,o2c,o3c,o4c}
+		value *=NULL
+		datax nrs#object_nr_of_sections   #same as previous call
+		#blank sections at ocomp?
+
+		sv p=to_data_extra
+		add p object
+
+		setcall p#d^ get_offset(pargs#)  #the ocomp with these sections from that creation time are still respected (32 bits)
+
+		add p (from_data_extra_to_data_extra_sz)
+		incst pargs
+
+		sd file
+		sv t=extra_sz
+		add t p
+		#,(ET_REL)
+		setcall p# get_file(pargs#,#file,#oN,object,#nrs,t)
+		call fclose(file)
+		sv d_unaligned;set d_unaligned p
+		add p (from_extra_sz_to_extra_sz_a)
+		setcall p# objs_align(d_unaligned#)
+		sv t_unaligned;set t_unaligned t
+		add t (from_extra_sz_to_extra_sz_a)
+		setcall t# objs_align(t_unaligned#)
+		incst pargs
+	endwhile
+endfunction
+
+#stripped size
+function get_offset(sd fname)
+	sd file;setcall file fopen(fname,"rb")
+	if file!=(NULL)
+		#at the first 3 documentations there is no info about errno errors for fseek ftell
+		#it is implementation specific, many judgements can be made
+		call seek(file,0,(SEEK_END))
+		sd off;setcall off ftell(file)
+		if off!=-1
+			sub off (2+8)  #knowing \r\n same as ounused that is not headering with src. and 8 is copy-paste
+			call seeks(file,off)
+			char buf={0,0,0,0, 0,0,0,0, 0}
+			call read(file,#buf,8) #copy-paste
+			datax nr#1
+			call sscanf(#buf,"%08x",#nr) #copy-paste
+			return nr
+		endif
+		call erMessages("ftell error at",fname)
+	endif
+	call fError(fname)
+endfunction
+
+function write_sec(ss name,sd sec,sd size)
+	if sec!=(NULL)   #is ok only to execute the prog with no data or text, and for reldyn
+		sd file;setcall file fopen(name,"wb")
+		if file!=(NULL)
+			call writeclose(file,sec,size)
+		else
+			call fError(name)
+		endelse
+	endif
+endfunction
+function write(sv names,sv psections)
+	while names#!=(NULL)
+		sd sec;set sec psections#
+		add psections :
+		sd size;set size psections#
+		add psections :
+		call write_sec(names#,sec,size)
+		incst names
+	endwhile
+endfunction
+function writeclose(sd file,sd buf,sd size)
+	sd written;setcall written fwrite(buf,1,size,file)
+	call fclose(file)
+	#pin that written=size*1
+	if written!=size
+		call erMessages("fwrite error")
+	endif
+endfunction
+function write_symtab_offset(sd file,sd offset,sd end,sd shentsize,sd pnr)
+	datax nr#1;set nr pnr#
+	if nr!=-1
+		call seeks(file,offset)
+		sd rest=-datasize
+		add rest shentsize
+		while offset!=end
+			#the sh64_name is first
+			datax offs#1;call read(file,#offs,(datasize))
+			if offs=nr
+				sd off=sh64_addr_to_offset
+				call get_section_loc(file,offset,#off)
+				sd fout;setcall fout fopen(#main.s3o,"wb")
+				if fout!=(NULL)
+					call writeclose(fout,#off,:)
+					ret
+				endif
+				call fError(#main.s3o)
+			endif
+			call seekc(file,rest)
+			add offset shentsize
+		endwhile
+	endif
+endfunction
--- ocompiler-1.orig/ostrip/obj.s
+++ /dev/null
@@ -1,163 +0,0 @@
-
-#data extra align at realoffset,concat,reldyn then unaligned at reloc,reldyn
-#text extra aligned
-
-const object_nr_of_main_sections=2
-const object_nr_of_secondary_sections=2
-const object_nr_of_sections=object_nr_of_main_sections+object_nr_of_secondary_sections
-const section_alloc=:*section_nr_of_values
-const object_alloc_secs=object_nr_of_sections*section_alloc
-#data text sym str
-#8,8  8,8  8,8 8,8=0x40
-
-#const to_text=section_alloc
-const to_symtab=object_nr_of_main_sections*section_alloc
-const to_strtab=to_symtab+section_alloc
-const from_symsize_to_voffset=:+section_alloc
-const from_strtab_to_symtab=section_alloc
-const from_text_to_symtab=section_alloc
-const from_text_to_data_extra=section_alloc+(object_nr_of_secondary_sections*section_alloc)
-
-const to_data_extra=object_alloc_secs
-const from_data_extra_to_data_extra_sz=datasize
-const from_extra_sz_to_extra_sz_a=:
-const from_data_extra_to_data_extra_sz_a=from_data_extra_to_data_extra_sz+from_extra_sz_to_extra_sz_a
-const to_data_extra_sz=object_alloc_secs+from_data_extra_to_data_extra_sz
-const extra_sz=from_extra_sz_to_extra_sz_a+:
-const to_text_extra=to_data_extra_sz+extra_sz
-const to_text_extra_a=to_text_extra+from_extra_sz_to_extra_sz_a
-const object_alloc=to_text_extra+extra_sz
-#4,8,8                   8,8
-#Xlogoffset,sz,szaligned textsz,szaligned
-#0x64
-
-##stripped size
-function get_objs(sv pargs,sd end)
-	#find the number of objects to prepare the field
-	sd pointers;set pointers end
-	sub pointers pargs
-	div pointers 2
-	add pointers :  #for null end
-
-	#make a container
-	sv pobjects%%pobjects
-	setcall pobjects# alloc(pointers)
-
-	#set end
-	sv objects;set objects pobjects#
-	set objects# (NULL)
-
-	while pargs!=end
-		#alloc
-		setcall objects# alloc((object_alloc))
-
-		sv object;set object objects#
-		set object# (NULL)  #this is not like the first file, there is 1 more like this extra in get_file
-		add objects :
-		set objects# (NULL)
-
-		char o1=".rela.data";char o2=".rela.text";char o3=".symtab";char o4=".strtab"
-		const o1c^o1;const o2c^o2;const o3c^o3;const o4c^o4
-		value oN%{o1c,o2c,o3c,o4c}
-		value *=NULL
-		datax nrs#object_nr_of_sections   #same as previous call
-		#blank sections at ocomp?
-
-		sv p=to_data_extra
-		add p object
-
-		setcall p#d^ get_offset(pargs#)  #the ocomp with these sections from that creation time are still respected (32 bits)
-
-		add p (from_data_extra_to_data_extra_sz)
-		incst pargs
-
-		sd file
-		sv t=extra_sz
-		add t p
-		#,(ET_REL)
-		setcall p# get_file(pargs#,#file,#oN,object,#nrs,t)
-		call fclose(file)
-		sv d_unaligned;set d_unaligned p
-		add p (from_extra_sz_to_extra_sz_a)
-		setcall p# objs_align(d_unaligned#)
-		sv t_unaligned;set t_unaligned t
-		add t (from_extra_sz_to_extra_sz_a)
-		setcall t# objs_align(t_unaligned#)
-		incst pargs
-	endwhile
-endfunction
-
-#stripped size
-function get_offset(sd fname)
-	sd file;setcall file fopen(fname,"rb")
-	if file!=(NULL)
-		#at the first 3 documentations there is no info about errno errors for fseek ftell
-		#it is implementation specific, many judgements can be made
-		call seek(file,0,(SEEK_END))
-		sd off;setcall off ftell(file)
-		if off!=-1
-			sub off (2+8)  #knowing \r\n same as ounused that is not headering with src. and 8 is copy-paste
-			call seeks(file,off)
-			char buf={0,0,0,0, 0,0,0,0, 0}
-			call read(file,#buf,8) #copy-paste
-			datax nr#1
-			call sscanf(#buf,"%08x",#nr) #copy-paste
-			return nr
-		endif
-		call erMessages("ftell error at",fname)
-	endif
-	call fError(fname)
-endfunction
-
-function write_sec(ss name,sd sec,sd size)
-	if sec!=(NULL)   #is ok only to execute the prog with no data or text, and for reldyn
-		sd file;setcall file fopen(name,"wb")
-		if file!=(NULL)
-			call writeclose(file,sec,size)
-		else
-			call fError(name)
-		endelse
-	endif
-endfunction
-function write(sv names,sv psections)
-	while names#!=(NULL)
-		sd sec;set sec psections#
-		add psections :
-		sd size;set size psections#
-		add psections :
-		call write_sec(names#,sec,size)
-		incst names
-	endwhile
-endfunction
-function writeclose(sd file,sd buf,sd size)
-	sd written;setcall written fwrite(buf,1,size,file)
-	call fclose(file)
-	#pin that written=size*1
-	if written!=size
-		call erMessages("fwrite error")
-	endif
-endfunction
-function write_symtab_offset(sd file,sd offset,sd end,sd shentsize,sd pnr)
-	datax nr#1;set nr pnr#
-	if nr!=-1
-		call seeks(file,offset)
-		sd rest=-datasize
-		add rest shentsize
-		while offset!=end
-			#the sh64_name is first
-			datax offs#1;call read(file,#offs,(datasize))
-			if offs=nr
-				sd off=sh64_addr_to_offset
-				call get_section_loc(file,offset,#off)
-				sd fout;setcall fout fopen(#main.s3o,"wb")
-				if fout!=(NULL)
-					call writeclose(fout,#off,:)
-					ret
-				endif
-				call fError(#main.s3o)
-			endif
-			call seekc(file,rest)
-			add offset shentsize
-		endwhile
-	endif
-endfunction
--- /dev/null
+++ ocompiler-1/ostrip/ostrip.oc
@@ -0,0 +1,175 @@
+
+#must do a stripped .data and resolved .text (and .symtab with offset (more at leaf.py))
+
+#input: exec log1 o1 ... logN oN
+
+format elfobj64
+#modify debian/control exec depends,appimage.yml,debian/control arh order
+
+#at exec
+#there is a rare case with rela.dyn but it is not important here (resolved stderr to object)
+#these are not position independent code and inplace relocs add better with obj64 but at obj32 use addend>=0 or sum<0 error check
+
+#both exec and shared:
+#	pointers to dataind at text/data
+#	aftercall has a copy at .symtab
+#	.rela.dyn:
+#		data section offsets (R_X86_64_64:^printf)
+
+#only exec:
+#	pointers to aftercall
+
+#only at shared and pie:
+#	.rela.dyn:
+#		addends from pointers to data section (this and the previous are saying the same thing but maybe is compatibility)
+#		data section offsets (R_X86_64_RELATIVE pointers to text/data sections)
+#iterate by type,compare offset if is in data or in text,will have 3 go ways from there(at text the offset is ok)(at .._64 no addend)(at data both offset and addend)
+
+#only at shared:
+#	aftercall value at .dynsym
+
+#pin about .data align at objects that ld respects when concatenating
+#aftercall is retrieved in .symtab in an entry with Type=NOTYPE and Ndx=dataind, then .strtab for name, then in another objects an import with that name
+#at exec instead of .strtab can be value is inside data(there are outside data values as well), but that's extra code
+#aftercall can be resolved not from the first iteration
+
+include "header.h"
+
+include "throwless.oc"
+include "rel.oc"
+
+function messagedelim(sv st)
+	Char visiblemessage={0x0a,0}
+	Call fprintf(st#,#visiblemessage)
+endfunction
+Function Message(ss text)
+	sv st^stdout
+	Call fprintf(st#,text)
+	call messagedelim(st)
+EndFunction
+Function eMessage(ss text)
+	sv st^stderr
+	Call fprintf(st#,text)
+	call messagedelim(st)
+EndFunction
+function erEnd()
+	call frees()
+	aftercall er
+	set er ~0
+	return (EXIT_FAILURE)
+endfunction
+function erMessage(ss text)
+	call eMessage(text)
+	call erEnd()
+endfunction
+function erMessages(ss m1,ss m2)
+	call eMessage(m1)
+	call eMessage(m2)
+	call erEnd()
+endfunction
+
+char s1=".data";char s2=".text";char s3=".symtab";char s3o=".symtab_offset";char s4=".strtab"
+
+include "file.oc"
+include "obj.oc"
+include "after.oc"
+include "reldyn.oc"
+
+entry main(sd argc,sv argv) #0,ss exec,ss log1,ss *obj1)   #... logN objN
+
+if argc>=(1+3)  #0 is all the time
+	sd verb%%ptrverbose
+	setcall verb# access(".debug",(F_OK))
+
+	sv pfile%%pexefile
+	const s1c^s1;const s2c^s2;const s3c^s3;const s4c^s4
+	value sN%{s1c,s2c}
+	value s3c%s3c
+	value s4c%s4c
+	value *=NULL
+	sv pexe%%pexedata
+	datax nrs#2   #this is required inside but is better than passing the number of sections
+	datax symtabnr#1
+	datax *#1
+
+	#text/data can go null later, with access error if rela points there, but to not set here null is probably same access error
+	#sv pt%%pexetext
+	#set pt# (NULL)
+	sv ps%%pexesym
+	set ps# (NULL)
+	#and set data null here, it is useless there for objects call
+	set pexe# (NULL)   #data
+	set frees.execreladyn (NULL)
+	set frees.execdynsym (NULL)
+	set frees.execdynstr (NULL)
+
+	sv pobjects%%pobjects
+	set pobjects# (NULL) #this is on the main plan, is after ss exec at frees
+
+	mult argc :
+	add argc argv
+
+	incst argv
+	#,(ET_EXEC)
+	sd datavaddr;setcall datavaddr get_file(argv#,pfile,#sN,pexe,#nrs,(NULL),#symtabnr)
+
+	incst argv
+	call get_objs(argv,argc) #aftercall can be in any object, need to keep memory
+
+	#at pie(and everywhere like a good practice), there is a starting offset in data
+	#	need to get our size then sub from full data size and use that instead of data virtual
+	sd datainneroffset;setcall datainneroffset realoffset((to_data_extra_sz),frees.exedatasize)
+	#and same for text
+	sd textinneroffset;setcall textinneroffset realoffset((to_text_extra),frees.exetextsize)
+
+	sd keepdatasize;set keepdatasize frees.exedatasize
+	call objs_concat(pobjects#,pexe,datainneroffset)
+
+	if frees.execreladyn!=(NULL)  #or set size 0
+		sd maximum;set maximum datavaddr
+		add maximum keepdatasize
+		add datavaddr datainneroffset
+		call reloc_dyn(datavaddr,maximum)
+	else
+		add datavaddr datainneroffset
+	endelse
+
+	call reloc(pobjects#,datavaddr,datainneroffset,textinneroffset)
+
+	sd acall;setcall acall aftercall_find(pobjects#,#datavaddr) #acall is the string and datavaddr new aftercall virtual
+	if acall!=(NULL)
+		if ps#!=(NULL)
+			#replace if exe symtab
+			sv pexestr%%pexestr
+			call aftercall_replace(ps,pexestr,acall,datavaddr)
+
+			set s4c (NULL)  #for write skip
+		else
+			#the symbols have been stripped (-s)
+			set s3c (NULL)
+		endelse
+
+		#replace on the field
+		call aftercall_in_objects(pobjects#,acall,datavaddr,textinneroffset)
+
+		#replace in dynsym (can be at shared, mainly)
+		if frees.execdynsym!=(NULL)
+			sd bool;setcall bool aftercall_replace(#frees.execdynsym,#frees.execdynstr,acall,datavaddr)
+			#it is not in all cases here (even at shared)
+			if bool=(TRUE)
+				call write_sec(".dynsym",frees.execdynsym,frees.execdynsymsize)
+			endif
+		endif
+	else
+		#skip symtab if no aftercall
+		set s3c (NULL)  #write will stop there
+	endelse
+
+	add frees.exedatasize datainneroffset    ##set leading size back for write
+	call write(#sN,pexe)
+	call write_sec(".rela.dyn",frees.execreladyn,frees.execreladynsize)
+
+	call frees()
+	return (EXIT_SUCCESS)
+endif
+return (EXIT_FAILURE)
--- ocompiler-1.orig/ostrip/ostrip.s
+++ /dev/null
@@ -1,175 +0,0 @@
-
-#must do a stripped .data and resolved .text (and .symtab with offset (more at leaf.py))
-
-#input: exec log1 o1 ... logN oN
-
-format elfobj64
-#modify debian/control exec depends,appimage.yml,debian/control arh order
-
-#at exec
-#there is a rare case with rela.dyn but it is not important here (resolved stderr to object)
-#these are not position independent code and inplace relocs add better with obj64 but at obj32 use addend>=0 or sum<0 error check
-
-#both exec and shared:
-#	pointers to dataind at text/data
-#	aftercall has a copy at .symtab
-#	.rela.dyn:
-#		data section offsets (R_X86_64_64:^printf)
-
-#only exec:
-#	pointers to aftercall
-
-#only at shared and pie:
-#	.rela.dyn:
-#		addends from pointers to data section (this and the previous are saying the same thing but maybe is compatibility)
-#		data section offsets (R_X86_64_RELATIVE pointers to text/data sections)
-#iterate by type,compare offset if is in data or in text,will have 3 go ways from there(at text the offset is ok)(at .._64 no addend)(at data both offset and addend)
-
-#only at shared:
-#	aftercall value at .dynsym
-
-#pin about .data align at objects that ld respects when concatenating
-#aftercall is retrieved in .symtab in an entry with Type=NOTYPE and Ndx=dataind, then .strtab for name, then in another objects an import with that name
-#at exec instead of .strtab can be value is inside data(there are outside data values as well), but that's extra code
-#aftercall can be resolved not from the first iteration
-
-include "header.h"
-
-include "throwless.s"
-include "rel.s"
-
-function messagedelim(sv st)
-	Char visiblemessage={0x0a,0}
-	Call fprintf(st#,#visiblemessage)
-endfunction
-Function Message(ss text)
-	sv st^stdout
-	Call fprintf(st#,text)
-	call messagedelim(st)
-EndFunction
-Function eMessage(ss text)
-	sv st^stderr
-	Call fprintf(st#,text)
-	call messagedelim(st)
-EndFunction
-function erEnd()
-	call frees()
-	aftercall er
-	set er ~0
-	return (EXIT_FAILURE)
-endfunction
-function erMessage(ss text)
-	call eMessage(text)
-	call erEnd()
-endfunction
-function erMessages(ss m1,ss m2)
-	call eMessage(m1)
-	call eMessage(m2)
-	call erEnd()
-endfunction
-
-char s1=".data";char s2=".text";char s3=".symtab";char s3o=".symtab_offset";char s4=".strtab"
-
-include "file.s"
-include "obj.s"
-include "after.s"
-include "reldyn.s"
-
-entry main(sd argc,sv argv) #0,ss exec,ss log1,ss *obj1)   #... logN objN
-
-if argc>=(1+3)  #0 is all the time
-	sd verb%%ptrverbose
-	setcall verb# access(".debug",(F_OK))
-
-	sv pfile%%pexefile
-	const s1c^s1;const s2c^s2;const s3c^s3;const s4c^s4
-	value sN%{s1c,s2c}
-	value s3c%s3c
-	value s4c%s4c
-	value *=NULL
-	sv pexe%%pexedata
-	datax nrs#2   #this is required inside but is better than passing the number of sections
-	datax symtabnr#1
-	datax *#1
-
-	#text/data can go null later, with access error if rela points there, but to not set here null is probably same access error
-	#sv pt%%pexetext
-	#set pt# (NULL)
-	sv ps%%pexesym
-	set ps# (NULL)
-	#and set data null here, it is useless there for objects call
-	set pexe# (NULL)   #data
-	set frees.execreladyn (NULL)
-	set frees.execdynsym (NULL)
-	set frees.execdynstr (NULL)
-
-	sv pobjects%%pobjects
-	set pobjects# (NULL) #this is on the main plan, is after ss exec at frees
-
-	mult argc :
-	add argc argv
-
-	incst argv
-	#,(ET_EXEC)
-	sd datavaddr;setcall datavaddr get_file(argv#,pfile,#sN,pexe,#nrs,(NULL),#symtabnr)
-
-	incst argv
-	call get_objs(argv,argc) #aftercall can be in any object, need to keep memory
-
-	#at pie(and everywhere like a good practice), there is a starting offset in data
-	#	need to get our size then sub from full data size and use that instead of data virtual
-	sd datainneroffset;setcall datainneroffset realoffset((to_data_extra_sz),frees.exedatasize)
-	#and same for text
-	sd textinneroffset;setcall textinneroffset realoffset((to_text_extra),frees.exetextsize)
-
-	sd keepdatasize;set keepdatasize frees.exedatasize
-	call objs_concat(pobjects#,pexe,datainneroffset)
-
-	if frees.execreladyn!=(NULL)  #or set size 0
-		sd maximum;set maximum datavaddr
-		add maximum keepdatasize
-		add datavaddr datainneroffset
-		call reloc_dyn(datavaddr,maximum)
-	else
-		add datavaddr datainneroffset
-	endelse
-
-	call reloc(pobjects#,datavaddr,datainneroffset,textinneroffset)
-
-	sd acall;setcall acall aftercall_find(pobjects#,#datavaddr) #acall is the string and datavaddr new aftercall virtual
-	if acall!=(NULL)
-		if ps#!=(NULL)
-			#replace if exe symtab
-			sv pexestr%%pexestr
-			call aftercall_replace(ps,pexestr,acall,datavaddr)
-
-			set s4c (NULL)  #for write skip
-		else
-			#the symbols have been stripped (-s)
-			set s3c (NULL)
-		endelse
-
-		#replace on the field
-		call aftercall_in_objects(pobjects#,acall,datavaddr,textinneroffset)
-
-		#replace in dynsym (can be at shared, mainly)
-		if frees.execdynsym!=(NULL)
-			sd bool;setcall bool aftercall_replace(#frees.execdynsym,#frees.execdynstr,acall,datavaddr)
-			#it is not in all cases here (even at shared)
-			if bool=(TRUE)
-				call write_sec(".dynsym",frees.execdynsym,frees.execdynsymsize)
-			endif
-		endif
-	else
-		#skip symtab if no aftercall
-		set s3c (NULL)  #write will stop there
-	endelse
-
-	add frees.exedatasize datainneroffset    ##set leading size back for write
-	call write(#sN,pexe)
-	call write_sec(".rela.dyn",frees.execreladyn,frees.execreladynsize)
-
-	call frees()
-	return (EXIT_SUCCESS)
-endif
-return (EXIT_FAILURE)
--- /dev/null
+++ ocompiler-1/ostrip/rel.oc
@@ -0,0 +1,100 @@
+
+
+function reloc(sv objects,sd daddr,sd datainneroffset,sd textinneroffset)
+	sd doffset;set doffset daddr
+	sv voffset%%pexedatasize;   #this is after the new size was set
+	set voffset voffset#
+	add voffset daddr
+	sv dphisic%%pexedata
+	set dphisic dphisic#
+	add dphisic datainneroffset
+	sv tphisic%%pexetext
+	set tphisic tphisic#
+	add tphisic textinneroffset
+	while objects#!=(NULL)
+		sv object;set object objects#
+		sd d;set d object
+		add object (section_alloc)
+
+		sd t;set t object
+		add object (from_text_to_data_extra)
+
+		sd voffset_obj;set voffset_obj object#d^
+		add object (from_data_extra_to_data_extra_sz)
+
+		sv vsize_obj;set vsize_obj object#
+		sub vsize_obj voffset_obj
+
+		call reloc_sec(d,doffset,voffset,voffset_obj,dphisic)
+		call reloc_sec(t,doffset,voffset,voffset_obj,tphisic)
+
+		add doffset voffset_obj
+		add voffset vsize_obj
+		add dphisic voffset_obj
+		add object (extra_sz+from_extra_sz_to_extra_sz_a)
+		add tphisic object#
+
+		incst objects
+	endwhile
+endfunction
+
+function reloc_sec(sv object,sd doffset,sd voffset,sd voffset_obj,sd soffset)
+	sv pointer;set pointer object#
+	incst object
+	sd end;set end object#
+	add end pointer
+	while pointer!=end
+#		Data elf64_r_offset#1;data *=0
+#		data elf64_r_info_type#1
+#		data elf64_r_info_symbolindex#1
+#		data elf64_r_addend#1;data *=0
+		const rel_to_type=:
+		const rel_from_type_to_addend=datasize+datasize
+		const rel_to_addend=rel_to_type+rel_from_type_to_addend
+		const rel_size=rel_to_addend+:
+
+		sv cursor;set cursor pointer
+		incst cursor
+		if cursor#d^=(R_X86_64_64)
+			add cursor (datasize)
+			if cursor#d^=(dataind)
+				add cursor (datasize)
+				sv addend;set addend cursor#
+				if addend>=voffset_obj
+					add addend voffset
+				else
+					add addend doffset
+				endelse
+				sv rel_offset;set rel_offset pointer#
+				add rel_offset soffset
+				set rel_offset# addend
+				call verbose((verbose_count))
+			endif
+		endif
+		add pointer (rel_size)
+	endwhile
+	call verbose((verbose_flush))
+endfunction
+function reloc_item(sv object,sd index,sv replacement,sd soffset)
+	sv pointer;set pointer object#
+	incst object
+	sd end;set end object#
+	add end pointer
+	while pointer!=end
+		sv cursor;set cursor pointer
+		incst cursor
+		if cursor#d^=(R_X86_64_64)
+			add cursor (datasize)
+			if cursor#d^=index
+				sv rel_offset;set rel_offset pointer#
+				add rel_offset soffset
+				set rel_offset# replacement
+				call verbose((verbose_count))
+			endif
+		endif
+		add pointer (rel_size)
+	endwhile
+	call verbose((verbose_flush))
+endfunction
+
+include "reldynt.oc"
--- ocompiler-1.orig/ostrip/rel.s
+++ /dev/null
@@ -1,100 +0,0 @@
-
-
-function reloc(sv objects,sd daddr,sd datainneroffset,sd textinneroffset)
-	sd doffset;set doffset daddr
-	sv voffset%%pexedatasize;   #this is after the new size was set
-	set voffset voffset#
-	add voffset daddr
-	sv dphisic%%pexedata
-	set dphisic dphisic#
-	add dphisic datainneroffset
-	sv tphisic%%pexetext
-	set tphisic tphisic#
-	add tphisic textinneroffset
-	while objects#!=(NULL)
-		sv object;set object objects#
-		sd d;set d object
-		add object (section_alloc)
-
-		sd t;set t object
-		add object (from_text_to_data_extra)
-
-		sd voffset_obj;set voffset_obj object#d^
-		add object (from_data_extra_to_data_extra_sz)
-
-		sv vsize_obj;set vsize_obj object#
-		sub vsize_obj voffset_obj
-
-		call reloc_sec(d,doffset,voffset,voffset_obj,dphisic)
-		call reloc_sec(t,doffset,voffset,voffset_obj,tphisic)
-
-		add doffset voffset_obj
-		add voffset vsize_obj
-		add dphisic voffset_obj
-		add object (extra_sz+from_extra_sz_to_extra_sz_a)
-		add tphisic object#
-
-		incst objects
-	endwhile
-endfunction
-
-function reloc_sec(sv object,sd doffset,sd voffset,sd voffset_obj,sd soffset)
-	sv pointer;set pointer object#
-	incst object
-	sd end;set end object#
-	add end pointer
-	while pointer!=end
-#		Data elf64_r_offset#1;data *=0
-#		data elf64_r_info_type#1
-#		data elf64_r_info_symbolindex#1
-#		data elf64_r_addend#1;data *=0
-		const rel_to_type=:
-		const rel_from_type_to_addend=datasize+datasize
-		const rel_to_addend=rel_to_type+rel_from_type_to_addend
-		const rel_size=rel_to_addend+:
-
-		sv cursor;set cursor pointer
-		incst cursor
-		if cursor#d^=(R_X86_64_64)
-			add cursor (datasize)
-			if cursor#d^=(dataind)
-				add cursor (datasize)
-				sv addend;set addend cursor#
-				if addend>=voffset_obj
-					add addend voffset
-				else
-					add addend doffset
-				endelse
-				sv rel_offset;set rel_offset pointer#
-				add rel_offset soffset
-				set rel_offset# addend
-				call verbose((verbose_count))
-			endif
-		endif
-		add pointer (rel_size)
-	endwhile
-	call verbose((verbose_flush))
-endfunction
-function reloc_item(sv object,sd index,sv replacement,sd soffset)
-	sv pointer;set pointer object#
-	incst object
-	sd end;set end object#
-	add end pointer
-	while pointer!=end
-		sv cursor;set cursor pointer
-		incst cursor
-		if cursor#d^=(R_X86_64_64)
-			add cursor (datasize)
-			if cursor#d^=index
-				sv rel_offset;set rel_offset pointer#
-				add rel_offset soffset
-				set rel_offset# replacement
-				call verbose((verbose_count))
-			endif
-		endif
-		add pointer (rel_size)
-	endwhile
-	call verbose((verbose_flush))
-endfunction
-
-include "reldynt.s"
--- /dev/null
+++ ocompiler-1/ostrip/reldyn.oc
@@ -0,0 +1,53 @@
+
+
+function reloc_dyn(sd datavaddrstart,sd datavaddrend)
+	sd pointer;set pointer frees.execreladyn
+	add pointer (rel_to_type)
+	sd end;set end frees.execreladynsize
+	add end pointer
+	sd start
+	while pointer!=end
+		if pointer#=(R_X86_64_64)
+			set start pointer
+			setcall pointer reloc_dyn_sort(pointer,end,(R_X86_64_64),0)
+			call reloc_iteration(start,pointer,datavaddrstart,datavaddrend,-rel_to_type)
+			call verbose((verbose_flush))
+		elseif pointer#=(R_X86_64_RELATIVE)
+			#sort by addend then by offset to let at offset, at start probably is at offset but who cares
+			set start pointer
+			#by addend
+			sd group;setcall group reloc_dyn_sort(pointer,end,(R_X86_64_RELATIVE),(rel_to_addend))
+			call reloc_iteration(start,group,datavaddrstart,datavaddrend,(rel_from_type_to_addend))
+			call verbose((verbose_flush))
+			#by offset
+			setcall pointer reloc_dyn_sort(pointer,end,(R_X86_64_RELATIVE),0)
+			call reloc_iteration(start,pointer,datavaddrstart,datavaddrend,-rel_to_type)
+			call verbose((verbose_flush))
+		else
+			add pointer (rel_size)
+		endelse
+	endwhile
+endfunction
+
+#pointer
+function reloc_dyn_sort(sd pointer,sd end,sd type,sd diff)
+	sv start=-rel_to_type;add start pointer
+	while pointer!=end
+		if pointer#!=type
+			break
+		endif
+		add pointer (rel_size)
+	endwhile
+
+	sd return;set return pointer
+
+	sub pointer (rel_to_type)
+	sd size;set size pointer
+	sub size start
+	sv mem;setcall mem alloc(size)
+	call reloc_sort(start,pointer,mem,diff)
+	call memcpy(start,mem,size)
+	call free(mem)
+
+	return return
+endfunction
--- ocompiler-1.orig/ostrip/reldyn.s
+++ /dev/null
@@ -1,53 +0,0 @@
-
-
-function reloc_dyn(sd datavaddrstart,sd datavaddrend)
-	sd pointer;set pointer frees.execreladyn
-	add pointer (rel_to_type)
-	sd end;set end frees.execreladynsize
-	add end pointer
-	sd start
-	while pointer!=end
-		if pointer#=(R_X86_64_64)
-			set start pointer
-			setcall pointer reloc_dyn_sort(pointer,end,(R_X86_64_64),0)
-			call reloc_iteration(start,pointer,datavaddrstart,datavaddrend,-rel_to_type)
-			call verbose((verbose_flush))
-		elseif pointer#=(R_X86_64_RELATIVE)
-			#sort by addend then by offset to let at offset, at start probably is at offset but who cares
-			set start pointer
-			#by addend
-			sd group;setcall group reloc_dyn_sort(pointer,end,(R_X86_64_RELATIVE),(rel_to_addend))
-			call reloc_iteration(start,group,datavaddrstart,datavaddrend,(rel_from_type_to_addend))
-			call verbose((verbose_flush))
-			#by offset
-			setcall pointer reloc_dyn_sort(pointer,end,(R_X86_64_RELATIVE),0)
-			call reloc_iteration(start,pointer,datavaddrstart,datavaddrend,-rel_to_type)
-			call verbose((verbose_flush))
-		else
-			add pointer (rel_size)
-		endelse
-	endwhile
-endfunction
-
-#pointer
-function reloc_dyn_sort(sd pointer,sd end,sd type,sd diff)
-	sv start=-rel_to_type;add start pointer
-	while pointer!=end
-		if pointer#!=type
-			break
-		endif
-		add pointer (rel_size)
-	endwhile
-
-	sd return;set return pointer
-
-	sub pointer (rel_to_type)
-	sd size;set size pointer
-	sub size start
-	sv mem;setcall mem alloc(size)
-	call reloc_sort(start,pointer,mem,diff)
-	call memcpy(start,mem,size)
-	call free(mem)
-
-	return return
-endfunction
--- /dev/null
+++ ocompiler-1/ostrip/reldynt.oc
@@ -0,0 +1,128 @@
+
+function reloc_sort(sv pointer,sv end,sv dest,sd diff)
+	sv start;set start pointer
+	while start!=end
+		set pointer start
+
+		add pointer diff
+		add end diff
+
+		sd min;set min pointer#
+		sd pos;set pos pointer
+		add pointer (rel_size)
+		while pointer!=end
+			if pointer#<^min
+				set min pointer#
+				set pos pointer
+			endif
+			add pointer (rel_size)
+		endwhile
+
+		sub pos diff
+		sub end diff
+
+		call memcpy(dest,pos,(rel_size))
+		add dest (rel_size)
+		if start!=pos
+		#to fill the gap
+			call memcpy(pos,start,(rel_size))
+		endif
+		add start (rel_size)
+	endwhile
+endfunction
+
+#correctoffset
+function reloc_dyn_value(sd wrongoffset)
+	valuex srcstart#1
+	valuex srcmid#1
+	valuex destd#1
+	valuex destv#1
+
+	if wrongoffset>=^srcmid
+	#virtual
+		sub wrongoffset srcmid
+		add wrongoffset destv
+		return wrongoffset
+	endif
+	#file
+	sub wrongoffset srcstart
+	add wrongoffset destd
+	return wrongoffset
+endfunction
+
+#datavaddr
+function reloc_dyn_initobj(sd datavaddr)
+	valuex objects#1
+	valuex srcend#1
+	valuex destdnext#1
+	valuex destvnext#1
+
+	set reloc_dyn_value.destd destdnext
+	set reloc_dyn_value.destv destvnext
+	set reloc_dyn_value.srcstart datavaddr
+
+	sv obj;set obj objects#
+	add obj (to_data_extra)
+	sd herevirtual;set herevirtual obj#d^
+	set reloc_dyn_value.srcmid datavaddr
+	add reloc_dyn_value.srcmid herevirtual
+	add destdnext herevirtual
+	add obj (from_data_extra_to_data_extra_sz)
+	sub herevirtual obj#
+	neg herevirtual
+	add destvnext herevirtual
+
+	add obj (from_extra_sz_to_extra_sz_a)
+	add datavaddr obj#
+	set srcend datavaddr
+
+	return datavaddr
+endfunction
+
+function reloc_iteration(sv pointer,sd end,sd datavaddr,sd datavaddrend,sd diff)
+	#this is called in all 3 cases (even only at addends there is virtual)
+	add pointer diff
+	add end diff
+	#find the minimum and the maximum
+	while pointer!=end
+		if pointer#>=^datavaddr
+			break
+		endif
+		add pointer (rel_size)
+	endwhile
+	if pointer!=end
+		#can be .text after .data
+		sv cursor;set cursor pointer
+		while pointer!=end
+			if pointer#>=^datavaddrend
+				break
+			endif
+			add pointer (rel_size)
+		endwhile
+		if cursor!=pointer
+			#at first object only virtuals can be corrected
+			set reloc_dyn_initobj.objects frees.objects
+			set reloc_dyn_initobj.destdnext datavaddr
+			set reloc_dyn_initobj.destvnext datavaddr
+			add reloc_dyn_initobj.destvnext frees.exedatasize  ##this is after the new size was set
+			setcall datavaddr reloc_dyn_initobj(datavaddr)
+			while cursor!=pointer
+				sd offset;set offset cursor#
+				while offset>=^reloc_dyn_value.srcstart
+					if offset<^reloc_dyn_initobj.srcend
+						break
+					endif
+					incst reloc_dyn_initobj.objects
+					if reloc_dyn_initobj.objects#!=(NULL)
+						setcall datavaddr reloc_dyn_initobj(datavaddr)
+						continue
+					endif
+					ret     #it's not in .data anymore
+				endwhile
+				setcall cursor# reloc_dyn_value(offset)
+				add cursor (rel_size)
+				call verbose((verbose_count))
+			endwhile
+		endif
+	endif
+endfunction
--- ocompiler-1.orig/ostrip/reldynt.s
+++ /dev/null
@@ -1,128 +0,0 @@
-
-function reloc_sort(sv pointer,sv end,sv dest,sd diff)
-	sv start;set start pointer
-	while start!=end
-		set pointer start
-
-		add pointer diff
-		add end diff
-
-		sd min;set min pointer#
-		sd pos;set pos pointer
-		add pointer (rel_size)
-		while pointer!=end
-			if pointer#<^min
-				set min pointer#
-				set pos pointer
-			endif
-			add pointer (rel_size)
-		endwhile
-
-		sub pos diff
-		sub end diff
-
-		call memcpy(dest,pos,(rel_size))
-		add dest (rel_size)
-		if start!=pos
-		#to fill the gap
-			call memcpy(pos,start,(rel_size))
-		endif
-		add start (rel_size)
-	endwhile
-endfunction
-
-#correctoffset
-function reloc_dyn_value(sd wrongoffset)
-	valuex srcstart#1
-	valuex srcmid#1
-	valuex destd#1
-	valuex destv#1
-
-	if wrongoffset>=^srcmid
-	#virtual
-		sub wrongoffset srcmid
-		add wrongoffset destv
-		return wrongoffset
-	endif
-	#file
-	sub wrongoffset srcstart
-	add wrongoffset destd
-	return wrongoffset
-endfunction
-
-#datavaddr
-function reloc_dyn_initobj(sd datavaddr)
-	valuex objects#1
-	valuex srcend#1
-	valuex destdnext#1
-	valuex destvnext#1
-
-	set reloc_dyn_value.destd destdnext
-	set reloc_dyn_value.destv destvnext
-	set reloc_dyn_value.srcstart datavaddr
-
-	sv obj;set obj objects#
-	add obj (to_data_extra)
-	sd herevirtual;set herevirtual obj#d^
-	set reloc_dyn_value.srcmid datavaddr
-	add reloc_dyn_value.srcmid herevirtual
-	add destdnext herevirtual
-	add obj (from_data_extra_to_data_extra_sz)
-	sub herevirtual obj#
-	neg herevirtual
-	add destvnext herevirtual
-
-	add obj (from_extra_sz_to_extra_sz_a)
-	add datavaddr obj#
-	set srcend datavaddr
-
-	return datavaddr
-endfunction
-
-function reloc_iteration(sv pointer,sd end,sd datavaddr,sd datavaddrend,sd diff)
-	#this is called in all 3 cases (even only at addends there is virtual)
-	add pointer diff
-	add end diff
-	#find the minimum and the maximum
-	while pointer!=end
-		if pointer#>=^datavaddr
-			break
-		endif
-		add pointer (rel_size)
-	endwhile
-	if pointer!=end
-		#can be .text after .data
-		sv cursor;set cursor pointer
-		while pointer!=end
-			if pointer#>=^datavaddrend
-				break
-			endif
-			add pointer (rel_size)
-		endwhile
-		if cursor!=pointer
-			#at first object only virtuals can be corrected
-			set reloc_dyn_initobj.objects frees.objects
-			set reloc_dyn_initobj.destdnext datavaddr
-			set reloc_dyn_initobj.destvnext datavaddr
-			add reloc_dyn_initobj.destvnext frees.exedatasize  ##this is after the new size was set
-			setcall datavaddr reloc_dyn_initobj(datavaddr)
-			while cursor!=pointer
-				sd offset;set offset cursor#
-				while offset>=^reloc_dyn_value.srcstart
-					if offset<^reloc_dyn_initobj.srcend
-						break
-					endif
-					incst reloc_dyn_initobj.objects
-					if reloc_dyn_initobj.objects#!=(NULL)
-						setcall datavaddr reloc_dyn_initobj(datavaddr)
-						continue
-					endif
-					ret     #it's not in .data anymore
-				endwhile
-				setcall cursor# reloc_dyn_value(offset)
-				add cursor (rel_size)
-				call verbose((verbose_count))
-			endwhile
-		endif
-	endif
-endfunction
--- /dev/null
+++ ocompiler-1/ostrip/throwless.oc
@@ -0,0 +1,199 @@
+
+function frees()
+	valuex exefile#1
+	const pexefile^exefile
+	if exefile!=(NULL)
+		call fclose(exefile)
+	valuex exedata#1;valuex exedatasize#1
+	valuex exetext#1;valuex exetextsize#1
+	valuex exesym#section_nr_of_values
+	valuex exestr#section_nr_of_values
+	const pexedata^exedata;const pexedatasize^exedatasize
+	const pexetext^exetext
+	const pexesym^exesym
+	const pexestr^exestr
+	valuex execreladyn#1;valuex execreladynsize#1
+	valuex execdynsym#1;valuex execdynsymsize#1
+	valuex execdynstr#1;valuex execdynstrsize#1
+		if exedata!=(NULL)
+			call free(exedata)
+			if exetext!=(NULL)
+				call free(exetext)
+				if exesym!=(NULL)
+					call free(exesym)
+					if exestr!=(NULL)
+						call free(exestr)
+					endif
+				endif
+			endif
+		endif
+		if execreladyn!=(NULL)
+			call free(execreladyn)
+		endif
+		if execdynsym!=(NULL)
+			call free(execdynsym)
+			if execdynstr!=(NULL)
+				call free(execdynstr)
+			endif
+		endif
+		valuex objects#1
+		const pobjects^objects
+		if objects!=(NULL)
+			call freeobjects(objects)
+			call free(objects)
+		endif
+	endif
+endfunction
+function freeobjects(sv objects)
+	while objects#!=(NULL)
+		call freeobject(objects#)
+		call free(objects#)
+		add objects :
+	endwhile
+endfunction
+function freeobject(sv object)
+	sd end=object_alloc_secs
+	add end object
+	while object!=end
+		if object#!=(NULL)
+			call free(object#)
+		else
+			ret
+		endelse
+		add object (section_alloc)
+	endwhile
+endfunction
+
+function verbose(sd action)
+	datax a#1
+	const ptrverbose^a
+	data n=0     ;#only in one ocomp section
+	if a=0
+		if action=(verbose_count)
+			inc n
+		else
+		#if action==(verbose_flush)
+			char out#10+1   ;#max 32
+			call sprintf(#out,"%u",n)
+			call Message(#out)
+			set n 0
+		endelse
+	endif
+endfunction
+
+#file
+
+#pos/-1
+function shnames_find(ss mem,sd end,sd str)
+	sd start;set start mem
+	while mem!=end
+		sd cmp;setcall cmp strcmp(mem,str)
+		if cmp=0
+			sub mem start
+			return mem
+		endif
+		addcall mem strlen(mem)
+		inc mem
+	endwhile
+	return -1
+endfunction
+function shnames_find_sec(sv sec,sd str)
+	sd mem;set mem sec#
+	incst sec
+	sd end;set end mem
+	add end sec#
+	sd pos;setcall pos shnames_find(mem,end,str)
+	return pos
+endfunction
+
+#obj
+
+function objs_concat(sv objects,sv pdata,sd datainneroffset)
+	sd initial;set initial pdata#
+	add initial datainneroffset
+	sd dest;set dest initial
+	sd src;set src dest
+
+	#skip first memtomem
+	sv object=to_data_extra;add object objects#
+	add dest object#d^
+	add object (from_data_extra_to_data_extra_sz_a)
+	add src object#
+	incst objects
+
+	while objects#!=(NULL)
+		set object (to_data_extra);add object objects#
+		sd stripped;set stripped object#d^
+		#we implement own memcpy here because right to left can break all
+		call memtomem(dest,src,stripped)
+		add dest stripped
+		add object (from_data_extra_to_data_extra_sz_a)
+		add src object#
+		incst objects
+	endwhile
+
+	incst pdata
+	#exe data size can have last object aligned/unaligned this way (don't count on initial size)
+	sub dest initial
+	#rewrite size from extra+unstripped to stripped, to be used at rel and reldyn
+	sd size;set size pdata#
+	set pdata# dest
+
+	sub size dest
+	sub size datainneroffset
+	sv out^stdout
+	call fprintf(out#,"Stripped size: %llu bytes",size)
+	call messagedelim(out)
+endfunction
+
+function memtomem(sv dest,sv src,sd size)
+	#optimized
+	sd opt=:-1
+	and opt size
+
+	sub size opt
+	add size dest
+	while dest!=size
+		set dest# src#
+		incst dest
+		incst src
+	endwhile
+
+	add size opt
+	while dest!=size
+		set dest#s^ src#s^
+		inc dest
+		inc src
+	endwhile
+endfunction
+
+function objs_align(sd sz)
+#must import the align from ocomp
+	const elf_sec_obj_align_trail=elf_sec_obj_align-1
+	add sz (elf_sec_obj_align_trail)
+	and sz (~elf_sec_obj_align_trail)
+	return sz
+endfunction
+
+#realoffset-offset
+function realoffset(sd add,sd sec_size)
+	sv objs;set objs frees.objects
+	sd data_size=0
+	while objs#!=(NULL)
+		sv obj;set obj objs#
+		add obj add
+		sv aligned;set aligned obj
+		add aligned (from_extra_sz_to_extra_sz_a)
+		set aligned aligned#
+		add data_size aligned
+		incst objs
+	endwhile
+	if aligned!=obj#
+	#last object is not aligned
+		sub aligned obj#
+		sub data_size aligned
+	endif
+	sub data_size sec_size
+	neg data_size
+	return data_size
+endfunction
--- ocompiler-1.orig/ostrip/throwless.s
+++ /dev/null
@@ -1,199 +0,0 @@
-
-function frees()
-	valuex exefile#1
-	const pexefile^exefile
-	if exefile!=(NULL)
-		call fclose(exefile)
-	valuex exedata#1;valuex exedatasize#1
-	valuex exetext#1;valuex exetextsize#1
-	valuex exesym#section_nr_of_values
-	valuex exestr#section_nr_of_values
-	const pexedata^exedata;const pexedatasize^exedatasize
-	const pexetext^exetext
-	const pexesym^exesym
-	const pexestr^exestr
-	valuex execreladyn#1;valuex execreladynsize#1
-	valuex execdynsym#1;valuex execdynsymsize#1
-	valuex execdynstr#1;valuex execdynstrsize#1
-		if exedata!=(NULL)
-			call free(exedata)
-			if exetext!=(NULL)
-				call free(exetext)
-				if exesym!=(NULL)
-					call free(exesym)
-					if exestr!=(NULL)
-						call free(exestr)
-					endif
-				endif
-			endif
-		endif
-		if execreladyn!=(NULL)
-			call free(execreladyn)
-		endif
-		if execdynsym!=(NULL)
-			call free(execdynsym)
-			if execdynstr!=(NULL)
-				call free(execdynstr)
-			endif
-		endif
-		valuex objects#1
-		const pobjects^objects
-		if objects!=(NULL)
-			call freeobjects(objects)
-			call free(objects)
-		endif
-	endif
-endfunction
-function freeobjects(sv objects)
-	while objects#!=(NULL)
-		call freeobject(objects#)
-		call free(objects#)
-		add objects :
-	endwhile
-endfunction
-function freeobject(sv object)
-	sd end=object_alloc_secs
-	add end object
-	while object!=end
-		if object#!=(NULL)
-			call free(object#)
-		else
-			ret
-		endelse
-		add object (section_alloc)
-	endwhile
-endfunction
-
-function verbose(sd action)
-	datax a#1
-	const ptrverbose^a
-	data n=0     ;#only in one ocomp section
-	if a=0
-		if action=(verbose_count)
-			inc n
-		else
-		#if action==(verbose_flush)
-			char out#10+1   ;#max 32
-			call sprintf(#out,"%u",n)
-			call Message(#out)
-			set n 0
-		endelse
-	endif
-endfunction
-
-#file
-
-#pos/-1
-function shnames_find(ss mem,sd end,sd str)
-	sd start;set start mem
-	while mem!=end
-		sd cmp;setcall cmp strcmp(mem,str)
-		if cmp=0
-			sub mem start
-			return mem
-		endif
-		addcall mem strlen(mem)
-		inc mem
-	endwhile
-	return -1
-endfunction
-function shnames_find_sec(sv sec,sd str)
-	sd mem;set mem sec#
-	incst sec
-	sd end;set end mem
-	add end sec#
-	sd pos;setcall pos shnames_find(mem,end,str)
-	return pos
-endfunction
-
-#obj
-
-function objs_concat(sv objects,sv pdata,sd datainneroffset)
-	sd initial;set initial pdata#
-	add initial datainneroffset
-	sd dest;set dest initial
-	sd src;set src dest
-
-	#skip first memtomem
-	sv object=to_data_extra;add object objects#
-	add dest object#d^
-	add object (from_data_extra_to_data_extra_sz_a)
-	add src object#
-	incst objects
-
-	while objects#!=(NULL)
-		set object (to_data_extra);add object objects#
-		sd stripped;set stripped object#d^
-		#we implement own memcpy here because right to left can break all
-		call memtomem(dest,src,stripped)
-		add dest stripped
-		add object (from_data_extra_to_data_extra_sz_a)
-		add src object#
-		incst objects
-	endwhile
-
-	incst pdata
-	#exe data size can have last object aligned/unaligned this way (don't count on initial size)
-	sub dest initial
-	#rewrite size from extra+unstripped to stripped, to be used at rel and reldyn
-	sd size;set size pdata#
-	set pdata# dest
-
-	sub size dest
-	sub size datainneroffset
-	sv out^stdout
-	call fprintf(out#,"Stripped size: %llu bytes",size)
-	call messagedelim(out)
-endfunction
-
-function memtomem(sv dest,sv src,sd size)
-	#optimized
-	sd opt=:-1
-	and opt size
-
-	sub size opt
-	add size dest
-	while dest!=size
-		set dest# src#
-		incst dest
-		incst src
-	endwhile
-
-	add size opt
-	while dest!=size
-		set dest#s^ src#s^
-		inc dest
-		inc src
-	endwhile
-endfunction
-
-function objs_align(sd sz)
-#must import the align from ocomp
-	const elf_sec_obj_align_trail=elf_sec_obj_align-1
-	add sz (elf_sec_obj_align_trail)
-	and sz (~elf_sec_obj_align_trail)
-	return sz
-endfunction
-
-#realoffset-offset
-function realoffset(sd add,sd sec_size)
-	sv objs;set objs frees.objects
-	sd data_size=0
-	while objs#!=(NULL)
-		sv obj;set obj objs#
-		add obj add
-		sv aligned;set aligned obj
-		add aligned (from_extra_sz_to_extra_sz_a)
-		set aligned aligned#
-		add data_size aligned
-		incst objs
-	endwhile
-	if aligned!=obj#
-	#last object is not aligned
-		sub aligned obj#
-		sub data_size aligned
-	endif
-	sub data_size sec_size
-	neg data_size
-	return data_size
-endfunction
--- ocompiler-1.orig/otoc/Makefile
+++ ocompiler-1/otoc/Makefile
@@ -18,7 +18,7 @@ endif
 
 OBJ = ${prog}.o
 FULLOBJ = ./${prog}
-FULLOBJS = ${FULLOBJ}.s
+FULLOBJS = ${FULLOBJ}.oc
 FULLOBJO = ${FULLOBJ}.o
 FULLOBJLOG = ${FULLOBJS}.log
 
--- /dev/null
+++ ocompiler-1/otoc/function.oc
@@ -0,0 +1,10 @@
+
+function functiondef_intern(sv pbuffer)
+	datax args#1;call get_data(pbuffer,#args)
+end
+#function functiondef_raw(sv pbuffer)
+function functiondef_extern(sv pbuffer)
+	charx e#1;call get_char(pbuffer,#e)
+	call functiondef_intern(pbuffer)
+end
+#function functiondef_entry(sv pbuffer)
--- ocompiler-1.orig/otoc/function.s
+++ /dev/null
@@ -1,10 +0,0 @@
-
-function functiondef_intern(sv pbuffer)
-	datax args#1;call get_data(pbuffer,#args)
-end
-#function functiondef_raw(sv pbuffer)
-function functiondef_extern(sv pbuffer)
-	charx e#1;call get_char(pbuffer,#e)
-	call functiondef_intern(pbuffer)
-end
-#function functiondef_entry(sv pbuffer)
--- /dev/null
+++ ocompiler-1/otoc/loop.oc
@@ -0,0 +1,174 @@
+
+importx "fseek" fseek
+importx "ftell" ftell
+importx "rewind" rewind
+importx "malloc" malloc
+importx "fread" fread
+importx "free" free
+
+const SEEK_END=2
+
+einclude "../src/files/headers/xfile.h" "/usr/include/ocompiler/xfile.h"
+#einclude? will use all constants in the header. yes, but some are used without touching them, like in this next function
+const Xfile_last_command=Xfile_line
+
+datax result#1
+
+#exit
+function loop(sd input,sd output)
+	set main.result (EXIT_FAILURE)
+	sd a;set a fseek(input,0,(SEEK_END)) #on 32 can be -1 return error
+	if a=0
+		sd delim;set delim ftell(input) #is still same place if file deleted in parallel
+		#if delim!=-1  #lseek and same result (remark fileno)
+		call rewind(input)
+		sd buffer;set buffer malloc(delim)
+		if buffer!=(NULL)
+			sd r;set r fread(buffer,delim,1,input)
+			if r=1
+				ss pointer;set pointer buffer
+				add delim buffer
+				set main.result (EXIT_SUCCESS)
+				while pointer!=delim
+					charx command#1;call get_char(#pointer,#command)
+					if command>(Xfile_last_command)
+						break
+					end
+					value Xfile_comment^comment
+					value *Xfile_commentmulti^commentmulti
+					value *Xfile_commentlineend^commentlineend
+					value *Xfile_format^format
+					value *Xfile_include^include
+					value *Xfile_functiondef^functiondef
+					value *Xfile_declare^declare
+					value *Xfile_action^action
+					value *Xfile_action2^action2
+					value *Xfile_call^call
+					value *Xfile_callex^callex
+					value *Xfile_if^if
+					value *Xfile_else^else
+					value *Xfile_while^while
+					value *Xfile_break^break
+					value *Xfile_continue^continue
+					value *Xfile_end^end
+					value *Xfile_ret^ret
+					value *Xfile_library^library
+					value *Xfile_import^import
+					value *Xfile_aftercall^aftercall
+					value *Xfile_hex^hex
+					value *Xfile_override^override
+					value *Xfile_orphan^orphan
+					value *Xfile_interrupt^interrupt
+					value *Xfile_line^line
+					mult command :
+					sv dest^Xfile_comment;add dest command
+					set dest dest#
+					call dest(#pointer,output)
+					if main.result=(EXIT_FAILURE);break;end
+				end
+			end
+			call free(buffer)
+		end
+	end
+	return main.result
+end
+
+function comment(sv *pbuffer)
+end
+function commentmulti(sv *pbuffer)
+end
+function commentlineend(sv *pbuffer)
+end
+function format(sv pbuffer)
+	charx fmt#1;call get_char(pbuffer,#fmt)
+end
+function include(sv *pbuffer)
+end
+include "function.oc"
+function functiondef(sv pbuffer)
+	datax sz#1;valuex pointer#1
+	call get_string(pbuffer,#sz,#pointer)
+
+	value intern^functiondef_intern
+	value *raw^functiondef_intern       #functiondef_raw
+	value *extern^functiondef_extern
+	value *entry^functiondef_extern     #functiondef_entry
+	charx type#1;call get_char(pbuffer,#type)
+	mult type :
+	sv dest^intern;add dest type
+	set dest dest#
+	call dest(pbuffer)
+end
+function declare(sv *pbuffer)
+end
+function action(sv *pbuffer)
+end
+function action2(sv *pbuffer)
+end
+function call(sv *pbuffer)
+end
+function callex(sv *pbuffer)
+end
+function if(sv *pbuffer)
+end
+function else(sv *pbuffer)
+end
+function while(sv *pbuffer)
+end
+function break(sv *pbuffer)
+end
+function continue(sv *pbuffer)
+end
+function end(sv *pbuffer,sd outfile)
+	call writen(outfile,"}",1)
+end
+function ret(sv *pbuffer)
+end
+function library(sv *pbuffer)
+end
+function import(sv *pbuffer)
+end
+function aftercall(sv *pbuffer)
+end
+function hex(sv *pbuffer)
+end
+function override(sv *pbuffer)
+end
+function orphan(sv *pbuffer)
+end
+function interrupt(sv *pbuffer)
+end
+function line(sv *pbuffer)
+end
+
+function get_char(sv pbuffer,ss pchar)
+	ss buffer;set buffer pbuffer#
+	set pchar# buffer#
+	add pbuffer# (Xfile_sz_char)
+end
+
+function get_data(sv pbuffer,sd pdata)
+	sd buffer;set buffer pbuffer#
+	set pdata# buffer#
+	add pbuffer# (Xfile_sz_int)
+end
+
+function get_string(sv pbuffer,sd psize,sv ppointer)
+	call get_data(pbuffer,psize)
+	set ppointer# pbuffer#
+	add pbuffer# psize#
+end
+
+importx "fwrite" fwrite
+
+function writen(sd outfile,ss buf,sd sz)
+	sd items;set items fwrite(buf,sz,1,outfile)
+	if items!=1
+		set main.result (EXIT_FAILURE)
+		ret
+	end
+	set items fwrite("\n",1,1,outfile)
+	if items!=1
+		set main.result (EXIT_FAILURE)
+	end
+end
--- ocompiler-1.orig/otoc/loop.s
+++ /dev/null
@@ -1,175 +0,0 @@
-
-importx "fseek" fseek
-importx "ftell" ftell
-importx "rewind" rewind
-importx "malloc" malloc
-importx "fread" fread
-importx "free" free
-
-const SEEK_END=2
-
-einclude "../src/files/headers/xfile.h" "/usr/include/ocompiler/xfile.h"
-#einclude? will use all constants in the header. yes, but some are used without touching them, like in this next function
-const Xfile_last_command=Xfile_line
-
-datax result#1
-
-#exit
-function loop(sd input,sd output)
-	set main.result (EXIT_FAILURE)
-	sd a;set a fseek(input,0,(SEEK_END)) #on 32 can be -1 return error
-	if a=0
-		sd delim;set delim ftell(input) #is still same place if file deleted in parallel
-		#if delim!=-1  #lseek and same result (remark fileno)
-		call rewind(input)
-		sd buffer;set buffer malloc(delim)
-		if buffer!=(NULL)
-			sd r;set r fread(buffer,delim,1,input)
-			if r=1
-				ss pointer;set pointer buffer
-				add delim buffer
-				set main.result (EXIT_SUCCESS)
-				while pointer!=delim
-					charx command#1;call get_char(#pointer,#command)
-					if command>(Xfile_last_command)
-						break
-					end
-					value Xfile_comment^comment
-					value *Xfile_commentmulti^commentmulti
-					value *Xfile_commentlineend^commentlineend
-					value *Xfile_format^format
-					value *Xfile_include^include
-					value *Xfile_functiondef^functiondef
-					value *Xfile_declare^declare
-					value *Xfile_action^action
-					value *Xfile_action2^action2
-					value *Xfile_call^call
-					value *Xfile_callex^callex
-					value *Xfile_if^if
-					value *Xfile_else^else
-					value *Xfile_while^while
-					value *Xfile_break^break
-					value *Xfile_continue^continue
-					value *Xfile_end^end
-					value *Xfile_ret^ret
-					value *Xfile_library^library
-					value *Xfile_import^import
-					value *Xfile_aftercall^aftercall
-					value *Xfile_hex^hex
-					value *Xfile_override^override
-					value *Xfile_orphan^orphan
-					value *Xfile_interrupt^interrupt
-					value *Xfile_line^line
-					mult command :
-					sv dest^Xfile_comment;add dest command
-					set dest dest#
-					call dest(#pointer,output)
-					if main.result=(EXIT_FAILURE);break;end
-				end
-			end
-			call free(buffer)
-		end
-	end
-	return main.result
-end
-
-function comment(sv *pbuffer)
-end
-function commentmulti(sv *pbuffer)
-end
-function commentlineend(sv *pbuffer)
-end
-function format(sv pbuffer)
-	charx fmt#1;call get_char(pbuffer,#fmt)
-end
-function include(sv *pbuffer)
-end
-include "function.s"
-function functiondef(sv pbuffer)
-	datax sz#1;valuex pointer#1
-	call get_string(pbuffer,#sz,#pointer)
-
-	value intern^functiondef_intern
-	value *raw^functiondef_intern       #functiondef_raw
-	value *extern^functiondef_extern
-	value *entry^functiondef_extern     #functiondef_entry
-	charx type#1;call get_char(pbuffer,#type)
-	mult type :
-	sv dest^intern;add dest type
-	set dest dest#
-	call dest(pbuffer)
-end
-function declare(sv *pbuffer)
-end
-function action(sv *pbuffer)
-end
-function action2(sv *pbuffer)
-end
-function call(sv *pbuffer)
-end
-function callex(sv *pbuffer)
-end
-function if(sv *pbuffer)
-end
-function else(sv *pbuffer)
-end
-function while(sv *pbuffer)
-end
-function break(sv *pbuffer)
-end
-function continue(sv *pbuffer)
-end
-function end(sv *pbuffer,sd outfile)
-	call writen(outfile,"}",1)
-end
-function ret(sv *pbuffer)
-end
-function library(sv *pbuffer)
-end
-function import(sv *pbuffer)
-end
-function aftercall(sv *pbuffer)
-end
-function hex(sv *pbuffer)
-end
-function override(sv *pbuffer)
-end
-function orphan(sv *pbuffer)
-end
-function interrupt(sv *pbuffer)
-end
-function line(sv *pbuffer)
-end
-
-function get_char(sv pbuffer,ss pchar)
-	ss buffer;set buffer pbuffer#
-	set pchar# buffer#
-	add pbuffer# (Xfile_sz_char)
-end
-
-function get_data(sv pbuffer,sd pdata)
-	sd buffer;set buffer pbuffer#
-	set pdata# buffer#
-	add pbuffer# (Xfile_sz_int)
-end
-
-function get_string(sv pbuffer,sd psize,sv ppointer)
-	call get_data(pbuffer,psize)
-	set ppointer# pbuffer#
-	add pbuffer# psize#
-end
-
-importx "strlen" strlen
-importx "fwrite" fwrite
-
-function writen(sd outfile,ss buf,sd sz)
-	sd items;set items fwrite(buf,sz,1,outfile)
-	if items!=1
-		set main.result (EXIT_FAILURE)
-		ret
-	end
-	set items fwrite("\n",1,1,outfile)
-	if items!=1
-		set main.result (EXIT_FAILURE)
-	end
-end
--- /dev/null
+++ ocompiler-1/otoc/otoc.oc
@@ -0,0 +1,61 @@
+
+format elfobj64
+
+const EXIT_SUCCESS=0
+const EXIT_FAILURE=1
+const NULL=0
+
+Const asciinul=0x0
+Const asciidot=0x2E
+Const asciic=0x63
+
+importx "puts" puts
+importx "fopen" fopen
+importx "fclose" fclose
+importx "strrchr" strrchr
+
+include "loop.oc"
+
+function out_file(sd in)
+	ss p;set p strrchr(in,(asciidot))
+	if p!=(NULL)
+		set p# 0
+		set p strrchr(in,(asciidot))
+		if p!=(NULL)
+			#here we know there at at least two dots and of course the term null char
+			inc p
+			set p# (asciic)
+			inc p
+			set p# (asciinul)
+			sd f;set f fopen(in,"wb")
+			if f!=(NULL)
+				return f
+			end
+			call puts("Cannot open output file")
+		end
+	end
+	return (NULL)
+end
+
+entry main(sd argc,sv argv)
+	if argc=2
+		incst argv
+		sd s;set s argv#
+		sd f;setcall f fopen(s,"rb")
+		if f!=(NULL)
+			sd out;set out out_file(s)
+			sd exit=EXIT_SUCCESS
+			if out!=(NULL)
+				set exit loop(f,out)
+				call fclose(out)
+			else
+				set exit (EXIT_FAILURE)
+			end
+			call fclose(f)
+			return exit
+		end
+		call puts("Cannot open input file")
+		return (EXIT_FAILURE)
+	end
+	call puts("Usage: otoc filePath")
+	return (EXIT_FAILURE)
--- ocompiler-1.orig/otoc/otoc.s
+++ /dev/null
@@ -1,61 +0,0 @@
-
-format elfobj64
-
-const EXIT_SUCCESS=0
-const EXIT_FAILURE=1
-const NULL=0
-
-Const asciinul=0x0
-Const asciidot=0x2E
-Const asciic=0x63
-
-importx "puts" puts
-importx "fopen" fopen
-importx "fclose" fclose
-importx "strrchr" strrchr
-
-include "loop.s"
-
-function out_file(sd in)
-	ss p;set p strrchr(in,(asciidot))
-	if p!=(NULL)
-		set p# 0
-		set p strrchr(in,(asciidot))
-		if p!=(NULL)
-			#here we know there at at least two dots and of course the term null char
-			inc p
-			set p# (asciic)
-			inc p
-			set p# (asciinul)
-			sd f;set f fopen(in,"wb")
-			if f!=(NULL)
-				return f
-			end
-			call puts("Cannot open output file")
-		end
-	end
-	return (NULL)
-end
-
-entry main(sd argc,sv argv)
-	if argc=2
-		incst argv
-		sd s;set s argv#
-		sd f;setcall f fopen(s,"rb")
-		if f!=(NULL)
-			sd out;set out out_file(s)
-			sd exit=EXIT_SUCCESS
-			if out!=(NULL)
-				set exit loop(f,out)
-				call fclose(out)
-			else
-				set exit (EXIT_FAILURE)
-			end
-			call fclose(f)
-			return exit
-		end
-		call puts("Cannot open input file")
-		return (EXIT_FAILURE)
-	end
-	call puts("Usage: otoc filePath")
-	return (EXIT_FAILURE)
--- ocompiler-1.orig/ounused/Makefile
+++ ocompiler-1/ounused/Makefile
@@ -5,7 +5,7 @@ all: ${OB}
 
 OBJ = ${OB}.o
 FULLOBJ = ./${OB}
-FULLOBJS = ${FULLOBJ}.s
+FULLOBJS = ${FULLOBJ}.oc
 FULLOBJO = ${FULLOBJ}.o
 FULLOBJLOG = ${FULLOBJS}.log
 
--- /dev/null
+++ ocompiler-1/ounused/const.oc
@@ -0,0 +1,29 @@
+
+function constant_add(sd s,sd sz)
+	sv p
+	setcall p working_file()
+	call addtocont(p,s,sz)
+endfunction
+
+#previous file
+function incrementfiles()
+	sd cursor%levels_dp
+	set cursor cursor#
+	sd pf
+	if cursor=0
+		set pf (NULL)
+	else
+		setcall pf working_file()
+	endelse
+	sv lvs%levels_p
+	call ralloc(lvs,(dword))
+	add cursor lvs#
+	#sd cursor;set cursor lvs#d^;call ralloc(lvs,(dword));add lvs (dword);add cursor lvs#
+	setcall cursor# filessize()
+	return pf
+endfunction
+
+function decrementfiles()
+	sd lvs%levels_p
+	call ralloc(lvs,(-dword))
+endfunction
--- ocompiler-1.orig/ounused/const.s
+++ /dev/null
@@ -1,29 +0,0 @@
-
-function constant_add(sd s,sd sz)
-	sv p
-	setcall p working_file()
-	call addtocont(p,s,sz)
-endfunction
-
-#previous file
-function incrementfiles()
-	sd cursor%levels_dp
-	set cursor cursor#
-	sd pf
-	if cursor=0
-		set pf (NULL)
-	else
-		setcall pf working_file()
-	endelse
-	sv lvs%levels_p
-	call ralloc(lvs,(dword))
-	add cursor lvs#
-	#sd cursor;set cursor lvs#d^;call ralloc(lvs,(dword));add lvs (dword);add cursor lvs#
-	setcall cursor# filessize()
-	return pf
-endfunction
-
-function decrementfiles()
-	sd lvs%levels_p
-	call ralloc(lvs,(-dword))
-endfunction
--- /dev/null
+++ ocompiler-1/ounused/files.oc
@@ -0,0 +1,95 @@
+
+const FALSE=0
+const TRUE=1
+
+#const size_cont=dword+:
+const size_cont=:+dword
+const size_conts=5*size_cont
+
+function fileentry_add(sd full,sd len)
+	sd er
+	sd size=size_conts+dword
+	sd ent
+	add size len
+	setcall er malloc_throwless(#ent,size)
+	if er=(NULL)
+		sd init
+		set init ent
+		#
+		setcall er fileentry_init(ent)
+		if er=(NULL)
+			add ent (size_conts)
+			set ent# len
+			add ent (dword)
+			call memcpy(ent,full,len)
+			#
+			sv fls%files_p
+			sd previous_file
+			setcall previous_file incrementfiles()
+			setcall er ralloc_throwless(fls,:)
+			if er=(NULL)
+				sd offset=-:
+				sd mem%files_dp
+				add offset mem#
+				set fls fls#
+				add fls offset
+				#sd mem;set mem fls#d^;call incrementfiles();setcall er ralloc_throwless(fls,:);if er==(NULL);sv cursor;add fls (dword);set cursor fls#;add cursor mem
+				set fls# init
+				if previous_file!=(NULL)
+					add previous_file (2*size_cont)
+					call adddwordtocont(previous_file,offset)
+				endif
+				ret
+			endif
+			call fileentry_uninit(init)
+			call free(init)
+			call free(full)
+			call erExit(er)
+		endif
+		call free(init)
+		call free(full)
+		call erExit(er)
+	endif
+	call free(full)
+	call erExit(er)
+endfunction
+
+function fileentry(sd s,sd sz)
+	call nullend(s,sz)
+	sd temp
+	setcall temp realpath(s,(NULL))
+	if temp!=(NULL)
+		call fileentry_exists(temp)
+		call free(temp)
+		ret
+	endif
+	call erExit("realpath error")
+endfunction
+
+function fileentry_exists(sd s)
+	sd sz
+	setcall sz strlen(s)
+	sv fls%files_p
+	sd init;set init fls#
+	sv p
+	set p init
+	add fls :
+	set fls fls#d^
+	add fls p
+	while p!=fls
+		sd b
+		setcall b fileentry_compare(p#,s,sz)
+		if b=0
+			call skip_set()
+			#add to previous declared
+			sd wf;setcall wf working_file()
+			sub p init
+			add wf (size_cont)
+			call adddwordtocont(wf,p)
+			ret
+		endif
+		incst p
+	#set p fls#d^;add fls (dword);set fls fls#;add p fls;while fls!=p;sd b;setcall b fileentry_compare(fls#,s,sz);if b==0;call skip_set();ret;endif;incst fls
+	endwhile
+	call fileentry_add(s,sz)
+endfunction
--- ocompiler-1.orig/ounused/files.s
+++ /dev/null
@@ -1,95 +0,0 @@
-
-const FALSE=0
-const TRUE=1
-
-#const size_cont=dword+:
-const size_cont=:+dword
-const size_conts=5*size_cont
-
-function fileentry_add(sd full,sd len)
-	sd er
-	sd size=size_conts+dword
-	sd ent
-	add size len
-	setcall er malloc_throwless(#ent,size)
-	if er=(NULL)
-		sd init
-		set init ent
-		#
-		setcall er fileentry_init(ent)
-		if er=(NULL)
-			add ent (size_conts)
-			set ent# len
-			add ent (dword)
-			call memcpy(ent,full,len)
-			#
-			sv fls%files_p
-			sd previous_file
-			setcall previous_file incrementfiles()
-			setcall er ralloc_throwless(fls,:)
-			if er=(NULL)
-				sd offset=-:
-				sd mem%files_dp
-				add offset mem#
-				set fls fls#
-				add fls offset
-				#sd mem;set mem fls#d^;call incrementfiles();setcall er ralloc_throwless(fls,:);if er==(NULL);sv cursor;add fls (dword);set cursor fls#;add cursor mem
-				set fls# init
-				if previous_file!=(NULL)
-					add previous_file (2*size_cont)
-					call adddwordtocont(previous_file,offset)
-				endif
-				ret
-			endif
-			call fileentry_uninit(init)
-			call free(init)
-			call free(full)
-			call erExit(er)
-		endif
-		call free(init)
-		call free(full)
-		call erExit(er)
-	endif
-	call free(full)
-	call erExit(er)
-endfunction
-
-function fileentry(sd s,sd sz)
-	call nullend(s,sz)
-	sd temp
-	setcall temp realpath(s,(NULL))
-	if temp!=(NULL)
-		call fileentry_exists(temp)
-		call free(temp)
-		ret
-	endif
-	call erExit("realpath error")
-endfunction
-
-function fileentry_exists(sd s)
-	sd sz
-	setcall sz strlen(s)
-	sv fls%files_p
-	sd init;set init fls#
-	sv p
-	set p init
-	add fls :
-	set fls fls#d^
-	add fls p
-	while p!=fls
-		sd b
-		setcall b fileentry_compare(p#,s,sz)
-		if b=0
-			call skip_set()
-			#add to previous declared
-			sd wf;setcall wf working_file()
-			sub p init
-			add wf (size_cont)
-			call adddwordtocont(wf,p)
-			ret
-		endif
-		incst p
-	#set p fls#d^;add fls (dword);set fls fls#;add p fls;while fls!=p;sd b;setcall b fileentry_compare(fls#,s,sz);if b==0;call skip_set();ret;endif;incst fls
-	endwhile
-	call fileentry_add(s,sz)
-endfunction
--- /dev/null
+++ ocompiler-1/ounused/inits.oc
@@ -0,0 +1,30 @@
+
+include "./mem.oc"
+
+function allocs()
+	sv ip%imp_mem_p
+	call alloc(ip)
+	sv fp%fn_mem_p
+	call alloc(fp)
+	#
+	sv cwd%cwd_p
+	setcall cwd# get_current_dir_name()
+	if cwd#=(NULL)
+		call erExit("get_current_dir_name error")
+	endif
+	sd size=:
+	add size cwd
+	sd sz
+	setcall sz strlen(cwd#)
+	inc sz
+	set size# sz
+	call ralloc(cwd,(dword))
+	set cwd cwd#
+	add cwd sz
+	set cwd#d^ sz
+	#sv cursor=dword;add cursor cwd;setcall cursor# get_current_dir_name();if cursor#==(NULL);call erExit("get_current_dir_name error");endif;sd size;setcall size strlen(cursor#);inc size;set cwd#d^ size;call ralloc(cwd,(dword));set cursor cursor#;add cursor size;set cursor#d^ size
+	sv fls%files_p
+	call alloc(fls)
+	sv lvs%levels_p
+	call alloc(lvs)
+endfunction
--- ocompiler-1.orig/ounused/inits.s
+++ /dev/null
@@ -1,30 +0,0 @@
-
-include "./mem.s"
-
-function allocs()
-	sv ip%imp_mem_p
-	call alloc(ip)
-	sv fp%fn_mem_p
-	call alloc(fp)
-	#
-	sv cwd%cwd_p
-	setcall cwd# get_current_dir_name()
-	if cwd#=(NULL)
-		call erExit("get_current_dir_name error")
-	endif
-	sd size=:
-	add size cwd
-	sd sz
-	setcall sz strlen(cwd#)
-	inc sz
-	set size# sz
-	call ralloc(cwd,(dword))
-	set cwd cwd#
-	add cwd sz
-	set cwd#d^ sz
-	#sv cursor=dword;add cursor cwd;setcall cursor# get_current_dir_name();if cursor#==(NULL);call erExit("get_current_dir_name error");endif;sd size;setcall size strlen(cursor#);inc size;set cwd#d^ size;call ralloc(cwd,(dword));set cursor cursor#;add cursor size;set cursor#d^ size
-	sv fls%files_p
-	call alloc(fls)
-	sv lvs%levels_p
-	call alloc(lvs)
-endfunction
--- /dev/null
+++ ocompiler-1/ounused/loop.oc
@@ -0,0 +1,191 @@
+
+const NULL=0
+#const void=0
+const asciiperiod=0x2E
+const asciio=0x6F
+
+include "../src/files/headers/log.h"
+
+include "inits.oc"
+include "files.oc"
+include "const.oc"
+include "uconst.oc"
+
+function log_file(ss file)
+	sd f
+	setcall f fopen(file,"r")
+	if f!=(NULL)
+		sv fp%logf_p
+		set fp# f
+		sv p%logf_mem_p
+		sd sz=0
+		sd link=TRUE
+		while sz!=-1
+			sd bsz
+			setcall sz getline(p,#bsz,f)
+			if sz!=-1
+				#knowing line\r\n from ocompiler
+				sub sz 2
+				call log_line(p#,sz,#link)
+			else
+				sd e
+				setcall e feof(f)
+				if e=0
+					call erExit("get line error")
+				endif
+			endelse
+		endwhile
+		call uconst_miniresolve()
+		call logclose()
+		if link=(TRUE)
+			call printlink(file)
+		endif
+		ret
+	endif
+	call erExit("fopen error")
+endfunction
+
+function log_line(ss s,sd sz,sd plink)
+#i all, f all; at end every f not i, failure. constants are with all includes two types of children declared/already and at every log unused/still unused
+	sd type
+	set type s#
+	inc s;dec sz
+	sd skip
+	if plink#=(TRUE)
+		if type=(log_offset)
+			setcall skip skip_test()
+			if skip=(FALSE)
+				call constant_add(s,sz) #same as with const, except it has a dot
+			endif
+			ret
+		elseif type=(log_declare)
+			setcall skip skip_test() #skip same included file
+			if skip=(FALSE)
+				call constant_add(s,sz)
+			endif
+			ret
+		elseif type=(log_import)
+			setcall skip skip_test()
+			if skip=(FALSE)
+				call import_add(s,sz)
+			endif
+			ret
+		elseif type=(log_constant)
+			call uconst_add(s,sz)
+			ret
+		elseif type=(log_function)
+			sv fns%fn_mem_p
+			call addtocont(fns,s,sz)
+			ret
+		elseif type=(log_variable)
+			call uconst_add(s,sz)
+			ret
+		endelseif
+	endif
+	if type=(log_pathname)
+		call filesplus()
+		setcall skip skip_test()
+		if skip=(FALSE)
+			call fileentry(s,sz)
+		endif
+	elseif type=(log_pathfolder)
+		setcall skip skip_test()
+		if skip=(FALSE)
+			call incrementdir(s,sz)
+		endif
+	elseif type=(log_fileend)
+		setcall skip filesminus()
+		if skip<=0
+			call decrementdir()
+			if skip<0
+				call decrementfiles()
+			endif
+		endif
+	elseif type=(log_fileend_old)
+		setcall skip filesminus()
+		if skip<0
+			call decrementfiles()
+		endif
+	elseif type=(log_reusable)
+		set plink# (FALSE)
+	endelseif
+endfunction
+
+function import_add(sd s,sd sz)
+	sv imps%imp_mem_p
+	sd p
+	setcall p pos_in_cont(imps,s,sz)
+	if p=-1
+		call addtocont(imps,s,sz)
+	endif
+endfunction
+
+function changedir(ss s)
+	if s#!=0 #it's extern chdir error
+		sd d
+		setcall d chdir(s)
+		if d!=0
+			Call erExit("chdir error")
+		endif
+	endif
+endfunction
+function incrementdir(ss s,sd sz)
+	call nullend(s,sz);inc sz
+	sv cwd%cwd_p
+	call addtocont_rev(cwd,s,sz)
+	call changedir(s)
+endfunction
+function decrementdir()
+	sv cwd%cwd_p
+	sd mem=:
+	add mem cwd
+	set mem mem#v^
+	add mem cwd#
+	#sd cwd%cwd_p;sd mem=dword;add mem cwd;set mem mem#v^;add mem cwd#
+	sub mem (dword)
+	#
+	sd sz=dword
+	add sz mem#
+	#
+	sub mem sz
+	sub mem mem#
+	call changedir(mem)
+	neg sz
+	call ralloc(cwd,sz)
+endfunction
+
+function printlink(sd file)
+	ss back
+	set back file
+	addcall back strlen(file)
+	vstr ers="printlink problems with log file name extension."
+	while back!=file
+		dec back
+		if back#=(asciiperiod)
+			while back!=file
+				dec back
+				if back#=(asciiperiod)
+					inc back
+					if back#!=(NULL)
+						set back# (asciio)
+						inc back
+						set back# (NULL)
+						sv st^stdout
+						sd len
+						setCall len fprintf(st#," ")
+						if len=1
+							setCall len fprintf(st#,file)
+							sub back file
+							if len=back
+								ret
+							endif
+						endif
+						call erExit("fprintf error.")
+					endif
+					call erExit(ers)
+				endif
+			endwhile
+		endif
+	endwhile
+	call erExit(ers)
+endfunction
--- ocompiler-1.orig/ounused/loop.s
+++ /dev/null
@@ -1,191 +0,0 @@
-
-const NULL=0
-#const void=0
-const asciiperiod=0x2E
-const asciio=0x6F
-
-include "../src/files/headers/log.h"
-
-include "inits.s"
-include "files.s"
-include "const.s"
-include "uconst.s"
-
-function log_file(ss file)
-	sd f
-	setcall f fopen(file,"r")
-	if f!=(NULL)
-		sv fp%logf_p
-		set fp# f
-		sv p%logf_mem_p
-		sd sz=0
-		sd link=TRUE
-		while sz!=-1
-			sd bsz
-			setcall sz getline(p,#bsz,f)
-			if sz!=-1
-				#knowing line\r\n from ocompiler
-				sub sz 2
-				call log_line(p#,sz,#link)
-			else
-				sd e
-				setcall e feof(f)
-				if e=0
-					call erExit("get line error")
-				endif
-			endelse
-		endwhile
-		call uconst_miniresolve()
-		call logclose()
-		if link=(TRUE)
-			call printlink(file)
-		endif
-		ret
-	endif
-	call erExit("fopen error")
-endfunction
-
-function log_line(ss s,sd sz,sd plink)
-#i all, f all; at end every f not i, failure. constants are with all includes two types of children declared/already and at every log unused/still unused
-	sd type
-	set type s#
-	inc s;dec sz
-	sd skip
-	if plink#=(TRUE)
-		if type=(log_offset)
-			setcall skip skip_test()
-			if skip=(FALSE)
-				call constant_add(s,sz) #same as with const, except it has a dot
-			endif
-			ret
-		elseif type=(log_declare)
-			setcall skip skip_test() #skip same included file
-			if skip=(FALSE)
-				call constant_add(s,sz)
-			endif
-			ret
-		elseif type=(log_import)
-			setcall skip skip_test()
-			if skip=(FALSE)
-				call import_add(s,sz)
-			endif
-			ret
-		elseif type=(log_constant)
-			call uconst_add(s,sz)
-			ret
-		elseif type=(log_function)
-			sv fns%fn_mem_p
-			call addtocont(fns,s,sz)
-			ret
-		elseif type=(log_variable)
-			call uconst_add(s,sz)
-			ret
-		endelseif
-	endif
-	if type=(log_pathname)
-		call filesplus()
-		setcall skip skip_test()
-		if skip=(FALSE)
-			call fileentry(s,sz)
-		endif
-	elseif type=(log_pathfolder)
-		setcall skip skip_test()
-		if skip=(FALSE)
-			call incrementdir(s,sz)
-		endif
-	elseif type=(log_fileend)
-		setcall skip filesminus()
-		if skip<=0
-			call decrementdir()
-			if skip<0
-				call decrementfiles()
-			endif
-		endif
-	elseif type=(log_fileend_old)
-		setcall skip filesminus()
-		if skip<0
-			call decrementfiles()
-		endif
-	elseif type=(log_reusable)
-		set plink# (FALSE)
-	endelseif
-endfunction
-
-function import_add(sd s,sd sz)
-	sv imps%imp_mem_p
-	sd p
-	setcall p pos_in_cont(imps,s,sz)
-	if p=-1
-		call addtocont(imps,s,sz)
-	endif
-endfunction
-
-function changedir(ss s)
-	if s#!=0 #it's extern chdir error
-		sd d
-		setcall d chdir(s)
-		if d!=0
-			Call erExit("chdir error")
-		endif
-	endif
-endfunction
-function incrementdir(ss s,sd sz)
-	call nullend(s,sz);inc sz
-	sv cwd%cwd_p
-	call addtocont_rev(cwd,s,sz)
-	call changedir(s)
-endfunction
-function decrementdir()
-	sv cwd%cwd_p
-	sd mem=:
-	add mem cwd
-	set mem mem#v^
-	add mem cwd#
-	#sd cwd%cwd_p;sd mem=dword;add mem cwd;set mem mem#v^;add mem cwd#
-	sub mem (dword)
-	#
-	sd sz=dword
-	add sz mem#
-	#
-	sub mem sz
-	sub mem mem#
-	call changedir(mem)
-	neg sz
-	call ralloc(cwd,sz)
-endfunction
-
-function printlink(sd file)
-	ss back
-	set back file
-	addcall back strlen(file)
-	vstr ers="printlink problems with log file name extension."
-	while back!=file
-		dec back
-		if back#=(asciiperiod)
-			while back!=file
-				dec back
-				if back#=(asciiperiod)
-					inc back
-					if back#!=(NULL)
-						set back# (asciio)
-						inc back
-						set back# (NULL)
-						sv st^stdout
-						sd len
-						setCall len fprintf(st#," ")
-						if len=1
-							setCall len fprintf(st#,file)
-							sub back file
-							if len=back
-								ret
-							endif
-						endif
-						call erExit("fprintf error.")
-					endif
-					call erExit(ers)
-				endif
-			endwhile
-		endif
-	endwhile
-	call erExit(ers)
-endfunction
--- /dev/null
+++ ocompiler-1/ounused/mem.oc
@@ -0,0 +1,58 @@
+
+const dword=4
+
+function alloc(sd p)
+	sd er
+	setcall er alloc_throwless(p)
+	if er=(NULL)
+		ret
+	endif
+	call erExit(er)
+endfunction
+
+function ralloc(sv p,sd sz)
+	sd er
+	setcall er ralloc_throwless(p,sz)
+	if er=(NULL)
+		ret
+	endif
+	call erExit(er)
+endfunction
+
+function addtocont(sv cont,ss s,sd sz)
+	#knowing ocompiler maxvaluecheck
+	sd size=dword
+	add size sz
+	call ralloc(cont,size)
+	sd mem
+	set mem cont#
+	add cont :
+	add mem cont#d^
+	sub mem sz
+	call memcpy(mem,s,sz)
+	sub mem (dword)
+	set mem# sz
+	#sd oldsize;set oldsize cont#d^;sd size=dword;add size sz;call ralloc(cont,size);add cont (dword);add oldsize cont#;set oldsize# sz;add oldsize (dword);call memcpy(oldsize,s,sz)
+endfunction
+function addtocont_rev(sv cont,ss s,sd sz)
+	sd size=dword
+	add size sz
+	call ralloc(cont,size)
+	sd mem
+	set mem cont#
+	add cont :
+	add mem cont#d^
+	sub mem (dword)
+	set mem# sz
+	sub mem sz
+	call memcpy(mem,s,sz)
+	#sd oldsize;set oldsize cont#d^;sd size=dword;add size sz;call ralloc(cont,size);add cont (dword);add oldsize cont#;call memcpy(oldsize,s,sz);add oldsize sz;set oldsize# sz
+endfunction
+function adddwordtocont(sv cont,sd the_dword)
+	call ralloc(cont,(dword))
+	sd pos=-dword
+	add pos cont#
+	add cont :
+	add pos cont#d^
+	set pos# the_dword
+endfunction
--- ocompiler-1.orig/ounused/mem.s
+++ /dev/null
@@ -1,58 +0,0 @@
-
-const dword=4
-
-function alloc(sd p)
-	sd er
-	setcall er alloc_throwless(p)
-	if er=(NULL)
-		ret
-	endif
-	call erExit(er)
-endfunction
-
-function ralloc(sv p,sd sz)
-	sd er
-	setcall er ralloc_throwless(p,sz)
-	if er=(NULL)
-		ret
-	endif
-	call erExit(er)
-endfunction
-
-function addtocont(sv cont,ss s,sd sz)
-	#knowing ocompiler maxvaluecheck
-	sd size=dword
-	add size sz
-	call ralloc(cont,size)
-	sd mem
-	set mem cont#
-	add cont :
-	add mem cont#d^
-	sub mem sz
-	call memcpy(mem,s,sz)
-	sub mem (dword)
-	set mem# sz
-	#sd oldsize;set oldsize cont#d^;sd size=dword;add size sz;call ralloc(cont,size);add cont (dword);add oldsize cont#;set oldsize# sz;add oldsize (dword);call memcpy(oldsize,s,sz)
-endfunction
-function addtocont_rev(sv cont,ss s,sd sz)
-	sd size=dword
-	add size sz
-	call ralloc(cont,size)
-	sd mem
-	set mem cont#
-	add cont :
-	add mem cont#d^
-	sub mem (dword)
-	set mem# sz
-	sub mem sz
-	call memcpy(mem,s,sz)
-	#sd oldsize;set oldsize cont#d^;sd size=dword;add size sz;call ralloc(cont,size);add cont (dword);add oldsize cont#;call memcpy(oldsize,s,sz);add oldsize sz;set oldsize# sz
-endfunction
-function adddwordtocont(sv cont,sd the_dword)
-	call ralloc(cont,(dword))
-	sd pos=-dword
-	add pos cont#
-	add cont :
-	add pos cont#d^
-	set pos# the_dword
-endfunction
--- /dev/null
+++ ocompiler-1/ounused/ounused.oc
@@ -0,0 +1,57 @@
+
+#every time this first file has timestamp greater than Makefile, Makefile is deleted
+#or make -B
+
+format elfobj
+
+include "header.h"
+
+include "./throwless.oc"
+
+function messagedelim()
+	sv st^stderr
+	Char visiblemessage={0x0a,0}
+	Call fprintf(st#,#visiblemessage)
+endfunction
+Function Message(ss text)
+	sv st^stderr
+	Call fprintf(st#,text)
+	call messagedelim()
+EndFunction
+function erMessage(ss text)
+	call Message(text)
+	aftercall er
+	set er (~0)
+	return (EXIT_FAILURE)
+endfunction
+function erExit(ss text)
+	call freeall()
+	call erMessage(text)
+endfunction
+
+include "./loop.oc"
+include "./resolve.oc"
+
+entryraw main(sd argc,ss *argv0,ss argv1)
+
+if argc>1
+	call inits()
+	call allocs()
+	call filesreset()
+	dec argc
+	sd i
+	set i argc
+	mult argc :
+	sv argv;set argv #argv1
+	add argc argv
+	while argv!=argc
+		call log_file(argv#)
+		call decrementdir()
+		incst argv
+	endwhile
+	call resolve(i)
+	call freeall()
+	return (EXIT_SUCCESS)
+endif
+
+return (EXIT_FAILURE)
--- ocompiler-1.orig/ounused/ounused.s
+++ /dev/null
@@ -1,57 +0,0 @@
-
-#every time this first file has timestamp greater than Makefile, Makefile is deleted
-#or make -B
-
-format elfobj
-
-include "header.h"
-
-include "./throwless.s"
-
-function messagedelim()
-	sv st^stderr
-	Char visiblemessage={0x0a,0}
-	Call fprintf(st#,#visiblemessage)
-endfunction
-Function Message(ss text)
-	sv st^stderr
-	Call fprintf(st#,text)
-	call messagedelim()
-EndFunction
-function erMessage(ss text)
-	call Message(text)
-	aftercall er
-	set er (~0)
-	return (EXIT_FAILURE)
-endfunction
-function erExit(ss text)
-	call freeall()
-	call erMessage(text)
-endfunction
-
-include "./loop.s"
-include "./resolve.s"
-
-entryraw main(sd argc,ss *argv0,ss argv1)
-
-if argc>1
-	call inits()
-	call allocs()
-	call filesreset()
-	dec argc
-	sd i
-	set i argc
-	mult argc :
-	sv argv;set argv #argv1
-	add argc argv
-	while argv!=argc
-		call log_file(argv#)
-		call decrementdir()
-		incst argv
-	endwhile
-	call resolve(i)
-	call freeall()
-	return (EXIT_SUCCESS)
-endif
-
-return (EXIT_FAILURE)
--- /dev/null
+++ ocompiler-1/ounused/resolve.oc
@@ -0,0 +1,53 @@
+
+function resolve(sd j)
+	sv cont%fn_mem_p
+	sd p
+	sd mem
+	set p cont#
+	add cont :
+	set mem cont#d^
+	add mem p
+	#set mem cont#d^;add cont (dword);set p cont#;add mem p
+	sv imps%imp_mem_p
+	sd i=0
+	vstr f="function"
+	while p!=mem
+		sd len
+		set len p#
+		add p (dword)
+		sd pos
+		setcall pos pos_in_cont(imps,p,len)
+		if pos=-1
+			call wrongExit(f,p,len)
+		endif
+		add p len
+		inc i
+	endwhile
+	vstr c="constant"
+	vstr v="variable"
+	call uconst_resolve(c,v)
+	sd k
+	setcall k uconst_resolved(2)
+	#
+	sv st^stderr
+	sd fls
+	setcall fls filessize()
+	div fls :
+	sd imps_sz
+	setcall imps_sz importssize()
+	sd const_sz
+	setcall const_sz constssize()
+	Call fprintf(st#,"%u logs, %u files, %u unique imports, %u %s/%s, %u %s resolved, %u %s/%s resolved.",j,fls,imps_sz,const_sz,c,v,i,f,k,c,v)
+	call messagedelim()
+
+	sv so^stdout
+	call fflush(so#) #there is no line end at stdout, then flush is required
+endfunction
+
+function wrongExit(ss x,ss n,sd len)
+	sv st^stderr
+	set st st#
+	Call fprintf(st,"Unused %s: ",x)
+	call fwrite(n,len,1,st)
+	call erExit("")
+endfunction
--- ocompiler-1.orig/ounused/resolve.s
+++ /dev/null
@@ -1,53 +0,0 @@
-
-function resolve(sd j)
-	sv cont%fn_mem_p
-	sd p
-	sd mem
-	set p cont#
-	add cont :
-	set mem cont#d^
-	add mem p
-	#set mem cont#d^;add cont (dword);set p cont#;add mem p
-	sv imps%imp_mem_p
-	sd i=0
-	vstr f="function"
-	while p!=mem
-		sd len
-		set len p#
-		add p (dword)
-		sd pos
-		setcall pos pos_in_cont(imps,p,len)
-		if pos=-1
-			call wrongExit(f,p,len)
-		endif
-		add p len
-		inc i
-	endwhile
-	vstr c="constant"
-	vstr v="variable"
-	call uconst_resolve(c,v)
-	sd k
-	setcall k uconst_resolved(2)
-	#
-	sv st^stderr
-	sd fls
-	setcall fls filessize()
-	div fls :
-	sd imps_sz
-	setcall imps_sz importssize()
-	sd const_sz
-	setcall const_sz constssize()
-	Call fprintf(st#,"%u logs, %u files, %u unique imports, %u %s/%s, %u %s resolved, %u %s/%s resolved.",j,fls,imps_sz,const_sz,c,v,i,f,k,c,v)
-	call messagedelim()
-
-	sv so^stdout
-	call fflush(so#) #there is no line end at stdout, then flush is required
-endfunction
-
-function wrongExit(ss x,ss n,sd len)
-	sv st^stderr
-	set st st#
-	Call fprintf(st,"Unused %s: ",x)
-	call fwrite(n,len,1,st)
-	call erExit("")
-endfunction
--- /dev/null
+++ ocompiler-1/ounused/skip.oc
@@ -0,0 +1,48 @@
+
+function filesreset()
+	data f#1
+	const files_nr_p^f
+	set f 0
+	call skip_reset()
+endfunction
+function skip_reset()
+	data s#1
+	const skip_nr_p^s
+	set s 0x7fFFffFF #files pointer array not reaching here
+endfunction
+
+function filesplus()
+	sd f%files_nr_p
+	inc f#
+endfunction
+
+#cmp
+function filesminus()
+	sd f%files_nr_p
+	sd s%skip_nr_p
+	sd nr
+	set nr f#
+	dec f#
+	if nr=s#
+		call skip_reset()
+		return 0
+	elseif nr<s#
+		return -1
+	endelseif
+	return 1
+endfunction
+
+function skip_test()
+	sd s%skip_nr_p
+	sd f%files_nr_p
+	if f#>=s#
+		return (TRUE)
+	endif
+	return (FALSE)
+endfunction
+
+function skip_set()
+	sd s%skip_nr_p
+	sd f%files_nr_p
+	set s# f#
+endfunction
--- ocompiler-1.orig/ounused/skip.s
+++ /dev/null
@@ -1,48 +0,0 @@
-
-function filesreset()
-	data f#1
-	const files_nr_p^f
-	set f 0
-	call skip_reset()
-endfunction
-function skip_reset()
-	data s#1
-	const skip_nr_p^s
-	set s 0x7fFFffFF #files pointer array not reaching here
-endfunction
-
-function filesplus()
-	sd f%files_nr_p
-	inc f#
-endfunction
-
-#cmp
-function filesminus()
-	sd f%files_nr_p
-	sd s%skip_nr_p
-	sd nr
-	set nr f#
-	dec f#
-	if nr=s#
-		call skip_reset()
-		return 0
-	elseif nr<s#
-		return -1
-	endelseif
-	return 1
-endfunction
-
-function skip_test()
-	sd s%skip_nr_p
-	sd f%files_nr_p
-	if f#>=s#
-		return (TRUE)
-	endif
-	return (FALSE)
-endfunction
-
-function skip_set()
-	sd s%skip_nr_p
-	sd f%files_nr_p
-	set s# f#
-endfunction
--- /dev/null
+++ ocompiler-1/ounused/throwless.oc
@@ -0,0 +1,298 @@
+
+#mem
+
+function malloc_throwless(sv p,sd sz)
+	setcall p# malloc(sz)
+	if p#!=(NULL)
+		return (NULL)
+	endif
+	return "malloc error"
+endfunction
+function alloc_throwless(sd p)
+	sd er
+	setcall er malloc_throwless(p,0)
+	if er=(NULL)
+		add p :
+		set p# 0
+		return (NULL)
+	endif
+	return er
+	#set p# 0;add p (dword);sd er;setcall er malloc_throwless(p,0);return er
+endfunction
+#function ralloc_throwless(sd p,sd sz);add sz p#;if sz>0;sv cursor=dword;add cursor p;setcall cursor# realloc(cursor#,sz);if cursor#!=(NULL);set p# sz
+function ralloc_throwless(sv p,sd sz)
+	sd cursor=:
+	add cursor p
+	add sz cursor#
+	if sz>0
+		setcall p# realloc(p#,sz)
+		if p#!=(NULL)
+			set cursor# sz
+			return (NULL)
+		endif
+		return "realloc error"
+	elseif sz=0  #equal 0 discovered at decrementfiles, since C23 the behaviour is undefined
+	#using this quirk, lvs[0] will be used at constants at end, when size is 0
+		#set p# 0
+		set cursor# 0
+		return (NULL)
+	endelseif
+	return "realloc must stay in 31 bits"
+endfunction
+
+#-1/offset
+function pos_in_cont(sv cont,ss s,sd sz)
+	sd p
+	sd mem=:
+	set p cont#
+	add mem cont
+	set mem mem#
+	add mem p
+	#set mem cont#d^;add cont (dword);set p cont#;add mem p
+	while p!=mem
+		sd len
+		set len p#
+		add p (dword)
+		if len=sz
+			sd c
+			setcall c memcmp(s,p,sz)
+			if c=0
+				sub p cont#
+				sub p (dword)
+				return p
+			endif
+		endif
+		add p len
+	endwhile
+	return -1
+endfunction
+
+#inits
+
+function inits()
+	value logf#1
+	const logf_p^logf
+	set logf (NULL)
+	value logf_mem#1
+	const logf_mem_p^logf_mem
+	set logf_mem (NULL)
+	value imp_mem#1;data *#1
+	const imp_mem_p^imp_mem
+	set imp_mem (NULL)
+	value fn_mem#1;data *#1
+	const fn_mem_p^fn_mem
+	set fn_mem (NULL)
+	value cwd#1;data *#1
+	const cwd_p^cwd
+	set cwd (NULL)
+	value files#1;data files_d#1
+	const files_p^files
+	const files_dp^files_d
+	set files (NULL)
+	value levels#1;data levels_d#1
+	const levels_p^levels
+	const levels_dp^levels_d
+	set levels (NULL)
+	call uconst_resolved(0)
+endfunction
+
+function uconst_resolved(sd t,sd size)
+	data nr#1
+	if t=0
+		set nr 0
+	elseif t=1
+		div size (dword)
+		add nr size
+	else
+		return nr
+	endelse
+endfunction
+
+function freeall()
+	sv ip%imp_mem_p
+	if ip#!=(NULL)
+		call free(ip#)
+		sv fp%fn_mem_p
+		if fp#!=(NULL)
+			call free(fp#)
+			sv cwd%cwd_p
+			if cwd#!=(NULL)
+				call free(cwd#)
+				sv fls%files_p
+				if fls#!=(NULL)
+					call freefiles()
+					sv lvs%levels_p
+					if lvs#!=(NULL)
+						call free(lvs#)
+						call logclose()
+					endif
+				endif
+			endif
+		endif
+	endif
+endfunction
+
+function logclose()
+	sv fp%logf_p
+	if fp#!=(NULL)
+		call fclose(fp#)
+		set fp# (NULL)
+		sv p%logf_mem_p
+		if p#!=(NULL)
+			call free(p#)
+			set p# (NULL)
+		endif
+	endif
+endfunction
+
+#files
+
+function freefiles()
+	#sv container%files_p;sv cursor;set cursor container#d^;add container (dword);set container container#;add cursor container;while container!=cursor;decst cursor;sv consts=dword;add consts cursor#;call free(consts#);call free(cursor#);endwhile;call free(cursor)
+	sv container%files_p
+	sv start
+	set start container#
+	add container :
+	set container container#d^
+	add container start
+	while start!=container
+		decst container
+		call fileentry_uninit(container#)
+		call free(container#)
+	endwhile
+	call free(container)
+endfunction
+function fileentry_uninit(sd cont)
+	sd b;set b cont;add b (size_conts)
+	call fileentry_uninit_base(cont,b)
+endfunction
+function fileentry_uninit_base(sd cont,sv cursor)
+	while cont!=cursor
+		sub cursor (size_cont)
+		call free(cursor#)
+	endwhile
+endfunction
+
+#er
+function fileentry_init(sd cont)
+	sd a;set a cont
+	sd b;set b cont;add b (size_conts)
+	while cont!=b
+		sd er
+		setcall er alloc_throwless(cont)
+		if er!=(NULL)
+			call fileentry_uninit_base(a,cont)
+			return er
+		endif
+		add cont (size_cont)
+	endwhile
+	return (NULL)
+endfunction
+
+#cmp
+function fileentry_compare(sd existent,sd new,sd sz)
+	add existent (size_conts)
+	if existent#!=sz
+		return (~0)
+	endif
+	add existent (dword)
+	sd c
+	setcall c memcmp(existent,new,sz)
+	return c
+endfunction
+
+include "skip.oc"
+
+#const
+
+#cont
+function working_file()
+	sv lvs%levels_p
+	sd lvsd%levels_dp
+	sv p=-dword
+	add p lvsd#
+	add p lvs#
+	set p p#d^
+	sv fls%files_p
+	add p fls#
+	#sv lvs%levels_p;sv p=-dword;add p lvs#d^;add lvs (dword);add p lvs#;set p p#d^;sv fls%files_vp;add p fls#
+	return p#
+endfunction
+
+#sz
+function filessize()
+	sd fls%files_dp
+	return fls#
+	#sd fls%files_p;set fls fls#;return fls
+endfunction
+
+#sz
+function constssize()
+	sv end%files_p
+	sv cursor
+	set cursor end#
+	add end :
+	set end end#d^
+	add end cursor
+	#sv cursor%files_p;sd end;set end cursor#d^;add cursor (dword);set cursor cursor#;add end cursor
+	sd sz=0
+	while cursor!=end
+		addcall sz constssize_file(cursor#)
+		incst cursor
+	endwhile
+	return sz
+endfunction
+#sz
+#function constssize_file(sd cursor);sd end;set end cursor#;add cursor (dword);set cursor cursor#v^;add end cursor
+function constssize_file(sv end)
+	sd cursor
+	set cursor end#
+	add end :
+	set end end#d^
+	add end cursor
+	sd sz=0
+	while cursor!=end
+		add cursor cursor#
+		add cursor (dword)
+		inc sz
+	endwhile
+	return sz
+endfunction
+
+#uconst
+
+function root_file()
+	sd lvs%levels_p
+	set lvs lvs#v^
+	set lvs lvs#
+	sv fls%files_p
+	set fls fls#
+	add fls lvs
+	return fls#
+endfunction
+
+#loop
+
+function nullend(ss s,sd sz)
+	add s sz;set s# 0 #this is on carriage return
+endfunction
+
+#resolve
+
+function importssize()
+	sv cont%imp_mem_p
+	sd p
+	sd mem
+	set p cont#
+	add cont :
+	set mem cont#d^
+	add mem p
+	#set mem cont#d^;add cont (dword);set p cont#;add mem p
+	sd i=0
+	while p!=mem
+		add p p#
+		add p (dword)
+		inc i
+	endwhile
+	return i
+endfunction
--- ocompiler-1.orig/ounused/throwless.s
+++ /dev/null
@@ -1,298 +0,0 @@
-
-#mem
-
-function malloc_throwless(sv p,sd sz)
-	setcall p# malloc(sz)
-	if p#!=(NULL)
-		return (NULL)
-	endif
-	return "malloc error"
-endfunction
-function alloc_throwless(sd p)
-	sd er
-	setcall er malloc_throwless(p,0)
-	if er=(NULL)
-		add p :
-		set p# 0
-		return (NULL)
-	endif
-	return er
-	#set p# 0;add p (dword);sd er;setcall er malloc_throwless(p,0);return er
-endfunction
-#function ralloc_throwless(sd p,sd sz);add sz p#;if sz>0;sv cursor=dword;add cursor p;setcall cursor# realloc(cursor#,sz);if cursor#!=(NULL);set p# sz
-function ralloc_throwless(sv p,sd sz)
-	sd cursor=:
-	add cursor p
-	add sz cursor#
-	if sz>0
-		setcall p# realloc(p#,sz)
-		if p#!=(NULL)
-			set cursor# sz
-			return (NULL)
-		endif
-		return "realloc error"
-	elseif sz=0  #equal 0 discovered at decrementfiles, since C23 the behaviour is undefined
-	#using this quirk, lvs[0] will be used at constants at end, when size is 0
-		#set p# 0
-		set cursor# 0
-		return (NULL)
-	endelseif
-	return "realloc must stay in 31 bits"
-endfunction
-
-#-1/offset
-function pos_in_cont(sv cont,ss s,sd sz)
-	sd p
-	sd mem=:
-	set p cont#
-	add mem cont
-	set mem mem#
-	add mem p
-	#set mem cont#d^;add cont (dword);set p cont#;add mem p
-	while p!=mem
-		sd len
-		set len p#
-		add p (dword)
-		if len=sz
-			sd c
-			setcall c memcmp(s,p,sz)
-			if c=0
-				sub p cont#
-				sub p (dword)
-				return p
-			endif
-		endif
-		add p len
-	endwhile
-	return -1
-endfunction
-
-#inits
-
-function inits()
-	value logf#1
-	const logf_p^logf
-	set logf (NULL)
-	value logf_mem#1
-	const logf_mem_p^logf_mem
-	set logf_mem (NULL)
-	value imp_mem#1;data *#1
-	const imp_mem_p^imp_mem
-	set imp_mem (NULL)
-	value fn_mem#1;data *#1
-	const fn_mem_p^fn_mem
-	set fn_mem (NULL)
-	value cwd#1;data *#1
-	const cwd_p^cwd
-	set cwd (NULL)
-	value files#1;data files_d#1
-	const files_p^files
-	const files_dp^files_d
-	set files (NULL)
-	value levels#1;data levels_d#1
-	const levels_p^levels
-	const levels_dp^levels_d
-	set levels (NULL)
-	call uconst_resolved(0)
-endfunction
-
-function uconst_resolved(sd t,sd size)
-	data nr#1
-	if t=0
-		set nr 0
-	elseif t=1
-		div size (dword)
-		add nr size
-	else
-		return nr
-	endelse
-endfunction
-
-function freeall()
-	sv ip%imp_mem_p
-	if ip#!=(NULL)
-		call free(ip#)
-		sv fp%fn_mem_p
-		if fp#!=(NULL)
-			call free(fp#)
-			sv cwd%cwd_p
-			if cwd#!=(NULL)
-				call free(cwd#)
-				sv fls%files_p
-				if fls#!=(NULL)
-					call freefiles()
-					sv lvs%levels_p
-					if lvs#!=(NULL)
-						call free(lvs#)
-						call logclose()
-					endif
-				endif
-			endif
-		endif
-	endif
-endfunction
-
-function logclose()
-	sv fp%logf_p
-	if fp#!=(NULL)
-		call fclose(fp#)
-		set fp# (NULL)
-		sv p%logf_mem_p
-		if p#!=(NULL)
-			call free(p#)
-			set p# (NULL)
-		endif
-	endif
-endfunction
-
-#files
-
-function freefiles()
-	#sv container%files_p;sv cursor;set cursor container#d^;add container (dword);set container container#;add cursor container;while container!=cursor;decst cursor;sv consts=dword;add consts cursor#;call free(consts#);call free(cursor#);endwhile;call free(cursor)
-	sv container%files_p
-	sv start
-	set start container#
-	add container :
-	set container container#d^
-	add container start
-	while start!=container
-		decst container
-		call fileentry_uninit(container#)
-		call free(container#)
-	endwhile
-	call free(container)
-endfunction
-function fileentry_uninit(sd cont)
-	sd b;set b cont;add b (size_conts)
-	call fileentry_uninit_base(cont,b)
-endfunction
-function fileentry_uninit_base(sd cont,sv cursor)
-	while cont!=cursor
-		sub cursor (size_cont)
-		call free(cursor#)
-	endwhile
-endfunction
-
-#er
-function fileentry_init(sd cont)
-	sd a;set a cont
-	sd b;set b cont;add b (size_conts)
-	while cont!=b
-		sd er
-		setcall er alloc_throwless(cont)
-		if er!=(NULL)
-			call fileentry_uninit_base(a,cont)
-			return er
-		endif
-		add cont (size_cont)
-	endwhile
-	return (NULL)
-endfunction
-
-#cmp
-function fileentry_compare(sd existent,sd new,sd sz)
-	add existent (size_conts)
-	if existent#!=sz
-		return (~0)
-	endif
-	add existent (dword)
-	sd c
-	setcall c memcmp(existent,new,sz)
-	return c
-endfunction
-
-include "skip.s"
-
-#const
-
-#cont
-function working_file()
-	sv lvs%levels_p
-	sd lvsd%levels_dp
-	sv p=-dword
-	add p lvsd#
-	add p lvs#
-	set p p#d^
-	sv fls%files_p
-	add p fls#
-	#sv lvs%levels_p;sv p=-dword;add p lvs#d^;add lvs (dword);add p lvs#;set p p#d^;sv fls%files_vp;add p fls#
-	return p#
-endfunction
-
-#sz
-function filessize()
-	sd fls%files_dp
-	return fls#
-	#sd fls%files_p;set fls fls#;return fls
-endfunction
-
-#sz
-function constssize()
-	sv end%files_p
-	sv cursor
-	set cursor end#
-	add end :
-	set end end#d^
-	add end cursor
-	#sv cursor%files_p;sd end;set end cursor#d^;add cursor (dword);set cursor cursor#;add end cursor
-	sd sz=0
-	while cursor!=end
-		addcall sz constssize_file(cursor#)
-		incst cursor
-	endwhile
-	return sz
-endfunction
-#sz
-#function constssize_file(sd cursor);sd end;set end cursor#;add cursor (dword);set cursor cursor#v^;add end cursor
-function constssize_file(sv end)
-	sd cursor
-	set cursor end#
-	add end :
-	set end end#d^
-	add end cursor
-	sd sz=0
-	while cursor!=end
-		add cursor cursor#
-		add cursor (dword)
-		inc sz
-	endwhile
-	return sz
-endfunction
-
-#uconst
-
-function root_file()
-	sd lvs%levels_p
-	set lvs lvs#v^
-	set lvs lvs#
-	sv fls%files_p
-	set fls fls#
-	add fls lvs
-	return fls#
-endfunction
-
-#loop
-
-function nullend(ss s,sd sz)
-	add s sz;set s# 0 #this is on carriage return
-endfunction
-
-#resolve
-
-function importssize()
-	sv cont%imp_mem_p
-	sd p
-	sd mem
-	set p cont#
-	add cont :
-	set mem cont#d^
-	add mem p
-	#set mem cont#d^;add cont (dword);set p cont#;add mem p
-	sd i=0
-	while p!=mem
-		add p p#
-		add p (dword)
-		inc i
-	endwhile
-	return i
-endfunction
--- /dev/null
+++ ocompiler-1/ounused/uconst.oc
@@ -0,0 +1,100 @@
+
+include "uconstres.oc"
+
+function uconst_add(sd s,sd sz)
+	sd f
+	setcall f root_file()
+	call uconst_spin(f,s,sz,(TRUE))
+endfunction
+
+#b
+function uconst_spin(sd f,sd s,sd sz,sd is_new)
+	sd const_cont
+	set const_cont f
+	sd found
+	#search in includes declared in other logs
+	add f (size_cont)
+	setcall found uconst_search(f,s,sz,(FALSE))
+	if found=(FALSE)
+		#search in includes declared this log
+		add f (size_cont)
+		setcall found uconst_search(f,s,sz,is_new)
+		if found=(FALSE)
+			#search in constants declared in this file, with respect to is_new
+			sd ofs
+			setcall ofs pos_in_cont(const_cont,s,sz)
+			if ofs!=-1
+				add f (size_cont)
+				if is_new=(FALSE)
+					#if is in unused move it to doubleunused
+					call uconst_unused(f,ofs)
+				else
+					call adddwordtocont(f,ofs)
+				endelse
+				return (TRUE)
+			endif
+		endif
+	endif
+	return (FALSE)
+endfunction
+
+#b
+function uconst_search(sv fs,sd s,sd sz,sd is_new)
+	sd cursor
+	set cursor fs#
+	add fs :
+	set fs fs#d^
+	add fs cursor
+	sv fls%files_p
+	set fls fls#
+	while cursor!=fs
+		sv pointer;set pointer fls
+		add pointer cursor#
+		sd found
+		setcall found uconst_spin(pointer#,s,sz,is_new)
+		if found=(TRUE)
+			return (TRUE)
+		endif
+		add cursor (dword)
+	endwhile
+	return (FALSE)
+endfunction
+
+function uconst_unused(sv cont,sd ofs)
+	sd uns
+	set uns cont
+	sd cursor
+	set cursor cont#
+	add cont :
+	sd end
+	set end cont#d^
+	add end cursor
+	add cont (dword)
+	while cursor!=end
+		sd offset
+		set offset cursor#
+
+		#if offset<=ofs
+		#this is not ordered since mixing const and variables
+
+		if offset=ofs
+			#move to doubleunused
+			call adddwordtocont(cont,offset)
+			sub end (dword)
+			sd pointer;set pointer cursor
+			while cursor!=end
+				add cursor (dword)
+				set pointer# cursor#
+				add pointer (dword)
+			endwhile
+			call ralloc(uns,(-dword))
+			ret
+		endif
+		add cursor (dword)
+
+		#else
+		#	ret
+		#endelse
+
+	endwhile
+endfunction
--- ocompiler-1.orig/ounused/uconst.s
+++ /dev/null
@@ -1,100 +0,0 @@
-
-include "uconstres.s"
-
-function uconst_add(sd s,sd sz)
-	sd f
-	setcall f root_file()
-	call uconst_spin(f,s,sz,(TRUE))
-endfunction
-
-#b
-function uconst_spin(sd f,sd s,sd sz,sd is_new)
-	sd const_cont
-	set const_cont f
-	sd found
-	#search in includes declared in other logs
-	add f (size_cont)
-	setcall found uconst_search(f,s,sz,(FALSE))
-	if found=(FALSE)
-		#search in includes declared this log
-		add f (size_cont)
-		setcall found uconst_search(f,s,sz,is_new)
-		if found=(FALSE)
-			#search in constants declared in this file, with respect to is_new
-			sd ofs
-			setcall ofs pos_in_cont(const_cont,s,sz)
-			if ofs!=-1
-				add f (size_cont)
-				if is_new=(FALSE)
-					#if is in unused move it to doubleunused
-					call uconst_unused(f,ofs)
-				else
-					call adddwordtocont(f,ofs)
-				endelse
-				return (TRUE)
-			endif
-		endif
-	endif
-	return (FALSE)
-endfunction
-
-#b
-function uconst_search(sv fs,sd s,sd sz,sd is_new)
-	sd cursor
-	set cursor fs#
-	add fs :
-	set fs fs#d^
-	add fs cursor
-	sv fls%files_p
-	set fls fls#
-	while cursor!=fs
-		sv pointer;set pointer fls
-		add pointer cursor#
-		sd found
-		setcall found uconst_spin(pointer#,s,sz,is_new)
-		if found=(TRUE)
-			return (TRUE)
-		endif
-		add cursor (dword)
-	endwhile
-	return (FALSE)
-endfunction
-
-function uconst_unused(sv cont,sd ofs)
-	sd uns
-	set uns cont
-	sd cursor
-	set cursor cont#
-	add cont :
-	sd end
-	set end cont#d^
-	add end cursor
-	add cont (dword)
-	while cursor!=end
-		sd offset
-		set offset cursor#
-
-		#if offset<=ofs
-		#this is not ordered since mixing const and variables
-
-		if offset=ofs
-			#move to doubleunused
-			call adddwordtocont(cont,offset)
-			sub end (dword)
-			sd pointer;set pointer cursor
-			while cursor!=end
-				add cursor (dword)
-				set pointer# cursor#
-				add pointer (dword)
-			endwhile
-			call ralloc(uns,(-dword))
-			ret
-		endif
-		add cursor (dword)
-
-		#else
-		#	ret
-		#endelse
-
-	endwhile
-endfunction
--- /dev/null
+++ ocompiler-1/ounused/uconstres.oc
@@ -0,0 +1,89 @@
+
+function uconst_miniresolve()
+	sd f
+	setcall f root_file()
+	#spin through old declared
+	call uconstres_spin(f,(TRUE))
+endfunction
+
+function uconstres_spin(sd f,sd is_new)
+	sd cont
+	set cont f
+	add f (size_cont)
+	call uconstres_search(f,(FALSE))
+	add f (size_cont)
+	call uconstres_search(f,is_new)
+	#
+	if is_new=(FALSE)
+		#resolve doubleunuseds
+		add f (size_cont)
+		sd double
+		set double f
+		add double (size_cont+:)
+		if double#!=0
+			sub double :
+			value aux#1;data *#1
+			call memcpy(#aux,f,(size_cont))
+			call memcpy(f,double,(size_cont))
+			call memcpy(double,#aux,(size_cont))
+			set f double
+		endif
+		add f :
+		sd size
+		set size f#
+		if size!=0
+			sub f :
+			call uconst_resolved(1,size)
+			neg size
+			call ralloc(f,size)
+		endif
+	endif
+endfunction
+
+function uconstres_search(sv f,sd is_new)
+#there is a segmentation if from a random (not log) file like "format elfobjso", TO DO when wanted
+	sd cursor
+	set cursor f#
+	add f :
+	set f f#d^
+	add f cursor
+	sv fls%files_p
+	set fls fls#
+	while cursor!=f
+		sv pointer;set pointer fls
+		add pointer cursor#
+		call uconstres_spin(pointer#,is_new)
+		add cursor (dword)
+	endwhile
+endfunction
+
+function uconst_resolve(ss const_str,ss var_str)
+	sv fls%files_p
+	sv cursor
+	set cursor fls#
+	add fls :
+	set fls fls#d^
+	add fls cursor
+	while cursor!=fls
+		sd pointer=3*size_cont+:
+		add pointer cursor#
+		if pointer#!=0
+			sub pointer :
+			set pointer pointer#v^
+			set cursor cursor#
+			set cursor cursor#
+			add cursor pointer#
+			sd offset
+			set offset cursor#d^
+			add cursor (dword)
+
+			sd is_var;setcall is_var memchr(cursor,(asciiperiod),offset)
+			if is_var!=(NULL)
+				call wrongExit(var_str,cursor,offset)
+			else
+				call wrongExit(const_str,cursor,offset)
+			endelse
+		endif
+		add cursor :
+	endwhile
+endfunction
--- ocompiler-1.orig/ounused/uconstres.s
+++ /dev/null
@@ -1,89 +0,0 @@
-
-function uconst_miniresolve()
-	sd f
-	setcall f root_file()
-	#spin through old declared
-	call uconstres_spin(f,(TRUE))
-endfunction
-
-function uconstres_spin(sd f,sd is_new)
-	sd cont
-	set cont f
-	add f (size_cont)
-	call uconstres_search(f,(FALSE))
-	add f (size_cont)
-	call uconstres_search(f,is_new)
-	#
-	if is_new=(FALSE)
-		#resolve doubleunuseds
-		add f (size_cont)
-		sd double
-		set double f
-		add double (size_cont+:)
-		if double#!=0
-			sub double :
-			value aux#1;data *#1
-			call memcpy(#aux,f,(size_cont))
-			call memcpy(f,double,(size_cont))
-			call memcpy(double,#aux,(size_cont))
-			set f double
-		endif
-		add f :
-		sd size
-		set size f#
-		if size!=0
-			sub f :
-			call uconst_resolved(1,size)
-			neg size
-			call ralloc(f,size)
-		endif
-	endif
-endfunction
-
-function uconstres_search(sv f,sd is_new)
-#there is a segmentation if from a random (not log) file like "format elfobjso", TO DO when wanted
-	sd cursor
-	set cursor f#
-	add f :
-	set f f#d^
-	add f cursor
-	sv fls%files_p
-	set fls fls#
-	while cursor!=f
-		sv pointer;set pointer fls
-		add pointer cursor#
-		call uconstres_spin(pointer#,is_new)
-		add cursor (dword)
-	endwhile
-endfunction
-
-function uconst_resolve(ss const_str,ss var_str)
-	sv fls%files_p
-	sv cursor
-	set cursor fls#
-	add fls :
-	set fls fls#d^
-	add fls cursor
-	while cursor!=fls
-		sd pointer=3*size_cont+:
-		add pointer cursor#
-		if pointer#!=0
-			sub pointer :
-			set pointer pointer#v^
-			set cursor cursor#
-			set cursor cursor#
-			add cursor pointer#
-			sd offset
-			set offset cursor#d^
-			add cursor (dword)
-
-			sd is_var;setcall is_var memchr(cursor,(asciiperiod),offset)
-			if is_var!=(NULL)
-				call wrongExit(var_str,cursor,offset)
-			else
-				call wrongExit(const_str,cursor,offset)
-			endelse
-		endif
-		add cursor :
-	endwhile
-endfunction
--- ocompiler-1.orig/src/Makefile
+++ ocompiler-1/src/Makefile
@@ -6,7 +6,7 @@ all: ${projname}
 OB = obj
 OBJ = ${OB}.o
 FULLOBJ = ./linux/${OB}
-FULLOBJS = ${FULLOBJ}.s
+FULLOBJS = ${FULLOBJ}.oc
 FULLOBJO = ${FULLOBJ}.o
 OBT = ${OB}.txt
 
@@ -43,12 +43,13 @@ else
 	etchelper=5
 	etc_helper=bin/o
 endif
-etcinclude=etcinclude.s
+etcinclude=etcinclude.oc
 #debian/ocompiler.install is forcing to usr/ / etc/
 
 #OFLAGS=
 
 ${FULLOBJS}: ${etcinclude}
+	echo something or is not working
 
 %.o: ${FULLOBJS}
 	if [ -s ${OBT} ];then \
@@ -86,7 +87,7 @@ clean-link:
 
 clean-test:
 	-rm -f ./linux/o
-	-rm -f ./linux/o.s.log
+	-rm -f ./linux/o.oc.log
 	-rm -f ./linux/z
 
 clean: clean-compile clean-link clean-test
@@ -98,9 +99,9 @@ uninstall:
 
 test:
 	echo "test"
-	cd linux; ../o o.s nul_res_pref 1; mv o z; ${linker} ./z o.s nul_res_pref 1; diff o z
+	cd linux; ../o o.oc nul_res_pref 1; mv o z; ${linker} ./z o.oc nul_res_pref 1; diff o z
 # linker=/home/bc/Desktop/out/libc6/lib32/ld-linux.so.2 make test
-#/home/bc/Desktop/out/libc6-i386.AppImage /home/bc/o/ocompiler-1/src/linux/z /home/bc/o/ocompiler-1/src/linux/o.s nul_res_pref 1
+#/home/bc/Desktop/out/libc6-i386.AppImage /home/bc/o/ocompiler-1/src/linux/z /home/bc/o/ocompiler-1/src/linux/o.oc nul_res_pref 1
 #2.36-0ubuntu4 (jammy) was ok, backportpackage is working for esm packages (tested)
 #DEB_BUILD_OPTIONS=nocheck debuild -us -uc
 
--- /dev/null
+++ ocompiler-1/src/files/actions.oc
@@ -0,0 +1,39 @@
+
+#inits needed on top then some allocs at openfilename then frees needing inits, then these allocs
+SetCall errormsg enumbags(true)
+#here is the start of mem worries for linux
+If errormsg!=noerr
+	Call msgerrexit(errormsg)
+EndIf
+
+Include "./actions/setdefdir.oc"
+
+Set includebool zero ##include or not include for applying after command parse
+SetCall errormsg include(safecurrentdirtopath,(TRUE),(cINCLUDE))
+If errormsg!=noerr
+	Call msgerrexit(errormsg)
+EndIf
+
+include "./inits/inits.oc"
+
+Include "./actions/main.oc"
+
+Include "./actions/terminations.oc"
+
+if xbool!=(Yes_strict)
+	#close the last LIBRARY
+	If fileformat=pe_exec
+		If implibsstarted=true
+			SetCall errormsg closelib()
+			If errormsg!=noerr
+				Call msgerrexit(errormsg)
+			EndIf
+		EndIf
+	EndIf
+	Include "./actions/pathout.oc"
+	Include "./actions/fileformat.oc"
+	Include "./actions/resolve.oc" #call to resolve local or imported functions
+	Include "./actions/write.oc"
+endif
+
+Call freeclose()
--- ocompiler-1.orig/src/files/actions.s
+++ /dev/null
@@ -1,39 +0,0 @@
-
-#inits needed on top then some allocs at openfilename then frees needing inits, then these allocs
-SetCall errormsg enumbags(true)
-#here is the start of mem worries for linux
-If errormsg!=noerr
-	Call msgerrexit(errormsg)
-EndIf
-
-Include "./actions/setdefdir.s"
-
-Set includebool zero ##include or not include for applying after command parse
-SetCall errormsg include(safecurrentdirtopath,(TRUE),(cINCLUDE))
-If errormsg!=noerr
-	Call msgerrexit(errormsg)
-EndIf
-
-include "./inits/inits.s"
-
-Include "./actions/main.s"
-
-Include "./actions/terminations.s"
-
-if xbool!=(Yes_strict)
-	#close the last LIBRARY
-	If fileformat=pe_exec
-		If implibsstarted=true
-			SetCall errormsg closelib()
-			If errormsg!=noerr
-				Call msgerrexit(errormsg)
-			EndIf
-		EndIf
-	EndIf
-	Include "./actions/pathout.s"
-	Include "./actions/fileformat.s"
-	Include "./actions/resolve.s" #call to resolve local or imported functions
-	Include "./actions/write.s"
-endif
-
-Call freeclose()
--- /dev/null
+++ ocompiler-1/src/files/actions/fileformat.oc
@@ -0,0 +1,19 @@
+
+#also needed at dtnb and old
+sub datasecSize datasecReg
+
+if nobits_virtual=(No)
+	#in case old style virtual
+	setcall errormsg set_reserve(datasecSize)
+	#setcall errormsg set_reserve(nobitssecReg)
+	if errormsg!=(noerror)
+		Call msgerrexit(errormsg)
+	endif
+endif
+
+If fileformat=pe_exec
+	Include "./fileformat/pe_struct.oc"
+	Include "./fileformat/pe_resolve.oc"
+Else
+	Include "./fileformat/elf_resolve.oc"
+EndElse
--- ocompiler-1.orig/src/files/actions/fileformat.s
+++ /dev/null
@@ -1,19 +0,0 @@
-
-#also needed at dtnb and old
-sub datasecSize datasecReg
-
-if nobits_virtual=(No)
-	#in case old style virtual
-	setcall errormsg set_reserve(datasecSize)
-	#setcall errormsg set_reserve(nobitssecReg)
-	if errormsg!=(noerror)
-		Call msgerrexit(errormsg)
-	endif
-endif
-
-If fileformat=pe_exec
-	Include "./fileformat/pe_struct.s"
-	Include "./fileformat/pe_resolve.s"
-Else
-	Include "./fileformat/elf_resolve.s"
-EndElse
--- /dev/null
+++ ocompiler-1/src/files/actions/fileformat/elf_resolve.oc
@@ -0,0 +1,386 @@
+
+If object=false
+	#data
+	Set elf32_phdr_p_filesz_data datasecReg
+	Set elf32_phdr_p_memsz_data datasecReg
+
+	#code
+	Set elf32_phdr_p_offset_code elf32_phdr_p_offset_data
+	Add elf32_phdr_p_offset_code datasecReg
+
+	Set elf32_phdr_p_vaddr_code elf32_phdr_p_vaddr_data
+
+	SetCall elf32_phdr_p_vaddr_code congruentmoduloatsegments(elf32_phdr_p_vaddr_code,elf32_phdr_p_offset_code,page_sectionalignment,datasecReg)
+	Set elf32_phdr_p_paddr_code elf32_phdr_p_vaddr_code
+
+	Set elf32_phdr_p_filesz_code codesecReg
+	Set elf32_phdr_p_memsz_code codesecReg
+
+
+	#######
+	Data ET_EXEC=2
+	Data ptrET_EXEC^ET_EXEC
+	Call memtomem(ptrelf32_ehd_e_type,ptrET_EXEC,wordsize)
+	#######
+	Add programentrypoint elf32_phdr_p_vaddr_code
+	Set elf32_ehd_e_entry programentrypoint
+	#######
+	Set elf32_ehd_e_phoff elf_fileheaders_size
+	#######
+	Data elf_sections_start_count=2
+	data ptrelf_sections_start_count^elf_sections_start_count
+	call memtomem(ptrelf32_ehd_e_phnum,ptrelf_sections_start_count,wordsize)
+	#######
+
+	#commons#
+	Set virtuallocalsoffset elf32_phdr_p_vaddr_code
+	Set fileheaders elf_fileheaders
+	Set sizefileheaders elf_fileheaders_size
+	#commons#
+
+	if implibsstarted=false
+		call memtomem(ptrelf32_ehd_e_shnum,#one,wordsize)
+		#######
+		call memtomem(ptrelf32_ehd_e_shstrndx,ptrnull,wordsize)
+	else
+		call memtomem(ptrelf32_ehd_e_shnum,#three,wordsize)
+		#######
+		#add here, next will be calculations and these will be above
+		data secstrs_off_atnames#1
+		setcall errormsg addtonames(ptrnull,#secstrs_off_atnames)
+		char dynstr_c=".dynstr";data dynstr#1
+		#shstrtab
+		setcall errormsg addtonames(#dynstr_c,#dynstr)
+		If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+		char dynsec_c=".dynamic";data dynsec#1
+		setcall errormsg addtonames(#dynsec_c,#dynsec)
+		If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+		#
+		call memtomem(ptrelf32_ehd_e_shstrndx,#one,wordsize)
+
+		#imports
+		#If implibsstarted==true
+		#interpreter
+		Inc elf32_ehd_e_phnum
+
+		Set elf32_phdr_p_offset_interp elf32_phdr_p_offset_code
+		Add elf32_phdr_p_offset_interp codesecReg
+
+		Set elf32_phdr_p_vaddr_interp elf32_phdr_p_vaddr_code
+		Add elf32_phdr_p_vaddr_interp codesecReg
+		#SetCall elf32_phdr_p_vaddr_interp congruentmoduloatsegments(elf32_phdr_p_vaddr_interp,elf32_phdr_p_offset_interp,page_sectionalignment,codesecReg)
+
+		Set elf32_phdr_p_paddr_interp elf32_phdr_p_vaddr_interp
+
+		SetCall interpretersize strlen(ptrinterpreter)
+		Inc interpretersize
+
+		Set elf32_phdr_p_filesz_interp interpretersize
+		Set elf32_phdr_p_memsz_interp interpretersize
+
+		#dynamic
+		Inc elf32_ehd_e_phnum
+
+		Set elf32_phdr_p_offset_dyn elf32_phdr_p_offset_interp
+		Add elf32_phdr_p_offset_dyn interpretersize
+
+		Set elf32_phdr_p_vaddr_dyn elf32_phdr_p_vaddr_interp
+		Add elf32_phdr_p_vaddr_dyn interpretersize
+
+
+
+
+
+		#the entry is not taken without this
+		data test1#1
+		data test2#1
+		set test1 elf32_phdr_p_vaddr_interp
+		div test1 page_sectionalignment
+		set test2 elf32_phdr_p_vaddr_dyn
+		div test2 page_sectionalignment
+		if test2=test1
+			add elf32_phdr_p_vaddr_dyn page_sectionalignment
+		endif
+		#recent tests (after some years have passed):
+		#	dynamic section must be in a load segment by gdb warning
+		#	segment=program header
+		#	readelf,gdb,objdump are not error/warning but the executable can only run with /lib/ld-linux.so.2 ./prog
+		#		for printf or something else, here at libs
+
+		#"ELF load command address/offset not page-aligned"
+		#but the fact was to align
+		#and elf32_phdr_p_vaddr_dyn (~page_sectionalignment^(page_sectionalignment-1)|page_sectionalignment)
+		#~(page_sectionalignment-1)
+
+
+
+
+
+		Set elf32_phdr_p_paddr_dyn elf32_phdr_p_vaddr_dyn
+
+		Set elf32_phdr_p_filesz_dyn tableReg
+		Add elf32_phdr_p_filesz_dyn elf_dynfix_size
+
+		Set elf32_phdr_p_memsz_dyn elf32_phdr_p_filesz_dyn
+
+		#libraries load
+		Inc elf32_ehd_e_phnum
+
+		Set elf32_phdr_p_offset_lib elf32_phdr_p_offset_dyn
+		#Add elf32_phdr_p_offset_lib elf32_phdr_p_filesz_dyn
+		data elf_str_offset#1
+		set elf_str_offset elf32_phdr_p_offset_lib
+		Add elf_str_offset elf32_phdr_p_filesz_dyn
+
+		set elf32_phdr_p_vaddr_lib elf32_phdr_p_vaddr_dyn
+		#Add elf32_phdr_p_vaddr_lib elf32_phdr_p_filesz_dyn
+
+		Set elf32_phdr_p_paddr_lib elf32_phdr_p_vaddr_lib
+
+		##resolve libraries
+		###hash
+		Set elf32_dyn_d_ptr_hash elf32_phdr_p_vaddr_lib
+		Add elf32_dyn_d_ptr_hash elf32_phdr_p_filesz_dyn
+
+		#
+		Set elf32_phdr_p_filesz_lib elf_hash_minsize
+		#
+
+		Set sizeofchain addressesReg
+		Div sizeofchain elf32_dyn_d_val_syment
+
+		## '## '=import command dependent
+		Data loopsymbols#1
+		Data ptrloopsymbols^loopsymbols
+		Set loopsymbols zero
+		While loopsymbols<sizeofchain
+			SetCall errormsg addtosec(ptrloopsymbols,dwordsize,ptrmiscbag)
+			If errormsg!=noerr
+				Call msgerrexit(errormsg)
+			EndIf
+			Inc loopsymbols
+		EndWhile
+		##
+		Set hash_var_size miscbagReg
+
+		#
+		Add elf32_phdr_p_filesz_lib hash_var_size
+		#
+
+		###symtab
+		Set elf32_dyn_d_ptr_symtab elf32_dyn_d_ptr_hash
+		Add elf32_dyn_d_ptr_symtab elf_hash_minsize
+		Add elf32_dyn_d_ptr_symtab hash_var_size
+
+		#
+		Add elf32_phdr_p_filesz_lib addressesReg
+		#
+
+		###strtab
+		Set elf32_dyn_d_ptr_strtab elf32_dyn_d_ptr_symtab
+		Add elf32_dyn_d_ptr_strtab addressesReg
+
+		###strsz
+		Set elf32_dyn_d_val_strsz namesReg
+
+		#stroff
+		add elf_str_offset elf32_phdr_p_filesz_lib
+
+		#
+		Add elf32_phdr_p_filesz_lib namesReg
+		#
+
+		###rel
+		Set elf32_dyn_d_ptr_rel elf32_dyn_d_ptr_strtab
+		Add elf32_dyn_d_ptr_rel namesReg
+
+		###relsz
+
+		Set elf32_dyn_d_val_relsz sizeofchain
+
+		Mult elf32_dyn_d_val_relsz elf32_dyn_d_val_relent
+
+		#
+		Add elf32_phdr_p_filesz_lib elf32_dyn_d_val_relsz
+		#
+
+		##
+		Data elf_rel_offset#1
+		Data elf_rel_info_symbolindex#1
+
+		Set elf_rel_offset elf32_dyn_d_ptr_rel
+		Add elf_rel_offset elf32_dyn_d_val_relsz
+		Set elf_rel_info_symbolindex zero
+
+		While elf_rel_info_symbolindex<sizeofchain
+			SetCall errormsg addrel(elf_rel_offset,elf_rel_info_symbolindex,ptrmiscbag)
+			If errormsg!=noerr
+				Call msgerrexit(errormsg)
+			EndIf
+			Inc elf_rel_info_symbolindex
+			Add elf_rel_offset dwordsize
+		EndWhile
+		##
+
+		Set rel_var_size miscbagReg
+		Sub rel_var_size hash_var_size
+
+		Set elf_rel_entries_size sizeofchain
+		Mult elf_rel_entries_size dwordsize
+
+		SetCall errormsg addtosec(0,elf_rel_entries_size,ptrmiscbag)
+		If errormsg!=noerr
+			Call msgerrexit(errormsg)
+		EndIf
+
+		Data el_rel_entries_loop#1
+		Set el_rel_entries_loop miscbag
+		Add el_rel_entries_loop miscbagReg
+		Set loopsymbols zero
+		While loopsymbols<sizeofchain
+			Sub el_rel_entries_loop dwordsize
+			Set el_rel_entries_loop# zero
+			Inc loopsymbols
+		EndWhile
+
+		#commons#
+		Set importfileheaders elf_importfileheaders
+		Set sizeimportfileheaders elf_importfileheaders_size
+
+		Set virtualimportsoffset elf32_dyn_d_ptr_hash
+		Add virtualimportsoffset elf32_phdr_p_filesz_lib
+		#commons#
+
+		#
+		Add elf32_phdr_p_filesz_lib elf_rel_entries_size
+		add elf32_phdr_p_filesz_lib elf32_phdr_p_filesz_dyn
+		#
+
+		Set elf32_phdr_p_memsz_lib elf32_phdr_p_filesz_lib
+	endelse
+
+	#######some section/s for readelf
+	sd sections_start=elf32_ehd_e_phentsize
+	mult sections_start elf32_ehd_e_phnum
+	add sections_start elf_fileheaders_size
+	set elf32_ehd_e_shoff sections_start ##memtomem depends on nul_res_pref
+Else
+	#######
+	Data ET_REL=ET_REL
+	Data ptrET_REL^ET_REL
+	Call memtomem(ptrelf32_ehd_e_type,ptrET_REL,wordsize)
+	#######
+	Set elf32_ehd_e_entry null
+	#######
+	Set elf32_ehd_e_phoff null
+	#######
+	call memtomem(ptrelf32_ehd_e_phnum,ptrnull,wordsize)
+	#######
+	#######
+	sd elf_sec_nr=7
+	sd ptrelf_sec_nr^elf_sec_nr
+	#######
+	sd elf_sec_strtab_nr=-1
+	sd ptrelf_sec_strtab_nr^elf_sec_strtab_nr
+	#######
+
+	Data SHT_PROGBITS=SHT_PROGBITS
+	Data elf_sec_fileoff#1
+
+	SetCall errormsg elfaddsecn()
+	If errormsg!=noerr
+		Call msgerrexit(errormsg)
+	EndIf
+
+	Data elf_sec_flags_data=SHF_WRITE|SHF_ALLOC
+	Set elf_sec_fileoff elf32_phdr_p_offset_data
+	SetCall errormsg elfaddsec(datastrtab,SHT_PROGBITS,elf_sec_flags_data,elf_sec_fileoff,ptrdatasec,null,null,(elf_sec_obj_align),null)
+	If errormsg!=noerr
+		Call msgerrexit(errormsg)
+	EndIf
+	Add elf_sec_fileoff datasecReg
+
+	Data elf_sec_flags_text=SHF_ALLOC|SHF_EXECINSTR
+	SetCall errormsg elfaddsec(codestrtab,SHT_PROGBITS,elf_sec_flags_text,elf_sec_fileoff,ptrcodesec,null,null,(elf_sec_obj_align),null)
+	If errormsg!=noerr
+		Call msgerrexit(errormsg)
+	EndIf
+	Add elf_sec_fileoff codesecReg
+
+	sd symind=symind
+
+	if nobits_virtual=(Yes)
+		SetCall errormsg elfaddsecs(dtnbstrtab,(SHT_NOBITS),elf_sec_flags_data,elf_sec_fileoff,datasecSize,(elf_sec_obj_align))
+		If errormsg!=noerr
+			Call msgerrexit(errormsg)
+		EndIf
+		inc elf_sec_nr
+		inc symind
+	endif
+
+	if has_debug=(Yes)
+		#SHT_NULL will not reach linker output
+		SetCall errormsg elfaddstrsec(".debug",(SHT_PROGBITS),0,elf_sec_fileoff,ptrdebug,0,0,(bsz),0)
+		If errormsg!=noerr
+			Call msgerrexit(errormsg)
+		EndIf
+		add elf_sec_fileoff debugsecReg
+		inc elf_sec_nr
+		inc symind
+	endif
+
+	add elf_sec_strtab_nr elf_sec_nr
+	sd syment;sd relent
+	if p_is_for_64_value#=(TRUE)
+		Set elf64_ehd_e_shoff (elf64_fileheaders_size)
+		call memtomem(#elf64_ehd_e_shnum,ptrelf_sec_nr,wordsize)
+		call memtomem(#elf64_ehd_e_shstrndx,ptrelf_sec_strtab_nr,wordsize)
+		Set fileheaders #elf64_ehd_e_ident_sign
+		Set sizefileheaders (elf64_fileheaders_size)
+		set syment (elf64_dyn_d_val_syment);set relent (elf64_dyn_d_val_relent)
+	else
+		Set elf32_ehd_e_shoff elf_fileheaders_size
+		call memtomem(ptrelf32_ehd_e_shnum,ptrelf_sec_nr,wordsize)
+		call memtomem(ptrelf32_ehd_e_shstrndx,ptrelf_sec_strtab_nr,wordsize)
+		Set fileheaders elf_fileheaders
+		Set sizefileheaders elf_fileheaders_size
+		set syment elf32_dyn_d_val_syment;set relent elf32_dyn_d_val_relent
+	endelse
+
+	Char elfsymtab=".symtab"
+	Str ptrelfsymtab^elfsymtab
+	Data SHT_SYMTAB=2
+
+	SetCall errormsg elfaddstrsec(ptrelfsymtab,SHT_SYMTAB,null,elf_sec_fileoff,ptrtable,elf_sec_strtab_nr,totallocalsymsaddedatstart,dwordsize,syment)
+	If errormsg!=noerr
+		Call msgerrexit(errormsg)
+	EndIf
+
+	Data SHT_RELA=4
+
+	Char elfreldata=".rela.data"
+	Str ptrelfreldata^elfreldata
+	Add elf_sec_fileoff tableReg
+	SetCall errormsg elfaddstrsec(ptrelfreldata,SHT_RELA,null,elf_sec_fileoff,ptraddresses,symind,dataind,dwordsize,relent)
+	If errormsg!=noerr
+		Call msgerrexit(errormsg)
+	EndIf
+
+	Char elfreltxt=".rela.text"
+	Str ptrelfreltxt^elfreltxt
+	Add elf_sec_fileoff addressesReg
+	SetCall errormsg elfaddstrsec(ptrelfreltxt,SHT_RELA,null,elf_sec_fileoff,ptrextra,symind,codeind,dwordsize,relent)
+	If errormsg!=noerr
+		Call msgerrexit(errormsg)
+	EndIf
+
+	Char elfstrtab=".strtab"
+	Str ptrelfstrtab^elfstrtab
+	Add elf_sec_fileoff extraReg
+	SetCall errormsg elfaddstrsec(ptrelfstrtab,(SHT_STRTAB),null,elf_sec_fileoff,ptrnames,null,null,bytesize,null)
+	If errormsg!=noerr
+		Call msgerrexit(errormsg)
+	EndIf
+
+	Set startofdata elf_startofdata
+EndElse
--- ocompiler-1.orig/src/files/actions/fileformat/elf_resolve.s
+++ /dev/null
@@ -1,386 +0,0 @@
-
-If object=false
-	#data
-	Set elf32_phdr_p_filesz_data datasecReg
-	Set elf32_phdr_p_memsz_data datasecReg
-
-	#code
-	Set elf32_phdr_p_offset_code elf32_phdr_p_offset_data
-	Add elf32_phdr_p_offset_code datasecReg
-
-	Set elf32_phdr_p_vaddr_code elf32_phdr_p_vaddr_data
-
-	SetCall elf32_phdr_p_vaddr_code congruentmoduloatsegments(elf32_phdr_p_vaddr_code,elf32_phdr_p_offset_code,page_sectionalignment,datasecReg)
-	Set elf32_phdr_p_paddr_code elf32_phdr_p_vaddr_code
-
-	Set elf32_phdr_p_filesz_code codesecReg
-	Set elf32_phdr_p_memsz_code codesecReg
-
-
-	#######
-	Data ET_EXEC=2
-	Data ptrET_EXEC^ET_EXEC
-	Call memtomem(ptrelf32_ehd_e_type,ptrET_EXEC,wordsize)
-	#######
-	Add programentrypoint elf32_phdr_p_vaddr_code
-	Set elf32_ehd_e_entry programentrypoint
-	#######
-	Set elf32_ehd_e_phoff elf_fileheaders_size
-	#######
-	Data elf_sections_start_count=2
-	data ptrelf_sections_start_count^elf_sections_start_count
-	call memtomem(ptrelf32_ehd_e_phnum,ptrelf_sections_start_count,wordsize)
-	#######
-
-	#commons#
-	Set virtuallocalsoffset elf32_phdr_p_vaddr_code
-	Set fileheaders elf_fileheaders
-	Set sizefileheaders elf_fileheaders_size
-	#commons#
-
-	if implibsstarted=false
-		call memtomem(ptrelf32_ehd_e_shnum,#one,wordsize)
-		#######
-		call memtomem(ptrelf32_ehd_e_shstrndx,ptrnull,wordsize)
-	else
-		call memtomem(ptrelf32_ehd_e_shnum,#three,wordsize)
-		#######
-		#add here, next will be calculations and these will be above
-		data secstrs_off_atnames#1
-		setcall errormsg addtonames(ptrnull,#secstrs_off_atnames)
-		char dynstr_c=".dynstr";data dynstr#1
-		#shstrtab
-		setcall errormsg addtonames(#dynstr_c,#dynstr)
-		If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
-		char dynsec_c=".dynamic";data dynsec#1
-		setcall errormsg addtonames(#dynsec_c,#dynsec)
-		If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
-		#
-		call memtomem(ptrelf32_ehd_e_shstrndx,#one,wordsize)
-
-		#imports
-		#If implibsstarted==true
-		#interpreter
-		Inc elf32_ehd_e_phnum
-
-		Set elf32_phdr_p_offset_interp elf32_phdr_p_offset_code
-		Add elf32_phdr_p_offset_interp codesecReg
-
-		Set elf32_phdr_p_vaddr_interp elf32_phdr_p_vaddr_code
-		Add elf32_phdr_p_vaddr_interp codesecReg
-		#SetCall elf32_phdr_p_vaddr_interp congruentmoduloatsegments(elf32_phdr_p_vaddr_interp,elf32_phdr_p_offset_interp,page_sectionalignment,codesecReg)
-
-		Set elf32_phdr_p_paddr_interp elf32_phdr_p_vaddr_interp
-
-		SetCall interpretersize strlen(ptrinterpreter)
-		Inc interpretersize
-
-		Set elf32_phdr_p_filesz_interp interpretersize
-		Set elf32_phdr_p_memsz_interp interpretersize
-
-		#dynamic
-		Inc elf32_ehd_e_phnum
-
-		Set elf32_phdr_p_offset_dyn elf32_phdr_p_offset_interp
-		Add elf32_phdr_p_offset_dyn interpretersize
-
-		Set elf32_phdr_p_vaddr_dyn elf32_phdr_p_vaddr_interp
-		Add elf32_phdr_p_vaddr_dyn interpretersize
-
-
-
-
-
-		#the entry is not taken without this
-		data test1#1
-		data test2#1
-		set test1 elf32_phdr_p_vaddr_interp
-		div test1 page_sectionalignment
-		set test2 elf32_phdr_p_vaddr_dyn
-		div test2 page_sectionalignment
-		if test2=test1
-			add elf32_phdr_p_vaddr_dyn page_sectionalignment
-		endif
-		#recent tests (after some years have passed):
-		#	dynamic section must be in a load segment by gdb warning
-		#	segment=program header
-		#	readelf,gdb,objdump are not error/warning but the executable can only run with /lib/ld-linux.so.2 ./prog
-		#		for printf or something else, here at libs
-
-		#"ELF load command address/offset not page-aligned"
-		#but the fact was to align
-		#and elf32_phdr_p_vaddr_dyn (~page_sectionalignment^(page_sectionalignment-1)|page_sectionalignment)
-		#~(page_sectionalignment-1)
-
-
-
-
-
-		Set elf32_phdr_p_paddr_dyn elf32_phdr_p_vaddr_dyn
-
-		Set elf32_phdr_p_filesz_dyn tableReg
-		Add elf32_phdr_p_filesz_dyn elf_dynfix_size
-
-		Set elf32_phdr_p_memsz_dyn elf32_phdr_p_filesz_dyn
-
-		#libraries load
-		Inc elf32_ehd_e_phnum
-
-		Set elf32_phdr_p_offset_lib elf32_phdr_p_offset_dyn
-		#Add elf32_phdr_p_offset_lib elf32_phdr_p_filesz_dyn
-		data elf_str_offset#1
-		set elf_str_offset elf32_phdr_p_offset_lib
-		Add elf_str_offset elf32_phdr_p_filesz_dyn
-
-		set elf32_phdr_p_vaddr_lib elf32_phdr_p_vaddr_dyn
-		#Add elf32_phdr_p_vaddr_lib elf32_phdr_p_filesz_dyn
-
-		Set elf32_phdr_p_paddr_lib elf32_phdr_p_vaddr_lib
-
-		##resolve libraries
-		###hash
-		Set elf32_dyn_d_ptr_hash elf32_phdr_p_vaddr_lib
-		Add elf32_dyn_d_ptr_hash elf32_phdr_p_filesz_dyn
-
-		#
-		Set elf32_phdr_p_filesz_lib elf_hash_minsize
-		#
-
-		Set sizeofchain addressesReg
-		Div sizeofchain elf32_dyn_d_val_syment
-
-		## '## '=import command dependent
-		Data loopsymbols#1
-		Data ptrloopsymbols^loopsymbols
-		Set loopsymbols zero
-		While loopsymbols<sizeofchain
-			SetCall errormsg addtosec(ptrloopsymbols,dwordsize,ptrmiscbag)
-			If errormsg!=noerr
-				Call msgerrexit(errormsg)
-			EndIf
-			Inc loopsymbols
-		EndWhile
-		##
-		Set hash_var_size miscbagReg
-
-		#
-		Add elf32_phdr_p_filesz_lib hash_var_size
-		#
-
-		###symtab
-		Set elf32_dyn_d_ptr_symtab elf32_dyn_d_ptr_hash
-		Add elf32_dyn_d_ptr_symtab elf_hash_minsize
-		Add elf32_dyn_d_ptr_symtab hash_var_size
-
-		#
-		Add elf32_phdr_p_filesz_lib addressesReg
-		#
-
-		###strtab
-		Set elf32_dyn_d_ptr_strtab elf32_dyn_d_ptr_symtab
-		Add elf32_dyn_d_ptr_strtab addressesReg
-
-		###strsz
-		Set elf32_dyn_d_val_strsz namesReg
-
-		#stroff
-		add elf_str_offset elf32_phdr_p_filesz_lib
-
-		#
-		Add elf32_phdr_p_filesz_lib namesReg
-		#
-
-		###rel
-		Set elf32_dyn_d_ptr_rel elf32_dyn_d_ptr_strtab
-		Add elf32_dyn_d_ptr_rel namesReg
-
-		###relsz
-
-		Set elf32_dyn_d_val_relsz sizeofchain
-
-		Mult elf32_dyn_d_val_relsz elf32_dyn_d_val_relent
-
-		#
-		Add elf32_phdr_p_filesz_lib elf32_dyn_d_val_relsz
-		#
-
-		##
-		Data elf_rel_offset#1
-		Data elf_rel_info_symbolindex#1
-
-		Set elf_rel_offset elf32_dyn_d_ptr_rel
-		Add elf_rel_offset elf32_dyn_d_val_relsz
-		Set elf_rel_info_symbolindex zero
-
-		While elf_rel_info_symbolindex<sizeofchain
-			SetCall errormsg addrel(elf_rel_offset,elf_rel_info_symbolindex,ptrmiscbag)
-			If errormsg!=noerr
-				Call msgerrexit(errormsg)
-			EndIf
-			Inc elf_rel_info_symbolindex
-			Add elf_rel_offset dwordsize
-		EndWhile
-		##
-
-		Set rel_var_size miscbagReg
-		Sub rel_var_size hash_var_size
-
-		Set elf_rel_entries_size sizeofchain
-		Mult elf_rel_entries_size dwordsize
-
-		SetCall errormsg addtosec(0,elf_rel_entries_size,ptrmiscbag)
-		If errormsg!=noerr
-			Call msgerrexit(errormsg)
-		EndIf
-
-		Data el_rel_entries_loop#1
-		Set el_rel_entries_loop miscbag
-		Add el_rel_entries_loop miscbagReg
-		Set loopsymbols zero
-		While loopsymbols<sizeofchain
-			Sub el_rel_entries_loop dwordsize
-			Set el_rel_entries_loop# zero
-			Inc loopsymbols
-		EndWhile
-
-		#commons#
-		Set importfileheaders elf_importfileheaders
-		Set sizeimportfileheaders elf_importfileheaders_size
-
-		Set virtualimportsoffset elf32_dyn_d_ptr_hash
-		Add virtualimportsoffset elf32_phdr_p_filesz_lib
-		#commons#
-
-		#
-		Add elf32_phdr_p_filesz_lib elf_rel_entries_size
-		add elf32_phdr_p_filesz_lib elf32_phdr_p_filesz_dyn
-		#
-
-		Set elf32_phdr_p_memsz_lib elf32_phdr_p_filesz_lib
-	endelse
-
-	#######some section/s for readelf
-	sd sections_start=elf32_ehd_e_phentsize
-	mult sections_start elf32_ehd_e_phnum
-	add sections_start elf_fileheaders_size
-	set elf32_ehd_e_shoff sections_start ##memtomem depends on nul_res_pref
-Else
-	#######
-	Data ET_REL=ET_REL
-	Data ptrET_REL^ET_REL
-	Call memtomem(ptrelf32_ehd_e_type,ptrET_REL,wordsize)
-	#######
-	Set elf32_ehd_e_entry null
-	#######
-	Set elf32_ehd_e_phoff null
-	#######
-	call memtomem(ptrelf32_ehd_e_phnum,ptrnull,wordsize)
-	#######
-	#######
-	sd elf_sec_nr=7
-	sd ptrelf_sec_nr^elf_sec_nr
-	#######
-	sd elf_sec_strtab_nr=-1
-	sd ptrelf_sec_strtab_nr^elf_sec_strtab_nr
-	#######
-
-	Data SHT_PROGBITS=SHT_PROGBITS
-	Data elf_sec_fileoff#1
-
-	SetCall errormsg elfaddsecn()
-	If errormsg!=noerr
-		Call msgerrexit(errormsg)
-	EndIf
-
-	Data elf_sec_flags_data=SHF_WRITE|SHF_ALLOC
-	Set elf_sec_fileoff elf32_phdr_p_offset_data
-	SetCall errormsg elfaddsec(datastrtab,SHT_PROGBITS,elf_sec_flags_data,elf_sec_fileoff,ptrdatasec,null,null,(elf_sec_obj_align),null)
-	If errormsg!=noerr
-		Call msgerrexit(errormsg)
-	EndIf
-	Add elf_sec_fileoff datasecReg
-
-	Data elf_sec_flags_text=SHF_ALLOC|SHF_EXECINSTR
-	SetCall errormsg elfaddsec(codestrtab,SHT_PROGBITS,elf_sec_flags_text,elf_sec_fileoff,ptrcodesec,null,null,(elf_sec_obj_align),null)
-	If errormsg!=noerr
-		Call msgerrexit(errormsg)
-	EndIf
-	Add elf_sec_fileoff codesecReg
-
-	sd symind=symind
-
-	if nobits_virtual=(Yes)
-		SetCall errormsg elfaddsecs(dtnbstrtab,(SHT_NOBITS),elf_sec_flags_data,elf_sec_fileoff,datasecSize,(elf_sec_obj_align))
-		If errormsg!=noerr
-			Call msgerrexit(errormsg)
-		EndIf
-		inc elf_sec_nr
-		inc symind
-	endif
-
-	if has_debug=(Yes)
-		#SHT_NULL will not reach linker output
-		SetCall errormsg elfaddstrsec(".debug",(SHT_PROGBITS),0,elf_sec_fileoff,ptrdebug,0,0,(bsz),0)
-		If errormsg!=noerr
-			Call msgerrexit(errormsg)
-		EndIf
-		add elf_sec_fileoff debugsecReg
-		inc elf_sec_nr
-		inc symind
-	endif
-
-	add elf_sec_strtab_nr elf_sec_nr
-	sd syment;sd relent
-	if p_is_for_64_value#=(TRUE)
-		Set elf64_ehd_e_shoff (elf64_fileheaders_size)
-		call memtomem(#elf64_ehd_e_shnum,ptrelf_sec_nr,wordsize)
-		call memtomem(#elf64_ehd_e_shstrndx,ptrelf_sec_strtab_nr,wordsize)
-		Set fileheaders #elf64_ehd_e_ident_sign
-		Set sizefileheaders (elf64_fileheaders_size)
-		set syment (elf64_dyn_d_val_syment);set relent (elf64_dyn_d_val_relent)
-	else
-		Set elf32_ehd_e_shoff elf_fileheaders_size
-		call memtomem(ptrelf32_ehd_e_shnum,ptrelf_sec_nr,wordsize)
-		call memtomem(ptrelf32_ehd_e_shstrndx,ptrelf_sec_strtab_nr,wordsize)
-		Set fileheaders elf_fileheaders
-		Set sizefileheaders elf_fileheaders_size
-		set syment elf32_dyn_d_val_syment;set relent elf32_dyn_d_val_relent
-	endelse
-
-	Char elfsymtab=".symtab"
-	Str ptrelfsymtab^elfsymtab
-	Data SHT_SYMTAB=2
-
-	SetCall errormsg elfaddstrsec(ptrelfsymtab,SHT_SYMTAB,null,elf_sec_fileoff,ptrtable,elf_sec_strtab_nr,totallocalsymsaddedatstart,dwordsize,syment)
-	If errormsg!=noerr
-		Call msgerrexit(errormsg)
-	EndIf
-
-	Data SHT_RELA=4
-
-	Char elfreldata=".rela.data"
-	Str ptrelfreldata^elfreldata
-	Add elf_sec_fileoff tableReg
-	SetCall errormsg elfaddstrsec(ptrelfreldata,SHT_RELA,null,elf_sec_fileoff,ptraddresses,symind,dataind,dwordsize,relent)
-	If errormsg!=noerr
-		Call msgerrexit(errormsg)
-	EndIf
-
-	Char elfreltxt=".rela.text"
-	Str ptrelfreltxt^elfreltxt
-	Add elf_sec_fileoff addressesReg
-	SetCall errormsg elfaddstrsec(ptrelfreltxt,SHT_RELA,null,elf_sec_fileoff,ptrextra,symind,codeind,dwordsize,relent)
-	If errormsg!=noerr
-		Call msgerrexit(errormsg)
-	EndIf
-
-	Char elfstrtab=".strtab"
-	Str ptrelfstrtab^elfstrtab
-	Add elf_sec_fileoff extraReg
-	SetCall errormsg elfaddstrsec(ptrelfstrtab,(SHT_STRTAB),null,elf_sec_fileoff,ptrnames,null,null,bytesize,null)
-	If errormsg!=noerr
-		Call msgerrexit(errormsg)
-	EndIf
-
-	Set startofdata elf_startofdata
-EndElse
--- /dev/null
+++ ocompiler-1/src/files/actions/fileformat/pe_resolve.oc
@@ -0,0 +1,166 @@
+
+
+
+
+
+##############################################
+Set SizeOfImage SectionAlignment
+##############################################
+
+##############################################
+#datasection VirtualSize
+Set dVirtualSize datasecReg
+#######################
+Set dSizeOfRawData datasecMax
+#######################
+Set SizeOfInitializedData dSizeOfRawData
+#######################
+Add SizeOfImage dSizeOfRawData
+##############################################
+
+
+##############################################
+Set BaseOfCode SizeOfImage
+#######################
+Set SizeOfCode codesecMax
+#######################
+Add programentrypoint BaseOfCode
+Set AddressOfEntryPoint programentrypoint
+#######################
+#codesection VirtualSize
+Set cVirtualSize codesecReg
+#######################
+Set cVirtualAddress BaseOfCode
+#######################
+Set cPointerToRawData SizeOfImage
+#######################
+Set cSizeOfRawData SizeOfCode
+#######################
+Add SizeOfImage cSizeOfRawData
+#######################
+#Const pe_fileheadersstart^dos_header
+#Const codesectionCharacteristicsoff^codesectionCharacteristics
+#Const sizefileheadercodedata=codesectionCharacteristicsoff+dwsz
+Const codedatasizefileheaders=sizefileheadercodedata-pe_fileheadersstart
+Data codedatasizefileheaders=codedatasizefileheaders
+
+Set SizeOfHeaders codedatasizefileheaders
+##############################################
+
+
+###################resolve commons###################
+Data pe_fileheaders%pe_fileheadersstart
+Set fileheaders pe_fileheaders
+Set sizefileheaders SizeOfHeaders
+
+set virtuallocalsoffset cVirtualAddress
+add virtuallocalsoffset imagebaseoffset
+###################resolve commons###################
+
+Data directoriesaddress^directoryentries
+Data destdir#1
+If implibsstarted=true
+	##############################################
+	Set iVirtualAddress SizeOfImage
+	#######################
+	Set iPointerToRawData SizeOfImage
+	#######################
+	#OPTIONAL_HEADER\Directories\Import table rva
+	Set destdir directoriesaddress
+	Data idiroffset=im_d_entry_import_offset
+	Add destdir idiroffset
+	Set destdir# iVirtualAddress
+	#######################
+
+	#OPTIONAL_HEADER\Directories\Import table size
+	Add destdir dwordsize
+
+	Data itabentrysize=IMAGE_IMPORT_DESCRIPTORsize
+	Data itabloc#1
+	Set itabloc tableReg
+	SetCall errormsg addtosec(0,itabentrysize,ptrtable)
+	If errormsg!=noerr
+		Call msgerrexit(errormsg)
+	EndIf
+	Add itabloc table
+	Call memset(itabloc,null,itabentrysize)
+
+	Set destdir# tableReg
+
+	#######################
+	Add SizeOfInitializedData iSizeOfRawData
+	#######################
+	Add SizeOfImage iSizeOfRawData
+	#######################
+	Inc ptrNumberOfSections#
+	#######################
+	#Const idatasectionCharacteristicsoff^idatasectionCharacteristics
+	#Const idatasectionstart^idatasection
+	Const idatasectionsize=idatasectionend-idatasectionstart
+	Data idatasectionstart%idatasectionstart
+	Data idatasectionsize=idatasectionsize
+
+	Add SizeOfHeaders idatasectionsize
+	#without this "There is an import table, but the section containing it could not be found"
+	add sizefileheaders idatasectionsize
+	##############################################
+
+	Const iaddressesoffset=itablesize
+	Const inamesoffset=itablesize+iaddressessize
+	Data iaddressesoffset=iaddressesoffset
+	Data inamesoffset=inamesoffset
+
+	###################resolve commons###################
+	Set importfileheaders idatasectionstart
+	Set sizeimportfileheaders idatasectionsize
+
+	Set virtualimportsoffset iVirtualAddress
+	Add virtualimportsoffset iaddressesoffset
+	add virtualimportsoffset imagebaseoffset
+	###################resolve commons###################
+
+	#resolve idata section
+	Add iaddressesoffset iVirtualAddress
+	Add inamesoffset iVirtualAddress
+
+	Data resolveitab#1
+	Set resolveitab table
+	Add resolveitab tableReg
+
+	Sub resolveitab itabentrysize
+	Data resolvevalue#1
+	While table!=resolveitab
+		Sub resolveitab dwordsize
+		Set resolvevalue resolveitab#
+		Add resolvevalue iaddressesoffset
+		Set resolveitab# resolvevalue
+		Sub resolveitab dwordsize
+		Set resolvevalue resolveitab#
+		Add resolvevalue inamesoffset
+		Set resolveitab# resolvevalue
+		Sub resolveitab dwordsize
+		Sub resolveitab dwordsize
+		Sub resolveitab dwordsize
+		Set resolvevalue resolveitab#
+		Add resolvevalue iaddressesoffset
+		Set resolveitab# resolvevalue
+	EndWhile
+
+	Data resolveiadr#1
+	Set resolveiadr addresses
+	Add resolveiadr addressesReg
+
+	While addresses!=resolveiadr
+		Sub resolveiadr dwordsize
+		Set resolvevalue resolveiadr#
+		#offset 0 can be wrong but is not because there it is the first library name and these are functions names
+		If resolvevalue!=zero
+			Add resolvevalue inamesoffset
+			Set resolveiadr# resolvevalue
+		EndIf
+	EndWhile
+EndIf
+
+Data padtheheaders#1
+SetCall padtheheaders requiredpad(SizeOfHeaders,FileAlignment)
+Add SizeOfHeaders padtheheaders
--- ocompiler-1.orig/src/files/actions/fileformat/pe_resolve.s
+++ /dev/null
@@ -1,166 +0,0 @@
-
-
-
-
-
-##############################################
-Set SizeOfImage SectionAlignment
-##############################################
-
-##############################################
-#datasection VirtualSize
-Set dVirtualSize datasecReg
-#######################
-Set dSizeOfRawData datasecMax
-#######################
-Set SizeOfInitializedData dSizeOfRawData
-#######################
-Add SizeOfImage dSizeOfRawData
-##############################################
-
-
-##############################################
-Set BaseOfCode SizeOfImage
-#######################
-Set SizeOfCode codesecMax
-#######################
-Add programentrypoint BaseOfCode
-Set AddressOfEntryPoint programentrypoint
-#######################
-#codesection VirtualSize
-Set cVirtualSize codesecReg
-#######################
-Set cVirtualAddress BaseOfCode
-#######################
-Set cPointerToRawData SizeOfImage
-#######################
-Set cSizeOfRawData SizeOfCode
-#######################
-Add SizeOfImage cSizeOfRawData
-#######################
-#Const pe_fileheadersstart^dos_header
-#Const codesectionCharacteristicsoff^codesectionCharacteristics
-#Const sizefileheadercodedata=codesectionCharacteristicsoff+dwsz
-Const codedatasizefileheaders=sizefileheadercodedata-pe_fileheadersstart
-Data codedatasizefileheaders=codedatasizefileheaders
-
-Set SizeOfHeaders codedatasizefileheaders
-##############################################
-
-
-###################resolve commons###################
-Data pe_fileheaders%pe_fileheadersstart
-Set fileheaders pe_fileheaders
-Set sizefileheaders SizeOfHeaders
-
-set virtuallocalsoffset cVirtualAddress
-add virtuallocalsoffset imagebaseoffset
-###################resolve commons###################
-
-Data directoriesaddress^directoryentries
-Data destdir#1
-If implibsstarted=true
-	##############################################
-	Set iVirtualAddress SizeOfImage
-	#######################
-	Set iPointerToRawData SizeOfImage
-	#######################
-	#OPTIONAL_HEADER\Directories\Import table rva
-	Set destdir directoriesaddress
-	Data idiroffset=im_d_entry_import_offset
-	Add destdir idiroffset
-	Set destdir# iVirtualAddress
-	#######################
-
-	#OPTIONAL_HEADER\Directories\Import table size
-	Add destdir dwordsize
-
-	Data itabentrysize=IMAGE_IMPORT_DESCRIPTORsize
-	Data itabloc#1
-	Set itabloc tableReg
-	SetCall errormsg addtosec(0,itabentrysize,ptrtable)
-	If errormsg!=noerr
-		Call msgerrexit(errormsg)
-	EndIf
-	Add itabloc table
-	Call memset(itabloc,null,itabentrysize)
-
-	Set destdir# tableReg
-
-	#######################
-	Add SizeOfInitializedData iSizeOfRawData
-	#######################
-	Add SizeOfImage iSizeOfRawData
-	#######################
-	Inc ptrNumberOfSections#
-	#######################
-	#Const idatasectionCharacteristicsoff^idatasectionCharacteristics
-	#Const idatasectionstart^idatasection
-	Const idatasectionsize=idatasectionend-idatasectionstart
-	Data idatasectionstart%idatasectionstart
-	Data idatasectionsize=idatasectionsize
-
-	Add SizeOfHeaders idatasectionsize
-	#without this "There is an import table, but the section containing it could not be found"
-	add sizefileheaders idatasectionsize
-	##############################################
-
-	Const iaddressesoffset=itablesize
-	Const inamesoffset=itablesize+iaddressessize
-	Data iaddressesoffset=iaddressesoffset
-	Data inamesoffset=inamesoffset
-
-	###################resolve commons###################
-	Set importfileheaders idatasectionstart
-	Set sizeimportfileheaders idatasectionsize
-
-	Set virtualimportsoffset iVirtualAddress
-	Add virtualimportsoffset iaddressesoffset
-	add virtualimportsoffset imagebaseoffset
-	###################resolve commons###################
-
-	#resolve idata section
-	Add iaddressesoffset iVirtualAddress
-	Add inamesoffset iVirtualAddress
-
-	Data resolveitab#1
-	Set resolveitab table
-	Add resolveitab tableReg
-
-	Sub resolveitab itabentrysize
-	Data resolvevalue#1
-	While table!=resolveitab
-		Sub resolveitab dwordsize
-		Set resolvevalue resolveitab#
-		Add resolvevalue iaddressesoffset
-		Set resolveitab# resolvevalue
-		Sub resolveitab dwordsize
-		Set resolvevalue resolveitab#
-		Add resolvevalue inamesoffset
-		Set resolveitab# resolvevalue
-		Sub resolveitab dwordsize
-		Sub resolveitab dwordsize
-		Sub resolveitab dwordsize
-		Set resolvevalue resolveitab#
-		Add resolvevalue iaddressesoffset
-		Set resolveitab# resolvevalue
-	EndWhile
-
-	Data resolveiadr#1
-	Set resolveiadr addresses
-	Add resolveiadr addressesReg
-
-	While addresses!=resolveiadr
-		Sub resolveiadr dwordsize
-		Set resolvevalue resolveiadr#
-		#offset 0 can be wrong but is not because there it is the first library name and these are functions names
-		If resolvevalue!=zero
-			Add resolvevalue inamesoffset
-			Set resolveiadr# resolvevalue
-		EndIf
-	EndWhile
-EndIf
-
-Data padtheheaders#1
-SetCall padtheheaders requiredpad(SizeOfHeaders,FileAlignment)
-Add SizeOfHeaders padtheheaders
--- /dev/null
+++ ocompiler-1/src/files/actions/fileformat/pe_struct.oc
@@ -0,0 +1,150 @@
+
+
+
+
+#IMAGE_DOS_HEADER
+#00    WORD   e_magic;                     // Magic number
+#02    WORD   e_cblp;                      // Bytes on last page of file
+#04    WORD   e_cp;                        // Pages in file
+#06    WORD   e_crlc;                      // Relocations
+#08    WORD   e_cparhdr;                   // Size of header in paragraphs
+#      WORD   e_minalloc;                  // Minimum extra paragraphs needed
+#      WORD   e_maxalloc;                  // Maximum extra paragraphs needed
+#      WORD   e_ss;                        // Initial (relative) SS value
+#10    WORD   e_sp;                        // Initial SP value
+#      WORD   e_csum;                      // Checksum
+#      WORD   e_ip;                        // Initial IP value
+#      WORD   e_cs;                        // Initial (relative) CS value
+#      WORD   e_lfarlc;                    // File address of relocation table
+#      WORD   e_ovno;                      // Overlay number
+#1c    WORD   e_res[4];                    // Reserved words
+#      WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
+#      WORD   e_oeminfo;                   // OEM information; e_oemid specific
+#      WORD   e_res2[10];                  // Reserved words
+#2c    LONG   e_lfanew;                    // File address of new exe header
+
+Data pdoscrs^dos_header
+Data pdos^dos_header
+Data dos_size=dossize
+Call memset(pdos,null,dos_size)
+
+Char mz="MZ"
+Str pmz^mz
+Call memtomem(pdos,pmz,wordsize)
+
+Add pdos wordsize
+Data e_cblp=128
+Set pdos# e_cblp
+
+Add pdos wordsize
+Data e_cp=1
+Set pdos# e_cp
+
+Add pdos wordsize
+Add pdos wordsize
+Data e_cparhdr=4
+Set pdos# e_cparhdr
+
+Add pdoscrs dos_size
+Sub pdoscrs dwordsize
+Data e_lfanew=0x80
+Set pdoscrs# e_lfanew
+
+Char stubcode={0x0e,0x1f,0xba,0x0e,0x00,0xb4,0x09,0xcd,0x21,0xb8,0x01,0x4c,0xcd,0x21}
+Char stubstr="This program cannot be run in DOS mode."
+Char stubstrend={0xd,0xa,0x24,0,0,0,0,0,0,0,0}
+Data pstub^stub
+Data stubsz^stubstr
+Data pstubcode^stubcode
+
+Sub stubsz pstubcode
+Call memtomem(pstub,pstubcode,stubsz)
+Add pstub stubsz
+Data stubsz2#1
+Data pstubstr^stubstr
+SetCall stubsz2 strlen(pstubstr)
+Call memtomem(pstub,pstubstr,stubsz2)
+Add pstub stubsz2
+Data stubsz3#1
+Data stublength=stublength
+set stubsz3 stublength
+Sub stubsz3 stubsz2
+Sub stubsz3 stubsz
+Data pstubstrend^stubstrend
+Call memtomem(pstub,pstubstrend,stubsz3)
+
+Const fileheaderoffset^fileheader
+#IMAGE_FILE_HEADER
+#    WORD    Machine;
+#    WORD    NumberOfSections;
+#    DWORD   TimeDateStamp;
+#    DWORD   PointerToSymbolTable;
+#    DWORD   NumberOfSymbols;
+#    WORD    SizeOfOptionalHeader;
+#    WORD    Characteristics;
+
+Data pfileheader%fileheaderoffset
+
+Const IMAGE_FILE_MACHINE_I386=0x014C
+Data Machine=IMAGE_FILE_MACHINE_I386
+Set pfileheader# Machine
+
+Add pfileheader wordsize
+Const defaultNumberOfSections=2
+Data defaultNumberOfSections=defaultNumberOfSections
+Data ptrNumberOfSections#1
+Set ptrNumberOfSections pfileheader
+Set pfileheader# defaultNumberOfSections
+
+#TimeDateStamp
+Add pfileheader wordsize
+Set pfileheader# null
+
+#PointerToSymbolTable
+Add pfileheader dwordsize
+Set pfileheader# null
+
+#NumberOfSymbols
+Add pfileheader dwordsize
+Set pfileheader# null
+
+#SizeOfOptionalHeader
+Add pfileheader dwordsize
+Data SizeOfOptionalHeader=0xE0
+Set pfileheader# SizeOfOptionalHeader
+
+#Characteristics
+Add pfileheader wordsize
+Const IMAGE_FILE_DEBUG_STRIPPED=0x0200
+Const IMAGE_FILE_32BIT_MACHINE=0x0100
+Const IMAGE_FILE_LOCAL_SYMS_STRIPPED=0x0008
+Const IMAGE_FILE_LINE_NUMS_STRIPPED=0x0004
+Const IMAGE_FILE_EXECUTABLE_IMAGE=0x0002
+#exe specific
+Const IMAGE_FILE_RELOCS_STRIPPED=0x0001
+#dll specific
+#Const IMAGE_FILE_DLL=0x2000
+
+Const coffChrsGeneral=IMAGE_FILE_DEBUG_STRIPPED|IMAGE_FILE_32BIT_MACHINE|IMAGE_FILE_LOCAL_SYMS_STRIPPED|IMAGE_FILE_LINE_NUMS_STRIPPED|IMAGE_FILE_EXECUTABLE_IMAGE
+Const coffexeCharacteristics=coffChrsGeneral|IMAGE_FILE_RELOCS_STRIPPED
+Data coffexeCharacteristics=coffexeCharacteristics
+
+Data Characteristics#1
+Set Characteristics coffexeCharacteristics
+Data pchrctrs^Characteristics
+Call memtomem(pfileheader,pchrctrs,wordsize)
+
+#IMAGE_OPTIONAL_HEADER
+Data popthd^Magic
+Const IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b
+Data nt_opt_hd_magic=IMAGE_NT_OPTIONAL_HDR32_MAGIC
+Data ohm^nt_opt_hd_magic
+Call memtomem(popthd,ohm,wordsize)
+
+
+Data ptrtodllcharacteristics^DllCharacteristics
+Call memtomem(ptrtodllcharacteristics,ptrnull,wordsize)
+
+Data patdirs^directoryentries
+Data imgdirsSize=dwsz*imgdirsInts
+Call memset(patdirs,null,imgdirsSize)
--- ocompiler-1.orig/src/files/actions/fileformat/pe_struct.s
+++ /dev/null
@@ -1,150 +0,0 @@
-
-
-
-
-#IMAGE_DOS_HEADER
-#00    WORD   e_magic;                     // Magic number
-#02    WORD   e_cblp;                      // Bytes on last page of file
-#04    WORD   e_cp;                        // Pages in file
-#06    WORD   e_crlc;                      // Relocations
-#08    WORD   e_cparhdr;                   // Size of header in paragraphs
-#      WORD   e_minalloc;                  // Minimum extra paragraphs needed
-#      WORD   e_maxalloc;                  // Maximum extra paragraphs needed
-#      WORD   e_ss;                        // Initial (relative) SS value
-#10    WORD   e_sp;                        // Initial SP value
-#      WORD   e_csum;                      // Checksum
-#      WORD   e_ip;                        // Initial IP value
-#      WORD   e_cs;                        // Initial (relative) CS value
-#      WORD   e_lfarlc;                    // File address of relocation table
-#      WORD   e_ovno;                      // Overlay number
-#1c    WORD   e_res[4];                    // Reserved words
-#      WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
-#      WORD   e_oeminfo;                   // OEM information; e_oemid specific
-#      WORD   e_res2[10];                  // Reserved words
-#2c    LONG   e_lfanew;                    // File address of new exe header
-
-Data pdoscrs^dos_header
-Data pdos^dos_header
-Data dos_size=dossize
-Call memset(pdos,null,dos_size)
-
-Char mz="MZ"
-Str pmz^mz
-Call memtomem(pdos,pmz,wordsize)
-
-Add pdos wordsize
-Data e_cblp=128
-Set pdos# e_cblp
-
-Add pdos wordsize
-Data e_cp=1
-Set pdos# e_cp
-
-Add pdos wordsize
-Add pdos wordsize
-Data e_cparhdr=4
-Set pdos# e_cparhdr
-
-Add pdoscrs dos_size
-Sub pdoscrs dwordsize
-Data e_lfanew=0x80
-Set pdoscrs# e_lfanew
-
-Char stubcode={0x0e,0x1f,0xba,0x0e,0x00,0xb4,0x09,0xcd,0x21,0xb8,0x01,0x4c,0xcd,0x21}
-Char stubstr="This program cannot be run in DOS mode."
-Char stubstrend={0xd,0xa,0x24,0,0,0,0,0,0,0,0}
-Data pstub^stub
-Data stubsz^stubstr
-Data pstubcode^stubcode
-
-Sub stubsz pstubcode
-Call memtomem(pstub,pstubcode,stubsz)
-Add pstub stubsz
-Data stubsz2#1
-Data pstubstr^stubstr
-SetCall stubsz2 strlen(pstubstr)
-Call memtomem(pstub,pstubstr,stubsz2)
-Add pstub stubsz2
-Data stubsz3#1
-Data stublength=stublength
-set stubsz3 stublength
-Sub stubsz3 stubsz2
-Sub stubsz3 stubsz
-Data pstubstrend^stubstrend
-Call memtomem(pstub,pstubstrend,stubsz3)
-
-Const fileheaderoffset^fileheader
-#IMAGE_FILE_HEADER
-#    WORD    Machine;
-#    WORD    NumberOfSections;
-#    DWORD   TimeDateStamp;
-#    DWORD   PointerToSymbolTable;
-#    DWORD   NumberOfSymbols;
-#    WORD    SizeOfOptionalHeader;
-#    WORD    Characteristics;
-
-Data pfileheader%fileheaderoffset
-
-Const IMAGE_FILE_MACHINE_I386=0x014C
-Data Machine=IMAGE_FILE_MACHINE_I386
-Set pfileheader# Machine
-
-Add pfileheader wordsize
-Const defaultNumberOfSections=2
-Data defaultNumberOfSections=defaultNumberOfSections
-Data ptrNumberOfSections#1
-Set ptrNumberOfSections pfileheader
-Set pfileheader# defaultNumberOfSections
-
-#TimeDateStamp
-Add pfileheader wordsize
-Set pfileheader# null
-
-#PointerToSymbolTable
-Add pfileheader dwordsize
-Set pfileheader# null
-
-#NumberOfSymbols
-Add pfileheader dwordsize
-Set pfileheader# null
-
-#SizeOfOptionalHeader
-Add pfileheader dwordsize
-Data SizeOfOptionalHeader=0xE0
-Set pfileheader# SizeOfOptionalHeader
-
-#Characteristics
-Add pfileheader wordsize
-Const IMAGE_FILE_DEBUG_STRIPPED=0x0200
-Const IMAGE_FILE_32BIT_MACHINE=0x0100
-Const IMAGE_FILE_LOCAL_SYMS_STRIPPED=0x0008
-Const IMAGE_FILE_LINE_NUMS_STRIPPED=0x0004
-Const IMAGE_FILE_EXECUTABLE_IMAGE=0x0002
-#exe specific
-Const IMAGE_FILE_RELOCS_STRIPPED=0x0001
-#dll specific
-#Const IMAGE_FILE_DLL=0x2000
-
-Const coffChrsGeneral=IMAGE_FILE_DEBUG_STRIPPED|IMAGE_FILE_32BIT_MACHINE|IMAGE_FILE_LOCAL_SYMS_STRIPPED|IMAGE_FILE_LINE_NUMS_STRIPPED|IMAGE_FILE_EXECUTABLE_IMAGE
-Const coffexeCharacteristics=coffChrsGeneral|IMAGE_FILE_RELOCS_STRIPPED
-Data coffexeCharacteristics=coffexeCharacteristics
-
-Data Characteristics#1
-Set Characteristics coffexeCharacteristics
-Data pchrctrs^Characteristics
-Call memtomem(pfileheader,pchrctrs,wordsize)
-
-#IMAGE_OPTIONAL_HEADER
-Data popthd^Magic
-Const IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b
-Data nt_opt_hd_magic=IMAGE_NT_OPTIONAL_HDR32_MAGIC
-Data ohm^nt_opt_hd_magic
-Call memtomem(popthd,ohm,wordsize)
-
-
-Data ptrtodllcharacteristics^DllCharacteristics
-Call memtomem(ptrtodllcharacteristics,ptrnull,wordsize)
-
-Data patdirs^directoryentries
-Data imgdirsSize=dwsz*imgdirsInts
-Call memset(patdirs,null,imgdirsSize)
--- /dev/null
+++ ocompiler-1/src/files/actions/main.oc
@@ -0,0 +1,165 @@
+
+
+Str content#1
+Str last#1
+Data contentoffsetinclude=contentoffileoff
+data contentlineinclude=lineoffile_offset
+
+data dot_comma_end#1;set dot_comma_end 0
+
+#data logbackup#1
+
+#backup prefs between passes, this can also be here: comline args, this, actions.oc
+#moved to after the format is set: call pref_store()
+
+set parses (pass_init)
+
+While includesReg!=null
+	Data cursorforincludes#1
+	Set cursorforincludes includes
+	Add cursorforincludes includesReg
+	Data sizeofincludeset=includesetSz
+	Sub cursorforincludes sizeofincludeset
+
+	Set contentoffile cursorforincludes#
+	If errormsg=noerr
+		if includemask=(TRUE)
+			set warningsbool (TRUE)
+		#else was not einclude or warns was off
+		endif
+
+		Add cursorforincludes dwordsize
+		call memtomem(#sizeoffile,cursorforincludes,(includesetSzData-dwsz))
+		Add cursorforincludes (includesetSzData-dwsz)
+
+		set ptrprevLineD# lineoffile
+
+		#Sub cursorforincludes includes
+		#Set nameofstoffile cursorforincludes
+
+		Set content contentoffile
+		Add content offsetoffile
+		Set last contentoffile
+		Add last sizeoffile
+
+		While content!=last
+			Include "./main/index.oc"
+			If errormsg=noerr
+				if parses=(pass_write)
+					if has_debug=(Yes)
+						setcall errormsg debug_lines(codesecReg,lineoffile,content,last)
+					endif
+				endif
+			EndIf
+			If errormsg!=noerr
+				#Str nameoffilewitherr#1
+				#Set nameoffilewitherr includes
+				#Add nameoffilewitherr nameofstoffile
+
+				Data columnoffile#1
+				Set columnoffile content
+				Sub columnoffile textlinestart
+
+				Add lineoffile one
+				Add columnoffile one
+
+				Data printbuffer#1
+
+				if totalnewlines=0
+					setcall printbuffer printbuf("%s File %s, Row %u, Column %u",errormsg,cursorforincludes,2,lineoffile,columnoffile)
+				else
+				#first textlinestart is lost at multilines command
+					setcall printbuffer printbuf("%s File %s, Row %u",errormsg,cursorforincludes,1,lineoffile)
+				endelse
+				If printbuffer=null
+					Call errexit()
+				EndIf
+				Call Message(printbuffer)
+				Call free(printbuffer)
+				Set content last
+			EndIf
+		EndWhile
+		If errormsg=noerr
+			setcall errormsg addtolog_withchar_parses("",fileendchar,(FALSE)) #also ok on win
+			if errormsg!=(noerror)
+				Call Message(errormsg)
+			elseif includedir=true
+				data int#1
+				setcall int chdir(contentoffile)
+				#0 success
+				if int!=chdirok
+					str restoredirerr="Restore folder error."
+					set errormsg restoredirerr
+					Call Message(errormsg)
+				endif
+			endelseif
+		endIf
+	EndIf
+
+	#this is used also inside index.oc
+	Sub includesReg sizeofincludeset
+
+	data skipfree#1
+	set skipfree 0
+	if includesReg=0
+		if parses!=(pass_write)
+			if errormsg=(noerror)
+				If innerfunction=true
+					Str endfnexp="ENDFUNCTION command expected to close the opened FUNCTION."
+					set errormsg endfnexp
+					Call Message(errormsg)
+				Else
+					if formatdefined=1
+					# a file with only comments, but cCOMMENT whitespaces is at pass write
+						call pref_restore()
+					endif
+					if parses=(pass_init)
+						set g_e_b_p# (FALSE)  #in case was set, for writes
+
+						set datasecSize datasecReg
+						set datasecReg 0
+						set nobitsDataStart datasecSize
+
+						#set logbackup logfile
+						#set logfile negative   #will reiterate tree. and will also have reusable,imports and constants
+
+						setcall errormsg align_alloc(functionTagIndex)
+						set parses (pass_calls)
+					else
+						call align_resolve()
+
+						setcall errormsg scopes_alloc(el_or_e,functionTagIndex)
+						set parses (pass_write)
+					endelse
+					if errormsg=(noerror)
+						#used when having multiple includes
+						data includescursor#1
+						set includescursor includes
+						add includescursor contentoffsetinclude
+						setcall includescursor# offsetoffile_value()
+						#
+						set includescursor includes
+						add includescursor contentlineinclude
+						set includescursor# 0
+						#
+						add includesReg sizeofincludeset
+
+						set skipfree 1
+
+						set functionTagIndex 0   #used after pass_init for alloc,through pass_calls,pass_write with scope/class store
+						#and scopes alloc
+					endif
+				EndElse
+			endif
+		endif
+	endif
+	if skipfree=0
+		Call free(contentoffile)
+	endif
+EndWhile
+
+#set logfile logbackup       #set for errexit, func/const at object, virtual, exit
+
+If errormsg!=noerr
+	Call errexit()
+EndIf
--- ocompiler-1.orig/src/files/actions/main.s
+++ /dev/null
@@ -1,165 +0,0 @@
-
-
-Str content#1
-Str last#1
-Data contentoffsetinclude=contentoffileoff
-data contentlineinclude=lineoffile_offset
-
-data dot_comma_end#1;set dot_comma_end 0
-
-#data logbackup#1
-
-#backup prefs between passes, this can also be here: comline args, this, actions.s
-#moved to after the format is set: call pref_store()
-
-set parses (pass_init)
-
-While includesReg!=null
-	Data cursorforincludes#1
-	Set cursorforincludes includes
-	Add cursorforincludes includesReg
-	Data sizeofincludeset=includesetSz
-	Sub cursorforincludes sizeofincludeset
-
-	Set contentoffile cursorforincludes#
-	If errormsg=noerr
-		if includemask=(TRUE)
-			set warningsbool (TRUE)
-		#else was not einclude or warns was off
-		endif
-
-		Add cursorforincludes dwordsize
-		call memtomem(#sizeoffile,cursorforincludes,(includesetSzData-dwsz))
-		Add cursorforincludes (includesetSzData-dwsz)
-
-		set ptrprevLineD# lineoffile
-
-		#Sub cursorforincludes includes
-		#Set nameofstoffile cursorforincludes
-
-		Set content contentoffile
-		Add content offsetoffile
-		Set last contentoffile
-		Add last sizeoffile
-
-		While content!=last
-			Include "./main/index.s"
-			If errormsg=noerr
-				if parses=(pass_write)
-					if has_debug=(Yes)
-						setcall errormsg debug_lines(codesecReg,lineoffile,content,last)
-					endif
-				endif
-			EndIf
-			If errormsg!=noerr
-				#Str nameoffilewitherr#1
-				#Set nameoffilewitherr includes
-				#Add nameoffilewitherr nameofstoffile
-
-				Data columnoffile#1
-				Set columnoffile content
-				Sub columnoffile textlinestart
-
-				Add lineoffile one
-				Add columnoffile one
-
-				Data printbuffer#1
-
-				if totalnewlines=0
-					setcall printbuffer printbuf("%s File %s, Row %u, Column %u",errormsg,cursorforincludes,2,lineoffile,columnoffile)
-				else
-				#first textlinestart is lost at multilines command
-					setcall printbuffer printbuf("%s File %s, Row %u",errormsg,cursorforincludes,1,lineoffile)
-				endelse
-				If printbuffer=null
-					Call errexit()
-				EndIf
-				Call Message(printbuffer)
-				Call free(printbuffer)
-				Set content last
-			EndIf
-		EndWhile
-		If errormsg=noerr
-			setcall errormsg addtolog_withchar_parses("",fileendchar,(FALSE)) #also ok on win
-			if errormsg!=(noerror)
-				Call Message(errormsg)
-			elseif includedir=true
-				data int#1
-				setcall int chdir(contentoffile)
-				#0 success
-				if int!=chdirok
-					str restoredirerr="Restore folder error."
-					set errormsg restoredirerr
-					Call Message(errormsg)
-				endif
-			endelseif
-		endIf
-	EndIf
-
-	#this is used also inside index.s
-	Sub includesReg sizeofincludeset
-
-	data skipfree#1
-	set skipfree 0
-	if includesReg=0
-		if parses!=(pass_write)
-			if errormsg=(noerror)
-				If innerfunction=true
-					Str endfnexp="ENDFUNCTION command expected to close the opened FUNCTION."
-					set errormsg endfnexp
-					Call Message(errormsg)
-				Else
-					if formatdefined=1
-					# a file with only comments, but cCOMMENT whitespaces is at pass write
-						call pref_restore()
-					endif
-					if parses=(pass_init)
-						set g_e_b_p# (FALSE)  #in case was set, for writes
-
-						set datasecSize datasecReg
-						set datasecReg 0
-						set nobitsDataStart datasecSize
-
-						#set logbackup logfile
-						#set logfile negative   #will reiterate tree. and will also have reusable,imports and constants
-
-						setcall errormsg align_alloc(functionTagIndex)
-						set parses (pass_calls)
-					else
-						call align_resolve()
-
-						setcall errormsg scopes_alloc(el_or_e,functionTagIndex)
-						set parses (pass_write)
-					endelse
-					if errormsg=(noerror)
-						#used when having multiple includes
-						data includescursor#1
-						set includescursor includes
-						add includescursor contentoffsetinclude
-						setcall includescursor# offsetoffile_value()
-						#
-						set includescursor includes
-						add includescursor contentlineinclude
-						set includescursor# 0
-						#
-						add includesReg sizeofincludeset
-
-						set skipfree 1
-
-						set functionTagIndex 0   #used after pass_init for alloc,through pass_calls,pass_write with scope/class store
-						#and scopes alloc
-					endif
-				EndElse
-			endif
-		endif
-	endif
-	if skipfree=0
-		Call free(contentoffile)
-	endif
-EndWhile
-
-#set logfile logbackup       #set for errexit, func/const at object, virtual, exit
-
-If errormsg!=noerr
-	Call errexit()
-EndIf
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index.oc
@@ -0,0 +1,337 @@
+
+sd comsize#1
+
+sd newlines
+sd totalnewlines=0
+
+Data pcontent^content
+Data pcomsize^comsize
+
+Str textlinestart#1
+if dot_comma_end=0
+	Set textlinestart content
+endif
+
+#test the line size and set the size of line break
+Char newline=asciireturn
+Data linebreaksize#1
+Set linebreaksize bytesize
+
+sd loop=2
+#set comsize 0
+
+#cursor for hidden whitespaces, this is different than textlinestart
+sd cursor_start
+ss pointer
+sd is_comment;sd is_comment_multiline
+
+setcall pointer command_start(#is_comment,#is_comment_multiline,#cursor_start,#content,last)
+while loop=2
+	if pointer=last
+		set loop 1
+		if is_comment!=0
+			if is_comment_multiline=0
+				setcall errormsg xfile_add_comment_ifif(content,pointer,(Xfile_comment))
+			else
+				setcall errormsg xfile_add_comment_multi_ifif(content,pointer)
+			endelse
+		endif
+	elseif pointer#=newline
+		set dot_comma_end 0   #a multiline comment can also be in a commands line
+		if is_comment_multiline=0
+			set loop 1
+			if pointer!=content
+				Char carriage=asciicarriage
+				ss testcontent
+				set testcontent pointer
+				dec testcontent
+				If testcontent#=carriage
+					#Dec comsize
+					set pointer testcontent
+					Inc linebreaksize
+				EndIf
+				if is_comment!=0
+					setcall errormsg xfile_add_comment_ifif(content,pointer,(Xfile_comment))
+				endif
+			endif
+		else
+			#like: #!line\nline\nline\n ! command
+			inc lineoffile
+			inc pointer
+			set textlinestart pointer
+			if pointer!=last
+				setcall pointer mem_spaces(pointer,last)
+				if pointer!=last
+					if pointer#=(asciiexclamationmark)
+						setcall errormsg xfile_add_comment_multi_ifif(content,pointer)
+						if errormsg!=(noerror)
+							set loop 1
+						else
+							inc pointer
+							set content pointer
+							setcall pointer command_start(#is_comment,#is_comment_multiline,#cursor_start,#content,last)
+						endelse
+					endif
+				endif
+			endif
+		endelse
+	elseif is_comment=0
+		if pointer#=(asciidoublequote)
+			setcall errormsg quotes_forward(#pointer,last,#newlines,#textlinestart)
+			if errormsg!=(noerror)
+				set loop 1
+			else
+				add totalnewlines newlines
+			endelse
+		elseif pointer#=(asciisemicolon)
+			set loop 1
+			set dot_comma_end 1
+		else
+			inc pointer
+		endelse
+	else
+		inc pointer
+	endelse
+endwhile
+if errormsg=(noerror)
+	set comsize pointer
+	sub comsize content
+	#\r\n case begin
+	#sub comsize linebreaksize
+	#inc comsize
+	#\r\n case end
+
+	ss was_whitespaces
+	If comsize!=0
+		Data pointtosearchat%compointersloc
+		SetCall commandset getcommand(pcontent,pcomsize,ptrsubtype,_errormsg,pointtosearchat)
+		If errormsg=noerr
+			if parses!=(pass_write)
+				if commandset!=(cCOMMENT)
+					if parses=(pass_init)
+						#tested at function gather; FORMAT is here starting with FUNCTIONX to set the mask knowing the format
+						if formatdefined=0
+							if commandset!=(cFORMAT)
+								setcall errormsg pe_init()
+								if errormsg=(noerror)
+									call backup_pref(#formatdefined)
+								else
+									set commandset (Error)
+								endelse
+							endif
+						endif
+						#needing to find virtual start
+						if commandset=(cDECLARE)
+						ElseIf commandset=(cPRIMSEC)
+						ElseIf commandset=(cONEARG)
+						Elseif commandset=(cCALL)
+						#before .dtnb: at object is difficult, there is no virtual, ostrip is in the project
+						elseIf commandset=(cIMPORTLINK) #needing importx here
+						elseif commandset=(cEND);ElseIf commandset=(cCONDITIONS)  #conditions to differ END at ENDFUNCTION or ENDcondition
+						elseif commandset=(cSTARTFUNCTION);elseif commandset=(cENDFUNCTION)
+						ElseIf commandset=(cLIBRARY)
+						elseif commandset=(cINCLUDELINK)
+						Elseif commandset=(cFORMAT)
+						Elseif commandset=(cDECLAREAFTERCALL)  #and import
+						elseif commandset=(cOVERRIDE)   #example underscore_pref
+						elseif commandset=(cORPHAN)    #for addaref
+						else;set commandset (cCOMMENT);endelse
+					else
+					#pass_calls
+						if commandset=(cDECLARE) #since not sub ebx 0 at start
+						elseIf commandset=(cPRIMSEC);elseif commandset=(cCALL)
+						elseif commandset=(cEND);ElseIf commandset=(cCONDITIONS)  #same as init
+						elseif commandset=(cINCLUDELINK);elseif commandset=(cENDFUNCTION)
+						elseif commandset=(cOVERRIDE)   #example call_align
+						else;set commandset (cCOMMENT);endelse
+					endelse
+				endif
+			else
+				set endfunction_has_write_marker (TRUE)  #why to loss space and write in every command when can write a default
+			endelse
+			if commandset=(cCOMMENT)
+				Call advancecursors(pcontent,pcomsize,comsize)
+				#1 is last
+				if parses=(pass_write) #at init and calls cCOMMENT istead of many commands
+					set was_whitespaces content;dec was_whitespaces;setcall was_whitespaces is_whitespace(was_whitespaces#)
+					if was_whitespaces=(TRUE)
+					#this is comment ending in whitespace
+						setcall errormsg warn_hidden_whitespaces(cursorforincludes) #includes,nameofstoffile)
+					endif
+				endif
+			ElseIf commandset=(cDECLARE)
+				setcall errormsg xfile_add_char_ifif((Xfile_declare))
+				If errormsg=(noerror)
+					setcall errormsg declare(pcontent,pcomsize,subtype,parses,p_is_for_64_value#)
+				endIf
+			ElseIf commandset=(cPRIMSEC)
+				Include "./index/primsec.oc"
+			ElseIf commandset=(cONEARG)
+				Include "./index/onearg.oc"
+			ElseIf commandset=(cCALL)
+				if parses=(pass_write)
+		call entryscope_verify_code()
+				endif
+				Include "./index/call.oc"
+			ElseIf commandset=(cEND)
+				Include "./index/end.oc"
+			ElseIf commandset=(cCONDITIONS)
+				if parses=(pass_write)
+		call entryscope_verify_code()
+				endif
+				Include "./index/conditions.oc"
+			ElseIf commandset=(cIMPORTLINK)
+				if parses=(pass_init);Include "./index/import.oc"
+				else;setcall errormsg xfile_add_import_if(pcontent,pcomsize,subtype);endelse
+			ElseIf commandset=(cSTARTFUNCTION)
+				Include "./index/function.oc"
+			ElseIf commandset=(cENDFUNCTION)
+				setcall errormsg endfunction(parses)
+			ElseIf commandset=(cRET)
+		call entryscope_verify_code()
+				setcall errormsg xfile_add_char_if((Xfile_ret));if errormsg=(noerror)
+					setcall errormsg writeret();endif
+			ElseIf commandset=(cINCLUDELINK)
+				Include "./index/include.oc"
+			ElseIf commandset=(cFORMAT)
+				if parses=(pass_init);Include "./index/format.oc"
+				else
+					Call advancecursors(pcontent,pcomsize,comsize)
+					setcall errormsg xfile_add_format_if(fileformat,ignore)
+				endelse
+			ElseIf commandset=(cDECLAREAFTERCALL)
+				if parses=(pass_write);Include "./index/aftercall.oc";
+				else;if subtype=(cAFTERCALL);add datasecReg (aftercalldeclaresize);endif
+					Call advancecursors(pcontent,pcomsize,comsize);endelse
+				set g_e_b_p# (TRUE)
+			ElseIf commandset=(cMANIPULATEAFTERCALL)
+				Include "./index/aftercallmanipulate.oc"
+			ElseIf commandset=(cCALLEX)
+		call entryscope_verify_code()
+				Include "./index/callex.oc"
+			ElseIf commandset=(cLIBRARY)
+				if parses=(pass_init);Include "./index/library.oc"
+				else;setcall errormsg xfile_add_library_if(pcontent,pcomsize);endelse
+			ElseIf commandset=(cHEX)
+		call entryscope_verify_code()
+				Include "./index/hex.oc"
+			ElseIf commandset=(cOVERRIDE)
+				#is at all, example at write hidden_pref
+				setcall errormsg override_com(#content,#comsize,parses)
+			ElseIf commandset=(cORPHAN)
+				Include "./index/warning.oc"
+			ElseIf commandset=(cI3)
+		call entryscope_verify_code()
+				Include "./index/i3.oc"
+			EndElseIf
+			#else commandset==(Error)
+			If errormsg=(noerror)
+				#set when code started
+				#this can be at line 0
+				If fnavailable=two
+					#retain the file and line where the main scope was started for functions separated from main code
+					#fnavailable two was set by code detectors
+
+					#Data currentfile#1
+					#Set currentfile includes
+					#Add currentfile nameofstoffile
+					Data sizeshortstr=shortstrsize
+					Call memtomem(ptrentrystartfile,cursorforincludes,sizeshortstr)
+
+					Set entrylinenumber lineoffile
+					Inc entrylinenumber
+
+					Set fnavailable zero
+				else
+					set endfunction_has_write endfunction_has_write_marker ##this is relevant only at pass_write
+				Endelse
+
+				If comsize!=zero
+					setcall was_whitespaces spaces(pcontent,pcomsize)
+					If comsize!=zero
+						if content#!=(commentascii)
+							Char _unreccomaftererr="Unrecognized data after command."
+							Str unreccomaftererr^_unreccomaftererr
+							Set errormsg unreccomaftererr
+						else
+							#this is comment after command
+							if xfile_sharp_comment!=0
+								call stepcursors(pcontent,pcomsize)
+								set xfile_sharp_comment 0
+							endif
+							setcall errormsg xfile_add_comment_ifif(content,pointer,(Xfile_commentlineend))
+							if errormsg=(noerror)
+								Call advancecursors(pcontent,pcomsize,comsize)
+							endif
+						endelse
+					elseIf was_whitespaces=(TRUE)
+						#mostly parses (pass_write), example: at cCALL is at all parses
+						#this is whitespace after command
+						#if parses==(pass_write) can be at init commands only, or write commands only, if all parses then extra code for wrongers (only at not w_as_e)
+						setcall errormsg warn_hidden_whitespaces_after(cursorforincludes,dot_comma_end) #includes,nameofstoffile
+					endelseIf
+				endIf
+			EndIf
+		EndIf
+	Elseif cursor_start!=content
+		#if parses==(pass_write) if all parses then extra code for wrongers (only at not w_as_e)
+		#this is only whitespace
+		setcall errormsg warn_hidden_whitespaces_after(cursorforincludes,dot_comma_end) #includes,nameofstoffile
+		#dot_comma_end check: is not like it accepts "    ;" but it accepts "...!    ;"
+		#endif
+	Endelseif
+
+	If errormsg=noerr
+		add lineoffile totalnewlines
+		#parse the line termination,then is the include that will retain the next line and advance to the next file
+		Data lineincrease#1
+		Set lineincrease zero
+		If content!=last
+			Add content linebreaksize
+			if dot_comma_end=0
+				Set lineincrease one
+			else
+				setcall errormsg xfile_add_char_ifif((Xfile_line))
+			endelse
+		EndIf
+		If errormsg=noerr
+			Add lineoffile lineincrease
+
+			#include next file
+			If includebool=one
+				Data inccursor#1
+				Set inccursor includes
+				Add inccursor includesReg
+
+				Sub inccursor sizeofincludeset
+
+				Add inccursor contentoffsetinclude
+				Data contentoffset#1
+				Set contentoffset content
+				Sub contentoffset contentoffile
+				Set inccursor# contentoffset
+				Add inccursor dwordsize
+
+				Set inccursor# lineoffile
+				SetCall errormsg include(miscbag,(FALSE),subtype)
+				If errormsg!=noerr
+					Set content textlinestart
+					Sub lineoffile lineincrease
+				Else
+					set ptrprevLineD# 0    #here 0, at main set back
+					Set content contentoffile
+					Set last content
+					Add content offsetoffile
+					Add last sizeoffile
+					Set miscbagReg zero
+					Set includebool zero
+
+					#and set for error informations
+					set cursorforincludes includes
+					add cursorforincludes includesReg
+					sub cursorforincludes (shortstrsize)
+				EndElse
+			EndIf
+		endif
+	EndIf
+endif
--- ocompiler-1.orig/src/files/actions/main/index.s
+++ /dev/null
@@ -1,332 +0,0 @@
-
-sd comsize#1
-
-sd newlines
-sd totalnewlines=0
-
-Data pcontent^content
-Data pcomsize^comsize
-
-Str textlinestart#1
-if dot_comma_end=0
-	Set textlinestart content
-endif
-
-#test the line size and set the size of line break
-Char newline=asciireturn
-Data linebreaksize#1
-Set linebreaksize bytesize
-
-sd loop=2
-#set comsize 0
-
-#cursor for hidden whitespaces, this is different than textlinestart
-sd cursor_start
-ss pointer
-sd is_comment;sd is_comment_multiline
-
-setcall pointer command_start(#is_comment,#is_comment_multiline,#cursor_start,#content,last)
-while loop=2
-	if pointer=last
-		set loop 1
-		if is_comment!=0
-			if is_comment_multiline=0
-				setcall errormsg xfile_add_comment_ifif(content,pointer,(Xfile_comment))
-			else
-				setcall errormsg xfile_add_comment_multi_ifif(content,pointer)
-			endelse
-		endif
-	elseif pointer#=newline
-		set dot_comma_end 0   #a multiline comment can also be in a commands line
-		if is_comment_multiline=0
-			set loop 1
-			if pointer!=content
-				Char carriage=asciicarriage
-				ss testcontent
-				set testcontent pointer
-				dec testcontent
-				If testcontent#=carriage
-					#Dec comsize
-					set pointer testcontent
-					Inc linebreaksize
-				EndIf
-				if is_comment!=0
-					setcall errormsg xfile_add_comment_ifif(content,pointer,(Xfile_comment))
-				endif
-			endif
-		else
-			#like: #!line\nline\nline\n ! command
-			inc lineoffile
-			inc pointer
-			set textlinestart pointer
-			if pointer!=last
-				setcall pointer mem_spaces(pointer,last)
-				if pointer!=last
-					if pointer#=(asciiexclamationmark)
-						setcall errormsg xfile_add_comment_multi_ifif(content,pointer)
-						if errormsg!=(noerror)
-							set loop 1
-						else
-							inc pointer
-							set content pointer
-							setcall pointer command_start(#is_comment,#is_comment_multiline,#cursor_start,#content,last)
-						endelse
-					endif
-				endif
-			endif
-		endelse
-	elseif is_comment=0
-		if pointer#=(asciidoublequote)
-			setcall errormsg quotes_forward(#pointer,last,#newlines,#textlinestart)
-			if errormsg!=(noerror)
-				set loop 1
-			else
-				add totalnewlines newlines
-			endelse
-		elseif pointer#=(asciisemicolon)
-			set loop 1
-			set dot_comma_end 1
-		else
-			inc pointer
-		endelse
-	else
-		inc pointer
-	endelse
-endwhile
-if errormsg=(noerror)
-	set comsize pointer
-	sub comsize content
-	#\r\n case begin
-	#sub comsize linebreaksize
-	#inc comsize
-	#\r\n case end
-
-	ss was_whitespaces
-	If comsize!=0
-		Data pointtosearchat%compointersloc
-		SetCall commandset getcommand(pcontent,pcomsize,ptrsubtype,_errormsg,pointtosearchat)
-		If errormsg=noerr
-			if parses!=(pass_write)
-				if commandset!=(cCOMMENT)
-					if parses=(pass_init)
-						#tested at function gather; FORMAT is here starting with FUNCTIONX to set the mask knowing the format
-						if formatdefined=0
-							if commandset!=(cFORMAT)
-								setcall errormsg pe_init()
-								if errormsg=(noerror)
-									call backup_pref(#formatdefined)
-								else
-									set commandset (Error)
-								endelse
-							endif
-						endif
-						#needing to find virtual start
-						if commandset=(cDECLARE)
-						ElseIf commandset=(cPRIMSEC)
-						ElseIf commandset=(cONEARG)
-						Elseif commandset=(cCALL)
-						#before .dtnb: at object is difficult, there is no virtual, ostrip is in the project
-						elseIf commandset=(cIMPORTLINK) #needing importx here
-						elseif commandset=(cEND);ElseIf commandset=(cCONDITIONS)  #conditions to differ END at ENDFUNCTION or ENDcondition
-						elseif commandset=(cSTARTFUNCTION);elseif commandset=(cENDFUNCTION)
-						ElseIf commandset=(cLIBRARY)
-						elseif commandset=(cINCLUDELINK)
-						Elseif commandset=(cFORMAT)
-						Elseif commandset=(cDECLAREAFTERCALL)  #and import
-						elseif commandset=(cOVERRIDE)   #example underscore_pref
-						elseif commandset=(cORPHAN)    #for addaref
-						else;set commandset (cCOMMENT);endelse
-					else
-					#pass_calls
-						If commandset=(cPRIMSEC);elseif commandset=(cCALL)
-						elseif commandset=(cEND);ElseIf commandset=(cCONDITIONS)  #same as init
-						elseif commandset=(cINCLUDELINK);elseif commandset=(cENDFUNCTION)
-						elseif commandset=(cOVERRIDE)   #example call_align
-						else;set commandset (cCOMMENT);endelse
-					endelse
-				endif
-			endif
-			if commandset=(cCOMMENT)
-				Call advancecursors(pcontent,pcomsize,comsize)
-				#1 is last
-				if parses=(pass_write) #at init and calls cCOMMENT istead of many commands
-					set was_whitespaces content;dec was_whitespaces;setcall was_whitespaces is_whitespace(was_whitespaces#)
-					if was_whitespaces=(TRUE)
-					#this is comment ending in whitespace
-						setcall errormsg warn_hidden_whitespaces(cursorforincludes) #includes,nameofstoffile)
-					endif
-				endif
-			ElseIf commandset=(cDECLARE)
-				setcall errormsg xfile_add_char_ifif((Xfile_declare))
-				If errormsg=(noerror)
-					setcall errormsg declare(pcontent,pcomsize,p_is_for_64_value#,subtype,parses)
-				endIf
-			ElseIf commandset=(cPRIMSEC)
-				Include "./index/primsec.s"
-			ElseIf commandset=(cONEARG)
-				Include "./index/onearg.s"
-			ElseIf commandset=(cCALL)
-				if parses=(pass_write)
-		call entryscope_verify_code()
-				endif
-				Include "./index/call.s"
-			ElseIf commandset=(cEND)
-				Include "./index/end.s"
-			ElseIf commandset=(cCONDITIONS)
-				if parses=(pass_write)
-		call entryscope_verify_code()
-				endif
-				Include "./index/conditions.s"
-			ElseIf commandset=(cIMPORTLINK)
-				if parses=(pass_init);Include "./index/import.s"
-				else;setcall errormsg xfile_add_import_if(pcontent,pcomsize,subtype);endelse
-			ElseIf commandset=(cSTARTFUNCTION)
-				Include "./index/function.s"
-			ElseIf commandset=(cENDFUNCTION)
-				setcall errormsg endfunction(parses)
-			ElseIf commandset=(cRET)
-		call entryscope_verify_code()
-				setcall errormsg xfile_add_char_if((Xfile_ret));if errormsg=(noerror)
-					setcall errormsg writeret();endif
-			ElseIf commandset=(cINCLUDELINK)
-				Include "./index/include.s"
-			ElseIf commandset=(cFORMAT)
-				if parses=(pass_init);Include "./index/format.s"
-				else
-					Call advancecursors(pcontent,pcomsize,comsize)
-					setcall errormsg xfile_add_format_if(fileformat,ignore)
-				endelse
-			ElseIf commandset=(cDECLAREAFTERCALL)
-				if parses=(pass_write);Include "./index/aftercall.s";
-				else;if subtype=(cAFTERCALL);add datasecReg (aftercalldeclaresize);endif
-					Call advancecursors(pcontent,pcomsize,comsize);endelse
-				set g_e_b_p# (TRUE)
-			ElseIf commandset=(cMANIPULATEAFTERCALL)
-				Include "./index/aftercallmanipulate.s"
-			ElseIf commandset=(cCALLEX)
-		call entryscope_verify_code()
-				Include "./index/callex.s"
-			ElseIf commandset=(cLIBRARY)
-				if parses=(pass_init);Include "./index/library.s"
-				else;setcall errormsg xfile_add_library_if(pcontent,pcomsize);endelse
-			ElseIf commandset=(cHEX)
-		call entryscope_verify_code()
-				Include "./index/hex.s"
-			ElseIf commandset=(cOVERRIDE)
-				#is at all, example at write hidden_pref
-				setcall errormsg override_com(#content,#comsize,parses)
-			ElseIf commandset=(cORPHAN)
-				Include "./index/warning.s"
-			ElseIf commandset=(cI3)
-		call entryscope_verify_code()
-				Include "./index/i3.s"
-			EndElseIf
-			#else commandset==(Error)
-			If errormsg=(noerror)
-				#set when code started
-				#this can be at line 0
-				If fnavailable=two
-					#retain the file and line where the main scope was started for functions separated from main code
-					#fnavailable two was set by code detectors
-
-					#Data currentfile#1
-					#Set currentfile includes
-					#Add currentfile nameofstoffile
-					Data sizeshortstr=shortstrsize
-					Call memtomem(ptrentrystartfile,cursorforincludes,sizeshortstr)
-
-					Set entrylinenumber lineoffile
-					Inc entrylinenumber
-
-					Set fnavailable zero
-				EndIf
-
-				If comsize!=zero
-					setcall was_whitespaces spaces(pcontent,pcomsize)
-					If comsize!=zero
-						if content#!=(commentascii)
-							Char _unreccomaftererr="Unrecognized data after command."
-							Str unreccomaftererr^_unreccomaftererr
-							Set errormsg unreccomaftererr
-						else
-							#this is comment after command
-							if xfile_sharp_comment!=0
-								call stepcursors(pcontent,pcomsize)
-								set xfile_sharp_comment 0
-							endif
-							setcall errormsg xfile_add_comment_ifif(content,pointer,(Xfile_commentlineend))
-							if errormsg=(noerror)
-								Call advancecursors(pcontent,pcomsize,comsize)
-							endif
-						endelse
-					elseIf was_whitespaces=(TRUE)
-						#mostly parses (pass_write), example: at cCALL is at all parses
-						#this is whitespace after command
-						#if parses==(pass_write) can be at init commands only, or write commands only, if all parses then extra code for wrongers (only at not w_as_e)
-						setcall errormsg warn_hidden_whitespaces_after(cursorforincludes,dot_comma_end) #includes,nameofstoffile
-					endelseIf
-				endIf
-			EndIf
-		EndIf
-	Elseif cursor_start!=content
-		#if parses==(pass_write) if all parses then extra code for wrongers (only at not w_as_e)
-		#this is only whitespace
-		setcall errormsg warn_hidden_whitespaces_after(cursorforincludes,dot_comma_end) #includes,nameofstoffile
-		#dot_comma_end check: is not like it accepts "    ;" but it accepts "...!    ;"
-		#endif
-	Endelseif
-
-	If errormsg=noerr
-		add lineoffile totalnewlines
-		#parse the line termination,then is the include that will retain the next line and advance to the next file
-		Data lineincrease#1
-		Set lineincrease zero
-		If content!=last
-			Add content linebreaksize
-			if dot_comma_end=0
-				Set lineincrease one
-			else
-				setcall errormsg xfile_add_char_ifif((Xfile_line))
-			endelse
-		EndIf
-		If errormsg=noerr
-			Add lineoffile lineincrease
-
-			#include next file
-			If includebool=one
-				Data inccursor#1
-				Set inccursor includes
-				Add inccursor includesReg
-
-				Sub inccursor sizeofincludeset
-
-				Add inccursor contentoffsetinclude
-				Data contentoffset#1
-				Set contentoffset content
-				Sub contentoffset contentoffile
-				Set inccursor# contentoffset
-				Add inccursor dwordsize
-
-				Set inccursor# lineoffile
-				SetCall errormsg include(miscbag,(FALSE),subtype)
-				If errormsg!=noerr
-					Set content textlinestart
-					Sub lineoffile lineincrease
-				Else
-					set ptrprevLineD# 0    #here 0, at main set back
-					Set content contentoffile
-					Set last content
-					Add content offsetoffile
-					Add last sizeoffile
-					Set miscbagReg zero
-					Set includebool zero
-
-					#and set for error informations
-					set cursorforincludes includes
-					add cursorforincludes includesReg
-					sub cursorforincludes (shortstrsize)
-				EndElse
-			EndIf
-		endif
-	EndIf
-endif
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/aftercall.oc
@@ -0,0 +1,70 @@
+
+#note that multiple calls on aftercall are tolerated and the next calls will use the last aftercall(can be used in a code strategy with multiple functions)
+
+const aftercalldeclaresize=1
+
+if comsize=0;set errormsg "AfterCall variable name expected."
+else
+	setcall errormsg xfile_add_char_if((Xfile_aftercall))
+	if errormsg=(noerror)
+		vstr ac_store_c#1;data ac_store_s#1
+		data acsym_value#1;data acsym_size#1;data acsym_shndx#1
+		sd g_e_p;setcall g_e_p global_err_p()
+		if subtype=(cAFTERCALLIMPORT)
+			If object=(FALSE);set errormsg "AfterCallImport is used at objects."
+			else
+				set ac_store_c content;set ac_store_s comsize
+				set acsym_value 0;set acsym_size (sym_with_size);set acsym_shndx (NULL)
+				setcall errormsg xfile_add_base_if((Xfile_aftercall_import),content,comsize)
+				call advancecursors(pcontent,pcomsize,comsize)
+			endelse
+		else
+		#(cAFTERCALL)
+			setcall errormsg xfile_add_char_if((Xfile_aftercall_declare))
+			if errormsg=(noerror)
+				sd ac_current_data
+				setcall ac_current_data get_img_vdata_dataReg()  #this must be before addtosec
+				SetCall errormsg addtosec(#null,(aftercalldeclaresize),ptrdatasec)
+				if errormsg=(noerror)
+					If object=(FALSE)
+						set g_e_p# ac_current_data
+					else
+						set acsym_value ac_current_data;set acsym_size 0;set acsym_shndx (dataind)
+					endelse
+					#size 0 test is above
+					if content#!=(unrefsign)
+						SetCall errormsg entryvarsfns(content,comsize)
+						if errormsg=(noerror)
+							setcall errormsg xfile_add_base_if((Xfile_declfeature_normal),content,comsize)
+							if errormsg=(noerror)
+								set ac_store_c content;set ac_store_s comsize
+								SetCall errormsg addaref(ac_current_data,pcontent,pcomsize,comsize,(charnumber),(dummy_mask))
+							endif
+						endif
+					else
+						#since aftercall(activate/clear)
+						call stepcursors(pcontent,pcomsize)
+						set ac_store_c (NULL);set ac_store_s 0
+						#              ok not "", is content!=null once and inside that libc memcpy
+						setcall errormsg xfile_add_base_if((Xfile_declfeature_unref),content,comsize)
+						call advancecursors(pcontent,pcomsize,comsize)
+					endelse
+				endif
+			endif
+		endelse
+		if errormsg=(noerror)
+			#set g_e_b_p# (TRUE)
+			if object=(TRUE)
+				set g_e_p# tableReg
+				if p_is_for_64_value#=(TRUE)
+					div g_e_p# (elf64_dyn_d_val_syment)
+				else
+					div g_e_p# elf32_dyn_d_val_syment
+				endelse
+				#adding at current names reg the content lenghting comsize
+				SetCall errormsg elfaddstrszsym(ac_store_c,ac_store_s,acsym_value,acsym_size,(STT_NOTYPE),(STB_GLOBAL),acsym_shndx,ptrtable)
+				#can be weak at linux but windows needs global and we agreed imports are global
+			endif
+		endif
+	endif
+endelse
--- ocompiler-1.orig/src/files/actions/main/index/aftercall.s
+++ /dev/null
@@ -1,70 +0,0 @@
-
-#note that multiple calls on aftercall are tolerated and the next calls will use the last aftercall(can be used in a code strategy with multiple functions)
-
-const aftercalldeclaresize=1
-
-if comsize=0;set errormsg "AfterCall variable name expected."
-else
-	setcall errormsg xfile_add_char_if((Xfile_aftercall))
-	if errormsg=(noerror)
-		vstr ac_store_c#1;data ac_store_s#1
-		data acsym_value#1;data acsym_size#1;data acsym_shndx#1
-		sd g_e_p;setcall g_e_p global_err_p()
-		if subtype=(cAFTERCALLIMPORT)
-			If object=(FALSE);set errormsg "AfterCallImport is used at objects."
-			else
-				set ac_store_c content;set ac_store_s comsize
-				set acsym_value 0;set acsym_size (sym_with_size);set acsym_shndx (NULL)
-				setcall errormsg xfile_add_base_if((Xfile_aftercall_import),content,comsize)
-				call advancecursors(pcontent,pcomsize,comsize)
-			endelse
-		else
-		#(cAFTERCALL)
-			setcall errormsg xfile_add_char_if((Xfile_aftercall_declare))
-			if errormsg=(noerror)
-				sd ac_current_data
-				setcall ac_current_data get_img_vdata_dataReg()  #this must be before addtosec
-				SetCall errormsg addtosec(#null,(aftercalldeclaresize),ptrdatasec)
-				if errormsg=(noerror)
-					If object=(FALSE)
-						set g_e_p# ac_current_data
-					else
-						set acsym_value ac_current_data;set acsym_size 0;set acsym_shndx (dataind)
-					endelse
-					#size 0 test is above
-					if content#!=(unrefsign)
-						SetCall errormsg entryvarsfns(content,comsize)
-						if errormsg=(noerror)
-							setcall errormsg xfile_add_base_if((Xfile_declfeature_normal),content,comsize)
-							if errormsg=(noerror)
-								set ac_store_c content;set ac_store_s comsize
-								SetCall errormsg addaref(ac_current_data,pcontent,pcomsize,comsize,(charnumber),(dummy_mask))
-							endif
-						endif
-					else
-						#since aftercall(activate/clear)
-						call stepcursors(pcontent,pcomsize)
-						set ac_store_c (NULL);set ac_store_s 0
-						#              ok not "", is content!=null once and inside that libc memcpy
-						setcall errormsg xfile_add_base_if((Xfile_declfeature_unref),content,comsize)
-						call advancecursors(pcontent,pcomsize,comsize)
-					endelse
-				endif
-			endif
-		endelse
-		if errormsg=(noerror)
-			#set g_e_b_p# (TRUE)
-			if object=(TRUE)
-				set g_e_p# tableReg
-				if p_is_for_64_value#=(TRUE)
-					div g_e_p# (elf64_dyn_d_val_syment)
-				else
-					div g_e_p# elf32_dyn_d_val_syment
-				endelse
-				#adding at current names reg the content lenghting comsize
-				SetCall errormsg elfaddstrszsym(ac_store_c,ac_store_s,acsym_value,acsym_size,(STT_NOTYPE),(STB_GLOBAL),acsym_shndx,ptrtable)
-				#can be weak at linux but windows needs global and we agreed imports are global
-			endif
-		endif
-	endif
-endelse
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/aftercallmanipulate.oc
@@ -0,0 +1,20 @@
+
+if g_e_b_p#=(FALSE)
+	set errormsg "AfterCall is not defined."
+else
+	setcall errormsg xfile_add_char_if((Xfile_aftercall))
+	if errormsg=(noerror)
+		sd acall_val
+		if subtype=(cAFTERCALLENABLE)
+			set acall_val (~aftercall_disable)
+			setcall errormsg xfile_add_char_if((Xfile_aftercall_enable))
+		else
+		#cAFTERCALLDISABLE
+			set acall_val (aftercall_disable)
+			setcall errormsg xfile_add_char_if((Xfile_aftercall_disable))
+		endelse
+		if errormsg=(noerror)
+			setcall errormsg aftercall_manipulate(acall_val)
+		endif
+	endif
+endelse
--- ocompiler-1.orig/src/files/actions/main/index/aftercallmanipulate.s
+++ /dev/null
@@ -1,20 +0,0 @@
-
-if g_e_b_p#=(FALSE)
-	set errormsg "AfterCall is not defined."
-else
-	setcall errormsg xfile_add_char_if((Xfile_aftercall))
-	if errormsg=(noerror)
-		sd acall_val
-		if subtype=(cAFTERCALLENABLE)
-			set acall_val (~aftercall_disable)
-			setcall errormsg xfile_add_char_if((Xfile_aftercall_enable))
-		else
-		#cAFTERCALLDISABLE
-			set acall_val (aftercall_disable)
-			setcall errormsg xfile_add_char_if((Xfile_aftercall_disable))
-		endelse
-		if errormsg=(noerror)
-			setcall errormsg aftercall_manipulate(acall_val)
-		endif
-	endif
-endelse
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/call.oc
@@ -0,0 +1,11 @@
+
+setcall errormsg xfile_add_callret_ifif((Xfile_call),subtype)
+if errormsg=(noerror)
+	Data callfn=callfunction
+	SetCall errormsg parsefunction(pcontent,pcomsize,callfn,subtype) #there are 2 more arguments but are not used
+	if parses=(pass_write)
+		if errormsg=(noerror)
+			setcall errormsg after_after_call(subtype)
+		endif
+	endif
+endif
--- ocompiler-1.orig/src/files/actions/main/index/call.s
+++ /dev/null
@@ -1,11 +0,0 @@
-
-setcall errormsg xfile_add_callret_ifif((Xfile_call),subtype)
-if errormsg=(noerror)
-	Data callfn=callfunction
-	SetCall errormsg parsefunction(pcontent,pcomsize,callfn,subtype) #there are 2 more arguments but are not used
-	if parses=(pass_write)
-		if errormsg=(noerror)
-			setcall errormsg after_after_call(subtype)
-		endif
-	endif
-endif
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/callex.oc
@@ -0,0 +1,55 @@
+
+setcall errormsg xfile_add_callret_if((Xfile_callex),subtype)
+if errormsg=(noerror)
+	sd call_sz
+	call arg_size(pcontent#,pcomsize#,#call_sz)
+	sd top_data
+	sd bool_indirect
+	setcall errormsg prepare_function_call(pcontent,pcomsize,call_sz,#top_data,#bool_indirect,subtype)
+	if errormsg=(noerror)
+		call spaces(pcontent,pcomsize)
+		setcall errormsg twoargs(pcontent,pcomsize,(cCALLEX_primsec),(NULL))
+		if errormsg=(noerror)
+			#
+			sd callex_data;sd callex_sz
+			const callex_regopcode=ecxregnumber*toregopcode
+			sd callex_bool;setcall callex_bool is_for_64()
+			if callex_bool=(TRUE)
+				sd callex64;setcall callex64 is_for_64_is_impX_or_fnX_get()
+				if callex64=(TRUE)
+					setcall errormsg callex64_call()
+				endif
+				if errormsg=(noerror)
+					const callex_x86_64_start=\
+					#same but with 2 rex, inc je, -2 jmp, and 3* at sib
+					char callex_x86_64={REX_Operand_64,0x81,0xf9,0,0,0,0,0x74,8,REX_Operand_64,0xFF,1*toregopcode|ecxregnumber|regregmod,0xff,6*toregopcode|espregnumber,3*tomod|callex_regopcode,0xEB,0xef}
+					set callex_sz (\-callex_x86_64_start);set callex_data #callex_x86_64
+				endif
+			else
+				const callex_start=\
+				# ## cmp ecx,0
+				char callex_i386={0x81,0xf9};data *=0
+				#je ###
+				char *={0x74};char *callex_je=7
+				#dec ecx
+				char *=0xFF;char *=1*toregopcode|ecxregnumber|0xc0
+				# push [eax+ecx*4]
+				char *callex_c2=0xff;char *=6*toregopcode|espregnumber;char *callex_sib=2*tomod|callex_regopcode
+				#jmp ##
+				char *=0xEB;char *callex_jmp=0xf1
+				#
+				set callex_sz (\-callex_start);set callex_data #callex_i386
+			endelse
+			#
+			if errormsg=(noerror)
+				SetCall errormsg addtosec(callex_data,callex_sz,ptrcodesec)
+				if errormsg=(noerror)
+					setcall errormsg write_function_call(top_data,bool_indirect,(TRUE),subtype)
+					if errormsg=(noerror)
+						setcall errormsg after_after_call(subtype)
+					endif
+				endif
+			endif
+		endif
+	endif
+endif
--- ocompiler-1.orig/src/files/actions/main/index/callex.s
+++ /dev/null
@@ -1,55 +0,0 @@
-
-setcall errormsg xfile_add_callret_if((Xfile_callex),subtype)
-if errormsg=(noerror)
-	sd call_sz
-	call arg_size(pcontent#,pcomsize#,#call_sz)
-	sd top_data
-	sd bool_indirect
-	setcall errormsg prepare_function_call(pcontent,pcomsize,call_sz,#top_data,#bool_indirect,subtype)
-	if errormsg=(noerror)
-		call spaces(pcontent,pcomsize)
-		setcall errormsg twoargs(pcontent,pcomsize,(cCALLEX_primsec),(NULL))
-		if errormsg=(noerror)
-			#
-			sd callex_data;sd callex_sz
-			const callex_regopcode=ecxregnumber*toregopcode
-			sd callex_bool;setcall callex_bool is_for_64()
-			if callex_bool=(TRUE)
-				sd callex64;setcall callex64 is_for_64_is_impX_or_fnX_get()
-				if callex64=(TRUE)
-					setcall errormsg callex64_call()
-				endif
-				if errormsg=(noerror)
-					const callex_x86_64_start=\
-					#same but with 2 rex, inc je, -2 jmp, and 3* at sib
-					char callex_x86_64={REX_Operand_64,0x81,0xf9,0,0,0,0,0x74,8,REX_Operand_64,0xFF,1*toregopcode|ecxregnumber|regregmod,0xff,6*toregopcode|espregnumber,3*tomod|callex_regopcode,0xEB,0xef}
-					set callex_sz (\-callex_x86_64_start);set callex_data #callex_x86_64
-				endif
-			else
-				const callex_start=\
-				# ## cmp ecx,0
-				char callex_i386={0x81,0xf9};data *=0
-				#je ###
-				char *={0x74};char *callex_je=7
-				#dec ecx
-				char *=0xFF;char *=1*toregopcode|ecxregnumber|0xc0
-				# push [eax+ecx*4]
-				char *callex_c2=0xff;char *=6*toregopcode|espregnumber;char *callex_sib=2*tomod|callex_regopcode
-				#jmp ##
-				char *=0xEB;char *callex_jmp=0xf1
-				#
-				set callex_sz (\-callex_start);set callex_data #callex_i386
-			endelse
-			#
-			if errormsg=(noerror)
-				SetCall errormsg addtosec(callex_data,callex_sz,ptrcodesec)
-				if errormsg=(noerror)
-					setcall errormsg write_function_call(top_data,bool_indirect,(TRUE),subtype)
-					if errormsg=(noerror)
-						setcall errormsg after_after_call(subtype)
-					endif
-				endif
-			endif
-		endif
-	endif
-endif
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/conditions.oc
@@ -0,0 +1,45 @@
+
+Data ifinscribe=ifinscribe
+Data ptrifinscribe^ifinscribe
+
+Data nocond=nocondnumber
+
+If subtype=(cIF)
+	SetCall errormsg addtosec(ptrifinscribe,dwordsize,ptrconditionsloops)
+	If errormsg=noerr
+		SetCall errormsg condbegin(pcontent,pcomsize,(ifnumber))
+	EndIf
+ElseIf subtype=(cENDIF)
+	SetCall errormsg conditionscondend((ifnumber),nocond)
+ElseIf subtype=(cELSE)
+	SetCall errormsg closeifopenelse()
+ElseIf subtype=(cENDELSE)
+	SetCall errormsg conditionscondend((elsenumber),nocond)
+ElseIf subtype=(cELSEIF)
+	SetCall errormsg closeifopenelse()
+	If errormsg=noerr
+		SetCall errormsg condbegin(pcontent,pcomsize,(ifnumber))
+	EndIf
+ElseIf subtype=(cENDELSEIF)
+	SetCall errormsg conditionscondend((ifnumber),(elsenumber))
+ElseIf subtype=(cWHILE)
+	SetCall errormsg coderegtocondloop()
+	If errormsg=noerr
+		SetCall errormsg condbegin(pcontent,pcomsize,(whilenumber))
+	EndIf
+ElseIf subtype=(cENDWHILE)
+	setcall errormsg whileend()
+Elseif parses=(pass_write)
+	If subtype=(cBREAK)
+		setcall errormsg xfile_add_char_if((Xfile_break))
+		If errormsg=noerr
+			setcall errormsg break()
+		EndIf
+	Else
+	#cCONTINUE
+		setcall errormsg xfile_add_char_if((Xfile_continue))
+		If errormsg=noerr
+			setcall errormsg continue()
+		EndIf
+	EndElse
+endelseif
--- ocompiler-1.orig/src/files/actions/main/index/conditions.s
+++ /dev/null
@@ -1,45 +0,0 @@
-
-Data ifinscribe=ifinscribe
-Data ptrifinscribe^ifinscribe
-
-Data nocond=nocondnumber
-
-If subtype=(cIF)
-	SetCall errormsg addtosec(ptrifinscribe,dwordsize,ptrconditionsloops)
-	If errormsg=noerr
-		SetCall errormsg condbegin(pcontent,pcomsize,(ifnumber))
-	EndIf
-ElseIf subtype=(cENDIF)
-	SetCall errormsg conditionscondend((ifnumber),nocond)
-ElseIf subtype=(cELSE)
-	SetCall errormsg closeifopenelse()
-ElseIf subtype=(cENDELSE)
-	SetCall errormsg conditionscondend((elsenumber),nocond)
-ElseIf subtype=(cELSEIF)
-	SetCall errormsg closeifopenelse()
-	If errormsg=noerr
-		SetCall errormsg condbegin(pcontent,pcomsize,(ifnumber))
-	EndIf
-ElseIf subtype=(cENDELSEIF)
-	SetCall errormsg conditionscondend((ifnumber),(elsenumber))
-ElseIf subtype=(cWHILE)
-	SetCall errormsg coderegtocondloop()
-	If errormsg=noerr
-		SetCall errormsg condbegin(pcontent,pcomsize,(whilenumber))
-	EndIf
-ElseIf subtype=(cENDWHILE)
-	setcall errormsg whileend()
-Elseif parses=(pass_write)
-	If subtype=(cBREAK)
-		setcall errormsg xfile_add_char_if((Xfile_break))
-		If errormsg=noerr
-			setcall errormsg break()
-		EndIf
-	Else
-	#cCONTINUE
-		setcall errormsg xfile_add_char_if((Xfile_continue))
-		If errormsg=noerr
-			setcall errormsg continue()
-		EndIf
-	EndElse
-endelseif
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/end.oc
@@ -0,0 +1,9 @@
+
+sd prev;sd second;setcall prev prev_cond(#second)
+if prev=(nocondnumber)
+	setcall errormsg endfunction(parses)
+elseif prev=(whilenumber)
+	setcall errormsg whileend()
+else
+	SetCall errormsg conditionscondend(prev,second)
+endelse
--- ocompiler-1.orig/src/files/actions/main/index/end.s
+++ /dev/null
@@ -1,9 +0,0 @@
-
-sd prev;sd second;setcall prev prev_cond(#second)
-if prev=(nocondnumber)
-	setcall errormsg endfunction(parses)
-elseif prev=(whilenumber)
-	setcall errormsg whileend()
-else
-	SetCall errormsg conditionscondend(prev,second)
-endelse
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/format.oc
@@ -0,0 +1,102 @@
+
+If formatdefined=1
+	Char nomoreformats="The FORMAT command can be defined at start and only once."
+	Str ptrnomoreformats^nomoreformats
+	Set errormsg ptrnomoreformats
+else
+	Data formatresponse#1
+
+	#exe format
+	Char exeformat="EXE"
+	Str ptrexeformat^exeformat
+	SetCall formatresponse stratmemspc(pcontent,pcomsize,ptrexeformat,false)
+
+	#elf format
+	If formatresponse=false
+		Char elfformat="ELF"
+		Str ptrelfformat^elfformat
+		SetCall formatresponse stratmemspc(pcontent,pcomsize,ptrelfformat,false)
+		If formatresponse=true
+			Set fileformat elf_unix
+			Char elfobjformat="OBJ"
+			Str ptrelfobjformat^elfobjformat
+			Data elfobjformresp#1
+
+			SetCall elfobjformresp stringsatmemspc(pcontent,pcomsize,ptrelfobjformat,false,"64",p_is_for_64_value,(NULL))
+			If elfobjformresp=true
+				sd is_so
+				set ignore (FALSE)
+				setcall is_so stratmemspc(pcontent,pcomsize,"SO",false)
+				if is_so=true
+					if ignore_format_so=(No)
+						set ignore (TRUE)
+						setcall errormsg addtolog_char((log_reusable),logfile)
+					endif
+				endif
+				If errormsg=noerr
+					if p_is_for_64_value#=(TRUE)
+						set convention_64 convention_64#
+						if convention_64=(ignore_convention_input)
+							set p_is_for_64_value# (FALSE)
+						else
+							call reloc64_init()
+							if convention_64=(direct_convention_input)
+								call convdata((convdata_init),(variable_convention))
+							#cross_convention_input
+							elseif (variable_convention)=(ms_convention)
+								call convdata((convdata_init),(lin_convention))
+							else
+								call convdata((convdata_init),(ms_convention))
+							endelse
+						endelse
+					endif
+					Set object true
+					SetCall errormsg elfaddstrsym(ptrnull,null,null,null,null,null,ptrtable)
+					If errormsg=noerr
+						Char elfdata=".data"
+						Str ptrelfdata^elfdata
+						Data dataind=dataind
+						Set datastrtab namesReg
+						SetCall errormsg elfaddstrsym(ptrelfdata,null,null,STT_SECTION,(STB_LOCAL),dataind,ptrtable)
+						If errormsg=noerr
+							Char elftext=".text"
+							Str ptrelftext^elftext
+							Data codeind=codeind
+							Set codestrtab namesReg
+							SetCall errormsg elfaddstrsym(ptrelftext,null,null,STT_SECTION,(STB_LOCAL),codeind,ptrtable)
+							sd totallocalsymsaddedatstart=3
+							If errormsg=noerr
+								if nobits_virtual=(Yes)
+									Set dtnbstrtab namesReg
+									SetCall errormsg elfaddstrsym(".dtnb",null,null,STT_SECTION,(STB_LOCAL),(dtnbind),ptrtable)
+									inc totallocalsymsaddedatstart
+								endif
+							EndIf
+						EndIf
+					EndIf
+					Set imagebaseoffset null
+					Set startofdata null
+				endif
+			Else
+				Data elf_imagebase=elf_imagebase
+				Set imagebaseoffset elf_imagebase
+
+				Set startofdata elf_startofdata
+
+				set nobits_virtual (No)  #.dtnb is not yet at exec format
+			EndElse
+		EndIf
+	Else
+		setcall errormsg pe_init()
+	EndElse
+
+	If errormsg=noerr
+		If formatresponse=false
+			Char unrecform="Unrecognized file format."
+			Str ptrunrecform^unrecform
+			Set errormsg ptrunrecform
+		else
+			call backup_pref(#formatdefined)
+		endelse
+	EndIf
+endelse
--- ocompiler-1.orig/src/files/actions/main/index/format.s
+++ /dev/null
@@ -1,102 +0,0 @@
-
-If formatdefined=1
-	Char nomoreformats="The FORMAT command can be defined at start and only once."
-	Str ptrnomoreformats^nomoreformats
-	Set errormsg ptrnomoreformats
-else
-	Data formatresponse#1
-
-	#exe format
-	Char exeformat="EXE"
-	Str ptrexeformat^exeformat
-	SetCall formatresponse stratmemspc(pcontent,pcomsize,ptrexeformat,false)
-
-	#elf format
-	If formatresponse=false
-		Char elfformat="ELF"
-		Str ptrelfformat^elfformat
-		SetCall formatresponse stratmemspc(pcontent,pcomsize,ptrelfformat,false)
-		If formatresponse=true
-			Set fileformat elf_unix
-			Char elfobjformat="OBJ"
-			Str ptrelfobjformat^elfobjformat
-			Data elfobjformresp#1
-
-			SetCall elfobjformresp stringsatmemspc(pcontent,pcomsize,ptrelfobjformat,false,"64",p_is_for_64_value,(NULL))
-			If elfobjformresp=true
-				sd is_so
-				set ignore (FALSE)
-				setcall is_so stratmemspc(pcontent,pcomsize,"SO",false)
-				if is_so=true
-					if ignore_format_so=(No)
-						set ignore (TRUE)
-						setcall errormsg addtolog_char((log_reusable),logfile)
-					endif
-				endif
-				If errormsg=noerr
-					if p_is_for_64_value#=(TRUE)
-						set convention_64 convention_64#
-						if convention_64=(ignore_convention_input)
-							set p_is_for_64_value# (FALSE)
-						else
-							call reloc64_init()
-							if convention_64=(direct_convention_input)
-								call convdata((convdata_init),(variable_convention))
-							#cross_convention_input
-							elseif (variable_convention)=(ms_convention)
-								call convdata((convdata_init),(lin_convention))
-							else
-								call convdata((convdata_init),(ms_convention))
-							endelse
-						endelse
-					endif
-					Set object true
-					SetCall errormsg elfaddstrsym(ptrnull,null,null,null,null,null,ptrtable)
-					If errormsg=noerr
-						Char elfdata=".data"
-						Str ptrelfdata^elfdata
-						Data dataind=dataind
-						Set datastrtab namesReg
-						SetCall errormsg elfaddstrsym(ptrelfdata,null,null,STT_SECTION,(STB_LOCAL),dataind,ptrtable)
-						If errormsg=noerr
-							Char elftext=".text"
-							Str ptrelftext^elftext
-							Data codeind=codeind
-							Set codestrtab namesReg
-							SetCall errormsg elfaddstrsym(ptrelftext,null,null,STT_SECTION,(STB_LOCAL),codeind,ptrtable)
-							sd totallocalsymsaddedatstart=3
-							If errormsg=noerr
-								if nobits_virtual=(Yes)
-									Set dtnbstrtab namesReg
-									SetCall errormsg elfaddstrsym(".dtnb",null,null,STT_SECTION,(STB_LOCAL),(dtnbind),ptrtable)
-									inc totallocalsymsaddedatstart
-								endif
-							EndIf
-						EndIf
-					EndIf
-					Set imagebaseoffset null
-					Set startofdata null
-				endif
-			Else
-				Data elf_imagebase=elf_imagebase
-				Set imagebaseoffset elf_imagebase
-
-				Set startofdata elf_startofdata
-
-				set nobits_virtual (No)  #.dtnb is not yet at exec format
-			EndElse
-		EndIf
-	Else
-		setcall errormsg pe_init()
-	EndElse
-
-	If errormsg=noerr
-		If formatresponse=false
-			Char unrecform="Unrecognized file format."
-			Str ptrunrecform^unrecform
-			Set errormsg ptrunrecform
-		else
-			call backup_pref(#formatdefined)
-		endelse
-	EndIf
-endelse
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/function.oc
@@ -0,0 +1,38 @@
+
+If innerfunction=true
+	Char finferr="There is already another function started."
+	Str ptrfinf^finferr
+	Set errormsg ptrfinf
+ElseIf programentrypoint!=codesecReg
+	Char funcafterentry="Unavailable FUNCTION/ENTRY[...] statement; The start address was at File: %s; Line: %s."
+	Str fnafteren^funcafterentry
+
+	call dwtomem(entrylinenumber,uint32s)
+	SetCall allocerrormsg printbuf(fnafteren,ptrentrystartfile,uint32s,0)
+	If allocerrormsg=null
+		Call errexit()
+	EndIf
+	Set errormsg allocerrormsg
+Else
+	sd varargs;set varargs subtype
+	and varargs (x_func_flag)
+	and subtype (~x_func_flag)
+
+	if subtype=(cENTRY);set el_or_e (TRUE)
+	elseif subtype=(cENTRYRAW);set el_or_e (TRUE)
+	else;set el_or_e (FALSE);endelse
+	If el_or_e=(TRUE)
+		#Data referencebit=referencebit
+		#Set objfnmask referencebit
+		if parses=(pass_write)
+			set fnavailable two
+		endif
+	Else
+		#Set objfnmask null
+		Set innerfunction true
+	EndElse
+	if errormsg=(noerror)
+		Data declarefn=declarefunction
+		SetCall errormsg parsefunction(pcontent,pcomsize,declarefn,subtype,el_or_e,varargs)
+	endif
+EndElse
--- ocompiler-1.orig/src/files/actions/main/index/function.s
+++ /dev/null
@@ -1,38 +0,0 @@
-
-If innerfunction=true
-	Char finferr="There is already another function started."
-	Str ptrfinf^finferr
-	Set errormsg ptrfinf
-ElseIf programentrypoint!=codesecReg
-	Char funcafterentry="Unavailable FUNCTION/ENTRY[...] statement; The start address was at File: %s; Line: %s."
-	Str fnafteren^funcafterentry
-
-	call dwtomem(entrylinenumber,uint32s)
-	SetCall allocerrormsg printbuf(fnafteren,ptrentrystartfile,uint32s,0)
-	If allocerrormsg=null
-		Call errexit()
-	EndIf
-	Set errormsg allocerrormsg
-Else
-	sd varargs;set varargs subtype
-	and varargs (x_func_flag)
-	and subtype (~x_func_flag)
-
-	if subtype=(cENTRY);set el_or_e (TRUE)
-	elseif subtype=(cENTRYRAW);set el_or_e (TRUE)
-	else;set el_or_e (FALSE);endelse
-	If el_or_e=(TRUE)
-		#Data referencebit=referencebit
-		#Set objfnmask referencebit
-		if parses=(pass_write)
-			set fnavailable two
-		endif
-	Else
-		#Set objfnmask null
-		Set innerfunction true
-	EndElse
-	if errormsg=(noerror)
-		Data declarefn=declarefunction
-		SetCall errormsg parsefunction(pcontent,pcomsize,declarefn,subtype,el_or_e,varargs)
-	endif
-EndElse
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/hex.oc
@@ -0,0 +1,8 @@
+
+setcall errormsg xfile_add_char_if((Xfile_hex))
+if errormsg=(noerror)
+	setcall errormsg enumcommas(pcontent,pcomsize,pcomsize#,(fndecandgroup),(charnumber),(NULL),(hexenum)) #there are 4 more arguments but are not used
+	if errormsg=(noerror)
+		setcall errormsg xfile_add_commas_if()
+	endif
+endif
--- ocompiler-1.orig/src/files/actions/main/index/hex.s
+++ /dev/null
@@ -1,8 +0,0 @@
-
-setcall errormsg xfile_add_char_if((Xfile_hex))
-if errormsg=(noerror)
-	setcall errormsg enumcommas(pcontent,pcomsize,pcomsize#,(fndecandgroup),(charnumber),(NULL),(hexenum)) #there are 4 more arguments but are not used
-	if errormsg=(noerror)
-		setcall errormsg xfile_add_commas_if()
-	endif
-endif
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/i3.oc
@@ -0,0 +1,7 @@
+
+SetCall errormsg xfile_add_char_if((Xfile_interrupt))
+if errormsg=(noerror)
+	Char interrupt={0xCC}
+	vStr ptrinterrupt^interrupt
+	SetCall errormsg addtosec(ptrinterrupt,bytesize,ptrcodesec)
+endif
--- ocompiler-1.orig/src/files/actions/main/index/i3.s
+++ /dev/null
@@ -1,7 +0,0 @@
-
-SetCall errormsg xfile_add_char_if((Xfile_interrupt))
-if errormsg=(noerror)
-	Char interrupt={0xCC}
-	vStr ptrinterrupt^interrupt
-	SetCall errormsg addtosec(ptrinterrupt,bytesize,ptrcodesec)
-endif
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/import.oc
@@ -0,0 +1,92 @@
+
+
+Data impquotsz#1
+Data impescapes#1
+Data ptrimpquotsz^impquotsz
+Data ptrimpescapes^impescapes
+
+If object=false
+	If implibsstarted=false
+		Char noliberr="Unexpected IMPORT statement; there is no LIBRARY opened."
+		Str ptrnoliberr^noliberr
+		Set errormsg ptrnoliberr
+	EndIf
+EndIf
+If errormsg=noerr
+	Data functionoffset#1
+
+	If fileformat=pe_exec
+		Set functionoffset addressesReg
+
+		Str ptrnamescurrentoffset^namesReg
+		SetCall errormsg addtosec(ptrnamescurrentoffset,dwordsize,ptraddresses)
+		If errormsg=noerr
+			SetCall errormsg addtosec(ptrnull,wordsize,ptrnames)
+		EndIf
+	Else
+		#get the last index for offset resolvations
+		If object=false
+			Set functionoffset addressesReg
+		Else
+			Set functionoffset tableReg
+		EndElse
+		#get the function index
+		If object=false
+			Div functionoffset elf32_dyn_d_val_syment
+			#get the dword offset to call at, index*dword
+			Mult functionoffset dwordsize
+			SetCall errormsg elfaddsym(namesReg,null,null,STT_FUNC,(STB_GLOBAL),null,ptraddresses)
+		ElseIf p_is_for_64_value#=(TRUE)
+			div functionoffset (elf64_dyn_d_val_syment)
+		Else
+			Div functionoffset elf32_dyn_d_val_syment
+		EndElse
+	EndElse
+	If errormsg=noerr
+		SetCall errormsg quotinmem(pcontent,pcomsize,ptrimpquotsz,ptrimpescapes)
+		If errormsg=noerr
+			Call import_leading_underscore(pcontent,pcomsize,ptrimpquotsz)
+			If object=true
+				#the sym entry
+				SetCall errormsg elfaddsym(namesReg,zero,(sym_with_size),STT_NOTYPE,(STB_GLOBAL),null,ptrtable)
+			EndIf
+			If errormsg=noerr
+				sd imp_mark;set imp_mark namesReg ##this is because the null at end makes code harder
+				SetCall errormsg addtosecstresc(pcontent,pcomsize,impquotsz,impescapes,ptrnames,true)
+				If errormsg=noerr
+					Call spaces(pcontent,pcomsize)
+					#after this will find var in vars/fns and if not add a new
+					sd imp_size;setcall imp_size find_whitespaceORcomment(content,comsize)
+					If imp_size=zero
+						Char missimportref="Import name for compiler must be specified after the name for output."
+						Str ptrimpref^missimportref
+						Set errormsg ptrimpref
+					Else
+						SetCall errormsg fnimp_exists(content,imp_size) #it is at first pass when only fns and imports are
+						If errormsg=noerr
+							if codeFnObj=(log_warn)
+								if subtype=(cIMPORT)
+									sub impquotsz impescapes
+									add imp_mark names
+									setcall errormsg addtolog_withchar_ex_atunused_handle(imp_mark,impquotsz,(log_import),logfile)
+								endif
+							endif
+							If errormsg=noerr
+								sd import_ref_mask=idatabitfunction
+								if subtype=(cIMPORTX)
+									or import_ref_mask (x86_64bit)
+								endif
+								if g_e_b_p#=(FALSE)
+									or import_ref_mask (aftercallthrowlessbit)
+								endif
+
+								Data functionsnr=functionsnumber
+								SetCall errormsg addaref(functionoffset,pcontent,pcomsize,imp_size,functionsnr,import_ref_mask)
+							endIf
+						EndIf
+					EndElse
+				EndIf
+			EndIf
+		EndIf
+	EndIf
+EndIf
--- ocompiler-1.orig/src/files/actions/main/index/import.s
+++ /dev/null
@@ -1,92 +0,0 @@
-
-
-Data impquotsz#1
-Data impescapes#1
-Data ptrimpquotsz^impquotsz
-Data ptrimpescapes^impescapes
-
-If object=false
-	If implibsstarted=false
-		Char noliberr="Unexpected IMPORT statement; there is no LIBRARY opened."
-		Str ptrnoliberr^noliberr
-		Set errormsg ptrnoliberr
-	EndIf
-EndIf
-If errormsg=noerr
-	Data functionoffset#1
-
-	If fileformat=pe_exec
-		Set functionoffset addressesReg
-
-		Str ptrnamescurrentoffset^namesReg
-		SetCall errormsg addtosec(ptrnamescurrentoffset,dwordsize,ptraddresses)
-		If errormsg=noerr
-			SetCall errormsg addtosec(ptrnull,wordsize,ptrnames)
-		EndIf
-	Else
-		#get the last index for offset resolvations
-		If object=false
-			Set functionoffset addressesReg
-		Else
-			Set functionoffset tableReg
-		EndElse
-		#get the function index
-		If object=false
-			Div functionoffset elf32_dyn_d_val_syment
-			#get the dword offset to call at, index*dword
-			Mult functionoffset dwordsize
-			SetCall errormsg elfaddsym(namesReg,null,null,STT_FUNC,(STB_GLOBAL),null,ptraddresses)
-		ElseIf p_is_for_64_value#=(TRUE)
-			div functionoffset (elf64_dyn_d_val_syment)
-		Else
-			Div functionoffset elf32_dyn_d_val_syment
-		EndElse
-	EndElse
-	If errormsg=noerr
-		SetCall errormsg quotinmem(pcontent,pcomsize,ptrimpquotsz,ptrimpescapes)
-		If errormsg=noerr
-			Call import_leading_underscore(pcontent,pcomsize,ptrimpquotsz)
-			If object=true
-				#the sym entry
-				SetCall errormsg elfaddsym(namesReg,zero,(sym_with_size),STT_NOTYPE,(STB_GLOBAL),null,ptrtable)
-			EndIf
-			If errormsg=noerr
-				sd imp_mark;set imp_mark namesReg ##this is because the null at end makes code harder
-				SetCall errormsg addtosecstresc(pcontent,pcomsize,impquotsz,impescapes,ptrnames,true)
-				If errormsg=noerr
-					Call spaces(pcontent,pcomsize)
-					#after this will find var in vars/fns and if not add a new
-					sd imp_size;setcall imp_size find_whitespaceORcomment(content,comsize)
-					If imp_size=zero
-						Char missimportref="Import name for compiler must be specified after the name for output."
-						Str ptrimpref^missimportref
-						Set errormsg ptrimpref
-					Else
-						SetCall errormsg fnimp_exists(content,imp_size) #it is at first pass when only fns and imports are
-						If errormsg=noerr
-							if codeFnObj=(log_warn)
-								if subtype=(cIMPORT)
-									sub impquotsz impescapes
-									add imp_mark names
-									setcall errormsg addtolog_withchar_ex_atunused_handle(imp_mark,impquotsz,(log_import),logfile)
-								endif
-							endif
-							If errormsg=noerr
-								sd import_ref_mask=idatabitfunction
-								if subtype=(cIMPORTX)
-									or import_ref_mask (x86_64bit)
-								endif
-								if g_e_b_p#=(FALSE)
-									or import_ref_mask (aftercallthrowlessbit)
-								endif
-
-								Data functionsnr=functionsnumber
-								SetCall errormsg addaref(functionoffset,pcontent,pcomsize,imp_size,functionsnr,import_ref_mask)
-							endIf
-						EndIf
-					EndElse
-				EndIf
-			EndIf
-		EndIf
-	EndIf
-EndIf
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/include.oc
@@ -0,0 +1,48 @@
+
+
+Data quotsz#1
+Data escapes#1
+Data pquotsz^quotsz
+Data pescapes^escapes
+
+SetCall errormsg xfile_add_char_ifif((Xfile_include))
+if errormsg=noerr
+	SetCall errormsg quotinmem(pcontent,pcomsize,pquotsz,pescapes) #there are: include "a a" "b b"
+	if errormsg=noerr
+		SetCall errormsg xfile_add_char_ifif(subtype)
+		if errormsg=noerr
+			if include_sec=(TRUE)
+				ss include_test
+				set include_test content
+				add include_test quotsz
+				inc include_test
+				setcall include_test mem_spaces(include_test,pointer)
+				if include_test!=pointer
+					if include_test#=(asciidoublequote)
+						SetCall errormsg addtosecstresc_xfile(pcontent,pcomsize,quotsz,escapes,ptrtempdata) #is ok with casts, at misc if set must set reg 0
+						if errormsg=noerr
+							sub include_test content
+							sub comsize include_test
+							add content include_test
+							SetCall errormsg quotinmem(pcontent,pcomsize,pquotsz,pescapes)
+							if errormsg=noerr
+								SetCall errormsg xfile_add_char_ifif((Xfile_include_alternative_yes))
+							endif
+						endif
+					else
+						setcall errormsg xfile_add_char_ifif((Xfile_include_alternative_no))
+					endelse
+				endif
+			endif
+			if errormsg=noerr
+				SetCall errormsg addtosecstresc_xfile(pcontent,pcomsize,quotsz,escapes,ptrmiscbag)
+				If errormsg=noerr
+					Set includebool one
+					if include_sec=(FALSE)
+						SetCall errormsg include_sec_skip(pcontent,pcomsize)
+					endif
+				EndIf
+			endif
+		endif
+	EndIf
+endif
--- ocompiler-1.orig/src/files/actions/main/index/include.s
+++ /dev/null
@@ -1,48 +0,0 @@
-
-
-Data quotsz#1
-Data escapes#1
-Data pquotsz^quotsz
-Data pescapes^escapes
-
-SetCall errormsg xfile_add_char_ifif((Xfile_include))
-if errormsg=noerr
-	SetCall errormsg quotinmem(pcontent,pcomsize,pquotsz,pescapes) #there are: include "a a" "b b"
-	if errormsg=noerr
-		SetCall errormsg xfile_add_char_ifif(subtype)
-		if errormsg=noerr
-			if include_sec=(TRUE)
-				ss include_test
-				set include_test content
-				add include_test quotsz
-				inc include_test
-				setcall include_test mem_spaces(include_test,pointer)
-				if include_test!=pointer
-					if include_test#=(asciidoublequote)
-						SetCall errormsg addtosecstresc_xfile(pcontent,pcomsize,quotsz,escapes,ptrtempdata) #is ok with casts, at misc if set must set reg 0
-						if errormsg=noerr
-							sub include_test content
-							sub comsize include_test
-							add content include_test
-							SetCall errormsg quotinmem(pcontent,pcomsize,pquotsz,pescapes)
-							if errormsg=noerr
-								SetCall errormsg xfile_add_char_ifif((Xfile_include_alternative_yes))
-							endif
-						endif
-					else
-						setcall errormsg xfile_add_char_ifif((Xfile_include_alternative_no))
-					endelse
-				endif
-			endif
-			if errormsg=noerr
-				SetCall errormsg addtosecstresc_xfile(pcontent,pcomsize,quotsz,escapes,ptrmiscbag)
-				If errormsg=noerr
-					Set includebool one
-					if include_sec=(FALSE)
-						SetCall errormsg include_sec_skip(pcontent,pcomsize)
-					endif
-				EndIf
-			endif
-		endif
-	EndIf
-endif
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/library.oc
@@ -0,0 +1,40 @@
+
+Data libquotsz#1
+Data libescapes#1
+Data ptrlibquotsz^libquotsz
+Data ptrlibescapes^libescapes
+
+If fileformat=pe_exec
+	If implibsstarted=true
+		SetCall errormsg closelib()
+	EndIf
+	If errormsg=noerr
+		SetCall errormsg openlib()
+	EndIf
+Else
+	If object=false
+		#Name of needed library offset
+		Data DT_NEEDED=1
+		Data d_un#1
+		Data ptr_d_tag^DT_NEEDED
+		Set d_un namesReg
+		SetCall errormsg addtosec(ptr_d_tag,sizeofElf32_Dyn,ptrtable)
+	Else
+		Char libatobj="LIBRARY statement is not used at object format."
+		Str ptrlibatobj^libatobj
+		Set errormsg ptrlibatobj
+	EndElse
+EndElse
+
+If errormsg=noerr
+	SetCall errormsg quotinmem(pcontent,pcomsize,ptrlibquotsz,ptrlibescapes)
+	If errormsg=noerr
+		SetCall errormsg addtosecstresc(pcontent,pcomsize,libquotsz,libescapes,ptrnames,true)
+		If errormsg=noerr
+			Set implibsstarted true
+		EndIf
+		#endif
+	EndIf
+EndIf
+
+
--- ocompiler-1.orig/src/files/actions/main/index/library.s
+++ /dev/null
@@ -1,40 +0,0 @@
-
-Data libquotsz#1
-Data libescapes#1
-Data ptrlibquotsz^libquotsz
-Data ptrlibescapes^libescapes
-
-If fileformat=pe_exec
-	If implibsstarted=true
-		SetCall errormsg closelib()
-	EndIf
-	If errormsg=noerr
-		SetCall errormsg openlib()
-	EndIf
-Else
-	If object=false
-		#Name of needed library offset
-		Data DT_NEEDED=1
-		Data d_un#1
-		Data ptr_d_tag^DT_NEEDED
-		Set d_un namesReg
-		SetCall errormsg addtosec(ptr_d_tag,sizeofElf32_Dyn,ptrtable)
-	Else
-		Char libatobj="LIBRARY statement is not used at object format."
-		Str ptrlibatobj^libatobj
-		Set errormsg ptrlibatobj
-	EndElse
-EndElse
-
-If errormsg=noerr
-	SetCall errormsg quotinmem(pcontent,pcomsize,ptrlibquotsz,ptrlibescapes)
-	If errormsg=noerr
-		SetCall errormsg addtosecstresc(pcontent,pcomsize,libquotsz,libescapes,ptrnames,true)
-		If errormsg=noerr
-			Set implibsstarted true
-		EndIf
-		#endif
-	EndIf
-EndIf
-
-
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/onearg.oc
@@ -0,0 +1,11 @@
+
+
+if parses=(pass_init)
+	setcall errormsg argument_init(pcontent,pcomsize,subtype)
+else
+	call entryscope_verify_code()
+	SetCall errormsg xfile_add_char_if((Xfile_action))
+	if errormsg=(noerror)
+		SetCall errormsg argument(pcontent,pcomsize,(FORWARD),subtype)
+	endif
+endelse
--- ocompiler-1.orig/src/files/actions/main/index/onearg.s
+++ /dev/null
@@ -1,11 +0,0 @@
-
-
-if parses=(pass_init)
-	setcall errormsg argument_init(pcontent,pcomsize,subtype)
-else
-	call entryscope_verify_code()
-	SetCall errormsg xfile_add_char_if((Xfile_action))
-	if errormsg=(noerror)
-		SetCall errormsg argument(pcontent,pcomsize,(FORWARD),subtype)
-	endif
-endelse
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/primsec.oc
@@ -0,0 +1,11 @@
+
+
+if parses!=(pass_write)
+	SetCall errormsg twoargs_ex(pcontent,pcomsize,subtype,null,(allow_later_sec),parses)
+else
+	call entryscope_verify_code()
+	SetCall errormsg xfile_add_char_if((Xfile_action2))
+	if errormsg=(noerror)
+		SetCall errormsg twoargs(pcontent,pcomsize,subtype,null)
+	endif
+endelse
--- ocompiler-1.orig/src/files/actions/main/index/primsec.s
+++ /dev/null
@@ -1,11 +0,0 @@
-
-
-if parses!=(pass_write)
-	SetCall errormsg twoargs_ex(pcontent,pcomsize,subtype,null,(allow_later_sec),parses)
-else
-	call entryscope_verify_code()
-	SetCall errormsg xfile_add_char_if((Xfile_action2))
-	if errormsg=(noerror)
-		SetCall errormsg twoargs(pcontent,pcomsize,subtype,null)
-	endif
-endelse
--- /dev/null
+++ ocompiler-1/src/files/actions/main/index/warning.oc
@@ -0,0 +1,19 @@
+
+setcall errormsg xfile_add_char_ifif((Xfile_orphan))
+if errormsg=(noerror)
+	Data warningsboolptr%ptrwarningsbool
+	sd warning_bool
+	setcall warning_bool stratmem(pcontent,pcomsize,"ON")
+	if warning_bool=(TRUE)
+		set warningsboolptr# (TRUE)
+		setcall errormsg xfile_add_char_ifif((Xfile_orphan_yes))
+	else
+		setcall warning_bool stratmem(pcontent,pcomsize,"OFF")
+		if warning_bool=(TRUE)
+			set warningsboolptr# (FALSE)
+			setcall errormsg xfile_add_char_ifif((Xfile_orphan_no))
+		else
+			set errormsg "Expecting 'on' or 'off' command"
+		endelse
+	endelse
+endif
--- ocompiler-1.orig/src/files/actions/main/index/warning.s
+++ /dev/null
@@ -1,19 +0,0 @@
-
-setcall errormsg xfile_add_char_ifif((Xfile_orphan))
-if errormsg=(noerror)
-	Data warningsboolptr%ptrwarningsbool
-	sd warning_bool
-	setcall warning_bool stratmem(pcontent,pcomsize,"ON")
-	if warning_bool=(TRUE)
-		set warningsboolptr# (TRUE)
-		setcall errormsg xfile_add_char_ifif((Xfile_orphan_yes))
-	else
-		setcall warning_bool stratmem(pcontent,pcomsize,"OFF")
-		if warning_bool=(TRUE)
-			set warningsboolptr# (FALSE)
-			setcall errormsg xfile_add_char_ifif((Xfile_orphan_no))
-		else
-			set errormsg "Expecting 'on' or 'off' command"
-		endelse
-	endelse
-endif
--- /dev/null
+++ ocompiler-1/src/files/actions/pathout.oc
@@ -0,0 +1,60 @@
+
+
+
+Str pointofpathout#1
+Data pathinsize#1
+Str minpath#1
+Str cursorpath#1
+Data unit=1
+
+Set minpath safecurrentdirloc
+
+Set pointofpathout safecurrentdirloc
+SetCall pathinsize strlen(safecurrentdirloc)
+Add pointofpathout pathinsize
+
+Set cursorpath pointofpathout
+Sub minpath unit
+Sub cursorpath unit
+
+While minpath!=cursorpath
+	Char teststr#1
+	Set teststr cursorpath#
+	If teststr=dot
+		Set pointofpathout cursorpath
+		Set cursorpath minpath
+	EndIf
+	If minpath!=cursorpath
+		Sub cursorpath unit
+	EndIf
+EndWhile
+
+Data extension#1
+Set extension null
+
+If fileformat=pe_exec
+	Char exe=".exe"
+	Str pexe^exe
+	Set extension pexe
+Else
+	If object=true
+		Char obj=".o"
+		Str pobj^obj
+		Set extension pobj
+	EndIf
+EndElse
+
+If extension!=null
+	Data sz#1
+	SetCall sz strlen(extension)
+
+	setcall errormsg maxpathverif(safecurrentdirtopath,extension)
+	if errormsg!=noerr
+		Call msgerrexit(errormsg)
+	endif
+
+	Call memtomem(pointofpathout,extension,sz)
+	Add pointofpathout sz
+EndIf
+
+Set pointofpathout# null
--- ocompiler-1.orig/src/files/actions/pathout.s
+++ /dev/null
@@ -1,60 +0,0 @@
-
-
-
-Str pointofpathout#1
-Data pathinsize#1
-Str minpath#1
-Str cursorpath#1
-Data unit=1
-
-Set minpath safecurrentdirloc
-
-Set pointofpathout safecurrentdirloc
-SetCall pathinsize strlen(safecurrentdirloc)
-Add pointofpathout pathinsize
-
-Set cursorpath pointofpathout
-Sub minpath unit
-Sub cursorpath unit
-
-While minpath!=cursorpath
-	Char teststr#1
-	Set teststr cursorpath#
-	If teststr=dot
-		Set pointofpathout cursorpath
-		Set cursorpath minpath
-	EndIf
-	If minpath!=cursorpath
-		Sub cursorpath unit
-	EndIf
-EndWhile
-
-Data extension#1
-Set extension null
-
-If fileformat=pe_exec
-	Char exe=".exe"
-	Str pexe^exe
-	Set extension pexe
-Else
-	If object=true
-		Char obj=".o"
-		Str pobj^obj
-		Set extension pobj
-	EndIf
-EndElse
-
-If extension!=null
-	Data sz#1
-	SetCall sz strlen(extension)
-
-	setcall errormsg maxpathverif(safecurrentdirtopath,extension)
-	if errormsg!=noerr
-		Call msgerrexit(errormsg)
-	endif
-
-	Call memtomem(pointofpathout,extension,sz)
-	Add pointofpathout sz
-EndIf
-
-Set pointofpathout# null
--- /dev/null
+++ ocompiler-1/src/files/actions/resolve.oc
@@ -0,0 +1,42 @@
+
+
+#the local calls (finalized)
+#data local calls (prepared)
+call localResolve(unresLocal,unresLocalReg)
+
+
+
+
+
+
+
+
+#resolve import at code, import at data, local at data
+data unresstruct#1
+Data unresoff#1
+data unresadd#1
+
+data unresstructure#1
+data ptrunresstructure^unresstructure
+
+Data unresptr#1
+Data unresptrlastpoint#1
+Set unresptrlastpoint unresolvedcallsReg
+Set unresptr unresolvedcalls
+add unresptrlastpoint unresolvedcalls
+While unresptr!=unresptrlastpoint
+	Set unresstruct unresptr#
+	call getcont(unresstruct,ptrunresstructure)
+
+	add unresptr dwordsize
+	Set unresoff unresptr#
+	add unresstructure unresoff
+
+	add unresptr dwordsize
+	set unresadd unresptr#
+	set unresadd unresadd#
+
+	add unresstructure# unresadd
+
+	Add unresptr dwordsize
+EndWhile
--- ocompiler-1.orig/src/files/actions/resolve.s
+++ /dev/null
@@ -1,42 +0,0 @@
-
-
-#the local calls (finalized)
-#data local calls (prepared)
-call localResolve(unresLocal,unresLocalReg)
-
-
-
-
-
-
-
-
-#resolve import at code, import at data, local at data
-data unresstruct#1
-Data unresoff#1
-data unresadd#1
-
-data unresstructure#1
-data ptrunresstructure^unresstructure
-
-Data unresptr#1
-Data unresptrlastpoint#1
-Set unresptrlastpoint unresolvedcallsReg
-Set unresptr unresolvedcalls
-add unresptrlastpoint unresolvedcalls
-While unresptr!=unresptrlastpoint
-	Set unresstruct unresptr#
-	call getcont(unresstruct,ptrunresstructure)
-
-	add unresptr dwordsize
-	Set unresoff unresptr#
-	add unresstructure unresoff
-
-	add unresptr dwordsize
-	set unresadd unresptr#
-	set unresadd unresadd#
-
-	add unresstructure# unresadd
-
-	Add unresptr dwordsize
-EndWhile
--- /dev/null
+++ ocompiler-1/src/files/actions/setdefdir.oc
@@ -0,0 +1,71 @@
+
+
+Char safedirdata="./"
+Str safedir^safedirdata
+
+Str filenameloc#1
+SetCall filenameloc endoffolders(path_nofree)
+Char storeachar#1
+Set storeachar filenameloc#
+Set filenameloc# null
+
+sd chdirresult#1
+setcall chdirresult changedir(path_nofree)
+if chdirresult!=chdirok
+	str startchdirerr="Cannot set active folder:"
+	setcall errormsg errorDefOut(startchdirerr,path_nofree)
+	Call msgerrexit(errormsg)
+endif
+
+
+Set filenameloc# storeachar
+
+Data movesize#1
+SetCall movesize strlen(filenameloc)
+Inc movesize
+
+setcall errormsg maxpathverif(filenameloc,safedir)
+if errormsg!=noerr
+	Call msgerrexit(errormsg)
+endif
+
+SetCall safecurrentdirtopath memalloc(flag_max_path)
+If safecurrentdirtopath=null
+	Call errexit()
+EndIf
+
+#files
+Set fileout (openno)
+set logfile (openno)
+set xfile (openno)
+
+#scopes and pass_calls
+set stackalign (NULL)
+set scopesbag (NULL)
+
+Call memtomem(safecurrentdirtopath,safedir,wordsize)
+Data safecurrentdirloc#1
+Set safecurrentdirloc safecurrentdirtopath
+Add safecurrentdirloc wordsize
+Call memtomem(safecurrentdirloc,filenameloc,movesize)
+
+if logbool=true
+	setcall errormsg openfile_write_add_extension(safecurrentdirtopath,".log",ptrlogfile)
+	if errormsg=noerr
+		sd log_main_folder
+		setcall log_main_folder getcwd((NULL),0)
+		if log_main_folder=(NULL)
+			char getcwd_first="first getcwd error"
+			set errormsg #getcwd_first
+		else
+			setcall errormsg addtolog_withchar_parses(log_main_folder,(log_pathfolder),(TRUE))
+			call free(log_main_folder)
+		endelse
+	endif
+endif
+if xbool!=(No)
+	setcall errormsg openfile_mode_add_extension(safecurrentdirtopath,".x",#xfile,(_open_readwrite))
+endif
+if errormsg!=noerr
+	Call msgerrexit(errormsg)
+endif
--- ocompiler-1.orig/src/files/actions/setdefdir.s
+++ /dev/null
@@ -1,71 +0,0 @@
-
-
-Char safedirdata="./"
-Str safedir^safedirdata
-
-Str filenameloc#1
-SetCall filenameloc endoffolders(path_nofree)
-Char storeachar#1
-Set storeachar filenameloc#
-Set filenameloc# null
-
-sd chdirresult#1
-setcall chdirresult changedir(path_nofree)
-if chdirresult!=chdirok
-	str startchdirerr="Cannot set active folder:"
-	setcall errormsg errorDefOut(startchdirerr,path_nofree)
-	Call msgerrexit(errormsg)
-endif
-
-
-Set filenameloc# storeachar
-
-Data movesize#1
-SetCall movesize strlen(filenameloc)
-Inc movesize
-
-setcall errormsg maxpathverif(filenameloc,safedir)
-if errormsg!=noerr
-	Call msgerrexit(errormsg)
-endif
-
-SetCall safecurrentdirtopath memalloc(flag_max_path)
-If safecurrentdirtopath=null
-	Call errexit()
-EndIf
-
-#files
-Set fileout (openno)
-set logfile (openno)
-set xfile (openno)
-
-#scopes and pass_calls
-set stackalign (NULL)
-set scopesbag (NULL)
-
-Call memtomem(safecurrentdirtopath,safedir,wordsize)
-Data safecurrentdirloc#1
-Set safecurrentdirloc safecurrentdirtopath
-Add safecurrentdirloc wordsize
-Call memtomem(safecurrentdirloc,filenameloc,movesize)
-
-if logbool=true
-	setcall errormsg openfile_write_add_extension(safecurrentdirtopath,".log",ptrlogfile)
-	if errormsg=noerr
-		sd log_main_folder
-		setcall log_main_folder getcwd((NULL),0)
-		if log_main_folder=(NULL)
-			char getcwd_first="first getcwd error"
-			set errormsg #getcwd_first
-		else
-			setcall errormsg addtolog_withchar_parses(log_main_folder,(log_pathfolder),(TRUE))
-			call free(log_main_folder)
-		endelse
-	endif
-endif
-if xbool!=(No)
-	setcall errormsg openfile_mode_add_extension(safecurrentdirtopath,".x",#xfile,(_open_readwrite))
-endif
-if errormsg!=noerr
-	Call msgerrexit(errormsg)
-endif
--- /dev/null
+++ ocompiler-1/src/files/actions/terminations.oc
@@ -0,0 +1,23 @@
+
+
+#verify that all conditions are closed
+SetCall errormsg checkcondloopclose()
+If errormsg!=noerr
+	Call msgerrexit(errormsg)
+EndIf
+
+#verify preferences
+sd err_bool
+setCall err_bool warnings(#errormsg,el_or_e)
+If errormsg!=noerr
+	if err_bool=(TRUE)
+		Call msgerrexit(errormsg)
+	endif
+	call errexit()
+EndIf
+
+#last entry for log file
+setcall errormsg addtolog_natural(datasecReg)
+if errormsg!=(noerror)
+	call msgerrexit(errormsg)
+endif
--- ocompiler-1.orig/src/files/actions/terminations.s
+++ /dev/null
@@ -1,23 +0,0 @@
-
-
-#verify that all conditions are closed
-SetCall errormsg checkcondloopclose()
-If errormsg!=noerr
-	Call msgerrexit(errormsg)
-EndIf
-
-#verify preferences
-sd err_bool
-setCall err_bool warnings(#errormsg,el_or_e)
-If errormsg!=noerr
-	if err_bool=(TRUE)
-		Call msgerrexit(errormsg)
-	endif
-	call errexit()
-EndIf
-
-#last entry for log file
-setcall errormsg addtolog_natural(datasecReg)
-if errormsg!=(noerror)
-	call msgerrexit(errormsg)
-endif
--- /dev/null
+++ ocompiler-1/src/files/actions/write.oc
@@ -0,0 +1,198 @@
+
+
+
+Data err#1
+
+SetCall err openfile(ptrfileout,safecurrentdirtopath,_open_write)
+If err!=noerr
+	Char fouterr="Error with the file out open function."
+	Str fileouterr^fouterr
+	Call msgerrexit(fileouterr)
+EndIf
+
+#headers
+Data writeres#1
+Data writefalse=writeno
+
+SetCall writeres writefile(fileout,fileheaders,sizefileheaders)
+If writeres=writefalse
+	Call errexit()
+EndIf
+If fileformat=elf_unix
+	If object=false
+		SetCall writeres writefile(fileout,elf_progdeffileheaders,elf_progdeffileheaders_size)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+		Add sizefileheaders elf_progdeffileheaders_size
+		If implibsstarted=true
+			SetCall writeres writefile(fileout,importfileheaders,sizeimportfileheaders)
+			If writeres=writefalse
+				Call errexit()
+			EndIf
+			Add sizefileheaders sizeimportfileheaders
+			#
+			#
+			SetCall errormsg elfaddsec_base(secstrs_off_atnames,0,0,null,null,0,0,0,0,null,ptrextra)
+			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+			SetCall errormsg elfaddsec_base(dynstr,(SHT_STRTAB),(SHF_ALLOC),elf_str_offset,elf32_dyn_d_val_strsz,0,0,bytesize,0,elf32_dyn_d_ptr_strtab,ptrextra)
+			#                                                   dynstr has alloc, the other str,no
+			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+			const SHT_DYNAMIC=6
+			SetCall errormsg elfaddsec_base(dynsec,(SHT_DYNAMIC),(SHF_WRITE|SHF_ALLOC),elf32_phdr_p_offset_dyn,elf32_phdr_p_filesz_dyn,1,0,elf32_phdr_p_align_dyn,qwordsize,elf32_phdr_p_vaddr_dyn,ptrextra)
+			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+			#
+			SetCall writeres writefile(fileout,extra,extraReg)
+			If writeres=writefalse;Call errexit();EndIf
+			Add sizefileheaders extraReg
+			#extra used nomore
+		Else
+			SetCall errormsg elfaddsecn()
+			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+			SetCall writeres writefile(fileout,miscbag,miscbagReg)
+			If writeres=writefalse;Call errexit();EndIf
+			Add sizefileheaders miscbagReg
+		EndElse
+	Else
+		SetCall writeres writefile(fileout,miscbag,miscbagReg)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+		Add sizefileheaders miscbagReg
+		#cannot see why i set this zero
+		#Set miscbagReg zero
+	EndElse
+EndIf
+
+SetCall writeres padsec(fileout,sizefileheaders,startofdata)
+If writeres=writefalse
+	Call errexit()
+EndIf
+
+Data writesecalignment#1
+Set writesecalignment page_sectionalignment
+If fileformat=elf_unix
+	Set writesecalignment one
+EndIf
+
+#data section
+SetCall writeres paddedwrite(fileout,datasec,datasecReg,writesecalignment)
+If writeres=writefalse
+	Call errexit()
+EndIf
+
+#code section
+SetCall writeres paddedwrite(fileout,codesec,codesecReg,writesecalignment)
+If writeres=writefalse
+	Call errexit()
+EndIf
+
+If object=true
+	#debug
+	if debugsecReg!=0
+		#has_debug is Yes
+		SetCall writeres writefile(fileout,debugsec,debugsecReg)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+	endif
+
+	#symtab
+	SetCall writeres writefile(fileout,table,tableReg)
+	If writeres=writefalse
+		Call errexit()
+	EndIf
+
+	#relocs
+	SetCall writeres writefile(fileout,addresses,addressesReg)
+	If writeres=writefalse
+		Call errexit()
+	EndIf
+	SetCall writeres writefile(fileout,extra,extraReg)
+	If writeres=writefalse
+		Call errexit()
+	EndIf
+
+	#strtab
+	SetCall writeres writefile(fileout,names,namesReg)
+	If writeres=writefalse
+		Call errexit()
+	EndIf
+ElseIf implibsstarted=true
+	#idata section
+	If fileformat=pe_exec
+		#table
+		SetCall writeres paddedwrite(fileout,table,tableReg,tableMax)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+		#addresses
+		SetCall writeres paddedwrite(fileout,addresses,addressesReg,addressesMax)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+		#names
+		SetCall writeres paddedwrite(fileout,names,namesReg,namesMax)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+	Else
+		#interpreter
+		SetCall writeres writefile(fileout,ptrinterpreter,interpretersize)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+
+		#dynamic
+		SetCall writeres writefile(fileout,table,tableReg)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+		Data ptrelf_dyn%elf_dynfix_start
+		SetCall writeres writefile(fileout,ptrelf_dyn,elf_dynfix_size)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+
+		#lib
+		##hashfix
+		Data ptrelf_hash%elf_hash_start
+		SetCall writeres writefile(fileout,ptrelf_hash,elf_hash_minsize)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+		##hashvar
+		Data elf_loop_write#1
+		Set elf_loop_write miscbag
+		SetCall writeres writefile(fileout,elf_loop_write,hash_var_size)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+		Add elf_loop_write hash_var_size
+
+		##symtab
+		SetCall writeres writefile(fileout,addresses,addressesReg)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+
+		##strtab
+		SetCall writeres writefile(fileout,names,namesReg)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+
+		##rel
+		SetCall writeres writefile(fileout,elf_loop_write,rel_var_size)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+		Add elf_loop_write rel_var_size
+
+		##calls
+		SetCall writeres writefile(fileout,elf_loop_write,elf_rel_entries_size)
+		If writeres=writefalse
+			Call errexit()
+		EndIf
+	EndElse
+EndElseIf
--- ocompiler-1.orig/src/files/actions/write.s
+++ /dev/null
@@ -1,198 +0,0 @@
-
-
-
-Data err#1
-
-SetCall err openfile(ptrfileout,safecurrentdirtopath,_open_write)
-If err!=noerr
-	Char fouterr="Error with the file out open function."
-	Str fileouterr^fouterr
-	Call msgerrexit(fileouterr)
-EndIf
-
-#headers
-Data writeres#1
-Data writefalse=writeno
-
-SetCall writeres writefile(fileout,fileheaders,sizefileheaders)
-If writeres=writefalse
-	Call errexit()
-EndIf
-If fileformat=elf_unix
-	If object=false
-		SetCall writeres writefile(fileout,elf_progdeffileheaders,elf_progdeffileheaders_size)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-		Add sizefileheaders elf_progdeffileheaders_size
-		If implibsstarted=true
-			SetCall writeres writefile(fileout,importfileheaders,sizeimportfileheaders)
-			If writeres=writefalse
-				Call errexit()
-			EndIf
-			Add sizefileheaders sizeimportfileheaders
-			#
-			#
-			SetCall errormsg elfaddsec_base(secstrs_off_atnames,0,0,null,null,0,0,0,0,null,ptrextra)
-			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
-			SetCall errormsg elfaddsec_base(dynstr,(SHT_STRTAB),(SHF_ALLOC),elf_str_offset,elf32_dyn_d_val_strsz,0,0,bytesize,0,elf32_dyn_d_ptr_strtab,ptrextra)
-			#                                                   dynstr has alloc, the other str,no
-			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
-			const SHT_DYNAMIC=6
-			SetCall errormsg elfaddsec_base(dynsec,(SHT_DYNAMIC),(SHF_WRITE|SHF_ALLOC),elf32_phdr_p_offset_dyn,elf32_phdr_p_filesz_dyn,1,0,elf32_phdr_p_align_dyn,qwordsize,elf32_phdr_p_vaddr_dyn,ptrextra)
-			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
-			#
-			SetCall writeres writefile(fileout,extra,extraReg)
-			If writeres=writefalse;Call errexit();EndIf
-			Add sizefileheaders extraReg
-			#extra used nomore
-		Else
-			SetCall errormsg elfaddsecn()
-			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
-			SetCall writeres writefile(fileout,miscbag,miscbagReg)
-			If writeres=writefalse;Call errexit();EndIf
-			Add sizefileheaders miscbagReg
-		EndElse
-	Else
-		SetCall writeres writefile(fileout,miscbag,miscbagReg)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-		Add sizefileheaders miscbagReg
-		#cannot see why i set this zero
-		#Set miscbagReg zero
-	EndElse
-EndIf
-
-SetCall writeres padsec(fileout,sizefileheaders,startofdata)
-If writeres=writefalse
-	Call errexit()
-EndIf
-
-Data writesecalignment#1
-Set writesecalignment page_sectionalignment
-If fileformat=elf_unix
-	Set writesecalignment one
-EndIf
-
-#data section
-SetCall writeres paddedwrite(fileout,datasec,datasecReg,writesecalignment)
-If writeres=writefalse
-	Call errexit()
-EndIf
-
-#code section
-SetCall writeres paddedwrite(fileout,codesec,codesecReg,writesecalignment)
-If writeres=writefalse
-	Call errexit()
-EndIf
-
-If object=true
-	#debug
-	if debugsecReg!=0
-		#has_debug is Yes
-		SetCall writeres writefile(fileout,debugsec,debugsecReg)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-	endif
-
-	#symtab
-	SetCall writeres writefile(fileout,table,tableReg)
-	If writeres=writefalse
-		Call errexit()
-	EndIf
-
-	#relocs
-	SetCall writeres writefile(fileout,addresses,addressesReg)
-	If writeres=writefalse
-		Call errexit()
-	EndIf
-	SetCall writeres writefile(fileout,extra,extraReg)
-	If writeres=writefalse
-		Call errexit()
-	EndIf
-
-	#strtab
-	SetCall writeres writefile(fileout,names,namesReg)
-	If writeres=writefalse
-		Call errexit()
-	EndIf
-ElseIf implibsstarted=true
-	#idata section
-	If fileformat=pe_exec
-		#table
-		SetCall writeres paddedwrite(fileout,table,tableReg,tableMax)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-		#addresses
-		SetCall writeres paddedwrite(fileout,addresses,addressesReg,addressesMax)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-		#names
-		SetCall writeres paddedwrite(fileout,names,namesReg,namesMax)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-	Else
-		#interpreter
-		SetCall writeres writefile(fileout,ptrinterpreter,interpretersize)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-
-		#dynamic
-		SetCall writeres writefile(fileout,table,tableReg)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-		Data ptrelf_dyn%elf_dynfix_start
-		SetCall writeres writefile(fileout,ptrelf_dyn,elf_dynfix_size)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-
-		#lib
-		##hashfix
-		Data ptrelf_hash%elf_hash_start
-		SetCall writeres writefile(fileout,ptrelf_hash,elf_hash_minsize)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-		##hashvar
-		Data elf_loop_write#1
-		Set elf_loop_write miscbag
-		SetCall writeres writefile(fileout,elf_loop_write,hash_var_size)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-		Add elf_loop_write hash_var_size
-
-		##symtab
-		SetCall writeres writefile(fileout,addresses,addressesReg)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-
-		##strtab
-		SetCall writeres writefile(fileout,names,namesReg)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-
-		##rel
-		SetCall writeres writefile(fileout,elf_loop_write,rel_var_size)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-		Add elf_loop_write rel_var_size
-
-		##calls
-		SetCall writeres writefile(fileout,elf_loop_write,elf_rel_entries_size)
-		If writeres=writefalse
-			Call errexit()
-		EndIf
-	EndElse
-EndElseIf
--- /dev/null
+++ ocompiler-1/src/files/functions.oc
@@ -0,0 +1,62 @@
+
+Include "./functions/inits.oc"
+
+Include "./functions/commons/comfn.oc"
+Include "./functions/commons/base.oc"
+Include "./functions/commons/vars.oc"
+Include "./functions/commons/strcommons.oc"
+Include "./functions/commons/valinmem.oc"
+Include "./functions/commons/getcommand.oc"
+
+Include "./functions/add/addtomem.oc"
+Include "./functions/add/add.oc"
+Include "./functions/add/addstresc.oc"
+
+Include "./functions/values/numbersandconstants.oc"
+Include "./functions/values/operations.oc"
+
+Include "./functions/elf/elf.oc"
+
+Include "./functions/stack/stack_inits.oc"
+
+Include "./functions/argument/comwrite.oc"
+Include "./functions/argument/imm.oc"
+Include "./functions/argument/arg.oc"
+Include "./functions/argument/argument.oc"
+
+Include "./functions/stack/stack.oc"
+
+Include "./functions/global/funcs.oc"
+Include "./functions/global/end.oc"
+
+Include "./functions/actions/dataparse.oc"
+Include "./functions/actions/fndecargs.oc"
+Include "./functions/actions/enumcomma.oc"
+Include "./functions/actions/fn.oc"
+Include "./functions/actions/argstwo.oc"
+Include "./functions/actions/declare.oc"
+
+Include "./functions/commands/cond.oc"
+Include "./functions/commands/lib.oc"
+Include "./functions/commands/ret.oc"
+
+Include "./functions/pref/preffuncs.oc"
+Include "./functions/pref/sdsv.oc"
+Include "./functions/pref/backup.oc"
+
+Include "./functions/64/bit.oc"
+Include "./functions/64/reloc.oc"
+Include "./functions/64/align.oc"
+
+Include "./functions/include.oc"
+Include "./functions/dataassign.oc"
+Include "./functions/enumbags.oc"
+Include "./functions/import.oc"
+Include "./functions/override.oc"
+Include "./functions/scopes.oc"
+Include "./functions/debug.oc"
+Include "./functions/index.oc"
+Include "./functions/short.oc"
+
+Include "./functions/xfile.oc"
+Include "./functions/xfile_details.oc"
--- ocompiler-1.orig/src/files/functions.s
+++ /dev/null
@@ -1,62 +0,0 @@
-
-Include "./functions/inits.s"
-
-Include "./functions/commons/comfn.s"
-Include "./functions/commons/base.s"
-Include "./functions/commons/vars.s"
-Include "./functions/commons/strcommons.s"
-Include "./functions/commons/valinmem.s"
-Include "./functions/commons/getcommand.s"
-
-Include "./functions/add/addtomem.s"
-Include "./functions/add/add.s"
-Include "./functions/add/addstresc.s"
-
-Include "./functions/values/numbersandconstants.s"
-Include "./functions/values/operations.s"
-
-Include "./functions/elf/elf.s"
-
-Include "./functions/stack/stack_inits.s"
-
-Include "./functions/argument/comwrite.s"
-Include "./functions/argument/imm.s"
-Include "./functions/argument/arg.s"
-Include "./functions/argument/argument.s"
-
-Include "./functions/stack/stack.s"
-
-Include "./functions/global/funcs.s"
-Include "./functions/global/end.s"
-
-Include "./functions/actions/dataparse.s"
-Include "./functions/actions/fndecargs.s"
-Include "./functions/actions/enumcomma.s"
-Include "./functions/actions/fn.s"
-Include "./functions/actions/argstwo.s"
-Include "./functions/actions/declare.s"
-
-Include "./functions/commands/cond.s"
-Include "./functions/commands/lib.s"
-Include "./functions/commands/ret.s"
-
-Include "./functions/pref/preffuncs.s"
-Include "./functions/pref/sdsv.s"
-Include "./functions/pref/backup.s"
-
-Include "./functions/64/bit.s"
-Include "./functions/64/reloc.s"
-Include "./functions/64/align.s"
-
-Include "./functions/include.s"
-Include "./functions/dataassign.s"
-Include "./functions/enumbags.s"
-Include "./functions/import.s"
-Include "./functions/override.s"
-Include "./functions/scopes.s"
-Include "./functions/debug.s"
-Include "./functions/index.s"
-Include "./functions/short.s"
-
-Include "./functions/xfile.s"
-Include "./functions/xfile_details.s"
--- /dev/null
+++ ocompiler-1/src/files/functions/64/align.oc
@@ -0,0 +1,198 @@
+
+value stackalign#1
+data *stackalign_size#1
+const ptrstackalign^stackalign
+
+const align_calculation_size=dwsz
+const function_calculation_sz=align_calculation_size+1   #1 for has stack variables
+
+#er
+function align_alloc(sd sz)
+	inc sz   ##for entry
+	mult sz (function_calculation_sz)
+	sv s%ptrstackalign
+	setcall s# memcalloc(sz) #need 0 by default
+	if s#!=(NULL)
+		add s :
+		set s#d^ sz
+		return (noerror)
+	endif
+	return (error)
+endfunction
+function align_free()
+	sv s%ptrstackalign
+	if s#!=(NULL)
+		call free(s#)
+	endif
+endfunction
+
+#er
+function stack_align(sd nr)
+	sd final_nr
+	setcall final_nr pref_call_align(nr)
+	if final_nr!=0
+		and final_nr 1
+		sd type;setcall type align_type()
+		if type=(even_align)
+			if final_nr=0
+				return (noerror)
+			endif
+		elseif   final_nr!=0
+				return (noerror)
+		endelseif
+		#Stack aligned on 16 bytes. Depending on the number of arguments
+		vdata code%%ptr_codesec
+		char align={REX_Operand_64,0x83,0xEC,8}
+		sd err
+		SetCall err addtosec(#align,(4),code)
+		return err
+	endif
+	return (noerror)
+endfunction
+#0/2/nr
+function pref_call_align(sd nr)
+	data ptr_call_align%ptr_call_align
+	sd type;set type ptr_call_align#
+	if type!=(call_align_no)
+	#1. was a debate at "yes for args and shadow", the point was to ignore shadow and align only the pushed args at next option "yes for args", example:
+	#    1 pushed, counting shadow will align like 5 odd arguments, not counting shadow like 1 odd argument
+	#    2 pushed, 6 even arguments, 2 even arguments
+	#   is same with or without this option because shadow is even
+	#2. another debate can be at no pushed args and shadow odd but is not the case
+		sd conv;setcall conv convdata((convdata_total))
+		if nr<=conv
+			if type=(call_align_yes_all)
+				return 2             #0 will not align, to align even, lin 6 even, win 4(also here is the shadow that is same, 4), args are on regs. was tested for <=conv
+			endif
+			#call_align_yes_pushedArgs
+		else
+			return nr                  ##convs are even, so nr-=conv is same
+		endelse
+	endif
+	return 0
+endfunction
+
+
+#err
+function align_ante(sd arguments)
+	setcall arguments pref_call_align(arguments)
+	if arguments!=0
+		sd pointer
+		#sd container%ptrstackAlign
+		#wanting with three pass, the impXorfnX is not ready at first pass: call getcontplusReg(container,#pointer)
+		#sub pointer (dwsz)
+		#test if in a function
+		#sd fnboolptr%globalinnerfunction
+		#if fnboolptr#==(TRUE)
+		#	sub pointer (dwsz)
+		#endif
+		setcall pointer align_ptype()
+		sd test=1;and test arguments
+		sd test2=0xffFF
+		if test=0
+		#even, put on low word
+			inc pointer#
+			and test2 pointer#
+			if test2!=0
+				return (noerror)
+			endif
+			return "More than 65535 even calls?"
+		endif
+		#odd, put on high word
+		sd bag;set bag pointer#
+		divu bag 0x10000
+		inc bag
+		and test2 bag
+		if test2!=0
+			#set to high word
+			#this is not endian independent add pointer (wsz)
+			#and pointer#s^ bag
+			#or pointer#s^ bag
+			#div bag 0x100
+			#inc pointer
+			#and pointer#s^ bag
+			#or pointer#s^ bag
+
+			mult bag 0x10000
+			and pointer# (0xffFF)
+			or pointer# bag
+			return (noerror)
+		endif
+		return "More than 65535 odd calls?"
+	endif
+	return (noerror)
+endfunction
+
+function align_resolve()
+	sv end%ptrstackalign
+	sd pointer;set pointer end#
+	add end :
+	set end end#d^
+	add end pointer
+	while pointer!=end
+		sd bag;set bag pointer#
+		if bag!=0
+			sd even=0xffFF;and even bag
+			divu bag 0x10000
+			if even>=bag
+				set pointer# (even_align)
+			else
+				set pointer# (odd_align)
+			endelse
+		endif
+		add pointer (function_calculation_sz)
+	endwhile
+endfunction
+
+#ptype
+function align_ptype()
+	sd ptrfunctionTagIndex%ptrfunctionTagIndex
+	sv container%ptrstackalign
+	sd cont;set cont container#
+	sd index=function_calculation_sz;mult index ptrfunctionTagIndex#
+	add cont index
+	return cont
+endfunction
+#pstack
+function align_pstack()
+	sd cont;setcall cont align_ptype()
+	add cont (align_calculation_size)
+	return cont
+endfunction
+
+#type
+function align_type()
+	sd cont;setcall cont align_ptype()
+	return cont#
+endfunction
+#stack
+function align_stack()
+	ss cont;setcall cont align_pstack()
+	return cont#
+endfunction
+
+#err
+function align_entryscope()
+	sd type;setcall type align_type()
+	if type!=0
+		#bt ebx,3 (offset 3) x8 or x0
+		#rex to bt the first byte it is useless
+		char bt={twobytesinstruction_byte1,bt_instruction,bt_reg_imm8|ebxregnumber,3}
+		#j(c|nc);sub rbx,8
+		char jump#1;char *=4;char *={REX_Operand_64,0x83,RegReg*tomod|(5*toregopcode)|ebxregnumber,8}
+		if type=(even_align)
+			#there are more even calls to align
+			#Jump short if not carry
+			set jump (jnc_instruction)
+		else
+			#odd
+			#Jump short if carry
+			set jump (0x72)
+		endelse
+		vdata code%%ptr_codesec
+		sd err
+		SetCall err addtosec(#bt,(4+6),code)
+		return err
+	endif
+	return (noerror)
+endfunction
--- ocompiler-1.orig/src/files/functions/64/align.s
+++ /dev/null
@@ -1,185 +0,0 @@
-
-value stackalign#1
-data *stackalign_size#1
-const ptrstackalign^stackalign
-#er
-function align_alloc(sd sz)
-	inc sz   ##for entry
-	mult sz (dwsz)
-	sv s%ptrstackalign
-	setcall s# memcalloc(sz) #need 0 by default
-	sv start;set start s#
-	if s#!=(NULL)
-		add s :
-		set s#d^ sz
-		return (noerror)
-	endif
-	return (error)
-endfunction
-function align_free()
-	sv s%ptrstackalign
-	if s#!=(NULL)
-		call free(s#)
-	endif
-endfunction
-
-#er
-function stack_align(sd nr)
-	sd final_nr
-	setcall final_nr pref_call_align(nr)
-	if final_nr!=0
-		and final_nr 1
-		sd type;setcall type align_type()
-		if type=(even_align)
-			if final_nr=0
-				return (noerror)
-			endif
-		elseif   final_nr!=0
-				return (noerror)
-		endelseif
-		#Stack aligned on 16 bytes. Depending on the number of arguments
-		vdata code%%ptr_codesec
-		char align={REX_Operand_64,0x83,0xEC,8}
-		sd err
-		SetCall err addtosec(#align,(4),code)
-		return err
-	endif
-	return (noerror)
-endfunction
-#nr
-function pref_call_align(sd nr)
-	data ptr_call_align%ptr_call_align
-	sd type;set type ptr_call_align#
-	if type!=(call_align_no)
-		sd conv;setcall conv convdata((convdata_total))
-		if nr<=conv
-			if conv=(lin_convention)
-				if type=(call_align_yes_all)
-					return 2 #to align at no args
-				endif
-			else
-				if type!=(call_align_yes_arg)
-					return conv
-				endif
-			endelse
-		else
-			return nr
-		endelse
-	endif
-	return 0
-endfunction
-
-
-#err
-function align_ante(sd arguments)
-	setcall arguments pref_call_align(arguments)
-	if arguments!=0
-		sd pointer
-		#sd container%ptrstackAlign
-		#wanting with three pass, the impXorfnX is not ready at first pass: call getcontplusReg(container,#pointer)
-		#sub pointer (dwsz)
-		#test if in a function
-		#sd fnboolptr%globalinnerfunction
-		#if fnboolptr#==(TRUE)
-		#	sub pointer (dwsz)
-		#endif
-		setcall pointer align_ptype()
-		sd test=1;and test arguments
-		sd test2=0xffFF
-		if test=0
-		#even, put on low word
-			inc pointer#
-			and test2 pointer#
-			if test2!=0
-				return (noerror)
-			endif
-			return "More than 65535 even calls?"
-		endif
-		#odd, put on high word
-		sd bag;set bag pointer#
-		div bag 0x10000
-		inc bag
-		and test2 bag
-		if test2!=0x8000
-			#set to high word
-			#this is not endian independent add pointer (wsz)
-			#and pointer#s^ bag
-			#or pointer#s^ bag
-			#div bag 0x100
-			#inc pointer
-			#and pointer#s^ bag
-			#or pointer#s^ bag
-			mult bag 0x10000
-			sd bag2;set bag2 pointer#
-			and bag2 bag;or bag2 bag
-			and pointer# (0xffFF)
-			or pointer# bag2
-			return (noerror)
-		endif
-		return "32768 odd calls?"  #to div without sign
-	endif
-	return (noerror)
-endfunction
-
-function align_resolve()
-	sv end%ptrstackalign
-	sd pointer;set pointer end#
-	add end :
-	set end end#d^
-	add end pointer
-	while pointer!=end
-		sd bag;set bag pointer#
-		if bag!=0
-			sd even=0xffFF;and even bag
-			div bag 0x10000
-			if even>=bag
-				set pointer# (even_align)
-			else
-				set pointer# (odd_align)
-			endelse
-		endif
-		add pointer (dwsz)
-	endwhile
-endfunction
-
-#ptype
-function align_ptype()
-	sd ptrfunctionTagIndex%ptrfunctionTagIndex
-	sv container%ptrstackalign
-	sd cont;set cont container#
-	sd index=dwsz;mult index ptrfunctionTagIndex#
-	add cont index
-	return cont
-endfunction
-
-#type
-function align_type()
-	sd cont;setcall cont align_ptype()
-	return cont#
-endfunction
-
-#err
-function align_entryscope()
-	sd type;setcall type align_type()
-	if type!=0
-		#bt ebx,3 (offset 3) x8 or x0
-		#rex to bt the first byte it is useless
-		char bt={twobytesinstruction_byte1,bt_instruction,bt_reg_imm8|ebxregnumber,3}
-		#j(c|nc);sub rbx,8
-		char jump#1;char *=4;char *={REX_Operand_64,0x83,RegReg*tomod|(5*toregopcode)|ebxregnumber,8}
-		if type=(even_align)
-			#there are more even calls to align
-			#Jump short if not carry
-			set jump (jnc_instruction)
-		else
-			#odd
-			#Jump short if carry
-			set jump (0x72)
-		endelse
-		vdata code%%ptr_codesec
-		sd err
-		SetCall err addtosec(#bt,(4+6),code)
-		return err
-	endif
-	return (noerror)
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/64/bit.oc
@@ -0,0 +1,482 @@
+
+
+#p_bits
+function p_is_for_64()
+	data bool#1
+	return #bool
+endfunction
+#bool
+function is_for_64()
+	sd p;setcall p p_is_for_64();return p#
+endfunction
+#p_bits
+function p_neg_is_for_64()
+	data bool#1
+	return #bool
+endfunction
+
+function scope64_p()
+	datax bool#1;return #bool
+endfunction
+function scope64_get()
+	sd p;setcall p scope64_p();return p#
+endfunction
+function scope64_set(sd b)
+	sd p;setcall p scope64_p();set p# b
+endfunction
+
+#get
+function is_for_64_is_impX_or_fnX_p_get();data b#1;return #b;endfunction
+#get
+function is_for_64_is_impX_or_fnX_get();sd p_b;setcall p_b is_for_64_is_impX_or_fnX_p_get();return p_b#;endfunction
+function is_for_64_is_impX_or_fnX_set(sd ptrdata,sd subtype)
+	sd b
+	setcall b is_for_64()
+	#importX and functionX used to have a test with is_for_64 outside of this, but at log need to know the type
+	if b=(TRUE)
+		add ptrdata (maskoffset)
+		sd val;set val ptrdata#;and val (x86_64bit)
+		sd p_b
+		if val=(x86_64bit)
+			setcall p_b is_for_64_is_impX_or_fnX_p_get()
+			set p_b# (TRUE)
+		else
+			setcall subtype callx_flag(subtype)
+			if subtype!=0
+				setcall p_b is_for_64_is_impX_or_fnX_p_get()
+				set p_b# (TRUE)
+			endif
+		endelse
+	endif
+	#set p_b# (FALSE)   #is set FALSE after it is used
+endfunction
+function is_for_64_is_impX_or_fnX_set_force(sd subtype)
+	sd b
+	setcall b is_for_64()
+	if b=(TRUE)
+		setcall subtype callx_flag(subtype)
+		if subtype!=0
+			sd p_b
+			setcall p_b is_for_64_is_impX_or_fnX_p_get()
+			set p_b# (TRUE)
+		endif
+	endif
+endfunction
+
+function callx_flag(sd subtype)
+	and subtype (x_callx_flag)
+	return subtype
+endfunction
+
+#get
+function nr_of_args_64need_p_get();data n#1;return #n;endfunction
+function nr_of_args_64need_count()
+	#sd p_b;setcall p_b is_for_64_is_impX_or_fnX_p_get()
+	#if p_b#==(TRUE)
+
+	#the check was good, but at xfile is needing the number of args at any function
+	sd p;setcall p nr_of_args_64need_p_get();inc p#
+
+	#endif
+endfunction
+
+##REX_W
+function rex_w(sd p_err)
+	Data code%%ptr_codesec
+	char r=REX_Operand_64
+	SetCall p_err# addtosec(#r,1,code)
+endfunction
+#er
+function rex_w_if64()
+	sd b;setcall b is_for_64()
+	if b=(FALSE)
+		return (noerror)
+	endif
+	sd err
+	call rex_w(#err)
+	return err
+endfunction
+#b
+function is_big(sd dataarg,sd sufix)
+#called when lowbyte is false
+	sd b;setcall b bigbits(dataarg)
+	if b!=0
+		setcall b pointbit(dataarg)
+		if b=0
+			if sufix=(sufix_true)
+				# sd# is not big
+				return (FALSE)
+			endif
+		endif
+		setcall b is_for_64()
+		return b
+	endif
+	return (FALSE)
+endfunction
+#z
+function bigbits(sd data)
+	sd test
+	setcall test stackbit(data)
+	if test=0
+		setcall test datapointbit(data)
+	endif
+	return test
+endfunction
+
+#function stack64_op_set()
+#	sd b;setcall b is_for_64()
+#	if b==(TRUE);call stack64_op_set_get((TRUE),(TRUE));endif
+#endfunction
+#(false)get
+#function stack64_op_set_get(sd b,sd val)
+#	data x#1
+#	if b==(TRUE);set x val
+#	else;return x
+#	endelse
+#endfunction
+#err
+#function stack64_op()
+#	sd b;setcall b stack64_op_set_get((FALSE))
+#	if b!=(FALSE)
+#		#reset
+#		call stack64_op_set_get((TRUE),(FALSE))
+#		#at push 64 and call 64, without rex is ok
+#		sd p;setcall p val64_p_get()
+#		set p# (val64_no)
+#	endif
+#endfunction
+
+function stack64_enlarge(sd val)
+	sd b;setcall b is_for_64()
+	if b=(TRUE)
+		mult val 2
+	endif
+	return val
+endfunction
+function stack64_base(sv data)
+	sd is_arg;setcall is_arg stackrelativebit(data)
+	if is_arg=0
+		return 0
+	endif
+	sd val;setcall val stack64_enlarge((stackinitpush+dwsz))  #ebp/ebx+return
+	return val
+endfunction
+
+#setx
+
+function val64_init()
+	sd p;setcall p val64_p_get();set p# (val64_no)
+endfunction
+function val64_p_get()
+	data x#1;return #x
+endfunction
+
+function convdata(sd type,sd dest,sd fnargs)
+	if type=(convdata_total)
+		data nr_of_args#1
+		return nr_of_args   ##ms_convention or lin
+	elseif type=(convdata_call)
+		#rdi
+		char hex_1={REX_Operand_64,moveatprocthemem,ediregnumber*toregopcode|espregnumber,0x24,0}
+		#rsi
+		char hex_2={REX_Operand_64,moveatprocthemem,esiregnumber*toregopcode|disp8mod|espregnumber,0x24,8}
+		#rcx/rdx,rsp+
+		char hex_3={REX_Operand_64,moveatprocthemem};char c3#1;char *=0x24;char c3o#1
+		#rdx/rcx,rsp+
+		char hex_4={REX_Operand_64,moveatprocthemem};char c4#1;char *=0x24;char c4o#1
+		#r8,rsp+
+		char hex_5={REX_R8_15,moveatprocthemem,0x44,0x24};char c5o#1
+		#r9,rsp+
+		char hex_6={REX_R8_15,moveatprocthemem,0x4C,0x24};char c6o#1
+		if nr_of_args=(lin_convention)
+			set dest# #hex_1
+			incst dest;set dest# #hex_2
+			incst dest
+		endif
+		set dest# #hex_3
+		incst dest;set dest# #hex_4
+		incst dest;set dest# #hex_5
+		incst dest;set dest# #hex_6
+		ret
+	elseif type=(convdata_fn)
+		const functionxlin_start=\
+		#pop a
+		char functionxlin_code=0x58
+		#sub esp,conv8
+		char *={REX_Operand_64,0x83,5*toregopcode|regregmod|espregnumber};char *=lin_convention*qwsz
+		#push a
+		char *=0x50
+		const functionxlin_shadow=\-functionxlin_start
+
+		char *={REX_Operand_64,moveatmemtheproc,ediregnumber*toregopcode|disp8mod|espregnumber,0x24,8}
+		const conv_fn_b1=\-functionxlin_start
+
+		char *={REX_Operand_64,moveatmemtheproc,esiregnumber*toregopcode|disp8mod|espregnumber,0x24,16}
+		const functionx_start=\
+		const conv_fn_b2=\-functionxlin_start
+
+		#mov [rsp+(8h/18h)],rcx/rdx
+		char functionx_code={REX_Operand_64,moveatmemtheproc};char f3#1;char *=0x24;char f3o#1
+		const conv_fn_a1=\-functionx_start
+		const conv_fn_b3=\-functionxlin_start
+
+		#mov [rsp+(10h/20h)],rdx/rcx
+		char *={REX_Operand_64,moveatmemtheproc};char f4#1;char *=0x24;char f4o#1
+		const conv_fn_a2=\-functionx_start
+		const conv_fn_b4=\-functionxlin_start
+
+		#mov [rsp+(18h/28h)],r8
+		char *={REX_R8_15,moveatmemtheproc,0x44,0x24};char f5o#1
+		const conv_fn_a3=\-functionx_start
+		const conv_fn_b5=\-functionxlin_start
+
+		#mov [rsp+(20h/30h)],r9
+		char *={REX_R8_15,moveatmemtheproc,0x4C,0x24};char f6o#1
+
+		if nr_of_args=(ms_convention)
+			if fnargs=0
+				set dest# 0
+			elseif fnargs=1
+				set dest# (conv_fn_a1)
+			elseif fnargs=2
+				set dest# (conv_fn_a2)
+			elseif fnargs=3
+				set dest# (conv_fn_a3)
+			else
+				set dest# (\-functionx_start)
+			endelse
+			return #functionx_code
+		endif
+		if fnargs=0
+			set dest# (functionxlin_shadow)
+		elseif fnargs=1
+			set dest# (conv_fn_b1)
+		elseif fnargs=2
+			set dest# (conv_fn_b2)
+		elseif fnargs=3
+			set dest# (conv_fn_b3)
+		elseif fnargs=4
+			set dest# (conv_fn_b4)
+		elseif fnargs=5
+			set dest# (conv_fn_b5)
+		else
+			set dest# (\-functionxlin_start)
+		endelse
+		return #functionxlin_code
+	endelseif
+	set nr_of_args dest
+	if nr_of_args=(ms_convention)
+		set c3 0x0C;set c3o 0
+		set c4 0x54;set c4o 8
+		set c5o 16;set c6o 24
+		set f3 0x4C;set f3o 8
+		set f4 0x54;set f4o 16
+		set f5o 24;set f6o 32
+	else
+		set c3 0x54;set c3o 16
+		set c4 0x4C;set c4o 24
+		set c5o 32;set c6o 40
+		set f3 0x54;set f3o 24
+		set f4 0x4C;set f4o 32
+		set f5o 40;set f6o 48
+	endelse
+endfunction
+
+function function_call_64fm(sd nr_of_args,sd hex_n,sd conv,sd code)
+	sd err
+	if nr_of_args>0
+		SetCall err addtosec(hex_n#,4,code);If err!=(noerror);Return err;EndIf
+		if nr_of_args>1
+			incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
+			if nr_of_args>2
+				incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
+				if nr_of_args>3
+					incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
+					if conv=(lin_convention)
+						if nr_of_args>4
+							incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
+							if nr_of_args>5
+								incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
+							endif
+						endif
+					endif
+				endif
+			endif
+		endif
+	endif
+	return (noerror)
+endfunction
+function function_call_64f(sd hex_n,sd conv,sd code)
+	sd err
+	sd nr_of_args;setcall nr_of_args nr_of_args_64need_p_get()
+	set nr_of_args nr_of_args#
+	#
+	setcall err function_call_64fm(nr_of_args,hex_n,conv,code)
+	If err=(noerror)
+		if conv=(ms_convention)
+			if nr_of_args<conv
+				#shadow space
+				#sub esp,x;default 4 args stack space convention
+				char hex_w={REX_Operand_64,0x83,0xEC};char argspush#1
+				set argspush nr_of_args;sub argspush conv;mult argspush ~qwszbits #minus 1 mult qwsz
+				SetCall err addtosec(#hex_w,4,code)
+			endif
+		elseif nr_of_args>0
+			#lin_convention
+			#add esp,x
+			char hex_x={REX_Operand_64,0x83,regregmod|espregnumber};char adjuster#1
+			if nr_of_args>conv;set adjuster conv;else;set adjuster nr_of_args;endelse
+			mult adjuster (qwsz)
+			SetCall err addtosec(#hex_x,4,code)
+		endelseif
+	endIf
+	return err
+endfunction
+function function_call_64(sd is_callex)
+	sd conv;setcall conv convdata((convdata_total))
+	sd err
+	Data code%%ptr_codesec
+	sd hex_1;sd hex_2;sd hex_3;sd hex_4;sd hex_5;sd hex_6
+	call convdata((convdata_call),#hex_1)
+	#
+	if is_callex=(FALSE)
+		setcall err function_call_64f(#hex_1,conv,code)
+		Return err
+	endif
+	##
+	#mov edx,eax
+	char find_args={REX_Operand_64,0x8b,edxregnumber|regregmod}
+	SetCall err addtosec(#find_args,3,code);If err!=(noerror);Return err;EndIf
+	#
+	#convention and shadow space
+	#cmp rax,imm32
+	char cmp_je={REX_Operand_64,0x3d};data cmp_imm32#1
+	set cmp_imm32 conv;dec cmp_imm32
+	#jump if above
+	char *callex_jump=0x77;char j_off#1
+	#
+	#convention gdb view,and gui view
+	#push a
+	char callex_conv=0x50
+	#neg al
+	char *={0xf6,3*toregopcode|regregmod}
+	#add al conv
+	char *=0x04;char conv_neg#1
+	#mov cl 5
+	char *={0xb1,5}
+	#mult al cl
+	char *={0xf6,4*toregopcode|ecxregnumber|regregmod}
+	#call
+	char *={0xe8,0,0,0,0}
+	#pop c
+	char *=0x59
+	#add rax rcx    can be --image-base=int64 but more than 0xff000000 x64 dbg says invalid but there is int64 rip in parent x64 debug
+	char *={REX_Operand_64,0x01,ecxregnumber|regregmod}
+	#pop a
+	char *=0x58
+	#add rcx,imm8
+	char *={REX_Operand_64,0x83,ecxregnumber|regregmod,11}
+	#j cl
+	char *={0xff,4*toregopcode|ecxregnumber|regregmod}
+	#
+	set conv_neg conv
+	set j_off 25
+	SetCall err addtosec(#cmp_je,8,code);If err!=(noerror);Return err;EndIf
+	SetCall err addtosec(#callex_conv,25,code);If err!=(noerror);Return err;EndIf
+	if conv=(lin_convention)
+		SetCall err addtosec(hex_6,5,code);If err!=(noerror);Return err;EndIf
+		SetCall err addtosec(hex_5,5,code);If err!=(noerror);Return err;EndIf
+	endif
+	SetCall err addtosec(hex_4,5,code);If err!=(noerror);Return err;EndIf
+	SetCall err addtosec(hex_3,5,code);If err!=(noerror);Return err;EndIf
+	SetCall err addtosec(hex_2,5,code);If err!=(noerror);Return err;EndIf
+	ss rspwithoffset;set rspwithoffset hex_1;add rspwithoffset 2;or rspwithoffset# (disp8mod)
+	SetCall err addtosec(hex_1,5,code);If err!=(noerror);Return err;EndIf
+	xor rspwithoffset# (disp8mod)
+	#
+	#shadow space
+	if conv=(ms_convention)
+		#neg al
+		char callex_shadow={0xf6,3*toregopcode|regregmod}
+		#add al conv-1
+		char *=0x04;char shadow_neg#1
+		#push qwordsz
+		char *={0x6a,qwsz}
+		#mul al [esp]
+		char *={0xf6,4*toregopcode|espregnumber,espregnumber*toregopcode|espregnumber}
+		#sub rsp,rax
+		char *={REX_Operand_64,0x2b,espregnumber*toregopcode|regregmod}
+		#
+		set shadow_neg conv;dec shadow_neg
+		set j_off 12
+		SetCall err addtosec(#cmp_je,8,code);If err!=(noerror);Return err;EndIf
+		SetCall err addtosec(#callex_shadow,12,code)
+	else
+		#lin_convention
+		#cmp rax,imm32
+		char callex_unshadow={REX_Operand_64,0x3d};data *cmp_imm32=lin_convention
+		#jump if below or equal
+		char *callex_jump=0x76;char *j_off=10
+		char *rax_conv={REX_Operand_64,0xb8};data *={lin_convention,0}
+		#push qwordsz
+		char *={0x6a,qwsz}
+		#inc al
+		char *={0xfe,regregmod}
+		#mul al [esp]
+		char *={0xf6,4*toregopcode|espregnumber,espregnumber*toregopcode|espregnumber}
+		#add rsp,rax
+		char *={REX_Operand_64,0x03,espregnumber*toregopcode|regregmod}
+		#
+		SetCall err addtosec(#callex_unshadow,28,code)
+	endelse
+	return err
+endfunction
+#err
+function function_start_64(sd nr_of_args)
+	Data code%%ptr_codesec
+	sd data;sd sz
+	setcall data convdata((convdata_fn),#sz,nr_of_args)
+	sd err
+	SetCall err addtosec(data,sz,code)
+	return err
+endfunction
+#err
+function callex64_call()
+	sd conv;setcall conv convdata((convdata_total))
+	#Stack aligned on 16 bytes.
+	const callex64_start=\
+	#bt esp,3 (bit offset 3)        rsp for 3 bits is useless
+	char callex64_code={0x0F,0xBA,bt_reg_imm8|espregnumber,3}
+	#jc @ (jump when rsp=....8)
+	char *=0x72;char *=7+2+4+2+2
+	#7cmp ecx,5
+	char *={REX_Operand_64,0x81,0xf9};data jcase1#1
+	set jcase1 conv;inc jcase1
+	#2jb $
+	char *=0x72;char *=4+2+2+7+2+4+2+4
+	#4bt ecx,0
+	char *={0x0F,0xBA,bt_reg_imm8|ecxregnumber,0}
+	#2jc %
+	char *=0x72;char *=2+7+2+4+2
+	#2jmp $
+	char *=0xEB;char *=7+2+4+2+4
+	#7@ cmp ecx,5
+	char *={REX_Operand_64,0x81,0xf9};data jcase2#1
+	set jcase2 conv;inc jcase2
+	#2jb %
+	char *=0x72;char *=4+2
+	#4bt ecx,0
+	char *={0x0F,0xBA,bt_reg_imm8|ecxregnumber,0}
+	#2jc $
+	char *=0x72;char *=4
+	#%
+	#4 sub rsp,8
+	char *={REX_Operand_64,0x83,0xEC};char *=8
+	#$
+	#mov rdx,rcx
+	char *keep_nr_args={REX_Operand_64,0x8b,edxregnumber*toregopcode|ecxregnumber|regregmod}
+	sd ptrcodesec%%ptr_codesec
+	sd err
+	SetCall err addtosec(#callex64_code,(\-callex64_start),ptrcodesec)
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/64/bit.s
+++ /dev/null
@@ -1,482 +0,0 @@
-
-
-#p_bits
-function p_is_for_64()
-	data bool#1
-	return #bool
-endfunction
-#bool
-function is_for_64()
-	sd p;setcall p p_is_for_64();return p#
-endfunction
-#p_bits
-function p_neg_is_for_64()
-	data bool#1
-	return #bool
-endfunction
-
-function scope64_p()
-	datax bool#1;return #bool
-endfunction
-function scope64_get()
-	sd p;setcall p scope64_p();return p#
-endfunction
-function scope64_set(sd b)
-	sd p;setcall p scope64_p();set p# b
-endfunction
-
-#get
-function is_for_64_is_impX_or_fnX_p_get();data b#1;return #b;endfunction
-#get
-function is_for_64_is_impX_or_fnX_get();sd p_b;setcall p_b is_for_64_is_impX_or_fnX_p_get();return p_b#;endfunction
-function is_for_64_is_impX_or_fnX_set(sd ptrdata,sd subtype)
-	sd b
-	setcall b is_for_64()
-	#importX and functionX used to have a test with is_for_64 outside of this, but at log need to know the type
-	if b=(TRUE)
-		add ptrdata (maskoffset)
-		sd val;set val ptrdata#;and val (x86_64bit)
-		sd p_b
-		if val=(x86_64bit)
-			setcall p_b is_for_64_is_impX_or_fnX_p_get()
-			set p_b# (TRUE)
-		else
-			setcall subtype callx_flag(subtype)
-			if subtype!=0
-				setcall p_b is_for_64_is_impX_or_fnX_p_get()
-				set p_b# (TRUE)
-			endif
-		endelse
-	endif
-	#set p_b# (FALSE)   #is set FALSE after it is used
-endfunction
-function is_for_64_is_impX_or_fnX_set_force(sd subtype)
-	sd b
-	setcall b is_for_64()
-	if b=(TRUE)
-		setcall subtype callx_flag(subtype)
-		if subtype!=0
-			sd p_b
-			setcall p_b is_for_64_is_impX_or_fnX_p_get()
-			set p_b# (TRUE)
-		endif
-	endif
-endfunction
-
-function callx_flag(sd subtype)
-	and subtype (x_callx_flag)
-	return subtype
-endfunction
-
-#get
-function nr_of_args_64need_p_get();data n#1;return #n;endfunction
-function nr_of_args_64need_count()
-	#sd p_b;setcall p_b is_for_64_is_impX_or_fnX_p_get()
-	#if p_b#==(TRUE)
-
-	#the check was good, but at xfile is needing the number of args at any function
-	sd p;setcall p nr_of_args_64need_p_get();inc p#
-
-	#endif
-endfunction
-
-##REX_W
-function rex_w(sd p_err)
-	Data code%%ptr_codesec
-	char r=REX_Operand_64
-	SetCall p_err# addtosec(#r,1,code)
-endfunction
-#er
-function rex_w_if64()
-	sd b;setcall b is_for_64()
-	if b=(FALSE)
-		return (noerror)
-	endif
-	sd err
-	call rex_w(#err)
-	return err
-endfunction
-#b
-function is_big(sd dataarg,sd sufix)
-#called when lowbyte is false
-	sd b;setcall b bigbits(dataarg)
-	if b!=0
-		setcall b pointbit(dataarg)
-		if b=0
-			if sufix=(sufix_true)
-				# sd# is not big
-				return (FALSE)
-			endif
-		endif
-		setcall b is_for_64()
-		return b
-	endif
-	return (FALSE)
-endfunction
-#z
-function bigbits(sd data)
-	sd test
-	setcall test stackbit(data)
-	if test=0
-		setcall test datapointbit(data)
-	endif
-	return test
-endfunction
-
-#function stack64_op_set()
-#	sd b;setcall b is_for_64()
-#	if b==(TRUE);call stack64_op_set_get((TRUE),(TRUE));endif
-#endfunction
-#(false)get
-#function stack64_op_set_get(sd b,sd val)
-#	data x#1
-#	if b==(TRUE);set x val
-#	else;return x
-#	endelse
-#endfunction
-#err
-#function stack64_op()
-#	sd b;setcall b stack64_op_set_get((FALSE))
-#	if b!=(FALSE)
-#		#reset
-#		call stack64_op_set_get((TRUE),(FALSE))
-#		#at push 64 and call 64, without rex is ok
-#		sd p;setcall p val64_p_get()
-#		set p# (val64_no)
-#	endif
-#endfunction
-
-function stack64_enlarge(sd val)
-	sd b;setcall b is_for_64()
-	if b=(TRUE)
-		mult val 2
-	endif
-	return val
-endfunction
-function stack64_base(sv data)
-	sd is_arg;setcall is_arg stackrelativebit(data)
-	if is_arg=0
-		return 0
-	endif
-	sd val;setcall val stack64_enlarge((stackinitpush+dwsz))  #ebp/ebx+return
-	return val
-endfunction
-
-#setx
-
-function val64_init()
-	sd p;setcall p val64_p_get();set p# (val64_no)
-endfunction
-function val64_p_get()
-	data x#1;return #x
-endfunction
-
-function convdata(sd type,sd dest,sd fnargs)
-	if type=(convdata_total)
-		data nr_of_args#1
-		return nr_of_args   ##ms_convention or lin
-	elseif type=(convdata_call)
-		#rdi
-		char hex_1={REX_Operand_64,moveatprocthemem,ediregnumber*toregopcode|espregnumber,0x24,0}
-		#rsi
-		char hex_2={REX_Operand_64,moveatprocthemem,esiregnumber*toregopcode|disp8mod|espregnumber,0x24,8}
-		#rcx/rdx,rsp+
-		char hex_3={REX_Operand_64,moveatprocthemem};char c3#1;char *=0x24;char c3o#1
-		#rdx/rcx,rsp+
-		char hex_4={REX_Operand_64,moveatprocthemem};char c4#1;char *=0x24;char c4o#1
-		#r8,rsp+
-		char hex_5={REX_R8_15,moveatprocthemem,0x44,0x24};char c5o#1
-		#r9,rsp+
-		char hex_6={REX_R8_15,moveatprocthemem,0x4C,0x24};char c6o#1
-		if nr_of_args=(lin_convention)
-			set dest# #hex_1
-			incst dest;set dest# #hex_2
-			incst dest
-		endif
-		set dest# #hex_3
-		incst dest;set dest# #hex_4
-		incst dest;set dest# #hex_5
-		incst dest;set dest# #hex_6
-		ret
-	elseif type=(convdata_fn)
-		const functionxlin_start=\
-		#pop a
-		char functionxlin_code=0x58
-		#sub esp,conv8
-		char *={REX_Operand_64,0x83,5*toregopcode|regregmod|espregnumber};char *=lin_convention*qwsz
-		#push a
-		char *=0x50
-		const functionxlin_shadow=\-functionxlin_start
-
-		char *={REX_Operand_64,moveatmemtheproc,ediregnumber*toregopcode|disp8mod|espregnumber,0x24,8}
-		const conv_fn_b1=\-functionxlin_start
-
-		char *={REX_Operand_64,moveatmemtheproc,esiregnumber*toregopcode|disp8mod|espregnumber,0x24,16}
-		const functionx_start=\
-		const conv_fn_b2=\-functionxlin_start
-
-		#mov [rsp+(8h/18h)],rcx/rdx
-		char functionx_code={REX_Operand_64,moveatmemtheproc};char f3#1;char *=0x24;char f3o#1
-		const conv_fn_a1=\-functionx_start
-		const conv_fn_b3=\-functionxlin_start
-
-		#mov [rsp+(10h/20h)],rdx/rcx
-		char *={REX_Operand_64,moveatmemtheproc};char f4#1;char *=0x24;char f4o#1
-		const conv_fn_a2=\-functionx_start
-		const conv_fn_b4=\-functionxlin_start
-
-		#mov [rsp+(18h/28h)],r8
-		char *={REX_R8_15,moveatmemtheproc,0x44,0x24};char f5o#1
-		const conv_fn_a3=\-functionx_start
-		const conv_fn_b5=\-functionxlin_start
-
-		#mov [rsp+(20h/30h)],r9
-		char *={REX_R8_15,moveatmemtheproc,0x4C,0x24};char f6o#1
-
-		if nr_of_args=(ms_convention)
-			if fnargs=0
-				set dest# 0
-			elseif fnargs=1
-				set dest# (conv_fn_a1)
-			elseif fnargs=2
-				set dest# (conv_fn_a2)
-			elseif fnargs=3
-				set dest# (conv_fn_a3)
-			else
-				set dest# (\-functionx_start)
-			endelse
-			return #functionx_code
-		endif
-		if fnargs=0
-			set dest# (functionxlin_shadow)
-		elseif fnargs=1
-			set dest# (conv_fn_b1)
-		elseif fnargs=2
-			set dest# (conv_fn_b2)
-		elseif fnargs=3
-			set dest# (conv_fn_b3)
-		elseif fnargs=4
-			set dest# (conv_fn_b4)
-		elseif fnargs=5
-			set dest# (conv_fn_b5)
-		else
-			set dest# (\-functionxlin_start)
-		endelse
-		return #functionxlin_code
-	endelseif
-	set nr_of_args dest
-	if nr_of_args=(ms_convention)
-		set c3 0x0C;set c3o 0
-		set c4 0x54;set c4o 8
-		set c5o 16;set c6o 24
-		set f3 0x4C;set f3o 8
-		set f4 0x54;set f4o 16
-		set f5o 24;set f6o 32
-	else
-		set c3 0x54;set c3o 16
-		set c4 0x4C;set c4o 24
-		set c5o 32;set c6o 40
-		set f3 0x54;set f3o 24
-		set f4 0x4C;set f4o 32
-		set f5o 40;set f6o 48
-	endelse
-endfunction
-
-function function_call_64fm(sd nr_of_args,sd hex_n,sd conv,sd code)
-	sd err
-	if nr_of_args>0
-		SetCall err addtosec(hex_n#,4,code);If err!=(noerror);Return err;EndIf
-		if nr_of_args>1
-			incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
-			if nr_of_args>2
-				incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
-				if nr_of_args>3
-					incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
-					if conv=(lin_convention)
-						if nr_of_args>4
-							incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
-							if nr_of_args>5
-								incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
-							endif
-						endif
-					endif
-				endif
-			endif
-		endif
-	endif
-	return (noerror)
-endfunction
-function function_call_64f(sd hex_n,sd conv,sd code)
-	sd err
-	sd nr_of_args;setcall nr_of_args nr_of_args_64need_p_get()
-	set nr_of_args nr_of_args#
-	#
-	setcall err function_call_64fm(nr_of_args,hex_n,conv,code)
-	If err=(noerror)
-		if conv=(ms_convention)
-			if nr_of_args<conv
-				#shadow space
-				#sub esp,x;default 4 args stack space convention
-				char hex_w={REX_Operand_64,0x83,0xEC};char argspush#1
-				set argspush nr_of_args;sub argspush conv;mult argspush ~qwszbits #minus 1 mult qwsz
-				SetCall err addtosec(#hex_w,4,code)
-			endif
-		elseif nr_of_args>0
-			#lin_convention
-			#add esp,x
-			char hex_x={REX_Operand_64,0x83,regregmod|espregnumber};char adjuster#1
-			if nr_of_args>conv;set adjuster conv;else;set adjuster nr_of_args;endelse
-			mult adjuster (qwsz)
-			SetCall err addtosec(#hex_x,4,code)
-		endelseif
-	endIf
-	return err
-endfunction
-function function_call_64(sd is_callex)
-	sd conv;setcall conv convdata((convdata_total))
-	sd err
-	Data code%%ptr_codesec
-	sd hex_1;sd hex_2;sd hex_3;sd hex_4;sd hex_5;sd hex_6
-	call convdata((convdata_call),#hex_1)
-	#
-	if is_callex=(FALSE)
-		setcall err function_call_64f(#hex_1,conv,code)
-		Return err
-	endif
-	##
-	#mov edx,eax
-	char find_args={REX_Operand_64,0x8b,edxregnumber|regregmod}
-	SetCall err addtosec(#find_args,3,code);If err!=(noerror);Return err;EndIf
-	#
-	#convention and shadow space
-	#cmp rax,imm32
-	char cmp_je={REX_Operand_64,0x3d};data cmp_imm32#1
-	set cmp_imm32 conv;dec cmp_imm32
-	#jump if above
-	char *callex_jump=0x77;char j_off#1
-	#
-	#convention gdb view,and gui view
-	#push a
-	char callex_conv=0x50
-	#neg al
-	char *={0xf6,3*toregopcode|regregmod}
-	#add al conv
-	char *=0x04;char conv_neg#1
-	#mov cl 5
-	char *={0xb1,5}
-	#mult al cl
-	char *={0xf6,4*toregopcode|ecxregnumber|regregmod}
-	#call
-	char *={0xe8,0,0,0,0}
-	#pop c
-	char *=0x59
-	#add rax rcx    can be --image-base=int64 but more than 0xff000000 x64 dbg says invalid but there is int64 rip in parent x64 debug
-	char *={REX_Operand_64,0x01,ecxregnumber|regregmod}
-	#pop a
-	char *=0x58
-	#add rcx,imm8
-	char *={REX_Operand_64,0x83,ecxregnumber|regregmod,11}
-	#j cl
-	char *={0xff,4*toregopcode|ecxregnumber|regregmod}
-	#
-	set conv_neg conv
-	set j_off 25
-	SetCall err addtosec(#cmp_je,8,code);If err!=(noerror);Return err;EndIf
-	SetCall err addtosec(#callex_conv,25,code);If err!=(noerror);Return err;EndIf
-	if conv=(lin_convention)
-		SetCall err addtosec(hex_6,5,code);If err!=(noerror);Return err;EndIf
-		SetCall err addtosec(hex_5,5,code);If err!=(noerror);Return err;EndIf
-	endif
-	SetCall err addtosec(hex_4,5,code);If err!=(noerror);Return err;EndIf
-	SetCall err addtosec(hex_3,5,code);If err!=(noerror);Return err;EndIf
-	SetCall err addtosec(hex_2,5,code);If err!=(noerror);Return err;EndIf
-	ss rspwithoffset;set rspwithoffset hex_1;add rspwithoffset 2;or rspwithoffset# (disp8mod)
-	SetCall err addtosec(hex_1,5,code);If err!=(noerror);Return err;EndIf
-	xor rspwithoffset# (disp8mod)
-	#
-	#shadow space
-	if conv=(ms_convention)
-		#neg al
-		char callex_shadow={0xf6,3*toregopcode|regregmod}
-		#add al conv-1
-		char *=0x04;char shadow_neg#1
-		#push qwordsz
-		char *={0x6a,qwsz}
-		#mul al [esp]
-		char *={0xf6,4*toregopcode|espregnumber,espregnumber*toregopcode|espregnumber}
-		#sub rsp,rax
-		char *={REX_Operand_64,0x2b,espregnumber*toregopcode|regregmod}
-		#
-		set shadow_neg conv;dec shadow_neg
-		set j_off 12
-		SetCall err addtosec(#cmp_je,8,code);If err!=(noerror);Return err;EndIf
-		SetCall err addtosec(#callex_shadow,12,code)
-	else
-		#lin_convention
-		#cmp rax,imm32
-		char callex_unshadow={REX_Operand_64,0x3d};data *cmp_imm32=lin_convention
-		#jump if below or equal
-		char *callex_jump=0x76;char *j_off=10
-		char *rax_conv={REX_Operand_64,0xb8};data *={lin_convention,0}
-		#push qwordsz
-		char *={0x6a,qwsz}
-		#inc al
-		char *={0xfe,regregmod}
-		#mul al [esp]
-		char *={0xf6,4*toregopcode|espregnumber,espregnumber*toregopcode|espregnumber}
-		#add rsp,rax
-		char *={REX_Operand_64,0x03,espregnumber*toregopcode|regregmod}
-		#
-		SetCall err addtosec(#callex_unshadow,28,code)
-	endelse
-	return err
-endfunction
-#err
-function function_start_64(sd nr_of_args)
-	Data code%%ptr_codesec
-	sd data;sd sz
-	setcall data convdata((convdata_fn),#sz,nr_of_args)
-	sd err
-	SetCall err addtosec(data,sz,code)
-	return err
-endfunction
-#err
-function callex64_call()
-	sd conv;setcall conv convdata((convdata_total))
-	#Stack aligned on 16 bytes.
-	const callex64_start=\
-	#bt esp,3 (bit offset 3)        rsp for 3 bits is useless
-	char callex64_code={0x0F,0xBA,bt_reg_imm8|espregnumber,3}
-	#jc @ (jump when rsp=....8)
-	char *=0x72;char *=7+2+4+2+2
-	#7cmp ecx,5
-	char *={REX_Operand_64,0x81,0xf9};data jcase1#1
-	set jcase1 conv;inc jcase1
-	#2jb $
-	char *=0x72;char *=4+2+2+7+2+4+2+4
-	#4bt ecx,0
-	char *={0x0F,0xBA,bt_reg_imm8|ecxregnumber,0}
-	#2jc %
-	char *=0x72;char *=2+7+2+4+2
-	#2jmp $
-	char *=0xEB;char *=7+2+4+2+4
-	#7@ cmp ecx,5
-	char *={REX_Operand_64,0x81,0xf9};data jcase2#1
-	set jcase2 conv;inc jcase2
-	#2jb %
-	char *=0x72;char *=4+2
-	#4bt ecx,0
-	char *={0x0F,0xBA,bt_reg_imm8|ecxregnumber,0}
-	#2jc $
-	char *=0x72;char *=4
-	#%
-	#4 sub rsp,8
-	char *={REX_Operand_64,0x83,0xEC};char *=8
-	#$
-	#mov rdx,rcx
-	char *keep_nr_args={REX_Operand_64,0x8b,edxregnumber*toregopcode|ecxregnumber|regregmod}
-	sd ptrcodesec%%ptr_codesec
-	sd err
-	SetCall err addtosec(#callex64_code,(\-callex64_start),ptrcodesec)
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/64/reloc.oc
@@ -0,0 +1,60 @@
+
+
+function reloc64_init()
+	sd a%p_pref_reloc_64
+	sd b%p_elf64_r_info_type
+	if a#=(TRUE)
+		set b# (R_X86_64_64)
+	endif
+	#blank is at inits
+endfunction
+
+function reloc64_offset(sd offset)
+	sd a%p_elf64_r_info_type
+	if a#=(R_X86_64_64)
+		add offset 1
+	endif
+	return offset
+endfunction
+#er
+function reloc64_ante()
+	sd a%p_elf64_r_info_type
+	if a#=(R_X86_64_64)
+		sd err
+		call rex_w(#err)
+		return err
+	endif
+	return (noerror)
+endfunction
+const reloc64_add=dwsz
+function reloc64_mid()
+	sd a%p_elf64_r_info_type
+	if a#=(R_X86_64_64)
+		return (reloc64_add)
+	endif
+	return 0
+endfunction
+#er
+function reloc64_post_base_extension(sd struct,sd fill)
+	sd a%p_elf64_r_info_type
+	if a#=(R_X86_64_64)
+		sd err
+		#extension is for example -1 at sd=const, mostly are 0
+		SetCall err addtosec(#fill,(reloc64_add),struct)
+		return err
+	endif
+	return (noerror)
+endfunction
+#er
+function reloc64_post_base(sd struct)
+	sd err
+	setcall err reloc64_post_base_extension(struct,(reloc64_main))
+	return err
+endfunction
+#er
+function reloc64_post()
+	sd ptrcodesec%%ptr_codesec
+	sd err
+	setcall err reloc64_post_base(ptrcodesec)
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/64/reloc.s
+++ /dev/null
@@ -1,60 +0,0 @@
-
-
-function reloc64_init()
-	sd a%p_pref_reloc_64
-	sd b%p_elf64_r_info_type
-	if a#=(TRUE)
-		set b# (R_X86_64_64)
-	endif
-	#blank is at inits
-endfunction
-
-function reloc64_offset(sd offset)
-	sd a%p_elf64_r_info_type
-	if a#=(R_X86_64_64)
-		add offset 1
-	endif
-	return offset
-endfunction
-#er
-function reloc64_ante()
-	sd a%p_elf64_r_info_type
-	if a#=(R_X86_64_64)
-		sd err
-		call rex_w(#err)
-		return err
-	endif
-	return (noerror)
-endfunction
-const reloc64_add=dwsz
-function reloc64_mid()
-	sd a%p_elf64_r_info_type
-	if a#=(R_X86_64_64)
-		return (reloc64_add)
-	endif
-	return 0
-endfunction
-#er
-function reloc64_post_base_extension(sd struct,sd fill)
-	sd a%p_elf64_r_info_type
-	if a#=(R_X86_64_64)
-		sd err
-		#extension is for example -1 at sd=const, mostly are 0
-		SetCall err addtosec(#fill,(reloc64_add),struct)
-		return err
-	endif
-	return (noerror)
-endfunction
-#er
-function reloc64_post_base(sd struct)
-	sd err
-	setcall err reloc64_post_base_extension(struct,(reloc64_main))
-	return err
-endfunction
-#er
-function reloc64_post()
-	sd ptrcodesec%%ptr_codesec
-	sd err
-	setcall err reloc64_post_base(ptrcodesec)
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/actions/argstwo.oc
@@ -0,0 +1,656 @@
+
+#err
+Function twoargs(sv ptrcontent,sd ptrsize,sd subtype,sd ptrcondition)
+	sd err;setcall err twoargs_ex(ptrcontent,ptrsize,subtype,ptrcondition,(allow_no)) #there are 2 more arguments but are not used
+	set main.tempdataReg 0 #this must be after primwrite and/or divmul, and at pass_write
+	return err
+endfunction
+
+#err
+Function twoargs_ex(sv ptrcontent,sd ptrsize,sd subtype,sd ptrcondition,sd allowdata,sd parses)
+	Data lowprim#1
+	Data ptrlowprim^lowprim
+	Data lowsec#1
+	Data ptrlowsec^lowsec
+	Data dataargprim#1
+	Data ptrdataargprim^dataargprim
+	Data dataargsec#1
+	Data ptrdataargsec^dataargsec
+
+	Data sufixprim#1
+	Data sufixsec#1
+	Data ptrsufixprim^sufixprim
+	Data ptrsufixsec^sufixsec
+
+	Data false=FALSE
+	Data true=TRUE
+
+	#Data noreg=noregnumber
+	Data eaxreg=eaxregnumber
+	Data ecxreg=ecxregnumber
+
+	Char opprim#1
+	Char opsec#1
+	Char atprocthemem={moveatprocthemem}
+	Char atmemtheproc={moveatmemtheproc}
+
+	sd imm
+	Data errnr#1
+	Data noerr=noerror
+	SetCall errnr argfilters(ptrcondition,ptrcontent,ptrsize,ptrdataargprim,ptrlowprim,ptrsufixprim,allowdata)
+	If errnr!=noerr
+		Return errnr
+	EndIf
+
+	Data callfn=callfunction
+
+	sd subtype_test
+
+	if allowdata=(allow_later_sec)
+		#pass_init or pass_calls
+		setcall subtype_test x_call_test(subtype,ptrcontent#,ptrsize#)
+		if subtype_test=0
+			if parses=(pass_init)
+				setcall errnr getarg(ptrcontent,ptrsize,ptrsize#,(allow_later),(FORWARD)) #there are 4 more arguments but are not used
+				return errnr
+			else
+			#skip this at pass_calls
+				Call advancecursors(ptrcontent,ptrsize,ptrsize#)
+			endelse
+		else
+			#and subtype (x_callx_flag) #call and callex are testing without and
+			SetCall errnr parsefunction(ptrcontent,ptrsize,callfn,subtype) #there are 2 more arguments but are not used
+			return errnr
+		endelse
+		return (noerror)
+	endif
+
+	Data sameimportant#1
+	Set sameimportant true
+	Data divmul#1
+	Set divmul false
+	#Data regprep#1
+	#Set regprep eaxreg
+	Data regopcode#1
+	Set regopcode eaxreg
+
+	#need to remind first prefix: p1 p2 need_p2 need_p1
+	sd remind_first_prefix
+	sd p_prefix
+	setcall p_prefix prefix_bool()
+
+	set remind_first_prefix p_prefix#;set p_prefix# 0
+	call storefirst_isimm()
+
+	Data primcalltype#1
+	Char two=2
+
+	Set primcalltype false
+
+	sd big
+	If ptrcondition=false
+		#imm second arg can be, at conditions was already called
+		call setimm()
+
+		if subtype=(cCALLEX_primsec)
+		#the text for callexx is elsewhere
+			Set opprim atprocthemem
+			#Set regprep ecxreg
+			Set regopcode ecxreg
+		else
+			setcall subtype_test x_call_test(subtype,ptrcontent#,ptrsize#)
+			if subtype_test!=0
+				Set primcalltype true
+				set subtype_test subtype  ##two more flags at parsefunc
+				and subtype ~x_call_flags
+			endif
+			sd xlog
+			if subtype=(cSET)
+				Set opprim atmemtheproc
+				set xlog (Xfile_action2_set)
+			ElseIf subtype=(cADD)
+				Char addprim={0x01}
+				Set opprim addprim
+				set xlog (Xfile_action2_add)
+			ElseIf subtype=(cSUB)
+				Char subprim={0x29}
+				Set opprim subprim
+				set xlog (Xfile_action2_sub)
+			ElseIf subtype<=(cREMU)
+				Set opprim atprocthemem
+				#Set regprep ecxreg
+				Set regopcode ecxreg
+				Set divmul true
+				if lowprim=(FALSE);setcall big is_big(dataargprim,sufixprim)
+				else;set big (FALSE);endelse
+				sd rem
+				if subtype=(cMULT)
+					set rem (FALSE)
+					set xlog (Xfile_action2_mult)
+				else
+					sd is_signed
+					if subtype=(cDIV)
+						set rem (FALSE)
+						set is_signed (TRUE)
+						set xlog (Xfile_action2_div)
+					elseif subtype=(cDIVU)
+						set rem (FALSE)
+						set is_signed (FALSE)
+						set xlog (Xfile_action2_divu)
+					elseif subtype=(cREM)
+						set rem (TRUE)
+						set is_signed (TRUE)
+						set xlog (Xfile_action2_rem)
+					else
+					#if subtype=(cREMU)
+						set rem (TRUE)
+						set is_signed (FALSE)
+						set xlog (Xfile_action2_remu)
+					endelse
+				endelse
+			Else
+			#If subtype<=(cXOR)
+				Set sameimportant false
+				If subtype=(cAND)
+					Char andprim={0x21}
+					Set opprim andprim
+					set xlog (Xfile_action2_and)
+				ElseIf subtype=(cOR)
+					Char orprim={0x09}
+					Set opprim orprim
+					set xlog (Xfile_action2_or)
+				Else
+				#(cXOR)
+					Char xorprim={0x31}
+					Set opprim xorprim
+					set xlog (Xfile_action2_xor)
+				EndElse
+			EndElse
+			SetCall errnr xfile_add_char_if(xlog)
+			If errnr!=noerr
+				Return errnr
+			EndIf
+		EndElse
+	Else
+		Data sz#1
+		Data condition#1
+		Set condition ptrcondition#
+		SetCall sz strlen(condition)
+		Add condition sz
+		Call advancecursors(ptrcontent,ptrsize,sz)
+
+		Data one=1
+		Add condition one
+
+		Char compare=0x39
+		Set opprim compare
+
+		#imm specific
+		char compimminitial={0x39}
+		char compimmop#1
+		set compimmop compimminitial
+
+		Data conditionmodrm#1
+		Set conditionmodrm condition#
+
+		setcall errnr xfile_add_char_if(conditionmodrm)
+		if errnr!=(noerror)
+			return errnr
+		endif
+	EndElse
+
+	If primcalltype=false
+		if ptrcondition=false
+			if subtype!=(cCALLEX_primsec)
+				SetCall errnr arg(ptrcontent,ptrsize,ptrdataargsec,ptrlowsec,ptrsufixsec,true,(allow_yes))
+			else
+				SetCall errnr arg(ptrcontent,ptrsize,ptrdataargsec,ptrlowsec,ptrsufixsec,true,(allow_no))
+			endelse
+		else
+			call resetisimm() #the first imm is stored, isimm is only set, and if is not will not unset it
+			SetCall errnr arg(ptrcontent,ptrsize,ptrdataargsec,ptrlowsec,ptrsufixsec,true,(allow_no)) #if not this allow no, Xfile_arg_varfn can go in the next if, that with allow yes
+		endelse
+		If errnr!=noerr
+			Return errnr
+		EndIf
+	Else
+		setcall errnr xfile_add_char_if((Xfile_arg_call))
+		if errnr=(noerror)
+			SetCall errnr parsefunction(ptrcontent,ptrsize,callfn,subtype_test) #there is 1 more argument but is not used
+			If errnr!=noerr
+				Return errnr
+			EndIf
+		else
+			return errnr
+		endelse
+	EndElse
+
+	#Data intchar#1
+	data is_prepare#1
+	set is_prepare (FALSE)
+	#Set intchar noreg
+	Set opsec atprocthemem
+
+	If ptrcondition=false
+		If lowprim=true
+			Dec opprim
+			if subtype!=(cCALLEX_primsec)
+				#at callex they can be different
+				Dec opsec
+			else
+			#if lowsec==true;dec opsec
+				#it is not possible to push from ff...al and scalar push using full rcx*8 at normal (therefor same for ff...cl)
+				return "Second argument at CALLEX must not be one byte."
+			endelse
+		ElseIf lowsec=true
+			#Dec opsec
+			If sameimportant=true
+				#Set intchar regprep
+				set is_prepare (TRUE)
+			Else
+				Dec opprim
+				Dec opsec
+			EndElse
+		EndElseIf
+	Else
+		sd store_big;set store_big (FALSE)
+		If lowprim=lowsec
+			If lowprim=true
+				Dec opprim
+				Dec opsec
+			else
+			#this code with the rex promotes, if this near comp later,undefined dataargsec(1==1)will go wrong in is_big, viol
+				setcall imm getisimm()
+				if imm=false
+				#it is 1==big/medium
+					setcall store_big is_big(dataargsec,sufixsec)
+				endif
+			endelse
+		Else
+			#Dec opsec
+			#Set intchar eaxreg
+			set is_prepare (TRUE)
+			If lowprim=true
+				#case compare low vs high, then: get low on all eax compare with high but op from mem vs proc becomes proc vs mem
+				Add opprim two
+				add compimmop two
+
+				#note that xor eax,eax will zero rax (not needing xor rax,rax)
+				Data aux#1
+				Set aux dataargprim;Set dataargprim dataargsec;Set dataargsec aux
+				Set aux sufixprim;Set sufixprim sufixsec;Set sufixsec aux
+				call switchimm()
+				#and for ss#
+				set aux lowprim;set lowprim lowsec;set lowsec aux
+				#and char==#sd
+				set aux remind_first_prefix;set remind_first_prefix p_prefix#;set p_prefix# aux
+			EndIf
+		EndElse
+	EndElse
+
+	Data codeptr%%ptr_codesec
+
+	If primcalltype=false
+		setcall imm getisimm()
+		if imm=true
+			#char immtake=0xB8
+			#set opsec immtake
+			#if divmul==(TRUE)
+			#	add opsec 1
+			#elseif subtype==(cCALLEX_primsec)
+			#	add opsec 1
+			#endelseif
+			if subtype!=(cCALLEX_primsec)
+				SetCall errnr write_imm_trunc(dataargsec,regopcode,lowprim,dataargprim,sufixprim)
+			else
+				SetCall errnr write_imm_sign(dataargsec,regopcode)
+			endelse
+		else
+			if p_prefix#=(FALSE)
+				sd comp_at_bigs
+				setcall comp_at_bigs comp_sec(lowsec,dataargprim,sufixprim,dataargsec,sufixsec,sameimportant,is_prepare)
+				setcall errnr writeop_promotes(dataargsec,opsec,sufixsec,regopcode,lowsec,comp_at_bigs)
+			else
+			#only take at prefix on regcode
+				setcall errnr writetake_offset(regopcode,dataargsec)
+				#call writeoperation_take(#errnr,dataargsec,sufixsec,regopcode,lowsec)
+				#pprefix is reset in the road at remind
+			endelse
+			#call restore_argmask_ex(dataargsec)
+		endelse
+		If errnr!=noerr
+			Return errnr
+		EndIf
+	Elseif divmul=(TRUE)
+		#only at multcall and divcall
+		char transferreturntoecx={0x89,0xc1}
+		str ptrcall^transferreturntoecx
+		data calltransfersize=2
+		if big=(TRUE)
+			call rex_w(#errnr)
+			If errnr!=noerr;Return errnr;EndIf
+		endif
+		setcall errnr addtosec(ptrcall,calltransfersize,codeptr)
+		If errnr!=noerr
+			Return errnr
+		EndIf
+	EndElseif
+
+	#write first arg, the second already was
+	set p_prefix# remind_first_prefix
+	call restorefirst_isimm()
+
+	#setcall imm getfirst_isimm() can be this but needing to deactivate imm slot
+	setcall imm getisimm()
+	if imm=true
+		#first argument imm are comparations
+		#first value is imm, or second value is imm (switched)
+		SetCall errnr write_imm_sign(dataargprim,(ecxregnumber)) #0xb8+
+	else
+		SetCall errnr writeop_prim(dataargprim,opprim,sufixprim,lowprim,sameimportant,lowsec)
+	endelse
+	If errnr!=noerr
+		Return errnr
+	EndIf
+
+	If divmul=true
+		Data regreg=RegReg
+
+		Char regopcodemult={5}
+		#If you don't care about the upper half, you can use either mul or imul
+		Char regopcodeex#1
+
+		If subtype=(cMULT)
+			Set regopcodeex regopcodemult
+		Else
+			setcall errnr div_prepare(lowprim,big,#regopcodeex,is_signed)
+		EndElse
+
+		Char opcodexini={0xF7}
+		Char opcodeex#1
+		Char modrmex#1
+		Data sizeex=2
+		Str ptropcodeex^opcodeex
+		Char storeex#1
+		char storeexrm#1
+
+		Set opcodeex opcodexini
+		Set storeex atmemtheproc
+
+		If lowprim=true
+			Dec opcodeex
+			Dec storeex
+		EndIf
+
+		SetCall modrmex formmodrm(regreg,regopcodeex,ecxreg)
+		Set regopcodeex modrmex
+
+		if big=(TRUE)
+			call rex_w(#errnr)
+			If errnr!=noerr;Return errnr;EndIf
+		endif
+		SetCall errnr addtosec(ptropcodeex,sizeex,codeptr)
+		If errnr!=noerr
+			Return errnr
+		EndIf
+
+		if lowprim=(TRUE)
+		# str# ss# char
+		#rdx is ready
+			if rem=(FALSE)
+				setcall storeexrm formmodrm((mod_0),eaxreg,(edxregnumber))
+			else
+				setcall storeexrm formmodrm((mod_0),(ahregnumber),(edxregnumber))
+			endelse
+			setcall errnr addtosec(#storeex,2,codeptr)
+		else
+			if rem=(FALSE)
+				SetCall errnr writeop(dataargprim,storeex,sufixprim,eaxreg,lowprim)
+			else
+				SetCall errnr writeoperation(dataargprim,storeex,sufixprim,(edxregnumber),ecxreg,lowprim)
+			endelse
+		endelse
+	ElseIf ptrcondition!=false
+		if imm=true
+			#first imm true only at comparations
+			#continue to write the imm comparation(first is imm, second doesnt care)ex: 1(constant)==1(constant)->cmp ecx,eax (eax,ecx can be if switch)
+			char immcompdata#1
+			set immcompdata compimmop
+			char *immcompdatamodrm=0xc1
+			str immcomp^immcompdata
+			data immcompsz=2
+			if store_big=(TRUE)
+				call rex_w(#errnr)
+				If errnr!=noerr;Return errnr;EndIf
+			endif
+			SetCall errnr addtosec(immcomp,immcompsz,codeptr)
+			If errnr!=noerr
+				Return errnr
+			EndIf
+		endif
+
+		Char jumpifnotcond={0x0f}
+		Char cond#1
+		#this will be resolved at endcond
+		Data *jump#1
+
+		Data jumpcond^jumpifnotcond
+		Data conddatasz=6
+
+		Set cond conditionmodrm
+
+		SetCall errnr addtosec(jumpcond,conddatasz,codeptr)
+	EndElseIf
+	Return errnr
+EndFunction
+
+#-1 normal, 0 unpromote, 1 sign extend, 2 zero extend
+function comp_sec(sd lowsec,sd dataargprim,sd sufixprim,sd dataargsec,sd sufixsec,sd sameimportant,sd is_prepare)
+	sd prim
+	if lowsec=(FALSE)
+		setcall prim is_big_imm(dataargprim,sufixprim)
+		sd sec;setcall sec is_big(dataargsec,sufixsec)
+		if prim!=sec
+			if sec=(TRUE)
+				#first is low/medium, don't promote the big second
+				return 0
+			elseif sameimportant=(TRUE)
+				#first is big, second is medium, keep sign for second
+				return 1
+			endelseif
+		endif
+	elseif is_prepare=(TRUE)
+		setcall prim is_big_imm(dataargprim,sufixprim)
+		if prim=(TRUE)
+			#zero extend all r64
+			sd p;setcall p val64_p_get()
+			set p# (val64_willbe)
+		endif
+		return 2
+	endelseif
+	return -1
+endfunction
+
+#bool
+function is_big_imm(sd data,sd sufix)
+	sd immprim
+	setcall immprim getfirst_isimm()
+	if immprim=(FALSE)
+		sd b
+		setcall b is_big(data,sufix)
+		return b
+	endif
+	return (FALSE)
+endfunction
+
+function writeoper(sd takeindex,sd location,sd sufix)
+	sd err
+	setcall err writetake_offset(takeindex,location)
+	If err=(noerror)
+		if sufix=(sufix_true)
+			sd t;setcall t sufix64(location)
+			setcall err sufix_take(takeindex,t)
+		endif
+	endif
+	return err
+endfunction
+
+function writeop_prim(sd dataargprim,sd opprim,sd sufixprim,sd lowprim,sd sameimportant,sd lowsec)
+	sd err
+	if sameimportant=(FALSE)
+		if lowsec=(TRUE)
+			#this is and/or... at sd low not needing to write rex
+			setcall err writeoper((edxregnumber),dataargprim,sufixprim)
+			if err!=(noerror);return err;endif
+			setcall err writeoperation_op(opprim,(FALSE),(eaxregnumber),(edxregnumber))
+			return err
+		endif
+	endif
+	SetCall err writeop(dataargprim,opprim,sufixprim,(eaxregnumber),lowprim)
+	return err
+endfunction
+
+#err
+function writeop_promotes(sd dataarg,sd op,sd sufix,sd regopcode,sd low,sd comp_at_bigs)
+	sd err
+	if comp_at_bigs=-1
+		SetCall err writeop(dataarg,op,sufix,regopcode,low)
+	else #0-2
+		setcall err writeoper((edxregnumber),dataarg,sufix) #no val64 recordings
+		if err=(noerror)
+			if comp_at_bigs=1 #these are all 64
+				# sd    data    must take signextended data at 64
+				set op (moveatprocthemem_sign)
+				sd p;setcall p val64_p_get()
+				set p# (val64_willbe)
+			elseif comp_at_bigs=2
+				#2 for zero extend; these are all low
+				set op 0xb6
+			endelseif
+			setcall err writeoperation_op(op,low,regopcode,(edxregnumber))
+		endif
+	endelse
+	return err
+endfunction
+
+#function argmasks()
+#	value a#5 #aligned(no casts at the time of write)
+#	return #a
+#endfunction
+#function store_argmask(sd data)
+#	ss a
+#	setcall a argmasks()
+#	inc a#
+#	if a#==2
+#		add a (2*:)
+#	endif
+#	incst a
+#	set a#v^ data
+#	incst a
+#	add data (maskoffset)
+#	set a#d^ data#
+#endfunction
+#function restore_argmask()
+#	call restore_argmask_ex((NULL))
+#endfunction
+#function restore_argmask_ex(sd original)
+#	ss a
+#	setcall a argmasks()
+#	if a#>0
+#		sv copy;set copy a
+#		if a#==2
+#			add copy (2*:)
+#		endif
+#		incst copy
+#		sd data
+#		set data copy#
+#		if original!=(NULL)
+#			if data!=original
+#				ret  #this is the case when castfirst secondnothing and try to restore second onfirst
+#			endif
+#		endif
+#		incst copy
+#		add data (maskoffset)
+#		set data# copy#d^
+#		dec a#
+#	endif
+#endfunction
+
+
+#err
+function div_prepare(sd low,sd big,ss p_regopcode,sd is_signed)
+	const bt_atdiv=bt_reg_imm8|eaxregnumber
+	vData codeptr%%ptr_codesec
+	Char regopcodeidiv={7}
+	sd errnr
+	if big=(TRUE)
+	#bt rax,63;jnc,;mov -1,rdx;jmp,
+		const div_prepare_high=\
+		char high={REX_Operand_64,twobytesinstruction_byte1,bt_instruction,bt_atdiv,63,jnc_instruction,9,REX_Operand_64,mov_imm_to_rm,regregmod|edxregnumber,-1,-1,-1,-1,jmp_rel8,5}
+	#In x64, any operation on a 32-bit register clears the top 32 bits of the corresponding 64-bit register too, so there's no need to use mov 0,rax (and xor rax, rax)
+	#mov 0,edx
+		const div_prepare_high_unsigned=\
+		char highu={atedximm,0,0,0,0}
+		if is_signed=(TRUE)
+			SetCall errnr addtosec(#high,(\-div_prepare_high),codeptr)
+		else
+			SetCall errnr addtosec(#highu,(\-div_prepare_high_unsigned),codeptr)
+		endelse
+		set p_regopcode# regopcodeidiv
+	elseif low=(FALSE)
+	#bt eax,31;jnc,;mov -1,edx;jmp,
+		const div_prepare_mediu=\
+		char mediu={twobytesinstruction_byte1,bt_instruction,bt_atdiv,31,jnc_instruction,7,atedximm,-1,-1,-1,-1,jmp_rel8,5}
+	#mov 0,edx
+		const div_prepare_mediu_unsigned=\
+		char mediuu={atedximm,0,0,0,0}
+		if is_signed=(TRUE)
+			SetCall errnr addtosec(#mediu,(\-div_prepare_mediu),codeptr)
+		else
+			SetCall errnr addtosec(#mediuu,(\-div_prepare_mediu_unsigned),codeptr)
+		endelse
+		set p_regopcode# regopcodeidiv
+	else
+		const div_prepare_low=\
+	#bt eax,7;jnc,;mov ah,-1;jmp,
+		char small={twobytesinstruction_byte1,bt_instruction,bt_atdiv,7,jnc_instruction,5,0xc6,regregmod|ahregnumber,-1,jmp_rel8,3}
+	#mov ah,0
+		const div_prepare_low_unsigned=\
+		char smallu={0xc6,regregmod|ahregnumber,0}
+		if is_signed=(TRUE)
+		#255/-1 idiv -255 debugger exception (-128 to 127 allowed)
+			SetCall errnr addtosec(#small,(\-div_prepare_low),codeptr)
+		else
+			SetCall errnr addtosec(#smallu,(\-div_prepare_low_unsigned),codeptr)
+		endelse
+		set p_regopcode# 6
+	endelse
+	return errnr
+	#before
+	#xor  test   jns  not
+	#33D2 4885c0 7903 48f7d2
+	#32E4 84c0   7902 f6d4
+	#33D2 85c0   7902 f7d2
+endfunction
+
+#subtype
+function x_call_test(sd subtype,ss content,sd size)
+	and subtype (x_call_flag)
+	if subtype!=0
+		return subtype
+	endif
+	if size!=0 #getarg is erroring here
+		if content#!=(getarg_str)
+			sd bool
+			setcall bool is_constant_related_ascii(content#)
+			if bool=(FALSE)
+				sd sz
+				setcall sz valinmem(content,size,(asciiparenthesisstart)) #to do for comments if required
+				if sz!=size
+					return (x_call_flag)
+				endif
+			endif
+		endif
+	endif
+	return subtype
+endfunction
--- ocompiler-1.orig/src/files/functions/actions/argstwo.s
+++ /dev/null
@@ -1,656 +0,0 @@
-
-#err
-Function twoargs(sv ptrcontent,sd ptrsize,sd subtype,sd ptrcondition)
-	sd err;setcall err twoargs_ex(ptrcontent,ptrsize,subtype,ptrcondition,(allow_no)) #there are 2 more arguments but are not used
-	set main.tempdataReg 0 #this must be after primwrite and/or divmul, and at pass_write
-	return err
-endfunction
-
-#err
-Function twoargs_ex(sv ptrcontent,sd ptrsize,sd subtype,sd ptrcondition,sd allowdata,sd parses)
-	Data lowprim#1
-	Data ptrlowprim^lowprim
-	Data lowsec#1
-	Data ptrlowsec^lowsec
-	Data dataargprim#1
-	Data ptrdataargprim^dataargprim
-	Data dataargsec#1
-	Data ptrdataargsec^dataargsec
-
-	Data sufixprim#1
-	Data sufixsec#1
-	Data ptrsufixprim^sufixprim
-	Data ptrsufixsec^sufixsec
-
-	Data false=FALSE
-	Data true=TRUE
-
-	#Data noreg=noregnumber
-	Data eaxreg=eaxregnumber
-	Data ecxreg=ecxregnumber
-
-	Char opprim#1
-	Char opsec#1
-	Char atprocthemem={moveatprocthemem}
-	Char atmemtheproc={moveatmemtheproc}
-
-	sd imm
-	Data errnr#1
-	Data noerr=noerror
-	SetCall errnr argfilters(ptrcondition,ptrcontent,ptrsize,ptrdataargprim,ptrlowprim,ptrsufixprim,allowdata)
-	If errnr!=noerr
-		Return errnr
-	EndIf
-
-	Data callfn=callfunction
-
-	sd subtype_test
-
-	if allowdata=(allow_later_sec)
-		#pass_init or pass_calls
-		setcall subtype_test x_call_test(subtype,ptrcontent#,ptrsize#)
-		if subtype_test=0
-			if parses=(pass_init)
-				setcall errnr getarg(ptrcontent,ptrsize,ptrsize#,(allow_later),(FORWARD)) #there are 4 more arguments but are not used
-				return errnr
-			else
-			#skip this at pass_calls
-				Call advancecursors(ptrcontent,ptrsize,ptrsize#)
-			endelse
-		else
-			#and subtype (x_callx_flag) #call and callex are testing without and
-			SetCall errnr parsefunction(ptrcontent,ptrsize,callfn,subtype) #there are 2 more arguments but are not used
-			return errnr
-		endelse
-		return (noerror)
-	endif
-
-	Data sameimportant#1
-	Set sameimportant true
-	Data divmul#1
-	Set divmul false
-	#Data regprep#1
-	#Set regprep eaxreg
-	Data regopcode#1
-	Set regopcode eaxreg
-
-	#need to remind first prefix: p1 p2 need_p2 need_p1
-	sd remind_first_prefix
-	sd p_prefix
-	setcall p_prefix prefix_bool()
-
-	set remind_first_prefix p_prefix#;set p_prefix# 0
-	call storefirst_isimm()
-
-	Data primcalltype#1
-	Char two=2
-
-	Set primcalltype false
-
-	sd big
-	If ptrcondition=false
-		#imm second arg can be, at conditions was already called
-		call setimm()
-
-		if subtype=(cCALLEX_primsec)
-		#the text for callexx is elsewhere
-			Set opprim atprocthemem
-			#Set regprep ecxreg
-			Set regopcode ecxreg
-		else
-			setcall subtype_test x_call_test(subtype,ptrcontent#,ptrsize#)
-			if subtype_test!=0
-				Set primcalltype true
-				set subtype_test subtype  ##two more flags at parsefunc
-				and subtype ~x_call_flags
-			endif
-			sd xlog
-			if subtype=(cSET)
-				Set opprim atmemtheproc
-				set xlog (Xfile_action2_set)
-			ElseIf subtype=(cADD)
-				Char addprim={0x01}
-				Set opprim addprim
-				set xlog (Xfile_action2_add)
-			ElseIf subtype=(cSUB)
-				Char subprim={0x29}
-				Set opprim subprim
-				set xlog (Xfile_action2_sub)
-			ElseIf subtype<=(cREMU)
-				Set opprim atprocthemem
-				#Set regprep ecxreg
-				Set regopcode ecxreg
-				Set divmul true
-				if lowprim=(FALSE);setcall big is_big(dataargprim,sufixprim)
-				else;set big (FALSE);endelse
-				sd rem
-				if subtype=(cMULT)
-					set rem (FALSE)
-					set xlog (Xfile_action2_mult)
-				else
-					sd is_signed
-					if subtype=(cDIV)
-						set rem (FALSE)
-						set is_signed (TRUE)
-						set xlog (Xfile_action2_div)
-					elseif subtype=(cDIVU)
-						set rem (FALSE)
-						set is_signed (FALSE)
-						set xlog (Xfile_action2_divu)
-					elseif subtype=(cREM)
-						set rem (TRUE)
-						set is_signed (TRUE)
-						set xlog (Xfile_action2_rem)
-					else
-					#if subtype=(cREMU)
-						set rem (TRUE)
-						set is_signed (FALSE)
-						set xlog (Xfile_action2_remu)
-					endelse
-				endelse
-			Else
-			#If subtype<=(cXOR)
-				Set sameimportant false
-				If subtype=(cAND)
-					Char andprim={0x21}
-					Set opprim andprim
-					set xlog (Xfile_action2_and)
-				ElseIf subtype=(cOR)
-					Char orprim={0x09}
-					Set opprim orprim
-					set xlog (Xfile_action2_or)
-				Else
-				#(cXOR)
-					Char xorprim={0x31}
-					Set opprim xorprim
-					set xlog (Xfile_action2_xor)
-				EndElse
-			EndElse
-			SetCall errnr xfile_add_char_if(xlog)
-			If errnr!=noerr
-				Return errnr
-			EndIf
-		EndElse
-	Else
-		Data sz#1
-		Data condition#1
-		Set condition ptrcondition#
-		SetCall sz strlen(condition)
-		Add condition sz
-		Call advancecursors(ptrcontent,ptrsize,sz)
-
-		Data one=1
-		Add condition one
-
-		Char compare=0x39
-		Set opprim compare
-
-		#imm specific
-		char compimminitial={0x39}
-		char compimmop#1
-		set compimmop compimminitial
-
-		Data conditionmodrm#1
-		Set conditionmodrm condition#
-
-		setcall errnr xfile_add_char_if(conditionmodrm)
-		if errnr!=(noerror)
-			return errnr
-		endif
-	EndElse
-
-	If primcalltype=false
-		if ptrcondition=false
-			if subtype!=(cCALLEX_primsec)
-				SetCall errnr arg(ptrcontent,ptrsize,ptrdataargsec,ptrlowsec,ptrsufixsec,true,(allow_yes))
-			else
-				SetCall errnr arg(ptrcontent,ptrsize,ptrdataargsec,ptrlowsec,ptrsufixsec,true,(allow_no))
-			endelse
-		else
-			call resetisimm() #the first imm is stored, isimm is only set, and if is not will not unset it
-			SetCall errnr arg(ptrcontent,ptrsize,ptrdataargsec,ptrlowsec,ptrsufixsec,true,(allow_no)) #if not this allow no, Xfile_arg_varfn can go in the next if, that with allow yes
-		endelse
-		If errnr!=noerr
-			Return errnr
-		EndIf
-	Else
-		setcall errnr xfile_add_char_if((Xfile_arg_call))
-		if errnr=(noerror)
-			SetCall errnr parsefunction(ptrcontent,ptrsize,callfn,subtype_test) #there is 1 more argument but is not used
-			If errnr!=noerr
-				Return errnr
-			EndIf
-		else
-			return errnr
-		endelse
-	EndElse
-
-	#Data intchar#1
-	data is_prepare#1
-	set is_prepare (FALSE)
-	#Set intchar noreg
-	Set opsec atprocthemem
-
-	If ptrcondition=false
-		If lowprim=true
-			Dec opprim
-			if subtype!=(cCALLEX_primsec)
-				#at callex they can be different
-				Dec opsec
-			else
-			#if lowsec==true;dec opsec
-				#it is not possible to push from ff...al and scalar push using full rcx*8 at normal (therefor same for ff...cl)
-				return "Second argument at CALLEX must not be one byte."
-			endelse
-		ElseIf lowsec=true
-			#Dec opsec
-			If sameimportant=true
-				#Set intchar regprep
-				set is_prepare (TRUE)
-			Else
-				Dec opprim
-				Dec opsec
-			EndElse
-		EndElseIf
-	Else
-		sd store_big;set store_big (FALSE)
-		If lowprim=lowsec
-			If lowprim=true
-				Dec opprim
-				Dec opsec
-			else
-			#this code with the rex promotes, if this near comp later,undefined dataargsec(1==1)will go wrong in is_big, viol
-				setcall imm getisimm()
-				if imm=false
-				#it is 1==big/medium
-					setcall store_big is_big(dataargsec,sufixsec)
-				endif
-			endelse
-		Else
-			#Dec opsec
-			#Set intchar eaxreg
-			set is_prepare (TRUE)
-			If lowprim=true
-				#case compare low vs high, then: get low on all eax compare with high but op from mem vs proc becomes proc vs mem
-				Add opprim two
-				add compimmop two
-
-				#note that xor eax,eax will zero rax (not needing xor rax,rax)
-				Data aux#1
-				Set aux dataargprim;Set dataargprim dataargsec;Set dataargsec aux
-				Set aux sufixprim;Set sufixprim sufixsec;Set sufixsec aux
-				call switchimm()
-				#and for ss#
-				set aux lowprim;set lowprim lowsec;set lowsec aux
-				#and char==#sd
-				set aux remind_first_prefix;set remind_first_prefix p_prefix#;set p_prefix# aux
-			EndIf
-		EndElse
-	EndElse
-
-	Data codeptr%%ptr_codesec
-
-	If primcalltype=false
-		setcall imm getisimm()
-		if imm=true
-			#char immtake=0xB8
-			#set opsec immtake
-			#if divmul==(TRUE)
-			#	add opsec 1
-			#elseif subtype==(cCALLEX_primsec)
-			#	add opsec 1
-			#endelseif
-			if subtype!=(cCALLEX_primsec)
-				SetCall errnr write_imm_trunc(dataargsec,regopcode,lowprim,dataargprim,sufixprim)
-			else
-				SetCall errnr write_imm_sign(dataargsec,regopcode)
-			endelse
-		else
-			if p_prefix#=(FALSE)
-				sd comp_at_bigs
-				setcall comp_at_bigs comp_sec(lowsec,dataargprim,sufixprim,dataargsec,sufixsec,sameimportant,is_prepare)
-				setcall errnr writeop_promotes(dataargsec,opsec,sufixsec,regopcode,lowsec,comp_at_bigs)
-			else
-			#only take at prefix on regcode
-				setcall errnr writetake_offset(regopcode,dataargsec)
-				#call writeoperation_take(#errnr,dataargsec,sufixsec,regopcode,lowsec)
-				#pprefix is reset in the road at remind
-			endelse
-			#call restore_argmask_ex(dataargsec)
-		endelse
-		If errnr!=noerr
-			Return errnr
-		EndIf
-	Elseif divmul=(TRUE)
-		#only at multcall and divcall
-		char transferreturntoecx={0x89,0xc1}
-		str ptrcall^transferreturntoecx
-		data calltransfersize=2
-		if big=(TRUE)
-			call rex_w(#errnr)
-			If errnr!=noerr;Return errnr;EndIf
-		endif
-		setcall errnr addtosec(ptrcall,calltransfersize,codeptr)
-		If errnr!=noerr
-			Return errnr
-		EndIf
-	EndElseif
-
-	#write first arg, the second already was
-	set p_prefix# remind_first_prefix
-	call restorefirst_isimm()
-
-	#setcall imm getfirst_isimm() can be this but needing to deactivate imm slot
-	setcall imm getisimm()
-	if imm=true
-		#first argument imm are comparations
-		#first value is imm, or second value is imm (switched)
-		SetCall errnr write_imm_sign(dataargprim,(ecxregnumber)) #0xb8+
-	else
-		SetCall errnr writeop_prim(dataargprim,opprim,sufixprim,lowprim,sameimportant,lowsec)
-	endelse
-	If errnr!=noerr
-		Return errnr
-	EndIf
-
-	If divmul=true
-		Data regreg=RegReg
-
-		Char regopcodemult={5}
-		#If you don't care about the upper half, you can use either mul or imul
-		Char regopcodeex#1
-
-		If subtype=(cMULT)
-			Set regopcodeex regopcodemult
-		Else
-			setcall errnr div_prepare(lowprim,big,#regopcodeex,is_signed)
-		EndElse
-
-		Char opcodexini={0xF7}
-		Char opcodeex#1
-		Char modrmex#1
-		Data sizeex=2
-		Str ptropcodeex^opcodeex
-		Char storeex#1
-		char storeexrm#1
-
-		Set opcodeex opcodexini
-		Set storeex atmemtheproc
-
-		If lowprim=true
-			Dec opcodeex
-			Dec storeex
-		EndIf
-
-		SetCall modrmex formmodrm(regreg,regopcodeex,ecxreg)
-		Set regopcodeex modrmex
-
-		if big=(TRUE)
-			call rex_w(#errnr)
-			If errnr!=noerr;Return errnr;EndIf
-		endif
-		SetCall errnr addtosec(ptropcodeex,sizeex,codeptr)
-		If errnr!=noerr
-			Return errnr
-		EndIf
-
-		if lowprim=(TRUE)
-		# str# ss# char
-		#rdx is ready
-			if rem=(FALSE)
-				setcall storeexrm formmodrm((mod_0),eaxreg,(edxregnumber))
-			else
-				setcall storeexrm formmodrm((mod_0),(ahregnumber),(edxregnumber))
-			endelse
-			setcall errnr addtosec(#storeex,2,codeptr)
-		else
-			if rem=(FALSE)
-				SetCall errnr writeop(dataargprim,storeex,sufixprim,eaxreg,lowprim)
-			else
-				SetCall errnr writeoperation(dataargprim,storeex,sufixprim,(edxregnumber),ecxreg,lowprim)
-			endelse
-		endelse
-	ElseIf ptrcondition!=false
-		if imm=true
-			#first imm true only at comparations
-			#continue to write the imm comparation(first is imm, second doesnt care)ex: 1(constant)==1(constant)->cmp ecx,eax (eax,ecx can be if switch)
-			char immcompdata#1
-			set immcompdata compimmop
-			char *immcompdatamodrm=0xc1
-			str immcomp^immcompdata
-			data immcompsz=2
-			if store_big=(TRUE)
-				call rex_w(#errnr)
-				If errnr!=noerr;Return errnr;EndIf
-			endif
-			SetCall errnr addtosec(immcomp,immcompsz,codeptr)
-			If errnr!=noerr
-				Return errnr
-			EndIf
-		endif
-
-		Char jumpifnotcond={0x0f}
-		Char cond#1
-		#this will be resolved at endcond
-		Data *jump#1
-
-		Data jumpcond^jumpifnotcond
-		Data conddatasz=6
-
-		Set cond conditionmodrm
-
-		SetCall errnr addtosec(jumpcond,conddatasz,codeptr)
-	EndElseIf
-	Return errnr
-EndFunction
-
-#-1 normal, 0 unpromote, 1 sign extend, 2 zero extend
-function comp_sec(sd lowsec,sd dataargprim,sd sufixprim,sd dataargsec,sd sufixsec,sd sameimportant,sd is_prepare)
-	sd prim
-	if lowsec=(FALSE)
-		setcall prim is_big_imm(dataargprim,sufixprim)
-		sd sec;setcall sec is_big(dataargsec,sufixsec)
-		if prim!=sec
-			if sec=(TRUE)
-				#first is low/medium, don't promote the big second
-				return 0
-			elseif sameimportant=(TRUE)
-				#first is big, second is medium, keep sign for second
-				return 1
-			endelseif
-		endif
-	elseif is_prepare=(TRUE)
-		setcall prim is_big_imm(dataargprim,sufixprim)
-		if prim=(TRUE)
-			#zero extend all r64
-			sd p;setcall p val64_p_get()
-			set p# (val64_willbe)
-		endif
-		return 2
-	endelseif
-	return -1
-endfunction
-
-#bool
-function is_big_imm(sd data,sd sufix)
-	sd immprim
-	setcall immprim getfirst_isimm()
-	if immprim=(FALSE)
-		sd b
-		setcall b is_big(data,sufix)
-		return b
-	endif
-	return (FALSE)
-endfunction
-
-function writeoper(sd takeindex,sd location,sd sufix)
-	sd err
-	setcall err writetake_offset(takeindex,location)
-	If err=(noerror)
-		if sufix=(sufix_true)
-			sd t;setcall t sufix64(location)
-			setcall err sufix_take(takeindex,t)
-		endif
-	endif
-	return err
-endfunction
-
-function writeop_prim(sd dataargprim,sd opprim,sd sufixprim,sd lowprim,sd sameimportant,sd lowsec)
-	sd err
-	if sameimportant=(FALSE)
-		if lowsec=(TRUE)
-			#this is and/or... at sd low not needing to write rex
-			setcall err writeoper((edxregnumber),dataargprim,sufixprim)
-			if err!=(noerror);return err;endif
-			setcall err writeoperation_op(opprim,(FALSE),(eaxregnumber),(edxregnumber))
-			return err
-		endif
-	endif
-	SetCall err writeop(dataargprim,opprim,sufixprim,(eaxregnumber),lowprim)
-	return err
-endfunction
-
-#err
-function writeop_promotes(sd dataarg,sd op,sd sufix,sd regopcode,sd low,sd comp_at_bigs)
-	sd err
-	if comp_at_bigs=-1
-		SetCall err writeop(dataarg,op,sufix,regopcode,low)
-	else #0-2
-		setcall err writeoper((edxregnumber),dataarg,sufix) #no val64 recordings
-		if err=(noerror)
-			if comp_at_bigs=1 #these are all 64
-				# sd    data    must take signextended data at 64
-				set op (moveatprocthemem_sign)
-				sd p;setcall p val64_p_get()
-				set p# (val64_willbe)
-			elseif comp_at_bigs=2
-				#2 for zero extend; these are all low
-				set op 0xb6
-			endelseif
-			setcall err writeoperation_op(op,low,regopcode,(edxregnumber))
-		endif
-	endelse
-	return err
-endfunction
-
-#function argmasks()
-#	value a#5 #aligned(no casts at the time of write)
-#	return #a
-#endfunction
-#function store_argmask(sd data)
-#	ss a
-#	setcall a argmasks()
-#	inc a#
-#	if a#==2
-#		add a (2*:)
-#	endif
-#	incst a
-#	set a#v^ data
-#	incst a
-#	add data (maskoffset)
-#	set a#d^ data#
-#endfunction
-#function restore_argmask()
-#	call restore_argmask_ex((NULL))
-#endfunction
-#function restore_argmask_ex(sd original)
-#	ss a
-#	setcall a argmasks()
-#	if a#>0
-#		sv copy;set copy a
-#		if a#==2
-#			add copy (2*:)
-#		endif
-#		incst copy
-#		sd data
-#		set data copy#
-#		if original!=(NULL)
-#			if data!=original
-#				ret  #this is the case when castfirst secondnothing and try to restore second onfirst
-#			endif
-#		endif
-#		incst copy
-#		add data (maskoffset)
-#		set data# copy#d^
-#		dec a#
-#	endif
-#endfunction
-
-
-#err
-function div_prepare(sd low,sd big,ss p_regopcode,sd is_signed)
-	const bt_atdiv=bt_reg_imm8|eaxregnumber
-	vData codeptr%%ptr_codesec
-	Char regopcodeidiv={7}
-	sd errnr
-	if big=(TRUE)
-	#bt rax,63;jnc,;mov -1,rdx;jmp,
-		const div_prepare_high=\
-		char high={REX_Operand_64,twobytesinstruction_byte1,bt_instruction,bt_atdiv,63,jnc_instruction,9,REX_Operand_64,mov_imm_to_rm,regregmod|edxregnumber,-1,-1,-1,-1,jmp_rel8,5}
-	#In x64, any operation on a 32-bit register clears the top 32 bits of the corresponding 64-bit register too, so there's no need to use mov 0,rax (and xor rax, rax)
-	#mov 0,edx
-		const div_prepare_high_unsigned=\
-		char highu={atedximm,0,0,0,0}
-		if is_signed=(TRUE)
-			SetCall errnr addtosec(#high,(\-div_prepare_high),codeptr)
-		else
-			SetCall errnr addtosec(#highu,(\-div_prepare_high_unsigned),codeptr)
-		endelse
-		set p_regopcode# regopcodeidiv
-	elseif low=(FALSE)
-	#bt eax,31;jnc,;mov -1,edx;jmp,
-		const div_prepare_mediu=\
-		char mediu={twobytesinstruction_byte1,bt_instruction,bt_atdiv,31,jnc_instruction,7,atedximm,-1,-1,-1,-1,jmp_rel8,5}
-	#mov 0,edx
-		const div_prepare_mediu_unsigned=\
-		char mediuu={atedximm,0,0,0,0}
-		if is_signed=(TRUE)
-			SetCall errnr addtosec(#mediu,(\-div_prepare_mediu),codeptr)
-		else
-			SetCall errnr addtosec(#mediuu,(\-div_prepare_mediu_unsigned),codeptr)
-		endelse
-		set p_regopcode# regopcodeidiv
-	else
-		const div_prepare_low=\
-	#bt eax,7;jnc,;mov ah,-1;jmp,
-		char small={twobytesinstruction_byte1,bt_instruction,bt_atdiv,7,jnc_instruction,5,0xc6,regregmod|ahregnumber,-1,jmp_rel8,3}
-	#mov ah,0
-		const div_prepare_low_unsigned=\
-		char smallu={0xc6,regregmod|ahregnumber,0}
-		if is_signed=(TRUE)
-		#255/-1 idiv -255 debugger exception (-128 to 127 allowed)
-			SetCall errnr addtosec(#small,(\-div_prepare_low),codeptr)
-		else
-			SetCall errnr addtosec(#smallu,(\-div_prepare_low_unsigned),codeptr)
-		endelse
-		set p_regopcode# 6
-	endelse
-	return errnr
-	#before
-	#xor  test   jns  not
-	#33D2 4885c0 7903 48f7d2
-	#32E4 84c0   7902 f6d4
-	#33D2 85c0   7902 f7d2
-endfunction
-
-#subtype
-function x_call_test(sd subtype,ss content,sd size)
-	and subtype (x_call_flag)
-	if subtype!=0
-		return subtype
-	endif
-	if size!=0 #getarg is erroring here
-		if content#!=(getarg_str)
-			sd bool
-			setcall bool is_constant_related_ascii(content#)
-			if bool=(FALSE)
-				sd sz
-				setcall sz valinmem(content,size,(asciiparenthesisstart)) #to do for comments if required
-				if sz!=size
-					return (x_call_flag)
-				endif
-			endif
-		endif
-	endif
-	return subtype
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/actions/dataparse.oc
@@ -0,0 +1,305 @@
+
+
+#err
+Function entryvarsfns(data content,data size)
+	Data notype=notype
+	Data pointer#1
+	SetCall pointer strinvars_ignoreref(content,size,notype)
+	Data noerr=noerror
+	Data zero=0
+	If pointer=zero
+		Data fns%%ptr_functions
+		SetCall pointer vars_ignoreref(content,size,fns)
+		If pointer=zero
+			Return noerr
+		EndIf
+	EndIf
+
+	Char varfndup="Variable/Function name is already defined."
+	Str ptrvarfndup^varfndup
+	Return ptrvarfndup
+EndFunction
+
+#relocated offset or for objects
+function get_img_vdata()   #(exandbit & nobits) = .nbsection
+	Data value#1
+	Data inter#1
+
+	Data ptrimageoff%ptrimagebaseoffset
+	Data ptrdataoff%ptrstartofdata
+
+	Set value ptrimageoff#
+	Set inter ptrdataoff#
+	Add value inter
+	return value
+endfunction
+#same
+function get_dataReg()
+	vdata ptrdataReg%%ptr_dataReg
+	return ptrdataReg#
+endfunction
+#same
+function get_dataSize()
+	vdata ptrdataSize%ptrdataSize
+	sd reg;set reg ptrdataSize#
+	vdata ptr_nobits_virtual%ptr_nobits_virtual
+	if ptr_nobits_virtual#=(Yes)
+		#this is here because this function is called from fndecargs and from simple declare add reference
+		vdata ptr_nobitsDataStart%ptr_nobitsDataStart
+		sub reg ptr_nobitsDataStart#
+	endif
+	return reg
+endfunction
+#same
+function get_img_vdata_dataReg()
+	sd reg;setcall reg get_img_vdata()
+	addcall reg get_dataReg()
+	return reg
+endfunction
+#same
+function get_img_vdata_dataSize()
+	sd reg;setcall reg get_img_vdata()
+	addcall reg get_dataSize()
+	return reg
+endfunction
+
+#err
+Function addvarreference(sv ptrcontent,sd ptrsize,sd valsize,sd typenumber,sd mask,sd stackoffset,sd is_expand)
+	#duplications
+	Data content#1
+	Set content ptrcontent#
+	Data zero=0
+	Data constantsnr=constantsnumber
+	Data value#1
+	Data errnr#1
+	Data noerr=noerror
+	data false=0
+
+	If typenumber!=constantsnr
+		SetCall errnr entryvarsfns(content,valsize)
+		If errnr!=noerr
+			Return errnr
+		EndIf
+		data stack#1
+		data ptrS^stack
+		call stackfilter(typenumber,ptrS)
+		if stack=false
+			if is_expand=(TRUE)
+				setcall value get_img_vdata_dataSize()
+
+				#commented was before expandbit at class scopes
+				#sd ptr_nobits_virtual%ptr_nobits_virtual
+				#if ptr_nobits_virtual#==(Yes)
+				or mask (expandbit)
+				#endif
+			else
+				setcall value get_img_vdata_dataReg()
+			endelse
+		else
+			if stackoffset=zero
+				#stack free declared
+				setcall value getramp_ebxrel()
+				#data ebx_relative=ebxregnumber*tostack_relative
+				#or mask ebx_relative
+			else
+				#stack function argument
+				set value stackoffset
+				#data ebp_relative=ebpregnumber*tostack_relative
+				or mask (stackrelativebit)
+			endelse
+			or mask (stackbit)
+			sd vbool
+			if typenumber=(stackvaluenumber);set vbool (TRUE);else;setcall vbool sd_as_sv((sd_as_sv_bool),typenumber);endelse
+			if vbool=(TRUE)
+				or mask (pointbit)
+			endif
+		endelse
+	Else
+		Data structure#1
+		SetCall structure getstructcont(constantsnr)
+		Data pointer#1
+		SetCall pointer vars(content,valsize,structure)
+		If pointer!=zero
+			Char constdup="Constant name is already defined."
+			Str pconstdup^constdup
+			Return pconstdup
+		EndIf
+		#this will be set outside Set value 0
+	EndElse
+
+	SetCall errnr addaref(value,ptrcontent,ptrsize,valsize,typenumber,mask)
+	Return errnr
+EndFunction
+
+#err
+function addvarreferenceorunref(sv ptrcontent,sd ptrsize,sd valsize,sd typenumber,sd mask,sd stackoffset,sd is_expand)
+	data err#1
+	data noerr=noerror
+
+	Data zero=0
+	If valsize=zero
+		Char _namecverr="Name for variable/constant expected."
+		vStr namecverr^_namecverr
+		Return namecverr
+	EndIf
+
+	data content#1
+	set content ptrcontent#
+	Char firstchar#1
+	Set firstchar content#
+
+	If firstchar!=(unrefsign)
+		if firstchar=(throwlesssign)   #throwless if on a throwing area
+			If typenumber=(constantsnumber)
+				Return "Unexpected throwless sign ('&') at constant declaration."
+			EndIf
+			dec valsize
+			If valsize=zero
+				Return "Name for variable expected."
+			endif
+			or mask (aftercallthrowlessbit)
+			call stepcursors(ptrcontent,ptrsize)
+		elseIf typenumber!=(constantsnumber)
+			sd global_err_pB;setcall global_err_pB global_err_pBool()
+			if global_err_pB#=(FALSE)
+				or mask (aftercallthrowlessbit)
+			endif
+		endelseif
+		SetCall err addvarreference(ptrcontent,ptrsize,valsize,typenumber,mask,stackoffset,is_expand)
+		Return err
+	EndIf
+	If typenumber=(constantsnumber)
+		Char unrefconstant="Unexpected unreference sign ('*') at constant declaration."
+		vStr ptrunrefconstant^unrefconstant
+		Return ptrunrefconstant
+	EndIf
+	Call advancecursors(ptrcontent,ptrsize,valsize)
+	Return noerr
+endfunction
+
+function getsign_size(sd start,sd last,sd mark,sd pdest) #mark is if was ended by a sign or whitespaces
+	if start!=mark
+		sub mark start
+		set pdest# mark
+		ret
+	endif
+	sub last start
+	set pdest# last
+endfunction
+#er
+function getsign(ss content,sd size,ss assigntype,sd ptrsz,sd typenumber,sd stack,sd ptrrelocbool,sd ptrdataxrel)
+	if size>0
+		sd start;set start content
+		sd size_mark;set size_mark start
+		if content#=(unrefsign)
+			call stepcursors(#content,#size)
+			add size content
+			while content!=size
+				if content#!=(assignsign)
+					if content#!=(reservesign)
+						if content#!=(pointersigndeclare)
+							if content#!=(relsign)
+								inc content
+								continue
+							endif
+						endif
+					endif
+				endif
+				set size_mark content
+				break
+			endwhile
+		else
+			add size content
+			while content!=size
+				if content#!=(assignsign)
+					if content#!=(reservesign)
+						if content#!=(pointersigndeclare)
+							if content#!=(relsign)
+								if content#=(asciispace)
+									set size_mark content
+									setcall content mem_spaces(content,size)
+									break
+								elseif content#=(asciitab)
+									set size_mark content
+									setcall content mem_spaces(content,size)
+									break
+								endelseif
+								inc content
+								continue
+							endif
+						endif
+					endif
+				endif
+				set size_mark content
+				break
+			endwhile
+		endelse
+		if content=size
+			if stack=(TRUE)
+				call getsign_size(start,content,size_mark,ptrsz)
+				Set assigntype# (nosign)
+				return (noerror)
+			endif
+		else
+			call getsign_size(start,content,size_mark,ptrsz)
+			if content#=(assignsign)
+				Set assigntype# (assignsign)
+				return (noerror)
+			elseif content#=(reservesign)
+				If typenumber=(constantsnumber)
+					Char constreserveerr="Unexpected reserve sign ('#') at constant declaration."
+					Str ptrconstreserveerr^constreserveerr
+					Return ptrconstreserveerr
+				EndIf
+				Set assigntype# (reservesign)
+				return (noerror)
+			elseif content#=(pointersigndeclare)
+				If typenumber=(charnumber)
+					#grep    stackfilter2 4
+					if stack=(FALSE)
+						Char ptrchar="Incorrect pointer sign ('^') used at CHAR declaration."
+						vStr ptrptrchar^ptrchar
+						Return ptrptrchar
+					endif
+				EndIf
+				Set assigntype# (pointersigndeclare)
+				If typenumber!=(constantsnumber)
+					Set ptrrelocbool# (TRUE)
+				EndIf
+
+				return (noerror)
+			elseif content#=(relsign)
+				Char ptrrelchar="Incorrect relocation sign ('%') used at CHAR/CONST declaration."
+				vStr ptrptrrelchar^ptrrelchar
+				If typenumber=(charnumber)
+					#stackfilter2   grep5
+					if stack=(FALSE)
+						Return ptrptrrelchar
+					endif
+				ElseIf typenumber=(constantsnumber)
+					Return ptrptrrelchar
+				EndElseIf
+				Set assigntype# (assignsign)
+				Set ptrrelocbool# (TRUE)
+
+				#call advancecursors(#content,#size,valsize)
+				#call stepcursors(#content,#size)
+				inc content
+
+				if content=size
+					return "Size 0 when testing for datax relocation."
+				endif
+				#this was moved here because of xfile, to know datax relocation
+				if content#=(relsign)
+					set ptrdataxrel# (TRUE)
+				else
+					set ptrdataxrel# (FALSE)
+				endelse
+				return (noerror)
+			endelseif
+		endelse
+	endif
+	Char _assignoperatorerr="One from the assign operators expected."
+	vStr assignoperatorerr^_assignoperatorerr
+	Return assignoperatorerr
+endfunction
--- ocompiler-1.orig/src/files/functions/actions/dataparse.s
+++ /dev/null
@@ -1,305 +0,0 @@
-
-
-#err
-Function entryvarsfns(data content,data size)
-	Data notype=notype
-	Data pointer#1
-	SetCall pointer strinvars_ignoreref(content,size,notype)
-	Data noerr=noerror
-	Data zero=0
-	If pointer=zero
-		Data fns%%ptr_functions
-		SetCall pointer vars_ignoreref(content,size,fns)
-		If pointer=zero
-			Return noerr
-		EndIf
-	EndIf
-
-	Char varfndup="Variable/Function name is already defined."
-	Str ptrvarfndup^varfndup
-	Return ptrvarfndup
-EndFunction
-
-#relocated offset or for objects
-function get_img_vdata()   #(exandbit & nobits) = .nbsection
-	Data value#1
-	Data inter#1
-
-	Data ptrimageoff%ptrimagebaseoffset
-	Data ptrdataoff%ptrstartofdata
-
-	Set value ptrimageoff#
-	Set inter ptrdataoff#
-	Add value inter
-	return value
-endfunction
-#same
-function get_dataReg()
-	vdata ptrdataReg%%ptr_dataReg
-	return ptrdataReg#
-endfunction
-#same
-function get_dataSize()
-	vdata ptrdataSize%ptrdataSize
-	sd reg;set reg ptrdataSize#
-	vdata ptr_nobits_virtual%ptr_nobits_virtual
-	if ptr_nobits_virtual#=(Yes)
-		#this is here because this function is called from fndecargs and from simple declare add reference
-		vdata ptr_nobitsDataStart%ptr_nobitsDataStart
-		sub reg ptr_nobitsDataStart#
-	endif
-	return reg
-endfunction
-#same
-function get_img_vdata_dataReg()
-	sd reg;setcall reg get_img_vdata()
-	addcall reg get_dataReg()
-	return reg
-endfunction
-#same
-function get_img_vdata_dataSize()
-	sd reg;setcall reg get_img_vdata()
-	addcall reg get_dataSize()
-	return reg
-endfunction
-
-#err
-Function addvarreference(sv ptrcontent,sd ptrsize,sd valsize,sd typenumber,sd mask,sd stackoffset,sd is_expand)
-	#duplications
-	Data content#1
-	Set content ptrcontent#
-	Data zero=0
-	Data constantsnr=constantsnumber
-	Data value#1
-	Data errnr#1
-	Data noerr=noerror
-	data false=0
-
-	If typenumber!=constantsnr
-		SetCall errnr entryvarsfns(content,valsize)
-		If errnr!=noerr
-			Return errnr
-		EndIf
-		data stack#1
-		data ptrS^stack
-		call stackfilter(typenumber,ptrS)
-		if stack=false
-			if is_expand=(TRUE)
-				setcall value get_img_vdata_dataSize()
-
-				#commented was before expandbit at class scopes
-				#sd ptr_nobits_virtual%ptr_nobits_virtual
-				#if ptr_nobits_virtual#==(Yes)
-				or mask (expandbit)
-				#endif
-			else
-				setcall value get_img_vdata_dataReg()
-			endelse
-		else
-			if stackoffset=zero
-				#stack free declared
-				setcall value getramp_ebxrel()
-				#data ebx_relative=ebxregnumber*tostack_relative
-				#or mask ebx_relative
-			else
-				#stack function argument
-				set value stackoffset
-				#data ebp_relative=ebpregnumber*tostack_relative
-				or mask (stackrelativebit)
-			endelse
-			or mask (stackbit)
-			sd vbool
-			if typenumber=(stackvaluenumber);set vbool (TRUE);else;setcall vbool sd_as_sv((sd_as_sv_bool),typenumber);endelse
-			if vbool=(TRUE)
-				or mask (pointbit)
-			endif
-		endelse
-	Else
-		Data structure#1
-		SetCall structure getstructcont(constantsnr)
-		Data pointer#1
-		SetCall pointer vars(content,valsize,structure)
-		If pointer!=zero
-			Char constdup="Constant name is already defined."
-			Str pconstdup^constdup
-			Return pconstdup
-		EndIf
-		#this will be set outside Set value 0
-	EndElse
-
-	SetCall errnr addaref(value,ptrcontent,ptrsize,valsize,typenumber,mask)
-	Return errnr
-EndFunction
-
-#err
-function addvarreferenceorunref(sv ptrcontent,sd ptrsize,sd valsize,sd typenumber,sd mask,sd stackoffset,sd is_expand)
-	data err#1
-	data noerr=noerror
-
-	Data zero=0
-	If valsize=zero
-		Char _namecverr="Name for variable/constant expected."
-		vStr namecverr^_namecverr
-		Return namecverr
-	EndIf
-
-	data content#1
-	set content ptrcontent#
-	Char firstchar#1
-	Set firstchar content#
-
-	If firstchar!=(unrefsign)
-		if firstchar=(throwlesssign)   #throwless if on a throwing area
-			If typenumber=(constantsnumber)
-				Return "Unexpected throwless sign ('&') at constant declaration."
-			EndIf
-			dec valsize
-			If valsize=zero
-				Return "Name for variable expected."
-			endif
-			or mask (aftercallthrowlessbit)
-			call stepcursors(ptrcontent,ptrsize)
-		elseIf typenumber!=(constantsnumber)
-			sd global_err_pB;setcall global_err_pB global_err_pBool()
-			if global_err_pB#=(FALSE)
-				or mask (aftercallthrowlessbit)
-			endif
-		endelseif
-		SetCall err addvarreference(ptrcontent,ptrsize,valsize,typenumber,mask,stackoffset,is_expand)
-		Return err
-	EndIf
-	If typenumber=(constantsnumber)
-		Char unrefconstant="Unexpected unreference sign ('*') at constant declaration."
-		vStr ptrunrefconstant^unrefconstant
-		Return ptrunrefconstant
-	EndIf
-	Call advancecursors(ptrcontent,ptrsize,valsize)
-	Return noerr
-endfunction
-
-function getsign_size(sd start,sd last,sd mark,sd pdest) #mark is if was ended by a sign or whitespaces
-	if start!=mark
-		sub mark start
-		set pdest# mark
-		ret
-	endif
-	sub last start
-	set pdest# last
-endfunction
-#er
-function getsign(ss content,sd size,ss assigntype,sd ptrsz,sd typenumber,sd stack,sd ptrrelocbool,sd ptrdataxrel)
-	if size>0
-		sd start;set start content
-		sd size_mark;set size_mark start
-		if content#=(unrefsign)
-			call stepcursors(#content,#size)
-			add size content
-			while content!=size
-				if content#!=(assignsign)
-					if content#!=(reservesign)
-						if content#!=(pointersigndeclare)
-							if content#!=(relsign)
-								inc content
-								continue
-							endif
-						endif
-					endif
-				endif
-				set size_mark content
-				break
-			endwhile
-		else
-			add size content
-			while content!=size
-				if content#!=(assignsign)
-					if content#!=(reservesign)
-						if content#!=(pointersigndeclare)
-							if content#!=(relsign)
-								if content#=(asciispace)
-									set size_mark content
-									setcall content mem_spaces(content,size)
-									break
-								elseif content#=(asciitab)
-									set size_mark content
-									setcall content mem_spaces(content,size)
-									break
-								endelseif
-								inc content
-								continue
-							endif
-						endif
-					endif
-				endif
-				set size_mark content
-				break
-			endwhile
-		endelse
-		if content=size
-			if stack=(TRUE)
-				call getsign_size(start,content,size_mark,ptrsz)
-				Set assigntype# (nosign)
-				return (noerror)
-			endif
-		else
-			call getsign_size(start,content,size_mark,ptrsz)
-			if content#=(assignsign)
-				Set assigntype# (assignsign)
-				return (noerror)
-			elseif content#=(reservesign)
-				If typenumber=(constantsnumber)
-					Char constreserveerr="Unexpected reserve sign ('#') at constant declaration."
-					Str ptrconstreserveerr^constreserveerr
-					Return ptrconstreserveerr
-				EndIf
-				Set assigntype# (reservesign)
-				return (noerror)
-			elseif content#=(pointersigndeclare)
-				If typenumber=(charnumber)
-					#grep    stackfilter2 4
-					if stack=(FALSE)
-						Char ptrchar="Incorrect pointer sign ('^') used at CHAR declaration."
-						vStr ptrptrchar^ptrchar
-						Return ptrptrchar
-					endif
-				EndIf
-				Set assigntype# (pointersigndeclare)
-				If typenumber!=(constantsnumber)
-					Set ptrrelocbool# (TRUE)
-				EndIf
-
-				return (noerror)
-			elseif content#=(relsign)
-				Char ptrrelchar="Incorrect relocation sign ('%') used at CHAR/CONST declaration."
-				vStr ptrptrrelchar^ptrrelchar
-				If typenumber=(charnumber)
-					#stackfilter2   grep5
-					if stack=(FALSE)
-						Return ptrptrrelchar
-					endif
-				ElseIf typenumber=(constantsnumber)
-					Return ptrptrrelchar
-				EndElseIf
-				Set assigntype# (assignsign)
-				Set ptrrelocbool# (TRUE)
-
-				#call advancecursors(#content,#size,valsize)
-				#call stepcursors(#content,#size)
-				inc content
-
-				if content=size
-					return "Size 0 when testing for datax relocation."
-				endif
-				#this was moved here because of xfile, to know datax relocation
-				if content#=(relsign)
-					set ptrdataxrel# (TRUE)
-				else
-					set ptrdataxrel# (FALSE)
-				endelse
-				return (noerror)
-			endelseif
-		endelse
-	endif
-	Char _assignoperatorerr="One from the assign operators expected."
-	vStr assignoperatorerr^_assignoperatorerr
-	Return assignoperatorerr
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/actions/declare.oc
@@ -0,0 +1,220 @@
+
+#err
+function declare(sv pcontent,sd pcomsize,sd subtype,sd parses,sd bool_64)
+	Data valsize#1
+	Char sign#1
+	#below also at virtual at get_reserve (with mask there)
+	sd is_stack
+	sd typenumber
+	sd mask
+
+	sd unitsize
+
+	sd declare_typenumber
+	sd is_expand
+	setcall declare_typenumber commandSubtypeDeclare_to_typenumber(subtype,#is_expand)
+
+	if parses=(pass_calls)
+		setcall typenumber stackfilter(declare_typenumber,#is_stack)
+		if is_stack=(TRUE)
+			ss a_s_p;setcall a_s_p align_pstack()
+			set a_s_p# (TRUE)
+		endif
+		call advancecursors(pcontent,pcomsize,pcomsize#)
+		return (noerror)
+	endif
+
+	#still can be ok at nobits=No, let natural selection because pnobitsReg is implemented instead of datasecSize at writes for simplicity
+	#if is_expand==(TRUE)
+	#	if parses==(pass_init)
+	#		call advancecursors(pcontent,pcomsize,pcomsize#)
+	#		return (noerror)
+	#	endif
+	#endif
+
+	sd xfile_decltype
+	if declare_typenumber=(vintegernumber)
+		set is_stack (FALSE);set typenumber (integernumber)
+		if bool_64=(TRUE);set mask (datapointbit)
+			if parses=(pass_init)
+				set unitsize (qwsz)
+			else
+				set xfile_decltype (Xfile_decltype_longInt)
+			endelse
+		else;set mask 0
+			if parses=(pass_init)
+				set unitsize (dwsz)
+			else
+				set xfile_decltype (Xfile_decltype_longInt)
+			endelse
+		endelse
+	elseif declare_typenumber=(vstringnumber)
+		set is_stack (FALSE);set typenumber (stringnumber)
+		if bool_64=(TRUE);set mask (datapointbit)
+			if parses=(pass_init)
+				set unitsize (qwsz)
+			else
+				set xfile_decltype (Xfile_decltype_longByte)
+			endelse
+		else;set mask 0
+			if parses=(pass_init)
+				set unitsize (dwsz)
+			else
+				set xfile_decltype (Xfile_decltype_longByte)
+			endelse
+		endelse
+	elseif declare_typenumber=(valuenumber)
+		set is_stack (FALSE);set typenumber (integernumber)
+		if bool_64=(TRUE);set mask (valueslongmask)
+			if parses=(pass_init)
+				set unitsize (qwsz)
+			else
+				set xfile_decltype (Xfile_decltype_long)
+			endelse
+		else;set mask 0
+			if parses=(pass_init)
+				set unitsize (dwsz)
+			else
+				set xfile_decltype (Xfile_decltype_long)
+			endelse
+		endelse
+	elseif declare_typenumber=(vwordnumber)
+		set is_stack (FALSE);set typenumber (integernumber) #place them at integers so they can be callable, "word" are still going to words section, the 2 bytes size is not here, is only at the x file at the moment
+		if bool_64=(TRUE);set mask (datapointbit)
+			if parses=(pass_init)
+				set unitsize (qwsz)
+			else
+				set xfile_decltype (Xfile_decltype_longWord)
+			endelse
+		else;set mask 0
+			if parses=(pass_init)
+				set unitsize (dwsz)
+			else
+				set xfile_decltype (Xfile_decltype_longWord)
+			endelse
+		endelse
+	else
+		setcall typenumber stackfilter(declare_typenumber,#is_stack)
+		if parses=(pass_init)
+			if is_stack=(TRUE)
+				if typenumber=(stringnumber)
+					set unitsize 0
+				else
+					call advancecursors(pcontent,pcomsize,pcomsize#)
+					return (noerror)
+				endelse
+			else
+				if typenumber!=(charnumber)
+					if typenumber!=(constantsnumber)
+						set unitsize (dwsz)
+					endif
+				else
+					set unitsize (bsz)
+				endelse
+			endelse
+		else
+			if is_stack=(TRUE)
+				#must be at the start
+				call entryscope_verify_code()
+
+				#xfile part
+				if typenumber=(valuesinnernumber)
+					set xfile_decltype (Xfile_decltype_long)
+				elseif typenumber=(integernumber)
+					set xfile_decltype (Xfile_decltype_longInt)
+				elseif typenumber=(stringnumber)
+					set xfile_decltype (Xfile_decltype_longByte)
+				else
+				#if typenumber=(wordnumber)
+					set xfile_decltype (Xfile_decltype_longWord)
+				endelse
+			else
+				#xfile part
+				if typenumber=(constantsnumber)
+					set xfile_decltype (Xfile_decltype_const)
+				elseif typenumber=(charnumber)
+					set xfile_decltype (Xfile_decltype_byte)
+				elseif typenumber=(integernumber)
+					set xfile_decltype (Xfile_decltype_int)
+				elseif typenumber=(stringnumber)
+					set xfile_decltype (Xfile_decltype_intByte)
+				else
+				#if typenumber=(wordnumber)
+					set xfile_decltype (Xfile_decltype_word)
+				endelse
+			endelse
+		endelse
+		set mask 0
+	endelse
+
+	sd err
+	sd relocbool=FALSE;sd dataxrel
+	setcall err getsign(pcontent#,pcomsize#,#sign,#valsize,typenumber,is_stack,#relocbool,#dataxrel)
+	if err=(noerror)
+		if parses=(pass_init)
+			if typenumber=(constantsnumber)
+				setcall err addtolog_withchar_ex_atunused(pcontent#,valsize,(log_declare))
+				if err=(noerror)
+					if sign=(pointersigndeclare)
+						call advancecursors(pcontent,pcomsize,pcomsize#)
+						return (noerror)
+					endif
+					setcall err dataassign(pcontent,pcomsize,sign,valsize,typenumber,(NULL),mask,relocbool) #there are 3 more argument but are not used
+					#                                                                            since %%|
+				endif
+			else
+				setcall err vars_log_prepare(pcontent#,valsize)
+				if err=(noerror)
+					if unitsize=0
+					#ss?
+						if sign!=(assignsign)
+							call advancecursors(pcontent,pcomsize,pcomsize#)
+							return (noerror)
+						endif
+						#ss =% ""/x/{}
+					else
+					#search for data%  with R_X86_64_64
+						if relocbool=(TRUE)
+							if mask=0
+							#data str
+							#strs are without ""
+								vdata is_64_and_pref_is_rx866464%p_elf64_r_info_type
+								if is_64_and_pref_is_rx866464#=(R_X86_64_64)
+									set unitsize (qwsz)
+								endif
+							endif
+						endif
+					endelse
+					setcall err dataassign(pcontent,pcomsize,sign,valsize,typenumber,#unitsize,mask,relocbool,dataxrel,is_stack) #there is 1 more argument but is not used
+					#                                                                               since %%|
+					if is_expand=(FALSE)
+						sd pdataReg%%ptr_dataReg
+						add pdataReg# unitsize
+					else
+						sd pnobitsReg%ptrdataSize
+						add pnobitsReg# unitsize
+					endelse
+				endif
+			endelse
+		else
+			setcall err xfile_add_declare_if(xfile_decltype,is_stack,is_expand,pcontent#,valsize,sign,relocbool,dataxrel)
+			if err=(noerror)
+				if typenumber=(constantsnumber)
+					if sign!=(pointersigndeclare)
+						setcall err xfile_add_char_if((Xfile_declmode_value))
+						if err=(noerror)
+							call advancecursors(pcontent,pcomsize,pcomsize#)
+							return (noerror)
+						endif
+					endif
+				elseif is_expand=(TRUE)
+					if sign!=(reservesign)
+						return "Virtual declarations can have only the reserve sign."
+					endif
+				endelseif
+				SetCall err dataassign(pcontent,pcomsize,sign,valsize,typenumber,(NULL),mask,relocbool,dataxrel,is_stack,is_expand)
+			endif
+		endelse
+	endif
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/actions/declare.s
+++ /dev/null
@@ -1,210 +0,0 @@
-
-#err
-function declare(sv pcontent,sd pcomsize,sd bool_64,sd subtype,sd parses)
-	Data valsize#1
-	Char sign#1
-	#below also at virtual at get_reserve (with mask there)
-	sd is_stack
-	sd typenumber
-	sd mask
-
-	sd unitsize
-
-	sd declare_typenumber
-	sd is_expand
-	setcall declare_typenumber commandSubtypeDeclare_to_typenumber(subtype,#is_expand)
-
-	#still can be ok at nobits=No, let natural selection because pnobitsReg is implemented instead of datasecSize at writes for simplicity
-	#if is_expand==(TRUE)
-	#	if parses==(pass_init)
-	#		call advancecursors(pcontent,pcomsize,pcomsize#)
-	#		return (noerror)
-	#	endif
-	#endif
-
-	sd xfile_decltype
-	if declare_typenumber=(vintegernumber)
-		set is_stack (FALSE);set typenumber (integernumber)
-		if bool_64=(TRUE);set mask (datapointbit)
-			if parses=(pass_init)
-				set unitsize (qwsz)
-			else
-				set xfile_decltype (Xfile_decltype_longInt)
-			endelse
-		else;set mask 0
-			if parses=(pass_init)
-				set unitsize (dwsz)
-			else
-				set xfile_decltype (Xfile_decltype_longInt)
-			endelse
-		endelse
-	elseif declare_typenumber=(vstringnumber)
-		set is_stack (FALSE);set typenumber (stringnumber)
-		if bool_64=(TRUE);set mask (datapointbit)
-			if parses=(pass_init)
-				set unitsize (qwsz)
-			else
-				set xfile_decltype (Xfile_decltype_longByte)
-			endelse
-		else;set mask 0
-			if parses=(pass_init)
-				set unitsize (dwsz)
-			else
-				set xfile_decltype (Xfile_decltype_longByte)
-			endelse
-		endelse
-	elseif declare_typenumber=(valuenumber)
-		set is_stack (FALSE);set typenumber (integernumber)
-		if bool_64=(TRUE);set mask (valueslongmask)
-			if parses=(pass_init)
-				set unitsize (qwsz)
-			else
-				set xfile_decltype (Xfile_decltype_long)
-			endelse
-		else;set mask 0
-			if parses=(pass_init)
-				set unitsize (dwsz)
-			else
-				set xfile_decltype (Xfile_decltype_long)
-			endelse
-		endelse
-	elseif declare_typenumber=(vwordnumber)
-		set is_stack (FALSE);set typenumber (integernumber) #place them at integers so they can be callable, "word" are still going to words section, the 2 bytes size is not here, is only at the x file at the moment
-		if bool_64=(TRUE);set mask (datapointbit)
-			if parses=(pass_init)
-				set unitsize (qwsz)
-			else
-				set xfile_decltype (Xfile_decltype_longWord)
-			endelse
-		else;set mask 0
-			if parses=(pass_init)
-				set unitsize (dwsz)
-			else
-				set xfile_decltype (Xfile_decltype_longWord)
-			endelse
-		endelse
-	else
-		setcall typenumber stackfilter(declare_typenumber,#is_stack)
-		if parses=(pass_init)
-			if is_stack=(TRUE)
-				if typenumber=(stringnumber)
-					set unitsize 0
-				else
-					call advancecursors(pcontent,pcomsize,pcomsize#)
-					return (noerror)
-				endelse
-			else
-				if typenumber!=(charnumber)
-					if typenumber!=(constantsnumber)
-						set unitsize (dwsz)
-					endif
-				else
-					set unitsize (bsz)
-				endelse
-			endelse
-		else
-			if is_stack=(TRUE)
-				#must be at the start
-				call entryscope_verify_code()
-
-				#xfile part
-				if typenumber=(valuesinnernumber)
-					set xfile_decltype (Xfile_decltype_long)
-				elseif typenumber=(integernumber)
-					set xfile_decltype (Xfile_decltype_longInt)
-				elseif typenumber=(stringnumber)
-					set xfile_decltype (Xfile_decltype_longByte)
-				else
-				#if typenumber=(wordnumber)
-					set xfile_decltype (Xfile_decltype_longWord)
-				endelse
-			else
-				#xfile part
-				if typenumber=(constantsnumber)
-					set xfile_decltype (Xfile_decltype_const)
-				elseif typenumber=(charnumber)
-					set xfile_decltype (Xfile_decltype_byte)
-				elseif typenumber=(integernumber)
-					set xfile_decltype (Xfile_decltype_int)
-				elseif typenumber=(stringnumber)
-					set xfile_decltype (Xfile_decltype_intByte)
-				else
-				#if typenumber=(wordnumber)
-					set xfile_decltype (Xfile_decltype_word)
-				endelse
-			endelse
-		endelse
-		set mask 0
-	endelse
-
-	sd err
-	sd relocbool=FALSE;sd dataxrel
-	setcall err getsign(pcontent#,pcomsize#,#sign,#valsize,typenumber,is_stack,#relocbool,#dataxrel)
-	if err=(noerror)
-		if parses=(pass_init)
-			if typenumber=(constantsnumber)
-				setcall err addtolog_withchar_ex_atunused(pcontent#,valsize,(log_declare))
-				if err=(noerror)
-					if sign=(pointersigndeclare)
-						call advancecursors(pcontent,pcomsize,pcomsize#)
-						return (noerror)
-					endif
-					setcall err dataassign(pcontent,pcomsize,sign,valsize,typenumber,(NULL),mask,relocbool) #there are 3 more argument but are not used
-					#                                                                            since %%|
-				endif
-			else
-				setcall err vars_log_prepare(pcontent#,valsize)
-				if err=(noerror)
-					if unitsize=0
-					#ss?
-						if sign!=(assignsign)
-							call advancecursors(pcontent,pcomsize,pcomsize#)
-							return (noerror)
-						endif
-						#ss =% ""/x/{}
-					else
-					#search for data%  with R_X86_64_64
-						if relocbool=(TRUE)
-							if mask=0
-							#data str
-							#strs are without ""
-								vdata is_64_and_pref_is_rx866464%p_elf64_r_info_type
-								if is_64_and_pref_is_rx866464#=(R_X86_64_64)
-									set unitsize (qwsz)
-								endif
-							endif
-						endif
-					endelse
-					setcall err dataassign(pcontent,pcomsize,sign,valsize,typenumber,#unitsize,mask,relocbool,dataxrel,is_stack) #there is 1 more argument but is not used
-					#                                                                               since %%|
-					if is_expand=(FALSE)
-						sd pdataReg%%ptr_dataReg
-						add pdataReg# unitsize
-					else
-						sd pnobitsReg%ptrdataSize
-						add pnobitsReg# unitsize
-					endelse
-				endif
-			endelse
-		else
-			setcall err xfile_add_declare_if(xfile_decltype,is_stack,is_expand,pcontent#,valsize,sign,relocbool,dataxrel)
-			if err=(noerror)
-				if typenumber=(constantsnumber)
-					if sign!=(pointersigndeclare)
-						setcall err xfile_add_char_if((Xfile_declmode_value))
-						if err=(noerror)
-							call advancecursors(pcontent,pcomsize,pcomsize#)
-							return (noerror)
-						endif
-					endif
-				elseif is_expand=(TRUE)
-					if sign!=(reservesign)
-						return "Virtual declarations can have only the reserve sign."
-					endif
-				endelseif
-				SetCall err dataassign(pcontent,pcomsize,sign,valsize,typenumber,(NULL),mask,relocbool,dataxrel,is_stack,is_expand)
-			endif
-		endelse
-	endif
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/actions/enumcomma.oc
@@ -0,0 +1,280 @@
+
+#e
+function writevar(sd ptrvalue,sd unitsize,sd relindex,sd stack,sd rightstackpointer,sd long_mask,sd relocbool)
+	data err#1
+	data noerr=noerror
+	data true=TRUE
+	data false=FALSE
+	data ptrobject%ptrobject
+
+	sd for_64
+
+	if stack=false
+		data ptrdatasec%%ptr_datasec
+		if ptrobject#=1
+			If relocbool=true
+				#data
+				Data ptraddresses%%ptr_addresses
+				Data relocoff=0
+
+				SetCall err adddirectrel_base(ptraddresses,relocoff,relindex,ptrvalue#)
+				If err!=noerr;Return err;EndIf
+				if relindex=(codeind)
+					#data^functionReloc
+					#this is at relocs not at data
+					setcall err unresReloc(ptraddresses)
+					If err!=noerr;Return err;EndIf
+					#ptrvalue# it is an addresses value (nothing related to the real value)
+					#	that will be resolved and overwritten at resolve.oc
+				endif
+				#else data a^dataB
+
+				call inplace_reloc(ptrvalue)
+
+				#endif
+				SetCall err addtosec(ptrvalue,(dwsz),ptrdatasec)
+				If err=(noerror)
+					setcall err reloc64_post_base(ptrdatasec)
+				EndIf
+				return err
+			endif
+		endif
+		SetCall err addtosec(ptrvalue,unitsize,ptrdatasec);If err!=noerr;Return err;EndIf
+		if long_mask!=0
+			data null=0
+			SetCall err addtosec(#null,(dwsz),ptrdatasec)
+			return err
+		endif
+		return (noerror)
+	endif
+
+	setcall for_64 is_for_64()
+	if ptrobject#=1
+		If relocbool=true
+			#code
+			sd stackoff
+			setcall stackoff reloc64_offset((rampadd_value_off))
+			data ptrextra%%ptr_extra
+			setcall err adddirectrel_base(ptrextra,stackoff,relindex,ptrvalue#)
+			If err!=noerr;Return err;EndIf
+			if relindex=(codeind)
+				#s^fn
+				setcall err unresReloc(ptrextra)
+				If err!=noerr;Return err;EndIf
+			endif
+			#else s^dat
+			call inplace_reloc(ptrvalue)
+			setcall err addtocodefordata(ptrvalue#,for_64,(NULL))
+			return err
+		EndIf
+	endif
+	if rightstackpointer!=(NULL)
+		#s^s
+		setcall err addtocodeforstack(rightstackpointer,for_64)
+	else
+		#s=consts
+		sd test=~0x7fFFffFF
+		and test ptrvalue#
+		if test=0
+			setcall err addtocodefordata(ptrvalue#,for_64,0)
+		else
+			#keep sign, for comparations
+			setcall err addtocodefordata(ptrvalue#,for_64,-1)
+		endelse
+	endelse
+	return err
+endfunction
+
+const fndecandgroup=1
+#er
+Function enumcommas(sv ptrcontent,sd ptrsize,sd sz,sd fndecandgroupOrpush,sd typenumberOrparses,sd punitsizeOrparses,sd hexOrunitsize,sd stack,sd long_mask,sd relocbool,sd relocindx)
+	Data zero=0
+	vstrx argsize#1
+	Char comma=asciicomma
+	Data err#1
+	Data noerr=noerror
+	datax content#1
+	Data csv#1
+	Data csvloop=1
+
+	Data true=TRUE
+	Data false=FALSE
+	Data sens#1
+	Data forward=FORWARD
+	Data backward=BACKWARD
+
+	Set csv csvloop
+	Set content ptrcontent#
+
+	Data fnnr=functionsnumber
+	If fndecandgroupOrpush=true
+		If typenumberOrparses=fnnr
+			Data stackoffset#1
+			Set stackoffset zero
+			Data ptrstackoffset^stackoffset
+		Else
+			Data bSz=bsz
+			Data dwSz=dwsz
+			Data unitsize#1   #ignored at stack
+			Data charnr=charnumber
+			if punitsizeOrparses=(NULL)
+				#here is only at decgroup and hex, and pass_write
+				setcall err xfile_prepare_commas_if()
+				If err!=noerr;Return err;EndIf
+
+				If typenumberOrparses=charnr
+				#ignored at stack value   grep stackfilter2  1
+					Set unitsize bSz    ##used also at hex
+				Else
+					Set unitsize dwSz
+				EndElse
+			endif
+		EndElse
+		Set sens forward
+	Else
+		Data storecontent#1
+		Add content sz
+		Set ptrcontent# content
+		Set storecontent content
+		Set sens backward
+	EndElse
+	While csv=csvloop
+		If fndecandgroupOrpush=true
+			SetCall argsize valinmemsens(content,sz,comma,sens)
+			#allow (x,    y,   z) spaces
+			sd sizeaux
+			set sizeaux ptrsize#
+			call spaces(ptrcontent,ptrsize)
+			sub sizeaux ptrsize#
+			sd argumentsize
+			set argumentsize argsize
+			sub argumentsize sizeaux
+			#
+			If typenumberOrparses=fnnr
+				if punitsizeOrparses!=(pass_write0)
+					#pass_init/pass_write
+					SetCall err fndecargs(ptrcontent,ptrsize,argumentsize,ptrstackoffset,punitsizeOrparses)
+					If err!=noerr
+						Return err
+					EndIf
+				else
+					inc hexOrunitsize#
+					call advancecursors(ptrcontent,ptrsize,argumentsize)
+				endelse
+			Else
+				if punitsizeOrparses=(NULL)
+					Data value#1
+					Data ptrvalue^value
+					SetCall err parseoperations(ptrcontent,ptrsize,argumentsize,ptrvalue,(FALSE))
+					If err!=noerr
+						Return err
+					EndIf
+					if hexOrunitsize=(not_hexenum)
+						setcall err writevar(ptrvalue,unitsize,relocindx,stack,zero,long_mask,relocbool)
+						If err!=noerr
+							Return err
+						EndIf
+					else
+						sd ptrcodesec%%ptr_codesec
+						setcall err addtosec(ptrvalue,unitsize,ptrcodesec)
+						If err!=noerr
+							Return err
+						EndIf
+					endelse
+					call xfile_inc_commas_if()
+				else
+					add punitsizeOrparses# hexOrunitsize
+					call advancecursors(ptrcontent,ptrsize,argumentsize)
+				endelse
+			EndElse
+		Else
+			#push
+			if typenumberOrparses=(pass_calls) #for regs at call   and shadow space
+				call nr_of_args_64need_count()
+			endif
+
+			sd size_aux
+			sd mark
+			if sz!=0
+				set argsize content
+				dec argsize
+				char d_quot=asciidoublequote
+				if argsize#=d_quot
+					#look later at escapes, here only at the margins
+					#here the string ".." is in a good condition when quotes_forward was called at parenthesis_size
+					sd last;set last content
+					sub last sz
+					dec argsize
+					while argsize!=last
+						if argsize#=d_quot
+							dec argsize
+							if argsize#!=(asciibs)
+								inc argsize
+								set last argsize
+							else
+								dec argsize
+							endelse
+						else
+							dec argsize
+						endelse
+					endwhile
+					set mark argsize
+					sub argsize content
+					neg argsize
+					set size_aux sz
+					sub size_aux argsize
+					setcall size_aux valinmemsens(mark,size_aux,comma,sens) #better than set size_aux 0
+				else
+					SetCall argsize valinmemsens(content,sz,comma,sens)
+					#and don't let ( ) at getarg, there let only something(exlcuding spaces)/nothing like in all cases
+					set size_aux content
+					sub size_aux argsize
+					set mark size_aux
+					setcall size_aux mem_spaces(size_aux,content)
+					sub size_aux mark
+					sub argsize size_aux
+				endelse
+			else
+			#(,a)
+				set argsize 0
+				#this will be error, don't bother. set size_aux 0
+			endelse
+
+			#here, advancecursors is not ok
+			sub ptrcontent# argsize
+			sub ptrsize# argsize
+			vData ptrargsize^argsize
+			if typenumberOrparses=(pass_init)
+				setcall err getarg(ptrcontent,ptrargsize,argsize,(allow_later),sens) #there are 4 more arguments but are not used
+				If err!=noerr
+					Return err
+				EndIf
+			elseif typenumberOrparses=(pass_write)
+				SetCall err argument(ptrcontent,ptrargsize,backward) #there is 1 more argument but is not used
+				If err!=noerr
+					Return err
+				EndIf
+			endelseif
+			sub ptrcontent# size_aux
+			sub ptrsize# size_aux
+			add argsize size_aux
+		EndElse
+		Sub sz argsize
+		If sz!=zero
+			Dec sz
+			add ptrcontent# sens
+			if sens=(FORWARD)
+				sub ptrsize# sens
+			else
+				add ptrsize# sens
+			endelse
+			Set content ptrcontent#
+		Else
+			Set csv zero
+		EndElse
+	EndWhile
+	If fndecandgroupOrpush=false
+		Set ptrcontent# storecontent
+	EndIf
+	Return noerr
+EndFunction
--- ocompiler-1.orig/src/files/functions/actions/enumcomma.s
+++ /dev/null
@@ -1,280 +0,0 @@
-
-#e
-function writevar(sd ptrvalue,sd unitsize,sd relindex,sd stack,sd rightstackpointer,sd long_mask,sd relocbool)
-	data err#1
-	data noerr=noerror
-	data true=TRUE
-	data false=FALSE
-	data ptrobject%ptrobject
-
-	sd for_64
-
-	if stack=false
-		data ptrdatasec%%ptr_datasec
-		if ptrobject#=1
-			If relocbool=true
-				#data
-				Data ptraddresses%%ptr_addresses
-				Data relocoff=0
-
-				SetCall err adddirectrel_base(ptraddresses,relocoff,relindex,ptrvalue#)
-				If err!=noerr;Return err;EndIf
-				if relindex=(codeind)
-					#data^functionReloc
-					#this is at relocs not at data
-					setcall err unresReloc(ptraddresses)
-					If err!=noerr;Return err;EndIf
-					#ptrvalue# it is an addresses value (nothing related to the real value)
-					#	that will be resolved and overwritten at resolve.s
-				endif
-				#else data a^dataB
-
-				call inplace_reloc(ptrvalue)
-
-				#endif
-				SetCall err addtosec(ptrvalue,(dwsz),ptrdatasec)
-				If err=(noerror)
-					setcall err reloc64_post_base(ptrdatasec)
-				EndIf
-				return err
-			endif
-		endif
-		SetCall err addtosec(ptrvalue,unitsize,ptrdatasec);If err!=noerr;Return err;EndIf
-		if long_mask!=0
-			data null=0
-			SetCall err addtosec(#null,(dwsz),ptrdatasec)
-			return err
-		endif
-		return (noerror)
-	endif
-
-	setcall for_64 is_for_64()
-	if ptrobject#=1
-		If relocbool=true
-			#code
-			sd stackoff
-			setcall stackoff reloc64_offset((rampadd_value_off))
-			data ptrextra%%ptr_extra
-			setcall err adddirectrel_base(ptrextra,stackoff,relindex,ptrvalue#)
-			If err!=noerr;Return err;EndIf
-			if relindex=(codeind)
-				#s^fn
-				setcall err unresReloc(ptrextra)
-				If err!=noerr;Return err;EndIf
-			endif
-			#else s^dat
-			call inplace_reloc(ptrvalue)
-			setcall err addtocodefordata(ptrvalue#,for_64,(NULL))
-			return err
-		EndIf
-	endif
-	if rightstackpointer!=(NULL)
-		#s^s
-		setcall err addtocodeforstack(rightstackpointer,for_64)
-	else
-		#s=consts
-		sd test=~0x7fFFffFF
-		and test ptrvalue#
-		if test=0
-			setcall err addtocodefordata(ptrvalue#,for_64,0)
-		else
-			#keep sign, for comparations
-			setcall err addtocodefordata(ptrvalue#,for_64,-1)
-		endelse
-	endelse
-	return err
-endfunction
-
-const fndecandgroup=1
-#er
-Function enumcommas(sv ptrcontent,sd ptrsize,sd sz,sd fndecandgroupOrpush,sd typenumberOrparses,sd punitsizeOrparses,sd hexOrunitsize,sd stack,sd long_mask,sd relocbool,sd relocindx)
-	Data zero=0
-	vstrx argsize#1
-	Char comma=asciicomma
-	Data err#1
-	Data noerr=noerror
-	datax content#1
-	Data csv#1
-	Data csvloop=1
-
-	Data true=TRUE
-	Data false=FALSE
-	Data sens#1
-	Data forward=FORWARD
-	Data backward=BACKWARD
-
-	Set csv csvloop
-	Set content ptrcontent#
-
-	Data fnnr=functionsnumber
-	If fndecandgroupOrpush=true
-		If typenumberOrparses=fnnr
-			Data stackoffset#1
-			Set stackoffset zero
-			Data ptrstackoffset^stackoffset
-		Else
-			Data bSz=bsz
-			Data dwSz=dwsz
-			Data unitsize#1   #ignored at stack
-			Data charnr=charnumber
-			if punitsizeOrparses=(NULL)
-				#here is only at decgroup and hex, and pass_write
-				setcall err xfile_prepare_commas_if()
-				If err!=noerr;Return err;EndIf
-
-				If typenumberOrparses=charnr
-				#ignored at stack value   grep stackfilter2  1
-					Set unitsize bSz    ##used also at hex
-				Else
-					Set unitsize dwSz
-				EndElse
-			endif
-		EndElse
-		Set sens forward
-	Else
-		Data storecontent#1
-		Add content sz
-		Set ptrcontent# content
-		Set storecontent content
-		Set sens backward
-	EndElse
-	While csv=csvloop
-		If fndecandgroupOrpush=true
-			SetCall argsize valinmemsens(content,sz,comma,sens)
-			#allow (x,    y,   z) spaces
-			sd sizeaux
-			set sizeaux ptrsize#
-			call spaces(ptrcontent,ptrsize)
-			sub sizeaux ptrsize#
-			sd argumentsize
-			set argumentsize argsize
-			sub argumentsize sizeaux
-			#
-			If typenumberOrparses=fnnr
-				if punitsizeOrparses!=(pass_write0)
-					#pass_init/pass_write
-					SetCall err fndecargs(ptrcontent,ptrsize,argumentsize,ptrstackoffset,punitsizeOrparses)
-					If err!=noerr
-						Return err
-					EndIf
-				else
-					inc hexOrunitsize#
-					call advancecursors(ptrcontent,ptrsize,argumentsize)
-				endelse
-			Else
-				if punitsizeOrparses=(NULL)
-					Data value#1
-					Data ptrvalue^value
-					SetCall err parseoperations(ptrcontent,ptrsize,argumentsize,ptrvalue,(FALSE))
-					If err!=noerr
-						Return err
-					EndIf
-					if hexOrunitsize=(not_hexenum)
-						setcall err writevar(ptrvalue,unitsize,relocindx,stack,zero,long_mask,relocbool)
-						If err!=noerr
-							Return err
-						EndIf
-					else
-						sd ptrcodesec%%ptr_codesec
-						setcall err addtosec(ptrvalue,unitsize,ptrcodesec)
-						If err!=noerr
-							Return err
-						EndIf
-					endelse
-					call xfile_inc_commas_if()
-				else
-					add punitsizeOrparses# hexOrunitsize
-					call advancecursors(ptrcontent,ptrsize,argumentsize)
-				endelse
-			EndElse
-		Else
-			#push
-			if typenumberOrparses=(pass_calls) #for regs at call   and shadow space
-				call nr_of_args_64need_count()
-			endif
-
-			sd size_aux
-			sd mark
-			if sz!=0
-				set argsize content
-				dec argsize
-				char d_quot=asciidoublequote
-				if argsize#=d_quot
-					#look later at escapes, here only at the margins
-					#here the string ".." is in a good condition when quotes_forward was called at parenthesis_size
-					sd last;set last content
-					sub last sz
-					dec argsize
-					while argsize!=last
-						if argsize#=d_quot
-							dec argsize
-							if argsize#!=(asciibs)
-								inc argsize
-								set last argsize
-							else
-								dec argsize
-							endelse
-						else
-							dec argsize
-						endelse
-					endwhile
-					set mark argsize
-					sub argsize content
-					neg argsize
-					set size_aux sz
-					sub size_aux argsize
-					setcall size_aux valinmemsens(mark,size_aux,comma,sens) #better than set size_aux 0
-				else
-					SetCall argsize valinmemsens(content,sz,comma,sens)
-					#and don't let ( ) at getarg, there let only something(exlcuding spaces)/nothing like in all cases
-					set size_aux content
-					sub size_aux argsize
-					set mark size_aux
-					setcall size_aux mem_spaces(size_aux,content)
-					sub size_aux mark
-					sub argsize size_aux
-				endelse
-			else
-			#(,a)
-				set argsize 0
-				#this will be error, don't bother. set size_aux 0
-			endelse
-
-			#here, advancecursors is not ok
-			sub ptrcontent# argsize
-			sub ptrsize# argsize
-			vData ptrargsize^argsize
-			if typenumberOrparses=(pass_init)
-				setcall err getarg(ptrcontent,ptrargsize,argsize,(allow_later),sens) #there are 4 more arguments but are not used
-				If err!=noerr
-					Return err
-				EndIf
-			elseif typenumberOrparses=(pass_write)
-				SetCall err argument(ptrcontent,ptrargsize,backward) #there is 1 more argument but is not used
-				If err!=noerr
-					Return err
-				EndIf
-			endelseif
-			sub ptrcontent# size_aux
-			sub ptrsize# size_aux
-			add argsize size_aux
-		EndElse
-		Sub sz argsize
-		If sz!=zero
-			Dec sz
-			add ptrcontent# sens
-			if sens=(FORWARD)
-				sub ptrsize# sens
-			else
-				add ptrsize# sens
-			endelse
-			Set content ptrcontent#
-		Else
-			Set csv zero
-		EndElse
-	EndWhile
-	If fndecandgroupOrpush=false
-		Set ptrcontent# storecontent
-	EndIf
-	Return noerr
-EndFunction
--- /dev/null
+++ ocompiler-1/src/files/functions/actions/fn.oc
@@ -0,0 +1,596 @@
+
+#err
+Function unresolvedcallsfn(data struct,data inneroffset,data atend,data valuedata)
+	data structure#1
+	Data offset#1
+	data addatend#1
+
+	Data poff^offset
+	Call getcontReg(struct,poff)
+	add offset inneroffset
+
+	Data err#1
+	Data true=TRUE
+	Data ptrobject%ptrobject
+
+	If ptrobject#=true
+		Data ptrextra%%ptr_extra
+		SetCall err addrel_base(offset,valuedata,atend,ptrextra)
+	Else
+		#add to resolve at end
+		Data unressz=3*dwsz
+		Data uncall%%ptr_unresolvedcalls
+		data ptrstruct^structure
+
+		set structure struct
+		set addatend atend
+
+		SetCall err addtosec(ptrstruct,unressz,uncall)
+	EndElse
+	Return err
+EndFunction
+
+#err
+function fnimp_exists(sd content,sd size)
+	sd fns%%ptr_functions
+	sd d;setcall d vars_ignoreref(content,size,fns)
+	if d=0
+		return (noerror)
+	endif
+	return "Function/Import name is already defined."
+endfunction
+#xf
+function func_xfile(sd subtype)
+	if subtype=(cFUNCTION) #Xfile_function_tintern
+		return (Xfile_function_not_x)
+	endif
+	return subtype ##Xfile_function_traw Xfile_function_extern Xfile_function_entry
+endfunction
+#err
+Function parsefunction(data ptrcontent,data ptrsize,data is_declare,sd subtype,sd el_or_e,sd varargs)
+	Data true=TRUE
+	#Data false=FALSE
+
+	Data zero=0
+	Data fns%%ptr_functions
+	Data code%%ptr_codesec
+
+	Data err#1
+	Data noerr=noerror
+
+	Str content#1
+	Data size#1
+	Data sz#1
+
+	Set content ptrcontent#
+	Set size ptrsize#
+
+	SetCall sz valinmem(content,size,(asciiparenthesisstart))
+	If sz=zero
+		Char funnameexp="Function name expected."
+		Str fnerr^funnameexp
+		Return fnerr
+	EndIf
+	If sz=size
+		Char startfnexp="Open parenthesis sign ('(') expected."
+		Str starterr^startfnexp
+		Return starterr
+	EndIf
+
+	vdata p_parses%ptr_parses
+	sd parses;set parses p_parses#
+
+	If is_declare=true
+		Data fnnr=functionsnumber
+		Data value#1
+		Data ptrvalue^value
+		if parses=(pass_init)
+			setcall err fnimp_exists(content,sz) #it is at first pass when only fns and imports are
+			if err!=(noerror)
+				return err
+			endif
+
+			Data mask#1
+			#Data ptrobjfnmask%ptrobjfnmask
+			if el_or_e=(TRUE)
+				Set mask (referencebit)
+			else
+				call vars_log_set(content,sz) #more at the function
+				set mask 0
+			endelse
+			sd can_scope64
+			setcall can_scope64 func_xfile(subtype)
+			if can_scope64!=(Xfile_function_not_x)
+				or mask (x86_64bit)
+			endif
+			sd err_pb;setcall err_pb global_err_pBool()
+			if err_pb#=(FALSE)
+				or mask (aftercallthrowlessbit)
+			endif
+
+			SetCall err addaref(value,ptrcontent,ptrsize,sz,fnnr,mask)
+			If err!=noerr
+				Return err
+			EndIf
+
+			#before virtuals
+			#skip the rest of the command at recon
+			#Call advancecursors(ptrcontent,ptrsize,ptrsize#)
+			#
+			#return noerr
+		else
+			if el_or_e=(FALSE)
+				call scopes_store_class()
+			endif
+
+			#pass_write
+			sd pointer
+			setcall pointer vars_ignoreref(content,sz,fns)
+			Call advancecursors(ptrcontent,ptrsize,sz)
+
+			#add the function name to the code section if the option is set
+			sd fn_text
+			setcall fn_text fn_text_info()
+			if fn_text#=1
+				sd fn_name
+				set fn_name pointer
+				add fn_name (nameoffset)
+				sd len
+				setcall len strlen(fn_name)
+				inc len
+				SetCall err addtoCode_set_programentrypoint(fn_name,len) #and set entry point in case this is an entry/entryraw and also will be the last command in the program
+				If err!=(noerror)
+					Return err
+				EndIf
+			endif
+
+			Call getcontReg(code,ptrvalue)
+			set pointer# value
+
+			#resolve the previous calls at this value
+			Data ptrobject%ptrobject
+			If ptrobject#=true
+				Data STT_FUNC=STT_FUNC
+				Data codeind=codeind
+				Data ptrtable%%ptr_table
+				if subtype!=(cFUNCTION)
+				#entries are also not local
+					SetCall err elfaddstrszsym(content,sz,value,zero,STT_FUNC,(STB_GLOBAL),codeind,ptrtable)
+				else
+					SetCall err elfaddstrszsym(content,sz,value,zero,STT_FUNC,(STB_WEAK),codeind,ptrtable)
+				endelse
+				If err!=noerr
+					Return err
+				EndIf
+			EndIf
+
+			if subtype=(cFUNCTION)
+				call scope64_set((FALSE))
+				setcall err xfile_add_fndef_if(content,sz,(Xfile_function_tintern),(Xfile_function_not_x)) #,arg
+			else
+				#functionx,entry in 64 conventions
+				if subtype!=(Xfile_function_traw)
+					sd scope64
+					setcall scope64 is_for_64()
+					call scope64_set(scope64)
+				else
+				#if subtype==(cENTRYRAW)
+				#entryraw has no return but has argc,aexec,a1...an
+					setcall err entryraw_top();if err!=noerr;Return err;EndIf
+
+					#set only to avoid at start args, else, not using, never get into getreturn here
+					call scope64_set((FALSE))
+				endelse
+				setcall err xfile_add_fndef_if(content,sz,subtype,subtype,varargs)
+			endelse
+			If err!=noerr
+				Return err
+			EndIf
+		endelse
+	Else
+		Data ptrdata#1
+		if parses=(pass_init)
+			call advancecursors(ptrcontent,ptrsize,sz)
+		elseif parses=(pass_calls)
+			SetCall ptrdata vars_ignoreref(content,sz,fns)
+			if ptrdata!=0
+				call is_for_64_is_impX_or_fnX_set(ptrdata,subtype)
+			else
+				call is_for_64_is_impX_or_fnX_set_force(subtype)
+			endelse
+			call advancecursors(ptrcontent,ptrsize,sz)
+		else
+			#pass_write
+			data boolindirect#1
+			setcall err prepare_function_call(ptrcontent,ptrsize,sz,#ptrdata,#boolindirect,subtype)
+			if err!=(noerror)
+				return err
+			endif
+		endelse
+	EndElse
+
+	Call stepcursors(ptrcontent,ptrsize)
+	data ptr_sz^sz
+	setcall err parenthesis_size(ptrcontent#,ptrsize#,ptr_sz)
+	if err!=noerr
+		return err
+	endif
+
+	If is_declare=true
+		if parses=(pass_write)
+			sd nr_of_args_tested=0
+			if sz!=zero
+				sv c;sd s;set c ptrcontent#;set s ptrsize#
+				Call enumcommas(#c,#s,sz,is_declare,fnnr,(pass_write0),#nr_of_args_tested) #there are 4 more arguments but are not used
+			endif
+			setcall err xfile_add_int_if(nr_of_args_tested)
+			If err!=noerr
+				Return err
+			EndIf
+
+			sd b;setcall b scope64_get()
+			if b=(TRUE)
+				if varargs!=0
+					sd nr_of_args
+					setcall nr_of_args convdata((convdata_total))
+					setcall err function_start_64(nr_of_args)
+				else
+					setcall err function_start_64(nr_of_args_tested)
+				endelse
+				If err!=noerr
+					Return err
+				EndIf
+			endif
+		endif
+		If sz!=zero
+			SetCall err enumcommas(ptrcontent,ptrsize,sz,is_declare,fnnr,parses) #there are 5 more arguments but are not used
+			if err!=noerr
+				return err
+			endif
+		EndIf
+		if parses=(pass_write)
+			call entryscope()
+		endif
+	Else
+		if parses=(pass_init)
+			if sz!=zero
+				SetCall err enumcommas(ptrcontent,ptrsize,sz,is_declare,parses) #there are 6 more arguments but are not used
+				if err!=noerr
+					return err
+				endif
+			endif
+		else
+			sd p
+			sd pbool;setcall pbool is_for_64_is_impX_or_fnX_p_get()
+			if parses=(pass_calls)
+				if pbool#=(FALSE)
+					call advancecursors(ptrcontent,ptrsize,sz)
+				else
+					if sz!=zero
+						setcall p nr_of_args_64need_p_get();set p# 0
+						SetCall err enumcommas(ptrcontent,ptrsize,sz,is_declare,parses) #there are 6 more arguments but are not used
+						if err=noerr
+							setcall err align_ante(p#)
+						endif
+					else
+						setcall err align_ante(0)
+					endelse
+					if err!=noerr
+						return err
+					endif
+					set pbool# (FALSE)
+				endelse
+			else
+				#pass_write
+
+				if pbool#=(FALSE)
+					if sz!=zero
+						setcall err xfile_add_commas_interncall_if(ptrcontent#,ptrsize#,sz)
+						if err=(noerror)
+							SetCall err enumcommas(ptrcontent,ptrsize,sz,is_declare,parses) #there are 6 more arguments but are not used
+							if err!=noerr;return err;endif
+						else
+							return err
+						endelse
+					endif
+				else
+					setcall p nr_of_args_64need_p_get();set p# 0 #also at 0 at win will be sub all shadow space
+					if sz!=zero
+						set content ptrcontent#
+						set size ptrsize#
+						SetCall err enumcommas(#content,#size,sz,is_declare,(pass_calls)) #there are 6 more arguments but are not used
+						if err=noerr
+							setcall err stack_align(p#)
+							if err=noerr
+								setcall err xfile_add_int_if(p#)
+								if err=noerr
+									SetCall err enumcommas(ptrcontent,ptrsize,sz,is_declare,parses) #there are 6 more arguments but are not used
+								else
+									return err
+								endelse
+							else
+								return err
+							endelse
+						else
+							return err
+						endelse
+					else
+						setcall err stack_align(0)
+					endelse
+					if err!=noerr;return err;endif
+				endelse
+
+				setcall err write_function_call(ptrdata,boolindirect,(FALSE),subtype)
+				if err!=noerr;return err;endif
+			endelse
+		endelse
+	EndElse
+	Call stepcursors(ptrcontent,ptrsize)
+	Return noerr
+EndFunction
+#p
+function fn_text_info()
+	data text_info#1
+	return #text_info
+endfunction
+
+#err
+function prepare_function_call(sv pcontent,sd psize,sd sz,sd p_data,sd p_bool_indirect,sd subtype)
+	Data fns%%ptr_functions
+	Char unfndeferr="Undefined function/data call."
+
+	SetCall p_data# vars(pcontent#,sz,fns)
+	If p_data#=0
+		setcall p_data# vars_number(pcontent#,sz,(integernumber))
+		if p_data#=0
+			setcall p_data# vars_number(pcontent#,sz,(stackvaluenumber))
+			if p_data#=0
+				return #unfndeferr
+			endif
+		else
+			sd test;setcall test pointbit(p_data#)
+			if test=0
+				sd b;setcall b is_for_64() #there will be no pointbit on 32
+				if b=(TRUE)
+					return #unfndeferr
+				endif
+			endif
+		endelse
+		set p_bool_indirect# (TRUE)
+		call is_for_64_is_impX_or_fnX_set_force(subtype)
+	Else
+		#at functions
+		set p_bool_indirect# (FALSE)
+		call is_for_64_is_impX_or_fnX_set(p_data#,subtype)
+	EndElse
+
+	sd err
+	setcall err xfile_add_call_if(pcontent#,sz,subtype)
+	if err=(noerror)   #here is coming from calls and callex
+		Call advancecursors(pcontent,psize,sz)
+
+		#move over the stack arguments, ebx is also shorting the first stack variable (mov rbx,rdx)
+		#mov esp,ebx
+		Data code%%ptr_codesec
+		#
+		setcall err rex_w_if64();if err!=(noerror);return err;endif
+		#
+		char espebx={moveatregthemodrm,0xe3}
+		Str ptrespebx^espebx
+		Data sizeespebx=2
+		SetCall err addtosec(ptrespebx,sizeespebx,code)
+	endif
+	Return err
+endfunction
+
+#err
+function write_function_call(sd ptrdata,sd boolindirect,sd is_callex,sd subtype)
+	sd err
+	Data code%%ptr_codesec
+
+	sd pb;setcall pb is_for_64_is_impX_or_fnX_p_get()
+	if pb#=(TRUE)
+		setcall err function_call_64(is_callex)
+		If err!=(noerror);Return err;EndIf
+		set pb# (FALSE) #reset the flag
+	endif
+
+	Data ptrfnmask#1
+	Set ptrfnmask ptrdata
+	Add ptrfnmask (maskoffset)
+
+	data mask#1
+	Data idatamask#1
+	Data idatafn=idatabitfunction
+	Data ptrobject%ptrobject
+	Set mask ptrfnmask#
+	set idatamask mask
+	And idatamask idatafn
+
+	sd is_valuedata_call;set is_valuedata_call boolindirect
+	If ptrobject#=(FALSE)
+		If idatamask=idatafn
+			Set boolindirect (TRUE)
+		EndIf
+	EndIf
+
+	If boolindirect=(FALSE)
+		Char directcall#1
+		Data directcalloff#1
+
+		Data ptrdirectcall^directcall
+		const directcallsize=1+dwsz
+		data ptrdirectcalloff^directcalloff
+
+		If idatamask!=idatafn
+			set directcall 0xe8
+			setcall err unresolvedLocal(1,code,ptrdata,ptrdirectcalloff)
+			If err!=(noerror);Return err;EndIf
+			SetCall err addtosec(ptrdirectcall,(directcallsize),code)
+		Else
+			#was: reloc when linking;0-dwsz(appears to be dwsz from Data directcallsize=1+dwsz), no truncation, so direct better
+			set directcall 0xb8
+			Set directcalloff 0
+			sd relocoff
+			setcall relocoff reloc64_offset(1)
+			SetCall err unresolvedcallsfn(code,relocoff,directcalloff,ptrdata#);If err!=(noerror);Return err;EndIf
+			setcall err reloc64_ante();If err!=(noerror);Return err;EndIf
+			SetCall err addtosec(ptrdirectcall,(directcallsize),code);If err!=(noerror);Return err;EndIf
+			setcall err reloc64_post();If err!=(noerror);Return err;EndIf
+			char callcode={0xff,0xd0}
+			setcall err addtosec(#callcode,2,code)
+		EndElse
+	Else
+		#this at object is call data() but the reloc is outside of this function
+		if idatamask=idatafn
+			data ptrvirtualimportsoffset%ptrvirtualimportsoffset
+			SetCall err unresolvedcallsfn(code,1,ptrvirtualimportsoffset) #,ptrdata#
+			If err!=(noerror);Return err;EndIf
+		endif
+		Char callaction={0xff}
+		#Data noreg=noregnumber
+		Char callactionopcode={2}
+		Data eaxregnumber=eaxregnumber
+		#call stack64_op_set()
+		SetCall err writeopera(ptrdata,callaction,callactionopcode,eaxregnumber) #no sufix was
+	EndElse
+	If err=(noerror)
+		#afterbit throwless is at fns imps if before aftercall; at values is throwless after aftercall if sign set
+		sd tless=aftercallthrowlessbit
+		and tless mask
+		if tless=0
+			if is_valuedata_call=(FALSE)
+				sd global_err_pB;setcall global_err_pB global_err_pBool()
+				if global_err_pB#=(FALSE)
+					#we are before aftercall and calling a fn/imp from after aftercall
+					return (noerror)
+				endif
+			endif
+			and subtype (call_ret_flag|x_callg_flag)
+			if subtype=0  #is useless if a RET will come  , or if was set to not throw
+				sd global_err_ptr;setcall global_err_ptr global_err_p()
+				Data ptrextra%%ptr_extra
+				If ptrobject#=(FALSE)
+				#absolute
+					const global_err_ex_start=\
+					#mov ecx,imm32
+					char g_err_mov=0xb8+ecxregnumber;data g_err_mov_disp32#1
+					#cmp byte[ecx],0
+					char *={0x80,7*toregopcode|ecxregnumber};char *=aftercall_disable
+					const global_err_ex_sz=\-global_err_ex_start
+					#add rel,1 is (b8+ecx), one byte
+					set g_err_mov_disp32 global_err_ptr#
+					#
+					SetCall err addtosec(#g_err_mov,(global_err_ex_sz),code)
+				Else
+					#mov to ecx is reseting the high part of the rcx
+					char g_err=0xb9
+					data *rel=0
+					#
+					sd af_relof
+					setcall af_relof reloc64_offset((bsz))
+					setcall err adddirectrel_base(ptrextra,af_relof,global_err_ptr#,0);If err!=(noerror);Return err;EndIf
+					setcall err reloc64_ante();If err!=(noerror);Return err;EndIf
+					SetCall err addtosec(#g_err,5,code);If err!=(noerror);Return err;EndIf
+					setcall err reloc64_post();If err!=(noerror);Return err;EndIf
+					char g_cmp={0x80,7*toregopcode|ecxregnumber,0}
+					SetCall err addtosec(#g_cmp,3,code)
+				EndElse
+				If err!=(noerror);Return err;EndIf
+				#jz
+				char g_err_jz=0x74;char ret_end_sz#1
+				#
+				ss ret_end_p
+				sd is_linux_term;setcall is_linux_term is_linux_end()
+				if is_linux_term=(TRUE)
+					#int 0x80, sys_exit, eax 1,ebx the return number
+					const g_err_sys_start=\
+					char g_err_sys={0x8b,ebxregnumber*toregopcode|0xc0|eaxregnumber}
+					char *={0xb8,1,0,0,0}
+					Char *={intimm8,0x80}
+					const g_err_sys_size=\-g_err_sys_start
+					set ret_end_sz (g_err_sys_size)
+					set ret_end_p #g_err_sys
+				else
+					setcall ret_end_sz getreturn(#ret_end_p)
+				endelse
+				SetCall err addtosec(#g_err_jz,(bsz+bsz),code);If err!=(noerror);Return err;EndIf
+				#return
+				SetCall err addtosec(ret_end_p,ret_end_sz,code)
+				#;If err!=(noerror);Return err;EndIf
+			endif
+		endif
+	endif
+	return err
+endfunction
+
+#p
+function global_err_p()
+	data e#1
+	return #e
+endfunction
+#p
+function global_err_pBool()
+	data bool#1
+	return #bool
+endfunction
+
+#bool
+function is_linux_end()
+	sd ptrfnavailable%ptrfnavailable
+	if ptrfnavailable#=0  #one is default, two from multiple entry start detectors and from entry tags
+	#here innerfunction is also practical, but that is more for data offsets
+		sd p_exit_end%p_exit_end
+		return p_exit_end#
+	endif
+	return (FALSE) #not at inner functions
+endfunction
+#er
+function entryraw_top()
+	char s={0x6a,0}
+	data code%%ptr_codesec
+	sd err
+	setcall err addtosec(#s,2,code)
+	return err
+endfunction
+
+#err
+function aftercall_manipulate(sd acall_val)
+	sd err
+	vData ptrobject%ptrobject
+	vData ptrextra%%ptr_extra
+	vData code%%ptr_codesec
+	sd global_err_ptr;setcall global_err_ptr global_err_p()
+
+	If ptrobject#=(FALSE)
+	#absolute
+		#mov [disp32],imm8 /0
+		char a=0xc6;char *=disp32regnumber;data b#1;char c#1
+		set b global_err_ptr#
+		set c acall_val
+		SetCall err addtosec(#a,7,code)
+	Else
+		#for a 64 rel: 0xc6/0xc7 is still disp32; and rex is nothing at 0xc6
+		sd normal_offset=bsz
+		sd af_relof
+		setcall af_relof reloc64_offset(normal_offset)
+
+		if af_relof!=normal_offset
+			char a64={REX_Operand_64,ateaximm+ecxregnumber};data *=reloc64_main;data *=reloc64_main
+			char *=0xc6;char *=ecxregnumber;char val#1
+
+			setcall err adddirectrel_base(ptrextra,af_relof,global_err_ptr#,0);If err!=(noerror);Return err;EndIf
+
+			set val acall_val
+			SetCall err addtosec(#a64,(10+3),code)
+		else
+			char g_err=0xc6;char *=disp32regnumber;data *rel=0;char val32#1
+
+			setcall err adddirectrel_base(ptrextra,(bsz+bsz),global_err_ptr#,0);If err!=(noerror);Return err;EndIf
+
+			set val32 acall_val
+			SetCall err addtosec(#g_err,7,code)
+		endelse
+	EndElse
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/actions/fn.s
+++ /dev/null
@@ -1,596 +0,0 @@
-
-#err
-Function unresolvedcallsfn(data struct,data inneroffset,data atend,data valuedata)
-	data structure#1
-	Data offset#1
-	data addatend#1
-
-	Data poff^offset
-	Call getcontReg(struct,poff)
-	add offset inneroffset
-
-	Data err#1
-	Data true=TRUE
-	Data ptrobject%ptrobject
-
-	If ptrobject#=true
-		Data ptrextra%%ptr_extra
-		SetCall err addrel_base(offset,valuedata,atend,ptrextra)
-	Else
-		#add to resolve at end
-		Data unressz=3*dwsz
-		Data uncall%%ptr_unresolvedcalls
-		data ptrstruct^structure
-
-		set structure struct
-		set addatend atend
-
-		SetCall err addtosec(ptrstruct,unressz,uncall)
-	EndElse
-	Return err
-EndFunction
-
-#err
-function fnimp_exists(sd content,sd size)
-	sd fns%%ptr_functions
-	sd d;setcall d vars_ignoreref(content,size,fns)
-	if d=0
-		return (noerror)
-	endif
-	return "Function/Import name is already defined."
-endfunction
-#xf
-function func_xfile(sd subtype)
-	if subtype=(cFUNCTION) #Xfile_function_tintern
-		return (Xfile_function_not_x)
-	endif
-	return subtype ##Xfile_function_traw Xfile_function_extern Xfile_function_entry
-endfunction
-#err
-Function parsefunction(data ptrcontent,data ptrsize,data is_declare,sd subtype,sd el_or_e,sd varargs)
-	Data true=TRUE
-	#Data false=FALSE
-
-	Data zero=0
-	Data fns%%ptr_functions
-	Data code%%ptr_codesec
-
-	Data err#1
-	Data noerr=noerror
-
-	Str content#1
-	Data size#1
-	Data sz#1
-
-	Set content ptrcontent#
-	Set size ptrsize#
-
-	SetCall sz valinmem(content,size,(asciiparenthesisstart))
-	If sz=zero
-		Char funnameexp="Function name expected."
-		Str fnerr^funnameexp
-		Return fnerr
-	EndIf
-	If sz=size
-		Char startfnexp="Open parenthesis sign ('(') expected."
-		Str starterr^startfnexp
-		Return starterr
-	EndIf
-
-	vdata p_parses%ptr_parses
-	sd parses;set parses p_parses#
-
-	If is_declare=true
-		Data fnnr=functionsnumber
-		Data value#1
-		Data ptrvalue^value
-		if parses=(pass_init)
-			setcall err fnimp_exists(content,sz) #it is at first pass when only fns and imports are
-			if err!=(noerror)
-				return err
-			endif
-
-			Data mask#1
-			#Data ptrobjfnmask%ptrobjfnmask
-			if el_or_e=(TRUE)
-				Set mask (referencebit)
-			else
-				call vars_log_set(content,sz) #more at the function
-				set mask 0
-			endelse
-			sd can_scope64
-			setcall can_scope64 func_xfile(subtype)
-			if can_scope64!=(Xfile_function_not_x)
-				or mask (x86_64bit)
-			endif
-			sd err_pb;setcall err_pb global_err_pBool()
-			if err_pb#=(FALSE)
-				or mask (aftercallthrowlessbit)
-			endif
-
-			SetCall err addaref(value,ptrcontent,ptrsize,sz,fnnr,mask)
-			If err!=noerr
-				Return err
-			EndIf
-
-			#before virtuals
-			#skip the rest of the command at recon
-			#Call advancecursors(ptrcontent,ptrsize,ptrsize#)
-			#
-			#return noerr
-		else
-			if el_or_e=(FALSE)
-				call scopes_store_class()
-			endif
-
-			#pass_write
-			sd pointer
-			setcall pointer vars_ignoreref(content,sz,fns)
-			Call advancecursors(ptrcontent,ptrsize,sz)
-
-			#add the function name to the code section if the option is set
-			sd fn_text
-			setcall fn_text fn_text_info()
-			if fn_text#=1
-				sd fn_name
-				set fn_name pointer
-				add fn_name (nameoffset)
-				sd len
-				setcall len strlen(fn_name)
-				inc len
-				SetCall err addtoCode_set_programentrypoint(fn_name,len)
-				If err!=(noerror)
-					Return err
-				EndIf
-			endif
-
-			Call getcontReg(code,ptrvalue)
-			set pointer# value
-
-			#resolve the previous calls at this value
-			Data ptrobject%ptrobject
-			If ptrobject#=true
-				Data STT_FUNC=STT_FUNC
-				Data codeind=codeind
-				Data ptrtable%%ptr_table
-				if subtype!=(cFUNCTION)
-				#entries are also not local
-					SetCall err elfaddstrszsym(content,sz,value,zero,STT_FUNC,(STB_GLOBAL),codeind,ptrtable)
-				else
-					SetCall err elfaddstrszsym(content,sz,value,zero,STT_FUNC,(STB_WEAK),codeind,ptrtable)
-				endelse
-				If err!=noerr
-					Return err
-				EndIf
-			EndIf
-
-			if subtype=(cFUNCTION)
-				call scope64_set((FALSE))
-				setcall err xfile_add_fndef_if(content,sz,(Xfile_function_tintern),(Xfile_function_not_x)) #,arg
-			else
-				#functionx,entry in 64 conventions
-				if subtype!=(Xfile_function_traw)
-					sd scope64
-					setcall scope64 is_for_64()
-					call scope64_set(scope64)
-				else
-				#if subtype==(cENTRYRAW)
-				#entryraw has no return but has argc,aexec,a1...an
-					setcall err entryraw_top();if err!=noerr;Return err;EndIf
-
-					#set only to avoid at start args, else, not using, never get into getreturn here
-					call scope64_set((FALSE))
-				endelse
-				setcall err xfile_add_fndef_if(content,sz,subtype,subtype,varargs)
-			endelse
-			If err!=noerr
-				Return err
-			EndIf
-		endelse
-	Else
-		Data ptrdata#1
-		if parses=(pass_init)
-			call advancecursors(ptrcontent,ptrsize,sz)
-		elseif parses=(pass_calls)
-			SetCall ptrdata vars_ignoreref(content,sz,fns)
-			if ptrdata!=0
-				call is_for_64_is_impX_or_fnX_set(ptrdata,subtype)
-			else
-				call is_for_64_is_impX_or_fnX_set_force(subtype)
-			endelse
-			call advancecursors(ptrcontent,ptrsize,sz)
-		else
-			#pass_write
-			data boolindirect#1
-			setcall err prepare_function_call(ptrcontent,ptrsize,sz,#ptrdata,#boolindirect,subtype)
-			if err!=(noerror)
-				return err
-			endif
-		endelse
-	EndElse
-
-	Call stepcursors(ptrcontent,ptrsize)
-	data ptr_sz^sz
-	setcall err parenthesis_size(ptrcontent#,ptrsize#,ptr_sz)
-	if err!=noerr
-		return err
-	endif
-
-	If is_declare=true
-		if parses=(pass_write)
-			sd nr_of_args_tested=0
-			if sz!=zero
-				sv c;sd s;set c ptrcontent#;set s ptrsize#
-				Call enumcommas(#c,#s,sz,is_declare,fnnr,(pass_write0),#nr_of_args_tested) #there are 4 more arguments but are not used
-			endif
-			setcall err xfile_add_int_if(nr_of_args_tested)
-			If err!=noerr
-				Return err
-			EndIf
-
-			sd b;setcall b scope64_get()
-			if b=(TRUE)
-				if varargs!=0
-					sd nr_of_args
-					setcall nr_of_args convdata((convdata_total))
-					setcall err function_start_64(nr_of_args)
-				else
-					setcall err function_start_64(nr_of_args_tested)
-				endelse
-				If err!=noerr
-					Return err
-				EndIf
-			endif
-		endif
-		If sz!=zero
-			SetCall err enumcommas(ptrcontent,ptrsize,sz,is_declare,fnnr,parses) #there are 5 more arguments but are not used
-			if err!=noerr
-				return err
-			endif
-		EndIf
-		if parses=(pass_write)
-			call entryscope()
-		endif
-	Else
-		if parses=(pass_init)
-			if sz!=zero
-				SetCall err enumcommas(ptrcontent,ptrsize,sz,is_declare,parses) #there are 6 more arguments but are not used
-				if err!=noerr
-					return err
-				endif
-			endif
-		else
-			sd p
-			sd pbool;setcall pbool is_for_64_is_impX_or_fnX_p_get()
-			if parses=(pass_calls)
-				if pbool#=(FALSE)
-					call advancecursors(ptrcontent,ptrsize,sz)
-				else
-					if sz!=zero
-						setcall p nr_of_args_64need_p_get();set p# 0
-						SetCall err enumcommas(ptrcontent,ptrsize,sz,is_declare,parses) #there are 6 more arguments but are not used
-						if err=noerr
-							setcall err align_ante(p#)
-						endif
-					else
-						setcall err align_ante(0)
-					endelse
-					if err!=noerr
-						return err
-					endif
-					set pbool# (FALSE)
-				endelse
-			else
-				#pass_write
-
-				if pbool#=(FALSE)
-					if sz!=zero
-						setcall err xfile_add_commas_interncall_if(ptrcontent#,ptrsize#,sz)
-						if err=(noerror)
-							SetCall err enumcommas(ptrcontent,ptrsize,sz,is_declare,parses) #there are 6 more arguments but are not used
-							if err!=noerr;return err;endif
-						else
-							return err
-						endelse
-					endif
-				else
-					setcall p nr_of_args_64need_p_get();set p# 0 #also at 0 at win will be sub all shadow space
-					if sz!=zero
-						set content ptrcontent#
-						set size ptrsize#
-						SetCall err enumcommas(#content,#size,sz,is_declare,(pass_calls)) #there are 6 more arguments but are not used
-						if err=noerr
-							setcall err stack_align(p#)
-							if err=noerr
-								setcall err xfile_add_int_if(p#)
-								if err=noerr
-									SetCall err enumcommas(ptrcontent,ptrsize,sz,is_declare,parses) #there are 6 more arguments but are not used
-								else
-									return err
-								endelse
-							else
-								return err
-							endelse
-						else
-							return err
-						endelse
-					else
-						setcall err stack_align(0)
-					endelse
-					if err!=noerr;return err;endif
-				endelse
-
-				setcall err write_function_call(ptrdata,boolindirect,(FALSE),subtype)
-				if err!=noerr;return err;endif
-			endelse
-		endelse
-	EndElse
-	Call stepcursors(ptrcontent,ptrsize)
-	Return noerr
-EndFunction
-#p
-function fn_text_info()
-	data text_info#1
-	return #text_info
-endfunction
-
-#err
-function prepare_function_call(sv pcontent,sd psize,sd sz,sd p_data,sd p_bool_indirect,sd subtype)
-	Data fns%%ptr_functions
-	Char unfndeferr="Undefined function/data call."
-
-	SetCall p_data# vars(pcontent#,sz,fns)
-	If p_data#=0
-		setcall p_data# vars_number(pcontent#,sz,(integernumber))
-		if p_data#=0
-			setcall p_data# vars_number(pcontent#,sz,(stackvaluenumber))
-			if p_data#=0
-				return #unfndeferr
-			endif
-		else
-			sd test;setcall test pointbit(p_data#)
-			if test=0
-				sd b;setcall b is_for_64() #there will be no pointbit on 32
-				if b=(TRUE)
-					return #unfndeferr
-				endif
-			endif
-		endelse
-		set p_bool_indirect# (TRUE)
-		call is_for_64_is_impX_or_fnX_set_force(subtype)
-	Else
-		#at functions
-		set p_bool_indirect# (FALSE)
-		call is_for_64_is_impX_or_fnX_set(p_data#,subtype)
-	EndElse
-
-	sd err
-	setcall err xfile_add_call_if(pcontent#,sz,subtype)
-	if err=(noerror)   #here is coming from calls and callex
-		Call advancecursors(pcontent,psize,sz)
-
-		#move over the stack arguments, ebx is also shorting the first stack variable (mov rbx,rdx)
-		#mov esp,ebx
-		Data code%%ptr_codesec
-		#
-		setcall err rex_w_if64();if err!=(noerror);return err;endif
-		#
-		char espebx={moveatregthemodrm,0xe3}
-		Str ptrespebx^espebx
-		Data sizeespebx=2
-		SetCall err addtosec(ptrespebx,sizeespebx,code)
-	endif
-	Return err
-endfunction
-
-#err
-function write_function_call(sd ptrdata,sd boolindirect,sd is_callex,sd subtype)
-	sd err
-	Data code%%ptr_codesec
-
-	sd pb;setcall pb is_for_64_is_impX_or_fnX_p_get()
-	if pb#=(TRUE)
-		setcall err function_call_64(is_callex)
-		If err!=(noerror);Return err;EndIf
-		set pb# (FALSE) #reset the flag
-	endif
-
-	Data ptrfnmask#1
-	Set ptrfnmask ptrdata
-	Add ptrfnmask (maskoffset)
-
-	data mask#1
-	Data idatamask#1
-	Data idatafn=idatabitfunction
-	Data ptrobject%ptrobject
-	Set mask ptrfnmask#
-	set idatamask mask
-	And idatamask idatafn
-
-	sd is_valuedata_call;set is_valuedata_call boolindirect
-	If ptrobject#=(FALSE)
-		If idatamask=idatafn
-			Set boolindirect (TRUE)
-		EndIf
-	EndIf
-
-	If boolindirect=(FALSE)
-		Char directcall#1
-		Data directcalloff#1
-
-		Data ptrdirectcall^directcall
-		const directcallsize=1+dwsz
-		data ptrdirectcalloff^directcalloff
-
-		If idatamask!=idatafn
-			set directcall 0xe8
-			setcall err unresolvedLocal(1,code,ptrdata,ptrdirectcalloff)
-			If err!=(noerror);Return err;EndIf
-			SetCall err addtosec(ptrdirectcall,(directcallsize),code)
-		Else
-			#was: reloc when linking;0-dwsz(appears to be dwsz from Data directcallsize=1+dwsz), no truncation, so direct better
-			set directcall 0xb8
-			Set directcalloff 0
-			sd relocoff
-			setcall relocoff reloc64_offset(1)
-			SetCall err unresolvedcallsfn(code,relocoff,directcalloff,ptrdata#);If err!=(noerror);Return err;EndIf
-			setcall err reloc64_ante();If err!=(noerror);Return err;EndIf
-			SetCall err addtosec(ptrdirectcall,(directcallsize),code);If err!=(noerror);Return err;EndIf
-			setcall err reloc64_post();If err!=(noerror);Return err;EndIf
-			char callcode={0xff,0xd0}
-			setcall err addtosec(#callcode,2,code)
-		EndElse
-	Else
-		#this at object is call data() but the reloc is outside of this function
-		if idatamask=idatafn
-			data ptrvirtualimportsoffset%ptrvirtualimportsoffset
-			SetCall err unresolvedcallsfn(code,1,ptrvirtualimportsoffset) #,ptrdata#
-			If err!=(noerror);Return err;EndIf
-		endif
-		Char callaction={0xff}
-		#Data noreg=noregnumber
-		Char callactionopcode={2}
-		Data eaxregnumber=eaxregnumber
-		#call stack64_op_set()
-		SetCall err writeopera(ptrdata,callaction,callactionopcode,eaxregnumber) #no sufix was
-	EndElse
-	If err=(noerror)
-		#afterbit throwless is at fns imps if before aftercall; at values is throwless after aftercall if sign set
-		sd tless=aftercallthrowlessbit
-		and tless mask
-		if tless=0
-			if is_valuedata_call=(FALSE)
-				sd global_err_pB;setcall global_err_pB global_err_pBool()
-				if global_err_pB#=(FALSE)
-					#we are before aftercall and calling a fn/imp from after aftercall
-					return (noerror)
-				endif
-			endif
-			and subtype (call_ret_flag|x_callg_flag)
-			if subtype=0  #is useless if a RET will come  , or if was set to not throw
-				sd global_err_ptr;setcall global_err_ptr global_err_p()
-				Data ptrextra%%ptr_extra
-				If ptrobject#=(FALSE)
-				#absolute
-					const global_err_ex_start=\
-					#mov ecx,imm32
-					char g_err_mov=0xb8+ecxregnumber;data g_err_mov_disp32#1
-					#cmp byte[ecx],0
-					char *={0x80,7*toregopcode|ecxregnumber};char *=aftercall_disable
-					const global_err_ex_sz=\-global_err_ex_start
-					#add rel,1 is (b8+ecx), one byte
-					set g_err_mov_disp32 global_err_ptr#
-					#
-					SetCall err addtosec(#g_err_mov,(global_err_ex_sz),code)
-				Else
-					#mov to ecx is reseting the high part of the rcx
-					char g_err=0xb9
-					data *rel=0
-					#
-					sd af_relof
-					setcall af_relof reloc64_offset((bsz))
-					setcall err adddirectrel_base(ptrextra,af_relof,global_err_ptr#,0);If err!=(noerror);Return err;EndIf
-					setcall err reloc64_ante();If err!=(noerror);Return err;EndIf
-					SetCall err addtosec(#g_err,5,code);If err!=(noerror);Return err;EndIf
-					setcall err reloc64_post();If err!=(noerror);Return err;EndIf
-					char g_cmp={0x80,7*toregopcode|ecxregnumber,0}
-					SetCall err addtosec(#g_cmp,3,code)
-				EndElse
-				If err!=(noerror);Return err;EndIf
-				#jz
-				char g_err_jz=0x74;char ret_end_sz#1
-				#
-				ss ret_end_p
-				sd is_linux_term;setcall is_linux_term is_linux_end()
-				if is_linux_term=(TRUE)
-					#int 0x80, sys_exit, eax 1,ebx the return number
-					const g_err_sys_start=\
-					char g_err_sys={0x8b,ebxregnumber*toregopcode|0xc0|eaxregnumber}
-					char *={0xb8,1,0,0,0}
-					Char *={intimm8,0x80}
-					const g_err_sys_size=\-g_err_sys_start
-					set ret_end_sz (g_err_sys_size)
-					set ret_end_p #g_err_sys
-				else
-					setcall ret_end_sz getreturn(#ret_end_p)
-				endelse
-				SetCall err addtosec(#g_err_jz,(bsz+bsz),code);If err!=(noerror);Return err;EndIf
-				#return
-				SetCall err addtosec(ret_end_p,ret_end_sz,code)
-				#;If err!=(noerror);Return err;EndIf
-			endif
-		endif
-	endif
-	return err
-endfunction
-
-#p
-function global_err_p()
-	data e#1
-	return #e
-endfunction
-#p
-function global_err_pBool()
-	data bool#1
-	return #bool
-endfunction
-
-#bool
-function is_linux_end()
-	sd ptrfnavailable%ptrfnavailable
-	if ptrfnavailable#=0  #one is default, two from multiple entry start detectors and from entry tags
-	#here innerfunction is also practical, but that is more for data offsets
-		sd p_exit_end%p_exit_end
-		return p_exit_end#
-	endif
-	return (FALSE) #not at inner functions
-endfunction
-#er
-function entryraw_top()
-	char s={0x6a,0}
-	data code%%ptr_codesec
-	sd err
-	setcall err addtosec(#s,2,code)
-	return err
-endfunction
-
-#err
-function aftercall_manipulate(sd acall_val)
-	sd err
-	vData ptrobject%ptrobject
-	vData ptrextra%%ptr_extra
-	vData code%%ptr_codesec
-	sd global_err_ptr;setcall global_err_ptr global_err_p()
-
-	If ptrobject#=(FALSE)
-	#absolute
-		#mov [disp32],imm8 /0
-		char a=0xc6;char *=disp32regnumber;data b#1;char c#1
-		set b global_err_ptr#
-		set c acall_val
-		SetCall err addtosec(#a,7,code)
-	Else
-		#for a 64 rel: 0xc6/0xc7 is still disp32; and rex is nothing at 0xc6
-		sd normal_offset=bsz
-		sd af_relof
-		setcall af_relof reloc64_offset(normal_offset)
-
-		if af_relof!=normal_offset
-			char a64={REX_Operand_64,ateaximm+ecxregnumber};data *=reloc64_main;data *=reloc64_main
-			char *=0xc6;char *=ecxregnumber;char val#1
-
-			setcall err adddirectrel_base(ptrextra,af_relof,global_err_ptr#,0);If err!=(noerror);Return err;EndIf
-
-			set val acall_val
-			SetCall err addtosec(#a64,(10+3),code)
-		else
-			char g_err=0xc6;char *=disp32regnumber;data *rel=0;char val32#1
-
-			setcall err adddirectrel_base(ptrextra,(bsz+bsz),global_err_ptr#,0);If err!=(noerror);Return err;EndIf
-
-			set val32 acall_val
-			SetCall err addtosec(#g_err,7,code)
-		endelse
-	EndElse
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/actions/fndecargs.oc
@@ -0,0 +1,217 @@
+
+
+Function fndecargs(sv ptrcontent,sd ptrsize,sd sz,sd ptr_stackoffset,sd parses)
+	If sz=0
+		Char szexp="Variable declaration expected."
+		Str szexpptr^szexp
+		Return szexpptr
+	EndIf
+
+	Data noerr=noerror
+	Data pointerset%compointersvarsloc
+	Data err#1
+	Data perr^err
+	data subtype#1
+
+	Data ptrsearchsize^sz
+	Data len#1
+	Set len sz
+	Set err noerr
+
+	Call getcommand(ptrcontent,ptrsearchsize,#subtype,perr,pointerset)
+	If err!=noerr
+		Return err
+	EndIf
+
+	#substract from the big size the declaration+spc size, the ptrcontent is already there, outside are comma values
+	Sub len sz
+	Data length#1
+	Set length ptrsize#
+	Sub length len
+	Set ptrsize# length
+
+	sd vartype
+	sd is_expand
+	setcall vartype commandSubtypeDeclare_to_typenumber(subtype,#is_expand)
+
+	data is_stack#1
+	data ptrstack^is_stack
+	call stackfilter(vartype,ptrstack)
+
+	sd datasize=dwsz
+	sd b;setcall b is_for_64()
+
+	vdata ptrdataSize%ptrdataSize
+
+	if parses=(pass_init)
+		if is_stack=(FALSE)
+			if vartype>=(vnumbers)
+				if b=(TRUE)
+					set datasize (qwsz)
+				endif
+			elseif vartype=(charnumber)
+				set datasize (bsz)
+			endelseif
+			if is_expand=(FALSE)
+				vdata ptrdataReg%%ptr_dataReg
+				add ptrdataReg# datasize
+			else
+				add ptrdataSize# datasize
+			endelse
+		endif
+		call advancecursors(ptrcontent,ptrsize,sz)
+		return (noerror)
+	endif
+
+	sd xfile_decltype
+	sd long_mask=0
+	if is_stack=(TRUE)
+		if vartype=(stackdatanumber)
+			set xfile_decltype (Xfile_decltype_longInt)
+		elseif vartype=(stackstringnumber)
+			set xfile_decltype (Xfile_decltype_longByte)
+		elseif vartype=(stackvaluenumber)
+			set xfile_decltype (Xfile_decltype_long)
+		else
+		#if vartype=(stackwordnumber)
+			set xfile_decltype (Xfile_decltype_longWord)
+		endelse
+	else
+		if vartype>=(vnumbers)
+			sub vartype (vnumbers)
+			if vartype=(valuesinnernumber)
+				set vartype (integernumber)
+				if b=(TRUE)
+					set long_mask (valueslongmask)
+					set datasize (qwsz)
+				endif
+				set xfile_decltype (Xfile_decltype_long)
+			else
+				if b=(TRUE)
+					set long_mask (datapointbit)
+					set datasize (qwsz)
+				endif
+				if vartype=(integernumber)
+					set xfile_decltype (Xfile_decltype_longInt)
+				elseif vartype=(stringnumber)
+					set xfile_decltype (Xfile_decltype_longByte)
+				else
+				#if vartype=(wordnumber)
+					set xfile_decltype (Xfile_decltype_longWord)
+				endelse
+			endelse
+		elseif vartype=(charnumber)
+			set datasize (bsz)
+			set xfile_decltype (Xfile_decltype_byte)
+		elseif vartype=(integernumber)
+			set xfile_decltype (Xfile_decltype_int)
+		elseif vartype=(stringnumber)
+			set xfile_decltype (Xfile_decltype_intByte)
+		else
+		#if vartype=(wordnumber)
+			set xfile_decltype (Xfile_decltype_word)
+		endelse
+	endelse
+	setcall err xfile_add_declare_if(xfile_decltype,is_stack,is_expand,ptrcontent#,sz,(sign_not_required)) #2 more
+	If err!=noerr
+		Return err
+	EndIf
+
+	#this is a write to sec for old data args, careful with stackoff
+	Char stacktransfer1#1;char *={0x84,0x24}
+	Data stackoff#1
+	Char stacktransfer2#1
+	Data memoff#1
+
+	sd stackindex
+	setcall stackindex stack64_enlarge((dwsz))
+	#(,sd *) is 5 at 64 is 8 but off_t on 32 ocompiler is signed(more at lseek), so no more than 32bits
+	#setcall err maxsectioncheck(stackindex,ptr_stackoffset)
+
+	add ptr_stackoffset# stackindex
+	Set stackoff ptr_stackoffset#
+	#stackoff is a write to sec for old data args
+
+	setcall stackindex stack64_enlarge((stackinitpush))
+	#setcall err maxsectioncheck(stackoff,#stackindex)
+	add stackindex stackoff
+
+	setcall err addvarreferenceorunref(ptrcontent,ptrsize,sz,vartype,long_mask,stackindex,is_expand)
+	If err!=noerr
+		Return err
+	EndIf
+
+	if is_stack=(TRUE)
+		return noerr
+	endif
+
+	sd sectionind=dataind
+	if is_expand=(TRUE)
+		setcall memoff get_img_vdata_dataSize()
+		add ptrdataSize# datasize
+		sd ptr_nobits_virtual%ptr_nobits_virtual
+		if ptr_nobits_virtual#=(Yes)
+			set sectionind (dtnbind)
+		endif
+	else
+		setcall memoff get_img_vdata_dataReg()
+		Data null={NULL,NULL}
+		Data ptrnull^null
+		Data _datasec%%ptr_datasec
+		SetCall err addtosec(ptrnull,datasize,_datasec)
+		If err!=noerr
+			Return err
+		EndIf
+	endelse
+
+	Char stackt1ini=moveatprocthemem
+	Char stackt2ini=0xA3
+
+	Set stacktransfer1 stackt1ini
+	Set stacktransfer2 stackt2ini
+
+	If datasize=(bsz)
+	#char
+		Dec stacktransfer1
+		Dec stacktransfer2
+	elseif long_mask!=0
+	#values
+		call rex_w(#err)
+		If err!=noerr;Return err;EndIf
+	endelseif
+
+	data p_is_object%ptrobject
+	if p_is_object#=(TRUE)
+		Const fndecargs_offend^memoff
+		Const fndecargs_offstart^stacktransfer1
+		Data ptrextra%%ptr_extra
+		sd reloff=fndecargs_offend-fndecargs_offstart
+		if long_mask!=0
+			inc reloff
+		endif
+		SetCall err adddirectrel_base(ptrextra,reloff,sectionind,memoff)
+		If err!=noerr
+			Return err
+		EndIf
+		call inplace_reloc(#memoff)
+	endif
+
+	Data _codesec%%ptr_codesec
+
+	SetCall err addtosec(#stacktransfer1,(3*bsz+dwsz),_codesec);If err!=noerr;Return err;EndIf
+	if long_mask!=0
+		call rex_w(#err)
+		If err!=noerr;Return err;EndIf
+	endif
+	SetCall err addtosec(#stacktransfer2,(bsz+dwsz),_codesec);If err!=noerr;Return err;EndIf
+
+	if b=(TRUE)
+		#at 64 code:
+		#A3 XX.XX.XX.XX_XX.XX.XX.XX
+		sd z=i386_obj_default_reloc_rah
+		SetCall err addtosec(#z,(dwsz),_codesec)
+		return err
+	endif
+
+	Return (noerror)
+EndFunction
--- ocompiler-1.orig/src/files/functions/actions/fndecargs.s
+++ /dev/null
@@ -1,217 +0,0 @@
-
-
-Function fndecargs(sv ptrcontent,sd ptrsize,sd sz,sd ptr_stackoffset,sd parses)
-	If sz=0
-		Char szexp="Variable declaration expected."
-		Str szexpptr^szexp
-		Return szexpptr
-	EndIf
-
-	Data noerr=noerror
-	Data pointerset%compointersvarsloc
-	Data err#1
-	Data perr^err
-	data subtype#1
-
-	Data ptrsearchsize^sz
-	Data len#1
-	Set len sz
-	Set err noerr
-
-	Call getcommand(ptrcontent,ptrsearchsize,#subtype,perr,pointerset)
-	If err!=noerr
-		Return err
-	EndIf
-
-	#substract from the big size the declaration+spc size, the ptrcontent is already there, outside are comma values
-	Sub len sz
-	Data length#1
-	Set length ptrsize#
-	Sub length len
-	Set ptrsize# length
-
-	sd vartype
-	sd is_expand
-	setcall vartype commandSubtypeDeclare_to_typenumber(subtype,#is_expand)
-
-	data is_stack#1
-	data ptrstack^is_stack
-	call stackfilter(vartype,ptrstack)
-
-	sd datasize=dwsz
-	sd b;setcall b is_for_64()
-
-	vdata ptrdataSize%ptrdataSize
-
-	if parses=(pass_init)
-		if is_stack=(FALSE)
-			if vartype>=(vnumbers)
-				if b=(TRUE)
-					set datasize (qwsz)
-				endif
-			elseif vartype=(charnumber)
-				set datasize (bsz)
-			endelseif
-			if is_expand=(FALSE)
-				vdata ptrdataReg%%ptr_dataReg
-				add ptrdataReg# datasize
-			else
-				add ptrdataSize# datasize
-			endelse
-		endif
-		call advancecursors(ptrcontent,ptrsize,sz)
-		return (noerror)
-	endif
-
-	sd xfile_decltype
-	sd long_mask=0
-	if is_stack=(TRUE)
-		if vartype=(stackdatanumber)
-			set xfile_decltype (Xfile_decltype_longInt)
-		elseif vartype=(stackstringnumber)
-			set xfile_decltype (Xfile_decltype_longByte)
-		elseif vartype=(stackvaluenumber)
-			set xfile_decltype (Xfile_decltype_long)
-		else
-		#if vartype=(stackwordnumber)
-			set xfile_decltype (Xfile_decltype_longWord)
-		endelse
-	else
-		if vartype>=(vnumbers)
-			sub vartype (vnumbers)
-			if vartype=(valuesinnernumber)
-				set vartype (integernumber)
-				if b=(TRUE)
-					set long_mask (valueslongmask)
-					set datasize (qwsz)
-				endif
-				set xfile_decltype (Xfile_decltype_long)
-			else
-				if b=(TRUE)
-					set long_mask (datapointbit)
-					set datasize (qwsz)
-				endif
-				if vartype=(integernumber)
-					set xfile_decltype (Xfile_decltype_longInt)
-				elseif vartype=(stringnumber)
-					set xfile_decltype (Xfile_decltype_longByte)
-				else
-				#if vartype=(wordnumber)
-					set xfile_decltype (Xfile_decltype_longWord)
-				endelse
-			endelse
-		elseif vartype=(charnumber)
-			set datasize (bsz)
-			set xfile_decltype (Xfile_decltype_byte)
-		elseif vartype=(integernumber)
-			set xfile_decltype (Xfile_decltype_int)
-		elseif vartype=(stringnumber)
-			set xfile_decltype (Xfile_decltype_intByte)
-		else
-		#if vartype=(wordnumber)
-			set xfile_decltype (Xfile_decltype_word)
-		endelse
-	endelse
-	setcall err xfile_add_declare_if(xfile_decltype,is_stack,is_expand,ptrcontent#,sz,(sign_not_required)) #2 more
-	If err!=noerr
-		Return err
-	EndIf
-
-	#this is a write to sec for old data args, careful with stackoff
-	Char stacktransfer1#1;char *={0x84,0x24}
-	Data stackoff#1
-	Char stacktransfer2#1
-	Data memoff#1
-
-	sd stackindex
-	setcall stackindex stack64_enlarge((dwsz))
-	#(,sd *) is 5 at 64 is 8 but off_t on 32 ocompiler is signed(more at lseek), so no more than 32bits
-	#setcall err maxsectioncheck(stackindex,ptr_stackoffset)
-
-	add ptr_stackoffset# stackindex
-	Set stackoff ptr_stackoffset#
-	#stackoff is a write to sec for old data args
-
-	setcall stackindex stack64_enlarge((stackinitpush))
-	#setcall err maxsectioncheck(stackoff,#stackindex)
-	add stackindex stackoff
-
-	setcall err addvarreferenceorunref(ptrcontent,ptrsize,sz,vartype,long_mask,stackindex,is_expand)
-	If err!=noerr
-		Return err
-	EndIf
-
-	if is_stack=(TRUE)
-		return noerr
-	endif
-
-	sd sectionind=dataind
-	if is_expand=(TRUE)
-		setcall memoff get_img_vdata_dataSize()
-		add ptrdataSize# datasize
-		sd ptr_nobits_virtual%ptr_nobits_virtual
-		if ptr_nobits_virtual#=(Yes)
-			set sectionind (dtnbind)
-		endif
-	else
-		setcall memoff get_img_vdata_dataReg()
-		Data null={NULL,NULL}
-		Data ptrnull^null
-		Data _datasec%%ptr_datasec
-		SetCall err addtosec(ptrnull,datasize,_datasec)
-		If err!=noerr
-			Return err
-		EndIf
-	endelse
-
-	Char stackt1ini=moveatprocthemem
-	Char stackt2ini=0xA3
-
-	Set stacktransfer1 stackt1ini
-	Set stacktransfer2 stackt2ini
-
-	If datasize=(bsz)
-	#char
-		Dec stacktransfer1
-		Dec stacktransfer2
-	elseif long_mask!=0
-	#values
-		call rex_w(#err)
-		If err!=noerr;Return err;EndIf
-	endelseif
-
-	data p_is_object%ptrobject
-	if p_is_object#=(TRUE)
-		Const fndecargs_offend^memoff
-		Const fndecargs_offstart^stacktransfer1
-		Data ptrextra%%ptr_extra
-		sd reloff=fndecargs_offend-fndecargs_offstart
-		if long_mask!=0
-			inc reloff
-		endif
-		SetCall err adddirectrel_base(ptrextra,reloff,sectionind,memoff)
-		If err!=noerr
-			Return err
-		EndIf
-		call inplace_reloc(#memoff)
-	endif
-
-	Data _codesec%%ptr_codesec
-
-	SetCall err addtosec(#stacktransfer1,(3*bsz+dwsz),_codesec);If err!=noerr;Return err;EndIf
-	if long_mask!=0
-		call rex_w(#err)
-		If err!=noerr;Return err;EndIf
-	endif
-	SetCall err addtosec(#stacktransfer2,(bsz+dwsz),_codesec);If err!=noerr;Return err;EndIf
-
-	if b=(TRUE)
-		#at 64 code:
-		#A3 XX.XX.XX.XX_XX.XX.XX.XX
-		sd z=i386_obj_default_reloc_rah
-		SetCall err addtosec(#z,(dwsz),_codesec)
-		return err
-	endif
-
-	Return (noerror)
-EndFunction
--- /dev/null
+++ ocompiler-1/src/files/functions/add/add.oc
@@ -0,0 +1,97 @@
+
+
+
+#bool
+Function is_variable_char(sd byte)
+	If byte<(asciizero)
+		Return (FALSE)
+	ElseIf byte<=(asciinine)
+		Return (TRUE)
+	EndElseIf
+	sd bool
+	setcall bool is_variable_char_not_numeric(byte)
+	return bool
+EndFunction
+
+#bool
+function is_variable_char_not_numeric(sd in_byte)
+	if in_byte=(asciiaround)
+		return (TRUE)
+	elseif in_byte<(asciiA)
+		return (FALSE)
+	elseif in_byte<=(asciiZ)
+		return (TRUE)
+	elseif in_byte=(asciiunderscore)
+		return (TRUE)
+	elseif in_byte<(asciia)
+		return (FALSE)
+	elseif in_byte<=(asciiz)
+		return (TRUE)
+	endelseif
+	return (FALSE)
+endfunction
+
+#errnr
+Function addaref(data value,data ptrcontent,data ptrsize,data size,data typenumber,data mask)
+	Ss content
+	Set content ptrcontent#
+	Char byte#1
+
+	Char err="The declarations must contain only alphanumeric, underscore and around chars and cannot start with a number."
+	Str _err^err
+
+	sd bool
+	setcall bool is_variable_char_not_numeric(content#)
+	if bool!=(TRUE)
+		Return _err
+	EndIf
+	ss end;set end content;add end size
+	inc content
+	Data false=FALSE
+	While content!=end
+		Set byte content#
+		SetCall bool is_variable_char(byte)
+		If bool=false
+			Return _err
+		EndIf
+		Inc content
+	EndWhile
+
+	#set the referenced bit if warnings are off
+	Data warningsboolptr%ptrwarningsbool
+	if warningsboolptr#=(FALSE)
+		or mask (referencebit)
+	endif
+
+	sd dest
+	SetCall dest getstructcont(typenumber)
+	sd errnr
+	setcall errnr add_ref_to_sec(dest,value,mask,ptrcontent#,size)
+	If errnr!=(noerror)
+		Return errnr
+	EndIf
+
+	Call advancecursors(ptrcontent,ptrsize,size)
+
+	Return errnr
+EndFunction
+
+#err
+function add_ref_to_sec(sd sec,sd value,sd mask,sd name,sd size)
+	sd errnr
+	SetCall errnr addtosec(#value,(dwsz),sec)
+	If errnr!=(noerror)
+		Return errnr
+	EndIf
+	#Mask is described at header.h
+	SetCall errnr addtosec(#mask,(dwsz),sec)
+	If errnr!=(noerror)
+		Return errnr
+	EndIf
+	SetCall errnr addtosecstr(name,size,sec)
+	If errnr!=(noerror)
+		Return errnr
+	EndIf
+
+	return (noerror)
+EndFunction
--- ocompiler-1.orig/src/files/functions/add/add.s
+++ /dev/null
@@ -1,97 +0,0 @@
-
-
-
-#bool
-Function is_variable_char(sd byte)
-	If byte<(asciizero)
-		Return (FALSE)
-	ElseIf byte<=(asciinine)
-		Return (TRUE)
-	EndElseIf
-	sd bool
-	setcall bool is_variable_char_not_numeric(byte)
-	return bool
-EndFunction
-
-#bool
-function is_variable_char_not_numeric(sd in_byte)
-	if in_byte=(asciiaround)
-		return (TRUE)
-	elseif in_byte<(asciiA)
-		return (FALSE)
-	elseif in_byte<=(asciiZ)
-		return (TRUE)
-	elseif in_byte=(asciiunderscore)
-		return (TRUE)
-	elseif in_byte<(asciia)
-		return (FALSE)
-	elseif in_byte<=(asciiz)
-		return (TRUE)
-	endelseif
-	return (FALSE)
-endfunction
-
-#errnr
-Function addaref(data value,data ptrcontent,data ptrsize,data size,data typenumber,data mask)
-	Ss content
-	Set content ptrcontent#
-	Char byte#1
-
-	Char err="The declarations must contain only alphanumeric, underscore and around chars and cannot start with a number."
-	Str _err^err
-
-	sd bool
-	setcall bool is_variable_char_not_numeric(content#)
-	if bool!=(TRUE)
-		Return _err
-	EndIf
-	ss end;set end content;add end size
-	inc content
-	Data false=FALSE
-	While content!=end
-		Set byte content#
-		SetCall bool is_variable_char(byte)
-		If bool=false
-			Return _err
-		EndIf
-		Inc content
-	EndWhile
-
-	#set the referenced bit if warnings are off
-	Data warningsboolptr%ptrwarningsbool
-	if warningsboolptr#=(FALSE)
-		or mask (referencebit)
-	endif
-
-	sd dest
-	SetCall dest getstructcont(typenumber)
-	sd errnr
-	setcall errnr add_ref_to_sec(dest,value,mask,ptrcontent#,size)
-	If errnr!=(noerror)
-		Return errnr
-	EndIf
-
-	Call advancecursors(ptrcontent,ptrsize,size)
-
-	Return errnr
-EndFunction
-
-#err
-function add_ref_to_sec(sd sec,sd value,sd mask,sd name,sd size)
-	sd errnr
-	SetCall errnr addtosec(#value,(dwsz),sec)
-	If errnr!=(noerror)
-		Return errnr
-	EndIf
-	#Mask is described at header.h
-	SetCall errnr addtosec(#mask,(dwsz),sec)
-	If errnr!=(noerror)
-		Return errnr
-	EndIf
-	SetCall errnr addtosecstr(name,size,sec)
-	If errnr!=(noerror)
-		Return errnr
-	EndIf
-
-	return (noerror)
-EndFunction
--- /dev/null
+++ ocompiler-1/src/files/functions/add/addstresc.oc
@@ -0,0 +1,82 @@
+
+
+#errnr
+Function addtosecstresc(sd pcontent,sd psize,sd sz,sd escapes,sd pdest,sd wordpad)
+	sd err;setcall err addtosecstresc_base(pcontent,psize,sz,escapes,pdest,wordpad,(FALSE))
+	return err
+endFunction
+#errnr
+Function addtosecstresc_xfile(sd pcontent,sd psize,sd sz,sd escapes,sd pdest)
+	sd err;setcall err addtosecstresc_base(pcontent,psize,sz,escapes,pdest,(FALSE),(TRUE))
+	return err
+endFunction
+#errnr
+Function addtosecstresc_base(sd pcontent,sd psize,sd sz,sd escapes,sd pdest,sd wordpad,sd write_to_xfile)
+	#set destination start
+	Data destReg#1
+	Data ptrdestReg^destReg
+	Call getcontReg(pdest,ptrdestReg)
+
+	Data odd#1
+	Data zero=0
+
+	# size of the string out with term
+	Data sizeEsc#1
+	Set sizeEsc sz
+	sd end;set end sizeEsc
+	Sub sizeEsc escapes
+	if write_to_xfile=(TRUE)
+		sd xfilesz;set xfilesz sizeEsc
+	endif
+	Inc sizeEsc
+
+	Set odd zero
+	#into idata string is padded to word
+	If wordpad!=zero
+		set odd sizeEsc
+		and odd 1
+		If odd!=zero
+			Inc sizeEsc
+		EndIf
+	EndIf
+
+	Data noerr=noerror
+	Data errnr#1
+	SetCall errnr addtosec(0,sizeEsc,pdest)
+	If errnr!=noerr
+		Return errnr
+	EndIf
+
+	#set destination start
+	Str destloc#1
+	Data ptrdestloc^destloc
+	Call getcont(pdest,ptrdestloc)
+	Add destloc destReg
+	if write_to_xfile=(TRUE)
+		sd xfileloc;set xfileloc destloc
+	endif
+
+	add end pcontent#
+	While pcontent#!=end
+		Char byte#1
+		SetCall byte quotescaped(pcontent,psize,zero)
+		Set destloc# byte
+		Inc destloc
+		Call stepcursors(pcontent,psize)
+	EndWhile
+	Set destloc# zero
+	If odd!=zero
+		Inc destloc
+		Set destloc# zero
+	EndIf
+
+	call stepcursors(pcontent,psize)
+
+	if write_to_xfile=(TRUE)
+		#ifif only for include tag
+		setcall errnr xfile_add_string_ifif(xfileloc,xfilesz)
+		return errnr
+	endif
+
+	Return (noerror)
+EndFunction
--- ocompiler-1.orig/src/files/functions/add/addstresc.s
+++ /dev/null
@@ -1,82 +0,0 @@
-
-
-#errnr
-Function addtosecstresc(sd pcontent,sd psize,sd sz,sd escapes,sd pdest,sd wordpad)
-	sd err;setcall err addtosecstresc_base(pcontent,psize,sz,escapes,pdest,wordpad,(FALSE))
-	return err
-endFunction
-#errnr
-Function addtosecstresc_xfile(sd pcontent,sd psize,sd sz,sd escapes,sd pdest)
-	sd err;setcall err addtosecstresc_base(pcontent,psize,sz,escapes,pdest,(FALSE),(TRUE))
-	return err
-endFunction
-#errnr
-Function addtosecstresc_base(sd pcontent,sd psize,sd sz,sd escapes,sd pdest,sd wordpad,sd write_to_xfile)
-	#set destination start
-	Data destReg#1
-	Data ptrdestReg^destReg
-	Call getcontReg(pdest,ptrdestReg)
-
-	Data odd#1
-	Data zero=0
-
-	# size of the string out with term
-	Data sizeEsc#1
-	Set sizeEsc sz
-	sd end;set end sizeEsc
-	Sub sizeEsc escapes
-	if write_to_xfile=(TRUE)
-		sd xfilesz;set xfilesz sizeEsc
-	endif
-	Inc sizeEsc
-
-	Set odd zero
-	#into idata string is padded to word
-	If wordpad!=zero
-		set odd sizeEsc
-		and odd 1
-		If odd!=zero
-			Inc sizeEsc
-		EndIf
-	EndIf
-
-	Data noerr=noerror
-	Data errnr#1
-	SetCall errnr addtosec(0,sizeEsc,pdest)
-	If errnr!=noerr
-		Return errnr
-	EndIf
-
-	#set destination start
-	Str destloc#1
-	Data ptrdestloc^destloc
-	Call getcont(pdest,ptrdestloc)
-	Add destloc destReg
-	if write_to_xfile=(TRUE)
-		sd xfileloc;set xfileloc destloc
-	endif
-
-	add end pcontent#
-	While pcontent#!=end
-		Char byte#1
-		SetCall byte quotescaped(pcontent,psize,zero)
-		Set destloc# byte
-		Inc destloc
-		Call stepcursors(pcontent,psize)
-	EndWhile
-	Set destloc# zero
-	If odd!=zero
-		Inc destloc
-		Set destloc# zero
-	EndIf
-
-	call stepcursors(pcontent,psize)
-
-	if write_to_xfile=(TRUE)
-		#ifif only for include tag
-		setcall errnr xfile_add_string_ifif(xfileloc,xfilesz)
-		return errnr
-	endif
-
-	Return (noerror)
-EndFunction
--- /dev/null
+++ ocompiler-1/src/files/functions/add/addtomem.oc
@@ -0,0 +1,123 @@
+
+
+
+
+#80...h and can't compare signed<>unsigned and will loose control at alloc
+#this *4 is still positive, this still positive *2 is there a shame check against negative
+#                        aaBBccDD
+#Const maxreservevalue=0x20000000-1
+#1 073 741 823
+
+#err
+Function maxsectioncheck(sd a,sd pb)
+	add pb# a
+	if pb#<0
+		return "Section size cannot be greater than 2 147 483 647 (0x7fFFffFF)."
+	EndIf
+	Return (noerror)
+EndFunction
+
+#errnr
+Function addtosec(str content,data size,data dst)
+	Data destMax#1
+	Data pdestReg#1
+	Data ppdestReg^pdestReg
+
+	Call getptrcontReg(dst,ppdestReg)
+
+	Set destMax dst#
+
+	Data null=0
+	Data destData#1
+	Data avail#1
+	Data noerr=noerror
+
+	Set destData pdestReg#
+	Set avail destMax
+	Sub avail destData
+	If avail<size
+		Data ptrfileformat%ptrfileformat
+		Data pe_exec=pe_exec
+		If ptrfileformat#=pe_exec
+			Char _memerr="Memory space error."
+			vStr memerr^_memerr
+			Value ptrtable%%ptr_table
+			Value ptrnames%%ptr_names
+			Value ptraddresses%%ptr_addresses
+			If dst=ptrtable
+				Return memerr
+			ElseIf dst=ptrnames
+				Return memerr
+			ElseIf dst=ptraddresses
+				Return memerr
+			EndElseIf
+		Endif
+		Data value#1
+		sd err
+
+		Set value destData
+		setcall err maxsectioncheck(size,#value)
+		If err!=noerr
+			Return err
+		EndIf
+		Data pad#1
+		Data ptrsecalign%ptrpage_sectionalignment
+		Data secalign#1
+		Set secalign ptrsecalign#
+		SetCall pad requiredpad(value,secalign)
+		setcall err maxsectioncheck(pad,#value)
+		If err!=noerr
+			Return err
+		EndIf
+
+		Data contoffset=containersdataoffset
+		Data container#1
+		Set container dst
+		Add container contoffset
+
+		SetCall err memrealloc(container,value)
+		If err!=noerr
+			Return err
+		EndIf
+		Set dst# value
+	EndIf
+	If content!=null
+		Str destloc#1
+		Data ptrdest^destloc
+		Call getcont(dst,ptrdest)
+		Add destloc destData
+		Call memtomem(destloc,content,size)
+	EndIf
+	Add destData size
+	Set pdestReg# destData
+	Return noerr
+EndFunction
+function set_programentrypoint()
+	data code%%ptr_codesec
+	data c#1
+	Call getcontReg(code,#c)
+	data e%ptrprogramentrypoint
+	Set e# c
+endfunction
+#errnr
+function addtoCode_set_programentrypoint(ss content,sd size)
+	sd err;data code%%ptr_codesec
+	setcall err addtosec(content,size,code)
+	#if noerror #is fatal anyway
+		call set_programentrypoint()
+	return err
+endfunction
+#errnr
+Function addtosecstr(str content,data size,data dst)
+	Data errnr#1
+	Data noerr=noerror
+	SetCall errnr addtosec(content,size,dst)
+	If errnr!=noerr
+		Return errnr
+	EndIf
+	Char null={0}
+	Data sz=1
+	Str ptrnull^null
+	SetCall errnr addtosec(ptrnull,sz,dst)
+	Return errnr
+EndFunction
--- ocompiler-1.orig/src/files/functions/add/addtomem.s
+++ /dev/null
@@ -1,119 +0,0 @@
-
-
-
-
-#80...h and can't compare signed<>unsigned and will loose control at alloc
-#this *4 is still positive, this still positive *2 is there a shame check against negative
-#                        aaBBccDD
-#Const maxreservevalue=0x20000000-1
-#1 073 741 823
-
-#err
-Function maxsectioncheck(sd a,sd pb)
-	add pb# a
-	if pb#<0
-		return "Section size cannot be greater than 2 147 483 647 (0x7fFFffFF)."
-	EndIf
-	Return (noerror)
-EndFunction
-
-#errnr
-Function addtosec(str content,data size,data dst)
-	Data destMax#1
-	Data pdestReg#1
-	Data ppdestReg^pdestReg
-
-	Call getptrcontReg(dst,ppdestReg)
-
-	Set destMax dst#
-
-	Data null=0
-	Data destData#1
-	Data avail#1
-	Data noerr=noerror
-
-	Set destData pdestReg#
-	Set avail destMax
-	Sub avail destData
-	If avail<size
-		Data ptrfileformat%ptrfileformat
-		Data pe_exec=pe_exec
-		If ptrfileformat#=pe_exec
-			Char _memerr="Memory space error."
-			vStr memerr^_memerr
-			Value ptrtable%%ptr_table
-			Value ptrnames%%ptr_names
-			Value ptraddresses%%ptr_addresses
-			If dst=ptrtable
-				Return memerr
-			ElseIf dst=ptrnames
-				Return memerr
-			ElseIf dst=ptraddresses
-				Return memerr
-			EndElseIf
-		Endif
-		Data value#1
-		sd err
-
-		Set value destData
-		setcall err maxsectioncheck(size,#value)
-		If err!=noerr
-			Return err
-		EndIf
-		Data pad#1
-		Data ptrsecalign%ptrpage_sectionalignment
-		Data secalign#1
-		Set secalign ptrsecalign#
-		SetCall pad requiredpad(value,secalign)
-		setcall err maxsectioncheck(pad,#value)
-		If err!=noerr
-			Return err
-		EndIf
-
-		Data contoffset=containersdataoffset
-		Data container#1
-		Set container dst
-		Add container contoffset
-
-		SetCall err memrealloc(container,value)
-		If err!=noerr
-			Return err
-		EndIf
-		Set dst# value
-	EndIf
-	If content!=null
-		Str destloc#1
-		Data ptrdest^destloc
-		Call getcont(dst,ptrdest)
-		Add destloc destData
-		Call memtomem(destloc,content,size)
-	EndIf
-	Add destData size
-	Set pdestReg# destData
-	Return noerr
-EndFunction
-#errnr
-function addtoCode_set_programentrypoint(ss content,sd size)
-	sd err;data code%%ptr_codesec
-	setcall err addtosec(content,size,code)
-	if err!=(noerror);return err;endif
-	data c#1
-	Call getcontReg(code,#c)
-	data e%ptrprogramentrypoint
-	Set e# c
-	return (noerror)
-endfunction
-#errnr
-Function addtosecstr(str content,data size,data dst)
-	Data errnr#1
-	Data noerr=noerror
-	SetCall errnr addtosec(content,size,dst)
-	If errnr!=noerr
-		Return errnr
-	EndIf
-	Char null={0}
-	Data sz=1
-	Str ptrnull^null
-	SetCall errnr addtosec(ptrnull,sz,dst)
-	Return errnr
-EndFunction
--- /dev/null
+++ ocompiler-1/src/files/functions/argument/arg.oc
@@ -0,0 +1,781 @@
+
+function verify_syntax_end_and_restore(sv ptrcontent,sd ptrsize,sd argsize)
+	sd c
+	sd s
+	set c ptrcontent#
+	set s ptrsize#
+
+	Call spaces(ptrcontent,ptrsize)
+	data z=0
+	if ptrsize#!=z
+		str er="Unrecognized inner text."
+		return er
+	endif
+	sub c argsize
+	add s argsize
+	set ptrcontent# c
+	set ptrsize# s
+	return (noerror)
+endfunction
+
+function arg_size(ss content,sd sizetoverify,sd p_argsize)
+	Char spc=asciispace
+	Char tab=asciitab
+	sd szargspc
+	sd szargtab
+	SetCall szargspc valinmem(content,sizetoverify,spc)
+	SetCall szargtab valinmem(content,sizetoverify,tab)
+	If szargspc<szargtab
+		Set p_argsize# szargspc
+	Else
+		Set p_argsize# szargtab
+	EndElse
+	#was resolved at push enumcomma. if p_argsize#=0
+	#	return "Expecting argument name."  #this is good at BACKWARD, call a( )
+	#endif
+	#at callex (going to undefined at varsize=size) and at declare^ is ok
+endfunction
+
+function extend_arg_size(ss content,sd sizetoverify,sd p_argsize)
+	sub sizetoverify p_argsize#
+	if sizetoverify!=0
+		add content p_argsize#
+		ss marker;set marker content
+		dec marker	##argsize is not 0
+		if marker#!=(pointerascii)
+			if marker#!=(castascii)
+				set marker content
+				call spaces(#content,#sizetoverify)
+				if sizetoverify!=0
+					if content#=(pointerascii)
+						call stepcursors(#content,#sizetoverify)
+						if sizetoverify!=0
+							if content#=(pointerascii)
+								#this " ##" is the only line end comment after sufix and allowing spaces
+								set main.xfile_sharp_comment (nonzero)   #and notify for xfile
+								ret
+							endif
+							#this disallow "arg #comment"
+							addcall p_argsize# find_whitespaceORcomment(content,sizetoverify)
+						endif
+						#and not letting "arg #" as comment to not regret later
+						sub content marker
+						add p_argsize# content
+					endif
+				endif
+			endif
+		endif
+	endif
+endfunction
+function extend_sufix_test(ss content,sd p_size)
+	while p_size#!=0
+		dec content
+		sd b;setcall b is_whitespace(content#)
+		if b=(FALSE)
+			ret
+		endif
+		dec p_size#
+	endwhile
+endfunction
+
+#err
+Function getarg(sv ptrcontent,sd ptrsize,sd argsize,sd allowdata,sd sens,sd ptrdata,sd ptrlow,sd ptrsufix)
+	ss content
+	sd size
+	sd errnr
+
+	char d_q=getarg_str
+
+	if argsize=0
+		return "Argument name expected."
+	endif
+
+	data false=0
+
+	Set content ptrcontent#
+
+	sd prefix
+	if content#=d_q
+		sd q_size
+		sd escapes
+		set size ptrsize#
+		SetCall errnr quotinmem(#content,#size,#q_size,#escapes) #this has a stepcursors
+		If errnr!=(noerror)
+			return errnr
+		endif
+		if allowdata!=(allow_yes)
+			if allowdata=(allow_later)
+				vdata ptrdataReg%%ptr_dataReg
+				sub q_size escapes
+				add ptrdataReg# q_size
+				inc ptrdataReg#   #null end
+			else
+				#allow_no later_sec
+				return "String here is useless at the moment."  #the real problem: is disturbing virtual calculation at pass_init
+			endelse
+		else
+			setcall errnr xfile_add_char_if((Xfile_arg_string))
+			If errnr!=(noerror)
+				return errnr
+			endif
+			#get entry
+			sd sec%ptrdummyEntry
+			call getcont(sec,ptrdata)
+			sd location
+			set location ptrdata#
+			setcall location# get_img_vdata_dataReg()
+
+			#set string to data
+			data ptrdatasec%%ptr_datasec
+			set ptrcontent# content
+			set ptrsize# size
+			SetCall errnr addtosecstresc_xfile(ptrcontent,ptrsize,q_size,escapes,ptrdatasec)
+			If errnr!=(noerror)
+				return errnr
+			endif
+			#set low and sufix
+			set ptrlow# (FALSE)
+			set ptrsufix# (sufix_false)
+			#the code operation is a "prefix" like
+			setcall prefix prefix_bool()
+			set prefix# 1
+
+			#advancing
+			if sens=(FORWARD)
+				return (noerror)
+			endif
+			add q_size 2
+			setcall errnr verify_syntax_end_and_restore(ptrcontent,ptrsize,q_size)
+			return errnr
+		endelse
+	elseif allowdata!=(allow_later)  #exclude pass_init, but even there jump over first arg
+		call arg_size(content,argsize,#argsize)  #spc,tab
+		if allowdata!=(allow_later_sec)
+			sd bool
+			setcall bool is_constant_related_ascii(content#)
+			if bool=(TRUE)
+				#verify if imm is ok
+				sd canhaveimm
+				setcall canhaveimm getimm()
+				if canhaveimm=false
+					str immnothere="Unexpected numbers/constants, expecting a variable."
+					return immnothere
+				endif
+				setcall errnr xfile_add_char_if((Xfile_arg_number))
+				if errnr=(noerror)
+					#extend to parenthesis if found
+					if content#=(asciiparenthesisstart)
+						call stepcursors(ptrcontent,ptrsize)
+						setcall errnr parenthesis_size(ptrcontent#,ptrsize#,#argsize)
+						if errnr!=(noerror)
+							return errnr
+						endif
+						setcall errnr parseoperations(ptrcontent,ptrsize,argsize,ptrdata,(FALSE))
+						if errnr!=(noerror)
+							return errnr
+						endif
+						call stepcursors(ptrcontent,ptrsize)
+						if sens=(BACKWARD)
+							add argsize 2 #the recognised parenthesis
+						endif
+					else
+						setcall errnr parseoperations(ptrcontent,ptrsize,argsize,ptrdata,(FALSE))
+						if errnr!=(noerror)
+							return errnr
+						endif
+					endelse
+				endif
+
+				call setisimm()
+				#sufix is not used at imm value
+				set ptrlow# false
+
+				if sens=(FORWARD)
+					return (noerror)
+				endif
+				setcall errnr verify_syntax_end_and_restore(ptrcontent,ptrsize,argsize)
+				return errnr
+			endif
+			sd imm;setcall imm getimm()
+			if imm=(TRUE) #if is FALSE, this is the only option for xfile. also allow(string) is no
+			#then, this is a test at allow yes; also at allow no for conditions
+				setcall errnr xfile_add_char_if((Xfile_arg_varfn))
+				if errnr!=(noerror)
+					return errnr
+				endif
+			endif
+			if allowdata=(allow_yes)
+				#at last/only argument it is better to allow space before sufix to not regret later
+				#"##" will be a comment and "#" a sufix
+				set size ptrsize#
+				call extend_arg_size(content,size,#argsize)
+			endif
+			sd argsize_filter
+			sd container_sz
+			if content#=(pointerascii)
+				setcall errnr xfile_add_char_if((Xfile_arg_varfn_prefix_yes))
+				if errnr=(noerror)
+					#prefix
+					setcall prefix prefix_bool()
+					set prefix# 1
+					inc content
+					set argsize_filter argsize
+					dec argsize_filter
+
+					#class test
+					setcall container_sz valinmem(content,argsize_filter,(asciicolon))
+					if container_sz!=argsize_filter
+						setcall errnr getarg_colon(content,argsize_filter,container_sz,ptrdata,ptrlow,ptrsufix)
+					else
+						setcall errnr xfile_add_char_if((Xfile_arg_varfn_colon_no))
+						if errnr=(noerror)
+							setcall errnr getarg_testdot(content,argsize_filter,ptrdata,ptrlow,ptrsufix)
+						else
+							return errnr
+						endelse
+					endelse
+					if errnr!=(noerror)
+						return errnr
+					endif
+				else
+					return errnr
+				endelse
+			else
+				setcall errnr xfile_add_char_if((Xfile_arg_varfn_prefix_no))
+				if errnr=(noerror)
+					data ptrobject%ptrobject
+					data ptrfunctions%%ptr_functions
+
+					#class test
+					setcall container_sz valinmem(content,argsize,(asciicolon))
+					if container_sz!=argsize
+						setcall errnr getarg_colon(content,argsize,container_sz,ptrdata,ptrlow,ptrsufix)
+						if errnr!=(noerror)
+							return errnr
+						endif
+					else
+						setcall errnr xfile_add_char_if((Xfile_arg_varfn_colon_no))
+						if errnr=(noerror)
+							setcall container_sz valinmem(content,argsize,(asciidot))
+							if container_sz!=argsize
+								setcall errnr getarg_dot(content,argsize,container_sz,ptrdata,ptrlow,ptrsufix)
+								if errnr!=(noerror)
+									return errnr
+								endif
+							else
+								SetCall errnr varsufix(content,argsize,ptrdata,ptrlow,ptrsufix)
+								if errnr!=(noerror)
+									if ptrobject#=1
+										sd undvar_err
+										setcall undvar_err undefinedvariable()
+										if errnr=undvar_err
+											#verify for function
+											setcall ptrdata# vars(content,argsize,ptrfunctions)
+											if ptrdata#!=(NULL)
+												setcall errnr xfile_add_string_if(content,argsize)
+												if errnr=(noerror)
+													set ptrlow# (FALSE)
+													set ptrsufix# (sufix_false)
+													sd var
+													setcall var function_in_code()
+													set var# 1
+													#the code operation is a "prefix" like
+													setcall prefix prefix_bool()
+													set prefix# 1
+												else
+													return errnr
+												endelse
+											else
+												setcall errnr undefinedvar_fn()
+												return errnr
+											endelse
+										else
+											return errnr
+										endelse
+									else
+										return errnr
+									endelse
+								endif
+							endelse
+						else
+							return errnr
+						endelse
+					endelse
+				else
+					return errnr
+				endelse
+			endelse
+			Call advancecursors(ptrcontent,ptrsize,argsize)
+			if sens=(FORWARD)
+				return (noerror)
+			endif
+			setcall errnr verify_syntax_end_and_restore(ptrcontent,ptrsize,argsize)
+			return errnr
+		endif
+	endelseif
+	If sens=(FORWARD)
+		Call advancecursors(ptrcontent,ptrsize,argsize)
+	endIf
+	return (noerror)
+EndFunction
+#err
+function getarg_dot_any(sd content,sd argsize,sd container_sz,sd ptrdata,sd ptrlow,sd ptrsufix)
+	sd errnr
+	setcall errnr xfile_add_char_if((Xfile_arg_varfn_dot_yes))
+	if errnr=(noerror)
+		sd scope
+		setcall errnr get_scope(#content,#argsize,container_sz,#scope)
+		if errnr!=(noerror)
+			return errnr
+		endif
+		SetCall errnr varsufix_ex(content,argsize,ptrdata,ptrlow,ptrsufix,scope)
+	endif
+	return errnr
+endfunction
+#err
+function getarg_dot(sd content,sd argsize,sd container_sz,sd ptrdata,sd ptrlow,sd ptrsufix)
+	sd errnr
+	setcall errnr getarg_dot_any(content,argsize,container_sz,ptrdata,ptrlow,ptrsufix)
+	if errnr!=(noerror)
+		return errnr
+	endif
+	sd test;setcall test stackbit(ptrdata#)
+	if test=0
+		return (noerror)
+	endif
+	setcall errnr there_is_nothing_there()
+	return errnr
+endfunction
+#er
+#function getarg_colon(sd content,sd argsize,sd container_sz,sv ptrdata,sd ptrlow,sd ptrsufix)
+#	sd data
+#	sd err
+#	sd scope
+#	sd nr
+#	sd subtract_base
+#	sd part_sz
+
+#	setcall part_sz valinmem(content,container_sz,(asciidot))
+#	sub argsize container_sz
+#	if part_sz!=container_sz
+#		setcall err get_scope(#content,#container_sz,part_sz,#scope)
+#		if err!=(noerror)
+#			return err
+#		endif
+#		setcall data searchinvars_scope(content,container_sz,#nr,scope)
+#		if data==(NULL)
+#			setcall err undefinedvariable()
+#			return err
+#		endif
+#		if nr<(totalmemvariables)
+#			sd entrybags%%ptr_scopes
+#			if scope!=entrybags
+#				#stored class info
+#				setcall subtract_base scopes_get_class_data(scope,data) # test expandbit is inside
+#			else
+#				setcall subtract_base get_img_vdata() #or img_nbdata if exec will have (test expandbit)
+#			endelse
+#		else
+#			#stack
+#			set subtract_base 0
+#		endelse
+#	else
+#		setcall data strinvars(content,container_sz,#nr)
+#		if data==(NULL)
+#			setcall err undefinedvariable()
+#			return err
+#		endif
+#		if nr<(totalmemvariables)
+#			sd ptrinnerfunction%globalinnerfunction
+#			if ptrinnerfunction#==(TRUE)
+#				sd ptrfunctionTagIndex%ptrfunctionTagIndex
+#				setcall scope scopes_get_scope(ptrfunctionTagIndex#)
+#				setcall subtract_base scopes_get_class_data(scope,data)
+#			else
+#				setcall subtract_base get_img_vdata() #or img_nbdata if exec will have (test expandbit)
+#			endelse
+#		else
+#			#stack
+#			set subtract_base 0
+#		endelse
+#	endelse
+
+#	#this offset will be added
+#	sd val;set val data#
+#	sub val subtract_base
+
+#	add content container_sz
+#	call stepcursors(#content,#argsize)
+
+#	#get location and mask
+#	setcall err getarg_testdot(content,argsize,ptrdata,ptrlow,ptrsufix)
+#	if err!=(noerror)
+#		return err
+#	endif
+
+#	char random#1
+#	data *#2    #ignore name
+#	#in case are two args
+#	data *#2    #ignore name
+#	call tempdatapair(#random,ptrdata)
+#	sd pointer;set pointer ptrdata#
+#	add pointer# val
+#	return (noerror)
+#endfunction
+#er
+function getarg_colon(sd content,sd argsize,sd container_sz,sv ptrdata,sd ptrlow,sd ptrsufix)
+	sd err
+	setcall err xfile_add_char_if((Xfile_arg_varfn_colon_yes))
+	if err=(noerror)
+		#first test if has runtime pointer
+		sd pointer_size=0
+		if container_sz!=0
+			# !=0? yes, example: ":"
+			ss cursor=-1
+			add cursor content
+			add cursor container_sz
+			if cursor#=(pointerascii)
+				dec container_sz
+				inc pointer_size
+			endif
+		endif
+		sd data
+		sd scope
+		sd is_stack
+		sd part_sz;setcall part_sz valinmem(content,container_sz,(asciidot))
+		sub argsize container_sz
+		if part_sz!=container_sz
+			setcall err xfile_add_char_if((Xfile_arg_varfn_dot_yes))
+			if err=(noerror)
+				setcall err get_scope(#content,#container_sz,part_sz,#scope)
+				if err!=(noerror)
+					return err
+				endif
+				sd nr;setcall data searchinvars_scope(content,container_sz,#nr,scope)
+				if data=(NULL)
+					setcall err undefinedvariable()
+					return err
+				endif
+				if nr>=(totalmemvariables)
+					setcall err there_is_nothing_there()
+					return err
+				endif
+				set is_stack 0   #use later when keeping location
+			else
+				return err
+			endelse
+		else
+			setcall err xfile_add_char_if((Xfile_arg_varfn_dot_no))
+			if err=(noerror)
+				setcall data searchinvars(content,container_sz,(NULL),(NULL),1)
+				if data=(NULL)
+					setcall err undefinedvariable()
+					return err
+				endif
+				setcall is_stack stackbit(data)
+			else
+				return err
+			endelse
+		endelse
+		#xfile and colon part suffix
+		setcall err xfile_add_string_if(content,container_sz)
+		if err!=(noerror)
+			return err
+		endif
+		if pointer_size!=0
+			setcall err xfile_add_char_if((Xfile_suffix_true))
+		else
+			setcall err xfile_add_char_if((Xfile_suffix_false))
+		endelse
+		if err!=(noerror)
+			return err
+		endif
+
+		add content container_sz
+		call advancecursors(#content,#argsize,pointer_size)
+		call stepcursors(#content,#argsize)
+
+		sd subtract_base
+		sd test
+		setcall container_sz valinmem(content,argsize,(asciidot))
+		if container_sz!=argsize
+			setcall err xfile_add_char_if((Xfile_arg_varfn_dot_yes))
+			if err=(noerror)
+				setcall err getarg_base(content,argsize,container_sz,ptrdata,ptrlow,ptrsufix,#subtract_base)
+				if err!=(noerror)
+					return err
+				endif
+			else
+				return err
+			endelse
+		else
+			SetCall err varsufix(content,argsize,ptrdata,ptrlow,ptrsufix)
+			if err!=(noerror)
+				return err
+			endif
+			setcall test stackbit(ptrdata#)
+			if test=0
+				sd ptrinnerfunction%globalinnerfunction
+				if ptrinnerfunction#=(TRUE)
+					sd ptrfunctionTagIndex%ptrfunctionTagIndex
+					setcall scope scopes_get_scope(ptrfunctionTagIndex#)
+					setcall subtract_base scopes_get_class_data(scope,ptrdata#)
+				else
+					setcall subtract_base get_img_vdata() #if exe will get nobits add one argument, get_img_vdata is also called at datareg and datasize
+				endelse
+			else
+				setcall subtract_base stack64_base(ptrdata#)
+			endelse
+		endelse
+		setcall err tempdataadd(ptrdata)
+		if err=(noerror)
+			sd pointer;set pointer ptrdata#
+			sub pointer# subtract_base
+
+			#keep location, will be some disturbance if combining stack with data, but if not is ok
+			sd pointer2=maskoffset;sd data2=maskoffset
+			add pointer2 pointer
+			add data2 data
+			sd location_part;sd transformation_part
+			if is_stack!=0
+				set location_part (stack_location_bits)
+				and location_part data2#
+				set transformation_part (~stack_location_bits)
+			else
+				set location_part (location_bits)
+				and location_part data2#
+				set transformation_part (~location_bits)
+			endelse
+			and pointer2# transformation_part
+			or pointer2# location_part
+
+			#decide if add offset now or at runtime with sufix
+			if pointer_size!=0
+				#runtime
+				or pointer2# (suffixbit)
+				add pointer2 (masksize) #note that here is not on nameoffset, is on data#3 value from temp
+				set pointer2# pointer#
+				set pointer# data#
+			else
+				add pointer# data#
+			endelse
+		endif
+	endif
+	return err
+endfunction
+#err
+function getarg_testdot(sd content,sd size,sd ptrdata,sd ptrlow,sd ptrsufix)
+	sd errnr
+	sd container_sz
+	setcall container_sz valinmem(content,size,(asciidot))
+	if container_sz!=size
+		setcall errnr getarg_dot(content,size,container_sz,ptrdata,ptrlow,ptrsufix)
+	else
+		SetCall errnr varsufix(content,size,ptrdata,ptrlow,ptrsufix)
+	endelse
+	return errnr
+endfunction
+
+#err
+function getarg_base(sd content,sd argsize,sd container_sz,sv ptrdata,sd ptrlow,sd ptrsufix,sd p_subtract_base)
+	sd err
+	sd scope
+	setcall err get_scope(#content,#argsize,container_sz,#scope)
+	if err!=(noerror)
+		return err
+	endif
+	SetCall err varsufix_ex(content,argsize,ptrdata,ptrlow,ptrsufix,scope)
+	if err!=(noerror)
+		return err
+	endif
+	sd test
+	setcall test stackbit(ptrdata#)
+	if test=0
+		sd entrybags%%ptr_scopes
+		if scope!=entrybags
+			#stored class info
+			setcall p_subtract_base# scopes_get_class_data(scope,ptrdata#) # test expandbit is inside
+		else
+			setcall p_subtract_base# get_img_vdata() #if exe will get nobits add one argument, get_img_vdata is also called at datareg and datasize
+		endelse
+	else
+		setcall p_subtract_base# stack64_base(ptrdata#)
+	endelse
+	return (noerror)
+endfunction
+
+function there_is_nothing_there()
+	return "Stack variables are not relevant for scope.variable."
+endfunction
+
+#err
+function get_scope(sv pcontent,sd psize,sd sz,sv pscope)
+	sd pos
+	sd err;setcall err get_scope_pos(pcontent#,sz,#pos)
+	if err=(noerror)
+		inc sz
+		call advancecursors(pcontent,psize,sz)
+		setcall pscope# scopes_get_scope(pos)
+	endif
+	return err
+endfunction
+#err
+function get_scope_pos(ss content,sd sz,sv ppos)
+	data ptrfunctions%%ptr_functions
+	set ppos# 0
+	sd var
+	setcall var vars_core_ref_scope(content,sz,ptrfunctions,(NULL),(TRUE),ppos)
+	if var!=(NULL)
+		sd err;setcall err xfile_add_string_if(content,sz)
+		return err
+	endif
+	return "Undefined function name."
+endfunction
+
+function function_in_code()
+	data bool#1
+	return #bool
+endfunction
+
+function is_constant_related_ascii(sd in_byte)
+# ! data cursor
+	if in_byte=(asciiexclamationmark)
+		return (TRUE)
+	elseif in_byte=(asciiparenthesisstart)
+		return (TRUE)
+#negative number
+	elseif in_byte=(asciiminus)
+		return (TRUE)
+	elseif in_byte<(asciizero)
+		return (FALSE)
+	elseif in_byte<=(asciinine)
+		return (TRUE)
+# : size of integer
+	elseif in_byte=(asciicolon)
+		return (TRUE)
+# not,~
+	elseif in_byte=(asciiequiv)
+		return (TRUE)
+	endelseif
+	return (FALSE)
+endfunction
+
+#err
+Function arg(sv ptrcontent,sd ptrsize,sd ptrdata,sd ptrlow,sd ptrsufix,sd sens,sd allowdata)
+	sd szarg
+	set szarg ptrsize#
+
+	Data errnr#1
+	SetCall errnr getarg(ptrcontent,ptrsize,szarg,allowdata,sens,ptrdata,ptrlow,ptrsufix)
+	Return errnr
+EndFunction
+
+#err
+Function argfilters(sd ptrcondition,sv ptrcontent,sd ptrsize,sd ptrdata,sd ptrlow,sd ptrsufix,sd allowdata)
+	sd err
+	setcall err argfilters_helper(ptrcondition,ptrcontent,ptrsize,ptrdata,ptrlow,ptrsufix,allowdata)
+	if err=(noerror)
+		#this is only at first arg
+		call spaces(ptrcontent,ptrsize)
+	endif
+	return err
+endfunction
+#err
+function argfilters_helper(sd ptrcondition,sv ptrcontent,sd ptrsize,sd ptrdata,sd ptrlow,sd ptrsufix,sd allowdata)
+	Data null=NULL
+	Data err#1
+	Data forward=FORWARD
+
+	If ptrcondition=null
+		call unsetimm()
+		SetCall err arg(ptrcontent,ptrsize,ptrdata,ptrlow,ptrsufix,forward,allowdata)
+		Return err
+	EndIf
+	call setimm()
+
+	vstr content#1
+	Data size#1
+	Set content ptrcontent#
+	Set size ptrsize#
+	Data argsz#1
+
+	#and same rule like getcommand like elseif then else
+	Char firstcomp="!=";Data *je=Xfile_cond_notequal
+	Char *="<=^";       Data *ja=Xfile_cond_lessequalunsign
+	Char *=">=^";       Data *jb=Xfile_cond_greatequalunsign
+	Char *="<=";        Data *jg=Xfile_cond_lessequal
+	Char *=">=";        Data *jl=Xfile_cond_greatequal
+	Char *="<^";        Data *jae=Xfile_cond_lessunsign   #wanted cast before but will problem with arg cast that was after to continue at suffix
+	Char *=">^";        Data *jbe=Xfile_cond_greatunsign
+	Char *="=";         Data *jne=Xfile_cond_equal
+	Char *="<";         Data *jge=Xfile_cond_less
+	Char *=">";         Data *jle=Xfile_cond_great
+	Char *="!!";        Data *jp=Xfile_cond_notparity     #example: if 1 (2!1) or if 0x7f..f
+	Char *="!";         Data *jnp=Xfile_cond_parity       #example: if 3 (4!1) or if 0xff..f
+	Char term={0}
+
+	Data ptr#1
+	Data ptrini^firstcomp
+	Char byte#1
+	Data sz#1
+	Data errnr#1
+
+	Set ptr ptrini
+	Set byte ptr#
+
+	if size>0
+		if content#=(asciiparenthesisstart)
+	#let a possibility for example for (a<<b)!=c
+			SetCall errnr getarg(ptrcontent,ptrsize,ptrsize#,allowdata,forward,ptrdata,ptrlow,ptrsufix)
+			if errnr!=(noerror)
+				Return errnr
+			endif
+			Set content ptrcontent#
+			Set size ptrsize#
+			While byte!=term
+				SetCall argsz stringatmem(content,size,ptr)
+				If argsz!=size
+					Set ptrcondition# ptr
+					return (noerror)
+				endif
+				SetCall sz strlen(ptr)
+				Add ptr sz
+				Add ptr (1+4)
+				Set byte ptr#
+			endwhile
+		endif
+	endif
+	While byte!=term
+		SetCall argsz stringinmem(content,size,ptr)
+		If argsz!=size
+			Set ptrcondition# ptr
+			sd verifyafter
+			set verifyafter content
+			add verifyafter argsz
+			SetCall errnr getarg(ptrcontent,ptrsize,argsz,allowdata,forward,ptrdata,ptrlow,ptrsufix)
+			data noerrnr=noerror
+			if errnr!=noerrnr
+				Return errnr
+			endif
+			if verifyafter!=ptrcontent#
+				str moreatprimcond="Unrecognized characters at first condition argument."
+				return moreatprimcond
+			endif
+			return noerrnr
+		EndIf
+		SetCall sz strlen(ptr)
+		Add ptr sz
+		Add ptr (1+4)
+		Set byte ptr#
+	EndWhile
+	Char conderr="Condition sign(s) expected."
+	Str _conderr^conderr
+	Return _conderr
+	Return err
+EndFunction
+
+function prefix_bool()
+	data value#1
+	data p^value
+	return p
+endfunction
--- ocompiler-1.orig/src/files/functions/argument/arg.s
+++ /dev/null
@@ -1,781 +0,0 @@
-
-function verify_syntax_end_and_restore(sv ptrcontent,sd ptrsize,sd argsize)
-	sd c
-	sd s
-	set c ptrcontent#
-	set s ptrsize#
-
-	Call spaces(ptrcontent,ptrsize)
-	data z=0
-	if ptrsize#!=z
-		str er="Unrecognized inner text."
-		return er
-	endif
-	sub c argsize
-	add s argsize
-	set ptrcontent# c
-	set ptrsize# s
-	return (noerror)
-endfunction
-
-function arg_size(ss content,sd sizetoverify,sd p_argsize)
-	Char spc=asciispace
-	Char tab=asciitab
-	sd szargspc
-	sd szargtab
-	SetCall szargspc valinmem(content,sizetoverify,spc)
-	SetCall szargtab valinmem(content,sizetoverify,tab)
-	If szargspc<szargtab
-		Set p_argsize# szargspc
-	Else
-		Set p_argsize# szargtab
-	EndElse
-	#was resolved at push enumcomma. if p_argsize#=0
-	#	return "Expecting argument name."  #this is good at BACKWARD, call a( )
-	#endif
-	#at callex (going to undefined at varsize=size) and at declare^ is ok
-endfunction
-
-function extend_arg_size(ss content,sd sizetoverify,sd p_argsize)
-	sub sizetoverify p_argsize#
-	if sizetoverify!=0
-		add content p_argsize#
-		ss marker;set marker content
-		dec marker	##argsize is not 0
-		if marker#!=(pointerascii)
-			if marker#!=(castascii)
-				set marker content
-				call spaces(#content,#sizetoverify)
-				if sizetoverify!=0
-					if content#=(pointerascii)
-						call stepcursors(#content,#sizetoverify)
-						if sizetoverify!=0
-							if content#=(pointerascii)
-								#this " ##" is the only line end comment after sufix and allowing spaces
-								set main.xfile_sharp_comment (nonzero)   #and notify for xfile
-								ret
-							endif
-							#this disallow "arg #comment"
-							addcall p_argsize# find_whitespaceORcomment(content,sizetoverify)
-						endif
-						#and not letting "arg #" as comment to not regret later
-						sub content marker
-						add p_argsize# content
-					endif
-				endif
-			endif
-		endif
-	endif
-endfunction
-function extend_sufix_test(ss content,sd p_size)
-	while p_size#!=0
-		dec content
-		sd b;setcall b is_whitespace(content#)
-		if b=(FALSE)
-			ret
-		endif
-		dec p_size#
-	endwhile
-endfunction
-
-#err
-Function getarg(sv ptrcontent,sd ptrsize,sd argsize,sd allowdata,sd sens,sd ptrdata,sd ptrlow,sd ptrsufix)
-	ss content
-	sd size
-	sd errnr
-
-	char d_q=getarg_str
-
-	if argsize=0
-		return "Argument name expected."
-	endif
-
-	data false=0
-
-	Set content ptrcontent#
-
-	sd prefix
-	if content#=d_q
-		sd q_size
-		sd escapes
-		set size ptrsize#
-		SetCall errnr quotinmem(#content,#size,#q_size,#escapes) #this has a stepcursors
-		If errnr!=(noerror)
-			return errnr
-		endif
-		if allowdata!=(allow_yes)
-			if allowdata=(allow_later)
-				vdata ptrdataReg%%ptr_dataReg
-				sub q_size escapes
-				add ptrdataReg# q_size
-				inc ptrdataReg#   #null end
-			else
-				#allow_no later_sec
-				return "String here is useless at the moment."  #the real problem: is disturbing virtual calculation at pass_init
-			endelse
-		else
-			setcall errnr xfile_add_char_if((Xfile_arg_string))
-			If errnr!=(noerror)
-				return errnr
-			endif
-			#get entry
-			sd sec%ptrdummyEntry
-			call getcont(sec,ptrdata)
-			sd location
-			set location ptrdata#
-			setcall location# get_img_vdata_dataReg()
-
-			#set string to data
-			data ptrdatasec%%ptr_datasec
-			set ptrcontent# content
-			set ptrsize# size
-			SetCall errnr addtosecstresc_xfile(ptrcontent,ptrsize,q_size,escapes,ptrdatasec)
-			If errnr!=(noerror)
-				return errnr
-			endif
-			#set low and sufix
-			set ptrlow# (FALSE)
-			set ptrsufix# (sufix_false)
-			#the code operation is a "prefix" like
-			setcall prefix prefix_bool()
-			set prefix# 1
-
-			#advancing
-			if sens=(FORWARD)
-				return (noerror)
-			endif
-			add q_size 2
-			setcall errnr verify_syntax_end_and_restore(ptrcontent,ptrsize,q_size)
-			return errnr
-		endelse
-	elseif allowdata!=(allow_later)  #exclude pass_init, but even there jump over first arg
-		call arg_size(content,argsize,#argsize)  #spc,tab
-		if allowdata!=(allow_later_sec)
-			sd bool
-			setcall bool is_constant_related_ascii(content#)
-			if bool=(TRUE)
-				#verify if imm is ok
-				sd canhaveimm
-				setcall canhaveimm getimm()
-				if canhaveimm=false
-					str immnothere="Unexpected numbers/constants, expecting a variable."
-					return immnothere
-				endif
-				setcall errnr xfile_add_char_if((Xfile_arg_number))
-				if errnr=(noerror)
-					#extend to parenthesis if found
-					if content#=(asciiparenthesisstart)
-						call stepcursors(ptrcontent,ptrsize)
-						setcall errnr parenthesis_size(ptrcontent#,ptrsize#,#argsize)
-						if errnr!=(noerror)
-							return errnr
-						endif
-						setcall errnr parseoperations(ptrcontent,ptrsize,argsize,ptrdata,(FALSE))
-						if errnr!=(noerror)
-							return errnr
-						endif
-						call stepcursors(ptrcontent,ptrsize)
-						if sens=(BACKWARD)
-							add argsize 2 #the recognised parenthesis
-						endif
-					else
-						setcall errnr parseoperations(ptrcontent,ptrsize,argsize,ptrdata,(FALSE))
-						if errnr!=(noerror)
-							return errnr
-						endif
-					endelse
-				endif
-
-				call setisimm()
-				#sufix is not used at imm value
-				set ptrlow# false
-
-				if sens=(FORWARD)
-					return (noerror)
-				endif
-				setcall errnr verify_syntax_end_and_restore(ptrcontent,ptrsize,argsize)
-				return errnr
-			endif
-			sd imm;setcall imm getimm()
-			if imm=(TRUE) #if is FALSE, this is the only option for xfile. also allow(string) is no
-			#then, this is a test at allow yes; also at allow no for conditions
-				setcall errnr xfile_add_char_if((Xfile_arg_varfn))
-				if errnr!=(noerror)
-					return errnr
-				endif
-			endif
-			if allowdata=(allow_yes)
-				#at last/only argument it is better to allow space before sufix to not regret later
-				#"##" will be a comment and "#" a sufix
-				set size ptrsize#
-				call extend_arg_size(content,size,#argsize)
-			endif
-			sd argsize_filter
-			sd container_sz
-			if content#=(pointerascii)
-				setcall errnr xfile_add_char_if((Xfile_arg_varfn_prefix_yes))
-				if errnr=(noerror)
-					#prefix
-					setcall prefix prefix_bool()
-					set prefix# 1
-					inc content
-					set argsize_filter argsize
-					dec argsize_filter
-
-					#class test
-					setcall container_sz valinmem(content,argsize_filter,(asciicolon))
-					if container_sz!=argsize_filter
-						setcall errnr getarg_colon(content,argsize_filter,container_sz,ptrdata,ptrlow,ptrsufix)
-					else
-						setcall errnr xfile_add_char_if((Xfile_arg_varfn_colon_no))
-						if errnr=(noerror)
-							setcall errnr getarg_testdot(content,argsize_filter,ptrdata,ptrlow,ptrsufix)
-						else
-							return errnr
-						endelse
-					endelse
-					if errnr!=(noerror)
-						return errnr
-					endif
-				else
-					return errnr
-				endelse
-			else
-				setcall errnr xfile_add_char_if((Xfile_arg_varfn_prefix_no))
-				if errnr=(noerror)
-					data ptrobject%ptrobject
-					data ptrfunctions%%ptr_functions
-
-					#class test
-					setcall container_sz valinmem(content,argsize,(asciicolon))
-					if container_sz!=argsize
-						setcall errnr getarg_colon(content,argsize,container_sz,ptrdata,ptrlow,ptrsufix)
-						if errnr!=(noerror)
-							return errnr
-						endif
-					else
-						setcall errnr xfile_add_char_if((Xfile_arg_varfn_colon_no))
-						if errnr=(noerror)
-							setcall container_sz valinmem(content,argsize,(asciidot))
-							if container_sz!=argsize
-								setcall errnr getarg_dot(content,argsize,container_sz,ptrdata,ptrlow,ptrsufix)
-								if errnr!=(noerror)
-									return errnr
-								endif
-							else
-								SetCall errnr varsufix(content,argsize,ptrdata,ptrlow,ptrsufix)
-								if errnr!=(noerror)
-									if ptrobject#=1
-										sd undvar_err
-										setcall undvar_err undefinedvariable()
-										if errnr=undvar_err
-											#verify for function
-											setcall ptrdata# vars(content,argsize,ptrfunctions)
-											if ptrdata#!=(NULL)
-												setcall errnr xfile_add_string_if(content,argsize)
-												if errnr=(noerror)
-													set ptrlow# (FALSE)
-													set ptrsufix# (sufix_false)
-													sd var
-													setcall var function_in_code()
-													set var# 1
-													#the code operation is a "prefix" like
-													setcall prefix prefix_bool()
-													set prefix# 1
-												else
-													return errnr
-												endelse
-											else
-												setcall errnr undefinedvar_fn()
-												return errnr
-											endelse
-										else
-											return errnr
-										endelse
-									else
-										return errnr
-									endelse
-								endif
-							endelse
-						else
-							return errnr
-						endelse
-					endelse
-				else
-					return errnr
-				endelse
-			endelse
-			Call advancecursors(ptrcontent,ptrsize,argsize)
-			if sens=(FORWARD)
-				return (noerror)
-			endif
-			setcall errnr verify_syntax_end_and_restore(ptrcontent,ptrsize,argsize)
-			return errnr
-		endif
-	endelseif
-	If sens=(FORWARD)
-		Call advancecursors(ptrcontent,ptrsize,argsize)
-	endIf
-	return (noerror)
-EndFunction
-#err
-function getarg_dot_any(sd content,sd argsize,sd container_sz,sd ptrdata,sd ptrlow,sd ptrsufix)
-	sd errnr
-	setcall errnr xfile_add_char_if((Xfile_arg_varfn_dot_yes))
-	if errnr=(noerror)
-		sd scope
-		setcall errnr get_scope(#content,#argsize,container_sz,#scope)
-		if errnr!=(noerror)
-			return errnr
-		endif
-		SetCall errnr varsufix_ex(content,argsize,ptrdata,ptrlow,ptrsufix,scope)
-	endif
-	return errnr
-endfunction
-#err
-function getarg_dot(sd content,sd argsize,sd container_sz,sd ptrdata,sd ptrlow,sd ptrsufix)
-	sd errnr
-	setcall errnr getarg_dot_any(content,argsize,container_sz,ptrdata,ptrlow,ptrsufix)
-	if errnr!=(noerror)
-		return errnr
-	endif
-	sd test;setcall test stackbit(ptrdata#)
-	if test=0
-		return (noerror)
-	endif
-	setcall errnr there_is_nothing_there()
-	return errnr
-endfunction
-#er
-#function getarg_colon(sd content,sd argsize,sd container_sz,sv ptrdata,sd ptrlow,sd ptrsufix)
-#	sd data
-#	sd err
-#	sd scope
-#	sd nr
-#	sd subtract_base
-#	sd part_sz
-
-#	setcall part_sz valinmem(content,container_sz,(asciidot))
-#	sub argsize container_sz
-#	if part_sz!=container_sz
-#		setcall err get_scope(#content,#container_sz,part_sz,#scope)
-#		if err!=(noerror)
-#			return err
-#		endif
-#		setcall data searchinvars_scope(content,container_sz,#nr,scope)
-#		if data==(NULL)
-#			setcall err undefinedvariable()
-#			return err
-#		endif
-#		if nr<(totalmemvariables)
-#			sd entrybags%%ptr_scopes
-#			if scope!=entrybags
-#				#stored class info
-#				setcall subtract_base scopes_get_class_data(scope,data) # test expandbit is inside
-#			else
-#				setcall subtract_base get_img_vdata() #or img_nbdata if exec will have (test expandbit)
-#			endelse
-#		else
-#			#stack
-#			set subtract_base 0
-#		endelse
-#	else
-#		setcall data strinvars(content,container_sz,#nr)
-#		if data==(NULL)
-#			setcall err undefinedvariable()
-#			return err
-#		endif
-#		if nr<(totalmemvariables)
-#			sd ptrinnerfunction%globalinnerfunction
-#			if ptrinnerfunction#==(TRUE)
-#				sd ptrfunctionTagIndex%ptrfunctionTagIndex
-#				setcall scope scopes_get_scope(ptrfunctionTagIndex#)
-#				setcall subtract_base scopes_get_class_data(scope,data)
-#			else
-#				setcall subtract_base get_img_vdata() #or img_nbdata if exec will have (test expandbit)
-#			endelse
-#		else
-#			#stack
-#			set subtract_base 0
-#		endelse
-#	endelse
-
-#	#this offset will be added
-#	sd val;set val data#
-#	sub val subtract_base
-
-#	add content container_sz
-#	call stepcursors(#content,#argsize)
-
-#	#get location and mask
-#	setcall err getarg_testdot(content,argsize,ptrdata,ptrlow,ptrsufix)
-#	if err!=(noerror)
-#		return err
-#	endif
-
-#	char random#1
-#	data *#2    #ignore name
-#	#in case are two args
-#	data *#2    #ignore name
-#	call tempdatapair(#random,ptrdata)
-#	sd pointer;set pointer ptrdata#
-#	add pointer# val
-#	return (noerror)
-#endfunction
-#er
-function getarg_colon(sd content,sd argsize,sd container_sz,sv ptrdata,sd ptrlow,sd ptrsufix)
-	sd err
-	setcall err xfile_add_char_if((Xfile_arg_varfn_colon_yes))
-	if err=(noerror)
-		#first test if has runtime pointer
-		sd pointer_size=0
-		if container_sz!=0
-			# !=0? yes, example: ":"
-			ss cursor=-1
-			add cursor content
-			add cursor container_sz
-			if cursor#=(pointerascii)
-				dec container_sz
-				inc pointer_size
-			endif
-		endif
-		sd data
-		sd scope
-		sd is_stack
-		sd part_sz;setcall part_sz valinmem(content,container_sz,(asciidot))
-		sub argsize container_sz
-		if part_sz!=container_sz
-			setcall err xfile_add_char_if((Xfile_arg_varfn_dot_yes))
-			if err=(noerror)
-				setcall err get_scope(#content,#container_sz,part_sz,#scope)
-				if err!=(noerror)
-					return err
-				endif
-				sd nr;setcall data searchinvars_scope(content,container_sz,#nr,scope)
-				if data=(NULL)
-					setcall err undefinedvariable()
-					return err
-				endif
-				if nr>=(totalmemvariables)
-					setcall err there_is_nothing_there()
-					return err
-				endif
-				set is_stack 0   #use later when keeping location
-			else
-				return err
-			endelse
-		else
-			setcall err xfile_add_char_if((Xfile_arg_varfn_dot_no))
-			if err=(noerror)
-				setcall data searchinvars(content,container_sz,(NULL),(NULL),1)
-				if data=(NULL)
-					setcall err undefinedvariable()
-					return err
-				endif
-				setcall is_stack stackbit(data)
-			else
-				return err
-			endelse
-		endelse
-		#xfile and colon part suffix
-		setcall err xfile_add_string_if(content,container_sz)
-		if err!=(noerror)
-			return err
-		endif
-		if pointer_size!=0
-			setcall err xfile_add_char_if((Xfile_suffix_true))
-		else
-			setcall err xfile_add_char_if((Xfile_suffix_false))
-		endelse
-		if err!=(noerror)
-			return err
-		endif
-
-		add content container_sz
-		call advancecursors(#content,#argsize,pointer_size)
-		call stepcursors(#content,#argsize)
-
-		sd subtract_base
-		sd test
-		setcall container_sz valinmem(content,argsize,(asciidot))
-		if container_sz!=argsize
-			setcall err xfile_add_char_if((Xfile_arg_varfn_dot_yes))
-			if err=(noerror)
-				setcall err getarg_base(content,argsize,container_sz,ptrdata,ptrlow,ptrsufix,#subtract_base)
-				if err!=(noerror)
-					return err
-				endif
-			else
-				return err
-			endelse
-		else
-			SetCall err varsufix(content,argsize,ptrdata,ptrlow,ptrsufix)
-			if err!=(noerror)
-				return err
-			endif
-			setcall test stackbit(ptrdata#)
-			if test=0
-				sd ptrinnerfunction%globalinnerfunction
-				if ptrinnerfunction#=(TRUE)
-					sd ptrfunctionTagIndex%ptrfunctionTagIndex
-					setcall scope scopes_get_scope(ptrfunctionTagIndex#)
-					setcall subtract_base scopes_get_class_data(scope,ptrdata#)
-				else
-					setcall subtract_base get_img_vdata() #if exe will get nobits add one argument, get_img_vdata is also called at datareg and datasize
-				endelse
-			else
-				setcall subtract_base stack64_base(ptrdata#)
-			endelse
-		endelse
-		setcall err tempdataadd(ptrdata)
-		if err=(noerror)
-			sd pointer;set pointer ptrdata#
-			sub pointer# subtract_base
-
-			#keep location, will be some disturbance if combining stack with data, but if not is ok
-			sd pointer2=maskoffset;sd data2=maskoffset
-			add pointer2 pointer
-			add data2 data
-			sd location_part;sd transformation_part
-			if is_stack!=0
-				set location_part (stack_location_bits)
-				and location_part data2#
-				set transformation_part (~stack_location_bits)
-			else
-				set location_part (location_bits)
-				and location_part data2#
-				set transformation_part (~location_bits)
-			endelse
-			and pointer2# transformation_part
-			or pointer2# location_part
-
-			#decide if add offset now or at runtime with sufix
-			if pointer_size!=0
-				#runtime
-				or pointer2# (suffixbit)
-				add pointer2 (masksize) #note that here is not on nameoffset, is on data#3 value from temp
-				set pointer2# pointer#
-				set pointer# data#
-			else
-				add pointer# data#
-			endelse
-		endif
-	endif
-	return err
-endfunction
-#err
-function getarg_testdot(sd content,sd size,sd ptrdata,sd ptrlow,sd ptrsufix)
-	sd errnr
-	sd container_sz
-	setcall container_sz valinmem(content,size,(asciidot))
-	if container_sz!=size
-		setcall errnr getarg_dot(content,size,container_sz,ptrdata,ptrlow,ptrsufix)
-	else
-		SetCall errnr varsufix(content,size,ptrdata,ptrlow,ptrsufix)
-	endelse
-	return errnr
-endfunction
-
-#err
-function getarg_base(sd content,sd argsize,sd container_sz,sv ptrdata,sd ptrlow,sd ptrsufix,sd p_subtract_base)
-	sd err
-	sd scope
-	setcall err get_scope(#content,#argsize,container_sz,#scope)
-	if err!=(noerror)
-		return err
-	endif
-	SetCall err varsufix_ex(content,argsize,ptrdata,ptrlow,ptrsufix,scope)
-	if err!=(noerror)
-		return err
-	endif
-	sd test
-	setcall test stackbit(ptrdata#)
-	if test=0
-		sd entrybags%%ptr_scopes
-		if scope!=entrybags
-			#stored class info
-			setcall p_subtract_base# scopes_get_class_data(scope,ptrdata#) # test expandbit is inside
-		else
-			setcall p_subtract_base# get_img_vdata() #if exe will get nobits add one argument, get_img_vdata is also called at datareg and datasize
-		endelse
-	else
-		setcall p_subtract_base# stack64_base(ptrdata#)
-	endelse
-	return (noerror)
-endfunction
-
-function there_is_nothing_there()
-	return "Stack variables are not relevant for scope.variable."
-endfunction
-
-#err
-function get_scope(sv pcontent,sd psize,sd sz,sv pscope)
-	sd pos
-	sd err;setcall err get_scope_pos(pcontent#,sz,#pos)
-	if err=(noerror)
-		inc sz
-		call advancecursors(pcontent,psize,sz)
-		setcall pscope# scopes_get_scope(pos)
-	endif
-	return err
-endfunction
-#err
-function get_scope_pos(ss content,sd sz,sv ppos)
-	data ptrfunctions%%ptr_functions
-	set ppos# 0
-	sd var
-	setcall var vars_core_ref_scope(content,sz,ptrfunctions,(NULL),(TRUE),ppos)
-	if var!=(NULL)
-		sd err;setcall err xfile_add_string_if(content,sz)
-		return err
-	endif
-	return "Undefined function name."
-endfunction
-
-function function_in_code()
-	data bool#1
-	return #bool
-endfunction
-
-function is_constant_related_ascii(sd in_byte)
-# ! data cursor
-	if in_byte=(asciiexclamationmark)
-		return (TRUE)
-	elseif in_byte=(asciiparenthesisstart)
-		return (TRUE)
-#negative number
-	elseif in_byte=(asciiminus)
-		return (TRUE)
-	elseif in_byte<(asciizero)
-		return (FALSE)
-	elseif in_byte<=(asciinine)
-		return (TRUE)
-# : size of integer
-	elseif in_byte=(asciicolon)
-		return (TRUE)
-# not,~
-	elseif in_byte=(asciiequiv)
-		return (TRUE)
-	endelseif
-	return (FALSE)
-endfunction
-
-#err
-Function arg(sv ptrcontent,sd ptrsize,sd ptrdata,sd ptrlow,sd ptrsufix,sd sens,sd allowdata)
-	sd szarg
-	set szarg ptrsize#
-
-	Data errnr#1
-	SetCall errnr getarg(ptrcontent,ptrsize,szarg,allowdata,sens,ptrdata,ptrlow,ptrsufix)
-	Return errnr
-EndFunction
-
-#err
-Function argfilters(sd ptrcondition,sv ptrcontent,sd ptrsize,sd ptrdata,sd ptrlow,sd ptrsufix,sd allowdata)
-	sd err
-	setcall err argfilters_helper(ptrcondition,ptrcontent,ptrsize,ptrdata,ptrlow,ptrsufix,allowdata)
-	if err=(noerror)
-		#this is only at first arg
-		call spaces(ptrcontent,ptrsize)
-	endif
-	return err
-endfunction
-#err
-function argfilters_helper(sd ptrcondition,sv ptrcontent,sd ptrsize,sd ptrdata,sd ptrlow,sd ptrsufix,sd allowdata)
-	Data null=NULL
-	Data err#1
-	Data forward=FORWARD
-
-	If ptrcondition=null
-		call unsetimm()
-		SetCall err arg(ptrcontent,ptrsize,ptrdata,ptrlow,ptrsufix,forward,allowdata)
-		Return err
-	EndIf
-	call setimm()
-
-	vstr content#1
-	Data size#1
-	Set content ptrcontent#
-	Set size ptrsize#
-	Data argsz#1
-
-	#and same rule like getcommand like elseif then else
-	Char firstcomp="!=";Data *je=Xfile_cond_notequal
-	Char *="<=^";       Data *ja=Xfile_cond_lessequalunsign
-	Char *=">=^";       Data *jb=Xfile_cond_greatequalunsign
-	Char *="<=";        Data *jg=Xfile_cond_lessequal
-	Char *=">=";        Data *jl=Xfile_cond_greatequal
-	Char *="<^";        Data *jae=Xfile_cond_lessunsign   #wanted cast before but will problem with arg cast that was after to continue at suffix
-	Char *=">^";        Data *jbe=Xfile_cond_greatunsign
-	Char *="=";         Data *jne=Xfile_cond_equal
-	Char *="<";         Data *jge=Xfile_cond_less
-	Char *=">";         Data *jle=Xfile_cond_great
-	Char *="!!";        Data *jp=Xfile_cond_notparity     #example: if 1 (2!1) or if 0x7f..f
-	Char *="!";         Data *jnp=Xfile_cond_parity       #example: if 3 (4!1) or if 0xff..f
-	Char term={0}
-
-	Data ptr#1
-	Data ptrini^firstcomp
-	Char byte#1
-	Data sz#1
-	Data errnr#1
-
-	Set ptr ptrini
-	Set byte ptr#
-
-	if size>0
-		if content#=(asciiparenthesisstart)
-	#let a possibility for example for (a<<b)!=c
-			SetCall errnr getarg(ptrcontent,ptrsize,ptrsize#,allowdata,forward,ptrdata,ptrlow,ptrsufix)
-			if errnr!=(noerror)
-				Return errnr
-			endif
-			Set content ptrcontent#
-			Set size ptrsize#
-			While byte!=term
-				SetCall argsz stringatmem(content,size,ptr)
-				If argsz!=size
-					Set ptrcondition# ptr
-					return (noerror)
-				endif
-				SetCall sz strlen(ptr)
-				Add ptr sz
-				Add ptr (1+4)
-				Set byte ptr#
-			endwhile
-		endif
-	endif
-	While byte!=term
-		SetCall argsz stringinmem(content,size,ptr)
-		If argsz!=size
-			Set ptrcondition# ptr
-			sd verifyafter
-			set verifyafter content
-			add verifyafter argsz
-			SetCall errnr getarg(ptrcontent,ptrsize,argsz,allowdata,forward,ptrdata,ptrlow,ptrsufix)
-			data noerrnr=noerror
-			if errnr!=noerrnr
-				Return errnr
-			endif
-			if verifyafter!=ptrcontent#
-				str moreatprimcond="Unrecognized characters at first condition argument."
-				return moreatprimcond
-			endif
-			return noerrnr
-		EndIf
-		SetCall sz strlen(ptr)
-		Add ptr sz
-		Add ptr (1+4)
-		Set byte ptr#
-	EndWhile
-	Char conderr="Condition sign(s) expected."
-	Str _conderr^conderr
-	Return _conderr
-	Return err
-EndFunction
-
-function prefix_bool()
-	data value#1
-	data p^value
-	return p
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/argument/argument.oc
@@ -0,0 +1,274 @@
+
+#sz
+function getreturn(data ptrptrcontinuation)
+	sd b;setcall b scope64_get()
+	if b=(TRUE)
+		sd conv;setcall conv convdata((convdata_total))
+		if conv=(lin_convention)
+			char lin64_return={0xc9,0x5b}
+			#pop c;add rsp,8*conv;push c
+			char *={0x59,REX_Operand_64,0x83,regregmod|espregnumber,lin_convention*qwsz,0x51}
+			char *=retcom
+			set ptrptrcontinuation# #lin64_return
+			return (2+6+1)
+		endif
+	endif
+	Char returncontinuation={0xc9,0x5b,retcom}
+	str ptrreturncontinuation^returncontinuation
+	data sizeretcontinuation=3
+	set ptrptrcontinuation# ptrreturncontinuation
+	return sizeretcontinuation
+endfunction
+#err
+function getexit(sv ptrptrcontinuation,sd psizeofcontinuation)
+	#if to keep rsp can be leave pop sub rsp,:
+
+	#int 0x80, sys_exit, eax 1,ebx the return number
+	char sys_exit={0xb8,1,0,0,0}
+	data exinit^sys_exit
+	data exitsize=5
+	Data codeptr%%ptr_codesec
+	sd err
+	SetCall err addtosec(exinit,exitsize,codeptr)
+	If err!=(noerror)
+		Return err
+	EndIf
+
+	Char unixcontinuation={intimm8,0x80}
+	set ptrptrcontinuation# #unixcontinuation
+	set psizeofcontinuation# 2
+	return (noerror)
+endfunction
+
+#err
+function argument_return(sd termswitch,ss pop,sd pregprepare_bool,sv pptrcontinuation,sd psizeofcontinuation,sd pregopcode)
+	call setimm()
+	Set pop# (moveatprocthemem)
+	Set pregprepare_bool# (TRUE)
+	set main.endfunction_has_write_marker (FALSE)
+
+	if termswitch=(TRUE)
+		data ebxregnumber=ebxregnumber
+		set pregopcode# ebxregnumber
+		sd err
+		setcall err getexit(pptrcontinuation,psizeofcontinuation)
+		return err
+	endif
+	set pregopcode# (eaxregnumber)
+	setcall psizeofcontinuation# getreturn(pptrcontinuation)
+	return (noerror)
+endfunction
+
+#err
+Function argument(data ptrcontent,data ptrsize,data forwardORcallsens,data subtype)
+	Data false=FALSE
+	Data true=TRUE
+
+	Data regprepare_bool#1
+
+	Char op#1
+	Data zero=0
+
+	Str ptrcontinuation#1
+	Data sizeofcontinuation#1
+
+	vData codeptr%%ptr_codesec
+	Data regopcode#1
+
+	Data err#1
+	Data forward=FORWARD
+
+	Set regprepare_bool false
+	Set sizeofcontinuation zero
+
+	If forwardORcallsens=forward
+		call unsetimm() #set is at returns/and at push
+
+		sd xlog
+		If subtype=(cRETURN)
+			sd termswitch
+			setcall termswitch is_linux_end() #exit from linux term
+			setcall err argument_return(termswitch,#op,#regprepare_bool,#ptrcontinuation,#sizeofcontinuation,#regopcode)
+			If err!=(noerror)
+				Return err
+			EndIf
+			set xlog (Xfile_action_areturn)
+		ElseIf subtype=(cINC)
+			Char inc={0xFF}
+			Set op inc
+			set regopcode 0
+			set xlog (Xfile_action_tinc)
+		ElseIf subtype=(cDEC)
+			Char dec={0xFF}
+			Char decregopcode={1}
+			Set op dec
+			Set regopcode decregopcode
+			set xlog (Xfile_action_tdec)
+		ElseIf subtype<=(cDECST)
+			set op (0x83)
+			if subtype=(cINCST)
+				set regopcode 0
+				set xlog (Xfile_action_tincst)
+			else
+				set regopcode 5
+				set xlog (Xfile_action_tdecst)
+			endelse
+			char incs_sz#1
+			sd b;setcall b is_for_64()
+			if b=(FALSE);set incs_sz (dwsz)
+			else;set incs_sz (qwsz);endelse
+			set ptrcontinuation #incs_sz
+			set sizeofcontinuation (bsz)
+		ElseIf subtype=(cNEG)
+			set op (0xf7)
+			set regopcode 3
+			set xlog (Xfile_action_tneg)
+		ElseIf subtype=(cNOT)
+			Char not={0xF7}
+			Char notregopcode={Notregopcode}
+			Set op not
+			Set regopcode notregopcode
+			set xlog (Xfile_action_tnot)
+		ElseIf subtype<=(cSAR1)
+			set op (0xD1)
+			If subtype=(cSHL1)
+				set regopcode 4
+				set xlog (Xfile_action_tshl1)
+			ElseIf subtype=(cSHR1)
+				set regopcode 5
+				set xlog (Xfile_action_tshr1)
+			Else
+			#cSAR1
+				set regopcode 7
+				set xlog (Xfile_action_tsar1)
+			EndElse
+		Else
+		#If subtype==(cEXIT)
+			setcall err argument_return((TRUE),#op,#regprepare_bool,#ptrcontinuation,#sizeofcontinuation,#regopcode)
+			If err!=(noerror)
+				Return err
+			EndIf
+			set xlog (Xfile_action_aexit)
+		EndElse
+		setcall err xfile_add_char_if(xlog)
+		If err!=(noerror);Return err;EndIf
+	Else
+	#push imm prepare test
+		call setimm()
+	EndElse
+
+	Data lowbyte#1
+	Data ptrlowbyte^lowbyte
+	Data dataarg#1
+	Data ptrdataarg^dataarg
+	Data sufix#1
+	Data ptrsufix^sufix
+	data tempdata_mark#1
+
+	set tempdata_mark main.tempdataReg
+	SetCall err arg(ptrcontent,ptrsize,ptrdataarg,ptrlowbyte,ptrsufix,forwardORcallsens,(allow_yes))
+	If err=(noerror)
+		sd imm
+		setcall imm getisimm()
+		if imm=false
+			#Data noreg=noregnumber
+			#Data eaxreg=eaxregnumber
+			#Data intchar#1
+			#Set intchar noreg
+			If forwardORcallsens!=forward
+			#push
+				#If lowbyte==false
+				#since with 64 push data will push quad even without rex
+				#	Char push={0xff}
+				#	Char pushopcode={6}
+				#	Set op push
+				#	Set regopcode pushopcode
+				#	call stack64_op_set()
+				#Else
+				#If lowbyte==true
+				#	#prepare for eax for al
+				#	Set intchar eaxreg
+				#EndIf
+				Char pushaction={moveatprocthemem}
+				Set op pushaction
+				set regopcode (eaxregnumber)
+
+				char pushadvance={0x50}
+				data pushcontinuationsize=1
+				data ptrpushcontinuation^pushadvance
+				Set ptrcontinuation ptrpushcontinuation
+				set sizeofcontinuation pushcontinuationsize
+				#EndElse
+			ElseIf lowbyte=true
+			#imm don't use one byte at the moment
+				if regprepare_bool=false
+					Dec op
+				endif
+			#Else;Set intchar regopcode
+			EndElseIf
+			sd comp_at_bigs;setcall comp_at_bigs comp_one(lowbyte,dataarg,sufix,op)
+			setcall err writeop_promotes(dataarg,op,sufix,regopcode,lowbyte,comp_at_bigs)
+		Else
+		#imm
+			If forwardORcallsens!=forward
+			#push
+				setcall err write_imm(dataarg,(0x68))
+			else
+			#return/exit
+				setcall err write_imm_sign(dataarg,regopcode)
+			endelse
+		EndElse
+		If err=(noerror)
+			If sizeofcontinuation!=zero
+				#return / exit / (only at noimm):incst/push
+				SetCall err addtosec(ptrcontinuation,sizeofcontinuation,codeptr)
+			EndIf
+		EndIf
+	endif
+	set main.tempdataReg tempdata_mark ##in arg can alloc ok, then an error in arg, free here for the second case
+	return err
+endfunction
+
+#same as comp_sec
+function comp_one(sd low,sd dataarg,sd sufix,sd op)
+	if op=(moveatprocthemem)
+		sd p
+		if low=(FALSE)
+			setcall p prefix_bool() #can't touch functions
+			if p#=0
+				sd big;setcall big is_big(dataarg,sufix)
+				if big=(FALSE)
+					sd for64;setcall for64 is_for_64()
+					if for64=(TRUE)
+						#is medium but with sign
+						return 1
+					endif
+				endif
+			endif
+		else
+			sd b;setcall b is_for_64()
+			if b=(TRUE)
+			#return all r64; take all; is from the time when was set that data, waiting outside, can have a char extended with zeros
+				setcall p val64_p_get()
+				set p# (val64_willbe)
+			endif
+			return 2
+		endelse
+	endif
+	return -1
+endfunction
+
+#err
+function argument_init(sv ptrcontent,sd ptrsize,sd subtype)
+	sd err
+	if subtype!=(cRETURN)
+		if subtype!=(cEXIT)
+			#exclude strings at inc,dec,...
+			#can't go with allow_no because, for vars, will not exclude pass init
+			setcall err getarg(ptrcontent,ptrsize,ptrsize#,(allow_later_sec),(FORWARD)) #there are 3 more arguments but are not used
+			return err
+		endif
+	endif
+	setcall err getarg(ptrcontent,ptrsize,ptrsize#,(allow_later),(FORWARD)) #there are 3 more arguments but are not used
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/argument/argument.s
+++ /dev/null
@@ -1,273 +0,0 @@
-
-#sz
-function getreturn(data ptrptrcontinuation)
-	sd b;setcall b scope64_get()
-	if b=(TRUE)
-		sd conv;setcall conv convdata((convdata_total))
-		if conv=(lin_convention)
-			char lin64_return={0xc9,0x5b}
-			#pop c;add rsp,8*conv;push c
-			char *={0x59,REX_Operand_64,0x83,regregmod|espregnumber,lin_convention*qwsz,0x51}
-			char *=retcom
-			set ptrptrcontinuation# #lin64_return
-			return (2+6+1)
-		endif
-	endif
-	Char returncontinuation={0xc9,0x5b,retcom}
-	str ptrreturncontinuation^returncontinuation
-	data sizeretcontinuation=3
-	set ptrptrcontinuation# ptrreturncontinuation
-	return sizeretcontinuation
-endfunction
-#err
-function getexit(sv ptrptrcontinuation,sd psizeofcontinuation)
-	#if to keep rsp can be leave pop sub rsp,:
-
-	#int 0x80, sys_exit, eax 1,ebx the return number
-	char sys_exit={0xb8,1,0,0,0}
-	data exinit^sys_exit
-	data exitsize=5
-	Data codeptr%%ptr_codesec
-	sd err
-	SetCall err addtosec(exinit,exitsize,codeptr)
-	If err!=(noerror)
-		Return err
-	EndIf
-
-	Char unixcontinuation={intimm8,0x80}
-	set ptrptrcontinuation# #unixcontinuation
-	set psizeofcontinuation# 2
-	return (noerror)
-endfunction
-
-#err
-function argument_return(sd termswitch,ss pop,sd pregprepare_bool,sv pptrcontinuation,sd psizeofcontinuation,sd pregopcode)
-	call setimm()
-	Set pop# (moveatprocthemem)
-	Set pregprepare_bool# (TRUE)
-
-	if termswitch=(TRUE)
-		data ebxregnumber=ebxregnumber
-		set pregopcode# ebxregnumber
-		sd err
-		setcall err getexit(pptrcontinuation,psizeofcontinuation)
-		return err
-	endif
-	set pregopcode# (eaxregnumber)
-	setcall psizeofcontinuation# getreturn(pptrcontinuation)
-	return (noerror)
-endfunction
-
-#err
-Function argument(data ptrcontent,data ptrsize,data forwardORcallsens,data subtype)
-	Data false=FALSE
-	Data true=TRUE
-
-	Data regprepare_bool#1
-
-	Char op#1
-	Data zero=0
-
-	Str ptrcontinuation#1
-	Data sizeofcontinuation#1
-
-	vData codeptr%%ptr_codesec
-	Data regopcode#1
-
-	Data err#1
-	Data forward=FORWARD
-
-	Set regprepare_bool false
-	Set sizeofcontinuation zero
-
-	If forwardORcallsens=forward
-		call unsetimm() #set is at returns/and at push
-
-		sd xlog
-		If subtype=(cRETURN)
-			sd termswitch
-			setcall termswitch is_linux_end() #exit from linux term
-			setcall err argument_return(termswitch,#op,#regprepare_bool,#ptrcontinuation,#sizeofcontinuation,#regopcode)
-			If err!=(noerror)
-				Return err
-			EndIf
-			set xlog (Xfile_action_areturn)
-		ElseIf subtype=(cINC)
-			Char inc={0xFF}
-			Set op inc
-			set regopcode 0
-			set xlog (Xfile_action_tinc)
-		ElseIf subtype=(cDEC)
-			Char dec={0xFF}
-			Char decregopcode={1}
-			Set op dec
-			Set regopcode decregopcode
-			set xlog (Xfile_action_tdec)
-		ElseIf subtype<=(cDECST)
-			set op (0x83)
-			if subtype=(cINCST)
-				set regopcode 0
-				set xlog (Xfile_action_tincst)
-			else
-				set regopcode 5
-				set xlog (Xfile_action_tdecst)
-			endelse
-			char incs_sz#1
-			sd b;setcall b is_for_64()
-			if b=(FALSE);set incs_sz (dwsz)
-			else;set incs_sz (qwsz);endelse
-			set ptrcontinuation #incs_sz
-			set sizeofcontinuation (bsz)
-		ElseIf subtype=(cNEG)
-			set op (0xf7)
-			set regopcode 3
-			set xlog (Xfile_action_tneg)
-		ElseIf subtype=(cNOT)
-			Char not={0xF7}
-			Char notregopcode={Notregopcode}
-			Set op not
-			Set regopcode notregopcode
-			set xlog (Xfile_action_tnot)
-		ElseIf subtype<=(cSAR1)
-			set op (0xD1)
-			If subtype=(cSHL1)
-				set regopcode 4
-				set xlog (Xfile_action_tshl1)
-			ElseIf subtype=(cSHR1)
-				set regopcode 5
-				set xlog (Xfile_action_tshr1)
-			Else
-			#cSAR1
-				set regopcode 7
-				set xlog (Xfile_action_tsar1)
-			EndElse
-		Else
-		#If subtype==(cEXIT)
-			setcall err argument_return((TRUE),#op,#regprepare_bool,#ptrcontinuation,#sizeofcontinuation,#regopcode)
-			If err!=(noerror)
-				Return err
-			EndIf
-			set xlog (Xfile_action_aexit)
-		EndElse
-		setcall err xfile_add_char_if(xlog)
-		If err!=(noerror);Return err;EndIf
-	Else
-	#push imm prepare test
-		call setimm()
-	EndElse
-
-	Data lowbyte#1
-	Data ptrlowbyte^lowbyte
-	Data dataarg#1
-	Data ptrdataarg^dataarg
-	Data sufix#1
-	Data ptrsufix^sufix
-	data tempdata_mark#1
-
-	set tempdata_mark main.tempdataReg
-	SetCall err arg(ptrcontent,ptrsize,ptrdataarg,ptrlowbyte,ptrsufix,forwardORcallsens,(allow_yes))
-	If err=(noerror)
-		sd imm
-		setcall imm getisimm()
-		if imm=false
-			#Data noreg=noregnumber
-			#Data eaxreg=eaxregnumber
-			#Data intchar#1
-			#Set intchar noreg
-			If forwardORcallsens!=forward
-			#push
-				#If lowbyte==false
-				#since with 64 push data will push quad even without rex
-				#	Char push={0xff}
-				#	Char pushopcode={6}
-				#	Set op push
-				#	Set regopcode pushopcode
-				#	call stack64_op_set()
-				#Else
-				#If lowbyte==true
-				#	#prepare for eax for al
-				#	Set intchar eaxreg
-				#EndIf
-				Char pushaction={moveatprocthemem}
-				Set op pushaction
-				set regopcode (eaxregnumber)
-
-				char pushadvance={0x50}
-				data pushcontinuationsize=1
-				data ptrpushcontinuation^pushadvance
-				Set ptrcontinuation ptrpushcontinuation
-				set sizeofcontinuation pushcontinuationsize
-				#EndElse
-			ElseIf lowbyte=true
-			#imm don't use one byte at the moment
-				if regprepare_bool=false
-					Dec op
-				endif
-			#Else;Set intchar regopcode
-			EndElseIf
-			sd comp_at_bigs;setcall comp_at_bigs comp_one(lowbyte,dataarg,sufix,op)
-			setcall err writeop_promotes(dataarg,op,sufix,regopcode,lowbyte,comp_at_bigs)
-		Else
-		#imm
-			If forwardORcallsens!=forward
-			#push
-				setcall err write_imm(dataarg,(0x68))
-			else
-			#return/exit
-				setcall err write_imm_sign(dataarg,regopcode)
-			endelse
-		EndElse
-		If err=(noerror)
-			If sizeofcontinuation!=zero
-				#return / exit / (only at noimm):incst/push
-				SetCall err addtosec(ptrcontinuation,sizeofcontinuation,codeptr)
-			EndIf
-		EndIf
-	endif
-	set main.tempdataReg tempdata_mark ##in arg can alloc ok, then an error in arg, free here for the second case
-	return err
-endfunction
-
-#same as comp_sec
-function comp_one(sd low,sd dataarg,sd sufix,sd op)
-	if op=(moveatprocthemem)
-		sd p
-		if low=(FALSE)
-			setcall p prefix_bool() #can't touch functions
-			if p#=0
-				sd big;setcall big is_big(dataarg,sufix)
-				if big=(FALSE)
-					sd for64;setcall for64 is_for_64()
-					if for64=(TRUE)
-						#is medium but with sign
-						return 1
-					endif
-				endif
-			endif
-		else
-			sd b;setcall b is_for_64()
-			if b=(TRUE)
-			#return all r64; take all; is from the time when was set that data, waiting outside, can have a char extended with zeros
-				setcall p val64_p_get()
-				set p# (val64_willbe)
-			endif
-			return 2
-		endelse
-	endif
-	return -1
-endfunction
-
-#err
-function argument_init(sv ptrcontent,sd ptrsize,sd subtype)
-	sd err
-	if subtype!=(cRETURN)
-		if subtype!=(cEXIT)
-			#exclude strings at inc,dec,...
-			#can't go with allow_no because, for vars, will not exclude pass init
-			setcall err getarg(ptrcontent,ptrsize,ptrsize#,(allow_later_sec),(FORWARD)) #there are 3 more arguments but are not used
-			return err
-		endif
-	endif
-	setcall err getarg(ptrcontent,ptrsize,ptrsize#,(allow_later),(FORWARD)) #there are 3 more arguments but are not used
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/argument/comwrite.oc
@@ -0,0 +1,361 @@
+
+Function rol(data number,data times)
+	Data nr#1
+	Data i#1
+	Data zero=0
+	Data two=2
+
+	Set nr number
+	Set i zero
+	While i<times
+		Mult nr two
+		Inc i
+	EndWhile
+	Return nr
+EndFunction
+#modrm
+Function formmodrm(data mod,data regopcode,data rm)
+	Data toregopcode=3
+	Data tomod=3
+	Data initialbitshift=1
+	Data bitshift#1
+
+	Data modrm#1
+	Data store#1
+
+	Set bitshift initialbitshift
+
+	Set modrm rm
+
+	SetCall bitshift rol(bitshift,toregopcode)
+	Set store bitshift
+	Mult store regopcode
+	Or modrm store
+
+	SetCall bitshift rol(bitshift,tomod)
+	Set store bitshift
+	Mult store mod
+	Or modrm store
+
+	Return modrm
+EndFunction
+
+function takewithimm(sd ind,sd addr)
+	Char takeop#1
+	Data takeloc#1
+
+	Set takeop (0xb8)
+	Add takeop ind
+	set takeloc addr
+
+	Data ptrcodesec%%ptr_codesec
+	Data sz1=bsz+dwsz
+
+	sd err
+	SetCall err addtosec(#takeop,sz1,ptrcodesec)
+	return err
+endfunction
+#er
+function datatake_reloc(sd takeindex,sd take_loc)
+	data p_is_object%ptrobject
+	if p_is_object#=(TRUE)
+		sd relocoff
+		setcall relocoff reloc64_offset(1)
+		sd errnr
+		setcall errnr adddirectrel_base_inplace(relocoff,#take_loc,(dataind))
+		If errnr!=(noerror)
+			Return errnr
+		EndIf
+	endif
+	setcall errnr datatake(takeindex,take_loc)
+	return errnr
+endfunction
+#er
+function datatake(sd takeindex,sd take_loc)
+	sd errnr
+	setcall errnr reloc64_ante();If errnr!=(noerror);Return errnr;EndIf
+	setcall errnr takewithimm(takeindex,take_loc);If errnr!=(noerror);Return errnr;EndIf
+	setcall errnr reloc64_post()
+	return errnr
+endfunction
+#err
+function adddirectrel_base_inplace(sd relocoff,sd p_take_loc,sd sectionind)
+	Data ptrextra%%ptr_extra
+	sd errnr
+	SetCall errnr adddirectrel_base(ptrextra,relocoff,sectionind,p_take_loc#)
+	If errnr=(noerror)
+		call inplace_reloc(p_take_loc)
+	EndIf
+	Return errnr
+endfunction
+#er
+function writetake(sd takeindex,sd entry)
+	Data errnr#1
+	sd take_loc;set take_loc entry#
+	sd stack
+	setcall stack stackbit(entry)
+	if stack=0
+		data p_is_object%ptrobject
+		if p_is_object#=(TRUE)
+			Data ptrextra%%ptr_extra
+			data relocoff#1
+			setcall relocoff reloc64_offset(1)
+			sd var
+			setcall var function_in_code()
+			if var#=0
+				sd sectionind
+				sd expand;setcall expand expandbit_wrap(entry)
+				if expand!=0
+					#before expandbit at class: this test is already at var declaration
+					set sectionind (dtnbind)
+				else
+					set sectionind (dataind)
+				endelse
+				setcall errnr adddirectrel_base_inplace(relocoff,#take_loc,sectionind)
+				If errnr!=(noerror)
+					Return errnr
+				EndIf
+			else
+				#function in code, not sd^local, sd^imp
+				#function in code is only at objects at the moment, is set only once at arg.oc
+				#var# 0? is static bool
+				set var# 0
+				sd impbit
+				setcall impbit importbit(entry)
+				setcall take_loc get_function_value(impbit,entry)
+				sd index
+				setcall index get_function_values(impbit,#take_loc,entry)
+				SetCall errnr adddirectrel_base(ptrextra,relocoff,index,take_loc)
+				If errnr!=(noerror)
+					Return errnr
+				EndIf
+				if impbit=0
+					setcall errnr unresReloc(ptrextra)
+					If errnr!=(noerror);Return errnr;EndIf
+					setcall errnr inplace_reloc_unres(#take_loc,relocoff)
+					If errnr!=(noerror);Return errnr;EndIf
+				endif
+			endelse
+		endif
+		setcall errnr datatake(takeindex,take_loc)
+	else
+		char stack_relative#1
+		char regreg=RegReg
+		setcall stack_relative stack_get_relative(entry)
+		char getfromstack={0x03}
+		char getfromstack_modrm#1
+		SetCall getfromstack_modrm formmodrm(regreg,takeindex,stack_relative)
+		data ptrgetfromstack^getfromstack
+		data sizegetfromstack=2
+		if take_loc!=0
+			setcall errnr takewithimm(takeindex,take_loc);If errnr!=(noerror);Return errnr;EndIf
+			set getfromstack 0x03
+		else;set getfromstack (moveatprocthemem);endelse
+		setcall errnr rex_w_if64();if errnr!=(noerror);return errnr;endif
+		Data ptrcodesec%%ptr_codesec
+		SetCall errnr addtosec(ptrgetfromstack,sizegetfromstack,ptrcodesec)
+	endelse
+	Return errnr
+endfunction
+#er
+function writetake_offset(sd takeindex,sd entry)
+	sd er;setcall er writetake(takeindex,entry)
+	if er=(noerror)
+		sd test;setcall test suffixbit(entry)
+		if test!=0
+			char op#1
+			char modrm#1
+			data disp32#1
+			add entry (addoffset)
+			set disp32 entry#
+			if disp32<0
+				#is only sign-extended imm32 to r64
+				return "The displacement for this value is not implemented at the moment."
+			endif
+			setcall er rex_w_if64()
+			if er=(noerror)
+				#need to take further
+				char take=moveatprocthemem
+				char tmodrm#1
+				setcall tmodrm formmodrm((mod_0),takeindex,takeindex)
+				value ptrcodesec%%ptr_codesec
+				SetCall er addtosec(#take,2,ptrcodesec)
+				if er=(noerror)
+					setcall er rex_w_if64()
+					if er=(noerror)
+						setcall modrm formmodrm((RegReg),0,takeindex)
+						sd sz
+						if disp32<0x80
+							set op (0x83)
+							set sz 3
+						else
+							set op (0x81)
+							set sz 6
+						endelse
+						SetCall er addtosec(#op,sz,ptrcodesec)
+					endif
+				endif
+			endif
+		endif
+	endif
+	return er
+endfunction
+
+#val64. is one call at this that will break val64 if not a return value
+Function writeoperation_take(sd p_errnr,sd location,sd sufix,sd takeindex,sd is_low)
+#last parameter is optional
+	Data errnr#1
+	Data noerr=noerror
+
+	setcall errnr writetake_offset(takeindex,location)
+	If errnr!=noerr
+		set p_errnr# errnr;ret
+	EndIf
+
+	sd v_64
+	sd prefix
+	setcall v_64 sufix64(location)
+	If sufix=(sufix_true)
+		sd take64;set take64 v_64
+		if v_64=(val64_willbe)
+			if is_low=(TRUE)
+			#not ss, rex.w op r/m8 is ok but is useless
+				set v_64 (val64_no)
+			else
+				sd pbit;setcall pbit pointbit(location)
+				if pbit=0
+					#not needed at sd#
+					setcall prefix prefix_bool()
+					if prefix#=0
+					#but keep at prefix, this is a #a# case,the logic is fragile
+						set v_64 (val64_no)
+					endif
+				endif
+			endelse
+		endif
+		setcall p_errnr# sufix_take(takeindex,take64)
+	Else
+		sd for_64;setcall for_64 is_for_64()
+		if for_64=(TRUE)
+			setcall prefix prefix_bool()
+			if prefix#!=0
+			#set here (example: return #data), this can be thinked to be wrote at writeoperation_op
+				set v_64 (val64_willbe)
+			endif
+		endif
+		set p_errnr# (noerror)
+	EndElse
+	Return v_64
+EndFunction
+#er
+function sufix_take(sd takeindex,sd take64)
+	sd err
+	if take64=(val64_willbe)
+		call rex_w(#err)
+		if err!=(noerror)
+			return err;endif
+	endif
+	Data ptrcodesec%%ptr_codesec
+	Char newtake=moveatprocthemem
+	Char newtakemodrm#1
+	Str ptrnewtake^newtake
+	Data sz2=bsz+bsz
+	setcall newtakemodrm formmodrm((mod_0),takeindex,takeindex)
+	SetCall err addtosec(ptrnewtake,sz2,ptrcodesec)
+	return err
+endfunction
+#v64
+function sufix64(sd location)
+	sd bittest;setcall bittest bigbits(location)
+	if bittest!=0
+		sd for_64;setcall for_64 is_for_64()
+		return for_64
+		#p test
+		#if for_64==(TRUE)
+		#	return (val64_willbe)
+		#	#rex if p
+		#endif
+		#take on takeindex
+	endif
+	return (val64_no)
+endfunction
+
+#er
+Function writeoperation_op(sd operationopcode,sd is_prepare,sd regopcode,sd takeindex)
+	Data ptrcodesec%%ptr_codesec
+	Data errnr#1
+	Data noerr=noerror
+	Data sz2=bsz+bsz
+
+	sd v64;setcall v64 val64_p_get()
+	if v64#=(val64_willbe)
+		call rex_w(#errnr);if errnr!=(noerror);return errnr;endif
+		set v64# (val64_no)
+	endif
+
+	sd mod=mod_0
+
+	#if is like was xor prepare,prepare
+	If is_prepare=(TRUE)
+	# !=(noregnumber)
+		#Char comprepare1={0x33}
+		#Char comprepare2#1
+		#setcall comprepare2 formmodrm((RegReg),regprepare,regprepare)
+		#SetCall errnr addtosec(#comprepare1,sz2,ptrcodesec)
+
+		#zero extend
+		char extend_byte=twobytesinstruction_byte1
+		SetCall errnr addtosec(#extend_byte,1,ptrcodesec)
+		If errnr!=noerr
+			Return errnr
+		EndIf
+	Else
+		#at calls there is no low
+		#there is no prefix at low, and no val64
+		sd prefix
+		setcall prefix prefix_bool()
+		If prefix#!=0
+			set mod (RegReg)
+			set prefix# 0
+		endIf
+		#Else
+		#	#this will reset calls and set v64
+		#	Call stack64_op()
+		#endElse
+	EndElse
+
+	Char actionop#1
+	Char actionmodrm#1
+
+	Set actionop operationopcode
+	SetCall actionmodrm formmodrm(mod,regopcode,takeindex)
+	SetCall errnr addtosec(#actionop,sz2,ptrcodesec)
+	Return errnr
+Endfunction
+#er
+Function writeoperation(sd location,sd operationopcode,sd sufix,sd regopcode,sd takeindex,sd is_low)
+	sd err;sd v_64
+	setcall v_64 writeoperation_take(#err,location,sufix,takeindex,is_low)
+	if err!=(noerror);return err;endif
+	sd v64;setcall v64 val64_p_get();set v64# v_64
+	setcall err writeoperation_op(operationopcode,(FALSE),regopcode,takeindex)
+	return err
+Endfunction
+
+#er
+Function writeop(sd location,sd operationopcode,sd sufix,sd regopcode,sd is_low)
+	Data err#1
+	Data edxregnumber=edxregnumber
+	SetCall err writeoperation(location,operationopcode,sufix,regopcode,edxregnumber,is_low)
+	Return err
+EndFunction
+
+#er
+function writeopera(sd location,sd operationopcode,sd regopcode,sd takeindex)
+	sd err
+	setcall err writetake(takeindex,location)
+	if err=(noerror)
+		setcall err writeoperation_op(operationopcode,(FALSE),regopcode,takeindex)
+	endif
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/argument/comwrite.s
+++ /dev/null
@@ -1,361 +0,0 @@
-
-Function rol(data number,data times)
-	Data nr#1
-	Data i#1
-	Data zero=0
-	Data two=2
-
-	Set nr number
-	Set i zero
-	While i<times
-		Mult nr two
-		Inc i
-	EndWhile
-	Return nr
-EndFunction
-#modrm
-Function formmodrm(data mod,data regopcode,data rm)
-	Data toregopcode=3
-	Data tomod=3
-	Data initialbitshift=1
-	Data bitshift#1
-
-	Data modrm#1
-	Data store#1
-
-	Set bitshift initialbitshift
-
-	Set modrm rm
-
-	SetCall bitshift rol(bitshift,toregopcode)
-	Set store bitshift
-	Mult store regopcode
-	Or modrm store
-
-	SetCall bitshift rol(bitshift,tomod)
-	Set store bitshift
-	Mult store mod
-	Or modrm store
-
-	Return modrm
-EndFunction
-
-function takewithimm(sd ind,sd addr)
-	Char takeop#1
-	Data takeloc#1
-
-	Set takeop (0xb8)
-	Add takeop ind
-	set takeloc addr
-
-	Data ptrcodesec%%ptr_codesec
-	Data sz1=bsz+dwsz
-
-	sd err
-	SetCall err addtosec(#takeop,sz1,ptrcodesec)
-	return err
-endfunction
-#er
-function datatake_reloc(sd takeindex,sd take_loc)
-	data p_is_object%ptrobject
-	if p_is_object#=(TRUE)
-		sd relocoff
-		setcall relocoff reloc64_offset(1)
-		sd errnr
-		setcall errnr adddirectrel_base_inplace(relocoff,#take_loc,(dataind))
-		If errnr!=(noerror)
-			Return errnr
-		EndIf
-	endif
-	setcall errnr datatake(takeindex,take_loc)
-	return errnr
-endfunction
-#er
-function datatake(sd takeindex,sd take_loc)
-	sd errnr
-	setcall errnr reloc64_ante();If errnr!=(noerror);Return errnr;EndIf
-	setcall errnr takewithimm(takeindex,take_loc);If errnr!=(noerror);Return errnr;EndIf
-	setcall errnr reloc64_post()
-	return errnr
-endfunction
-#err
-function adddirectrel_base_inplace(sd relocoff,sd p_take_loc,sd sectionind)
-	Data ptrextra%%ptr_extra
-	sd errnr
-	SetCall errnr adddirectrel_base(ptrextra,relocoff,sectionind,p_take_loc#)
-	If errnr=(noerror)
-		call inplace_reloc(p_take_loc)
-	EndIf
-	Return errnr
-endfunction
-#er
-function writetake(sd takeindex,sd entry)
-	Data errnr#1
-	sd take_loc;set take_loc entry#
-	sd stack
-	setcall stack stackbit(entry)
-	if stack=0
-		data p_is_object%ptrobject
-		if p_is_object#=(TRUE)
-			Data ptrextra%%ptr_extra
-			data relocoff#1
-			setcall relocoff reloc64_offset(1)
-			sd var
-			setcall var function_in_code()
-			if var#=0
-				sd sectionind
-				sd expand;setcall expand expandbit_wrap(entry)
-				if expand!=0
-					#before expandbit at class: this test is already at var declaration
-					set sectionind (dtnbind)
-				else
-					set sectionind (dataind)
-				endelse
-				setcall errnr adddirectrel_base_inplace(relocoff,#take_loc,sectionind)
-				If errnr!=(noerror)
-					Return errnr
-				EndIf
-			else
-				#function in code, not sd^local, sd^imp
-				#function in code is only at objects at the moment, is set only once at arg.s
-				#var# 0? is static bool
-				set var# 0
-				sd impbit
-				setcall impbit importbit(entry)
-				setcall take_loc get_function_value(impbit,entry)
-				sd index
-				setcall index get_function_values(impbit,#take_loc,entry)
-				SetCall errnr adddirectrel_base(ptrextra,relocoff,index,take_loc)
-				If errnr!=(noerror)
-					Return errnr
-				EndIf
-				if impbit=0
-					setcall errnr unresReloc(ptrextra)
-					If errnr!=(noerror);Return errnr;EndIf
-					setcall errnr inplace_reloc_unres(#take_loc,relocoff)
-					If errnr!=(noerror);Return errnr;EndIf
-				endif
-			endelse
-		endif
-		setcall errnr datatake(takeindex,take_loc)
-	else
-		char stack_relative#1
-		char regreg=RegReg
-		setcall stack_relative stack_get_relative(entry)
-		char getfromstack={0x03}
-		char getfromstack_modrm#1
-		SetCall getfromstack_modrm formmodrm(regreg,takeindex,stack_relative)
-		data ptrgetfromstack^getfromstack
-		data sizegetfromstack=2
-		if take_loc!=0
-			setcall errnr takewithimm(takeindex,take_loc);If errnr!=(noerror);Return errnr;EndIf
-			set getfromstack 0x03
-		else;set getfromstack (moveatprocthemem);endelse
-		setcall errnr rex_w_if64();if errnr!=(noerror);return errnr;endif
-		Data ptrcodesec%%ptr_codesec
-		SetCall errnr addtosec(ptrgetfromstack,sizegetfromstack,ptrcodesec)
-	endelse
-	Return errnr
-endfunction
-#er
-function writetake_offset(sd takeindex,sd entry)
-	sd er;setcall er writetake(takeindex,entry)
-	if er=(noerror)
-		sd test;setcall test suffixbit(entry)
-		if test!=0
-			char op#1
-			char modrm#1
-			data disp32#1
-			add entry (addoffset)
-			set disp32 entry#
-			if disp32<0
-				#is only sign-extended imm32 to r64
-				return "The displacement for this value is not implemented at the moment."
-			endif
-			setcall er rex_w_if64()
-			if er=(noerror)
-				#need to take further
-				char take=moveatprocthemem
-				char tmodrm#1
-				setcall tmodrm formmodrm((mod_0),takeindex,takeindex)
-				value ptrcodesec%%ptr_codesec
-				SetCall er addtosec(#take,2,ptrcodesec)
-				if er=(noerror)
-					setcall er rex_w_if64()
-					if er=(noerror)
-						setcall modrm formmodrm((RegReg),0,takeindex)
-						sd sz
-						if disp32<0x80
-							set op (0x83)
-							set sz 3
-						else
-							set op (0x81)
-							set sz 6
-						endelse
-						SetCall er addtosec(#op,sz,ptrcodesec)
-					endif
-				endif
-			endif
-		endif
-	endif
-	return er
-endfunction
-
-#val64. is one call at this that will break val64 if not a return value
-Function writeoperation_take(sd p_errnr,sd location,sd sufix,sd takeindex,sd is_low)
-#last parameter is optional
-	Data errnr#1
-	Data noerr=noerror
-
-	setcall errnr writetake_offset(takeindex,location)
-	If errnr!=noerr
-		set p_errnr# errnr;ret
-	EndIf
-
-	sd v_64
-	sd prefix
-	setcall v_64 sufix64(location)
-	If sufix=(sufix_true)
-		sd take64;set take64 v_64
-		if v_64=(val64_willbe)
-			if is_low=(TRUE)
-			#not ss, rex.w op r/m8 is ok but is useless
-				set v_64 (val64_no)
-			else
-				sd pbit;setcall pbit pointbit(location)
-				if pbit=0
-					#not needed at sd#
-					setcall prefix prefix_bool()
-					if prefix#=0
-					#but keep at prefix, this is a #a# case,the logic is fragile
-						set v_64 (val64_no)
-					endif
-				endif
-			endelse
-		endif
-		setcall p_errnr# sufix_take(takeindex,take64)
-	Else
-		sd for_64;setcall for_64 is_for_64()
-		if for_64=(TRUE)
-			setcall prefix prefix_bool()
-			if prefix#!=0
-			#set here (example: return #data), this can be thinked to be wrote at writeoperation_op
-				set v_64 (val64_willbe)
-			endif
-		endif
-		set p_errnr# (noerror)
-	EndElse
-	Return v_64
-EndFunction
-#er
-function sufix_take(sd takeindex,sd take64)
-	sd err
-	if take64=(val64_willbe)
-		call rex_w(#err)
-		if err!=(noerror)
-			return err;endif
-	endif
-	Data ptrcodesec%%ptr_codesec
-	Char newtake=moveatprocthemem
-	Char newtakemodrm#1
-	Str ptrnewtake^newtake
-	Data sz2=bsz+bsz
-	setcall newtakemodrm formmodrm((mod_0),takeindex,takeindex)
-	SetCall err addtosec(ptrnewtake,sz2,ptrcodesec)
-	return err
-endfunction
-#v64
-function sufix64(sd location)
-	sd bittest;setcall bittest bigbits(location)
-	if bittest!=0
-		sd for_64;setcall for_64 is_for_64()
-		return for_64
-		#p test
-		#if for_64==(TRUE)
-		#	return (val64_willbe)
-		#	#rex if p
-		#endif
-		#take on takeindex
-	endif
-	return (val64_no)
-endfunction
-
-#er
-Function writeoperation_op(sd operationopcode,sd is_prepare,sd regopcode,sd takeindex)
-	Data ptrcodesec%%ptr_codesec
-	Data errnr#1
-	Data noerr=noerror
-	Data sz2=bsz+bsz
-
-	sd v64;setcall v64 val64_p_get()
-	if v64#=(val64_willbe)
-		call rex_w(#errnr);if errnr!=(noerror);return errnr;endif
-		set v64# (val64_no)
-	endif
-
-	sd mod=mod_0
-
-	#if is like was xor prepare,prepare
-	If is_prepare=(TRUE)
-	# !=(noregnumber)
-		#Char comprepare1={0x33}
-		#Char comprepare2#1
-		#setcall comprepare2 formmodrm((RegReg),regprepare,regprepare)
-		#SetCall errnr addtosec(#comprepare1,sz2,ptrcodesec)
-
-		#zero extend
-		char extend_byte=twobytesinstruction_byte1
-		SetCall errnr addtosec(#extend_byte,1,ptrcodesec)
-		If errnr!=noerr
-			Return errnr
-		EndIf
-	Else
-		#at calls there is no low
-		#there is no prefix at low, and no val64
-		sd prefix
-		setcall prefix prefix_bool()
-		If prefix#!=0
-			set mod (RegReg)
-			set prefix# 0
-		endIf
-		#Else
-		#	#this will reset calls and set v64
-		#	Call stack64_op()
-		#endElse
-	EndElse
-
-	Char actionop#1
-	Char actionmodrm#1
-
-	Set actionop operationopcode
-	SetCall actionmodrm formmodrm(mod,regopcode,takeindex)
-	SetCall errnr addtosec(#actionop,sz2,ptrcodesec)
-	Return errnr
-Endfunction
-#er
-Function writeoperation(sd location,sd operationopcode,sd sufix,sd regopcode,sd takeindex,sd is_low)
-	sd err;sd v_64
-	setcall v_64 writeoperation_take(#err,location,sufix,takeindex,is_low)
-	if err!=(noerror);return err;endif
-	sd v64;setcall v64 val64_p_get();set v64# v_64
-	setcall err writeoperation_op(operationopcode,(FALSE),regopcode,takeindex)
-	return err
-Endfunction
-
-#er
-Function writeop(sd location,sd operationopcode,sd sufix,sd regopcode,sd is_low)
-	Data err#1
-	Data edxregnumber=edxregnumber
-	SetCall err writeoperation(location,operationopcode,sufix,regopcode,edxregnumber,is_low)
-	Return err
-EndFunction
-
-#er
-function writeopera(sd location,sd operationopcode,sd regopcode,sd takeindex)
-	sd err
-	setcall err writetake(takeindex,location)
-	if err=(noerror)
-		setcall err writeoperation_op(operationopcode,(FALSE),regopcode,takeindex)
-	endif
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/argument/imm.oc
@@ -0,0 +1,120 @@
+
+function setimm()
+	data canhaveimm#1
+	const immpointer^canhaveimm
+	data true=1
+	set canhaveimm true
+endfunction
+function unsetimm()
+	data ptratimm%immpointer
+	data false=0
+	set ptratimm# false
+endfunction
+function getimm()
+	data ptratimm%immpointer
+	return ptratimm#
+endfunction
+
+
+function setisimm()
+	data isimm#1
+	const ptr_isimm^isimm
+	data true=1
+	set isimm true
+endfunction
+function resetisimm()
+	data ptr%ptr_isimm
+	data false=0
+	set ptr# false
+endfunction
+function getisimm()
+	data ptr%ptr_isimm
+	return ptr#
+endfunction
+
+
+function storefirst_isimm()
+	data firstimm#1
+	const ptr_first_isimm^firstimm
+	data ptr%ptr_isimm
+	set firstimm ptr#
+endfunction
+function restorefirst_isimm()
+	data first%ptr_first_isimm
+	data ptr%ptr_isimm
+	set ptr# first#
+endfunction
+function getfirst_isimm()
+	data first%ptr_first_isimm
+	return first#
+endfunction
+
+function switchimm()
+	data ptr%ptr_isimm
+	data true=1
+	#first was false was low at comparations low vs high
+	if ptr#=true
+		data first%ptr_first_isimm
+		set first# true
+		data false=0
+		set ptr# false
+	endif
+endfunction
+
+
+#er
+function write_imm(sd dataarg,sd op)
+	char immop#1
+	data value#1
+	data immadd^immop
+	set immop op
+	set value dataarg
+	data sz=5
+	data code%%ptr_codesec
+	sd err
+	setcall err addtosec(immadd,sz,code)
+	call resetisimm()
+	return err
+endfunction
+#er
+function write_imm_sign(sd dataarg,sd regopcode)
+	vData codeptr%%ptr_codesec
+	sd err
+	setcall err rex_w_if64()
+	if err=(noerror)
+		char movs_imm=mov_imm_to_rm
+		SetCall err addtosec(#movs_imm,1,codeptr)
+		if err=(noerror)
+			sd op
+			SetCall op formmodrm((RegReg),0,regopcode)
+			setcall err write_imm(dataarg,op)
+		endif
+	endif
+	return err
+endfunction
+#err
+function write_imm_trunc(sd value,sd reg,sd low,sd data,sd sufix)
+	sd err
+	if low=(FALSE)
+		sd bool;setcall bool is_big_imm(data,sufix)
+		if bool=(FALSE)
+			#mediu
+			add reg (ateaximm)
+			setcall err write_imm(value,reg)
+			return err
+		endif
+		#big
+		setcall err write_imm_sign(value,reg)  #there is one if64 useless inside
+		return err
+	endif
+	#low
+	char a#2
+	ss b^a;set b# (atalimm)
+	add b# reg
+	inc b
+	set b# value
+	dec b
+	vData codeptr%%ptr_codesec
+	setcall err addtosec(b,2,codeptr)
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/argument/imm.s
+++ /dev/null
@@ -1,120 +0,0 @@
-
-function setimm()
-	data canhaveimm#1
-	const immpointer^canhaveimm
-	data true=1
-	set canhaveimm true
-endfunction
-function unsetimm()
-	data ptratimm%immpointer
-	data false=0
-	set ptratimm# false
-endfunction
-function getimm()
-	data ptratimm%immpointer
-	return ptratimm#
-endfunction
-
-
-function setisimm()
-	data isimm#1
-	const ptr_isimm^isimm
-	data true=1
-	set isimm true
-endfunction
-function resetisimm()
-	data ptr%ptr_isimm
-	data false=0
-	set ptr# false
-endfunction
-function getisimm()
-	data ptr%ptr_isimm
-	return ptr#
-endfunction
-
-
-function storefirst_isimm()
-	data firstimm#1
-	const ptr_first_isimm^firstimm
-	data ptr%ptr_isimm
-	set firstimm ptr#
-endfunction
-function restorefirst_isimm()
-	data first%ptr_first_isimm
-	data ptr%ptr_isimm
-	set ptr# first#
-endfunction
-function getfirst_isimm()
-	data first%ptr_first_isimm
-	return first#
-endfunction
-
-function switchimm()
-	data ptr%ptr_isimm
-	data true=1
-	#first was false was low at comparations low vs high
-	if ptr#=true
-		data first%ptr_first_isimm
-		set first# true
-		data false=0
-		set ptr# false
-	endif
-endfunction
-
-
-#er
-function write_imm(sd dataarg,sd op)
-	char immop#1
-	data value#1
-	data immadd^immop
-	set immop op
-	set value dataarg
-	data sz=5
-	data code%%ptr_codesec
-	sd err
-	setcall err addtosec(immadd,sz,code)
-	call resetisimm()
-	return err
-endfunction
-#er
-function write_imm_sign(sd dataarg,sd regopcode)
-	vData codeptr%%ptr_codesec
-	sd err
-	setcall err rex_w_if64()
-	if err=(noerror)
-		char movs_imm=mov_imm_to_rm
-		SetCall err addtosec(#movs_imm,1,codeptr)
-		if err=(noerror)
-			sd op
-			SetCall op formmodrm((RegReg),0,regopcode)
-			setcall err write_imm(dataarg,op)
-		endif
-	endif
-	return err
-endfunction
-#err
-function write_imm_trunc(sd value,sd reg,sd low,sd data,sd sufix)
-	sd err
-	if low=(FALSE)
-		sd bool;setcall bool is_big_imm(data,sufix)
-		if bool=(FALSE)
-			#mediu
-			add reg (ateaximm)
-			setcall err write_imm(value,reg)
-			return err
-		endif
-		#big
-		setcall err write_imm_sign(value,reg)  #there is one if64 useless inside
-		return err
-	endif
-	#low
-	char a#2
-	ss b^a;set b# (atalimm)
-	add b# reg
-	inc b
-	set b# value
-	dec b
-	vData codeptr%%ptr_codesec
-	setcall err addtosec(b,2,codeptr)
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/commands/cond.oc
@@ -0,0 +1,404 @@
+
+#err
+Function coderegtocondloop()
+	Data codesec%%ptr_codesec
+	Data codeReg#1
+	Data ptrcodeReg^codeReg
+
+	Call getcontReg(codesec,ptrcodeReg)
+
+	Data err#1
+	Data condloopsec%%ptr_conditionsloops
+	Data dsz=dwsz
+
+	SetCall err addtosec(ptrcodeReg,dsz,condloopsec)
+	Return err
+EndFunction
+
+#err
+Function condbeginwrite(data condnumber)
+	Data err#1
+	Data noerr=noerror
+
+	SetCall err coderegtocondloop()
+	If err!=noerr
+		Return err
+	EndIf
+
+	Data condloopsec%%ptr_conditionsloops
+	Data dsz=dwsz
+
+	Data ptrcondnumber^condnumber
+	SetCall err addtosec(ptrcondnumber,dsz,condloopsec)
+	Return err
+EndFunction
+
+#err
+Function condbegin(data ptrcontent,data ptrsize,data condnumber)
+	Data cond#1
+	Data ptrcond^cond
+	Data err#1
+	Data noerr=noerror
+
+	if main.parses=(pass_write)
+		setcall err xfile_add_char_if(condnumber)
+		If err!=noerr;Return err;EndIf
+		SetCall err twoargs(ptrcontent,ptrsize,(not_a_subtype),ptrcond)
+		If err!=noerr;Return err;EndIf
+	else
+		call advancecursors(ptrcontent,ptrsize,ptrsize#)
+	endelse
+	SetCall err condbeginwrite(condnumber)
+	Return err
+EndFunction
+
+#err
+Function checkcondloopclose()
+	Data regnr#1
+	Data ptrregnr^regnr
+	Data condloop%%ptr_conditionsloops
+	Call getcontReg(condloop,ptrregnr)
+	Data zero=0
+	If regnr!=zero
+		Char closeerr="All conditions/loops within a scope most be closed."
+		Str _closeerr^closeerr
+		Return _closeerr
+	EndIf
+	Data noerr=noerror
+	Return noerr
+EndFunction
+
+Const backjumpsize=5
+#err
+Function condjump(data size)
+	Char jump={0xe9}
+	Data jsize#1
+	Data bjsz=backjumpsize
+
+	Data pjsize^jsize
+
+	Set pjsize# size
+
+	Data pjump^jump
+
+	Data err#1
+	Data code%%ptr_codesec
+	SetCall err addtosec(pjump,bjsz,code)
+	Return err
+EndFunction
+
+#err
+Function condend(data number)
+	Data condloop%%ptr_conditionsloops
+	Data ptrcReg#1
+	Data ptrptrcReg^ptrcReg
+
+	Call getptrcontReg(condloop,ptrptrcReg)
+	If ptrcReg#=0
+		Char uncloseerr="Unexpected condition/loop close command."
+		Str _uncloseerr^uncloseerr
+		Return _uncloseerr
+	EndIf
+
+	Data codeoffset#1
+	Data ptrcodeoff^codeoffset
+	Data codesec%%ptr_codesec
+	Data whilenr=whilenumber
+	Data structure#1
+	Data ptrstructure^structure
+
+	Call getcontReg(codesec,ptrcodeoff)
+	If number=whilenr
+		Add codeoffset (backjumpsize)
+	EndIf
+	Call getcont(condloop,ptrstructure)
+	Add structure ptrcReg#
+	sd reg;set reg structure
+
+	sd err;setcall err condendtest(#structure,number,codeoffset)
+	if err=(noerror)
+		If number=whilenr
+			if main.parses=(pass_write)
+				setcall err jumpback(codeoffset,structure)
+				If err!=(noerror)
+					Return err
+				EndIf
+			endif
+			add reg (dwsz)   #to match for ptrcReg
+		EndIf
+
+		if main.parses=(pass_write)
+			call condendwrite(structure,codeoffset)
+		endif
+
+		sub reg structure
+		Sub ptrcReg# reg
+	endif
+	return err
+EndFunction
+
+#err
+function condendtest(sv p_conds,sd number,sd codeoffset)
+	sd conds;set conds p_conds#
+
+	#for breaks inside conditions
+	sd last;set last conds
+
+	while 1=1
+		Data lastcondition#1
+
+		sub conds (dwsz)
+		Set lastcondition conds#
+		sub conds (dwsz)
+
+		if lastcondition=(breaknumber)
+			if number=(whilenumber)
+				call condendwrite(conds,codeoffset)
+			endif
+		elseIf lastcondition!=number
+			Char difcloseerr="The previous condition/loop is from a different type."
+			vStr _difcloseerr^difcloseerr
+			Return _difcloseerr
+		else
+			if number!=(whilenumber)
+				sub last (2*dwsz)
+				if conds!=last
+					#move it to last to match the reg set outside
+					#and move ifinscribe if it is the case
+					#ignore type, it will only be removed outside
+					#don't increase size to align ifinscribe and just swap
+
+					sd cursor;set cursor conds
+					sub cursor (dwsz)
+					sd size
+					if cursor#=(ifinscribe)
+						set size (2*dwsz)
+					else
+						set size (dwsz)
+						add cursor (dwsz)
+					endelse
+					sd aux#2
+					call memtomem(#aux,cursor,size)
+					while conds!=last
+						add conds (2*dwsz)
+						call memtomem(cursor,conds,(2*dwsz))
+						add cursor (2*dwsz)
+					endwhile
+					call memtomem(cursor,#aux,size)
+				endif
+			endif
+			set p_conds# conds
+			return (noerror)
+		Endelse
+	endwhile
+endfunction
+
+function condendwrite(sd structure,sd codeoffset)
+	Data jumploc#1
+	Data codesec%%ptr_codesec
+	vData writeloc#1
+	Data ptrwriteloc^writeloc
+
+	Call getcont(codesec,ptrwriteloc)
+
+	Set jumploc structure#
+	Sub codeoffset jumploc
+	Add writeloc jumploc
+	Sub writeloc (dwsz)
+
+	Set writeloc# codeoffset
+endfunction
+
+#err
+function jumpback(sd codeoffset,sd condstruct)
+	sub condstruct (dwsz)
+	sub codeoffset condstruct#
+	neg codeoffset
+	sd err
+	SetCall err condjump(codeoffset)
+	return err
+endfunction
+
+#err
+Function conditionscondend(data close1,data close2)
+	Data err#1
+	Data noerr=noerror
+
+	setcall err xfile_add_end_ifif()
+	if err=(noerror)
+		Data loop#1
+		Data loopini=1
+		Data loopstop=0
+		Set loop loopini
+
+		Data number#1
+		Set number close1
+
+		Data ifnr=ifnumber
+		Data elsenr=elsenumber
+		Data structure%%ptr_conditionsloops
+		Data dsz=dwsz
+
+		While loop=loopini
+			SetCall err condend(number)
+			If err!=noerr
+				Return err
+			EndIf
+			sd c
+			If number=ifnr
+				If close2=elsenr
+					Set number elsenr
+					setcall c prevcond()
+					if c=(ifinscribe)
+						call Message("Warning: ENDELSEIF not matching IF")
+					endif
+				Else
+					Set loop loopstop
+				EndElse
+			EndIf
+			If number=elsenr
+				setcall c prevcond()
+				if c=(ifinscribe)
+					Set loop loopstop
+				endif
+			EndIf
+		EndWhile
+
+		Data ptrReg#1
+		Data ptrptrReg^ptrReg
+		Call getptrcontReg(structure,ptrptrReg)
+		Data Reg#1
+		Set Reg ptrReg#
+		Sub Reg dsz
+		Set ptrReg# Reg
+	endif
+	Return err
+EndFunction
+function prevcond()
+	vData cl#1
+	vData structure%%ptr_conditionsloops
+	Call getcontplusReg(structure,#cl)
+	Sub cl (dwsz)
+	return cl#
+endfunction
+
+Function closeifopenelse()
+	Data err#1
+	Data noerr=noerror
+
+	if main.parses=(pass_write)
+		Data number=0
+		SetCall err condjump(number)
+		If err!=noerr
+			Return err
+		EndIf
+	endif
+	Data ifnr=ifnumber
+	SetCall err condend(ifnr)
+	If err!=noerr
+		Return err
+	EndIf
+
+	setcall err xfile_add_char_ifif((Xfile_else))
+	if err=(noerror)
+		Data elsenr=elsenumber
+		SetCall err condbeginwrite(elsenr)
+	endif
+	Return err
+EndFunction
+
+#err
+function continue()
+	sd regnr
+	sd structure
+	vData condloop%%ptr_conditionsloops
+	call getcontandcontReg(condloop,#structure,#regnr)
+	if regnr!=0
+		sd start;set start structure
+		add structure regnr
+		while start!=structure
+			sd type
+			sub structure (dwsz)
+			set type structure#
+			if type!=(ifinscribe)
+				sub structure (dwsz)
+				if type=(whilenumber)
+					vdata ptrcodesec%%ptr_codesec
+					sd codeoffset
+					call getcontReg(ptrcodesec,#codeoffset)
+					Add codeoffset (backjumpsize)
+					sd err;setcall err jumpback(codeoffset,structure)
+					return err
+				endif
+			endif
+		endwhile
+	endif
+	return "There is no loop to continue."
+endfunction
+
+#err
+function break()
+	sd regnr
+	sd structure
+	vData condloop%%ptr_conditionsloops
+	call getcontandcontReg(condloop,#structure,#regnr)
+	if regnr!=0
+		sd start;set start structure
+		add structure regnr
+		while start!=structure
+			sd type
+			sub structure (dwsz)
+			set type structure#
+			if type!=(ifinscribe)
+				sub structure (dwsz)
+				if type=(whilenumber)
+					sd err
+					SetCall err condjump(0)
+					if err=(noerror)
+						SetCall err condbeginwrite((breaknumber))
+					endif
+					Return err
+				endif
+			endif
+		endwhile
+	endif
+	return "There is no loop to break."
+endfunction
+
+#err
+function whileend()
+	sd err;setcall err xfile_add_end_ifif()
+	If err=(noerror)
+		SetCall err condend((whilenumber))
+	EndIf
+	return err
+endfunction
+
+#err
+function prev_cond(sd psecond)
+	sd structure
+	vData condloop%%ptr_conditionsloops
+	call getcontReg(condloop,#structure)
+	if structure=0
+		return (nocondnumber) #function
+	endif
+	call getcontplusReg(condloop,#structure)
+	sub structure (dwsz)
+	while structure#=(breaknumber)
+		sub structure (2*dwsz)
+	endwhile
+	if structure#=(whilenumber)
+		return (whilenumber)
+	endif
+	if structure#=(elsenumber)
+		set psecond# (nocondnumber)
+		return (elsenumber)
+	endif
+	sub structure (2*dwsz)
+	if structure#=(ifinscribe)
+		set psecond# (nocondnumber)
+	else
+		set psecond# (elsenumber)
+	endelse
+	return (ifnumber) #if,elseif
+endfunction
--- ocompiler-1.orig/src/files/functions/commands/cond.s
+++ /dev/null
@@ -1,404 +0,0 @@
-
-#err
-Function coderegtocondloop()
-	Data codesec%%ptr_codesec
-	Data codeReg#1
-	Data ptrcodeReg^codeReg
-
-	Call getcontReg(codesec,ptrcodeReg)
-
-	Data err#1
-	Data condloopsec%%ptr_conditionsloops
-	Data dsz=dwsz
-
-	SetCall err addtosec(ptrcodeReg,dsz,condloopsec)
-	Return err
-EndFunction
-
-#err
-Function condbeginwrite(data condnumber)
-	Data err#1
-	Data noerr=noerror
-
-	SetCall err coderegtocondloop()
-	If err!=noerr
-		Return err
-	EndIf
-
-	Data condloopsec%%ptr_conditionsloops
-	Data dsz=dwsz
-
-	Data ptrcondnumber^condnumber
-	SetCall err addtosec(ptrcondnumber,dsz,condloopsec)
-	Return err
-EndFunction
-
-#err
-Function condbegin(data ptrcontent,data ptrsize,data condnumber)
-	Data cond#1
-	Data ptrcond^cond
-	Data err#1
-	Data noerr=noerror
-
-	if main.parses=(pass_write)
-		setcall err xfile_add_char_if(condnumber)
-		If err!=noerr;Return err;EndIf
-		SetCall err twoargs(ptrcontent,ptrsize,(not_a_subtype),ptrcond)
-		If err!=noerr;Return err;EndIf
-	else
-		call advancecursors(ptrcontent,ptrsize,ptrsize#)
-	endelse
-	SetCall err condbeginwrite(condnumber)
-	Return err
-EndFunction
-
-#err
-Function checkcondloopclose()
-	Data regnr#1
-	Data ptrregnr^regnr
-	Data condloop%%ptr_conditionsloops
-	Call getcontReg(condloop,ptrregnr)
-	Data zero=0
-	If regnr!=zero
-		Char closeerr="All conditions/loops within a scope most be closed."
-		Str _closeerr^closeerr
-		Return _closeerr
-	EndIf
-	Data noerr=noerror
-	Return noerr
-EndFunction
-
-Const backjumpsize=5
-#err
-Function condjump(data size)
-	Char jump={0xe9}
-	Data jsize#1
-	Data bjsz=backjumpsize
-
-	Data pjsize^jsize
-
-	Set pjsize# size
-
-	Data pjump^jump
-
-	Data err#1
-	Data code%%ptr_codesec
-	SetCall err addtosec(pjump,bjsz,code)
-	Return err
-EndFunction
-
-#err
-Function condend(data number)
-	Data condloop%%ptr_conditionsloops
-	Data ptrcReg#1
-	Data ptrptrcReg^ptrcReg
-
-	Call getptrcontReg(condloop,ptrptrcReg)
-	If ptrcReg#=0
-		Char uncloseerr="Unexpected condition/loop close command."
-		Str _uncloseerr^uncloseerr
-		Return _uncloseerr
-	EndIf
-
-	Data codeoffset#1
-	Data ptrcodeoff^codeoffset
-	Data codesec%%ptr_codesec
-	Data whilenr=whilenumber
-	Data structure#1
-	Data ptrstructure^structure
-
-	Call getcontReg(codesec,ptrcodeoff)
-	If number=whilenr
-		Add codeoffset (backjumpsize)
-	EndIf
-	Call getcont(condloop,ptrstructure)
-	Add structure ptrcReg#
-	sd reg;set reg structure
-
-	sd err;setcall err condendtest(#structure,number,codeoffset)
-	if err=(noerror)
-		If number=whilenr
-			if main.parses=(pass_write)
-				setcall err jumpback(codeoffset,structure)
-				If err!=(noerror)
-					Return err
-				EndIf
-			endif
-			add reg (dwsz)   #to match for ptrcReg
-		EndIf
-
-		if main.parses=(pass_write)
-			call condendwrite(structure,codeoffset)
-		endif
-
-		sub reg structure
-		Sub ptrcReg# reg
-	endif
-	return err
-EndFunction
-
-#err
-function condendtest(sv p_conds,sd number,sd codeoffset)
-	sd conds;set conds p_conds#
-
-	#for breaks inside conditions
-	sd last;set last conds
-
-	while 1=1
-		Data lastcondition#1
-
-		sub conds (dwsz)
-		Set lastcondition conds#
-		sub conds (dwsz)
-
-		if lastcondition=(breaknumber)
-			if number=(whilenumber)
-				call condendwrite(conds,codeoffset)
-			endif
-		elseIf lastcondition!=number
-			Char difcloseerr="The previous condition/loop is from a different type."
-			vStr _difcloseerr^difcloseerr
-			Return _difcloseerr
-		else
-			if number!=(whilenumber)
-				sub last (2*dwsz)
-				if conds!=last
-					#move it to last to match the reg set outside
-					#and move ifinscribe if it is the case
-					#ignore type, it will only be removed outside
-					#don't increase size to align ifinscribe and just swap
-
-					sd cursor;set cursor conds
-					sub cursor (dwsz)
-					sd size
-					if cursor#=(ifinscribe)
-						set size (2*dwsz)
-					else
-						set size (dwsz)
-						add cursor (dwsz)
-					endelse
-					sd aux#2
-					call memtomem(#aux,cursor,size)
-					while conds!=last
-						add conds (2*dwsz)
-						call memtomem(cursor,conds,(2*dwsz))
-						add cursor (2*dwsz)
-					endwhile
-					call memtomem(cursor,#aux,size)
-				endif
-			endif
-			set p_conds# conds
-			return (noerror)
-		Endelse
-	endwhile
-endfunction
-
-function condendwrite(sd structure,sd codeoffset)
-	Data jumploc#1
-	Data codesec%%ptr_codesec
-	vData writeloc#1
-	Data ptrwriteloc^writeloc
-
-	Call getcont(codesec,ptrwriteloc)
-
-	Set jumploc structure#
-	Sub codeoffset jumploc
-	Add writeloc jumploc
-	Sub writeloc (dwsz)
-
-	Set writeloc# codeoffset
-endfunction
-
-#err
-function jumpback(sd codeoffset,sd condstruct)
-	sub condstruct (dwsz)
-	sub codeoffset condstruct#
-	neg codeoffset
-	sd err
-	SetCall err condjump(codeoffset)
-	return err
-endfunction
-
-#err
-Function conditionscondend(data close1,data close2)
-	Data err#1
-	Data noerr=noerror
-
-	setcall err xfile_add_end_ifif()
-	if err=(noerror)
-		Data loop#1
-		Data loopini=1
-		Data loopstop=0
-		Set loop loopini
-
-		Data number#1
-		Set number close1
-
-		Data ifnr=ifnumber
-		Data elsenr=elsenumber
-		Data structure%%ptr_conditionsloops
-		Data dsz=dwsz
-
-		While loop=loopini
-			SetCall err condend(number)
-			If err!=noerr
-				Return err
-			EndIf
-			sd c
-			If number=ifnr
-				If close2=elsenr
-					Set number elsenr
-					setcall c prevcond()
-					if c=(ifinscribe)
-						call Message("Warning: ENDELSEIF not matching IF")
-					endif
-				Else
-					Set loop loopstop
-				EndElse
-			EndIf
-			If number=elsenr
-				setcall c prevcond()
-				if c=(ifinscribe)
-					Set loop loopstop
-				endif
-			EndIf
-		EndWhile
-
-		Data ptrReg#1
-		Data ptrptrReg^ptrReg
-		Call getptrcontReg(structure,ptrptrReg)
-		Data Reg#1
-		Set Reg ptrReg#
-		Sub Reg dsz
-		Set ptrReg# Reg
-	endif
-	Return err
-EndFunction
-function prevcond()
-	vData cl#1
-	vData structure%%ptr_conditionsloops
-	Call getcontplusReg(structure,#cl)
-	Sub cl (dwsz)
-	return cl#
-endfunction
-
-Function closeifopenelse()
-	Data err#1
-	Data noerr=noerror
-
-	if main.parses=(pass_write)
-		Data number=0
-		SetCall err condjump(number)
-		If err!=noerr
-			Return err
-		EndIf
-	endif
-	Data ifnr=ifnumber
-	SetCall err condend(ifnr)
-	If err!=noerr
-		Return err
-	EndIf
-
-	setcall err xfile_add_char_ifif((Xfile_else))
-	if err=(noerror)
-		Data elsenr=elsenumber
-		SetCall err condbeginwrite(elsenr)
-	endif
-	Return err
-EndFunction
-
-#err
-function continue()
-	sd regnr
-	sd structure
-	vData condloop%%ptr_conditionsloops
-	call getcontandcontReg(condloop,#structure,#regnr)
-	if regnr!=0
-		sd start;set start structure
-		add structure regnr
-		while start!=structure
-			sd type
-			sub structure (dwsz)
-			set type structure#
-			if type!=(ifinscribe)
-				sub structure (dwsz)
-				if type=(whilenumber)
-					vdata ptrcodesec%%ptr_codesec
-					sd codeoffset
-					call getcontReg(ptrcodesec,#codeoffset)
-					Add codeoffset (backjumpsize)
-					sd err;setcall err jumpback(codeoffset,structure)
-					return err
-				endif
-			endif
-		endwhile
-	endif
-	return "There is no loop to continue."
-endfunction
-
-#err
-function break()
-	sd regnr
-	sd structure
-	vData condloop%%ptr_conditionsloops
-	call getcontandcontReg(condloop,#structure,#regnr)
-	if regnr!=0
-		sd start;set start structure
-		add structure regnr
-		while start!=structure
-			sd type
-			sub structure (dwsz)
-			set type structure#
-			if type!=(ifinscribe)
-				sub structure (dwsz)
-				if type=(whilenumber)
-					sd err
-					SetCall err condjump(0)
-					if err=(noerror)
-						SetCall err condbeginwrite((breaknumber))
-					endif
-					Return err
-				endif
-			endif
-		endwhile
-	endif
-	return "There is no loop to break."
-endfunction
-
-#err
-function whileend()
-	sd err;setcall err xfile_add_end_ifif()
-	If err=(noerror)
-		SetCall err condend((whilenumber))
-	EndIf
-	return err
-endfunction
-
-#err
-function prev_cond(sd psecond)
-	sd structure
-	vData condloop%%ptr_conditionsloops
-	call getcontReg(condloop,#structure)
-	if structure=0
-		return (nocondnumber) #function
-	endif
-	call getcontplusReg(condloop,#structure)
-	sub structure (dwsz)
-	while structure#=(breaknumber)
-		sub structure (2*dwsz)
-	endwhile
-	if structure#=(whilenumber)
-		return (whilenumber)
-	endif
-	if structure#=(elsenumber)
-		set psecond# (nocondnumber)
-		return (elsenumber)
-	endif
-	sub structure (2*dwsz)
-	if structure#=(ifinscribe)
-		set psecond# (nocondnumber)
-	else
-		set psecond# (elsenumber)
-	endelse
-	return (ifnumber) #if,elseif
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/commands/lib.oc
@@ -0,0 +1,80 @@
+
+
+Data implibsstarted#1
+
+#er
+Function openlib()
+	Data addressesReg#1
+	Data namesReg#1
+	Data ptraddressesReg^addressesReg
+	Data ptrnamesReg^namesReg
+	Data iaddresses%%ptr_addresses
+	Data inames%%ptr_names
+	Call getcontReg(iaddresses,ptraddressesReg)
+	Call getcontReg(inames,ptrnamesReg)
+
+	Data OriginalFirstThunk#1
+	Data *TimeDateStamp=0
+	Data *ForwarderChain=0
+	Data Name#1
+	Data FirstThunk#1
+
+	Set Name namesReg
+	Set FirstThunk addressesReg
+
+	Data iid^OriginalFirstThunk
+	Data iid_size=IMAGE_IMPORT_DESCRIPTORsize
+	Data itable%%ptr_table
+	Data err#1
+	SetCall err addtosec(iid,iid_size,itable)
+	Return err
+EndFunction
+
+#er
+Function closelib()
+	Data itable%%ptr_table
+	Data itab#1
+	Data tabsize#1
+	Data ptritab^itab
+	Data ptrtabsize^tabsize
+	Call getcontandcontReg(itable,ptritab,ptrtabsize)
+
+	Data iaddresses%%ptr_addresses
+
+	Data null=NULL
+	Data ptrnull^null
+	Data dsz=dwsz
+	Data err#1
+	SetCall err addtosec(ptrnull,dsz,iaddresses)
+	Data noerr=noerror
+	If err!=noerr
+		Return err
+	EndIf
+
+	Data iadr#1
+	Data adrsize#1
+	Data ptriadr^iadr
+	Data ptradrsize^adrsize
+	Call getcontandcontReg(iaddresses,ptriadr,ptradrsize)
+
+	Add itab tabsize
+	Data ptrfirstthunk#1
+	Set ptrfirstthunk itab
+	Sub ptrfirstthunk dsz
+	Data firstthunk#1
+	Set firstthunk ptrfirstthunk#
+
+	Data iidsize=IMAGE_IMPORT_DESCRIPTORsize
+	Sub itab iidsize
+
+	Set itab# adrsize
+
+	Data src#1
+	Set src iadr
+	Add src firstthunk
+
+	Sub adrsize firstthunk
+
+	SetCall err addtosec(src,adrsize,iaddresses)
+	Return err
+EndFunction
--- ocompiler-1.orig/src/files/functions/commands/lib.s
+++ /dev/null
@@ -1,80 +0,0 @@
-
-
-Data implibsstarted#1
-
-#er
-Function openlib()
-	Data addressesReg#1
-	Data namesReg#1
-	Data ptraddressesReg^addressesReg
-	Data ptrnamesReg^namesReg
-	Data iaddresses%%ptr_addresses
-	Data inames%%ptr_names
-	Call getcontReg(iaddresses,ptraddressesReg)
-	Call getcontReg(inames,ptrnamesReg)
-
-	Data OriginalFirstThunk#1
-	Data *TimeDateStamp=0
-	Data *ForwarderChain=0
-	Data Name#1
-	Data FirstThunk#1
-
-	Set Name namesReg
-	Set FirstThunk addressesReg
-
-	Data iid^OriginalFirstThunk
-	Data iid_size=IMAGE_IMPORT_DESCRIPTORsize
-	Data itable%%ptr_table
-	Data err#1
-	SetCall err addtosec(iid,iid_size,itable)
-	Return err
-EndFunction
-
-#er
-Function closelib()
-	Data itable%%ptr_table
-	Data itab#1
-	Data tabsize#1
-	Data ptritab^itab
-	Data ptrtabsize^tabsize
-	Call getcontandcontReg(itable,ptritab,ptrtabsize)
-
-	Data iaddresses%%ptr_addresses
-
-	Data null=NULL
-	Data ptrnull^null
-	Data dsz=dwsz
-	Data err#1
-	SetCall err addtosec(ptrnull,dsz,iaddresses)
-	Data noerr=noerror
-	If err!=noerr
-		Return err
-	EndIf
-
-	Data iadr#1
-	Data adrsize#1
-	Data ptriadr^iadr
-	Data ptradrsize^adrsize
-	Call getcontandcontReg(iaddresses,ptriadr,ptradrsize)
-
-	Add itab tabsize
-	Data ptrfirstthunk#1
-	Set ptrfirstthunk itab
-	Sub ptrfirstthunk dsz
-	Data firstthunk#1
-	Set firstthunk ptrfirstthunk#
-
-	Data iidsize=IMAGE_IMPORT_DESCRIPTORsize
-	Sub itab iidsize
-
-	Set itab# adrsize
-
-	Data src#1
-	Set src iadr
-	Add src firstthunk
-
-	Sub adrsize firstthunk
-
-	SetCall err addtosec(src,adrsize,iaddresses)
-	Return err
-EndFunction
--- /dev/null
+++ ocompiler-1/src/files/functions/commands/ret.oc
@@ -0,0 +1,37 @@
+
+#err
+function writeret()
+	sd err
+	sd termswitch
+	sd continuation
+	sd continuationsize
+	setcall termswitch is_linux_end()
+	if termswitch=(TRUE)
+		setcall err getexit(#continuation,#continuationsize)
+		if err=(noerror)
+			Data ptrcodesec%%ptr_codesec
+			setcall err addtosec(continuation,continuationsize,ptrcodesec)
+		endif
+	else
+		setcall continuationsize getreturn(#continuation)
+		setcall err addtosec(continuation,continuationsize,ptrcodesec)
+	endelse
+	set main.endfunction_has_write_marker (FALSE)
+	return err
+endfunction
+
+function callret_flag(sd subtype)
+	and subtype (call_ret_flag)
+	return subtype
+endfunction
+
+#err
+function after_after_call(sd subtype)
+	setcall subtype callret_flag(subtype)
+	if subtype!=0
+		sd err
+		setcall err writeret()
+		return err
+	endif
+	return (noerror)
+endfunction
--- ocompiler-1.orig/src/files/functions/commands/ret.s
+++ /dev/null
@@ -1,36 +0,0 @@
-
-#err
-function writeret()
-	sd err
-	sd termswitch
-	sd continuation
-	sd continuationsize
-	setcall termswitch is_linux_end()
-	if termswitch=(TRUE)
-		setcall err getexit(#continuation,#continuationsize)
-		if err=(noerror)
-			Data ptrcodesec%%ptr_codesec
-			setcall err addtosec(continuation,continuationsize,ptrcodesec)
-		endif
-	else
-		setcall continuationsize getreturn(#continuation)
-		setcall err addtosec(continuation,continuationsize,ptrcodesec)
-	endelse
-	return err
-endfunction
-
-function callret_flag(sd subtype)
-	and subtype (call_ret_flag)
-	return subtype
-endfunction
-
-#err
-function after_after_call(sd subtype)
-	setcall subtype callret_flag(subtype)
-	if subtype!=0
-		sd err
-		setcall err writeret()
-		return err
-	endif
-	return (noerror)
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/commons/base.oc
@@ -0,0 +1,251 @@
+
+Function getcont(data ptrstructure,data ptrcontainer)
+	Data offset=containersdataoffset
+	Add ptrstructure offset
+	Set ptrcontainer# ptrstructure#
+EndFunction
+function setcont(sv ptrstructure,sd value)
+	add ptrstructure (containersdataoffset)
+	set ptrstructure# value
+endfunction
+Function getptrcont(sv ptrstructure,sv ptrptrcontainer)
+	add ptrstructure (containersdataoffset)
+	set ptrptrcontainer# ptrstructure
+EndFunction
+
+Function getcontReg(data ptrstructure,data ptrcontainerReg)
+	Data ptrcReg#1
+	Data ptrptrcReg^ptrcReg
+	Call getptrcontReg(ptrstructure,ptrptrcReg)
+	Set ptrcontainerReg# ptrcReg#
+EndFunction
+function setcontReg(sd ptrstructure,sd value)
+	add ptrstructure (containersdataRegoffset)
+	set ptrstructure# value
+endfunction
+Function getptrcontReg(data ptrstructure,data ptrptrcontainerReg)
+	Data offset=containersdataRegoffset
+	Add ptrstructure offset
+	Set ptrptrcontainerReg# ptrstructure
+EndFunction
+
+Function getcontMax(sd ptrstructure,sd ptrcontainerMax)
+	set ptrcontainerMax# ptrstructure#
+EndFunction
+function setcontMax(sd ptrstructure,sd value)
+	set ptrstructure# value
+endfunction
+
+Function getcontandcontReg(data ptrstrucutre,data ptrcontainer,data ptrcontainerReg)
+	Call getcontReg(ptrstrucutre,ptrcontainerReg)
+	Call getcont(ptrstrucutre,ptrcontainer)
+EndFunction
+Function getcontplusReg(data ptrstrucutre,data ptrcontainer)
+	Call getcont(ptrstrucutre,ptrcontainer)
+	sd r
+	Call getcontReg(ptrstrucutre,#r)
+	add ptrcontainer# r
+EndFunction
+
+Data innerfunction#1
+Const globalinnerfunction^innerfunction
+
+#pdata
+Function getstructcont(data typenumber)
+#structcont is not same as cont, it's easy to rename
+	Data dest#1
+	Data scopes%%ptr_scopes
+	Data sizeofdataset=sizeofcontainer
+
+	Data fnboolptr%globalinnerfunction
+	Data fnbool#1
+
+	Set fnbool fnboolptr#
+
+	Data true=TRUE
+	Data scopeindependent=afterscopes
+
+	If fnbool=true
+		If typenumber<scopeindependent
+			Data nrofvars=numberofvars
+			Add typenumber nrofvars
+		EndIf
+	EndIf
+
+	Data offset#1
+	Set offset sizeofdataset
+	Mult offset typenumber
+	Set dest scopes
+	Add dest offset
+	Return dest
+EndFunction
+#pdata
+Function getstructcont_scope(sd typenumber,sd scope)
+	sd offset
+	set offset (sizeofcontainer)
+	mult offset typenumber
+	add offset scope
+	return offset
+EndFunction
+
+#return virtual value
+Function congruentmoduloatsegments(data virtual,data offset,data modulo,data newbytes)
+	Data offsettop#1
+	Data virtualtop#1
+
+    #add newbytes at virtual, offset already has them
+	Add virtual newbytes
+
+	SetCall virtualtop remainder(virtual,modulo)
+
+	SetCall offsettop remainder(offset,modulo)
+
+	Data value#1
+
+	If virtualtop!=offsettop
+	    If virtualtop<offsettop
+		    #rise virtual to offset
+		    Sub offsettop virtualtop
+			Add virtual offsettop
+		Else
+		    #rise virtual to modulo+offset
+			Set value modulo
+			Sub value virtualtop
+			Add virtual value
+			Add virtual offsettop
+		EndElse
+	EndIf
+
+	#pad safe for avoiding segemntation faults
+	SetCall value remainder(offsettop,modulo)
+	Data zero=0
+	If value!=zero
+	     Add virtual modulo
+	EndIf
+	return virtual
+EndFunction
+
+#str
+function log_term(sd psz)
+	char textterm={asciicarriage,asciireturn,0}
+	set psz# 2
+	return #textterm
+endfunction
+#err
+function addtolog_term(sd filehandle)
+	sd sz
+	ss text;setcall text log_term(#sz)
+	sd err
+	setcall err writefile_errversion(filehandle,text,sz)
+	return err
+endfunction
+#err
+function addtolog_handle(ss content,sd sizetowrite,sd filehandle)
+	sd err
+	setcall err writefile_errversion(filehandle,content,sizetowrite)
+	if err!=(noerror);return err;endif
+	setcall err addtolog_term(filehandle)
+	return err
+endfunction
+#err
+function addtolog_char(sd type,sd handle)
+	sd err
+	setcall err addtolog_withchar_handle((NULL),0,type,handle)
+	return err
+endfunction
+#err
+function addtolog_withchar_handle(ss content,sd size,sd type,sd handle)
+	if handle!=-1
+	#this compare only at first chdir is extra
+		sd err
+		setcall err writefile_errversion(handle,#type,1)
+		if err=(noerror)
+			setcall err addtolog_handle(content,size,handle)
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
+#err
+function addtolog_withchar_ex(ss content,sd size,sd type)
+	vdata ptrfilehandle%ptrlogfile
+	sd err
+	setcall err addtolog_withchar_handle(content,size,type,ptrfilehandle#)
+	return err
+endfunction
+#err
+function addtolog_withchar(ss content,sd type)
+	sd len
+	setcall len strlen(content)
+	sd err
+	setcall err addtolog_withchar_ex(content,len,type)
+	return err
+endfunction
+#err
+function addtolog_array_withchar(sv array,sd type)
+	vdata ptrfilehandle%ptrlogfile
+	if ptrfilehandle#!=-1
+		sd err
+		setcall err writefile_errversion(ptrfilehandle#,#type,1)
+		if err=(noerror)
+			while array#!=(NULL)
+				sd val;set val array#
+				incst array
+				setcall err writefile_errversion(ptrfilehandle#,val,array#d^)
+				if err!=(noerror);return err;endif
+				add array (dwsz)
+			endwhile
+			setcall err addtolog_term(ptrfilehandle#)
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
+#err
+function addtolog_withchar_parses(ss content,sd type,sd both)
+	sd err
+	if both=(FALSE)
+		sd ptrparses%ptr_parses
+		if ptrparses#=(pass_init)
+			setcall err addtolog_withchar(content,type)
+		elseif ptrparses#=(pass_write)
+			setcall err addtodebug_withchar(content,type)
+		else
+		#skip pass_calls
+			return (noerror)
+		endelse
+		return err
+	endif
+	setcall err addtolog_withchar(content,type)
+	if err=(noerror)
+		setcall err addtodebug_withchar(content,type)
+	endif
+	return err
+endfunction
+#err
+function addtolog_withchar_ex_atunused(ss content,sd size,sd type)
+	data ptrobject%ptrobject
+	if ptrobject#=(TRUE)
+		sd err
+		setcall err addtolog_withchar_ex(content,size,type)
+		return err
+	endif
+	return (noerror)
+endfunction
+#err
+function addtolog_withchar_ex_atunused_handle(ss content,sd size,sd type,sd filehandle)
+	data ptrobject%ptrobject
+	if ptrobject#=(TRUE)
+		sd err
+		setcall err addtolog_withchar_handle(content,size,type,filehandle)
+		return err
+	endif
+	return (noerror)
+endfunction
+#err
+function addtolog_natural(sd number)
+	char buf#8+1
+	call sprintf(#buf,"%08x",number)  #for file seek at position
+	sd err;setcall err addtolog_withchar(#buf,(log_expand))
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/commons/base.s
+++ /dev/null
@@ -1,251 +0,0 @@
-
-Function getcont(data ptrstructure,data ptrcontainer)
-	Data offset=containersdataoffset
-	Add ptrstructure offset
-	Set ptrcontainer# ptrstructure#
-EndFunction
-function setcont(sv ptrstructure,sd value)
-	add ptrstructure (containersdataoffset)
-	set ptrstructure# value
-endfunction
-Function getptrcont(sv ptrstructure,sv ptrptrcontainer)
-	add ptrstructure (containersdataoffset)
-	set ptrptrcontainer# ptrstructure
-EndFunction
-
-Function getcontReg(data ptrstructure,data ptrcontainerReg)
-	Data ptrcReg#1
-	Data ptrptrcReg^ptrcReg
-	Call getptrcontReg(ptrstructure,ptrptrcReg)
-	Set ptrcontainerReg# ptrcReg#
-EndFunction
-function setcontReg(sd ptrstructure,sd value)
-	add ptrstructure (containersdataRegoffset)
-	set ptrstructure# value
-endfunction
-Function getptrcontReg(data ptrstructure,data ptrptrcontainerReg)
-	Data offset=containersdataRegoffset
-	Add ptrstructure offset
-	Set ptrptrcontainerReg# ptrstructure
-EndFunction
-
-Function getcontMax(sd ptrstructure,sd ptrcontainerMax)
-	set ptrcontainerMax# ptrstructure#
-EndFunction
-function setcontMax(sd ptrstructure,sd value)
-	set ptrstructure# value
-endfunction
-
-Function getcontandcontReg(data ptrstrucutre,data ptrcontainer,data ptrcontainerReg)
-	Call getcontReg(ptrstrucutre,ptrcontainerReg)
-	Call getcont(ptrstrucutre,ptrcontainer)
-EndFunction
-Function getcontplusReg(data ptrstrucutre,data ptrcontainer)
-	Call getcont(ptrstrucutre,ptrcontainer)
-	sd r
-	Call getcontReg(ptrstrucutre,#r)
-	add ptrcontainer# r
-EndFunction
-
-Data innerfunction#1
-Const globalinnerfunction^innerfunction
-
-#pdata
-Function getstructcont(data typenumber)
-#structcont is not same as cont, it's easy to rename
-	Data dest#1
-	Data scopes%%ptr_scopes
-	Data sizeofdataset=sizeofcontainer
-
-	Data fnboolptr%globalinnerfunction
-	Data fnbool#1
-
-	Set fnbool fnboolptr#
-
-	Data true=TRUE
-	Data scopeindependent=afterscopes
-
-	If fnbool=true
-		If typenumber<scopeindependent
-			Data nrofvars=numberofvars
-			Add typenumber nrofvars
-		EndIf
-	EndIf
-
-	Data offset#1
-	Set offset sizeofdataset
-	Mult offset typenumber
-	Set dest scopes
-	Add dest offset
-	Return dest
-EndFunction
-#pdata
-Function getstructcont_scope(sd typenumber,sd scope)
-	sd offset
-	set offset (sizeofcontainer)
-	mult offset typenumber
-	add offset scope
-	return offset
-EndFunction
-
-#return virtual value
-Function congruentmoduloatsegments(data virtual,data offset,data modulo,data newbytes)
-	Data offsettop#1
-	Data virtualtop#1
-
-    #add newbytes at virtual, offset already has them
-	Add virtual newbytes
-
-	SetCall virtualtop remainder(virtual,modulo)
-
-	SetCall offsettop remainder(offset,modulo)
-
-	Data value#1
-
-	If virtualtop!=offsettop
-	    If virtualtop<offsettop
-		    #rise virtual to offset
-		    Sub offsettop virtualtop
-			Add virtual offsettop
-		Else
-		    #rise virtual to modulo+offset
-			Set value modulo
-			Sub value virtualtop
-			Add virtual value
-			Add virtual offsettop
-		EndElse
-	EndIf
-
-	#pad safe for avoiding segemntation faults
-	SetCall value remainder(offsettop,modulo)
-	Data zero=0
-	If value!=zero
-	     Add virtual modulo
-	EndIf
-	return virtual
-EndFunction
-
-#str
-function log_term(sd psz)
-	char textterm={asciicarriage,asciireturn,0}
-	set psz# 2
-	return #textterm
-endfunction
-#err
-function addtolog_term(sd filehandle)
-	sd sz
-	ss text;setcall text log_term(#sz)
-	sd err
-	setcall err writefile_errversion(filehandle,text,sz)
-	return err
-endfunction
-#err
-function addtolog_handle(ss content,sd sizetowrite,sd filehandle)
-	sd err
-	setcall err writefile_errversion(filehandle,content,sizetowrite)
-	if err!=(noerror);return err;endif
-	setcall err addtolog_term(filehandle)
-	return err
-endfunction
-#err
-function addtolog_char(sd type,sd handle)
-	sd err
-	setcall err addtolog_withchar_handle((NULL),0,type,handle)
-	return err
-endfunction
-#err
-function addtolog_withchar_handle(ss content,sd size,sd type,sd handle)
-	if handle!=-1
-	#this compare only at first chdir is extra
-		sd err
-		setcall err writefile_errversion(handle,#type,1)
-		if err=(noerror)
-			setcall err addtolog_handle(content,size,handle)
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
-#err
-function addtolog_withchar_ex(ss content,sd size,sd type)
-	vdata ptrfilehandle%ptrlogfile
-	sd err
-	setcall err addtolog_withchar_handle(content,size,type,ptrfilehandle#)
-	return err
-endfunction
-#err
-function addtolog_withchar(ss content,sd type)
-	sd len
-	setcall len strlen(content)
-	sd err
-	setcall err addtolog_withchar_ex(content,len,type)
-	return err
-endfunction
-#err
-function addtolog_array_withchar(sv array,sd type)
-	vdata ptrfilehandle%ptrlogfile
-	if ptrfilehandle#!=-1
-		sd err
-		setcall err writefile_errversion(ptrfilehandle#,#type,1)
-		if err=(noerror)
-			while array#!=(NULL)
-				sd val;set val array#
-				incst array
-				setcall err writefile_errversion(ptrfilehandle#,val,array#d^)
-				if err!=(noerror);return err;endif
-				add array (dwsz)
-			endwhile
-			setcall err addtolog_term(ptrfilehandle#)
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
-#err
-function addtolog_withchar_parses(ss content,sd type,sd both)
-	sd err
-	if both=(FALSE)
-		sd ptrparses%ptr_parses
-		if ptrparses#=(pass_init)
-			setcall err addtolog_withchar(content,type)
-		elseif ptrparses#=(pass_write)
-			setcall err addtodebug_withchar(content,type)
-		else
-		#skip pass_calls
-			return (noerror)
-		endelse
-		return err
-	endif
-	setcall err addtolog_withchar(content,type)
-	if err=(noerror)
-		setcall err addtodebug_withchar(content,type)
-	endif
-	return err
-endfunction
-#err
-function addtolog_withchar_ex_atunused(ss content,sd size,sd type)
-	data ptrobject%ptrobject
-	if ptrobject#=(TRUE)
-		sd err
-		setcall err addtolog_withchar_ex(content,size,type)
-		return err
-	endif
-	return (noerror)
-endfunction
-#err
-function addtolog_withchar_ex_atunused_handle(ss content,sd size,sd type,sd filehandle)
-	data ptrobject%ptrobject
-	if ptrobject#=(TRUE)
-		sd err
-		setcall err addtolog_withchar_handle(content,size,type,filehandle)
-		return err
-	endif
-	return (noerror)
-endfunction
-#err
-function addtolog_natural(sd number)
-	char buf#8+1
-	call sprintf(#buf,"%08x",number)  #for file seek at position
-	sd err;setcall err addtolog_withchar(#buf,(log_expand))
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/commons/comfn.oc
@@ -0,0 +1,450 @@
+
+#################Memory
+#err
+Function memrealloc(data ptrpointer,data size)
+	Data newpointer#1
+	Data oldpointer#1
+	Set oldpointer ptrpointer#
+	SetCall newpointer realloc(oldpointer,size)
+	Data null=NULL
+	If newpointer=null
+		Char newmem="Memory allocation error."
+		Data pnewmem^newmem
+		Return pnewmem
+	EndIf
+	Set ptrpointer# newpointer
+	Data noerr=noerror
+	Return noerr
+EndFunction
+#err
+Function mem_alloc(sd size,sv p)
+	sd mem
+	setcall mem malloc(size)
+	if mem!=(NULL)
+		set p# mem
+		return (noerror)
+	endif
+	return "malloc error"
+EndFunction
+
+#err
+Function memoryalloc(data pathsize,data memptr)
+	Data err#1
+	Data null=NULL
+	Set memptr# null
+	SetCall err memrealloc(memptr,pathsize)
+	Return err
+EndFunction
+
+#null or ptr
+Function memalloc(data pathsize)
+	Data errmsg#1
+	Data mem#1
+	Data memptr^mem
+	SetCall errmsg memoryalloc(pathsize,memptr)
+	Data null=NULL
+	Data noerr=noerror
+	If errmsg=noerr
+		Return mem
+	Else
+		Call Message(errmsg)
+		Return null
+	EndElse
+EndFunction
+
+
+#null or ptr
+Function memcalloc(data pathsize)
+	Data path=0
+	Data null=NULL
+	SetCall path memalloc(pathsize)
+	If path=null
+		Return null
+	EndIf
+	Call memset(path,null,pathsize)
+	Return path
+EndFunction
+
+#0 equal -1 not
+Function memcmp(str m1,str m2,data size)
+	Data zero=0
+
+	Data equal=0
+	Data notequal=-1
+
+	Char c1#1
+	Char c2#1
+	While size!=zero
+		Set c1 m1#
+		Set c2 m2#
+		If c1!=c2
+			Return notequal
+		EndIf
+		Inc m1
+		Inc m2
+		Dec size
+	EndWhile
+	Return equal
+EndFunction
+
+#sizeof the string
+Function strlen(str str)
+	Char term={0}
+	Char byte#1
+	Data sz#1
+	Data zero=0
+	Set sz zero
+	Set byte str#
+	While byte!=term
+		Inc str
+		Inc sz
+		Set byte str#
+	EndWhile
+	Return sz
+EndFunction
+
+#null or buffer
+Function printbuf(sd format,sd message,sd s1,sd nr,sd n1,sd n2)
+	Data bufsize#1
+	SetCall bufsize strlen(format)
+	addCall bufsize strlen(message)
+	addCall bufsize strlen(s1)
+	if nr>0
+		add bufsize (dw_char)
+		if nr>1
+			add bufsize (dw_char)
+		endif
+	endif
+
+	Str buf#1
+	SetCall buf memalloc(bufsize)
+	Data null=NULL
+	If buf=null
+		Return null
+	EndIf
+	call sprintf(buf,format,message,s1,n1,n2)
+	Return buf
+EndFunction
+
+#str1/newPointer
+function errorDefOut(str str1,str str2)
+	str format="%s%s"
+	data ptrallocerrormsg%ptrallocerrormsg
+	SetCall ptrallocerrormsg# printbuf(format,str1,str2,0)
+	data null=NULL
+	If ptrallocerrormsg#=null
+		return str1
+	EndIf
+	return ptrallocerrormsg#
+endfunction
+
+#################Files and Folders
+#err
+Function openfile(data pfile,str path,data oflag)
+	sd permission
+	sd creat_test;set creat_test oflag;and creat_test (flag_O_CREAT);if creat_test!=0
+		set permission (pmode_mode);endif
+	Data openfalse=openno
+	SetCall pfile# open(path,oflag,permission)
+	If pfile#=openfalse
+		str errorreturn#1
+		Str fileOpenErr="Cannot open a file:"
+		setcall errorreturn errorDefOut(fileOpenErr,path)
+		Return errorreturn
+	EndIf
+	Data noerr=noerror
+	Return noerr
+EndFunction
+#err
+function openfile_write_add_extension(ss path,ss extension,sd popen)
+	sd er
+	setcall er openfile_mode_add_extension(path,extension,popen,(_open_write))
+	return er
+endfunction
+#err
+function openfile_mode_add_extension(ss path,ss extension,sd popen,sd mod)
+	sd er
+	setcall er maxpathverif(path,extension)
+	if er=(noerror)
+		ss c;set c path
+		addcall c strlen(path)
+		ss b;setcall b strlen(extension)
+		inc b
+		call memtomem(c,extension,b)
+		setcall er openfile(popen,path,mod)
+		set c# (asciinul)  #required in all cases
+	endif
+	return er
+endfunction
+
+char writefile_err="Cannot write data to a file."
+const writefile_err_p^writefile_err
+#return _write (-1 or wrln)
+Function writefile(data hfile,str buf,data ln)
+	sd writeres
+	SetCall writeres write(hfile,buf,ln)
+	If writeres!=ln
+		sd writeerr%writefile_err_p
+		Call Message(writeerr)
+		Return (writeno)
+	EndIf
+	Return writeres
+EndFunction
+#err
+Function writefile_errversion(data hfile,str buf,data ln)
+	sd writeres
+	SetCall writeres write(hfile,buf,ln)
+	If writeres!=ln
+		sd writeerr%writefile_err_p
+		Return writeerr
+	EndIf
+	Return (noerror)
+EndFunction
+
+#return required pad, so value can be a multiple of pad
+Function requiredpad(data value,data pad)
+	Data integers#1
+	Set integers value
+	Div integers pad
+	Mult integers pad
+	Sub value integers
+
+	Data zero=0
+	If value=zero
+		return zero
+	EndIf
+	Sub pad value
+	Return pad
+EndFunction
+
+#return writefile
+Function padwrite(data hfile,data size)
+	Data padmem#1
+	Data null=NULL
+	Data writefalse=writeno
+	SetCall padmem memcalloc(size)
+	If padmem=null
+		return writefalse
+	EndIf
+	Data writeres#1
+	SetCall writeres writefile(hfile,padmem,size)
+	Return writeres
+EndFunction
+
+#return writefile
+#write ln, and walk size value to pad
+Function paddedwrite(data hfile,str buf,data ln,data pad)
+	Data zero=0
+	Data padvalue#1
+	Set padvalue pad
+	Div padvalue padvalue
+	If padvalue=pad
+		Set padvalue zero
+	Else
+		Set padvalue pad
+	EndElse
+	Data writeres#1
+	If ln!=zero
+		Data writefalse=writeno
+		SetCall writeres writefile(hfile,buf,ln)
+		If writeres=writefalse
+			Return writefalse
+		EndIf
+
+		SetCall padvalue requiredpad(ln,pad)
+		If padvalue=zero
+			Return writeres
+		EndIf
+	EndIf
+	SetCall writeres padwrite(hfile,padvalue)
+	Return writeres
+EndFunction
+
+#return writeres
+Function padsec(data hfile,data value,data pad)
+	Data valuetopad#1
+	SetCall valuetopad requiredpad(value,pad)
+	Data writeres#1
+	SetCall writeres padwrite(hfile,valuetopad)
+	Return writeres
+EndFunction
+
+#true if match or false
+Function filepathdelims(char chr)
+	Char bslash=asciibs
+	Char slash=asciislash
+	Data true=TRUE
+	Data false=FALSE
+	If chr=bslash
+		Return true
+	EndIf
+	If chr=slash
+		Return true
+	EndIf
+	Return false
+EndFunction
+
+#folders ('c:\folder\file.txt' will be pointer starting at 'file.txt')
+Function endoffolders(ss path)
+	sd sz
+    setcall sz strlen(path)
+    ss cursor
+    set cursor path
+    add cursor sz
+    sd i=0
+    while i<sz
+        dec cursor
+        sd bool
+        setcall bool filepathdelims(cursor#)
+        if bool=(TRUE)
+			inc cursor
+            return cursor
+        endif
+        inc i
+    endwhile
+    return path
+EndFunction
+
+#chdir
+function changedir(ss path)
+	sd testsamefolder
+	data null=0
+	data chdirok=chdirok
+	data chdirresult#1
+
+	setcall testsamefolder strlen(path)
+	if testsamefolder=null
+		return chdirok
+	endif
+	SetCall chdirresult chdir(path)
+	return chdirresult
+endfunction
+
+#lseek
+function seekfile(sd file,sd n,sd whence,sv perr)
+	sd p;setcall p lseek(file,n,whence)
+	if p=-1    #see the other lseek
+		set perr# "lseek error"
+	endif
+	return p
+endfunction
+
+#err
+function readfile(sd file,sd mem,sd len)
+	sd sz;setcall sz read(file,mem,len)
+	if sz!=len
+		return "File read error."
+	endif
+	return (noerror)
+endfunction
+
+#################Mixt
+#offset is when wanting to put the content at the allocation+offset
+Function file_get_content_ofs(str path,data ptrsize,data ptrmem,data offset)
+	Data err#1
+	Data noerr=noerror
+
+	Data file#1
+	Data ptrfile^file
+
+	Data ordflag=_open_read
+	SetCall err openfile(ptrfile,path,ordflag)
+	If err!=noerr
+		Return err
+	EndIf
+
+	Data size#1
+	Data seek_set=SEEK_SET
+	Data seek_end=SEEK_END
+	SetCall size lseek(file,0,seek_end)   #off_t is signed on elf32(ff... on c is only -1 at if, not 4billions...)
+	If size!=-1
+		#a simple test is showing that gedit can write, rm can delete, this is not exclusive
+		#The disk space won't be released until the last process with an open file descriptor for the file finally closes the file.
+		call lseek(file,0,seek_set)
+		#offset here
+		add size offset       ##this is only with MAX_PATH more on a int file size
+		#setcall err addfull(offset,#size)
+		SetCall err memoryalloc(size,ptrmem)
+		If err=noerr
+			value mem#1
+			Set mem ptrmem#
+
+			#and offset here
+			add mem offset
+			Set ptrsize# size
+			sub size offset
+			#
+
+			setcall err readfile(file,mem,size)
+			if err!=(noerror)
+				call free(ptrmem#)
+			endif
+		EndIf
+	else
+		set err "File length function error."
+	endelse
+	Call close(file)
+	return err
+EndFunction
+
+#err
+#function addfull(sd u,sv ps)
+#	add ps# u
+#	if u>=0
+#		return (noerror)
+#	endif
+#	if ps#<0
+#		return (noerror)
+#	endif
+#	return "Overflow at two numbers."
+#endfunction
+
+#return remainder
+Function remainder(data quotient,data dividend)
+    Data returnval#1
+	Set returnval quotient
+	Div quotient dividend
+	Mult quotient dividend
+	Sub returnval quotient
+	Return returnval
+EndFunction
+
+#return neg(nr)
+Function neg(data nr)
+	Data negative#1
+	Set negative nr
+	Sub nr negative
+	Sub nr negative
+	Return nr
+EndFunction
+
+#void
+function clearmessage()
+	data ptrallocerrormsg%ptrallocerrormsg
+	data null=NULL
+	If ptrallocerrormsg#!=null
+		Call free(ptrallocerrormsg#)
+		#if the error from file_get.. is from open here is ok, else if is only a str err alloc was not
+		set ptrallocerrormsg# null
+	EndIf
+endfunction
+
+#void
+function safeMessage(str text)
+	call Message(text)
+	#here if display msg only
+	call clearmessage()
+endfunction
+
+#err
+function compareagainstmaxpath(data sizetocompare)
+	data flag_max_path=flag_MAX_PATH
+	if sizetocompare>flag_max_path
+		char greaterthanmax="A file path size is greater than maximum number."
+		str greater^greaterthanmax
+		return greater
+	else
+		data noerr=noerror
+		return noerr
+	endelse
+endfunction
--- ocompiler-1.orig/src/files/functions/commons/comfn.s
+++ /dev/null
@@ -1,450 +0,0 @@
-
-#################Memory
-#err
-Function memrealloc(data ptrpointer,data size)
-	Data newpointer#1
-	Data oldpointer#1
-	Set oldpointer ptrpointer#
-	SetCall newpointer realloc(oldpointer,size)
-	Data null=NULL
-	If newpointer=null
-		Char newmem="Memory allocation error."
-		Data pnewmem^newmem
-		Return pnewmem
-	EndIf
-	Set ptrpointer# newpointer
-	Data noerr=noerror
-	Return noerr
-EndFunction
-#err
-Function mem_alloc(sd size,sv p)
-	sd mem
-	setcall mem malloc(size)
-	if mem!=(NULL)
-		set p# mem
-		return (noerror)
-	endif
-	return "malloc error"
-EndFunction
-
-#err
-Function memoryalloc(data pathsize,data memptr)
-	Data err#1
-	Data null=NULL
-	Set memptr# null
-	SetCall err memrealloc(memptr,pathsize)
-	Return err
-EndFunction
-
-#null or ptr
-Function memalloc(data pathsize)
-	Data errmsg#1
-	Data mem#1
-	Data memptr^mem
-	SetCall errmsg memoryalloc(pathsize,memptr)
-	Data null=NULL
-	Data noerr=noerror
-	If errmsg=noerr
-		Return mem
-	Else
-		Call Message(errmsg)
-		Return null
-	EndElse
-EndFunction
-
-
-#null or ptr
-Function memcalloc(data pathsize)
-	Data path=0
-	Data null=NULL
-	SetCall path memalloc(pathsize)
-	If path=null
-		Return null
-	EndIf
-	Call memset(path,null,pathsize)
-	Return path
-EndFunction
-
-#0 equal -1 not
-Function memcmp(str m1,str m2,data size)
-	Data zero=0
-
-	Data equal=0
-	Data notequal=-1
-
-	Char c1#1
-	Char c2#1
-	While size!=zero
-		Set c1 m1#
-		Set c2 m2#
-		If c1!=c2
-			Return notequal
-		EndIf
-		Inc m1
-		Inc m2
-		Dec size
-	EndWhile
-	Return equal
-EndFunction
-
-#sizeof the string
-Function strlen(str str)
-	Char term={0}
-	Char byte#1
-	Data sz#1
-	Data zero=0
-	Set sz zero
-	Set byte str#
-	While byte!=term
-		Inc str
-		Inc sz
-		Set byte str#
-	EndWhile
-	Return sz
-EndFunction
-
-#null or buffer
-Function printbuf(sd format,sd message,sd s1,sd nr,sd n1,sd n2)
-	Data bufsize#1
-	SetCall bufsize strlen(format)
-	addCall bufsize strlen(message)
-	addCall bufsize strlen(s1)
-	if nr>0
-		add bufsize (dw_char)
-		if nr>1
-			add bufsize (dw_char)
-		endif
-	endif
-
-	Str buf#1
-	SetCall buf memalloc(bufsize)
-	Data null=NULL
-	If buf=null
-		Return null
-	EndIf
-	call sprintf(buf,format,message,s1,n1,n2)
-	Return buf
-EndFunction
-
-#str1/newPointer
-function errorDefOut(str str1,str str2)
-	str format="%s%s"
-	data ptrallocerrormsg%ptrallocerrormsg
-	SetCall ptrallocerrormsg# printbuf(format,str1,str2,0)
-	data null=NULL
-	If ptrallocerrormsg#=null
-		return str1
-	EndIf
-	return ptrallocerrormsg#
-endfunction
-
-#################Files and Folders
-#err
-Function openfile(data pfile,str path,data oflag)
-	sd permission
-	sd creat_test;set creat_test oflag;and creat_test (flag_O_CREAT);if creat_test!=0
-		set permission (pmode_mode);endif
-	Data openfalse=openno
-	SetCall pfile# open(path,oflag,permission)
-	If pfile#=openfalse
-		str errorreturn#1
-		Str fileOpenErr="Cannot open a file:"
-		setcall errorreturn errorDefOut(fileOpenErr,path)
-		Return errorreturn
-	EndIf
-	Data noerr=noerror
-	Return noerr
-EndFunction
-#err
-function openfile_write_add_extension(ss path,ss extension,sd popen)
-	sd er
-	setcall er openfile_mode_add_extension(path,extension,popen,(_open_write))
-	return er
-endfunction
-#err
-function openfile_mode_add_extension(ss path,ss extension,sd popen,sd mod)
-	sd er
-	setcall er maxpathverif(path,extension)
-	if er=(noerror)
-		ss c;set c path
-		addcall c strlen(path)
-		ss b;setcall b strlen(extension)
-		inc b
-		call memtomem(c,extension,b)
-		setcall er openfile(popen,path,mod)
-		set c# (asciinul)  #required in all cases
-	endif
-	return er
-endfunction
-
-char writefile_err="Cannot write data to a file."
-const writefile_err_p^writefile_err
-#return _write (-1 or wrln)
-Function writefile(data hfile,str buf,data ln)
-	sd writeres
-	SetCall writeres write(hfile,buf,ln)
-	If writeres!=ln
-		sd writeerr%writefile_err_p
-		Call Message(writeerr)
-		Return (writeno)
-	EndIf
-	Return writeres
-EndFunction
-#err
-Function writefile_errversion(data hfile,str buf,data ln)
-	sd writeres
-	SetCall writeres write(hfile,buf,ln)
-	If writeres!=ln
-		sd writeerr%writefile_err_p
-		Return writeerr
-	EndIf
-	Return (noerror)
-EndFunction
-
-#return required pad, so value can be a multiple of pad
-Function requiredpad(data value,data pad)
-	Data integers#1
-	Set integers value
-	Div integers pad
-	Mult integers pad
-	Sub value integers
-
-	Data zero=0
-	If value=zero
-		return zero
-	EndIf
-	Sub pad value
-	Return pad
-EndFunction
-
-#return writefile
-Function padwrite(data hfile,data size)
-	Data padmem#1
-	Data null=NULL
-	Data writefalse=writeno
-	SetCall padmem memcalloc(size)
-	If padmem=null
-		return writefalse
-	EndIf
-	Data writeres#1
-	SetCall writeres writefile(hfile,padmem,size)
-	Return writeres
-EndFunction
-
-#return writefile
-#write ln, and walk size value to pad
-Function paddedwrite(data hfile,str buf,data ln,data pad)
-	Data zero=0
-	Data padvalue#1
-	Set padvalue pad
-	Div padvalue padvalue
-	If padvalue=pad
-		Set padvalue zero
-	Else
-		Set padvalue pad
-	EndElse
-	Data writeres#1
-	If ln!=zero
-		Data writefalse=writeno
-		SetCall writeres writefile(hfile,buf,ln)
-		If writeres=writefalse
-			Return writefalse
-		EndIf
-
-		SetCall padvalue requiredpad(ln,pad)
-		If padvalue=zero
-			Return writeres
-		EndIf
-	EndIf
-	SetCall writeres padwrite(hfile,padvalue)
-	Return writeres
-EndFunction
-
-#return writeres
-Function padsec(data hfile,data value,data pad)
-	Data valuetopad#1
-	SetCall valuetopad requiredpad(value,pad)
-	Data writeres#1
-	SetCall writeres padwrite(hfile,valuetopad)
-	Return writeres
-EndFunction
-
-#true if match or false
-Function filepathdelims(char chr)
-	Char bslash=asciibs
-	Char slash=asciislash
-	Data true=TRUE
-	Data false=FALSE
-	If chr=bslash
-		Return true
-	EndIf
-	If chr=slash
-		Return true
-	EndIf
-	Return false
-EndFunction
-
-#folders ('c:\folder\file.txt' will be pointer starting at 'file.txt')
-Function endoffolders(ss path)
-	sd sz
-    setcall sz strlen(path)
-    ss cursor
-    set cursor path
-    add cursor sz
-    sd i=0
-    while i<sz
-        dec cursor
-        sd bool
-        setcall bool filepathdelims(cursor#)
-        if bool=(TRUE)
-			inc cursor
-            return cursor
-        endif
-        inc i
-    endwhile
-    return path
-EndFunction
-
-#chdir
-function changedir(ss path)
-	sd testsamefolder
-	data null=0
-	data chdirok=chdirok
-	data chdirresult#1
-
-	setcall testsamefolder strlen(path)
-	if testsamefolder=null
-		return chdirok
-	endif
-	SetCall chdirresult chdir(path)
-	return chdirresult
-endfunction
-
-#lseek
-function seekfile(sd file,sd n,sd whence,sv perr)
-	sd p;setcall p lseek(file,n,whence)
-	if p=-1    #see the other lseek
-		set perr# "lseek error"
-	endif
-	return p
-endfunction
-
-#err
-function readfile(sd file,sd mem,sd len)
-	sd sz;setcall sz read(file,mem,len)
-	if sz!=len
-		return "File read error."
-	endif
-	return (noerror)
-endfunction
-
-#################Mixt
-#offset is when wanting to put the content at the allocation+offset
-Function file_get_content_ofs(str path,data ptrsize,data ptrmem,data offset)
-	Data err#1
-	Data noerr=noerror
-
-	Data file#1
-	Data ptrfile^file
-
-	Data ordflag=_open_read
-	SetCall err openfile(ptrfile,path,ordflag)
-	If err!=noerr
-		Return err
-	EndIf
-
-	Data size#1
-	Data seek_set=SEEK_SET
-	Data seek_end=SEEK_END
-	SetCall size lseek(file,0,seek_end)   #off_t is signed on elf32(ff... on c is only -1 at if, not 4billions...)
-	If size!=-1
-		#a simple test is showing that gedit can write, rm can delete, this is not exclusive
-		#The disk space won't be released until the last process with an open file descriptor for the file finally closes the file.
-		call lseek(file,0,seek_set)
-		#offset here
-		add size offset       ##this is only with MAX_PATH more on a int file size
-		#setcall err addfull(offset,#size)
-		SetCall err memoryalloc(size,ptrmem)
-		If err=noerr
-			value mem#1
-			Set mem ptrmem#
-
-			#and offset here
-			add mem offset
-			Set ptrsize# size
-			sub size offset
-			#
-
-			setcall err readfile(file,mem,size)
-			if err!=(noerror)
-				call free(ptrmem#)
-			endif
-		EndIf
-	else
-		set err "File length function error."
-	endelse
-	Call close(file)
-	return err
-EndFunction
-
-#err
-#function addfull(sd u,sv ps)
-#	add ps# u
-#	if u>=0
-#		return (noerror)
-#	endif
-#	if ps#<0
-#		return (noerror)
-#	endif
-#	return "Overflow at two numbers."
-#endfunction
-
-#return remainder
-Function remainder(data quotient,data dividend)
-    Data returnval#1
-	Set returnval quotient
-	Div quotient dividend
-	Mult quotient dividend
-	Sub returnval quotient
-	Return returnval
-EndFunction
-
-#return neg(nr)
-Function neg(data nr)
-	Data negative#1
-	Set negative nr
-	Sub nr negative
-	Sub nr negative
-	Return nr
-EndFunction
-
-#void
-function clearmessage()
-	data ptrallocerrormsg%ptrallocerrormsg
-	data null=NULL
-	If ptrallocerrormsg#!=null
-		Call free(ptrallocerrormsg#)
-		#if the error from file_get.. is from open here is ok, else if is only a str err alloc was not
-		set ptrallocerrormsg# null
-	EndIf
-endfunction
-
-#void
-function safeMessage(str text)
-	call Message(text)
-	#here if display msg only
-	call clearmessage()
-endfunction
-
-#err
-function compareagainstmaxpath(data sizetocompare)
-	data flag_max_path=flag_MAX_PATH
-	if sizetocompare>flag_max_path
-		char greaterthanmax="A file path size is greater than maximum number."
-		str greater^greaterthanmax
-		return greater
-	else
-		data noerr=noerror
-		return noerr
-	endelse
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/commons/getcommand.oc
@@ -0,0 +1,687 @@
+
+
+Const spacereq=1
+Const spacenotreq=0
+
+#with caution like elseif before else for getcommand comparations, only at space not required (elseif/else, endelseif/endelse, end../end, return/ret)
+#and shl1,i3,... are ok, only AZ are going to az
+
+Char cCOMMENT_c={commentascii,0}
+Char cDATA_c="DATA";Char cSTR_c="STR";Char cCHAR_c="CHAR";Char cWORD_c="WORD";Char cSD_c="SD";Char cSS_c="SS";Char cSV_c="SV";Char cSW_c="SW"
+	Char cVDATA_c="VDATA";Char cVSTR_c="VSTR";Char cVALUE_c="VALUE";Char cVWORD_c="VWORD"
+	Char cDATAX_c="DATAX";Char cSTRX_c="STRX";Char cCHARX_c="CHARX";Char cWORDX_c="WORDX"
+	Char cVDATAX_c="VDATAX";Char cVSTRX_c="VSTRX";Char cVALUEX_c="VALUEX";Char cVWORDX_c="VWORDX"
+	Char cCONST_c="CONST"
+Char cSET_c="SET";Char cADD_c="ADD";Char cSUB_c="SUB";Char cMULT_c="MULT";Char cDIV_c="DIV";Char cDIVU_c="DIVU";Char cREM_c="REM";Char cREMU_c="REMU";Char cAND_c="AND";Char cOR_c="OR";Char cXOR_c="XOR"
+Char cRETURN_c="RETURN";Char cINC_c="INC";Char cDEC_c="DEC";Char cINCST_c="INCST";Char cDECST_c="DECST";Char cNEG_c="NEG";Char cNOT_c="NOT";Char cSHL1_c="SHL1";Char cSHR1_c="SHR1";Char cSAR1_c="SAR1";Char cEXIT_c="EXIT"
+Char cCALL_c="CALL";Char cCALLX_c="CALLX"
+Char cIF_c="IF";Char cELSEIF_c="ELSEIF";Char cELSE_c="ELSE";Char cENDIF_c="ENDIF";Char cENDELSEIF_c="ENDELSEIF";Char cENDELSE_c="ENDELSE";Char cWHILE_c="WHILE";Char cENDWHILE_c="ENDWHILE";Char cBREAK_c="BREAK";Char cCONTINUE_c="CONTINUE"
+Char cIMPORT_c="IMPORT";Char cIMPORTX_c="IMPORTX"
+Char cFUNCTION_c="FUNCTION";Char cFUNCTIONX_c="FUNCTIONX";Char cENTRY_c="ENTRY";Char cENTRYRAW_c="ENTRYRAW"
+Char cENDFUNCTION_c="ENDFUNCTION"
+Char cEND_c="END"
+Char cRET_c="RET"
+Char cINCLUDE_c="INCLUDE";Char cEINCLUDE_c="EINCLUDE"
+Char cFORMAT_c="FORMAT"
+Char cAFTERCALLIMPORT_c="AFTERCALLIMPORT";Char cAFTERCALL_c="AFTERCALL"
+Char cAFTERCALLENABLE_c="AFTERCALLENABLE";Char cAFTERCALLDISABLE_c="AFTERCALLDISABLE"
+Char cCALLEX_c="CALLEX";Char cCALLEXX_c="CALLEXX"
+Char cLIBRARY_c="LIBRARY"
+Char cHEX_c="HEX"
+Char cOVERRIDE_c="OVERRIDE"
+Char cORPHAN_c="ORPHAN"
+Char cI3_c="I3"
+
+const not_a_subtype=-1
+
+const coms_start=\
+	Const cCOMMENT=\-coms_start
+		data cCOMMENT_s^cCOMMENT_c
+Const comsloc^cCOMMENT_s
+		Data *=cCOMMENT
+		Data *#1
+		Data *=spacenotreq
+const commandsvars_start=\
+	Const cDECLARE=\-coms_start
+	Const cDECLARE_top=\
+		Const cDATA=\-cDECLARE_top
+			data cDATA_s^cDATA_c
+Const cdataloc^cDATA_s
+			Data *=cDECLARE
+			Data *=cDATA
+			Data *=spacereq
+		Const cSTR=\-cDECLARE_top
+Const com_size=cSTR-cDATA
+			data *^cSTR_c
+			Data *=cDECLARE
+			Data *=cSTR
+			Data *=spacereq
+		Const cCHAR=\-cDECLARE_top
+			data *^cCHAR_c
+			Data *=cDECLARE
+			Data *=cCHAR
+			Data *=spacereq
+		Const cWORD=\-cDECLARE_top
+			data *^cWORD_c
+			Data *=cDECLARE
+			Data *=cWORD
+			Data *=spacereq
+		Const cSD=\-cDECLARE_top
+			data *^cSD_c
+			Data *=cDECLARE
+			Data *=cSD
+			Data *=spacereq
+		Const cSS=\-cDECLARE_top
+			data *^cSS_c
+			Data *=cDECLARE
+			Data *=cSS
+			Data *=spacereq
+		Const cSV=\-cDECLARE_top
+			data *^cSV_c
+			Data *=cDECLARE
+			Data *=cSV
+			Data *=spacereq
+		Const cSW=\-cDECLARE_top
+			data *^cSW_c
+			Data *=cDECLARE
+			Data *=cSW
+			Data *=spacereq
+		Const cVDATA=\-cDECLARE_top
+			data *^cVDATA_c
+			Data *=cDECLARE
+			Data *=cVDATA
+			Data *=spacereq
+		Const cVSTR=\-cDECLARE_top
+			data *^cVSTR_c
+			Data *=cDECLARE
+			Data *=cVSTR
+			Data *=spacereq
+		Const cVALUE=\-cDECLARE_top
+			data *^cVALUE_c
+			Data *=cDECLARE
+			Data *=cVALUE
+			Data *=spacereq
+		Const cVWORD=\-cDECLARE_top
+			data *^cVWORD_c
+			Data *=cDECLARE
+			Data *=cVWORD
+			Data *=spacereq
+		Const cDATAX=\-cDECLARE_top
+			data *^cDATAX_c
+			Data *=cDECLARE
+			Data *=cDATAX
+			Data *=spacereq
+		Const cSTRX=\-cDECLARE_top
+			data *^cSTRX_c
+			Data *=cDECLARE
+			Data *=cSTRX
+			Data *=spacereq
+		Const cCHARX=\-cDECLARE_top
+			data *^cCHARX_c
+			Data *=cDECLARE
+			Data *=cCHARX
+			Data *=spacereq
+		Const cWORDX=\-cDECLARE_top
+			data *^cWORDX_c
+			Data *=cDECLARE
+			Data *=cWORDX
+			Data *=spacereq
+		Const cVDATAX=\-cDECLARE_top
+			data *^cVDATAX_c
+			Data *=cDECLARE
+			Data *=cVDATAX
+			Data *=spacereq
+		Const cVSTRX=\-cDECLARE_top
+			data *^cVSTRX_c
+			Data *=cDECLARE
+			Data *=cVSTRX
+			Data *=spacereq
+		Const cVALUEX=\-cDECLARE_top
+			data *^cVALUEX_c
+			Data *=cDECLARE
+			Data *=cVALUEX
+			Data *=spacereq
+		Const cVWORDX=\-cDECLARE_top
+			data *^cVWORDX_c
+			Data *=cDECLARE
+			Data *=cVWORDX
+			Data *=spacereq
+#numberofcommandsvars to set these commands to search for them at function parameter declare
+Const numberofcommandsvars=(\-commandsvars_start)/com_size
+		Const cCONST=\-cDECLARE_top
+			data *^cCONST_c
+			Data *=cDECLARE
+			Data *=cCONST
+			Data *=spacereq
+	Const cPRIMSEC=\-coms_start
+	Const cPRIMSEC_top=\
+		Const cSET=\-cPRIMSEC_top
+			data *^cSET_c
+			Data *=cPRIMSEC
+			Data *=cSET
+			Data *=spacereq
+		Const cADD=\-cPRIMSEC_top
+			data *^cADD_c
+			Data *=cPRIMSEC
+			Data *=cADD
+			Data *=spacereq
+		Const cSUB=\-cPRIMSEC_top
+			data *^cSUB_c
+			Data *=cPRIMSEC
+			Data *=cSUB
+			Data *=spacereq
+		Const cMULT=\-cPRIMSEC_top
+			data *^cMULT_c
+			Data *=cPRIMSEC
+			Data *=cMULT
+			Data *=spacereq
+		Const cDIV=\-cPRIMSEC_top
+			data *^cDIV_c
+			Data *=cPRIMSEC
+			Data *=cDIV
+			Data *=spacereq
+		Const cDIVU=\-cPRIMSEC_top
+			data *^cDIVU_c
+			Data *=cPRIMSEC
+			Data *=cDIVU
+			Data *=spacereq
+		Const cREM=\-cPRIMSEC_top
+			data *^cREM_c
+			Data *=cPRIMSEC
+			Data *=cREM
+			Data *=spacereq
+		Const cREMU=\-cPRIMSEC_top
+			data *^cREMU_c
+			Data *=cPRIMSEC
+			Data *=cREMU
+			Data *=spacereq
+		Const cAND=\-cPRIMSEC_top
+			data *^cAND_c
+			Data *=cPRIMSEC
+			Data *=cAND
+			Data *=spacereq
+		Const cOR=\-cPRIMSEC_top
+			data *^cOR_c
+			Data *=cPRIMSEC
+			Data *=cOR
+			Data *=spacereq
+		Const cXOR=\-cPRIMSEC_top
+			data *^cXOR_c
+			Data *=cPRIMSEC
+			Data *=cXOR
+			Data *=spacereq
+		Const cCALLEX_primsec=\-cPRIMSEC_top
+	Const cONEARG=\-coms_start
+	Const cONEARG_top=\
+		Const cRETURN=\-cONEARG_top
+			data *^cRETURN_c
+			Data *=cONEARG
+			Data *=cRETURN
+			Data *=spacereq
+		Const cINC=\-cONEARG_top
+			data *^cINC_c
+			Data *=cONEARG
+			Data *=cINC
+			Data *=spacereq
+		Const cDEC=\-cONEARG_top
+			data *^cDEC_c
+			Data *=cONEARG
+			Data *=cDEC
+			Data *=spacereq
+		Const cINCST=\-cONEARG_top
+			data *^cINCST_c
+			Data *=cONEARG
+			Data *=cINCST
+			Data *=spacereq
+		Const cDECST=\-cONEARG_top
+			data *^cDECST_c
+			Data *=cONEARG
+			Data *=cDECST
+			Data *=spacereq
+		Const cNEG=\-cONEARG_top
+			data *^cNEG_c
+			Data *=cONEARG
+			Data *=cNEG
+			Data *=spacereq
+		Const cNOT=\-cONEARG_top
+			data *^cNOT_c
+			Data *=cONEARG
+			Data *=cNOT
+			Data *=spacereq
+		Const cSHL1=\-cONEARG_top
+			data *^cSHL1_c
+			Data *=cONEARG
+			Data *=cSHL1
+			Data *=spacereq
+		Const cSHR1=\-cONEARG_top
+			data *^cSHR1_c
+			Data *=cONEARG
+			Data *=cSHR1
+			Data *=spacereq
+		Const cSAR1=\-cONEARG_top
+			data *^cSAR1_c
+			Data *=cONEARG
+			Data *=cSAR1
+			Data *=spacereq
+		Const cEXIT=\-cONEARG_top
+			data *^cEXIT_c
+			Data *=cONEARG
+			Data *=cEXIT
+			Data *=spacereq
+	Const cCALL=\-coms_start
+		data *^cCALL_c
+		Data *=cCALL
+		Data *=0
+		Data *=spacereq
+		data *^cCALLX_c
+		Data *=cCALL
+		Data *=x_callx_flag
+		Data *=spacereq
+	Const cCONDITIONS=\-coms_start
+	Const cCONDITIONS_top=\
+		Const cIF=\-cCONDITIONS_top
+			data *^cIF_c
+			Data *=cCONDITIONS
+			Data *=cIF
+			Data *=spacereq
+		Const cELSEIF=\-cCONDITIONS_top
+			data *^cELSEIF_c
+			Data *=cCONDITIONS
+			Data *=cELSEIF
+			Data *=spacereq
+		Const cELSE=\-cCONDITIONS_top
+			data *^cELSE_c
+			Data *=cCONDITIONS
+			Data *=cELSE
+			Data *=spacenotreq
+		Const cENDIF=\-cCONDITIONS_top
+			data *^cENDIF_c
+			Data *=cCONDITIONS
+			Data *=cENDIF
+			Data *=spacenotreq
+		Const cENDELSEIF=\-cCONDITIONS_top
+			data *^cENDELSEIF_c
+			Data *=cCONDITIONS
+			Data *=cENDELSEIF
+			Data *=spacenotreq
+		Const cENDELSE=\-cCONDITIONS_top
+			data *^cENDELSE_c
+			Data *=cCONDITIONS
+			Data *=cENDELSE
+			Data *=spacenotreq
+		Const cWHILE=\-cCONDITIONS_top
+			data *^cWHILE_c
+			Data *=cCONDITIONS
+			Data *=cWHILE
+			Data *=spacereq
+		Const cENDWHILE=\-cCONDITIONS_top
+			data *^cENDWHILE_c
+			Data *=cCONDITIONS
+			Data *=cENDWHILE
+			Data *=spacenotreq
+		Const cBREAK=\-cCONDITIONS_top
+			data *^cBREAK_c
+			Data *=cCONDITIONS
+			Data *=cBREAK
+			Data *=spacenotreq
+		Const cCONTINUE=\-cCONDITIONS_top
+			data *^cCONTINUE_c
+			Data *=cCONDITIONS
+			Data *=cCONTINUE
+			Data *=spacenotreq
+	Const cIMPORTLINK=\-coms_start
+		const cIMPORT=Xfile_import_normal
+			data *^cIMPORT_c
+			Data *=cIMPORTLINK
+			Data *=cIMPORT
+			Data *=spacereq
+		const cIMPORTX=Xfile_import_extern
+			data *^cIMPORTX_c
+			Data *=cIMPORTLINK
+			Data *=cIMPORTX
+			Data *=spacereq
+	Const cSTARTFUNCTION=\-coms_start
+		Const cFUNCTION=Xfile_function_tintern
+			data *^cFUNCTION_c
+			Data *=cSTARTFUNCTION
+			Data *=cFUNCTION
+			Data *=spacereq
+		Const cFUNCTIONX=Xfile_function_extern
+			data *^cFUNCTIONX_c
+			Data *=cSTARTFUNCTION
+			Data *=cFUNCTIONX
+			Data *=spacereq
+		Const cENTRY=Xfile_function_entry
+			data *^cENTRY_c
+			Data *=cSTARTFUNCTION
+			Data *=cENTRY
+			Data *=spacereq
+		Const cENTRYRAW=Xfile_function_traw
+			data *^cENTRYRAW_c
+			Data *=cSTARTFUNCTION
+			Data *=cENTRYRAW
+			Data *=spacereq
+	Const cENDFUNCTION=\-coms_start
+		data *^cENDFUNCTION_c
+		Data *=cENDFUNCTION
+		Data *#1
+		Data *=spacenotreq
+	Const cEND=\-coms_start
+		data *^cEND_c
+		Data *=cEND
+		Data *#1
+		Data *=spacenotreq
+	Const cRET=\-coms_start
+		data *^cRET_c
+		Data *=cRET
+		Data *#1
+		Data *=spacenotreq
+	Const cINCLUDELINK=\-coms_start
+		Const cINCLUDE=Xfile_include_normal
+			data *^cINCLUDE_c
+			Data *=cINCLUDELINK
+			Data *=cINCLUDE
+			Data *=spacereq
+		Const cEINCLUDE=Xfile_include_extern
+			data *^cEINCLUDE_c
+			Data *=cINCLUDELINK
+			Data *=cEINCLUDE
+			Data *=spacereq
+	Const cFORMAT=\-coms_start
+		data *^cFORMAT_c
+		Data *=cFORMAT
+		Data *#1
+		Data *=spacereq
+# aftercall can be at function parameters but the get_img_vdata_dataReg() is set inside and codding must be done for not a big deal
+	Const cDECLAREAFTERCALL=\-coms_start
+	Const cDECLAREAFTERCALL_top=\
+		Const cAFTERCALLIMPORT=\-cDECLAREAFTERCALL_top
+			data *^cAFTERCALLIMPORT_c
+			Data *=cDECLAREAFTERCALL
+			Data *=cAFTERCALLIMPORT
+			Data *=spacereq
+		Const cAFTERCALL=\-cDECLAREAFTERCALL_top
+			data *^cAFTERCALL_c
+			Data *=cDECLAREAFTERCALL
+			Data *=cAFTERCALL
+			Data *=spacereq
+	Const cMANIPULATEAFTERCALL=\-coms_start
+	Const cMANIPULATEAFTERCALL_top=\
+		Const cAFTERCALLENABLE=\-cMANIPULATEAFTERCALL_top
+			data *^cAFTERCALLENABLE_c
+			Data *=cMANIPULATEAFTERCALL
+			Data *=cAFTERCALLENABLE
+			Data *=spacenotreq
+		Const cAFTERCALLDISABLE=\-cMANIPULATEAFTERCALL_top
+			data *^cAFTERCALLDISABLE_c
+			Data *=cMANIPULATEAFTERCALL
+			Data *=cAFTERCALLDISABLE
+			Data *=spacenotreq
+	Const cCALLEX=\-coms_start
+		data *^cCALLEX_c
+		Data *=cCALLEX
+		Data *=0
+		Data *=spacereq
+		data *^cCALLEXX_c
+		Data *=cCALLEX
+		Data *=x_callx_flag
+		Data *=spacereq
+	Const cLIBRARY=\-coms_start
+		data *^cLIBRARY_c
+		Data *=cLIBRARY
+		Data *#1
+		Data *=spacereq
+	Const cHEX=\-coms_start
+		data *^cHEX_c
+		Data *=cHEX
+		Data *#1
+		Data *=spacereq
+	Const cOVERRIDE=\-coms_start
+		data *^cOVERRIDE_c
+		Data *=cOVERRIDE
+		Data *#1
+		Data *=spacereq
+	Const cORPHAN=\-coms_start
+		data *^cORPHAN_c
+		Data *=cORPHAN
+		Data *#1
+		Data *=spacereq
+	Const cI3=\-coms_start
+		data *^cI3_c
+		Data *=cI3
+		Data *#1
+		Data *=spacenotreq
+Const numberofcommands=(\-coms_start)/com_size
+Const Error=\-coms_start
+
+Data pointers#numberofcommands+1
+Const compointersloc^pointers
+
+Data pointersvars#numberofcommandsvars+1
+Const compointersvarsloc^pointersvars
+
+#at fn
+const x_func_flag=0x80000000   #at def, varargs
+
+#at ...call...
+const x_callx_flag=0x80000000  #call a variable function import like functionx importx
+const x_callg_flag=0x40000000  #skip aftercall
+
+const call_ret_flag=0x20000000 #at call
+const x_call_flag=0x10000000   #at setcall... . attention that at write_func is asking about callret and setcall does not have that
+
+const x_call_flags=x_call_flag|x_callx_flag|x_callg_flag
+
+#declare coresp
+function commandSubtypeDeclare_to_typenumber(sd subtype,sd p_is_expand)
+#these numbers will be used at getstruct directly
+	if subtype=(cCONST)
+		return (constantsnumber)
+	endif
+	div subtype (com_size)
+	if subtype>=(xnumbers)
+		if subtype>=(xvnumbers)
+			sub subtype (xnumbers-totalmemvariables)
+		else
+			sub subtype (xnumbers)
+		endelse
+		set p_is_expand# (TRUE)
+	else
+		set p_is_expand# (FALSE)   #this, if typenumber is constant, atm is not used
+	endelse
+	return subtype
+endfunction
+#set errormsg to pointer error or return the find
+Function getcommand(value pcontent,data psize,data ptrsubtype,data ptrerrormsg,data pointercommands)
+	Data zero=0
+	Data command#1
+	Data result#1
+	Data cursor#1
+	Data true=TRUE
+
+	Data dsz=dwsz
+
+	valuex start#1;set start pcontent#
+	Set cursor pointercommands#
+	While cursor!=zero
+		Data offset#1
+		Set offset cursor#
+		Add cursor dsz
+		Set command cursor#
+		Add cursor dsz
+		Set ptrsubtype# cursor#
+
+		Data spacebool#1
+		Add cursor dsz
+		Set spacebool cursor#
+
+		#implement for Set[X]Call
+		Char calldata="CALL"
+		vStr call^calldata
+		vstr xstr="X"
+		vstr skipaftercall="G"
+		value pointer#1;data sz#1
+
+		ss extstr=NULL
+
+		sd extbooldata=FALSE
+		sv extbool^extbooldata
+		sd intercursors=NULL
+		set pointer start
+
+		If command=(cPRIMSEC)
+			Set extstr xstr
+			set intercursors #pointer
+		elseif command=(cCALL)
+		vstr call_ret_str="RET"
+			set extstr call_ret_str
+			set intercursors #pointer
+		Elseif command=(cSTARTFUNCTION)
+			sd x_fn;setcall x_fn func_xfile(ptrsubtype#)
+			if x_fn!=(Xfile_function_not_x)
+				Set extstr xstr ##varargs
+			endif
+		elseif command=(cCALLEX)
+			set extstr call_ret_str
+			set intercursors #pointer
+		endElseif
+
+		SetCall result stringsatmemspc(pcontent,psize,offset,spacebool,extstr,extbool,intercursors)
+		If extbooldata=true
+		#here firstAndSecond part was recognized
+			If command=(cPRIMSEC)
+				if result=(TRUE)
+				#setx
+					or ptrsubtype# (x_call_flag|x_callx_flag)
+					Return command
+				else
+					#here there was not a space
+					setcall result stratmemspc(#pointer,#sz,skipaftercall,spacebool)
+					if result=(TRUE)
+						or ptrsubtype# (x_call_flag|x_callx_flag|x_callg_flag)
+						set pcontent# pointer
+						set psize# sz
+						Return command
+					endif
+					#maybe is the deprecated ..xcall
+					setcall result stratmemspc(#pointer,#sz,call,spacebool)
+					if result=(TRUE)
+						#or first byte at subcommand to recognize the xcall at two args
+						or ptrsubtype# (x_call_flag|x_callx_flag)
+						set pcontent# pointer
+						set psize# sz
+						Return command
+					endif
+				endelse
+			Elseif result=(TRUE)
+				If command=(cSTARTFUNCTION)
+				#functionx/entry [x] , varargs
+					#allow the command at 64, there is a check inside parsefunc, and for xfile better to know
+					#sd for64;setcall for64 is_for_64()
+					#if for64==(TRUE)
+					or ptrsubtype# (x_func_flag)
+					#endif
+					return command
+				else
+				#call[ex][x]ret
+					or ptrsubtype# (call_ret_flag)
+					return command
+				endelse
+			endElseif
+		elseIf result=true
+		#here (first/onlyone)+-space was ok
+			Return command
+		elseif start!=pointer  ##here first was ok, but not extra part
+			if command=(cPRIMSEC)
+				setcall result stratmemspc(#pointer,#sz,skipaftercall,spacebool)
+				if result=(TRUE)
+					or ptrsubtype# (x_call_flag|x_callg_flag)
+					set pcontent# pointer
+					set psize# sz
+					Return command
+				endif
+				#maybe is the deprecated ..call
+				setcall result stratmemspc(#pointer,#sz,call,spacebool)
+				if result=(TRUE)
+					or ptrsubtype# (x_call_flag)
+					set pcontent# pointer
+					set psize# sz
+					Return command
+				endif
+				#break #don't want to remember this when having something like addend command, and who will wrong here?
+			else
+			#if command=(cCALL)
+			#if command=(cCALLEX)  #cSTARTFUNCTION is not coming here with intercursors=NULL
+				setcall result stratmemspc(#pointer,#sz,skipaftercall,spacebool)
+				if result=(TRUE)
+					or ptrsubtype# (x_callg_flag)
+					set pcontent# pointer
+					set psize# sz
+					Return command
+				endif
+			endelse
+		endelseIf
+		Add pointercommands dsz
+		Set cursor pointercommands#
+	EndWhile
+
+	Char _unrecCom="Unrecognized command/declaration name."
+	vStr unrecCom^_unrecCom
+	Set ptrerrormsg# unrecCom
+EndFunction
+
+
+
+Function sortcommands(sv pointerscursor,sd nrofcomms,sd datacursor)
+#it's that old strategy elseif will be only else if let unsorted, endelseif/endelse, maybe more
+	sd i=0
+#	Data sz#1
+#	Data j#1
+	Data dsize=dwsz
+#	Data szval#1
+#	Data ptrval#1
+#	Data ptrvalstand#1
+#	Data dataval#1
+
+	While i<nrofcomms
+#		SetCall sz strlen(datacursor#)
+#		Set j i
+#		Set ptrval pointerscursor
+#		Set ptrvalstand pointerscursor
+#		While zero<j
+#			Sub ptrval dsize
+#			Set dataval ptrval#
+#			SetCall szval strlen(dataval#)
+#			If szval>=sz
+#				Set j zero
+#			Else
+#				Set ptrvalstand# dataval
+#				Sub ptrvalstand dsize
+#				Dec j
+#			EndElse
+#		EndWhile
+#		Set ptrvalstand# datacursor
+		set pointerscursor# datacursor
+		Add pointerscursor dsize
+		Add datacursor dsize
+		Add datacursor dsize
+		Add datacursor dsize
+		Add datacursor dsize
+		Inc i
+	EndWhile
+	Set pointerscursor# (NULL)
+EndFunction
+
+Function sortallcommands()
+#put commands pointers at init
+	vdata commandscursorini%comsloc
+	vData pointerscursor%compointersloc
+	Data comms=numberofcommands
+
+	Call sortcommands(pointerscursor,comms,commandscursorini)
+
+	vData datacursorini%cdataloc
+	vData pointersvarscursor%compointersvarsloc
+	Data variables=numberofcommandsvars
+	Call sortcommands(pointersvarscursor,variables,datacursorini)
+EndFunction
--- ocompiler-1.orig/src/files/functions/commons/getcommand.s
+++ /dev/null
@@ -1,687 +0,0 @@
-
-
-Const spacereq=1
-Const spacenotreq=0
-
-#with caution like elseif before else for getcommand comparations, only at space not required (elseif/else, endelseif/endelse, end../end, return/ret)
-#and shl1,i3,... are ok, only AZ are going to az
-
-Char cCOMMENT_c={commentascii,0}
-Char cDATA_c="DATA";Char cSTR_c="STR";Char cCHAR_c="CHAR";Char cWORD_c="WORD";Char cSD_c="SD";Char cSS_c="SS";Char cSV_c="SV";Char cSW_c="SW"
-	Char cVDATA_c="VDATA";Char cVSTR_c="VSTR";Char cVALUE_c="VALUE";Char cVWORD_c="VWORD"
-	Char cDATAX_c="DATAX";Char cSTRX_c="STRX";Char cCHARX_c="CHARX";Char cWORDX_c="WORDX"
-	Char cVDATAX_c="VDATAX";Char cVSTRX_c="VSTRX";Char cVALUEX_c="VALUEX";Char cVWORDX_c="VWORDX"
-	Char cCONST_c="CONST"
-Char cSET_c="SET";Char cADD_c="ADD";Char cSUB_c="SUB";Char cMULT_c="MULT";Char cDIV_c="DIV";Char cDIVU_c="DIVU";Char cREM_c="REM";Char cREMU_c="REMU";Char cAND_c="AND";Char cOR_c="OR";Char cXOR_c="XOR"
-Char cRETURN_c="RETURN";Char cINC_c="INC";Char cDEC_c="DEC";Char cINCST_c="INCST";Char cDECST_c="DECST";Char cNEG_c="NEG";Char cNOT_c="NOT";Char cSHL1_c="SHL1";Char cSHR1_c="SHR1";Char cSAR1_c="SAR1";Char cEXIT_c="EXIT"
-Char cCALL_c="CALL";Char cCALLX_c="CALLX"
-Char cIF_c="IF";Char cELSEIF_c="ELSEIF";Char cELSE_c="ELSE";Char cENDIF_c="ENDIF";Char cENDELSEIF_c="ENDELSEIF";Char cENDELSE_c="ENDELSE";Char cWHILE_c="WHILE";Char cENDWHILE_c="ENDWHILE";Char cBREAK_c="BREAK";Char cCONTINUE_c="CONTINUE"
-Char cIMPORT_c="IMPORT";Char cIMPORTX_c="IMPORTX"
-Char cFUNCTION_c="FUNCTION";Char cFUNCTIONX_c="FUNCTIONX";Char cENTRY_c="ENTRY";Char cENTRYRAW_c="ENTRYRAW"
-Char cENDFUNCTION_c="ENDFUNCTION"
-Char cEND_c="END"
-Char cRET_c="RET"
-Char cINCLUDE_c="INCLUDE";Char cEINCLUDE_c="EINCLUDE"
-Char cFORMAT_c="FORMAT"
-Char cAFTERCALLIMPORT_c="AFTERCALLIMPORT";Char cAFTERCALL_c="AFTERCALL"
-Char cAFTERCALLENABLE_c="AFTERCALLENABLE";Char cAFTERCALLDISABLE_c="AFTERCALLDISABLE"
-Char cCALLEX_c="CALLEX";Char cCALLEXX_c="CALLEXX"
-Char cLIBRARY_c="LIBRARY"
-Char cHEX_c="HEX"
-Char cOVERRIDE_c="OVERRIDE"
-Char cORPHAN_c="ORPHAN"
-Char cI3_c="I3"
-
-const not_a_subtype=-1
-
-const coms_start=\
-	Const cCOMMENT=\-coms_start
-		data cCOMMENT_s^cCOMMENT_c
-Const comsloc^cCOMMENT_s
-		Data *=cCOMMENT
-		Data *#1
-		Data *=spacenotreq
-const commandsvars_start=\
-	Const cDECLARE=\-coms_start
-	Const cDECLARE_top=\
-		Const cDATA=\-cDECLARE_top
-			data cDATA_s^cDATA_c
-Const cdataloc^cDATA_s
-			Data *=cDECLARE
-			Data *=cDATA
-			Data *=spacereq
-		Const cSTR=\-cDECLARE_top
-Const com_size=cSTR-cDATA
-			data *^cSTR_c
-			Data *=cDECLARE
-			Data *=cSTR
-			Data *=spacereq
-		Const cCHAR=\-cDECLARE_top
-			data *^cCHAR_c
-			Data *=cDECLARE
-			Data *=cCHAR
-			Data *=spacereq
-		Const cWORD=\-cDECLARE_top
-			data *^cWORD_c
-			Data *=cDECLARE
-			Data *=cWORD
-			Data *=spacereq
-		Const cSD=\-cDECLARE_top
-			data *^cSD_c
-			Data *=cDECLARE
-			Data *=cSD
-			Data *=spacereq
-		Const cSS=\-cDECLARE_top
-			data *^cSS_c
-			Data *=cDECLARE
-			Data *=cSS
-			Data *=spacereq
-		Const cSV=\-cDECLARE_top
-			data *^cSV_c
-			Data *=cDECLARE
-			Data *=cSV
-			Data *=spacereq
-		Const cSW=\-cDECLARE_top
-			data *^cSW_c
-			Data *=cDECLARE
-			Data *=cSW
-			Data *=spacereq
-		Const cVDATA=\-cDECLARE_top
-			data *^cVDATA_c
-			Data *=cDECLARE
-			Data *=cVDATA
-			Data *=spacereq
-		Const cVSTR=\-cDECLARE_top
-			data *^cVSTR_c
-			Data *=cDECLARE
-			Data *=cVSTR
-			Data *=spacereq
-		Const cVALUE=\-cDECLARE_top
-			data *^cVALUE_c
-			Data *=cDECLARE
-			Data *=cVALUE
-			Data *=spacereq
-		Const cVWORD=\-cDECLARE_top
-			data *^cVWORD_c
-			Data *=cDECLARE
-			Data *=cVWORD
-			Data *=spacereq
-		Const cDATAX=\-cDECLARE_top
-			data *^cDATAX_c
-			Data *=cDECLARE
-			Data *=cDATAX
-			Data *=spacereq
-		Const cSTRX=\-cDECLARE_top
-			data *^cSTRX_c
-			Data *=cDECLARE
-			Data *=cSTRX
-			Data *=spacereq
-		Const cCHARX=\-cDECLARE_top
-			data *^cCHARX_c
-			Data *=cDECLARE
-			Data *=cCHARX
-			Data *=spacereq
-		Const cWORDX=\-cDECLARE_top
-			data *^cWORDX_c
-			Data *=cDECLARE
-			Data *=cWORDX
-			Data *=spacereq
-		Const cVDATAX=\-cDECLARE_top
-			data *^cVDATAX_c
-			Data *=cDECLARE
-			Data *=cVDATAX
-			Data *=spacereq
-		Const cVSTRX=\-cDECLARE_top
-			data *^cVSTRX_c
-			Data *=cDECLARE
-			Data *=cVSTRX
-			Data *=spacereq
-		Const cVALUEX=\-cDECLARE_top
-			data *^cVALUEX_c
-			Data *=cDECLARE
-			Data *=cVALUEX
-			Data *=spacereq
-		Const cVWORDX=\-cDECLARE_top
-			data *^cVWORDX_c
-			Data *=cDECLARE
-			Data *=cVWORDX
-			Data *=spacereq
-#numberofcommandsvars to set these commands to search for them at function parameter declare
-Const numberofcommandsvars=(\-commandsvars_start)/com_size
-		Const cCONST=\-cDECLARE_top
-			data *^cCONST_c
-			Data *=cDECLARE
-			Data *=cCONST
-			Data *=spacereq
-	Const cPRIMSEC=\-coms_start
-	Const cPRIMSEC_top=\
-		Const cSET=\-cPRIMSEC_top
-			data *^cSET_c
-			Data *=cPRIMSEC
-			Data *=cSET
-			Data *=spacereq
-		Const cADD=\-cPRIMSEC_top
-			data *^cADD_c
-			Data *=cPRIMSEC
-			Data *=cADD
-			Data *=spacereq
-		Const cSUB=\-cPRIMSEC_top
-			data *^cSUB_c
-			Data *=cPRIMSEC
-			Data *=cSUB
-			Data *=spacereq
-		Const cMULT=\-cPRIMSEC_top
-			data *^cMULT_c
-			Data *=cPRIMSEC
-			Data *=cMULT
-			Data *=spacereq
-		Const cDIV=\-cPRIMSEC_top
-			data *^cDIV_c
-			Data *=cPRIMSEC
-			Data *=cDIV
-			Data *=spacereq
-		Const cDIVU=\-cPRIMSEC_top
-			data *^cDIVU_c
-			Data *=cPRIMSEC
-			Data *=cDIVU
-			Data *=spacereq
-		Const cREM=\-cPRIMSEC_top
-			data *^cREM_c
-			Data *=cPRIMSEC
-			Data *=cREM
-			Data *=spacereq
-		Const cREMU=\-cPRIMSEC_top
-			data *^cREMU_c
-			Data *=cPRIMSEC
-			Data *=cREMU
-			Data *=spacereq
-		Const cAND=\-cPRIMSEC_top
-			data *^cAND_c
-			Data *=cPRIMSEC
-			Data *=cAND
-			Data *=spacereq
-		Const cOR=\-cPRIMSEC_top
-			data *^cOR_c
-			Data *=cPRIMSEC
-			Data *=cOR
-			Data *=spacereq
-		Const cXOR=\-cPRIMSEC_top
-			data *^cXOR_c
-			Data *=cPRIMSEC
-			Data *=cXOR
-			Data *=spacereq
-		Const cCALLEX_primsec=\-cPRIMSEC_top
-	Const cONEARG=\-coms_start
-	Const cONEARG_top=\
-		Const cRETURN=\-cONEARG_top
-			data *^cRETURN_c
-			Data *=cONEARG
-			Data *=cRETURN
-			Data *=spacereq
-		Const cINC=\-cONEARG_top
-			data *^cINC_c
-			Data *=cONEARG
-			Data *=cINC
-			Data *=spacereq
-		Const cDEC=\-cONEARG_top
-			data *^cDEC_c
-			Data *=cONEARG
-			Data *=cDEC
-			Data *=spacereq
-		Const cINCST=\-cONEARG_top
-			data *^cINCST_c
-			Data *=cONEARG
-			Data *=cINCST
-			Data *=spacereq
-		Const cDECST=\-cONEARG_top
-			data *^cDECST_c
-			Data *=cONEARG
-			Data *=cDECST
-			Data *=spacereq
-		Const cNEG=\-cONEARG_top
-			data *^cNEG_c
-			Data *=cONEARG
-			Data *=cNEG
-			Data *=spacereq
-		Const cNOT=\-cONEARG_top
-			data *^cNOT_c
-			Data *=cONEARG
-			Data *=cNOT
-			Data *=spacereq
-		Const cSHL1=\-cONEARG_top
-			data *^cSHL1_c
-			Data *=cONEARG
-			Data *=cSHL1
-			Data *=spacereq
-		Const cSHR1=\-cONEARG_top
-			data *^cSHR1_c
-			Data *=cONEARG
-			Data *=cSHR1
-			Data *=spacereq
-		Const cSAR1=\-cONEARG_top
-			data *^cSAR1_c
-			Data *=cONEARG
-			Data *=cSAR1
-			Data *=spacereq
-		Const cEXIT=\-cONEARG_top
-			data *^cEXIT_c
-			Data *=cONEARG
-			Data *=cEXIT
-			Data *=spacereq
-	Const cCALL=\-coms_start
-		data *^cCALL_c
-		Data *=cCALL
-		Data *=0
-		Data *=spacereq
-		data *^cCALLX_c
-		Data *=cCALL
-		Data *=x_callx_flag
-		Data *=spacereq
-	Const cCONDITIONS=\-coms_start
-	Const cCONDITIONS_top=\
-		Const cIF=\-cCONDITIONS_top
-			data *^cIF_c
-			Data *=cCONDITIONS
-			Data *=cIF
-			Data *=spacereq
-		Const cELSEIF=\-cCONDITIONS_top
-			data *^cELSEIF_c
-			Data *=cCONDITIONS
-			Data *=cELSEIF
-			Data *=spacereq
-		Const cELSE=\-cCONDITIONS_top
-			data *^cELSE_c
-			Data *=cCONDITIONS
-			Data *=cELSE
-			Data *=spacenotreq
-		Const cENDIF=\-cCONDITIONS_top
-			data *^cENDIF_c
-			Data *=cCONDITIONS
-			Data *=cENDIF
-			Data *=spacenotreq
-		Const cENDELSEIF=\-cCONDITIONS_top
-			data *^cENDELSEIF_c
-			Data *=cCONDITIONS
-			Data *=cENDELSEIF
-			Data *=spacenotreq
-		Const cENDELSE=\-cCONDITIONS_top
-			data *^cENDELSE_c
-			Data *=cCONDITIONS
-			Data *=cENDELSE
-			Data *=spacenotreq
-		Const cWHILE=\-cCONDITIONS_top
-			data *^cWHILE_c
-			Data *=cCONDITIONS
-			Data *=cWHILE
-			Data *=spacereq
-		Const cENDWHILE=\-cCONDITIONS_top
-			data *^cENDWHILE_c
-			Data *=cCONDITIONS
-			Data *=cENDWHILE
-			Data *=spacenotreq
-		Const cBREAK=\-cCONDITIONS_top
-			data *^cBREAK_c
-			Data *=cCONDITIONS
-			Data *=cBREAK
-			Data *=spacenotreq
-		Const cCONTINUE=\-cCONDITIONS_top
-			data *^cCONTINUE_c
-			Data *=cCONDITIONS
-			Data *=cCONTINUE
-			Data *=spacenotreq
-	Const cIMPORTLINK=\-coms_start
-		const cIMPORT=Xfile_import_normal
-			data *^cIMPORT_c
-			Data *=cIMPORTLINK
-			Data *=cIMPORT
-			Data *=spacereq
-		const cIMPORTX=Xfile_import_extern
-			data *^cIMPORTX_c
-			Data *=cIMPORTLINK
-			Data *=cIMPORTX
-			Data *=spacereq
-	Const cSTARTFUNCTION=\-coms_start
-		Const cFUNCTION=Xfile_function_tintern
-			data *^cFUNCTION_c
-			Data *=cSTARTFUNCTION
-			Data *=cFUNCTION
-			Data *=spacereq
-		Const cFUNCTIONX=Xfile_function_extern
-			data *^cFUNCTIONX_c
-			Data *=cSTARTFUNCTION
-			Data *=cFUNCTIONX
-			Data *=spacereq
-		Const cENTRY=Xfile_function_entry
-			data *^cENTRY_c
-			Data *=cSTARTFUNCTION
-			Data *=cENTRY
-			Data *=spacereq
-		Const cENTRYRAW=Xfile_function_traw
-			data *^cENTRYRAW_c
-			Data *=cSTARTFUNCTION
-			Data *=cENTRYRAW
-			Data *=spacereq
-	Const cENDFUNCTION=\-coms_start
-		data *^cENDFUNCTION_c
-		Data *=cENDFUNCTION
-		Data *#1
-		Data *=spacenotreq
-	Const cEND=\-coms_start
-		data *^cEND_c
-		Data *=cEND
-		Data *#1
-		Data *=spacenotreq
-	Const cRET=\-coms_start
-		data *^cRET_c
-		Data *=cRET
-		Data *#1
-		Data *=spacenotreq
-	Const cINCLUDELINK=\-coms_start
-		Const cINCLUDE=Xfile_include_normal
-			data *^cINCLUDE_c
-			Data *=cINCLUDELINK
-			Data *=cINCLUDE
-			Data *=spacereq
-		Const cEINCLUDE=Xfile_include_extern
-			data *^cEINCLUDE_c
-			Data *=cINCLUDELINK
-			Data *=cEINCLUDE
-			Data *=spacereq
-	Const cFORMAT=\-coms_start
-		data *^cFORMAT_c
-		Data *=cFORMAT
-		Data *#1
-		Data *=spacereq
-#aftercall can be at function parameters but the get_img_vdata_dataReg() is set inside and codding must be done for not a big deal
-	Const cDECLAREAFTERCALL=\-coms_start
-	Const cDECLAREAFTERCALL_top=\
-		Const cAFTERCALLIMPORT=\-cDECLAREAFTERCALL_top
-			data *^cAFTERCALLIMPORT_c
-			Data *=cDECLAREAFTERCALL
-			Data *=cAFTERCALLIMPORT
-			Data *=spacereq
-		Const cAFTERCALL=\-cDECLAREAFTERCALL_top
-			data *^cAFTERCALL_c
-			Data *=cDECLAREAFTERCALL
-			Data *=cAFTERCALL
-			Data *=spacereq
-	Const cMANIPULATEAFTERCALL=\-coms_start
-	Const cMANIPULATEAFTERCALL_top=\
-		Const cAFTERCALLENABLE=\-cMANIPULATEAFTERCALL_top
-			data *^cAFTERCALLENABLE_c
-			Data *=cMANIPULATEAFTERCALL
-			Data *=cAFTERCALLENABLE
-			Data *=spacenotreq
-		Const cAFTERCALLDISABLE=\-cMANIPULATEAFTERCALL_top
-			data *^cAFTERCALLDISABLE_c
-			Data *=cMANIPULATEAFTERCALL
-			Data *=cAFTERCALLDISABLE
-			Data *=spacenotreq
-	Const cCALLEX=\-coms_start
-		data *^cCALLEX_c
-		Data *=cCALLEX
-		Data *=0
-		Data *=spacereq
-		data *^cCALLEXX_c
-		Data *=cCALLEX
-		Data *=x_callx_flag
-		Data *=spacereq
-	Const cLIBRARY=\-coms_start
-		data *^cLIBRARY_c
-		Data *=cLIBRARY
-		Data *#1
-		Data *=spacereq
-	Const cHEX=\-coms_start
-		data *^cHEX_c
-		Data *=cHEX
-		Data *#1
-		Data *=spacereq
-	Const cOVERRIDE=\-coms_start
-		data *^cOVERRIDE_c
-		Data *=cOVERRIDE
-		Data *#1
-		Data *=spacereq
-	Const cORPHAN=\-coms_start
-		data *^cORPHAN_c
-		Data *=cORPHAN
-		Data *#1
-		Data *=spacereq
-	Const cI3=\-coms_start
-		data *^cI3_c
-		Data *=cI3
-		Data *#1
-		Data *=spacenotreq
-Const numberofcommands=(\-coms_start)/com_size
-Const Error=\-coms_start
-
-Data pointers#numberofcommands+1
-Const compointersloc^pointers
-
-Data pointersvars#numberofcommandsvars+1
-Const compointersvarsloc^pointersvars
-
-#at fn
-const x_func_flag=0x80000000   #at def, varargs
-
-#at ...call...
-const x_callx_flag=0x80000000  #call a variable function import like functionx importx
-const x_callg_flag=0x40000000  #skip aftercall
-
-const call_ret_flag=0x20000000 #at call
-const x_call_flag=0x10000000   #at setcall... . attention that at write_func is asking about callret and setcall does not have that
-
-const x_call_flags=x_call_flag|x_callx_flag|x_callg_flag
-
-#declare coresp
-function commandSubtypeDeclare_to_typenumber(sd subtype,sd p_is_expand)
-#these numbers will be used at getstruct directly
-	if subtype=(cCONST)
-		return (constantsnumber)
-	endif
-	div subtype (com_size)
-	if subtype>=(xnumbers)
-		if subtype>=(xvnumbers)
-			sub subtype (xnumbers-totalmemvariables)
-		else
-			sub subtype (xnumbers)
-		endelse
-		set p_is_expand# (TRUE)
-	else
-		set p_is_expand# (FALSE)   #this, if typenumber is constant, atm is not used
-	endelse
-	return subtype
-endfunction
-#set errormsg to pointer error or return the find
-Function getcommand(value pcontent,data psize,data ptrsubtype,data ptrerrormsg,data pointercommands)
-	Data zero=0
-	Data command#1
-	Data result#1
-	Data cursor#1
-	Data true=TRUE
-
-	Data dsz=dwsz
-
-	valuex start#1;set start pcontent#
-	Set cursor pointercommands#
-	While cursor!=zero
-		Data offset#1
-		Set offset cursor#
-		Add cursor dsz
-		Set command cursor#
-		Add cursor dsz
-		Set ptrsubtype# cursor#
-
-		Data spacebool#1
-		Add cursor dsz
-		Set spacebool cursor#
-
-		#implement for Set[X]Call
-		Char calldata="CALL"
-		vStr call^calldata
-		vstr xstr="X"
-		vstr skipaftercall="G"
-		value pointer#1;data sz#1
-
-		ss extstr=NULL
-
-		sd extbooldata=FALSE
-		sv extbool^extbooldata
-		sd intercursors=NULL
-		set pointer start
-
-		If command=(cPRIMSEC)
-			Set extstr xstr
-			set intercursors #pointer
-		elseif command=(cCALL)
-		vstr call_ret_str="RET"
-			set extstr call_ret_str
-			set intercursors #pointer
-		Elseif command=(cSTARTFUNCTION)
-			sd x_fn;setcall x_fn func_xfile(ptrsubtype#)
-			if x_fn!=(Xfile_function_not_x)
-				Set extstr xstr ##varargs
-			endif
-		elseif command=(cCALLEX)
-			set extstr call_ret_str
-			set intercursors #pointer
-		endElseif
-
-		SetCall result stringsatmemspc(pcontent,psize,offset,spacebool,extstr,extbool,intercursors)
-		If extbooldata=true
-		#here firstAndSecond part was recognized
-			If command=(cPRIMSEC)
-				if result=(TRUE)
-				#setx
-					or ptrsubtype# (x_call_flag|x_callx_flag)
-					Return command
-				else
-					#here there was not a space
-					setcall result stratmemspc(#pointer,#sz,skipaftercall,spacebool)
-					if result=(TRUE)
-						or ptrsubtype# (x_call_flag|x_callx_flag|x_callg_flag)
-						set pcontent# pointer
-						set psize# sz
-						Return command
-					endif
-					#maybe is the deprecated ..xcall
-					setcall result stratmemspc(#pointer,#sz,call,spacebool)
-					if result=(TRUE)
-						#or first byte at subcommand to recognize the xcall at two args
-						or ptrsubtype# (x_call_flag|x_callx_flag)
-						set pcontent# pointer
-						set psize# sz
-						Return command
-					endif
-				endelse
-			Elseif result=(TRUE)
-				If command=(cSTARTFUNCTION)
-				#functionx/entry [x] , varargs
-					#allow the command at 64, there is a check inside parsefunc, and for xfile better to know
-					#sd for64;setcall for64 is_for_64()
-					#if for64==(TRUE)
-					or ptrsubtype# (x_func_flag)
-					#endif
-					return command
-				else
-				#call[ex][x]ret
-					or ptrsubtype# (call_ret_flag)
-					return command
-				endelse
-			endElseif
-		elseIf result=true
-		#here (first/onlyone)+-space was ok
-			Return command
-		elseif start!=pointer  ##here first was ok, but not extra part
-			if command=(cPRIMSEC)
-				setcall result stratmemspc(#pointer,#sz,skipaftercall,spacebool)
-				if result=(TRUE)
-					or ptrsubtype# (x_call_flag|x_callg_flag)
-					set pcontent# pointer
-					set psize# sz
-					Return command
-				endif
-				#maybe is the deprecated ..call
-				setcall result stratmemspc(#pointer,#sz,call,spacebool)
-				if result=(TRUE)
-					or ptrsubtype# (x_call_flag)
-					set pcontent# pointer
-					set psize# sz
-					Return command
-				endif
-				#break #don't want to remember this when having something like addend command, and who will wrong here?
-			else
-			#if command=(cCALL)
-			#if command=(cCALLEX)  #cSTARTFUNCTION is not coming here with intercursors=NULL
-				setcall result stratmemspc(#pointer,#sz,skipaftercall,spacebool)
-				if result=(TRUE)
-					or ptrsubtype# (x_callg_flag)
-					set pcontent# pointer
-					set psize# sz
-					Return command
-				endif
-			endelse
-		endelseIf
-		Add pointercommands dsz
-		Set cursor pointercommands#
-	EndWhile
-
-	Char _unrecCom="Unrecognized command/declaration name."
-	vStr unrecCom^_unrecCom
-	Set ptrerrormsg# unrecCom
-EndFunction
-
-
-
-Function sortcommands(sv pointerscursor,sd nrofcomms,sd datacursor)
-#it's that old strategy elseif will be only else if let unsorted, endelseif/endelse, maybe more
-	sd i=0
-#	Data sz#1
-#	Data j#1
-	Data dsize=dwsz
-#	Data szval#1
-#	Data ptrval#1
-#	Data ptrvalstand#1
-#	Data dataval#1
-
-	While i<nrofcomms
-#		SetCall sz strlen(datacursor#)
-#		Set j i
-#		Set ptrval pointerscursor
-#		Set ptrvalstand pointerscursor
-#		While zero<j
-#			Sub ptrval dsize
-#			Set dataval ptrval#
-#			SetCall szval strlen(dataval#)
-#			If szval>=sz
-#				Set j zero
-#			Else
-#				Set ptrvalstand# dataval
-#				Sub ptrvalstand dsize
-#				Dec j
-#			EndElse
-#		EndWhile
-#		Set ptrvalstand# datacursor
-		set pointerscursor# datacursor
-		Add pointerscursor dsize
-		Add datacursor dsize
-		Add datacursor dsize
-		Add datacursor dsize
-		Add datacursor dsize
-		Inc i
-	EndWhile
-	Set pointerscursor# (NULL)
-EndFunction
-
-Function sortallcommands()
-#put commands pointers at init
-	vdata commandscursorini%comsloc
-	vData pointerscursor%compointersloc
-	Data comms=numberofcommands
-
-	Call sortcommands(pointerscursor,comms,commandscursorini)
-
-	vData datacursorini%cdataloc
-	vData pointersvarscursor%compointersvarsloc
-	Data variables=numberofcommandsvars
-	Call sortcommands(pointersvarscursor,variables,datacursorini)
-EndFunction
--- /dev/null
+++ ocompiler-1/src/files/functions/commons/strcommons.oc
@@ -0,0 +1,428 @@
+
+#advance the content/size by value
+Function advancecursors(data ptrcontent,data ptrsize,data nr)
+	Str content#1
+	Data size#1
+	Set content ptrcontent#
+	Set size ptrsize#
+	Add content nr
+
+	#take nr if nr>0 or -nr if nr<0. was ok in one case at enumcomma backward
+	#Data zero=0;If nr<zero;SetCall nr neg(nr);EndIf
+
+	Sub size nr
+	Set ptrcontent# content
+	Set ptrsize# size
+EndFunction
+
+#advance the content/size by one
+Function stepcursors(data ptrcontent,data ptrsize)
+	Data one=1
+	Call advancecursors(ptrcontent,ptrsize,one)
+EndFunction
+
+
+#String in mem; return size(if string is not),size before string(if string is)
+Function stringinmem(str content,data size,str match)
+	Data zero=0
+	Data nrsz#1
+	SetCall nrsz strlen(match)
+	If size<nrsz
+		Return size
+	EndIf
+	Str cnt#1
+	Set cnt content
+	Data sz#1
+	Set sz size
+	Data b#1
+	While sz>=nrsz
+		SetCall b memcmp(cnt,match,nrsz)
+		If b=zero
+			Set nrsz sz
+			Inc nrsz
+		EndIf
+		If b!=zero
+			Inc cnt
+			Dec sz
+		EndIf
+	EndWhile
+	If b=zero
+		Sub cnt content
+		return cnt
+	EndIf
+	Return size
+EndFunction
+#and this same logic, +1, -1, like there are no 32bit asm instructions
+Function stringatmem(ss content,sd size,ss match)
+	sd nrsz
+	SetCall nrsz strlen(match)
+	If size<nrsz
+		Return size
+	EndIf
+	sd sz;set sz nrsz
+	while nrsz>0
+		if content#!=match#
+			return size
+		endif
+		dec nrsz
+		inc content
+		inc match
+	endwhile
+	return sz
+EndFunction
+
+#bool
+#AB to ab
+#match have size
+Function stratmem(data pcontent,data psize,str match)
+	Data nrsz=0
+	Data sz=0
+	Str content=0
+	Data zero=0
+	Data one=1
+	Data sizetorun=0
+
+	SetCall nrsz strlen(match)
+	Set sz psize#
+	Set content pcontent#
+
+	If sz<nrsz
+		Return zero
+	EndIf
+
+	Set sizetorun nrsz
+	While sizetorun!=zero
+		Char a_from_az={a_from_az}
+		Char z_from_az={z_from_az}
+		Char b#1
+		Char c#1
+
+		Set b content#
+		If b>=a_from_az
+			If b<=z_from_az
+				Sub b (AZ_to_az)
+			EndIf
+		EndIf
+		Set c match#
+		If b!=c
+			Return zero
+		EndIf
+		Inc content
+		Inc match
+		Dec sizetorun
+	EndWhile
+	Set pcontent# content
+	Sub sz nrsz
+	Set psize# sz
+	Return one
+EndFunction
+
+#new size
+function find_whitespaceORcomment(ss content,sd size)
+#size is greater than zero but this is not a problem here
+	ss end;set end content;add end size
+	ss start;set start content
+	while content!=end
+		char b#1;set b content#
+		if b=(commentascii)
+			sub content start
+			return content
+		endif
+		sd bool
+		setcall bool is_whitespace(b)
+		if bool=(TRUE)
+			sub content start
+			return content
+		endif
+		inc content
+	endwhile
+	sub content start
+	return content
+endfunction
+#bool
+function is_whitespace(char c)
+	if c=(asciispace)
+		return (TRUE)
+	endif
+	if c=(asciitab)
+		return (TRUE)
+	endif
+	return (FALSE)
+endfunction
+data warn_hidden_whitespaces_times#1
+const warn_hidden_whitespaces_times_p^warn_hidden_whitespaces_times
+#err
+function warn_hidden_whitespaces(sd inc)
+	sd p%p_hidden_pref
+	if p#=(TRUE)
+		data warn_hidden_whitespaces_times_p%warn_hidden_whitespaces_times_p
+		if warn_hidden_whitespaces_times_p#=0
+		#show once
+			sd goodwrongstring
+			setcall goodwrongstring errorDefOut("Hidden whitespaces at :",inc)
+			call safeMessage(goodwrongstring)
+			inc warn_hidden_whitespaces_times_p#
+		endif
+		sd w%p_w_as_e
+		if w#=(TRUE)
+			return ""
+		endif
+	endif
+	return (noerror)
+endfunction
+#err
+function warn_hidden_whitespaces_after(sd inc,sd dot_comma_end)
+	if dot_comma_end=0
+		sd er;setcall er warn_hidden_whitespaces(inc)
+		return er
+	endif
+	return (noerror)
+endfunction
+
+#pointer
+function mem_spaces(ss content,ss last)
+	while content!=last
+		sd bool;setcall bool is_whitespace(content#)
+		if bool=(FALSE)
+			return content
+		endif
+		inc content
+	endwhile
+	return content
+endfunction
+Function spaces_helper(ss cursor,sd size)
+	sd end;set end cursor;add end size
+	while cursor!=end
+		sd b
+		setcall b is_whitespace(cursor#)
+		if b=(TRUE)
+			inc cursor
+		else
+			return cursor
+		endelse
+	endwhile
+	return cursor
+endfunction
+#spaces;return 1 if at least one spc/tab;0 otherwise
+Function spaces(sd pcontent,sd psize)
+	sd start;set start pcontent#
+	setcall pcontent# spaces_helper(pcontent#,psize#)
+	if pcontent#=start
+		return (FALSE)
+	endif
+	sub start pcontent#
+	add psize# start
+	return (TRUE)
+EndFunction
+
+#bool;return 1 or 0
+Function stringsatmemspc(sv pcontent,sd psize,ss match,sd spacereq,ss extstr,sd extbool,sv intercursors)
+#												    attention here there is a sd but not working on entire long, so sd is ok
+	Data content#1
+	Data size#1
+	Data bool#1
+	Data tocontent^content
+	Data tosize^size
+	Data zero=FALSE
+	Data nonzero=TRUE
+
+	Set content pcontent#
+	Set size psize#
+	SetCall bool stratmem(tocontent,tosize,match)
+	If bool=zero
+		Return zero
+	EndIf
+
+	If extstr!=zero
+		SetCall extbool# stratmem(tocontent,tosize,extstr)
+		if intercursors!=(NULL)
+			#to work around ...xcall
+			Set intercursors# content
+			add intercursors :
+			set intercursors#d^ size
+		endif
+	EndIf
+
+	If spacereq=nonzero
+		SetCall bool spaces(tocontent,tosize)
+		IF bool=zero
+			Return zero
+		EndIf
+	EndIf
+	Set pcontent# content
+	Set psize# size
+	Return nonzero
+EndFunction
+
+#return stringsatmemspc
+Function stratmemspc(data pcontent,data psize,str match,data spacereq)
+	Data null=NULL
+	Data bool#1
+	SetCall bool stringsatmemspc(pcontent,psize,match,spacereq,null,null,null)
+	Return bool
+EndFunction
+
+#return the escaped char and change the size and cursor
+Function quotescaped(Data pcontent,Data psize,Data pescapes)
+	Str content#1
+	Data size#1
+	Char byte#1
+	Char bs=asciibs
+	Data zero=0
+
+	Set content pcontent#
+	Set byte content#
+	If byte!=bs
+		Return byte
+	EndIf
+	Set size psize#
+	Dec size
+	If size=zero
+		Return byte
+	EndIf
+
+	Inc content
+	Set byte content#
+	Set pcontent# content
+	Set psize# size
+	If pescapes!=zero
+		Inc pescapes#
+		Return byte   ##quotation/null/another are relevant here
+	EndIf
+
+	if byte=(asciin)
+		return (asciireturn)
+	elseif byte=(asciir)
+		return (asciicarriage)
+	elseif byte=(asciit)
+		return (asciitab)
+	endelseif
+	return byte
+EndFunction
+
+#return false or true
+Function quotientinmem(data ptrcontent,data ptrsize,data pquotsz,data pescapes)
+	Char quotation={asciidoublequote,0}
+	Str pquotation^quotation
+	Data intnr=0
+	Data zero=0
+	Data nonzero=1
+
+	SetCall intnr stratmem(ptrcontent,ptrsize,pquotation)
+	If intnr=zero
+		Return zero
+	EndIf
+
+	Str data#1
+	Data length#1
+	Str ptrdata^data
+	Data ptrlength^length
+
+	Set data ptrcontent#
+	Set length ptrsize#
+	Set pescapes# zero
+	Data escbefore=0
+	Data escafter=0
+
+	Char byte={0}
+	Char bnull={0}
+	While length!=zero
+		Set escbefore pescapes#
+		SetCall byte quotescaped(ptrdata,ptrlength,pescapes)
+		If byte=quotation
+			Set escafter pescapes#
+			If escbefore=escafter
+				Str datastart#1
+				Set datastart ptrcontent#
+				Sub data datastart
+				Set pquotsz# data
+				Return nonzero
+			EndIf
+		ElseIf byte=bnull
+			Return zero
+		EndElseIf
+		Inc data
+		Dec length
+	EndWhile
+	Return zero
+EndFunction
+
+#err
+Function quotinmem(data ptrcontent,data ptrsize,data pquotsz,data pescapes)
+	Data bool#1
+	SetCall bool quotientinmem(ptrcontent,ptrsize,pquotsz,pescapes)
+	Data false=FALSE
+	If bool=false
+		Char strerr="Expecting string delimited by quotations and with the backslash the escape character."
+		Str ptrstrerr^strerr
+		Return ptrstrerr
+	EndIf
+	Data noerr=noerror
+	Return noerr
+EndFunction
+
+#err
+function maxpathverif(str safecurrentdirtopath,str logextension)
+	data size1#1
+	data size2#1
+	setcall size1 strlen(safecurrentdirtopath)
+	setcall size2 strlen(logextension)
+	add size1 size2
+	inc size1
+
+	data err#1
+	setcall err compareagainstmaxpath(size1)
+	return err
+endfunction
+
+#err
+function quotes_forward(sd p_content,ss last,sd p_newlines,sd p_lastlinestart)
+#this version is knowing that the first char is "
+	char delim=asciidoublequote
+	ss content
+	set content p_content#
+	str unend="end string (\") expected"
+	sd escapes=0
+	inc content
+	if content=last
+		return unend
+	endif
+	sd newlines=0
+	while content#!=delim
+		char escape_c=asciibs
+		while content#=escape_c
+			if escapes=0
+				set escapes 1
+			else
+				set escapes 0
+			endelse
+			inc content
+			if content=last
+				return unend
+			endif
+		endwhile
+		char newline=asciireturn
+		if content#=newline
+			if p_newlines!=0
+				inc newlines
+				set p_lastlinestart# content
+				inc p_lastlinestart#
+			endif
+		endif
+		if escapes=1
+			inc content
+			set escapes 0
+		elseif content#!=delim
+			inc content
+		endelseif
+		if content=last
+			return unend
+		endif
+	endwhile
+	inc content
+	set p_content# content
+	if p_newlines!=0
+		set p_newlines# newlines
+	endif
+	return (noerror)
+endfunction
--- ocompiler-1.orig/src/files/functions/commons/strcommons.s
+++ /dev/null
@@ -1,428 +0,0 @@
-
-#advance the content/size by value
-Function advancecursors(data ptrcontent,data ptrsize,data nr)
-	Str content#1
-	Data size#1
-	Set content ptrcontent#
-	Set size ptrsize#
-	Add content nr
-
-	#take nr if nr>0 or -nr if nr<0. was ok in one case at enumcomma backward
-	#Data zero=0;If nr<zero;SetCall nr neg(nr);EndIf
-
-	Sub size nr
-	Set ptrcontent# content
-	Set ptrsize# size
-EndFunction
-
-#advance the content/size by one
-Function stepcursors(data ptrcontent,data ptrsize)
-	Data one=1
-	Call advancecursors(ptrcontent,ptrsize,one)
-EndFunction
-
-
-#String in mem; return size(if string is not),size before string(if string is)
-Function stringinmem(str content,data size,str match)
-	Data zero=0
-	Data nrsz#1
-	SetCall nrsz strlen(match)
-	If size<nrsz
-		Return size
-	EndIf
-	Str cnt#1
-	Set cnt content
-	Data sz#1
-	Set sz size
-	Data b#1
-	While sz>=nrsz
-		SetCall b memcmp(cnt,match,nrsz)
-		If b=zero
-			Set nrsz sz
-			Inc nrsz
-		EndIf
-		If b!=zero
-			Inc cnt
-			Dec sz
-		EndIf
-	EndWhile
-	If b=zero
-		Sub cnt content
-		return cnt
-	EndIf
-	Return size
-EndFunction
-#and this same logic, +1, -1, like there are no 32bit asm instructions
-Function stringatmem(ss content,sd size,ss match)
-	sd nrsz
-	SetCall nrsz strlen(match)
-	If size<nrsz
-		Return size
-	EndIf
-	sd sz;set sz nrsz
-	while nrsz>0
-		if content#!=match#
-			return size
-		endif
-		dec nrsz
-		inc content
-		inc match
-	endwhile
-	return sz
-EndFunction
-
-#bool
-#AB to ab
-#match have size
-Function stratmem(data pcontent,data psize,str match)
-	Data nrsz=0
-	Data sz=0
-	Str content=0
-	Data zero=0
-	Data one=1
-	Data sizetorun=0
-
-	SetCall nrsz strlen(match)
-	Set sz psize#
-	Set content pcontent#
-
-	If sz<nrsz
-		Return zero
-	EndIf
-
-	Set sizetorun nrsz
-	While sizetorun!=zero
-		Char a_from_az={a_from_az}
-		Char z_from_az={z_from_az}
-		Char b#1
-		Char c#1
-
-		Set b content#
-		If b>=a_from_az
-			If b<=z_from_az
-				Sub b (AZ_to_az)
-			EndIf
-		EndIf
-		Set c match#
-		If b!=c
-			Return zero
-		EndIf
-		Inc content
-		Inc match
-		Dec sizetorun
-	EndWhile
-	Set pcontent# content
-	Sub sz nrsz
-	Set psize# sz
-	Return one
-EndFunction
-
-#new size
-function find_whitespaceORcomment(ss content,sd size)
-#size is greater than zero but this is not a problem here
-	ss end;set end content;add end size
-	ss start;set start content
-	while content!=end
-		char b#1;set b content#
-		if b=(commentascii)
-			sub content start
-			return content
-		endif
-		sd bool
-		setcall bool is_whitespace(b)
-		if bool=(TRUE)
-			sub content start
-			return content
-		endif
-		inc content
-	endwhile
-	sub content start
-	return content
-endfunction
-#bool
-function is_whitespace(char c)
-	if c=(asciispace)
-		return (TRUE)
-	endif
-	if c=(asciitab)
-		return (TRUE)
-	endif
-	return (FALSE)
-endfunction
-data warn_hidden_whitespaces_times#1
-const warn_hidden_whitespaces_times_p^warn_hidden_whitespaces_times
-#err
-function warn_hidden_whitespaces(sd inc)
-	sd p%p_hidden_pref
-	if p#=(TRUE)
-		data warn_hidden_whitespaces_times_p%warn_hidden_whitespaces_times_p
-		if warn_hidden_whitespaces_times_p#=0
-		#show once
-			sd goodwrongstring
-			setcall goodwrongstring errorDefOut("Hidden whitespaces at :",inc)
-			call safeMessage(goodwrongstring)
-			inc warn_hidden_whitespaces_times_p#
-		endif
-		sd w%p_w_as_e
-		if w#=(TRUE)
-			return ""
-		endif
-	endif
-	return (noerror)
-endfunction
-#err
-function warn_hidden_whitespaces_after(sd inc,sd dot_comma_end)
-	if dot_comma_end=0
-		sd er;setcall er warn_hidden_whitespaces(inc)
-		return er
-	endif
-	return (noerror)
-endfunction
-
-#pointer
-function mem_spaces(ss content,ss last)
-	while content!=last
-		sd bool;setcall bool is_whitespace(content#)
-		if bool=(FALSE)
-			return content
-		endif
-		inc content
-	endwhile
-	return content
-endfunction
-Function spaces_helper(ss cursor,sd size)
-	sd end;set end cursor;add end size
-	while cursor!=end
-		sd b
-		setcall b is_whitespace(cursor#)
-		if b=(TRUE)
-			inc cursor
-		else
-			return cursor
-		endelse
-	endwhile
-	return cursor
-endfunction
-#spaces;return 1 if at least one spc/tab;0 otherwise
-Function spaces(sd pcontent,sd psize)
-	sd start;set start pcontent#
-	setcall pcontent# spaces_helper(pcontent#,psize#)
-	if pcontent#=start
-		return (FALSE)
-	endif
-	sub start pcontent#
-	add psize# start
-	return (TRUE)
-EndFunction
-
-#bool;return 1 or 0
-Function stringsatmemspc(sv pcontent,sd psize,ss match,sd spacereq,ss extstr,sd extbool,sv intercursors)
-#												    attention here there is a sd but not working on entire long, so sd is ok
-	Data content#1
-	Data size#1
-	Data bool#1
-	Data tocontent^content
-	Data tosize^size
-	Data zero=FALSE
-	Data nonzero=TRUE
-
-	Set content pcontent#
-	Set size psize#
-	SetCall bool stratmem(tocontent,tosize,match)
-	If bool=zero
-		Return zero
-	EndIf
-
-	If extstr!=zero
-		SetCall extbool# stratmem(tocontent,tosize,extstr)
-		if intercursors!=(NULL)
-			#to work around ...xcall
-			Set intercursors# content
-			add intercursors :
-			set intercursors#d^ size
-		endif
-	EndIf
-
-	If spacereq=nonzero
-		SetCall bool spaces(tocontent,tosize)
-		IF bool=zero
-			Return zero
-		EndIf
-	EndIf
-	Set pcontent# content
-	Set psize# size
-	Return nonzero
-EndFunction
-
-#return stringsatmemspc
-Function stratmemspc(data pcontent,data psize,str match,data spacereq)
-	Data null=NULL
-	Data bool#1
-	SetCall bool stringsatmemspc(pcontent,psize,match,spacereq,null,null,null)
-	Return bool
-EndFunction
-
-#return the escaped char and change the size and cursor
-Function quotescaped(Data pcontent,Data psize,Data pescapes)
-	Str content#1
-	Data size#1
-	Char byte#1
-	Char bs=asciibs
-	Data zero=0
-
-	Set content pcontent#
-	Set byte content#
-	If byte!=bs
-		Return byte
-	EndIf
-	Set size psize#
-	Dec size
-	If size=zero
-		Return byte
-	EndIf
-
-	Inc content
-	Set byte content#
-	Set pcontent# content
-	Set psize# size
-	If pescapes!=zero
-		Inc pescapes#
-		Return byte   ##quotation/null/another are relevant here
-	EndIf
-
-	if byte=(asciin)
-		return (asciireturn)
-	elseif byte=(asciir)
-		return (asciicarriage)
-	elseif byte=(asciit)
-		return (asciitab)
-	endelseif
-	return byte
-EndFunction
-
-#return false or true
-Function quotientinmem(data ptrcontent,data ptrsize,data pquotsz,data pescapes)
-	Char quotation={asciidoublequote,0}
-	Str pquotation^quotation
-	Data intnr=0
-	Data zero=0
-	Data nonzero=1
-
-	SetCall intnr stratmem(ptrcontent,ptrsize,pquotation)
-	If intnr=zero
-		Return zero
-	EndIf
-
-	Str data#1
-	Data length#1
-	Str ptrdata^data
-	Data ptrlength^length
-
-	Set data ptrcontent#
-	Set length ptrsize#
-	Set pescapes# zero
-	Data escbefore=0
-	Data escafter=0
-
-	Char byte={0}
-	Char bnull={0}
-	While length!=zero
-		Set escbefore pescapes#
-		SetCall byte quotescaped(ptrdata,ptrlength,pescapes)
-		If byte=quotation
-			Set escafter pescapes#
-			If escbefore=escafter
-				Str datastart#1
-				Set datastart ptrcontent#
-				Sub data datastart
-				Set pquotsz# data
-				Return nonzero
-			EndIf
-		ElseIf byte=bnull
-			Return zero
-		EndElseIf
-		Inc data
-		Dec length
-	EndWhile
-	Return zero
-EndFunction
-
-#err
-Function quotinmem(data ptrcontent,data ptrsize,data pquotsz,data pescapes)
-	Data bool#1
-	SetCall bool quotientinmem(ptrcontent,ptrsize,pquotsz,pescapes)
-	Data false=FALSE
-	If bool=false
-		Char strerr="Expecting string delimited by quotations and with the backslash the escape character."
-		Str ptrstrerr^strerr
-		Return ptrstrerr
-	EndIf
-	Data noerr=noerror
-	Return noerr
-EndFunction
-
-#err
-function maxpathverif(str safecurrentdirtopath,str logextension)
-	data size1#1
-	data size2#1
-	setcall size1 strlen(safecurrentdirtopath)
-	setcall size2 strlen(logextension)
-	add size1 size2
-	inc size1
-
-	data err#1
-	setcall err compareagainstmaxpath(size1)
-	return err
-endfunction
-
-#err
-function quotes_forward(sd p_content,ss last,sd p_newlines,sd p_lastlinestart)
-#this version is knowing that the first char is "
-	char delim=asciidoublequote
-	ss content
-	set content p_content#
-	str unend="end string (\") expected"
-	sd escapes=0
-	inc content
-	if content=last
-		return unend
-	endif
-	sd newlines=0
-	while content#!=delim
-		char escape_c=asciibs
-		while content#=escape_c
-			if escapes=0
-				set escapes 1
-			else
-				set escapes 0
-			endelse
-			inc content
-			if content=last
-				return unend
-			endif
-		endwhile
-		char newline=asciireturn
-		if content#=newline
-			if p_newlines!=0
-				inc newlines
-				set p_lastlinestart# content
-				inc p_lastlinestart#
-			endif
-		endif
-		if escapes=1
-			inc content
-			set escapes 0
-		elseif content#!=delim
-			inc content
-		endelseif
-		if content=last
-			return unend
-		endif
-	endwhile
-	inc content
-	set p_content# content
-	if p_newlines!=0
-		set p_newlines# newlines
-	endif
-	return (noerror)
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/commons/valinmem.oc
@@ -0,0 +1,43 @@
+
+
+
+
+#return the size of the value, if the delim is found the size counts until there
+Function valinmemsens(str content,data size,char delim,data sens)
+	Data length#1
+	Set length size
+	Char byte#1
+	Data zero=0
+
+	If size=zero
+		Return size
+	EndIf
+	Data backward=BACKWARD
+	If sens=backward
+		Dec content
+	EndIf
+	Set byte content#
+	While byte!=delim
+		If sens!=backward
+			Inc content
+		Else
+			Dec content
+		EndElse
+		Dec size
+		If size=zero
+			Set byte delim
+		Else
+			Set byte content#
+		EndElse
+	EndWhile
+
+	Sub length size
+	Return length
+EndFunction
+
+Function valinmem(str content,data size,char delim)
+	Data returnvalue#1
+	Data forward=FORWARD
+	SetCall returnvalue valinmemsens(content,size,delim,forward)
+	Return returnvalue
+EndFunction
--- ocompiler-1.orig/src/files/functions/commons/valinmem.s
+++ /dev/null
@@ -1,43 +0,0 @@
-
-
-
-
-#return the size of the value, if the delim is found the size counts until there
-Function valinmemsens(str content,data size,char delim,data sens)
-	Data length#1
-	Set length size
-	Char byte#1
-	Data zero=0
-
-	If size=zero
-		Return size
-	EndIf
-	Data backward=BACKWARD
-	If sens=backward
-		Dec content
-	EndIf
-	Set byte content#
-	While byte!=delim
-		If sens!=backward
-			Inc content
-		Else
-			Dec content
-		EndElse
-		Dec size
-		If size=zero
-			Set byte delim
-		Else
-			Set byte content#
-		EndElse
-	EndWhile
-
-	Sub length size
-	Return length
-EndFunction
-
-Function valinmem(str content,data size,char delim)
-	Data returnvalue#1
-	Data forward=FORWARD
-	SetCall returnvalue valinmemsens(content,size,delim,forward)
-	Return returnvalue
-EndFunction
--- /dev/null
+++ ocompiler-1/src/files/functions/commons/vars.oc
@@ -0,0 +1,459 @@
+
+
+#same or zero
+function warn_or_log(sd type,sd return_value,ss symbolname,sd log_option,sd p_err,sd size)
+	data ptrobject%ptrobject
+	if ptrobject#=(TRUE)
+		if log_option=(log_warn)
+			setcall p_err# addtolog_withchar_ex(symbolname,size,type) #is not calling atunused version, that will return noerror at object false
+			if p_err#=(noerror)
+				return 0
+			endif
+		endif
+	endif
+	return return_value
+endfunction
+#same function, except the array
+function warn_or_log_vars(sd return_value,ss symbolname,sd p_err,sd size)
+	data ptrobject%ptrobject
+	if ptrobject#=(TRUE)
+		data p_o_w%%p_offset_warn
+		if p_o_w#=(log_warn)
+			sd vals;setcall vals vars_log((get),symbolname,size)
+			setcall p_err# addtolog_array_withchar(vals,(log_variable))
+			if p_err#=(noerror)
+				return 0
+			endif
+		endif
+	endif
+	return return_value
+endfunction
+
+function vars_log(sd type,sd val,sd sz)
+	char dot=asciidot
+	#at unnamed entry is: .val , first can be size 0
+	value a#1;data as#1
+	value *^dot;data *=1
+	value c#1;data cs#1
+	value *=NULL
+	if type=(set)
+		set a val
+		set as sz
+	else
+		set c val
+		set cs sz
+		return #a
+	endelse
+endfunction
+function vars_log_reset()
+	call vars_log((set),"",0)
+endfunction
+function vars_log_set(sd a,sd b)
+#preferring to log .var even at main.var to be recognized at ounused(before entry is o.var and vmain.var at the end)
+#                                        and .var is united with a realpath so in a file can be main1.var, in another file can be main2.var
+	call vars_log((set),a,b)
+endfunction
+#err
+function vars_log_prepare(ss content,sd size)
+	data ptrobject%ptrobject
+	if ptrobject#=(TRUE)
+		if size>0  #addvarref..orunref is erroring there for getsign and fndecargs
+			if content#=(unrefsign)
+				return (noerror)
+			elseif content#=(throwlesssign)
+				inc content;dec size
+			endelseif
+		endif
+		sd vals;setcall vals vars_log((get),content,size)
+		sd err
+		setcall err addtolog_array_withchar(vals,(log_offset))
+		return err
+	endif
+	return (noerror)
+endfunction
+
+function vars_core_ref(ss content,sd size,sv ptrstructure,sv warningssearch,sd setref)
+	sd data
+	setcall data vars_core_ref_scope(content,size,ptrstructure,warningssearch,setref,(NULL))
+	return data
+endfunction
+
+#null or a pointer to the constant/variable/function
+function vars_core_ref_scope(ss content,sd size,sv ptrstructure,data warningssearch,sd setref,sd position_pointer)
+	Data zero=0
+	Data varsize#1
+	#Data dwlen=dwsz
+	Data blen=bsz
+
+	Str container#1
+	Data containerReg#1
+	Data ptrcontainer^container
+	Data ptrcontainerReg^containerReg
+	Call getcontandcontReg(ptrstructure,ptrcontainer,ptrcontainerReg)
+	Data entrypoint#1
+
+	sd end;set end container
+	add end containerReg
+	While container!=end
+		Set entrypoint container
+		Add container (location)
+		sd pmask;set pmask container
+		Add container (masksize) #add here, not twice, inside warn_or_log and outside (since logging all variables)
+		If warningssearch!=(NULL)
+			SetCall varsize strlen(container)
+
+			Data ReferenceBit=referencebit
+			Data checkvalue#1
+			Set checkvalue pmask#
+			And checkvalue ReferenceBit
+			data ptrconstants%%ptr_constants;sd cb
+			If checkvalue=zero
+				data returnvalue#1
+				set returnvalue entrypoint
+				#
+				data ptrfunctions%%ptr_functions
+				if ptrfunctions=ptrstructure
+					Set checkvalue pmask#
+					sd against_idata=idatabitfunction
+					and against_idata checkvalue
+					if against_idata=0
+						and checkvalue (x86_64bit)
+						if checkvalue=0
+							data ptrcodeFnObj%ptrcodeFnObj
+							setcall returnvalue warn_or_log((log_function),returnvalue,container,ptrcodeFnObj#,warningssearch,varsize)
+						else
+							#functionx are extern
+							set returnvalue 0
+						endelse
+					endif
+				elseif ptrconstants=ptrstructure
+					setcall cb constants_bool((const_warn_get))
+					setcall returnvalue warn_or_log((log_constant),returnvalue,container,cb,warningssearch,varsize)
+				else
+					setcall returnvalue warn_or_log_vars(returnvalue,container,warningssearch,varsize)
+				endelse
+				if returnvalue!=zero
+					Return returnvalue
+				endif
+			endIf
+			#elseIf ptrconstants==ptrstructure 0x72
+		Else
+			SetCall varsize strlen(container)
+			If varsize=size
+				Data cmpret#1
+				SetCall cmpret memcmp(container,content,size)
+				If cmpret=zero
+					#if set the reference is true
+					if setref=1
+						#go back from string to mask
+						#Sub container dwlen
+
+						#get the value and change the reference bit of the mask to true
+						Data value#1
+						Set value pmask#
+						Data referenceBit=referencebit
+						Or value referenceBit
+						Set pmask# value
+					endif
+					Return entrypoint
+				EndIf
+			EndIf
+			if position_pointer!=(NULL)
+				#are mixed with imports
+				sd against=idatabitfunction
+				and against pmask#
+				if against=0
+					inc position_pointer#
+				endif
+			endif
+		endElse
+		Add varsize blen
+		Add container varsize
+	EndWhile
+	Return zero
+endfunction
+
+#null or a pointer to the constant/variable/function
+Function varscore(str content,data size,data ptrstructure,data warningssearch)
+	sd pointer
+	setcall pointer vars_core_ref(content,size,ptrstructure,warningssearch,1)
+	return pointer
+EndFunction
+
+#vars_core_ref
+function vars_ignoreref(str content,data size,data ptrstructure)
+	Data pointer#1
+	Data false=FALSE
+	SetCall pointer vars_core_ref(content,size,ptrstructure,(NULL),false)
+	Return pointer
+endfunction
+
+#varscore
+Function vars(str content,data size,data ptrstructure)
+	Data pointer#1
+	SetCall pointer varscore(content,size,ptrstructure,(NULL))
+	Return pointer
+EndFunction
+
+function vars_number(ss content,sd size,sd number)
+	sd pointer
+	sd container
+	setcall container getstructcont(number)
+	setcall pointer vars(content,size,container)
+	return pointer
+endfunction
+
+Const notype=0
+
+#null or a pointer to the variable
+Function searchinvars(str content,data size,data ptrtype,data warningssearch,sd setref)
+	Data data#1
+	Data ptrcontainer#1
+
+	Data i#1
+	Data null=NULL
+	Data nrofvars=numberofvars
+
+	Set i 0
+	While i<nrofvars
+		SetCall ptrcontainer getstructcont(i)
+		SetCall data vars_core_ref(content,size,ptrcontainer,warningssearch,setref)
+		If data!=null
+			If warningssearch=null
+				If ptrtype!=null
+					Set ptrtype# i
+				EndIf
+			EndIf
+			Return data
+		endIf
+		Inc i
+	EndWhile
+	Return null
+EndFunction
+
+#null or a pointer to the variable
+Function searchinvars_scope(ss content,sd size,sd ptrtype,sd scope)
+	sd data
+	sd ptrcontainer
+	sd i=0
+	While i<(numberofvars)
+		SetCall ptrcontainer getstructcont_scope(i,scope)
+		SetCall data varscore(content,size,ptrcontainer,(NULL))
+		If data!=(NULL)
+			Set ptrtype# i
+			Return data
+		endIf
+		Inc i
+	EndWhile
+	Return (NULL)
+EndFunction
+#null or a pointer to the variable
+Function searchinvars_scope_warn(sd warningssearch,sd scope)
+	sd data
+	sd ptrcontainer
+	sd i=0
+	While i<(numberofvars)
+		SetCall ptrcontainer getstructcont_scope(i,scope)
+		SetCall data varscore((NULL),0,ptrcontainer,warningssearch)
+		If data!=(NULL)
+			Return data
+		endIf
+		Inc i
+	EndWhile
+	Return (NULL)
+EndFunction
+
+#searchinvars
+Function strinvars(str content,data size,data ptrtype)
+	Data pointer#1
+	SetCall pointer searchinvars(content,size,ptrtype,(NULL),1)
+	Return pointer
+EndFunction
+#searchinvars
+Function strinvars_ignoreref(str content,data size,data ptrtype)
+	Data pointer#1
+	SetCall pointer searchinvars(content,size,ptrtype,(NULL),0)
+	Return pointer
+EndFunction
+
+#err
+Function undefinedvariable()
+	Char undefinedvar="Undefined variable name."
+	Str _undefinedvar^undefinedvar
+	Return _undefinedvar
+EndFunction
+
+const no_cast=Xfile_suffix_cast_none
+const cast_value=Xfile_suffix_cast_value
+const cast_data=Xfile_suffix_cast_data
+const cast_string=Xfile_suffix_cast_string
+
+#err
+Function varsufix(ss content,sd size,sd ptrdata,sd ptrlow,sd ptrsufix)
+	sd err
+	setcall err xfile_add_char_if((Xfile_arg_varfn_dot_no))
+	if err=(noerror)
+		setcall err varsufix_ex(content,size,ptrdata,ptrlow,ptrsufix,(NULL))
+	endif
+	return err
+endfunction
+
+#err
+function varsufix_ex(ss content,sd size,sd ptrdata,sd ptrlow,sd ptrsufix,sd scope)
+	Data type#1
+	Data ptrtype^type
+	Data false=FALSE
+	Data true=TRUE
+	sd err
+	sd cast
+
+	#size is expecting to be greater than zero
+	setcall ptrsufix# sufix_test(content,#size,#cast)
+
+	Data null=NULL
+	Data data#1
+
+	if scope=(NULL)
+		SetCall data strinvars(content,size,ptrtype)
+	else
+		setcall data searchinvars_scope(content,size,ptrtype,scope)
+	endelse
+	If data=null
+		SetCall err undefinedvariable()
+		Return err
+	EndIf
+
+	setcall err xfile_add_varsufix_if(content,size,ptrsufix#,cast)
+	if err=(noerror)
+		Set ptrdata# data
+
+		Data charnumber=charnumber
+		sd prefix
+		setcall prefix prefix_bool()
+
+		If type=charnumber
+			If ptrsufix#=(sufix_true)
+				Char ptrsfxerr="CHAR statement cannot have the pointer sufix."
+				Str _ptrsfxerr^ptrsfxerr
+				Return _ptrsfxerr
+			EndIf
+			if prefix#=0
+				Set ptrlow# true
+			else
+				#need all char address at prefix
+				set ptrlow# false
+			endelse
+		else
+			sd is_str
+			setcall is_str cast_resolve(type,cast,ptrdata,#err)
+			if err=(noerror)
+				If is_str=false
+					Set ptrlow# false
+				Else
+				#str ss
+					If ptrsufix#=(sufix_true)
+						if prefix#=0
+							Set ptrlow# true
+						else
+							Set ptrlow# false
+						endelse
+					Else
+						Set ptrlow# false
+					EndElse
+				EndElse
+			endif
+		endelse
+	endif
+	return err
+EndFunction
+
+#sufix
+function sufix_test(ss content,sd p_size,sd p_cast)
+	add content p_size#
+	dec content
+	if content#!=(pointerascii)
+		if content#=(castascii)
+			setcall p_cast# cast_test(content,p_size)
+			return (sufix_true)
+		endif
+		set p_cast# (no_cast)
+		return (sufix_false)
+	endif
+	dec p_size#
+	set p_cast# (no_cast)
+	call extend_sufix_test(content,p_size)
+	#and, allow prefix and sufix same time, for fun
+	return (sufix_true)
+endfunction
+
+#cast
+function cast_test(ss content,sd p_size)
+	if p_size#>=3 #test only the cast
+		dec content
+		sd c
+		set c content#
+		if c>=(a_from_az)
+			sub c (AZ_to_az)
+		endif
+		if c=(cast_value)
+		elseif c=(cast_data)
+		elseif c=(cast_string)
+		else
+			set c (no_cast)
+		endelse
+		if c!=(no_cast)
+			dec content
+			if content#=(pointerascii)
+				sub p_size# 3
+				call extend_sufix_test(content,p_size)
+				return c
+			endif
+		endif
+	endif
+	return (no_cast)
+endfunction
+
+function tempdataadd(sv ptrdata)
+	sd err
+	sv original;set original ptrdata#
+	sv t%%ptr_tempdata
+	setcall err addtosec(original,(location_and_mask),t)
+	if err=(noerror)
+		call getcontplusReg(t,ptrdata)
+		sub ptrdata# (location_and_mask)
+		call memtomem(ptrdata#,original,(location_and_mask))
+	endif
+	return err
+endfunction
+
+#bool is_string
+function cast_resolve(sd number,sd cast,sv ptrdata,sv p_error)
+	if cast=(no_cast)
+		Data stringsnumber=stringnumber
+		Data stackstringnumber=stackstringnumber
+		if number=stringsnumber
+			return (TRUE)
+		elseif number=stackstringnumber
+			return (TRUE)
+		endelseif
+		return (FALSE)
+	endif
+	if cast!=(cast_string)
+		setcall p_error# tempdataadd(ptrdata)
+
+		sd data;set data ptrdata#
+		add data (maskoffset)
+
+		if cast=(cast_data)
+			and data# (~pointbit)
+		else
+		#cast==(cast_value)
+			sd for_64;setcall for_64 is_for_64()
+			if for_64!=0 #not at sizeof variable, will be xor
+				or data# (pointbit)
+			endif
+		endelse
+		return (FALSE)
+	endif
+	return (TRUE)
+endfunction
--- ocompiler-1.orig/src/files/functions/commons/vars.s
+++ /dev/null
@@ -1,459 +0,0 @@
-
-
-#same or zero
-function warn_or_log(sd type,sd return_value,ss symbolname,sd log_option,sd p_err,sd size)
-	data ptrobject%ptrobject
-	if ptrobject#=(TRUE)
-		if log_option=(log_warn)
-			setcall p_err# addtolog_withchar_ex(symbolname,size,type) #is not calling atunused version, that will return noerror at object false
-			if p_err#=(noerror)
-				return 0
-			endif
-		endif
-	endif
-	return return_value
-endfunction
-#same function, except the array
-function warn_or_log_vars(sd return_value,ss symbolname,sd p_err,sd size)
-	data ptrobject%ptrobject
-	if ptrobject#=(TRUE)
-		data p_o_w%%p_offset_warn
-		if p_o_w#=(log_warn)
-			sd vals;setcall vals vars_log((get),symbolname,size)
-			setcall p_err# addtolog_array_withchar(vals,(log_variable))
-			if p_err#=(noerror)
-				return 0
-			endif
-		endif
-	endif
-	return return_value
-endfunction
-
-function vars_log(sd type,sd val,sd sz)
-	char dot=asciidot
-	#at unnamed entry is: .val , first can be size 0
-	value a#1;data as#1
-	value *^dot;data *=1
-	value c#1;data cs#1
-	value *=NULL
-	if type=(set)
-		set a val
-		set as sz
-	else
-		set c val
-		set cs sz
-		return #a
-	endelse
-endfunction
-function vars_log_reset()
-	call vars_log((set),"",0)
-endfunction
-function vars_log_set(sd a,sd b)
-#preferring to log .var even at main.var to be recognized at ounused(before entry is o.var and vmain.var at the end)
-#                                        and .var is united with a realpath so in a file can be main1.var, in another file can be main2.var
-	call vars_log((set),a,b)
-endfunction
-#err
-function vars_log_prepare(ss content,sd size)
-	data ptrobject%ptrobject
-	if ptrobject#=(TRUE)
-		if size>0  #addvarref..orunref is erroring there for getsign and fndecargs
-			if content#=(unrefsign)
-				return (noerror)
-			elseif content#=(throwlesssign)
-				inc content;dec size
-			endelseif
-		endif
-		sd vals;setcall vals vars_log((get),content,size)
-		sd err
-		setcall err addtolog_array_withchar(vals,(log_offset))
-		return err
-	endif
-	return (noerror)
-endfunction
-
-function vars_core_ref(ss content,sd size,sv ptrstructure,sv warningssearch,sd setref)
-	sd data
-	setcall data vars_core_ref_scope(content,size,ptrstructure,warningssearch,setref,(NULL))
-	return data
-endfunction
-
-#null or a pointer to the constant/variable/function
-function vars_core_ref_scope(ss content,sd size,sv ptrstructure,data warningssearch,sd setref,sd position_pointer)
-	Data zero=0
-	Data varsize#1
-	#Data dwlen=dwsz
-	Data blen=bsz
-
-	Str container#1
-	Data containerReg#1
-	Data ptrcontainer^container
-	Data ptrcontainerReg^containerReg
-	Call getcontandcontReg(ptrstructure,ptrcontainer,ptrcontainerReg)
-	Data entrypoint#1
-
-	sd end;set end container
-	add end containerReg
-	While container!=end
-		Set entrypoint container
-		Add container (location)
-		sd pmask;set pmask container
-		Add container (masksize) #add here, not twice, inside warn_or_log and outside (since logging all variables)
-		If warningssearch!=(NULL)
-			SetCall varsize strlen(container)
-
-			Data ReferenceBit=referencebit
-			Data checkvalue#1
-			Set checkvalue pmask#
-			And checkvalue ReferenceBit
-			data ptrconstants%%ptr_constants;sd cb
-			If checkvalue=zero
-				data returnvalue#1
-				set returnvalue entrypoint
-				#
-				data ptrfunctions%%ptr_functions
-				if ptrfunctions=ptrstructure
-					Set checkvalue pmask#
-					sd against_idata=idatabitfunction
-					and against_idata checkvalue
-					if against_idata=0
-						and checkvalue (x86_64bit)
-						if checkvalue=0
-							data ptrcodeFnObj%ptrcodeFnObj
-							setcall returnvalue warn_or_log((log_function),returnvalue,container,ptrcodeFnObj#,warningssearch,varsize)
-						else
-							#functionx are extern
-							set returnvalue 0
-						endelse
-					endif
-				elseif ptrconstants=ptrstructure
-					setcall cb constants_bool((const_warn_get))
-					setcall returnvalue warn_or_log((log_constant),returnvalue,container,cb,warningssearch,varsize)
-				else
-					setcall returnvalue warn_or_log_vars(returnvalue,container,warningssearch,varsize)
-				endelse
-				if returnvalue!=zero
-					Return returnvalue
-				endif
-			endIf
-			#elseIf ptrconstants==ptrstructure 0x72
-		Else
-			SetCall varsize strlen(container)
-			If varsize=size
-				Data cmpret#1
-				SetCall cmpret memcmp(container,content,size)
-				If cmpret=zero
-					#if set the reference is true
-					if setref=1
-						#go back from string to mask
-						#Sub container dwlen
-
-						#get the value and change the reference bit of the mask to true
-						Data value#1
-						Set value pmask#
-						Data referenceBit=referencebit
-						Or value referenceBit
-						Set pmask# value
-					endif
-					Return entrypoint
-				EndIf
-			EndIf
-			if position_pointer!=(NULL)
-				#are mixed with imports
-				sd against=idatabitfunction
-				and against pmask#
-				if against=0
-					inc position_pointer#
-				endif
-			endif
-		endElse
-		Add varsize blen
-		Add container varsize
-	EndWhile
-	Return zero
-endfunction
-
-#null or a pointer to the constant/variable/function
-Function varscore(str content,data size,data ptrstructure,data warningssearch)
-	sd pointer
-	setcall pointer vars_core_ref(content,size,ptrstructure,warningssearch,1)
-	return pointer
-EndFunction
-
-#vars_core_ref
-function vars_ignoreref(str content,data size,data ptrstructure)
-	Data pointer#1
-	Data false=FALSE
-	SetCall pointer vars_core_ref(content,size,ptrstructure,(NULL),false)
-	Return pointer
-endfunction
-
-#varscore
-Function vars(str content,data size,data ptrstructure)
-	Data pointer#1
-	SetCall pointer varscore(content,size,ptrstructure,(NULL))
-	Return pointer
-EndFunction
-
-function vars_number(ss content,sd size,sd number)
-	sd pointer
-	sd container
-	setcall container getstructcont(number)
-	setcall pointer vars(content,size,container)
-	return pointer
-endfunction
-
-Const notype=0
-
-#null or a pointer to the variable
-Function searchinvars(str content,data size,data ptrtype,data warningssearch,sd setref)
-	Data data#1
-	Data ptrcontainer#1
-
-	Data i#1
-	Data null=NULL
-	Data nrofvars=numberofvars
-
-	Set i 0
-	While i<nrofvars
-		SetCall ptrcontainer getstructcont(i)
-		SetCall data vars_core_ref(content,size,ptrcontainer,warningssearch,setref)
-		If data!=null
-			If warningssearch=null
-				If ptrtype!=null
-					Set ptrtype# i
-				EndIf
-			EndIf
-			Return data
-		endIf
-		Inc i
-	EndWhile
-	Return null
-EndFunction
-
-#null or a pointer to the variable
-Function searchinvars_scope(ss content,sd size,sd ptrtype,sd scope)
-	sd data
-	sd ptrcontainer
-	sd i=0
-	While i<(numberofvars)
-		SetCall ptrcontainer getstructcont_scope(i,scope)
-		SetCall data varscore(content,size,ptrcontainer,(NULL))
-		If data!=(NULL)
-			Set ptrtype# i
-			Return data
-		endIf
-		Inc i
-	EndWhile
-	Return (NULL)
-EndFunction
-#null or a pointer to the variable
-Function searchinvars_scope_warn(sd warningssearch,sd scope)
-	sd data
-	sd ptrcontainer
-	sd i=0
-	While i<(numberofvars)
-		SetCall ptrcontainer getstructcont_scope(i,scope)
-		SetCall data varscore((NULL),0,ptrcontainer,warningssearch)
-		If data!=(NULL)
-			Return data
-		endIf
-		Inc i
-	EndWhile
-	Return (NULL)
-EndFunction
-
-#searchinvars
-Function strinvars(str content,data size,data ptrtype)
-	Data pointer#1
-	SetCall pointer searchinvars(content,size,ptrtype,(NULL),1)
-	Return pointer
-EndFunction
-#searchinvars
-Function strinvars_ignoreref(str content,data size,data ptrtype)
-	Data pointer#1
-	SetCall pointer searchinvars(content,size,ptrtype,(NULL),0)
-	Return pointer
-EndFunction
-
-#err
-Function undefinedvariable()
-	Char undefinedvar="Undefined variable name."
-	Str _undefinedvar^undefinedvar
-	Return _undefinedvar
-EndFunction
-
-const no_cast=Xfile_suffix_cast_none
-const cast_value=Xfile_suffix_cast_value
-const cast_data=Xfile_suffix_cast_data
-const cast_string=Xfile_suffix_cast_string
-
-#err
-Function varsufix(ss content,sd size,sd ptrdata,sd ptrlow,sd ptrsufix)
-	sd err
-	setcall err xfile_add_char_if((Xfile_arg_varfn_dot_no))
-	if err=(noerror)
-		setcall err varsufix_ex(content,size,ptrdata,ptrlow,ptrsufix,(NULL))
-	endif
-	return err
-endfunction
-
-#err
-function varsufix_ex(ss content,sd size,sd ptrdata,sd ptrlow,sd ptrsufix,sd scope)
-	Data type#1
-	Data ptrtype^type
-	Data false=FALSE
-	Data true=TRUE
-	sd err
-	sd cast
-
-	#size is expecting to be greater than zero
-	setcall ptrsufix# sufix_test(content,#size,#cast)
-
-	Data null=NULL
-	Data data#1
-
-	if scope=(NULL)
-		SetCall data strinvars(content,size,ptrtype)
-	else
-		setcall data searchinvars_scope(content,size,ptrtype,scope)
-	endelse
-	If data=null
-		SetCall err undefinedvariable()
-		Return err
-	EndIf
-
-	setcall err xfile_add_varsufix_if(content,size,ptrsufix#,cast)
-	if err=(noerror)
-		Set ptrdata# data
-
-		Data charnumber=charnumber
-		sd prefix
-		setcall prefix prefix_bool()
-
-		If type=charnumber
-			If ptrsufix#=(sufix_true)
-				Char ptrsfxerr="CHAR statement cannot have the pointer sufix."
-				Str _ptrsfxerr^ptrsfxerr
-				Return _ptrsfxerr
-			EndIf
-			if prefix#=0
-				Set ptrlow# true
-			else
-				#need all char address at prefix
-				set ptrlow# false
-			endelse
-		else
-			sd is_str
-			setcall is_str cast_resolve(type,cast,ptrdata,#err)
-			if err=(noerror)
-				If is_str=false
-					Set ptrlow# false
-				Else
-				#str ss
-					If ptrsufix#=(sufix_true)
-						if prefix#=0
-							Set ptrlow# true
-						else
-							Set ptrlow# false
-						endelse
-					Else
-						Set ptrlow# false
-					EndElse
-				EndElse
-			endif
-		endelse
-	endif
-	return err
-EndFunction
-
-#sufix
-function sufix_test(ss content,sd p_size,sd p_cast)
-	add content p_size#
-	dec content
-	if content#!=(pointerascii)
-		if content#=(castascii)
-			setcall p_cast# cast_test(content,p_size)
-			return (sufix_true)
-		endif
-		set p_cast# (no_cast)
-		return (sufix_false)
-	endif
-	dec p_size#
-	set p_cast# (no_cast)
-	call extend_sufix_test(content,p_size)
-	#and, allow prefix and sufix same time, for fun
-	return (sufix_true)
-endfunction
-
-#cast
-function cast_test(ss content,sd p_size)
-	if p_size#>=3 #test only the cast
-		dec content
-		sd c
-		set c content#
-		if c>=(a_from_az)
-			sub c (AZ_to_az)
-		endif
-		if c=(cast_value)
-		elseif c=(cast_data)
-		elseif c=(cast_string)
-		else
-			set c (no_cast)
-		endelse
-		if c!=(no_cast)
-			dec content
-			if content#=(pointerascii)
-				sub p_size# 3
-				call extend_sufix_test(content,p_size)
-				return c
-			endif
-		endif
-	endif
-	return (no_cast)
-endfunction
-
-function tempdataadd(sv ptrdata)
-	sd err
-	sv original;set original ptrdata#
-	sv t%%ptr_tempdata
-	setcall err addtosec(original,(location_and_mask),t)
-	if err=(noerror)
-		call getcontplusReg(t,ptrdata)
-		sub ptrdata# (location_and_mask)
-		call memtomem(ptrdata#,original,(location_and_mask))
-	endif
-	return err
-endfunction
-
-#bool is_string
-function cast_resolve(sd number,sd cast,sv ptrdata,sv p_error)
-	if cast=(no_cast)
-		Data stringsnumber=stringnumber
-		Data stackstringnumber=stackstringnumber
-		if number=stringsnumber
-			return (TRUE)
-		elseif number=stackstringnumber
-			return (TRUE)
-		endelseif
-		return (FALSE)
-	endif
-	if cast!=(cast_string)
-		setcall p_error# tempdataadd(ptrdata)
-
-		sd data;set data ptrdata#
-		add data (maskoffset)
-
-		if cast=(cast_data)
-			and data# (~pointbit)
-		else
-		#cast==(cast_value)
-			sd for_64;setcall for_64 is_for_64()
-			if for_64!=0 #not at sizeof variable, will be xor
-				or data# (pointbit)
-			endif
-		endelse
-		return (FALSE)
-	endif
-	return (TRUE)
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/dataassign.oc
@@ -0,0 +1,532 @@
+
+
+#err
+Function dataassign(sd ptrcontent,sd ptrsize,sd sign,sd valsize,sd typenumber,sd punitsize,sd long_mask,sd relocbool,sd dataxrel,sd stack,sd is_expand)
+	Data false=FALSE
+	Data true=TRUE
+	Str err#1
+	Data noerr=noerror
+	char nosign=nosign
+
+	Data constantsnr=constantsnumber
+	Data charnr=charnumber
+	Data stringsnr=stringnumber
+
+	data offset_const#1
+	Data ptroffset_const^offset_const
+	Data constantsstruct%%ptr_constants
+	#Data pointer_structure#1
+	#at constants and at data^sd,str^ss
+
+	#for size of var
+	sd reg;sd ptr_reserve
+
+	if punitsize=(NULL)
+		if typenumber=constantsnr
+			#this can't go after dataparse, addvarref will increase the offset
+			Call getcontReg(constantsstruct,ptroffset_const)
+			SetCall err addvarreferenceorunref(ptrcontent,ptrsize,valsize,typenumber,long_mask) #there are 2 more argument but are not used
+			#it is not a mistake to go with 0 mask in variable from here to addaref
+			If err!=noerr;Return err;EndIf
+		else
+			sd immovable_struct_cont
+			if stack=(TRUE)
+				sd sectiontypenumber=totalmemvariables
+				add sectiontypenumber typenumber
+				#
+				setcall immovable_struct_cont getstructcont(sectiontypenumber)
+				call getcontReg(immovable_struct_cont,#reg)
+				#
+				SetCall err addvarreferenceorunref(ptrcontent,ptrsize,valsize,sectiontypenumber,long_mask,0) #there is 1 more argument but is not used
+			else
+				#
+				setcall immovable_struct_cont getstructcont(typenumber)
+				call getcontReg(immovable_struct_cont,#reg)
+				#
+				SetCall err addvarreferenceorunref(ptrcontent,ptrsize,valsize,typenumber,long_mask,0,is_expand)
+			endelse
+			If err!=noerr;Return err;EndIf
+
+			#for size of var
+			call getcont(immovable_struct_cont,#ptr_reserve)
+			add ptr_reserve reg
+			add ptr_reserve (maskoffset_reserve)
+			call i_to_s(1,ptr_reserve) #why not set # 1? anyone can modify in peace and not set this part if not required. is this a plan? don't care
+
+			if sign=nosign
+				#stack variable declared without assignation, only increment stack variables
+				call addramp(#err)
+				Return err
+			endif
+		endelse
+	else
+		call advancecursors(ptrcontent,ptrsize,valsize)
+	endelse
+
+	call spaces(ptrcontent,ptrsize) #since 5 131
+	Call stepcursors(ptrcontent,ptrsize)
+
+	Data size#1
+	Set size ptrsize#
+	If size=0
+		#not at unitsize: constants,stacks
+		Char rightsideerr="Right side of the assignment expected."
+		Str ptrrightsideerr^rightsideerr
+		Return ptrrightsideerr
+	endIf
+
+	data rightstackpointer#1
+
+	Data relocindx#1
+	Data dataind=dataind
+
+	Data value#1
+	Data ptrvalue^value
+
+	Str content#1
+	Data ptrdatasec%%ptr_datasec
+	Data ptrcodesec%%ptr_codesec
+	Data ptrfunctions%%ptr_functions
+
+	Data zero=0
+
+	data valuewritesize#1
+	#is for char name="value" or str name="value"
+	data stringtodata#1
+	#is for char name="value"
+	data skipNumberValue#1
+	Data importbittest#1
+
+	set rightstackpointer false
+	Set relocindx dataind
+	set valuewritesize (dwsz)
+	set stringtodata false
+	set skipNumberValue false
+	set importbittest -1
+
+	If sign=(assignsign)
+		Set content ptrcontent#
+		#if byte==(relsign)
+		if relocbool=true
+			if dataxrel=true
+				Call stepcursors(ptrcontent,ptrsize)
+				Call stepcursors(#content,#size)
+				#this was moved from here because of xfile, to know datax relocation
+				#If size==0
+				#	#to not set byte in vain
+				#	Return ptrrightsideerr
+				#endIf
+				#this comparation is not for char and const is excluded at getsign
+				#if relocbool!=true
+				#	return "Unexpected relocation sign."
+				#endif
+				vdata ptr_nobits_virtual%ptr_nobits_virtual
+				if ptr_nobits_virtual#=(Yes)
+					set relocindx (dtnbind)
+				endif
+				#Set byte content#
+			endif
+		endif
+		Char byte#1
+		Set byte content#
+		Char groupstart="{"
+		If byte!=groupstart
+			char stringstart=asciidoublequote
+			If byte=stringstart
+			#"text"
+				If typenumber=charnr
+					if stack=false
+					#else is at stack value   grep stackfilter2   2
+						set stringtodata true
+						set skipNumberValue true
+						if punitsize!=(NULL)
+							set punitsize# 1    #was 1 from bsz is 1 from null end
+						endif
+					endif
+				ElseIf typenumber=stringsnr
+					set stringtodata true
+					if punitsize=(NULL)
+						setcall value get_img_vdata_dataReg()
+						if stack=false
+							if long_mask!=0
+								add value (qwsz)
+							else
+								add value (dwsz)
+								addcall value reloc64_mid()
+							endelse
+						endif
+						if relocbool=true
+							str badrelocstr="Relocation sign and string surrounded by quotations is not allowed."
+							return badrelocstr
+						endif
+						set relocbool true
+					else
+						#let relocationsign, mess with dataReg, possible error will be catched at pass_write
+						inc punitsize#   #null end
+						if stack=false
+							if long_mask=0
+								#for ^ and rel64 write is somewhere else
+								addcall punitsize# reloc64_mid()
+							endif
+						endif
+					endelse
+				EndElseIf
+				if stringtodata=false
+					char bytesatintegers="The string assignment (\"\") can be used at CHAR, STR or SS."
+					str bytesatints^bytesatintegers
+					return bytesatints
+				endif
+				if punitsize=(NULL)
+					setcall err xfile_add_char_if((Xfile_declmode_string))
+					If err!=noerr;Return err;EndIf
+				endif
+			Else
+			#=value+constant-/&...
+				if punitsize!=(NULL)
+				#dwsz or bsz  or qwsz
+				#ss =% x is 0
+					call advancecursors(ptrcontent,ptrsize,size)
+					return (noerror)
+				elseif typenumber!=constantsnr ##constant=value is declared at pass_init
+					setcall err xfile_add_char_if((Xfile_declmode_value))
+					If err!=noerr;Return err;EndIf
+				endelseif
+				SetCall err parseoperations(ptrcontent,ptrsize,size,ptrvalue,(TRUE))
+				if err!=noerr
+					return err
+				endif
+				If typenumber=charnr
+					if stack=false
+					#else is at stack value   grep stackfilter2   3
+						set valuewritesize (bsz)
+					endif
+				EndIf
+			EndElse
+		Else
+		#{} group
+			if punitsize!=(NULL)
+				if stack=true
+				#ss =% {}      is 0
+					call advancecursors(ptrcontent,ptrsize,size)
+					return (noerror)
+				endif
+			else
+				setcall err xfile_add_char_if((Xfile_declmode_group))
+				If err!=noerr;Return err;EndIf
+			endelse
+			If typenumber=constantsnr
+				Char constgroup="Group begin sign ('{') is not expected to declare a constant."
+				Str ptrconstgroup^constgroup
+				Return ptrconstgroup
+			EndIf
+			Call stepcursors(ptrcontent,ptrsize)
+			Set content ptrcontent#
+			Set size ptrsize#
+			Data sz#1
+			Char groupstop="}"
+			SetCall sz valinmem(content,size,groupstop)
+			If sz=size
+				Char groupend="Group end sign ('}') expected."
+				Str ptrgroupend^groupend
+				Return ptrgroupend
+			EndIf
+			if punitsize=(NULL)
+				SetCall err enumcommas(ptrcontent,ptrsize,sz,true,typenumber,(NULL),(not_hexenum),stack,long_mask,relocbool,relocindx)
+				If err!=noerr;Return err;EndIf
+				setcall err xfile_add_commas_if()
+				If err!=noerr;Return err;EndIf
+			else
+				sd aux;set aux punitsize#
+				set punitsize# 0   #will add unit sizes inside
+				Call enumcommas(ptrcontent,ptrsize,sz,true,typenumber,punitsize,aux) #there are 4 more arguments but are not used
+			endelse
+			Call stepcursors(ptrcontent,ptrsize)
+			Return noerr
+		EndElse
+	ElseIf sign=(reservesign)
+		setcall err get_reserve_size(ptrcontent,ptrsize,size,ptrvalue,stack,typenumber,long_mask,ptr_reserve)
+		if err=(noerror)
+			if punitsize!=(NULL)
+				set punitsize# value
+				return (noerror)
+			endif
+			if stack=false
+				if is_expand=(TRUE)
+					vdata ptrdataSize%ptrdataSize
+					add ptrdataSize# value
+				else
+					setcall err set_reserve(value)
+				endelse
+			else
+				call growramp(value,#err)
+			endelse
+		endif
+		Return err
+	Else
+	#^ pointer
+		if punitsize!=(NULL)
+			call advancecursors(ptrcontent,ptrsize,size)
+			return (noerror)
+		endif
+		Set content ptrcontent#
+		data doublepointer#1
+		set doublepointer zero
+		if content#=(pointersigndeclare)
+			inc doublepointer
+			call stepcursors(ptrcontent,ptrsize)
+			Set content ptrcontent#
+			set size ptrsize#
+		endif
+		Data tp=notype
+		Data pointer#1
+		call arg_size(content,size,#size)
+		SetCall pointer strinvars(content,size,tp)
+		If pointer!=zero
+			data rightstackbit#1
+			setcall rightstackbit stackbit(pointer)
+			if rightstackbit=0
+				Set value pointer#
+
+				#data^datax or sd^datax
+				#before expandbit at class: expandbit already has nobits_virtual previous test
+				sd expand;setcall expand expandbit_wrap(pointer)
+				if expand!=0
+					set relocindx (dtnbind)
+				endif
+			else
+				set relocbool false
+				if stack=false
+					If typenumber!=constantsnr
+					#data^stack
+						setcall err writetake((eaxregnumber),pointer)
+						If err!=noerr
+							Return err
+						EndIf
+						setcall value get_img_vdata_dataReg()
+						setcall err datatake_reloc((edxregnumber),value)
+						If err!=noerr
+							Return err
+						EndIf
+						sd v64;setcall v64 val64_p_get()
+						if long_mask!=0
+							setcall v64# is_for_64()
+						else
+							set v64# (val64_no)
+						endelse
+						setcall err writeoperation_op((moveatmemtheproc),(FALSE),(eaxregnumber),(edxregnumber))
+						If err!=noerr
+							Return err
+						EndIf
+					Else
+						set value pointer#
+					endElse
+				else
+					set rightstackpointer pointer
+				endelse
+			endelse
+		Else
+			If typenumber=constantsnr
+				SetCall err undefinedvariable()
+				Return err
+			EndIf
+			SetCall pointer vars(content,size,ptrfunctions)
+			If pointer=zero
+				setcall err undefinedvar_fn()
+				return err
+			EndIf
+
+			setcall importbittest importbit(pointer)
+			setcall value get_function_value(importbittest,pointer)
+
+			Data ptrobject%ptrobject
+			If ptrobject#=false
+				data addatend#1
+				data ptrvirtualimportsoffset%ptrvirtualimportsoffset
+				data ptrvirtuallocalsoffset%ptrvirtuallocalsoffset
+				If importbittest=false
+					set addatend ptrvirtuallocalsoffset
+				else
+					if doublepointer=zero
+						str doubleexp="Double pointer (^^) expected in this case: executable format and imported function."
+						return doubleexp
+					endif
+					dec doublepointer
+					set addatend ptrvirtualimportsoffset
+				endelse
+
+				sd section
+				sd section_offset
+				if stack=false
+					set section ptrdatasec
+					set section_offset zero
+				else
+					set section ptrcodesec
+					data stackoff=rampadd_value_off
+					set section_offset stackoff
+				endelse
+				setcall err unresolvedcallsfn(section,section_offset,addatend) #this is intentionaly without last arg
+				If err!=noerr
+					Return err
+				EndIf
+			Else
+				setcall relocindx get_function_values(importbittest,#value,pointer)
+			EndElse
+		EndElse
+		if doublepointer!=zero
+			str unexpdp="Unexpected double pointer."
+			return unexpdp
+		endif
+		setcall err xfile_add_string_if(content,size)
+		if err!=noerr;return err;endif
+		Call advancecursors(ptrcontent,ptrsize,size)
+	EndElse
+	if skipNumberValue=false
+		If typenumber!=constantsnr
+			#it can be data% but with R_X86_64_64 at prefs and that will force 8 bytes
+			if punitsize=(NULL)
+				#init -1, 0 is local function in the right
+				if importbittest=0
+					sd p_inplace_reloc_pref%p_inplace_reloc_pref
+					#at addend 0 at data/code must not pe resolved
+					if p_inplace_reloc_pref#!=(zero_reloc)
+						if stack=false
+							setcall err unresLc(0,ptrdatasec,0)
+						else
+							#it's only an imm to reg
+							sd stack_off;setcall stack_off reloc64_offset((rampadd_value_off))
+							setcall err unresLc(stack_off,ptrcodesec,0)
+						endelse
+						if err!=(noerror)
+							return err
+						endif
+					endif
+				endif
+				#addtocode(#test,1,code) cannot add to code for test will trick the next compiler, entry is started,will look like a bug
+				setcall err writevar(ptrvalue,valuewritesize,relocindx,stack,rightstackpointer,long_mask,relocbool)
+				If err!=noerr
+					Return err
+				EndIf
+			endif
+		Else
+			Data container#1
+			Data ptrcontainer^container
+			Call getcont(constantsstruct,ptrcontainer)
+			Add container offset_const
+			Set container# value
+		EndElse
+	endif
+	if stringtodata=true
+		sd escapes
+		SetCall err quotinmem(ptrcontent,ptrsize,ptrvalue,#escapes)
+		if punitsize=(NULL)
+			SetCall err addtosecstresc_xfile(ptrcontent,ptrsize,value,escapes,ptrdatasec)
+			return err
+		else
+			sub value escapes
+			add punitsize# value
+			call advancecursors(ptrcontent,ptrsize,ptrsize#)
+		endelse
+	endif
+	Return noerr
+EndFunction
+
+function undefinedvar_fn()
+	return "Undefined variable/function name."
+endfunction
+
+#value
+function get_function_value(sd impbit,sd pointer)
+	if impbit!=0
+		#imports
+		return pointer#
+	endif
+	#local
+	sd value
+	call get_fn_pos(pointer,#value)
+	return value
+endfunction
+#relocindex
+function get_function_values(sd impbit,sd p_value,sd pointer)
+	If impbit=0
+		#code
+		return (codeind)
+	endif
+	#import
+	set p_value# 0
+	return pointer#
+endfunction
+
+#err
+function get_reserve_size(sv ptrcontent,sd ptrsize,sd size,sd ptrvalue,sd is_stack,sd typenumber,sd long_mask,sd ptr_reserve)
+	sd err
+	SetCall err parseoperations(ptrcontent,ptrsize,size,ptrvalue,(TRUE))
+	If err!=(noerror)
+		Return err
+	EndIf
+	Char negreserve="Unexpected negative value at reserve declaration."
+	vStr ptrnegreserve^negreserve
+	If ptrvalue#<0
+		Return ptrnegreserve
+	EndIf
+
+	sd value;set value ptrvalue#
+	vdata p_parses%ptr_parses
+	if p_parses=(pass_write)
+	#ptr_reserve is undefined at another pass (and theoretically at constants)
+		if value<=(wmax)
+			call i_to_s(value,ptr_reserve)
+		else
+			call i_to_s(0,ptr_reserve)
+		endelse
+	endif
+
+	if is_stack=(FALSE)
+		If typenumber!=(charnumber)
+			SetCall err maxsectioncheck(value,ptrvalue)
+			If err=(noerror)
+				SetCall err maxsectioncheck(ptrvalue#,ptrvalue)
+				If err=(noerror)
+					if long_mask!=0
+						SetCall err maxsectioncheck(ptrvalue#,ptrvalue)
+					endif
+				endIf
+			EndIf
+		EndIf
+	else
+		SetCall err maxsectioncheck(value,ptrvalue)
+		If err=(noerror)
+			SetCall err maxsectioncheck(ptrvalue#,ptrvalue)
+			If err=(noerror)
+				#at format 64 can be a *2 at growramp
+				sd b;setcall b is_for_64()
+				if b=(TRUE)
+					SetCall err maxsectioncheck(ptrvalue#,ptrvalue)
+				endIf
+			endIf
+		endIf
+	endelse
+	Return err
+endfunction
+
+#err
+function set_reserve(sd value)
+	vData ptrdatasec%%ptr_datasec
+	sd p_nul_res_pref%p_nul_res_pref
+	if p_nul_res_pref#!=(FALSE)
+		sd reg;call getcontReg(ptrdatasec,#reg)
+	endif
+	sd err
+	SetCall err addtosec(0,value,ptrdatasec)
+	If err=(noerror)
+		if p_nul_res_pref#!=(FALSE)
+			sd cont;call getcont(ptrdatasec,#cont)
+			add cont reg
+			if p_nul_res_pref#=(TRUE)
+				call memset(cont,0,value)
+			else
+				call memset(cont,~0,value)
+			endelse
+		endif
+	EndIf
+	Return err
+endfunction
--- ocompiler-1.orig/src/files/functions/dataassign.s
+++ /dev/null
@@ -1,532 +0,0 @@
-
-
-#err
-Function dataassign(sd ptrcontent,sd ptrsize,sd sign,sd valsize,sd typenumber,sd punitsize,sd long_mask,sd relocbool,sd dataxrel,sd stack,sd is_expand)
-	Data false=FALSE
-	Data true=TRUE
-	Str err#1
-	Data noerr=noerror
-	char nosign=nosign
-
-	Data constantsnr=constantsnumber
-	Data charnr=charnumber
-	Data stringsnr=stringnumber
-
-	data offset_const#1
-	Data ptroffset_const^offset_const
-	Data constantsstruct%%ptr_constants
-	#Data pointer_structure#1
-	#at constants and at data^sd,str^ss
-
-	#for size of var
-	sd reg;sd ptr_reserve
-
-	if punitsize=(NULL)
-		if typenumber=constantsnr
-			#this can't go after dataparse, addvarref will increase the offset
-			Call getcontReg(constantsstruct,ptroffset_const)
-			SetCall err addvarreferenceorunref(ptrcontent,ptrsize,valsize,typenumber,long_mask) #there are 2 more argument but are not used
-			#it is not a mistake to go with 0 mask in variable from here to addaref
-			If err!=noerr;Return err;EndIf
-		else
-			sd immovable_struct_cont
-			if stack=(TRUE)
-				sd sectiontypenumber=totalmemvariables
-				add sectiontypenumber typenumber
-				#
-				setcall immovable_struct_cont getstructcont(sectiontypenumber)
-				call getcontReg(immovable_struct_cont,#reg)
-				#
-				SetCall err addvarreferenceorunref(ptrcontent,ptrsize,valsize,sectiontypenumber,long_mask,0) #there is 1 more argument but is not used
-			else
-				#
-				setcall immovable_struct_cont getstructcont(typenumber)
-				call getcontReg(immovable_struct_cont,#reg)
-				#
-				SetCall err addvarreferenceorunref(ptrcontent,ptrsize,valsize,typenumber,long_mask,0,is_expand)
-			endelse
-			If err!=noerr;Return err;EndIf
-
-			#for size of var
-			call getcont(immovable_struct_cont,#ptr_reserve)
-			add ptr_reserve reg
-			add ptr_reserve (maskoffset_reserve)
-			call i_to_s(1,ptr_reserve) #why not set # 1? anyone can modify in peace and not set this part if not required. is this a plan? don't care
-
-			if sign=nosign
-				#stack variable declared without assignation, only increment stack variables
-				call addramp(#err)
-				Return err
-			endif
-		endelse
-	else
-		call advancecursors(ptrcontent,ptrsize,valsize)
-	endelse
-
-	call spaces(ptrcontent,ptrsize) #since 5 131
-	Call stepcursors(ptrcontent,ptrsize)
-
-	Data size#1
-	Set size ptrsize#
-	If size=0
-		#not at unitsize: constants,stacks
-		Char rightsideerr="Right side of the assignment expected."
-		Str ptrrightsideerr^rightsideerr
-		Return ptrrightsideerr
-	endIf
-
-	data rightstackpointer#1
-
-	Data relocindx#1
-	Data dataind=dataind
-
-	Data value#1
-	Data ptrvalue^value
-
-	Str content#1
-	Data ptrdatasec%%ptr_datasec
-	Data ptrcodesec%%ptr_codesec
-	Data ptrfunctions%%ptr_functions
-
-	Data zero=0
-
-	data valuewritesize#1
-	#is for char name="value" or str name="value"
-	data stringtodata#1
-	#is for char name="value"
-	data skipNumberValue#1
-	Data importbittest#1
-
-	set rightstackpointer false
-	Set relocindx dataind
-	set valuewritesize (dwsz)
-	set stringtodata false
-	set skipNumberValue false
-	set importbittest -1
-
-	If sign=(assignsign)
-		Set content ptrcontent#
-		#if byte==(relsign)
-		if relocbool=true
-			if dataxrel=true
-				Call stepcursors(ptrcontent,ptrsize)
-				Call stepcursors(#content,#size)
-				#this was moved from here because of xfile, to know datax relocation
-				#If size==0
-				#	#to not set byte in vain
-				#	Return ptrrightsideerr
-				#endIf
-				#this comparation is not for char and const is excluded at getsign
-				#if relocbool!=true
-				#	return "Unexpected relocation sign."
-				#endif
-				vdata ptr_nobits_virtual%ptr_nobits_virtual
-				if ptr_nobits_virtual#=(Yes)
-					set relocindx (dtnbind)
-				endif
-				#Set byte content#
-			endif
-		endif
-		Char byte#1
-		Set byte content#
-		Char groupstart="{"
-		If byte!=groupstart
-			char stringstart=asciidoublequote
-			If byte=stringstart
-			#"text"
-				If typenumber=charnr
-					if stack=false
-					#else is at stack value   grep stackfilter2   2
-						set stringtodata true
-						set skipNumberValue true
-						if punitsize!=(NULL)
-							set punitsize# 1    #was 1 from bsz is 1 from null end
-						endif
-					endif
-				ElseIf typenumber=stringsnr
-					set stringtodata true
-					if punitsize=(NULL)
-						setcall value get_img_vdata_dataReg()
-						if stack=false
-							if long_mask!=0
-								add value (qwsz)
-							else
-								add value (dwsz)
-								addcall value reloc64_mid()
-							endelse
-						endif
-						if relocbool=true
-							str badrelocstr="Relocation sign and string surrounded by quotations is not allowed."
-							return badrelocstr
-						endif
-						set relocbool true
-					else
-						#let relocationsign, mess with dataReg, possible error will be catched at pass_write
-						inc punitsize#   #null end
-						if stack=false
-							if long_mask=0
-								#for ^ and rel64 write is somewhere else
-								addcall punitsize# reloc64_mid()
-							endif
-						endif
-					endelse
-				EndElseIf
-				if stringtodata=false
-					char bytesatintegers="The string assignment (\"\") can be used at CHAR, STR or SS."
-					str bytesatints^bytesatintegers
-					return bytesatints
-				endif
-				if punitsize=(NULL)
-					setcall err xfile_add_char_if((Xfile_declmode_string))
-					If err!=noerr;Return err;EndIf
-				endif
-			Else
-			#=value+constant-/&...
-				if punitsize!=(NULL)
-				#dwsz or bsz  or qwsz
-				#ss =% x is 0
-					call advancecursors(ptrcontent,ptrsize,size)
-					return (noerror)
-				elseif typenumber!=constantsnr ##constant=value is declared at pass_init
-					setcall err xfile_add_char_if((Xfile_declmode_value))
-					If err!=noerr;Return err;EndIf
-				endelseif
-				SetCall err parseoperations(ptrcontent,ptrsize,size,ptrvalue,(TRUE))
-				if err!=noerr
-					return err
-				endif
-				If typenumber=charnr
-					if stack=false
-					#else is at stack value   grep stackfilter2   3
-						set valuewritesize (bsz)
-					endif
-				EndIf
-			EndElse
-		Else
-		#{} group
-			if punitsize!=(NULL)
-				if stack=true
-				#ss =% {}      is 0
-					call advancecursors(ptrcontent,ptrsize,size)
-					return (noerror)
-				endif
-			else
-				setcall err xfile_add_char_if((Xfile_declmode_group))
-				If err!=noerr;Return err;EndIf
-			endelse
-			If typenumber=constantsnr
-				Char constgroup="Group begin sign ('{') is not expected to declare a constant."
-				Str ptrconstgroup^constgroup
-				Return ptrconstgroup
-			EndIf
-			Call stepcursors(ptrcontent,ptrsize)
-			Set content ptrcontent#
-			Set size ptrsize#
-			Data sz#1
-			Char groupstop="}"
-			SetCall sz valinmem(content,size,groupstop)
-			If sz=size
-				Char groupend="Group end sign ('}') expected."
-				Str ptrgroupend^groupend
-				Return ptrgroupend
-			EndIf
-			if punitsize=(NULL)
-				SetCall err enumcommas(ptrcontent,ptrsize,sz,true,typenumber,(NULL),(not_hexenum),stack,long_mask,relocbool,relocindx)
-				If err!=noerr;Return err;EndIf
-				setcall err xfile_add_commas_if()
-				If err!=noerr;Return err;EndIf
-			else
-				sd aux;set aux punitsize#
-				set punitsize# 0   #will add unit sizes inside
-				Call enumcommas(ptrcontent,ptrsize,sz,true,typenumber,punitsize,aux) #there are 4 more arguments but are not used
-			endelse
-			Call stepcursors(ptrcontent,ptrsize)
-			Return noerr
-		EndElse
-	ElseIf sign=(reservesign)
-		setcall err get_reserve_size(ptrcontent,ptrsize,size,ptrvalue,stack,typenumber,long_mask,ptr_reserve)
-		if err=(noerror)
-			if punitsize!=(NULL)
-				set punitsize# value
-				return (noerror)
-			endif
-			if stack=false
-				if is_expand=(TRUE)
-					vdata ptrdataSize%ptrdataSize
-					add ptrdataSize# value
-				else
-					setcall err set_reserve(value)
-				endelse
-			else
-				call growramp(value,#err)
-			endelse
-		endif
-		Return err
-	Else
-	#^ pointer
-		if punitsize!=(NULL)
-			call advancecursors(ptrcontent,ptrsize,size)
-			return (noerror)
-		endif
-		Set content ptrcontent#
-		data doublepointer#1
-		set doublepointer zero
-		if content#=(pointersigndeclare)
-			inc doublepointer
-			call stepcursors(ptrcontent,ptrsize)
-			Set content ptrcontent#
-			set size ptrsize#
-		endif
-		Data tp=notype
-		Data pointer#1
-		call arg_size(content,size,#size)
-		SetCall pointer strinvars(content,size,tp)
-		If pointer!=zero
-			data rightstackbit#1
-			setcall rightstackbit stackbit(pointer)
-			if rightstackbit=0
-				Set value pointer#
-
-				#data^datax or sd^datax
-				#before expandbit at class: expandbit already has nobits_virtual previous test
-				sd expand;setcall expand expandbit_wrap(pointer)
-				if expand!=0
-					set relocindx (dtnbind)
-				endif
-			else
-				set relocbool false
-				if stack=false
-					If typenumber!=constantsnr
-					#data^stack
-						setcall err writetake((eaxregnumber),pointer)
-						If err!=noerr
-							Return err
-						EndIf
-						setcall value get_img_vdata_dataReg()
-						setcall err datatake_reloc((edxregnumber),value)
-						If err!=noerr
-							Return err
-						EndIf
-						sd v64;setcall v64 val64_p_get()
-						if long_mask!=0
-							setcall v64# is_for_64()
-						else
-							set v64# (val64_no)
-						endelse
-						setcall err writeoperation_op((moveatmemtheproc),(FALSE),(eaxregnumber),(edxregnumber))
-						If err!=noerr
-							Return err
-						EndIf
-					Else
-						set value pointer#
-					endElse
-				else
-					set rightstackpointer pointer
-				endelse
-			endelse
-		Else
-			If typenumber=constantsnr
-				SetCall err undefinedvariable()
-				Return err
-			EndIf
-			SetCall pointer vars(content,size,ptrfunctions)
-			If pointer=zero
-				setcall err undefinedvar_fn()
-				return err
-			EndIf
-
-			setcall importbittest importbit(pointer)
-			setcall value get_function_value(importbittest,pointer)
-
-			Data ptrobject%ptrobject
-			If ptrobject#=false
-				data addatend#1
-				data ptrvirtualimportsoffset%ptrvirtualimportsoffset
-				data ptrvirtuallocalsoffset%ptrvirtuallocalsoffset
-				If importbittest=false
-					set addatend ptrvirtuallocalsoffset
-				else
-					if doublepointer=zero
-						str doubleexp="Double pointer (^^) expected in this case: executable format and imported function."
-						return doubleexp
-					endif
-					dec doublepointer
-					set addatend ptrvirtualimportsoffset
-				endelse
-
-				sd section
-				sd section_offset
-				if stack=false
-					set section ptrdatasec
-					set section_offset zero
-				else
-					set section ptrcodesec
-					data stackoff=rampadd_value_off
-					set section_offset stackoff
-				endelse
-				setcall err unresolvedcallsfn(section,section_offset,addatend) #this is intentionaly without last arg
-				If err!=noerr
-					Return err
-				EndIf
-			Else
-				setcall relocindx get_function_values(importbittest,#value,pointer)
-			EndElse
-		EndElse
-		if doublepointer!=zero
-			str unexpdp="Unexpected double pointer."
-			return unexpdp
-		endif
-		setcall err xfile_add_string_if(content,size)
-		if err!=noerr;return err;endif
-		Call advancecursors(ptrcontent,ptrsize,size)
-	EndElse
-	if skipNumberValue=false
-		If typenumber!=constantsnr
-			#it can be data% but with R_X86_64_64 at prefs and that will force 8 bytes
-			if punitsize=(NULL)
-				#init -1, 0 is local function in the right
-				if importbittest=0
-					sd p_inplace_reloc_pref%p_inplace_reloc_pref
-					#at addend 0 at data/code must not pe resolved
-					if p_inplace_reloc_pref#!=(zero_reloc)
-						if stack=false
-							setcall err unresLc(0,ptrdatasec,0)
-						else
-							#it's only an imm to reg
-							sd stack_off;setcall stack_off reloc64_offset((rampadd_value_off))
-							setcall err unresLc(stack_off,ptrcodesec,0)
-						endelse
-						if err!=(noerror)
-							return err
-						endif
-					endif
-				endif
-				#addtocode(#test,1,code) cannot add to code for test will trick the next compiler, entry is started,will look like a bug
-				setcall err writevar(ptrvalue,valuewritesize,relocindx,stack,rightstackpointer,long_mask,relocbool)
-				If err!=noerr
-					Return err
-				EndIf
-			endif
-		Else
-			Data container#1
-			Data ptrcontainer^container
-			Call getcont(constantsstruct,ptrcontainer)
-			Add container offset_const
-			Set container# value
-		EndElse
-	endif
-	if stringtodata=true
-		sd escapes
-		SetCall err quotinmem(ptrcontent,ptrsize,ptrvalue,#escapes)
-		if punitsize=(NULL)
-			SetCall err addtosecstresc_xfile(ptrcontent,ptrsize,value,escapes,ptrdatasec)
-			return err
-		else
-			sub value escapes
-			add punitsize# value
-			call advancecursors(ptrcontent,ptrsize,ptrsize#)
-		endelse
-	endif
-	Return noerr
-EndFunction
-
-function undefinedvar_fn()
-	return "Undefined variable/function name."
-endfunction
-
-#value
-function get_function_value(sd impbit,sd pointer)
-	if impbit!=0
-		#imports
-		return pointer#
-	endif
-	#local
-	sd value
-	call get_fn_pos(pointer,#value)
-	return value
-endfunction
-#relocindex
-function get_function_values(sd impbit,sd p_value,sd pointer)
-	If impbit=0
-		#code
-		return (codeind)
-	endif
-	#import
-	set p_value# 0
-	return pointer#
-endfunction
-
-#err
-function get_reserve_size(sv ptrcontent,sd ptrsize,sd size,sd ptrvalue,sd is_stack,sd typenumber,sd long_mask,sd ptr_reserve)
-	sd err
-	SetCall err parseoperations(ptrcontent,ptrsize,size,ptrvalue,(TRUE))
-	If err!=(noerror)
-		Return err
-	EndIf
-	Char negreserve="Unexpected negative value at reserve declaration."
-	vStr ptrnegreserve^negreserve
-	If ptrvalue#<0
-		Return ptrnegreserve
-	EndIf
-
-	sd value;set value ptrvalue#
-	vdata p_parses%ptr_parses
-	if p_parses=(pass_write)
-	#ptr_reserve is undefined at another pass (and theoretically at constants)
-		if value<=(wmax)
-			call i_to_s(value,ptr_reserve)
-		else
-			call i_to_s(0,ptr_reserve)
-		endelse
-	endif
-
-	if is_stack=(FALSE)
-		If typenumber!=(charnumber)
-			SetCall err maxsectioncheck(value,ptrvalue)
-			If err=(noerror)
-				SetCall err maxsectioncheck(ptrvalue#,ptrvalue)
-				If err=(noerror)
-					if long_mask!=0
-						SetCall err maxsectioncheck(ptrvalue#,ptrvalue)
-					endif
-				endIf
-			EndIf
-		EndIf
-	else
-		SetCall err maxsectioncheck(value,ptrvalue)
-		If err=(noerror)
-			SetCall err maxsectioncheck(ptrvalue#,ptrvalue)
-			If err=(noerror)
-				#at format 64 can be a *2 at growramp
-				sd b;setcall b is_for_64()
-				if b=(TRUE)
-					SetCall err maxsectioncheck(ptrvalue#,ptrvalue)
-				endIf
-			endIf
-		endIf
-	endelse
-	Return err
-endfunction
-
-#err
-function set_reserve(sd value)
-	vData ptrdatasec%%ptr_datasec
-	sd p_nul_res_pref%p_nul_res_pref
-	if p_nul_res_pref#!=(FALSE)
-		sd reg;call getcontReg(ptrdatasec,#reg)
-	endif
-	sd err
-	SetCall err addtosec(0,value,ptrdatasec)
-	If err=(noerror)
-		if p_nul_res_pref#!=(FALSE)
-			sd cont;call getcont(ptrdatasec,#cont)
-			add cont reg
-			if p_nul_res_pref#=(TRUE)
-				call memset(cont,0,value)
-			else
-				call memset(cont,~0,value)
-			endelse
-		endif
-	EndIf
-	Return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/debug.oc
@@ -0,0 +1,74 @@
+
+#er
+function debug_lines(sd reg,sd line,sd content,sd last)
+	datax prevLine#1
+	const ptrprevLineD^prevLine
+	datax codeRegD#1
+	const ptrcodeRegD^codeRegD
+	#initialized values
+
+	sd aux;sd test
+	if line!=prevLine   #no a[semicolon]b column atm
+		#set line
+		set aux prevLine;set prevLine line
+		set test (TRUE)
+	elseif content=last  #but last line with no new line must be verified
+		set aux prevLine;set prevLine line
+		set test (TRUE)
+	else
+		set test (FALSE)
+	endelse
+	if test=(TRUE)
+		if reg!=codeRegD
+			sv ptrdebug%%ptr_debug
+			char a=log_line
+			sd err
+			setcall err addtosec(#a,(bsz),ptrdebug)
+			if err=(noerror)
+				charx buf#dw_char_0
+				sd len
+				inc aux
+				setcall len dwtomem(aux,#buf)
+				setcall err addtosec(#buf,len,ptrdebug)
+				if err=(noerror)
+					char b=asciispace
+					setcall err addtosec(#b,(bsz),ptrdebug)
+					if err=(noerror)
+						setcall len dwtomem(codeRegD,#buf)
+						setcall err addtosec(#buf,len,ptrdebug)
+						if err=(noerror)
+							sd t;sd sz;setcall t log_term(#sz)
+							setcall err addtosec(t,sz,ptrdebug)
+							#set codeReg
+							set codeRegD reg
+						endif
+					endif
+				endif
+			endif
+			return err
+		endif
+	endif
+	return (noerror)
+endfunction
+
+#err
+function addtodebug_withchar(ss content,sd char)
+	sd ptr_has_debug%ptr_has_debug
+	if ptr_has_debug#=(Yes)
+	#at exec formats will add for no one
+	#if blocking at exe , care to remove if dst==debugsec from addtosec
+		sv ptrdebug%%ptr_debug
+		sd err
+		setcall err addtosec(#char,(bsz),ptrdebug)
+		if err=(noerror)
+			sd ln;setcall ln strlen(content)
+			setcall err addtosec(content,ln,ptrdebug)
+			if err=(noerror)
+				sd t;sd sz;setcall t log_term(#sz)
+				setcall err addtosec(t,sz,ptrdebug)
+			endif
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
--- ocompiler-1.orig/src/files/functions/debug.s
+++ /dev/null
@@ -1,74 +0,0 @@
-
-#er
-function debug_lines(sd reg,sd line,sd content,sd last)
-	datax prevLine#1
-	const ptrprevLineD^prevLine
-	datax codeRegD#1
-	const ptrcodeRegD^codeRegD
-	#initialized values
-
-	sd aux;sd test
-	if line!=prevLine   #no a[semicolon]b column atm
-		#set line
-		set aux prevLine;set prevLine line
-		set test (TRUE)
-	elseif content=last  #but last line with no new line must be verified
-		set aux prevLine;set prevLine line
-		set test (TRUE)
-	else
-		set test (FALSE)
-	endelse
-	if test=(TRUE)
-		if reg!=codeRegD
-			sv ptrdebug%%ptr_debug
-			char a=log_line
-			sd err
-			setcall err addtosec(#a,(bsz),ptrdebug)
-			if err=(noerror)
-				charx buf#dw_char_0
-				sd len
-				inc aux
-				setcall len dwtomem(aux,#buf)
-				setcall err addtosec(#buf,len,ptrdebug)
-				if err=(noerror)
-					char b=asciispace
-					setcall err addtosec(#b,(bsz),ptrdebug)
-					if err=(noerror)
-						setcall len dwtomem(codeRegD,#buf)
-						setcall err addtosec(#buf,len,ptrdebug)
-						if err=(noerror)
-							sd t;sd sz;setcall t log_term(#sz)
-							setcall err addtosec(t,sz,ptrdebug)
-							#set codeReg
-							set codeRegD reg
-						endif
-					endif
-				endif
-			endif
-			return err
-		endif
-	endif
-	return (noerror)
-endfunction
-
-#err
-function addtodebug_withchar(ss content,sd char)
-	sd ptr_has_debug%ptr_has_debug
-	if ptr_has_debug#=(Yes)
-	#at exec formats will add for no one
-	#if blocking at exe , care to remove if dst==debugsec from addtosec
-		sv ptrdebug%%ptr_debug
-		sd err
-		setcall err addtosec(#char,(bsz),ptrdebug)
-		if err=(noerror)
-			sd ln;setcall ln strlen(content)
-			setcall err addtosec(content,ln,ptrdebug)
-			if err=(noerror)
-				sd t;sd sz;setcall t log_term(#sz)
-				setcall err addtosec(t,sz,ptrdebug)
-			endif
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/elf/elf.oc
@@ -0,0 +1,309 @@
+
+#err
+Function addtonamessized(data str,data sz,data regoff)
+	Data ptrnames%%ptr_names
+	Call getcontReg(ptrnames,regoff)
+	Data err#1
+	SetCall err addtosecstr(str,sz,ptrnames)
+	Return err
+EndFunction
+
+#err
+Function addtonames(data str,data regoff)
+	Data sz#1
+	SetCall sz strlen(str)
+	Data err#1
+	SetCall err addtonamessized(str,sz,regoff)
+	Return err
+EndFunction
+
+#err
+function elfaddsec_base(sd stringname,sd type,sd flags,sd fileoffset,sd bsize,sd link,sd info,sd align,sd entsize,sd addr,sd ptrbag)
+	Const elf_section=\
+	#Section header
+	#Section name (string tbl index)
+	Data sh_name#1
+	#Section type
+	Data sh_type#1
+	#Section flags
+	Data sh_flags#1
+	#Section virtual addr at execution
+	Data sh_addr#1
+	#Section file offset
+	Data sh_offset#1
+	#Section size in bytes
+	Data sh_size#1
+	#Link to another section
+	Data sh_link#1
+	#Additional section information
+	Data sh_info#1
+	#Section alignment
+	Data sh_addralign#1
+	#Entry size if section holds table
+	Data sh_entsize#1
+	Const elf_section_size=\-elf_section
+
+	Const elf64_section=\
+	Data sh64_name#1
+	Data sh64_type#1
+	Data sh64_flags#1;data *=0
+	Data sh64_addr#1;data *=0
+	Data sh64_offset#1;data *=0
+	Data sh64_size#1;data *=0
+	Data sh64_link#1
+	Data sh64_info#1
+	Data sh64_addralign#1;data *=0
+	Data sh64_entsize#1;data *=0
+	Const elf64_section_size=\-elf64_section
+
+	Const SHT_NULL=0
+	Const SHT_PROGBITS=1
+	Const SHT_NOBITS=8
+
+	const SHF_WRITE=1
+		#Occupies memory during execution,1 << 1
+	Const SHF_ALLOC=2*1
+		#Executable,1 << 2
+	Const SHF_EXECINSTR=2*2
+		#`sh_info' contains SHT index,1 << 6
+	#Const SHF_INFO_LINK=2*6
+
+	#A section of SHT_NOBITS may have a non-zero size, but it occupies no space in the file
+	#and ld is warning it, so why was here in the first place?
+	#Data SHT_PROGBITS=SHT_PROGBITS
+	#Data SHT_NOBITS=SHT_NOBITS
+	#Data zero=0
+	#If type==SHT_PROGBITS
+	#	If bsize==zero
+	#		Set type SHT_NOBITS
+	#	EndIf
+	#EndIf
+
+	Data err#1
+	#is false at inits, no worry about only at object
+	sd e64;setcall e64 is_for_64()
+	if e64=(TRUE)
+		Set sh64_name stringname;Set sh64_type type;Set sh64_flags flags;set sh64_addr addr;Set sh64_offset fileoffset
+		set sh64_size bsize;Set sh64_link link;Set sh64_info info;Set sh64_addralign align;Set sh64_entsize entsize
+		setcall err addtosec(#sh64_name,(elf64_section_size),ptrbag)
+	else
+		Set sh_name stringname;Set sh_type type;Set sh_flags flags;set sh_addr addr;Set sh_offset fileoffset
+		set sh_size bsize;Set sh_link link;Set sh_info info;Set sh_addralign align;Set sh_entsize entsize
+		SetCall err addtosec(#sh_name,(elf_section_size),ptrbag)
+	endelse
+	Return err
+endfunction
+#err
+function elfaddsecn()
+	Data ptrmiscbag%%ptr_miscbag
+	sd err
+	SetCall err elfaddsec_base((NULL),(SHT_NULL),0,(NULL),(NULL),0,0,0,0,(NULL),ptrmiscbag)
+	Return err
+endfunction
+#err
+Function elfaddsecs(sd stringoff,sd type,sd flags,sd fileoffset,sd bsize,sd align)
+	Data ptrmiscbag%%ptr_miscbag
+	sd err
+	SetCall err elfaddsec_base(stringoff,type,flags,fileoffset,bsize,0,0,align,0,(NULL),ptrmiscbag)
+	Return err
+EndFunction
+#err
+Function elfaddsec(data stringoff,data type,data flags,data fileoffset,data seccont,data link,data info,data align,data entsize)
+	sd bsize
+	Call getcontReg(seccont,#bsize)
+	Data ptrmiscbag%%ptr_miscbag
+	sd err
+	SetCall err elfaddsec_base(stringoff,type,flags,fileoffset,bsize,link,info,align,entsize,(NULL),ptrmiscbag)
+	Return err
+EndFunction
+#err
+Function elfaddstrsec(data stringofname,data type,data flags,data fileoffset,data seccont,data link,data info,data align,data entsize)
+	sd err
+	sd regnr#1
+	sd ptrregnr^regnr
+	SetCall err addtonames(stringofname,ptrregnr)
+	If err=(noerror)
+		setcall err elfaddsec(regnr,type,flags,fileoffset,seccont,link,info,align,entsize)
+	endif
+	return err
+EndFunction
+
+#err
+Function elfaddsym(data stringoff,data value,data size,char st_info,char bind,data index,data struct)
+#	sd st_info
+#	Set st_info type
+const elf_sym_st_info_tohibyte=16
+	Mult bind (elf_sym_st_info_tohibyte)
+	Or st_info bind
+
+	Data ptrndxsrc^index
+	Data wsz=wsz
+
+	sd err
+	sd x;setcall x is_for_64()
+	if x=(TRUE)
+		Data elf64_sym_st_name#1
+	#const elf64_sym_st_info_offset=dwsz
+		Char elf64_sym_st_info#1
+		Char *elf64_sym_st_other={0}
+		Char elf64_sym_st_shndx#2
+		Data elf64_sym_st_value#1;data *=0
+		Data elf64_sym_st_size#1;data *=0
+
+		Set elf64_sym_st_name stringoff
+		Set elf64_sym_st_value value
+		Set elf64_sym_st_size size
+		set elf64_sym_st_info st_info
+		Call memtomem(#elf64_sym_st_shndx,ptrndxsrc,wsz)
+
+		Const elf64_sym_start^elf64_sym_st_name
+		SetCall err addtosec(#elf64_sym_st_name,(\-elf64_sym_start),struct)
+	else
+		#Symbol table entry
+		#Symbol name (string tbl index)
+		Data elf32_sym_st_name#1
+		#Symbol value
+		Data elf32_sym_st_value#1
+		#Symbol size
+		Data elf32_sym_st_size#1
+		#Symbol type and binding
+		Const STB_LOCAL=0
+		Const STB_WEAK=2
+		Const STT_FUNC=2
+		Const STT_SECTION=3
+	#const elf32_sym_st_info_offset=3*dwsz
+		Char elf32_sym_st_info#1
+		#Symbol visibility
+		Char *elf32_sym_st_other={0}
+		#Section index
+		Char elf32_sym_st_shndx#2
+
+		Set elf32_sym_st_name stringoff
+		Set elf32_sym_st_value value
+		Set elf32_sym_st_size size
+		set elf32_sym_st_info st_info
+		Call memtomem(#elf32_sym_st_shndx,ptrndxsrc,wsz)
+
+		Const elf_sym_start^elf32_sym_st_name
+		SetCall err addtosec(#elf32_sym_st_name,(\-elf_sym_start),struct)
+	endelse
+
+	Return err
+EndFunction
+#err
+Function elfaddstrszsym(data stringstroff,data sz,data value,data size,char type,char bind,data index,data struct)
+	Data regnr#1
+	Data ptrregnr^regnr
+	Data err#1
+	Data noerr=noerror
+	SetCall err addtonamessized(stringstroff,sz,ptrregnr)
+	If err=noerr
+		SetCall err elfaddsym(regnr,value,size,type,bind,index,struct)
+	EndIf
+	Return err
+EndFunction
+#err
+Function elfaddstrsym(data stringstroff,data value,data size,char type,char bind,data index,data struct)
+	Data sz#1
+	SetCall sz strlen(stringstroff)
+	Data err#1
+	SetCall err elfaddstrszsym(stringstroff,sz,value,size,type,bind,index,struct)
+	Return err
+EndFunction
+
+Data STT_NOTYPE=STT_NOTYPE
+Data STT_FUNC=STT_FUNC
+Data STT_SECTION=STT_SECTION
+
+#const dataind=1
+Const codeind=2
+const dtnbind=3
+Const symind=3
+Data datastrtab#1
+Data codestrtab#1
+Data dtnbstrtab#1
+
+#Data objfnmask#1
+#Const ptrobjfnmask^objfnmask
+
+#inplace	direct: at writetake: sd^data
+#			   writevar:  data a^dataB    here is also notinplace data^import
+#			   fndecarg:  (data a)
+#no inplace:  rel: at writes resolves imports at non-object, this is not occuring at 64
+#		 rel_base: call import()
+#		 direct: the other writevar sd^data
+#			   the other writetake (import)
+#			   aftercall
+#err
+Function addrel_base(sd offset,sd symbolindex,sd addend,sd struct)
+	#Direct 32 bit
+	Const R_386_32=1
+	const R_X86_64_32=10
+	#PC relative 32 bit
+	#const R_386_PC32=2
+	#const R_X86_64_PC32=R_386_PC32
+	#const R_X86_64_PC64=24
+
+	sd err
+	sd x;setcall x is_for_64()
+	if x=(TRUE)
+		Data elf64_r_offset#1;data *=0
+		data elf64_r_info_type#1
+	const p_elf64_r_info_type^elf64_r_info_type
+	#const elf64_r_info_symbolindex_offset=2*dwsz
+		data elf64_r_info_symbolindex#1
+	#const elf64_r_info_symbolindex_size=dwsz
+		data elf64_r_addend#1;data *=0
+
+		#it is not enough
+		#Call memtomem(#elf64_r_offset,#offset,(qwsz))
+		set elf64_r_offset offset
+		set elf64_r_info_symbolindex symbolindex
+		set elf64_r_addend addend
+
+		SetCall err addtosec(#elf64_r_offset,(elf64_dyn_d_val_relent),struct)
+	else
+		#offset
+		Data elf_r_offset#1
+		#Relocation type and symbol index
+		Char *elf_r_info_type=R_386_32
+	#const elf_r_info_symbolindex_offset=dwsz+bsz
+		char elf_r_info_symbolindex#3
+	#const elf_r_info_symbolindex_size=3
+		data elf_r_addend#1
+
+		Set elf_r_offset offset
+		Call memtomem(#elf_r_info_symbolindex,#symbolindex,3)
+		set elf_r_addend addend
+
+		SetCall err addtosec(#elf_r_offset,(elf32_dyn_d_val_relent),struct)
+	endelse
+	Return err
+EndFunction
+
+#err
+Function addrel(sd offset,sd symbolindex,sd struct)
+	sd err
+	setcall err addrel_base(offset,symbolindex,0,struct)
+	return err
+endfunction
+
+#err
+Function adddirectrel_base(sd relsec,sd extraoff,sd index,sd addend)
+	Data err#1
+	Data off#1
+	Data ptroff^off
+	Data ptrdatasec%%ptr_datasec
+	Data ptrcodesec%%ptr_codesec
+	Data ptraddresses%%ptr_addresses
+	Data struct#1
+	If relsec=ptraddresses
+		Set struct ptrdatasec
+	Else
+		Set struct ptrcodesec
+	EndElse
+	Call getcontReg(struct,ptroff)
+	Add off extraoff
+	SetCall err addrel_base(off,index,addend,relsec)
+	Return err
+EndFunction
--- ocompiler-1.orig/src/files/functions/elf/elf.s
+++ /dev/null
@@ -1,309 +0,0 @@
-
-#err
-Function addtonamessized(data str,data sz,data regoff)
-	Data ptrnames%%ptr_names
-	Call getcontReg(ptrnames,regoff)
-	Data err#1
-	SetCall err addtosecstr(str,sz,ptrnames)
-	Return err
-EndFunction
-
-#err
-Function addtonames(data str,data regoff)
-	Data sz#1
-	SetCall sz strlen(str)
-	Data err#1
-	SetCall err addtonamessized(str,sz,regoff)
-	Return err
-EndFunction
-
-#err
-function elfaddsec_base(sd stringname,sd type,sd flags,sd fileoffset,sd bsize,sd link,sd info,sd align,sd entsize,sd addr,sd ptrbag)
-	Const elf_section=\
-	#Section header
-	#Section name (string tbl index)
-	Data sh_name#1
-	#Section type
-	Data sh_type#1
-	#Section flags
-	Data sh_flags#1
-	#Section virtual addr at execution
-	Data sh_addr#1
-	#Section file offset
-	Data sh_offset#1
-	#Section size in bytes
-	Data sh_size#1
-	#Link to another section
-	Data sh_link#1
-	#Additional section information
-	Data sh_info#1
-	#Section alignment
-	Data sh_addralign#1
-	#Entry size if section holds table
-	Data sh_entsize#1
-	Const elf_section_size=\-elf_section
-
-	Const elf64_section=\
-	Data sh64_name#1
-	Data sh64_type#1
-	Data sh64_flags#1;data *=0
-	Data sh64_addr#1;data *=0
-	Data sh64_offset#1;data *=0
-	Data sh64_size#1;data *=0
-	Data sh64_link#1
-	Data sh64_info#1
-	Data sh64_addralign#1;data *=0
-	Data sh64_entsize#1;data *=0
-	Const elf64_section_size=\-elf64_section
-
-	Const SHT_NULL=0
-	Const SHT_PROGBITS=1
-	Const SHT_NOBITS=8
-
-	const SHF_WRITE=1
-		#Occupies memory during execution,1 << 1
-	Const SHF_ALLOC=2*1
-		#Executable,1 << 2
-	Const SHF_EXECINSTR=2*2
-		#`sh_info' contains SHT index,1 << 6
-	#Const SHF_INFO_LINK=2*6
-
-	#A section of SHT_NOBITS may have a non-zero size, but it occupies no space in the file
-	#and ld is warning it, so why was here in the first place?
-	#Data SHT_PROGBITS=SHT_PROGBITS
-	#Data SHT_NOBITS=SHT_NOBITS
-	#Data zero=0
-	#If type==SHT_PROGBITS
-	#	If bsize==zero
-	#		Set type SHT_NOBITS
-	#	EndIf
-	#EndIf
-
-	Data err#1
-	#is false at inits, no worry about only at object
-	sd e64;setcall e64 is_for_64()
-	if e64=(TRUE)
-		Set sh64_name stringname;Set sh64_type type;Set sh64_flags flags;set sh64_addr addr;Set sh64_offset fileoffset
-		set sh64_size bsize;Set sh64_link link;Set sh64_info info;Set sh64_addralign align;Set sh64_entsize entsize
-		setcall err addtosec(#sh64_name,(elf64_section_size),ptrbag)
-	else
-		Set sh_name stringname;Set sh_type type;Set sh_flags flags;set sh_addr addr;Set sh_offset fileoffset
-		set sh_size bsize;Set sh_link link;Set sh_info info;Set sh_addralign align;Set sh_entsize entsize
-		SetCall err addtosec(#sh_name,(elf_section_size),ptrbag)
-	endelse
-	Return err
-endfunction
-#err
-function elfaddsecn()
-	Data ptrmiscbag%%ptr_miscbag
-	sd err
-	SetCall err elfaddsec_base((NULL),(SHT_NULL),0,(NULL),(NULL),0,0,0,0,(NULL),ptrmiscbag)
-	Return err
-endfunction
-#err
-Function elfaddsecs(sd stringoff,sd type,sd flags,sd fileoffset,sd bsize,sd align)
-	Data ptrmiscbag%%ptr_miscbag
-	sd err
-	SetCall err elfaddsec_base(stringoff,type,flags,fileoffset,bsize,0,0,align,0,(NULL),ptrmiscbag)
-	Return err
-EndFunction
-#err
-Function elfaddsec(data stringoff,data type,data flags,data fileoffset,data seccont,data link,data info,data align,data entsize)
-	sd bsize
-	Call getcontReg(seccont,#bsize)
-	Data ptrmiscbag%%ptr_miscbag
-	sd err
-	SetCall err elfaddsec_base(stringoff,type,flags,fileoffset,bsize,link,info,align,entsize,(NULL),ptrmiscbag)
-	Return err
-EndFunction
-#err
-Function elfaddstrsec(data stringofname,data type,data flags,data fileoffset,data seccont,data link,data info,data align,data entsize)
-	sd err
-	sd regnr#1
-	sd ptrregnr^regnr
-	SetCall err addtonames(stringofname,ptrregnr)
-	If err=(noerror)
-		setcall err elfaddsec(regnr,type,flags,fileoffset,seccont,link,info,align,entsize)
-	endif
-	return err
-EndFunction
-
-#err
-Function elfaddsym(data stringoff,data value,data size,char st_info,char bind,data index,data struct)
-#	sd st_info
-#	Set st_info type
-const elf_sym_st_info_tohibyte=16
-	Mult bind (elf_sym_st_info_tohibyte)
-	Or st_info bind
-
-	Data ptrndxsrc^index
-	Data wsz=wsz
-
-	sd err
-	sd x;setcall x is_for_64()
-	if x=(TRUE)
-		Data elf64_sym_st_name#1
-	#const elf64_sym_st_info_offset=dwsz
-		Char elf64_sym_st_info#1
-		Char *elf64_sym_st_other={0}
-		Char elf64_sym_st_shndx#2
-		Data elf64_sym_st_value#1;data *=0
-		Data elf64_sym_st_size#1;data *=0
-
-		Set elf64_sym_st_name stringoff
-		Set elf64_sym_st_value value
-		Set elf64_sym_st_size size
-		set elf64_sym_st_info st_info
-		Call memtomem(#elf64_sym_st_shndx,ptrndxsrc,wsz)
-
-		Const elf64_sym_start^elf64_sym_st_name
-		SetCall err addtosec(#elf64_sym_st_name,(\-elf64_sym_start),struct)
-	else
-		#Symbol table entry
-		#Symbol name (string tbl index)
-		Data elf32_sym_st_name#1
-		#Symbol value
-		Data elf32_sym_st_value#1
-		#Symbol size
-		Data elf32_sym_st_size#1
-		#Symbol type and binding
-		Const STB_LOCAL=0
-		Const STB_WEAK=2
-		Const STT_FUNC=2
-		Const STT_SECTION=3
-	#const elf32_sym_st_info_offset=3*dwsz
-		Char elf32_sym_st_info#1
-		#Symbol visibility
-		Char *elf32_sym_st_other={0}
-		#Section index
-		Char elf32_sym_st_shndx#2
-
-		Set elf32_sym_st_name stringoff
-		Set elf32_sym_st_value value
-		Set elf32_sym_st_size size
-		set elf32_sym_st_info st_info
-		Call memtomem(#elf32_sym_st_shndx,ptrndxsrc,wsz)
-
-		Const elf_sym_start^elf32_sym_st_name
-		SetCall err addtosec(#elf32_sym_st_name,(\-elf_sym_start),struct)
-	endelse
-
-	Return err
-EndFunction
-#err
-Function elfaddstrszsym(data stringstroff,data sz,data value,data size,char type,char bind,data index,data struct)
-	Data regnr#1
-	Data ptrregnr^regnr
-	Data err#1
-	Data noerr=noerror
-	SetCall err addtonamessized(stringstroff,sz,ptrregnr)
-	If err=noerr
-		SetCall err elfaddsym(regnr,value,size,type,bind,index,struct)
-	EndIf
-	Return err
-EndFunction
-#err
-Function elfaddstrsym(data stringstroff,data value,data size,char type,char bind,data index,data struct)
-	Data sz#1
-	SetCall sz strlen(stringstroff)
-	Data err#1
-	SetCall err elfaddstrszsym(stringstroff,sz,value,size,type,bind,index,struct)
-	Return err
-EndFunction
-
-Data STT_NOTYPE=STT_NOTYPE
-Data STT_FUNC=STT_FUNC
-Data STT_SECTION=STT_SECTION
-
-#const dataind=1
-Const codeind=2
-const dtnbind=3
-Const symind=3
-Data datastrtab#1
-Data codestrtab#1
-Data dtnbstrtab#1
-
-#Data objfnmask#1
-#Const ptrobjfnmask^objfnmask
-
-#inplace	direct: at writetake: sd^data
-#			   writevar:  data a^dataB    here is also notinplace data^import
-#			   fndecarg:  (data a)
-#no inplace:  rel: at writes resolves imports at non-object, this is not occuring at 64
-#		 rel_base: call import()
-#		 direct: the other writevar sd^data
-#			   the other writetake (import)
-#			   aftercall
-#err
-Function addrel_base(sd offset,sd symbolindex,sd addend,sd struct)
-	#Direct 32 bit
-	Const R_386_32=1
-	const R_X86_64_32=10
-	#PC relative 32 bit
-	#const R_386_PC32=2
-	#const R_X86_64_PC32=R_386_PC32
-	#const R_X86_64_PC64=24
-
-	sd err
-	sd x;setcall x is_for_64()
-	if x=(TRUE)
-		Data elf64_r_offset#1;data *=0
-		data elf64_r_info_type#1
-	const p_elf64_r_info_type^elf64_r_info_type
-	#const elf64_r_info_symbolindex_offset=2*dwsz
-		data elf64_r_info_symbolindex#1
-	#const elf64_r_info_symbolindex_size=dwsz
-		data elf64_r_addend#1;data *=0
-
-		#it is not enough
-		#Call memtomem(#elf64_r_offset,#offset,(qwsz))
-		set elf64_r_offset offset
-		set elf64_r_info_symbolindex symbolindex
-		set elf64_r_addend addend
-
-		SetCall err addtosec(#elf64_r_offset,(elf64_dyn_d_val_relent),struct)
-	else
-		#offset
-		Data elf_r_offset#1
-		#Relocation type and symbol index
-		Char *elf_r_info_type=R_386_32
-	#const elf_r_info_symbolindex_offset=dwsz+bsz
-		char elf_r_info_symbolindex#3
-	#const elf_r_info_symbolindex_size=3
-		data elf_r_addend#1
-
-		Set elf_r_offset offset
-		Call memtomem(#elf_r_info_symbolindex,#symbolindex,3)
-		set elf_r_addend addend
-
-		SetCall err addtosec(#elf_r_offset,(elf32_dyn_d_val_relent),struct)
-	endelse
-	Return err
-EndFunction
-
-#err
-Function addrel(sd offset,sd symbolindex,sd struct)
-	sd err
-	setcall err addrel_base(offset,symbolindex,0,struct)
-	return err
-endfunction
-
-#err
-Function adddirectrel_base(sd relsec,sd extraoff,sd index,sd addend)
-	Data err#1
-	Data off#1
-	Data ptroff^off
-	Data ptrdatasec%%ptr_datasec
-	Data ptrcodesec%%ptr_codesec
-	Data ptraddresses%%ptr_addresses
-	Data struct#1
-	If relsec=ptraddresses
-		Set struct ptrdatasec
-	Else
-		Set struct ptrcodesec
-	EndElse
-	Call getcontReg(struct,ptroff)
-	Add off extraoff
-	SetCall err addrel_base(off,index,addend,relsec)
-	Return err
-EndFunction
--- /dev/null
+++ ocompiler-1/src/files/functions/enumbags.oc
@@ -0,0 +1,87 @@
+
+
+#err
+Function enumbags(data is_declare)
+	sd pointer%%containersbegin
+	sd cursor%containerssize
+	set cursor cursor#
+	add cursor pointer
+	While pointer!=cursor
+		If is_declare=(TRUE)
+			sd err;setcall err enumbags_alloc(pointer)
+			If err!=(noerror)
+				Return err
+			EndIf
+		Else
+			call enumbags_free(pointer)
+		EndElse
+		add pointer (sizeofcontainer)
+	EndWhile
+	Return (noerror)
+EndFunction
+
+#err
+function enumbags_alloc(sd container)
+	sd max;call getcontMax(container,#max)
+	sd pcont;call getptrcont(container,#pcont)
+	sd err;setcall err mem_alloc(max,pcont)
+	return err
+endfunction
+function enumbags_free(sd container)
+	sd cont;call getcont(container,#cont)
+	If cont!=(NULL)
+		Call free(cont)
+	EndIf
+endfunction
+
+#no return
+Function freeclose()
+	call platform_free()
+
+	Data zero=0
+	Call enumbags(zero)
+
+	#here if allocerrormsg was a submessage(included in sprintf)
+	#here at some main msgerrexits
+	call clearmessage()
+
+	sd p_safecurrentdirtopath%p_safecurrentdirtopath
+	if p_safecurrentdirtopath#!=(NULL)
+		call free(p_safecurrentdirtopath#)
+
+		Data value#1
+		Data negative=openno
+
+		data ptrlogfile%ptrlogfile
+		Set value ptrlogfile#
+		If value!=negative
+			Call close(value)
+		EndIf
+		if main.xfile!=negative
+			call close(main.xfile)
+		endif
+
+		call align_free()
+		call scopes_free()
+
+		Data ptrfileout%ptrfileout
+		Set value ptrfileout#
+		If value!=negative
+			Call close(value)
+		EndIf
+	endif
+EndFunction
+
+Function msgerrexit(data msg)
+	Call Message(msg)
+	call errexit()
+EndFunction
+
+Function errexit()
+	Call freeclose()
+	call errorexit()
+EndFunction
+
+function errorexit()
+	Call exit(-1)
+endfunction
--- ocompiler-1.orig/src/files/functions/enumbags.s
+++ /dev/null
@@ -1,87 +0,0 @@
-
-
-#err
-Function enumbags(data is_declare)
-	sd pointer%%containersbegin
-	sd cursor%containerssize
-	set cursor cursor#
-	add cursor pointer
-	While pointer!=cursor
-		If is_declare=(TRUE)
-			sd err;setcall err enumbags_alloc(pointer)
-			If err!=(noerror)
-				Return err
-			EndIf
-		Else
-			call enumbags_free(pointer)
-		EndElse
-		add pointer (sizeofcontainer)
-	EndWhile
-	Return (noerror)
-EndFunction
-
-#err
-function enumbags_alloc(sd container)
-	sd max;call getcontMax(container,#max)
-	sd pcont;call getptrcont(container,#pcont)
-	sd err;setcall err mem_alloc(max,pcont)
-	return err
-endfunction
-function enumbags_free(sd container)
-	sd cont;call getcont(container,#cont)
-	If cont!=(NULL)
-		Call free(cont)
-	EndIf
-endfunction
-
-#no return
-Function freeclose()
-	call platform_free()
-
-	Data zero=0
-	Call enumbags(zero)
-
-	#here if allocerrormsg was a submessage(included in sprintf)
-	#here at some main msgerrexits
-	call clearmessage()
-
-	sd p_safecurrentdirtopath%p_safecurrentdirtopath
-	if p_safecurrentdirtopath#!=(NULL)
-		call free(p_safecurrentdirtopath#)
-
-		Data value#1
-		Data negative=openno
-
-		data ptrlogfile%ptrlogfile
-		Set value ptrlogfile#
-		If value!=negative
-			Call close(value)
-		EndIf
-		if main.xfile!=negative
-			call close(main.xfile)
-		endif
-
-		call align_free()
-		call scopes_free()
-
-		Data ptrfileout%ptrfileout
-		Set value ptrfileout#
-		If value!=negative
-			Call close(value)
-		EndIf
-	endif
-EndFunction
-
-Function msgerrexit(data msg)
-	Call Message(msg)
-	call errexit()
-EndFunction
-
-Function errexit()
-	Call freeclose()
-	call errorexit()
-EndFunction
-
-function errorexit()
-	Call exit(-1)
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/global/end.oc
@@ -0,0 +1,56 @@
+
+#err
+function endfunction(sd parses)
+	if parses=(pass_init)
+		if main.innerfunction=(FALSE)
+			Char unexef="Unexpected ENDFUNCTION command."
+			Str unexeferr^unexef
+			return unexeferr
+		else
+			Set main.innerfunction (FALSE)
+			call vars_log_reset() #to let next variables be ".var"
+		endelse
+	elseif parses=(pass_write)
+		sd err
+		setcall err xfile_add_end_if()
+		if err=(noerror)
+			setCall err checkcondloopclose()
+			If err=(noerror)
+				if main.endfunction_has_write=(TRUE)
+					data ptrreturn#1
+					data sizereturn#1
+					data ptrptrreturn^ptrreturn
+					setcall sizereturn getreturn(ptrptrreturn)
+					SetCall err addtoCode_set_programentrypoint(ptrreturn,sizereturn)
+					If err!=(noerror);return err;endif
+				else
+					call set_programentrypoint()
+				endelse
+				setcall err scopes_store(main.functionTagIndex)
+				If err=(noerror)
+					sd i
+					Set i 0
+					While i!=(numberofvars)
+					#here is clearing indexes to not call variables from this scope in the parent scope
+						Data containertoclear#1
+						SetCall containertoclear getstructcont(i)
+						Data indexptr#1
+						Data ptrindexptr^indexptr
+						Call getptrcontReg(containertoclear,ptrindexptr)
+						Set indexptr# 0
+						Inc i
+					EndWhile
+				else
+					return err
+				endelse
+			else
+				return err
+			endelse
+			Set main.innerfunction (FALSE)
+		else
+			return err
+		endelse
+	endelseif
+	inc main.functionTagIndex
+	return (noerror)
+endfunction
--- ocompiler-1.orig/src/files/functions/global/end.s
+++ /dev/null
@@ -1,55 +0,0 @@
-
-#err
-function endfunction(sd parses)
-	if parses=(pass_init)
-		if main.innerfunction=(FALSE)
-			Char unexef="Unexpected ENDFUNCTION command."
-			Str unexeferr^unexef
-			return unexeferr
-		else
-			Set main.innerfunction (FALSE)
-			call vars_log_reset() #to let next variables be ".var"
-		endelse
-	elseif parses=(pass_write)
-		sd err
-		setcall err xfile_add_end_if()
-		if err=(noerror)
-			setCall err checkcondloopclose()
-			If err=(noerror)
-				data ptrreturn#1
-				data sizereturn#1
-				data ptrptrreturn^ptrreturn
-				setcall sizereturn getreturn(ptrptrreturn)
-				SetCall err addtoCode_set_programentrypoint(ptrreturn,sizereturn)
-				If err=(noerror)
-					setcall err scopes_store(main.functionTagIndex)
-					If err=(noerror)
-						sd i
-						Set i 0
-						While i!=(numberofvars)
-						#here is clearing indexes to not call variables from this scope in the parent scope
-							Data containertoclear#1
-							SetCall containertoclear getstructcont(i)
-							Data indexptr#1
-							Data ptrindexptr^indexptr
-							Call getptrcontReg(containertoclear,ptrindexptr)
-							Set indexptr# 0
-							Inc i
-						EndWhile
-					else
-						return err
-					endelse
-				else
-					return err
-				endelse
-			else
-				return err
-			endelse
-			Set main.innerfunction (FALSE)
-		else
-			return err
-		endelse
-	endelseif
-	inc main.functionTagIndex
-	return (noerror)
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/global/funcs.oc
@@ -0,0 +1,102 @@
+
+
+
+function localResolve(sd unrLc,sd unrLcReg)
+	data funcs#1
+	data ptr_funcs^funcs
+	data fns%%ptr_functions
+
+	sd struct
+	sd offset
+
+	while unrLcReg!=0
+		set struct unrLc#
+		sd cont
+		sd ptr_cont^cont
+		call getcont(struct,ptr_cont)
+
+		add unrLc 4
+
+		set offset unrLc#
+
+		add cont offset
+
+		call getcont(fns,ptr_funcs)
+
+		add funcs cont#
+		sd value
+		set value funcs#
+
+		add unrLc 4
+
+		if unrLc#=1
+			add offset 4
+			sub offset value
+			setcall offset neg(offset)
+		else
+			set offset value
+		endelse
+
+		set cont# offset
+
+		add unrLc 4
+		sub unrLcReg 12
+	endwhile
+endfunction
+
+function get_fn_pos(sd varfnpointer,sd ptr_out)
+	Data ptrfunctions%%ptr_functions
+	#store the functions reg
+	sd fns_cont
+	sd ptr_fns_cont^fns_cont
+	call getcont(ptrfunctions,ptr_fns_cont)
+	sub varfnpointer fns_cont
+	set ptr_out# varfnpointer
+endfunction
+
+#e
+function unresLc(sd addition,sd structure,sd direct)
+	data struct#1
+	data offset#1
+	data isdirect#1
+
+	sd ptradd^struct
+	sd ptroff^offset
+
+	Call getcontReg(structure,ptroff)
+
+	add offset addition
+
+	set struct structure
+	set isdirect direct
+
+	data unresLocal%%ptr_unresLocal
+	sd err
+	SetCall err addtosec(ptradd,12,unresLocal)
+	return err
+endfunction
+
+#e
+function unresolvedLocal(sd addition,sd structure,sd currentfnpointer,sd ptr_out)
+	sd err
+	setcall err unresLc(addition,structure,1)
+	If err!=(noerror)
+		Return err
+	EndIf
+
+	call get_fn_pos(currentfnpointer,ptr_out)
+	return (noerror)
+endfunction
+
+#e
+function unresReloc(sd section)
+	sd for_64
+	sd err
+	setcall for_64 is_for_64()
+	if for_64=(TRUE)
+		setcall err unresLc((-qwsz),section,0)
+	else
+		setcall err unresLc((-dwsz),section,0)
+	endelse
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/global/funcs.s
+++ /dev/null
@@ -1,102 +0,0 @@
-
-
-
-function localResolve(sd unrLc,sd unrLcReg)
-	data funcs#1
-	data ptr_funcs^funcs
-	data fns%%ptr_functions
-
-	sd struct
-	sd offset
-
-	while unrLcReg!=0
-		set struct unrLc#
-		sd cont
-		sd ptr_cont^cont
-		call getcont(struct,ptr_cont)
-
-		add unrLc 4
-
-		set offset unrLc#
-
-		add cont offset
-
-		call getcont(fns,ptr_funcs)
-
-		add funcs cont#
-		sd value
-		set value funcs#
-
-		add unrLc 4
-
-		if unrLc#=1
-			add offset 4
-			sub offset value
-			setcall offset neg(offset)
-		else
-			set offset value
-		endelse
-
-		set cont# offset
-
-		add unrLc 4
-		sub unrLcReg 12
-	endwhile
-endfunction
-
-function get_fn_pos(sd varfnpointer,sd ptr_out)
-	Data ptrfunctions%%ptr_functions
-	#store the functions reg
-	sd fns_cont
-	sd ptr_fns_cont^fns_cont
-	call getcont(ptrfunctions,ptr_fns_cont)
-	sub varfnpointer fns_cont
-	set ptr_out# varfnpointer
-endfunction
-
-#e
-function unresLc(sd addition,sd structure,sd direct)
-	data struct#1
-	data offset#1
-	data isdirect#1
-
-	sd ptradd^struct
-	sd ptroff^offset
-
-	Call getcontReg(structure,ptroff)
-
-	add offset addition
-
-	set struct structure
-	set isdirect direct
-
-	data unresLocal%%ptr_unresLocal
-	sd err
-	SetCall err addtosec(ptradd,12,unresLocal)
-	return err
-endfunction
-
-#e
-function unresolvedLocal(sd addition,sd structure,sd currentfnpointer,sd ptr_out)
-	sd err
-	setcall err unresLc(addition,structure,1)
-	If err!=(noerror)
-		Return err
-	EndIf
-
-	call get_fn_pos(currentfnpointer,ptr_out)
-	return (noerror)
-endfunction
-
-#e
-function unresReloc(sd section)
-	sd for_64
-	sd err
-	setcall for_64 is_for_64()
-	if for_64=(TRUE)
-		setcall err unresLc((-qwsz),section,0)
-	else
-		setcall err unresLc((-dwsz),section,0)
-	endelse
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/import.oc
@@ -0,0 +1,13 @@
+
+function import_leading_underscore(sv pcontent,sd pcomsize,sd ptrimpquotsz)
+	sd p_underscore_pref%p_underscore_pref
+	if p_underscore_pref#=(TRUE)
+		ss content
+		set content pcontent#
+		#here it is inside quotes
+		if content#=(asciiunderscore)
+			call stepcursors(pcontent,pcomsize)
+			dec ptrimpquotsz#
+		endif
+	endif
+endfunction
--- ocompiler-1.orig/src/files/functions/import.s
+++ /dev/null
@@ -1,13 +0,0 @@
-
-function import_leading_underscore(sv pcontent,sd pcomsize,sd ptrimpquotsz)
-	sd p_underscore_pref%p_underscore_pref
-	if p_underscore_pref#=(TRUE)
-		ss content
-		set content pcontent#
-		#here it is inside quotes
-		if content#=(asciiunderscore)
-			call stepcursors(pcontent,pcomsize)
-			dec ptrimpquotsz#
-		endif
-	endif
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/include.oc
@@ -0,0 +1,183 @@
+
+Data includebool#1
+
+Str contentoffile#1
+Data sizeoffile#1
+Data offsetoffile#1
+Data lineoffile#1
+Data includemask#1
+
+Const contentoffileoff=2*dwsz
+Const lineoffile_offset=contentoffileoff+dwsz
+
+Const includestructure^contentoffile
+
+function offsetoffile_value()
+	sd offsetoffl
+	data null=NULL
+	data true=TRUE
+	set offsetoffl null
+	data ptrincludedir%ptrincludedir
+	data flag_max_path=flag_MAX_PATH
+	if ptrincludedir#=true
+		add offsetoffl flag_max_path
+	endif
+	return offsetoffl
+endfunction
+
+#err
+Function include(ss path,sd both,sd subtype)
+	Data zero=0
+	Data one=1
+
+	Str contentoffl#1
+	Data sizeoffl#1
+	Data offsetoffl#1
+	Data *lineoffl=0
+	data mask#1
+	Char nameoffl#shortstrsize
+
+	Data err#1
+	Data noerr=noerror
+
+	Const includeset^contentoffl
+	Data includeset%includeset
+
+	Data psizeoffl^sizeoffl
+	Data pcontentoffl%includeset
+
+	setcall offsetoffl offsetoffile_value()
+
+	if subtype=(cEINCLUDE)
+		vData warningsboolptr%ptrwarningsbool
+		set mask warningsboolptr#
+		if mask=(TRUE)
+			set warningsboolptr# (FALSE)
+		endif
+	else
+		set mask (FALSE)
+	endelse
+
+	SetCall err file_get_content_ofs(path,psizeoffl,pcontentoffl,offsetoffl)
+	If err!=noerr
+		Return err
+	EndIf
+
+	Str folders#1
+	SetCall folders endoffolders(path)
+
+	data ptrincludedir%ptrincludedir
+	if ptrincludedir#=(TRUE)
+		data charpointer#1
+		setcall charpointer getcwd(pcontentoffl#,(flag_MAX_PATH))
+		if charpointer=(NULL)
+			str getcwderr="Getcdw error."
+			return getcwderr
+		endif
+
+		setcall err addtolog_withchar_parses(pcontentoffl#,(log_pathfolder),both)
+		If err!=noerr;Return err;EndIf
+
+		char storechar#1
+		set storechar folders#
+		set folders# 0
+
+		data int#1
+		data chdirok=chdirok
+		setcall int changedir(path)
+		#0 success
+		if int!=chdirok
+			str chdirerr="Chdir error."
+			return chdirerr
+		endif
+
+		set folders# storechar
+	endif
+
+	setcall err addtolog_withchar_parses(path,(log_pathname),both)
+	If err!=noerr;Return err;EndIf
+
+	Data strsz#1
+	SetCall strsz strlen(path)
+	Data fnamesize#1
+	Set fnamesize path
+	Add fnamesize strsz
+	Sub fnamesize folders
+
+	Data allowedforsize=shortstrsize
+	Data allowedsize#1
+
+	Set allowedsize allowedforsize
+	Sub allowedsize one
+
+	Data moresize#1
+	Set moresize zero
+
+	If fnamesize>allowedsize
+		Set fnamesize allowedsize
+		Sub fnamesize one
+		Set moresize one
+	EndIf
+
+	Str dest#1
+	Str initialdest^nameoffl
+	Set dest initialdest
+	Call memtomem(dest,folders,fnamesize)
+
+	Add dest fnamesize
+	If moresize=one
+		Char morestr="~"
+		Set dest# morestr
+		Add dest one
+	EndIf
+
+	Set dest# 0
+
+
+	Data pincludes%%ptr_includes
+	Data isetsize=includesetSz
+
+	SetCall err addtosec(includeset,isetsize,pincludes)
+	If err!=noerr
+		Return err
+	EndIf
+
+	Data pointers%includestructure
+#	Data sizeadd#1
+#	Set sizeadd isetsize
+#	Sub sizeadd allowedforsize
+	Call memtomem(pointers,includeset,(includesetSzData))
+
+#	Data includespoint#1
+#	Data ptrincludespoint^includespoint
+#	Call getcontReg(pincludes,ptrincludespoint)
+#	Sub includespoint allowedforsize
+
+#	Data envinccursor#1
+#	Set envinccursor pointers
+#	Add envinccursor sizeadd
+#	Set envinccursor# includespoint
+
+	Return noerr
+EndFunction
+
+#er
+function include_sec_skip(sv pcontent,sd pcomsize)
+	call spaces(pcontent,pcomsize)
+	ss content;set content pcontent#
+	if content#=(asciidoublequote)
+		sd sz;sd escapes
+		sd err
+		SetCall err quotinmem(pcontent,pcomsize,#sz,#escapes)
+		if err=(noerror)
+			setcall err xfile_add_char_ifif((Xfile_include_alternative_yes))
+			if err=(noerror)
+				Value ptrtemp%%ptr_tempdata
+				setcall err addtosecstresc_xfile(pcontent,pcomsize,sz,escapes,ptrtemp) #misc has first include file, and is ok with casts
+			endif
+		endif
+	else
+		setcall err xfile_add_char_ifif((Xfile_include_alternative_no))
+	endelse
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/include.s
+++ /dev/null
@@ -1,183 +0,0 @@
-
-Data includebool#1
-
-Str contentoffile#1
-Data sizeoffile#1
-Data offsetoffile#1
-Data lineoffile#1
-Data includemask#1
-
-Const contentoffileoff=2*dwsz
-Const lineoffile_offset=contentoffileoff+dwsz
-
-Const includestructure^contentoffile
-
-function offsetoffile_value()
-	sd offsetoffl
-	data null=NULL
-	data true=TRUE
-	set offsetoffl null
-	data ptrincludedir%ptrincludedir
-	data flag_max_path=flag_MAX_PATH
-	if ptrincludedir#=true
-		add offsetoffl flag_max_path
-	endif
-	return offsetoffl
-endfunction
-
-#err
-Function include(ss path,sd both,sd subtype)
-	Data zero=0
-	Data one=1
-
-	Str contentoffl#1
-	Data sizeoffl#1
-	Data offsetoffl#1
-	Data *lineoffl=0
-	data mask#1
-	Char nameoffl#shortstrsize
-
-	Data err#1
-	Data noerr=noerror
-
-	Const includeset^contentoffl
-	Data includeset%includeset
-
-	Data psizeoffl^sizeoffl
-	Data pcontentoffl%includeset
-
-	setcall offsetoffl offsetoffile_value()
-
-	if subtype=(cEINCLUDE)
-		vData warningsboolptr%ptrwarningsbool
-		set mask warningsboolptr#
-		if mask=(TRUE)
-			set warningsboolptr# (FALSE)
-		endif
-	else
-		set mask (FALSE)
-	endelse
-
-	SetCall err file_get_content_ofs(path,psizeoffl,pcontentoffl,offsetoffl)
-	If err!=noerr
-		Return err
-	EndIf
-
-	Str folders#1
-	SetCall folders endoffolders(path)
-
-	data ptrincludedir%ptrincludedir
-	if ptrincludedir#=(TRUE)
-		data charpointer#1
-		setcall charpointer getcwd(pcontentoffl#,(flag_MAX_PATH))
-		if charpointer=(NULL)
-			str getcwderr="Getcdw error."
-			return getcwderr
-		endif
-
-		setcall err addtolog_withchar_parses(pcontentoffl#,(log_pathfolder),both)
-		If err!=noerr;Return err;EndIf
-
-		char storechar#1
-		set storechar folders#
-		set folders# 0
-
-		data int#1
-		data chdirok=chdirok
-		setcall int changedir(path)
-		#0 success
-		if int!=chdirok
-			str chdirerr="Chdir error."
-			return chdirerr
-		endif
-
-		set folders# storechar
-	endif
-
-	setcall err addtolog_withchar_parses(path,(log_pathname),both)
-	If err!=noerr;Return err;EndIf
-
-	Data strsz#1
-	SetCall strsz strlen(path)
-	Data fnamesize#1
-	Set fnamesize path
-	Add fnamesize strsz
-	Sub fnamesize folders
-
-	Data allowedforsize=shortstrsize
-	Data allowedsize#1
-
-	Set allowedsize allowedforsize
-	Sub allowedsize one
-
-	Data moresize#1
-	Set moresize zero
-
-	If fnamesize>allowedsize
-		Set fnamesize allowedsize
-		Sub fnamesize one
-		Set moresize one
-	EndIf
-
-	Str dest#1
-	Str initialdest^nameoffl
-	Set dest initialdest
-	Call memtomem(dest,folders,fnamesize)
-
-	Add dest fnamesize
-	If moresize=one
-		Char morestr="~"
-		Set dest# morestr
-		Add dest one
-	EndIf
-
-	Set dest# 0
-
-
-	Data pincludes%%ptr_includes
-	Data isetsize=includesetSz
-
-	SetCall err addtosec(includeset,isetsize,pincludes)
-	If err!=noerr
-		Return err
-	EndIf
-
-	Data pointers%includestructure
-#	Data sizeadd#1
-#	Set sizeadd isetsize
-#	Sub sizeadd allowedforsize
-	Call memtomem(pointers,includeset,(includesetSzData))
-
-#	Data includespoint#1
-#	Data ptrincludespoint^includespoint
-#	Call getcontReg(pincludes,ptrincludespoint)
-#	Sub includespoint allowedforsize
-
-#	Data envinccursor#1
-#	Set envinccursor pointers
-#	Add envinccursor sizeadd
-#	Set envinccursor# includespoint
-
-	Return noerr
-EndFunction
-
-#er
-function include_sec_skip(sv pcontent,sd pcomsize)
-	call spaces(pcontent,pcomsize)
-	ss content;set content pcontent#
-	if content#=(asciidoublequote)
-		sd sz;sd escapes
-		sd err
-		SetCall err quotinmem(pcontent,pcomsize,#sz,#escapes)
-		if err=(noerror)
-			setcall err xfile_add_char_ifif((Xfile_include_alternative_yes))
-			if err=(noerror)
-				Value ptrtemp%%ptr_tempdata
-				setcall err addtosecstresc_xfile(pcontent,pcomsize,sz,escapes,ptrtemp) #misc has first include file, and is ok with casts
-			endif
-		endif
-	else
-		setcall err xfile_add_char_ifif((Xfile_include_alternative_no))
-	endelse
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/index.oc
@@ -0,0 +1,22 @@
+
+#pointer
+function command_start(sv p_is_comment,sv p_is_comment_multiline,sv p_cursor_start,sv p_content,sd last)
+	set p_cursor_start# p_content#
+	setcall p_content# mem_spaces(p_content#,last)
+	set p_is_comment# 0
+	set p_is_comment_multiline# 0
+	ss pointer;set pointer p_content#
+	if pointer!=last
+		if pointer#=(commentascii)
+			set p_is_comment# 1
+			inc pointer
+			if pointer!=last
+				if pointer#=(asciiexclamationmark)
+					set p_is_comment_multiline# 1
+					inc pointer
+				endif
+			endif
+		endif
+	endif
+	return pointer
+endfunction
--- ocompiler-1.orig/src/files/functions/index.s
+++ /dev/null
@@ -1,22 +0,0 @@
-
-#pointer
-function command_start(sv p_is_comment,sv p_is_comment_multiline,sv p_cursor_start,sv p_content,sd last)
-	set p_cursor_start# p_content#
-	setcall p_content# mem_spaces(p_content#,last)
-	set p_is_comment# 0
-	set p_is_comment_multiline# 0
-	ss pointer;set pointer p_content#
-	if pointer!=last
-		if pointer#=(commentascii)
-			set p_is_comment# 1
-			inc pointer
-			if pointer!=last
-				if pointer#=(asciiexclamationmark)
-					set p_is_comment_multiline# 1
-					inc pointer
-				endif
-			endif
-		endif
-	endif
-	return pointer
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/inits.oc
@@ -0,0 +1,103 @@
+
+
+#err
+function prefs_set(ss name,ss value,sv p_p)
+	sd err
+	setcall err comline_pointer(name,p_p)
+	if err!=(noerror)
+		return err
+	endif
+	setcall err comline_value(value,p_p#)
+	return err
+endfunction
+#err
+function comline_parse(sd argc,sv argv)
+	if argc>2
+		mult argc :
+		add argc argv
+		add argv (2*:)
+		while argv!=argc
+			sd err
+			sd name
+			set name argv#
+			incst argv
+			if argv=argc
+				return "missing value for command line argument"
+			endif
+			sd value
+			set value argv#
+			sd p;setcall err prefs_set(name,value,#p) #p here is not required but at xfile is, and is faster this way
+			if err!=(noerror)
+				return err
+			endif
+			incst argv
+		endwhile
+	endif
+	return (noerror)
+endfunction
+#err
+function comline_value(ss v,sd p)
+	char input#1
+	set input v#
+	if input!=0
+		if input>=(asciizero)
+			inc v
+			if v#=0
+				sub input (asciizero)
+				if input<=(maximum_conf_digit)
+					set p# input
+					return (noerror)
+				endif
+				return "a command line value can have only 0,1 or 2" #also connected to xfile output
+			endif
+			return "command line value must have only one digit"
+		endif
+		return "command line value is not a number"
+	endif
+	return "command line value null"
+endfunction
+#err
+function comline_pointer(ss a,sd p_p)
+	sv t%nr_of_prefs_strings_p
+	sd e=nr_of_prefs_jumper
+	add e t
+	sd a_len
+	setcall a_len strlen(a)
+	while t!=e
+		ss b;set b t#
+		sd b_len
+		setcall b_len strlen(b)
+		if a_len=b_len
+			sd c
+			setcall c memcmp(a,b,a_len)
+			if c=0
+				sub t (nr_of_prefs_jumper)  #this will subtract from strings and will be straight on the pointers
+				set p_p# t#
+				return (noerror)
+			endif
+		endif
+		incst t
+	endwhile
+	return "command line argument not found"
+endfunction
+
+#err
+function pe_init()
+	sd ptr_nobits_virtual%ptr_nobits_virtual
+	set ptr_nobits_virtual# (No)  #.dtnb is not yet at exe format
+	#this is default pe_exe format, same behavior for nobits
+
+	vdata ptrdatasec%%ptr_datasec
+	vdata ptrcodesec%%ptr_codesec
+	vdata ptrtable%%ptr_table
+	vdata ptraddresses%%ptr_addresses
+	vdata ptrnames%%ptr_names
+
+	sd err
+	set ptrdatasec# (page_sectionalignment);setcall err enumbags_alloc(ptrdatasec);if err!=(noerror);Return err;EndIf
+	set ptrcodesec# (page_sectionalignment);setcall err enumbags_alloc(ptrcodesec);if err!=(noerror);Return err;EndIf
+	set ptrtable# (sizeofiedataparts);setcall err enumbags_alloc(ptrtable);if err!=(noerror);Return err;EndIf
+	set ptraddresses# (iaddressessize);setcall err enumbags_alloc(ptraddresses);if err!=(noerror);Return err;EndIf
+	set ptrnames# (sizeofienames);setcall err enumbags_alloc(ptrnames)
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/inits.s
+++ /dev/null
@@ -1,103 +0,0 @@
-
-
-#err
-function prefs_set(ss name,ss value,sv p_p)
-	sd err
-	setcall err comline_pointer(name,p_p)
-	if err!=(noerror)
-		return err
-	endif
-	setcall err comline_value(value,p_p#)
-	return err
-endfunction
-#err
-function comline_parse(sd argc,sv argv)
-	if argc>2
-		mult argc :
-		add argc argv
-		add argv (2*:)
-		while argv!=argc
-			sd err
-			sd name
-			set name argv#
-			incst argv
-			if argv=argc
-				return "missing value for command line argument"
-			endif
-			sd value
-			set value argv#
-			sd p;setcall err prefs_set(name,value,#p) #p here is not required but at xfile is, and is faster this way
-			if err!=(noerror)
-				return err
-			endif
-			incst argv
-		endwhile
-	endif
-	return (noerror)
-endfunction
-#err
-function comline_value(ss v,sd p)
-	char input#1
-	set input v#
-	if input!=0
-		if input>=(asciizero)
-			inc v
-			if v#=0
-				sub input (asciizero)
-				if input<=(last_call_align_input)
-					set p# input
-					return (noerror)
-				endif
-				return "a command line value can have only 0,1,2 or 3" #also connected to xfile output
-			endif
-			return "command line value must have only one digit"
-		endif
-		return "command line value is not a number"
-	endif
-	return "command line value null"
-endfunction
-#err
-function comline_pointer(ss a,sd p_p)
-	sv t%nr_of_prefs_strings_p
-	sd e=nr_of_prefs_jumper
-	add e t
-	sd a_len
-	setcall a_len strlen(a)
-	while t!=e
-		ss b;set b t#
-		sd b_len
-		setcall b_len strlen(b)
-		if a_len=b_len
-			sd c
-			setcall c memcmp(a,b,a_len)
-			if c=0
-				sub t (nr_of_prefs_jumper)  #this will subtract from strings and will be straight on the pointers
-				set p_p# t#
-				return (noerror)
-			endif
-		endif
-		incst t
-	endwhile
-	return "command line argument not found"
-endfunction
-
-#err
-function pe_init()
-	sd ptr_nobits_virtual%ptr_nobits_virtual
-	set ptr_nobits_virtual# (No)  #.dtnb is not yet at exe format
-	#this is default pe_exe format, same behavior for nobits
-
-	vdata ptrdatasec%%ptr_datasec
-	vdata ptrcodesec%%ptr_codesec
-	vdata ptrtable%%ptr_table
-	vdata ptraddresses%%ptr_addresses
-	vdata ptrnames%%ptr_names
-
-	sd err
-	set ptrdatasec# (page_sectionalignment);setcall err enumbags_alloc(ptrdatasec);if err!=(noerror);Return err;EndIf
-	set ptrcodesec# (page_sectionalignment);setcall err enumbags_alloc(ptrcodesec);if err!=(noerror);Return err;EndIf
-	set ptrtable# (sizeofiedataparts);setcall err enumbags_alloc(ptrtable);if err!=(noerror);Return err;EndIf
-	set ptraddresses# (iaddressessize);setcall err enumbags_alloc(ptraddresses);if err!=(noerror);Return err;EndIf
-	set ptrnames# (sizeofienames);setcall err enumbags_alloc(ptrnames)
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/override.oc
@@ -0,0 +1,41 @@
+
+#err
+function override_com(sv pcontent,sd psize,sd parses)
+	sd name
+	sd namesize
+	setcall namesize valinmem(pcontent#,psize#,(asciispace))
+	if namesize=0
+		return "first argument is missing at override"
+	endif
+	set name pcontent#
+	call advancecursors(pcontent,psize,namesize)
+	call spaces(pcontent,psize)
+	if psize#=0
+		return "second argument is missing at override"
+	endif
+
+	sd err
+	ss mem
+	sd valuesize;setcall valuesize find_whitespaceORcomment(pcontent#,psize#)
+
+	sd allocsize=1+1;add allocsize valuesize
+	add allocsize namesize
+	setcall err memoryalloc(allocsize,#mem)
+	if err=(noerror)
+		ss p;set p mem
+		call memtomem(p,name,namesize);add p namesize
+		set p# 0;inc p
+		ss value;set value p
+		call memtomem(p,pcontent#,valuesize);add p valuesize
+		set p# 0
+		ss pointer;setcall err prefs_set(mem,value,#pointer) #pointer here is not required but at xfile is, and is faster this way
+		if err=(noerror)
+			call advancecursors(pcontent,psize,valuesize)
+			if parses=(pass_write)
+				setcall err xfile_add_override_if(mem,namesize,pointer#)
+			endif
+		endif
+		call free(mem)
+	endif
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/override.s
+++ /dev/null
@@ -1,41 +0,0 @@
-
-#err
-function override_com(sv pcontent,sd psize,sd parses)
-	sd name
-	sd namesize
-	setcall namesize valinmem(pcontent#,psize#,(asciispace))
-	if namesize=0
-		return "first argument is missing at override"
-	endif
-	set name pcontent#
-	call advancecursors(pcontent,psize,namesize)
-	call spaces(pcontent,psize)
-	if psize#=0
-		return "second argument is missing at override"
-	endif
-
-	sd err
-	ss mem
-	sd valuesize;setcall valuesize find_whitespaceORcomment(pcontent#,psize#)
-
-	sd allocsize=1+1;add allocsize valuesize
-	add allocsize namesize
-	setcall err memoryalloc(allocsize,#mem)
-	if err=(noerror)
-		ss p;set p mem
-		call memtomem(p,name,namesize);add p namesize
-		set p# 0;inc p
-		ss value;set value p
-		call memtomem(p,pcontent#,valuesize);add p valuesize
-		set p# 0
-		ss pointer;setcall err prefs_set(mem,value,#pointer) #pointer here is not required but at xfile is, and is faster this way
-		if err=(noerror)
-			call advancecursors(pcontent,psize,valuesize)
-			if parses=(pass_write)
-				setcall err xfile_add_override_if(mem,namesize,pointer#)
-			endif
-		endif
-		call free(mem)
-	endif
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/pref/backup.oc
@@ -0,0 +1,33 @@
+
+function pref_store()
+	sv src%nr_of_prefs_pointers_p
+	sd dest%prefs_backup_p
+
+	sd max=nr_of_prefs_jumper
+	add max src
+	while src!=max
+		sd p;set p src#
+		set dest# p#
+		incst src
+		add dest (dwsz)
+	endwhile
+endfunction
+
+function pref_restore()
+	sd src%prefs_backup_p
+	sv dest%nr_of_prefs_pointers_p
+
+	sd max=nr_of_prefs_jumper
+	add max dest
+	while dest!=max
+		sd p;set p dest#
+		set p# src#
+		incst dest
+		add src (dwsz)
+	endwhile
+endfunction
+
+function backup_pref(sd p_formatdefined)
+	set p_formatdefined# 1
+	call pref_store() #this must be after "set nobits_virtual"
+endfunction
--- ocompiler-1.orig/src/files/functions/pref/backup.s
+++ /dev/null
@@ -1,33 +0,0 @@
-
-function pref_store()
-	sv src%nr_of_prefs_pointers_p
-	sd dest%prefs_backup_p
-
-	sd max=nr_of_prefs_jumper
-	add max src
-	while src!=max
-		sd p;set p src#
-		set dest# p#
-		incst src
-		add dest (dwsz)
-	endwhile
-endfunction
-
-function pref_restore()
-	sd src%prefs_backup_p
-	sv dest%nr_of_prefs_pointers_p
-
-	sd max=nr_of_prefs_jumper
-	add max dest
-	while dest!=max
-		sd p;set p dest#
-		set p# src#
-		incst dest
-		add src (dwsz)
-	endwhile
-endfunction
-
-function backup_pref(sd p_formatdefined)
-	set p_formatdefined# 1
-	call pref_store() #this must be after "set nobits_virtual"
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/pref/preffuncs.oc
@@ -0,0 +1,333 @@
+
+data nul_res_pref#1
+const p_nul_res_pref^nul_res_pref
+
+data ignore_format_so#1
+const p_ignore_format_so^ignore_format_so
+
+#bool for err2
+Function warnings(sd p_err,sd has_named_entry)
+	Data warningsboolptr%ptrwarningsbool
+	Data warningsbool#1
+	Set warningsbool warningsboolptr#
+	If warningsbool=(TRUE)
+		sd fn_name
+		sd var
+		setcall var scopes_searchinvars(p_err,#fn_name)
+		If var=(NULL)
+			if has_named_entry=(FALSE)
+				#call vars_log_reset()
+				#why this? init/endfunction is already doing this.
+
+				SetCall var searchinvars((NULL),0,(NULL),p_err) #,setref unused
+				if var!=(NULL)
+					set fn_name "(entry)"
+				endif
+			endif
+			if var=(NULL)
+				data ptrcodeFnObj%ptrcodeFnObj
+				if ptrcodeFnObj#!=(ignore_warn)
+					Data functionsptr%%ptr_functions
+					SetCall var varscore((NULL),0,functionsptr,p_err)
+					if var!=(NULL)
+						set fn_name "(function)"
+					endif
+				endif
+				if var=(NULL)
+					sd cb;setcall cb constants_bool((const_warn_get))
+					if cb!=(ignore_warn)
+						data constantsptr%%ptr_constants
+						SetCall var varscore((NULL),0,constantsptr,p_err)
+						if var!=(NULL)
+							set fn_name "(constant)"
+						endif
+					endif
+				endif
+			EndIf
+		EndIf
+		If var!=(NULL)
+			if p_err#=(noerror)
+				Char unrefformat="Unreferenced variable/function/constant: %s. Parent: %s."
+				Str ptrunrefformat^unrefformat
+
+				Data printbuffer#1
+
+				Data fileoff=nameoffset
+				Add var fileoff
+				SetCall printbuffer printbuf(ptrunrefformat,var,fn_name,0)
+				If printbuffer!=(NULL)
+					sd pallocerrormsg%ptrallocerrormsg
+					set pallocerrormsg# printbuffer
+				EndIf
+				Call safeMessage(printbuffer)
+				sd w%p_w_as_e
+				if w#=(TRUE)
+					set p_err# ""
+					return (FALSE)
+				endif
+			endif
+		EndIf
+	EndIf
+	return (TRUE)
+EndFunction
+
+#bool
+#parse and set the value, 0-9(one digit) values are expected here
+function parsepreferences(sd ptrcontent,sd ptrsize)
+	Char searchsign="="
+	Data sizeuntilsign#1
+
+	str content#1
+	data size#1
+	set content ptrcontent#
+	set size ptrsize#
+
+	SetCall sizeuntilsign valinmem(content,size,searchsign)
+	call advancecursors(ptrcontent,ptrsize,sizeuntilsign)
+
+	If sizeuntilsign!=size
+		sd is_comment=FALSE
+		sd backp;setcall backp parsepreferences_back(sizeuntilsign,ptrcontent#,#is_comment)
+		Call stepcursors(ptrcontent,ptrsize)
+		if backp!=(NULL)
+			set size ptrsize#
+			If size!=0
+				set content ptrcontent#
+				Call stepcursors(ptrcontent,ptrsize)
+				Set backp# content#
+				Sub backp# (asciizero)
+			endIf
+		else
+			if is_comment=(FALSE)
+				call Message("Unrecognized preference")
+			endif
+		endelse
+		return (TRUE)
+	EndIf
+	return (FALSE)
+endfunction
+#pointer/null
+function parsepreferences_back(sd sizeback,ss content,sd p_is_comment)
+	sv strs_pointers%nr_of_prefs_strings_p
+	sv end;set end strs_pointers
+	add end (nr_of_prefs_jumper)
+	while strs_pointers!=end
+		sd i
+		ss s;set s strs_pointers#
+		setcall i strlen(s)
+		if sizeback>=i
+			ss e;set e s;add e i
+			sd b
+			setcall b parsepreferences_back_helper(content,e,s,sizeback,i,p_is_comment)
+			if b=(TRUE)
+				#and put this to last because it is not expected to get same preference more than one time
+				sv test;sv test2
+				set test2 strs_pointers;sub test2 (nr_of_prefs_jumper)
+				sd return
+				sd store
+				set return test2#
+				set store strs_pointers#
+				sub end :
+
+				#this was before commenting preferences
+				#set test strs_pointers
+				#sd test3;set test3 test2
+				#while test!=end
+				#	incst test;incst test2
+				#	set strs_pointers# test#
+				#	set test3# test2#
+				#	incst strs_pointers;incst test3
+				#endwhile
+				#set test2# return
+
+				#this is now
+				set strs_pointers# end#
+				set test end
+				sub end (nr_of_prefs_jumper)
+				set test2# end#
+				set end# return
+
+				set test# store
+				return return
+			elseif p_is_comment#=(TRUE)
+				#this is a recognized preference but it is commented, stop comparing characters
+				return (NULL)
+			endelseif
+		endif
+		incst strs_pointers
+	endwhile
+	return (NULL)
+endfunction
+#bool
+function parsepreferences_back_helper(ss content,ss e,ss s,sd sizeback,sd i,sd p_is_comment)
+	while s!=e
+		dec content
+		dec e
+		if content#!=e#
+			return (FALSE)
+		endif
+	endwhile
+	#and verify if it is commented or another case
+	if sizeback>i
+		dec content
+		if content#!=(asciireturn)
+			if content#!=(asciicarriage)
+				if content#=(asciinumber)
+					set p_is_comment# (TRUE)
+				endif
+				return (FALSE)
+			endif
+		endif
+	endif
+	return (TRUE)
+endfunction
+
+function initpreferences()
+	#defaults
+	sd ptrwarningsbool%ptrwarningsbool
+	sd p_over_pref%p_over_pref
+	sd p_hidden_pref%p_hidden_pref
+	sd p_w_as_e%p_w_as_e
+	sd ptrlogbool%ptrlogbool
+	sd ptrcodeFnObj%ptrcodeFnObj
+	sd cb;setcall cb constants_bool((const_warn_get_init))
+	sd p_o_w%%p_offset_warn
+	sd ptrincludedir%ptrincludedir
+	sd text_fn_info;setcall text_fn_info fn_text_info()
+	sd conv_64;setcall conv_64 p_neg_is_for_64()
+	sd p_nul_res_pref%p_nul_res_pref
+	sd sdsv_p;setcall sdsv_p sd_as_sv((sd_as_sv_get))
+	sd p_inplace_reloc_pref%p_inplace_reloc_pref
+	sd p_pref_reloc_64%p_pref_reloc_64
+	sd p_underscore_pref%p_underscore_pref
+	sd p_exit_end%p_exit_end
+	sd p_include_sec%p_include_sec
+	sd p_ignore_format_so%p_ignore_format_so
+	sd ptr_call_align%ptr_call_align
+	sd ptr_nobits_virtual%ptr_nobits_virtual
+	sd ptr_has_debug%ptr_has_debug
+
+	data true=TRUE
+	data false=FALSE
+
+	set ptrwarningsbool# true
+	set p_over_pref# true
+	set p_hidden_pref# true
+	set p_w_as_e# true
+	set ptrlogbool# true
+	set ptrcodeFnObj# (log_warn)
+	set cb# (log_warn)
+	set p_o_w# (log_warn)
+	set ptrincludedir# true
+	set text_fn_info# false
+	set conv_64# (direct_convention_input)
+	set p_nul_res_pref# false
+	set sdsv_p# false
+	set p_inplace_reloc_pref# (addend_reloc)
+	set p_pref_reloc_64# true
+	set p_underscore_pref# false
+	set p_exit_end# false
+	set p_include_sec# false
+	set p_ignore_format_so# (No)
+	set ptr_call_align# (call_align_yes_all)
+	set ptr_nobits_virtual# (Yes)
+	set ptr_has_debug# (No)
+	set main.xbool (No)
+
+	#this is used also at arguments
+
+	sv q%nr_of_prefs_pointers_p
+	set q# ptrwarningsbool; incst q;set q# p_over_pref; incst q;set q# p_hidden_pref; incst q;set q# p_w_as_e; incst q;set q# ptrlogbool; incst q;set q# ptrcodeFnObj; incst q;set q# cb;           incst q;set q# ptrincludedir; incst q;set q# text_fn_info;    incst q;set q# conv_64;   incst q;set q# p_nul_res_pref; incst q;set q# sdsv_p;     incst q;set q# p_inplace_reloc_pref; incst q;set q# p_pref_reloc_64; incst q;set q# p_underscore_pref; incst q;set q# p_exit_end; incst q;set q# p_include_sec; incst q;set q# p_ignore_format_so; incst q;set q# ptr_call_align; incst q;set q# ptr_nobits_virtual; incst q;set q# ptr_has_debug; incst q;set q# p_o_w;         incst q;set q# #main.xbool
+	sv t%nr_of_prefs_strings_p
+	set t# "orphans";       incst t;set t# "over_pref"; incst t;set t# "hidden_pref"; incst t;set t# "w_as_e"; incst t;set t# "logfile";  incst t;set t# "codeFnObj";  incst t;set t# "const_warn"; incst t;set t# "includedir";  incst t;set t# "function_name"; incst t;set t# "conv_64"; incst t;set t# "nul_res_pref"; incst t;set t# "sd_as_sv"; incst t;set t# "inplace_reloc";      incst t;set t# "reloc_64";      incst t;set t# "underscore_pref"; incst t;set t# "exit_end"; incst t;set t# "include_sec"; incst t;set t# "ignore_format_so"; incst t;set t# "call_align";   incst t;set t# "nobits_virtual";   incst t;set t# "has_debug";   incst t;set t# "offset_warn"; incst t;set t# "x_file"
+endfunction
+
+#void
+function setpreferences(vstr scrpath)
+	Str preferences="ocompiler.conf"
+	data err#1
+	data noerr=noerror
+	Str preferencescontent#1
+	Data ptrpreferencescontent^preferencescontent
+	Data preferencessize#1
+	Data ptrpreferencessize^preferencessize
+
+	setcall err prefextra(preferences,ptrpreferencessize,ptrpreferencescontent,scrpath)
+	If err!=noerr
+		data null=0
+		#data void#1
+
+		str folders#1
+		setcall folders endoffolders(scrpath)
+		set folders# null
+		sub folders scrpath
+
+		data prefsz#1
+		setcall prefsz strlen(preferences)
+		inc prefsz
+
+		data total#1
+		set total folders
+		add total prefsz
+
+		data ptrmem#1
+		data allocptrmem^ptrmem
+		setcall err memoryalloc(total,allocptrmem)
+		if err!=noerr
+			call Message(err)
+			ret
+		endif
+
+		call memtomem(ptrmem,scrpath,folders)
+
+		str apppath#1
+		set apppath ptrmem
+		add apppath folders
+		call memtomem(apppath,preferences,prefsz)
+
+		SetCall err file_get_content_ofs(ptrmem,ptrpreferencessize,ptrpreferencescontent,null)
+		call free(ptrmem)
+		If err!=noerr
+			Call safeMessage(err)
+		EndIf
+	endif
+	If err=noerr
+		Data freepreferences#1
+		Set freepreferences preferencescontent
+
+		sd b=TRUE
+		while b=(TRUE)
+			setcall b parsepreferences(ptrpreferencescontent,ptrpreferencessize)
+		endwhile
+
+		Call free(freepreferences)
+	endif
+EndFunction
+#void
+
+function constants_bool(sd direction)
+	data bool#1
+	if direction=(const_warn_get)
+		return bool
+	endif
+	return #bool
+endfunction
+
+function inplace_reloc(sd p_addend)
+	sd p_inplace_reloc_pref%p_inplace_reloc_pref
+	if p_inplace_reloc_pref#=(zero_reloc)
+		set p_addend# (i386_obj_default_reloc)
+	endif
+endfunction
+#er
+function inplace_reloc_unres(sd p,sd add)
+	sd p_inplace_reloc_pref%p_inplace_reloc_pref
+	if p_inplace_reloc_pref#!=(zero_reloc)
+		sd err
+		sd ptrcodesec%%ptr_codesec
+		setcall err unresLc(add,ptrcodesec,0)
+		return err
+	endif
+	set p# (i386_obj_default_reloc)
+	return (noerror)
+endfunction
--- ocompiler-1.orig/src/files/functions/pref/preffuncs.s
+++ /dev/null
@@ -1,333 +0,0 @@
-
-data nul_res_pref#1
-const p_nul_res_pref^nul_res_pref
-
-data ignore_format_so#1
-const p_ignore_format_so^ignore_format_so
-
-#bool for err2
-Function warnings(sd p_err,sd has_named_entry)
-	Data warningsboolptr%ptrwarningsbool
-	Data warningsbool#1
-	Set warningsbool warningsboolptr#
-	If warningsbool=(TRUE)
-		sd fn_name
-		sd var
-		setcall var scopes_searchinvars(p_err,#fn_name)
-		If var=(NULL)
-			if has_named_entry=(FALSE)
-				#call vars_log_reset()
-				#why this? init/endfunction is already doing this.
-
-				SetCall var searchinvars((NULL),0,(NULL),p_err) #,setref unused
-				if var!=(NULL)
-					set fn_name "(entry)"
-				endif
-			endif
-			if var=(NULL)
-				data ptrcodeFnObj%ptrcodeFnObj
-				if ptrcodeFnObj#!=(ignore_warn)
-					Data functionsptr%%ptr_functions
-					SetCall var varscore((NULL),0,functionsptr,p_err)
-					if var!=(NULL)
-						set fn_name "(function)"
-					endif
-				endif
-				if var=(NULL)
-					sd cb;setcall cb constants_bool((const_warn_get))
-					if cb!=(ignore_warn)
-						data constantsptr%%ptr_constants
-						SetCall var varscore((NULL),0,constantsptr,p_err)
-						if var!=(NULL)
-							set fn_name "(constant)"
-						endif
-					endif
-				endif
-			EndIf
-		EndIf
-		If var!=(NULL)
-			if p_err#=(noerror)
-				Char unrefformat="Unreferenced variable/function/constant: %s. Parent: %s."
-				Str ptrunrefformat^unrefformat
-
-				Data printbuffer#1
-
-				Data fileoff=nameoffset
-				Add var fileoff
-				SetCall printbuffer printbuf(ptrunrefformat,var,fn_name,0)
-				If printbuffer!=(NULL)
-					sd pallocerrormsg%ptrallocerrormsg
-					set pallocerrormsg# printbuffer
-				EndIf
-				Call safeMessage(printbuffer)
-				sd w%p_w_as_e
-				if w#=(TRUE)
-					set p_err# ""
-					return (FALSE)
-				endif
-			endif
-		EndIf
-	EndIf
-	return (TRUE)
-EndFunction
-
-#bool
-#parse and set the value, 0-9(one digit) values are expected here
-function parsepreferences(sd ptrcontent,sd ptrsize)
-	Char searchsign="="
-	Data sizeuntilsign#1
-
-	str content#1
-	data size#1
-	set content ptrcontent#
-	set size ptrsize#
-
-	SetCall sizeuntilsign valinmem(content,size,searchsign)
-	call advancecursors(ptrcontent,ptrsize,sizeuntilsign)
-
-	If sizeuntilsign!=size
-		sd is_comment=FALSE
-		sd backp;setcall backp parsepreferences_back(sizeuntilsign,ptrcontent#,#is_comment)
-		Call stepcursors(ptrcontent,ptrsize)
-		if backp!=(NULL)
-			set size ptrsize#
-			If size!=0
-				set content ptrcontent#
-				Call stepcursors(ptrcontent,ptrsize)
-				Set backp# content#
-				Sub backp# (asciizero)
-			endIf
-		else
-			if is_comment=(FALSE)
-				call Message("Unrecognized preference")
-			endif
-		endelse
-		return (TRUE)
-	EndIf
-	return (FALSE)
-endfunction
-#pointer/null
-function parsepreferences_back(sd sizeback,ss content,sd p_is_comment)
-	sv strs_pointers%nr_of_prefs_strings_p
-	sv end;set end strs_pointers
-	add end (nr_of_prefs_jumper)
-	while strs_pointers!=end
-		sd i
-		ss s;set s strs_pointers#
-		setcall i strlen(s)
-		if sizeback>=i
-			ss e;set e s;add e i
-			sd b
-			setcall b parsepreferences_back_helper(content,e,s,sizeback,i,p_is_comment)
-			if b=(TRUE)
-				#and put this to last because it is not expected to get same preference more than one time
-				sv test;sv test2
-				set test2 strs_pointers;sub test2 (nr_of_prefs_jumper)
-				sd return
-				sd store
-				set return test2#
-				set store strs_pointers#
-				sub end :
-
-				#this was before commenting preferences
-				#set test strs_pointers
-				#sd test3;set test3 test2
-				#while test!=end
-				#	incst test;incst test2
-				#	set strs_pointers# test#
-				#	set test3# test2#
-				#	incst strs_pointers;incst test3
-				#endwhile
-				#set test2# return
-
-				#this is now
-				set strs_pointers# end#
-				set test end
-				sub end (nr_of_prefs_jumper)
-				set test2# end#
-				set end# return
-
-				set test# store
-				return return
-			elseif p_is_comment#=(TRUE)
-				#this is a recognized preference but it is commented, stop comparing characters
-				return (NULL)
-			endelseif
-		endif
-		incst strs_pointers
-	endwhile
-	return (NULL)
-endfunction
-#bool
-function parsepreferences_back_helper(ss content,ss e,ss s,sd sizeback,sd i,sd p_is_comment)
-	while s!=e
-		dec content
-		dec e
-		if content#!=e#
-			return (FALSE)
-		endif
-	endwhile
-	#and verify if it is commented or another case
-	if sizeback>i
-		dec content
-		if content#!=(asciireturn)
-			if content#!=(asciicarriage)
-				if content#=(asciinumber)
-					set p_is_comment# (TRUE)
-				endif
-				return (FALSE)
-			endif
-		endif
-	endif
-	return (TRUE)
-endfunction
-
-function initpreferences()
-	#defaults
-	sd ptrwarningsbool%ptrwarningsbool
-	sd p_over_pref%p_over_pref
-	sd p_hidden_pref%p_hidden_pref
-	sd p_w_as_e%p_w_as_e
-	sd ptrlogbool%ptrlogbool
-	sd ptrcodeFnObj%ptrcodeFnObj
-	sd cb;setcall cb constants_bool((const_warn_get_init))
-	sd p_o_w%%p_offset_warn
-	sd ptrincludedir%ptrincludedir
-	sd text_fn_info;setcall text_fn_info fn_text_info()
-	sd conv_64;setcall conv_64 p_neg_is_for_64()
-	sd p_nul_res_pref%p_nul_res_pref
-	sd sdsv_p;setcall sdsv_p sd_as_sv((sd_as_sv_get))
-	sd p_inplace_reloc_pref%p_inplace_reloc_pref
-	sd p_pref_reloc_64%p_pref_reloc_64
-	sd p_underscore_pref%p_underscore_pref
-	sd p_exit_end%p_exit_end
-	sd p_include_sec%p_include_sec
-	sd p_ignore_format_so%p_ignore_format_so
-	sd ptr_call_align%ptr_call_align
-	sd ptr_nobits_virtual%ptr_nobits_virtual
-	sd ptr_has_debug%ptr_has_debug
-
-	data true=TRUE
-	data false=FALSE
-
-	set ptrwarningsbool# true
-	set p_over_pref# true
-	set p_hidden_pref# true
-	set p_w_as_e# true
-	set ptrlogbool# true
-	set ptrcodeFnObj# (log_warn)
-	set cb# (log_warn)
-	set p_o_w# (log_warn)
-	set ptrincludedir# true
-	set text_fn_info# false
-	set conv_64# (direct_convention_input)
-	set p_nul_res_pref# false
-	set sdsv_p# false
-	set p_inplace_reloc_pref# (addend_reloc)
-	set p_pref_reloc_64# true
-	set p_underscore_pref# false
-	set p_exit_end# false
-	set p_include_sec# false
-	set p_ignore_format_so# (No)
-	set ptr_call_align# (call_align_yes_all)
-	set ptr_nobits_virtual# (Yes)
-	set ptr_has_debug# (No)
-	set main.xbool (No)
-
-	#this is used also at arguments
-
-	sv q%nr_of_prefs_pointers_p
-	set q# ptrwarningsbool; incst q;set q# p_over_pref; incst q;set q# p_hidden_pref; incst q;set q# p_w_as_e; incst q;set q# ptrlogbool; incst q;set q# ptrcodeFnObj; incst q;set q# cb;           incst q;set q# ptrincludedir; incst q;set q# text_fn_info;    incst q;set q# conv_64;   incst q;set q# p_nul_res_pref; incst q;set q# sdsv_p;     incst q;set q# p_inplace_reloc_pref; incst q;set q# p_pref_reloc_64; incst q;set q# p_underscore_pref; incst q;set q# p_exit_end; incst q;set q# p_include_sec; incst q;set q# p_ignore_format_so; incst q;set q# ptr_call_align; incst q;set q# ptr_nobits_virtual; incst q;set q# ptr_has_debug; incst q;set q# p_o_w;         incst q;set q# #main.xbool
-	sv t%nr_of_prefs_strings_p
-	set t# "orphans";       incst t;set t# "over_pref"; incst t;set t# "hidden_pref"; incst t;set t# "w_as_e"; incst t;set t# "logfile";  incst t;set t# "codeFnObj";  incst t;set t# "const_warn"; incst t;set t# "includedir";  incst t;set t# "function_name"; incst t;set t# "conv_64"; incst t;set t# "nul_res_pref"; incst t;set t# "sd_as_sv"; incst t;set t# "inplace_reloc";      incst t;set t# "reloc_64";      incst t;set t# "underscore_pref"; incst t;set t# "exit_end"; incst t;set t# "include_sec"; incst t;set t# "ignore_format_so"; incst t;set t# "call_align";   incst t;set t# "nobits_virtual";   incst t;set t# "has_debug";   incst t;set t# "offset_warn"; incst t;set t# "x_file"
-endfunction
-
-#void
-function setpreferences(vstr scrpath)
-	Str preferences="ocompiler.conf"
-	data err#1
-	data noerr=noerror
-	Str preferencescontent#1
-	Data ptrpreferencescontent^preferencescontent
-	Data preferencessize#1
-	Data ptrpreferencessize^preferencessize
-
-	setcall err prefextra(preferences,ptrpreferencessize,ptrpreferencescontent,scrpath)
-	If err!=noerr
-		data null=0
-		#data void#1
-
-		str folders#1
-		setcall folders endoffolders(scrpath)
-		set folders# null
-		sub folders scrpath
-
-		data prefsz#1
-		setcall prefsz strlen(preferences)
-		inc prefsz
-
-		data total#1
-		set total folders
-		add total prefsz
-
-		data ptrmem#1
-		data allocptrmem^ptrmem
-		setcall err memoryalloc(total,allocptrmem)
-		if err!=noerr
-			call Message(err)
-			ret
-		endif
-
-		call memtomem(ptrmem,scrpath,folders)
-
-		str apppath#1
-		set apppath ptrmem
-		add apppath folders
-		call memtomem(apppath,preferences,prefsz)
-
-		SetCall err file_get_content_ofs(ptrmem,ptrpreferencessize,ptrpreferencescontent,null)
-		call free(ptrmem)
-		If err!=noerr
-			Call safeMessage(err)
-		EndIf
-	endif
-	If err=noerr
-		Data freepreferences#1
-		Set freepreferences preferencescontent
-
-		sd b=TRUE
-		while b=(TRUE)
-			setcall b parsepreferences(ptrpreferencescontent,ptrpreferencessize)
-		endwhile
-
-		Call free(freepreferences)
-	endif
-EndFunction
-#void
-
-function constants_bool(sd direction)
-	data bool#1
-	if direction=(const_warn_get)
-		return bool
-	endif
-	return #bool
-endfunction
-
-function inplace_reloc(sd p_addend)
-	sd p_inplace_reloc_pref%p_inplace_reloc_pref
-	if p_inplace_reloc_pref#=(zero_reloc)
-		set p_addend# (i386_obj_default_reloc)
-	endif
-endfunction
-#er
-function inplace_reloc_unres(sd p,sd add)
-	sd p_inplace_reloc_pref%p_inplace_reloc_pref
-	if p_inplace_reloc_pref#!=(zero_reloc)
-		sd err
-		sd ptrcodesec%%ptr_codesec
-		setcall err unresLc(add,ptrcodesec,0)
-		return err
-	endif
-	set p# (i386_obj_default_reloc)
-	return (noerror)
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/pref/sdsv.oc
@@ -0,0 +1,11 @@
+
+function sd_as_sv(sd direction,sd typenumber)
+	data bool#1
+	if direction=(sd_as_sv_bool)
+		if bool=(TRUE)
+			if typenumber=(stackdatanumber);return (TRUE);endif
+		endif
+		return (FALSE)
+	endif
+	return #bool
+endfunction
--- ocompiler-1.orig/src/files/functions/pref/sdsv.s
+++ /dev/null
@@ -1,11 +0,0 @@
-
-function sd_as_sv(sd direction,sd typenumber)
-	data bool#1
-	if direction=(sd_as_sv_bool)
-		if bool=(TRUE)
-			if typenumber=(stackdatanumber);return (TRUE);endif
-		endif
-		return (FALSE)
-	endif
-	return #bool
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/scopes.oc
@@ -0,0 +1,271 @@
+
+const sizeofclassinfostartdata=location
+#                              data
+const classinfostartdatax=sizeofclassinfostartdata
+const sizeofclassinfostarts=sizeofclassinfostartdata+location
+#                                                    datax
+const classinfosizedata=sizeofclassinfostarts
+const sizeofclassinfosizedata=location
+#                             datasize
+const sizeofclassinfosize=sizeofclassinfosizedata+location
+#                                                 dataxsize
+const classinfosizedatax=sizeofclassinfosizedata
+
+const sizeofclassinfo=sizeofclassinfostarts+sizeofclassinfosize
+
+value scopesbag#1
+data scopesbag_size#1
+const scopesbag_ptr^scopesbag
+const scopesbag_size_ptr^scopesbag_size
+function scopes_free()
+	sv s%scopesbag_ptr
+	if s#!=(NULL)
+		sv start;set start s#
+		add s :
+		sv pointer;set pointer s#d^
+		add pointer start
+		if start!=pointer
+			sub pointer :
+			sd scps%%ptr_scopes
+			if pointer#!=scps
+				add pointer :
+			endif
+			#else let named entry like it was
+			while start!=pointer
+				sub pointer :
+				sv cursor_first;set cursor_first pointer#
+				if cursor_first!=(NULL)
+					sv cursor=sizeofscope
+					add cursor cursor_first
+					while cursor_first!=cursor
+						#reversed order for speed reasons here, not care about alloc order
+						sub cursor (sizeofcontainer)
+						call enumbags_free(cursor) #this has check against NULL
+					endwhile
+					call free(cursor_first)
+				endif
+			endwhile
+		endif
+		call free(start)
+	endif
+endfunction
+
+#err
+function scopes_alloc(sd has_named_entry,sd i)
+	#now at three pass the fns are mixed with imports
+	#sv ptrfunctions%ptrfunctions
+	#sd i=0
+	#sd fns
+	#sv last
+	#call getcontandcontReg(ptrfunctions,#fns,#last)
+	#add last fns
+	#while fns!=last
+	#	add fns (nameoffset)
+	#	addcall fns strlen(fns)
+	#	inc fns
+	#	inc i
+	#endwhile
+	#mult i :
+	#
+	#sd almost_same_size_container%ptrstackAlign
+	#call getcontReg(almost_same_size_container,#i)
+	#if has_named_entry==(FALSE)
+	#	sub i :
+	#endif
+	if has_named_entry=(TRUE)
+		inc i
+	endif
+	mult i :
+	#
+	sv s%scopesbag_ptr
+	setcall s# memcalloc(i)
+	sv start;set start s#
+	if start!=(NULL)
+		add s :
+		set s# i
+		sv pointer;set pointer start
+		add pointer i
+		if has_named_entry=(TRUE)
+			#entry tag is, and is last, entry. define global variable, use in function is practical
+			sub pointer :
+			sd scps%%ptr_scopes
+			set pointer# scps
+		endif
+		#alloc some dummy values
+		while start!=pointer
+			sub pointer :
+			setcall pointer# memcalloc((sizeofscope+sizeofclassinfo)) #is calloc, needing reg 0, in case it is searched , and at freeings, and at size (grab future)
+			if pointer#=(NULL)
+				return (error)
+			endif
+		endwhile
+		return (noerror)
+	endif
+	return (error)
+endfunction
+
+function scopes_get_scope(sd i)
+	sv s%scopesbag_ptr
+	set s s#
+	mult i :
+	add s i
+	return s#
+endfunction
+
+function scopes_store(sv scope)
+	sv s%scopesbag_ptr
+	mult scope :
+	add scope s#
+	set scope scope#
+	sd last=sizeofscope
+	sv pointer%%ptr_fnscopes
+	add last pointer
+	while pointer!=last
+		sd cont;sd contReg;call getcontandcontReg(pointer,#cont,#contReg)
+		#add new cont at fns
+		call setcontMax(pointer,(subscope))
+		sd err;setcall err enumbags_alloc(pointer)
+		if err!=(noerror)
+			return err
+		endif
+		# reg is zero outside (was from when there was only one scope)
+		#transfer cont to store
+		# max is not used
+		call setcont(scope,cont)
+		call setcontReg(scope,contReg)
+		#next
+		add scope (sizeofcontainer)
+		add pointer (sizeofcontainer)
+	endwhile
+
+	#and set for class size, can get fast inter functions size for entry, and also the size of it
+	sd start;set start scope
+	add scope (sizeofclassinfostarts)
+
+	setcall scope#d^ get_img_vdata_dataReg()
+	sub scope#d^ start#
+
+	add start (sizeofclassinfostartdata)
+	add scope (sizeofclassinfosizedata)
+	setcall scope#d^ get_img_vdata_dataSize()
+	sub scope#d^ start#
+
+	return (noerror)
+endfunction
+
+function scopes_searchinvars(sd p_err,sv p_name)
+	value entrybags%%ptr_scopes
+
+	sd psz%scopesbag_size_ptr
+	#now at three pass the fns are mixed with imports
+	sd sz;set sz psz#
+	div sz :
+	sd i=0
+
+	sv ptrfunctions%%ptr_functions
+	sd fns
+	call getcont(ptrfunctions,#fns)
+	while i!=sz
+		sd ibit;setcall ibit importbit(fns)
+		add fns (nameoffset)
+		sd size;setcall size strlen(fns)
+		if ibit=0
+			sd data
+			sd scope
+			setcall scope scopes_get_scope(i)
+			if scope!=entrybags ##calloc was for every scope
+				call vars_log_set(fns,size) #more at the function
+			else
+				call vars_log_reset()
+			endelse
+			setcall data searchinvars_scope_warn(p_err,scope)
+			if data!=(NULL)
+				set p_name# fns
+				return data
+			endif
+			inc i
+		endif
+		add fns size
+		inc fns
+	endwhile
+	return (NULL)
+endfunction
+
+
+function scopes_store_class()
+	sd ptrfunctionTagIndex%ptrfunctionTagIndex
+	sd scope;setcall scope scopes_get_scope(ptrfunctionTagIndex#)
+	add scope (sizeofscope)
+	setcall scope# get_img_vdata_dataReg()  #and img_vdata ? at getarg will subtract from ptrdata# that is with the same img_vdata
+	add scope (location)
+	setcall scope# get_img_vdata_dataSize()
+endfunction
+function scopes_get_class_data(sd scope,sd data)
+	add scope (sizeofscope)
+	sd expand;setcall expand expandbit(data)
+	if expand!=0
+		add scope (location)
+		return scope#
+	endif
+	return scope#
+endfunction
+
+#size
+function get_scope_data_size(sd pos,sd is_expand)
+	value entrybags%%ptr_scopes
+	vdata ptrfunctionTagIndex%ptrfunctionTagIndex
+	vdata ptrinnerfunction%globalinnerfunction
+	sd size
+	sd scope;setcall scope scopes_get_scope(pos)
+	if scope!=entrybags
+		if ptrfunctionTagIndex#=pos
+			if ptrinnerfunction#=(TRUE)
+				add scope (sizeofscope)
+				if is_expand!=0
+					add scope (classinfostartdatax)
+					setcall size get_img_vdata_dataSize()
+				else
+					setcall size get_img_vdata_dataReg()
+				endelse
+				sub size scope#
+				return size
+			endif
+			#will be 0 (from calloc)
+		endif
+		#another function
+		add scope (sizeofscope+classinfosizedata)
+		if is_expand!=0
+			add scope (classinfosizedatax)
+		endif
+		return scope# #calloc at bigger
+	endif
+	#entry
+	if ptrinnerfunction#=(TRUE)
+		setcall scope scopes_get_scope(ptrfunctionTagIndex#)
+		add scope (sizeofscope)
+		if is_expand!=0
+			add scope (classinfostartdatax)
+		endif
+		set size scope#
+	else
+		if is_expand!=0
+			setcall size get_img_vdata_dataSize()
+		else
+			setcall size get_img_vdata_dataReg()
+		endelse
+	endelse
+	sv p%scopesbag_ptr
+	set p p#
+	sd last=:;mult last ptrfunctionTagIndex#
+	add last p
+	while p<^last
+		sd s;set s p#
+		add s (sizeofscope+classinfosizedata)
+		if is_expand!=0
+			add s (classinfosizedatax)
+		endif
+		sub size s#
+		incst p
+	endwhile
+	return size
+endfunction
--- ocompiler-1.orig/src/files/functions/scopes.s
+++ /dev/null
@@ -1,271 +0,0 @@
-
-const sizeofclassinfostartdata=location
-#                              data
-const classinfostartdatax=sizeofclassinfostartdata
-const sizeofclassinfostarts=sizeofclassinfostartdata+location
-#                                                    datax
-const classinfosizedata=sizeofclassinfostarts
-const sizeofclassinfosizedata=location
-#                             datasize
-const sizeofclassinfosize=sizeofclassinfosizedata+location
-#                                                 dataxsize
-const classinfosizedatax=sizeofclassinfosizedata
-
-const sizeofclassinfo=sizeofclassinfostarts+sizeofclassinfosize
-
-value scopesbag#1
-data scopesbag_size#1
-const scopesbag_ptr^scopesbag
-const scopesbag_size_ptr^scopesbag_size
-function scopes_free()
-	sv s%scopesbag_ptr
-	if s#!=(NULL)
-		sv start;set start s#
-		add s :
-		sv pointer;set pointer s#d^
-		add pointer start
-		if start!=pointer
-			sub pointer :
-			sd scps%%ptr_scopes
-			if pointer#!=scps
-				add pointer :
-			endif
-			#else let named entry like it was
-			while start!=pointer
-				sub pointer :
-				sv cursor_first;set cursor_first pointer#
-				if cursor_first!=(NULL)
-					sv cursor=sizeofscope
-					add cursor cursor_first
-					while cursor_first!=cursor
-						#reversed order for speed reasons here, not care about alloc order
-						sub cursor (sizeofcontainer)
-						call enumbags_free(cursor) #this has check against NULL
-					endwhile
-					call free(cursor_first)
-				endif
-			endwhile
-		endif
-		call free(start)
-	endif
-endfunction
-
-#err
-function scopes_alloc(sd has_named_entry,sd i)
-	#now at three pass the fns are mixed with imports
-	#sv ptrfunctions%ptrfunctions
-	#sd i=0
-	#sd fns
-	#sv last
-	#call getcontandcontReg(ptrfunctions,#fns,#last)
-	#add last fns
-	#while fns!=last
-	#	add fns (nameoffset)
-	#	addcall fns strlen(fns)
-	#	inc fns
-	#	inc i
-	#endwhile
-	#mult i :
-	#
-	#sd almost_same_size_container%ptrstackAlign
-	#call getcontReg(almost_same_size_container,#i)
-	#if has_named_entry==(FALSE)
-	#	sub i :
-	#endif
-	if has_named_entry=(TRUE)
-		inc i
-	endif
-	mult i :
-	#
-	sv s%scopesbag_ptr
-	setcall s# memcalloc(i)
-	sv start;set start s#
-	if start!=(NULL)
-		add s :
-		set s# i
-		sv pointer;set pointer start
-		add pointer i
-		if has_named_entry=(TRUE)
-			#entry tag is, and is last, entry. define global variable, use in function is practical
-			sub pointer :
-			sd scps%%ptr_scopes
-			set pointer# scps
-		endif
-		#alloc some dummy values
-		while start!=pointer
-			sub pointer :
-			setcall pointer# memcalloc((sizeofscope+sizeofclassinfo)) #is calloc, needing reg 0, in case it is searched , and at freeings, and at size (grab future)
-			if pointer#=(NULL)
-				return (error)
-			endif
-		endwhile
-		return (noerror)
-	endif
-	return (error)
-endfunction
-
-function scopes_get_scope(sd i)
-	sv s%scopesbag_ptr
-	set s s#
-	mult i :
-	add s i
-	return s#
-endfunction
-
-function scopes_store(sv scope)
-	sv s%scopesbag_ptr
-	mult scope :
-	add scope s#
-	set scope scope#
-	sd last=sizeofscope
-	sv pointer%%ptr_fnscopes
-	add last pointer
-	while pointer!=last
-		sd cont;sd contReg;call getcontandcontReg(pointer,#cont,#contReg)
-		#add new cont at fns
-		call setcontMax(pointer,(subscope))
-		sd err;setcall err enumbags_alloc(pointer)
-		if err!=(noerror)
-			return err
-		endif
-		# reg is zero outside (was from when there was only one scope)
-		#transfer cont to store
-		# max is not used
-		call setcont(scope,cont)
-		call setcontReg(scope,contReg)
-		#next
-		add scope (sizeofcontainer)
-		add pointer (sizeofcontainer)
-	endwhile
-
-	#and set for class size, can get fast inter functions size for entry, and also the size of it
-	sd start;set start scope
-	add scope (sizeofclassinfostarts)
-
-	setcall scope#d^ get_img_vdata_dataReg()
-	sub scope#d^ start#
-
-	add start (sizeofclassinfostartdata)
-	add scope (sizeofclassinfosizedata)
-	setcall scope#d^ get_img_vdata_dataSize()
-	sub scope#d^ start#
-
-	return (noerror)
-endfunction
-
-function scopes_searchinvars(sd p_err,sv p_name)
-	value entrybags%%ptr_scopes
-
-	sd psz%scopesbag_size_ptr
-	#now at three pass the fns are mixed with imports
-	sd sz;set sz psz#
-	div sz :
-	sd i=0
-
-	sv ptrfunctions%%ptr_functions
-	sd fns
-	call getcont(ptrfunctions,#fns)
-	while i!=sz
-		sd ibit;setcall ibit importbit(fns)
-		add fns (nameoffset)
-		sd size;setcall size strlen(fns)
-		if ibit=0
-			sd data
-			sd scope
-			setcall scope scopes_get_scope(i)
-			if scope!=entrybags ##calloc was for every scope
-				call vars_log_set(fns,size) #more at the function
-			else
-				call vars_log_reset()
-			endelse
-			setcall data searchinvars_scope_warn(p_err,scope)
-			if data!=(NULL)
-				set p_name# fns
-				return data
-			endif
-			inc i
-		endif
-		add fns size
-		inc fns
-	endwhile
-	return (NULL)
-endfunction
-
-
-function scopes_store_class()
-	sd ptrfunctionTagIndex%ptrfunctionTagIndex
-	sd scope;setcall scope scopes_get_scope(ptrfunctionTagIndex#)
-	add scope (sizeofscope)
-	setcall scope# get_img_vdata_dataReg()  #and img_vdata ? at getarg will subtract from ptrdata# that is with the same img_vdata
-	add scope (location)
-	setcall scope# get_img_vdata_dataSize()
-endfunction
-function scopes_get_class_data(sd scope,sd data)
-	add scope (sizeofscope)
-	sd expand;setcall expand expandbit(data)
-	if expand!=0
-		add scope (location)
-		return scope#
-	endif
-	return scope#
-endfunction
-
-#size
-function get_scope_data_size(sd pos,sd is_expand)
-	value entrybags%%ptr_scopes
-	vdata ptrfunctionTagIndex%ptrfunctionTagIndex
-	vdata ptrinnerfunction%globalinnerfunction
-	sd size
-	sd scope;setcall scope scopes_get_scope(pos)
-	if scope!=entrybags
-		if ptrfunctionTagIndex#=pos
-			if ptrinnerfunction#=(TRUE)
-				add scope (sizeofscope)
-				if is_expand!=0
-					add scope (classinfostartdatax)
-					setcall size get_img_vdata_dataSize()
-				else
-					setcall size get_img_vdata_dataReg()
-				endelse
-				sub size scope#
-				return size
-			endif
-			#will be 0 (from calloc)
-		endif
-		#another function
-		add scope (sizeofscope+classinfosizedata)
-		if is_expand!=0
-			add scope (classinfosizedatax)
-		endif
-		return scope# #calloc at bigger
-	endif
-	#entry
-	if ptrinnerfunction#=(TRUE)
-		setcall scope scopes_get_scope(ptrfunctionTagIndex#)
-		add scope (sizeofscope)
-		if is_expand!=0
-			add scope (classinfostartdatax)
-		endif
-		set size scope#
-	else
-		if is_expand!=0
-			setcall size get_img_vdata_dataSize()
-		else
-			setcall size get_img_vdata_dataReg()
-		endelse
-	endelse
-	sv p%scopesbag_ptr
-	set p p#
-	sd last=:;mult last ptrfunctionTagIndex#
-	add last p
-	while p<^last
-		sd s;set s p#
-		add s (sizeofscope+classinfosizedata)
-		if is_expand!=0
-			add s (classinfosizedatax)
-		endif
-		sub size s#
-		incst p
-	endwhile
-	return size
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/short.oc
@@ -0,0 +1,17 @@
+
+function i_to_s(sd data,ss pshort)
+	set pshort# data
+	inc pshort
+	div data 0x100
+	set pshort# data
+endfunction
+
+function s_to_i(ss pshort)
+	sd out
+	set out pshort#
+	inc pshort
+	ss p^out
+	inc p
+	set p# pshort#
+	return out
+endfunction
--- ocompiler-1.orig/src/files/functions/short.s
+++ /dev/null
@@ -1,17 +0,0 @@
-
-function i_to_s(sd data,ss pshort)
-	set pshort# data
-	inc pshort
-	div data 0x100
-	set pshort# data
-endfunction
-
-function s_to_i(ss pshort)
-	sd out
-	set out pshort#
-	inc pshort
-	ss p^out
-	inc p
-	set p# pshort#
-	return out
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/stack/stack.oc
@@ -0,0 +1,173 @@
+
+
+#set(0)/get(1) index
+function ramp_index(data mode,data container)
+	data reg#1
+	data set=0
+	if mode=set
+		data ptrreg^reg
+		#const ramppointer^reg
+		call getcontReg(container,ptrreg)
+		data dword=4
+		sub reg dword
+	else
+		return reg
+	endelse
+endfunction
+
+
+#typenumber
+function stackfilter(data nr,data ptrstack)
+	data totalmemvariables=totalmemvariables
+	data numberofvars=numberofvars
+	data false=0
+	data true=1
+	set ptrstack# false
+	if nr>=totalmemvariables
+		if nr<numberofvars
+			sub nr totalmemvariables
+			set ptrstack# true
+		endif
+	endif
+	return nr
+endfunction
+
+
+#p
+function getptrramp()
+	data code#1
+	data ptrcode^code
+	data ptrcodesec%%ptr_codesec
+	call getcont(ptrcodesec,ptrcode)
+	data get=1
+	addcall code ramp_index(get)
+	return code
+endfunction
+#ind(before)
+function growramp(sd value,sv perr)
+	vdata ptrramp#1
+	setcall ptrramp getptrramp()
+	sd ret;set ret ptrramp#
+	setcall perr# maxsectioncheck(value,ptrramp)  #we are adding a dword( sub ebx dword ), at 64 can go further, there are reserves declarations, a check is required
+	return ret
+endfunction
+#ind(before)
+function addramp(sv perr)
+	sd index
+	setcall index stack64_enlarge((dwsz))
+	data ramp#1
+	setcall ramp growramp(index,perr)
+	return ramp
+endfunction
+#ind
+function getramp_ebxrel()
+	data ptrramp#1
+	setcall ptrramp getptrramp()
+	return ptrramp#
+endfunction
+
+#er
+function entryscope()
+	data container%%ptr_codesec
+	sd err
+	#push ebx,push ebp
+	const scope1_start=\;char scope1={0x53,0x55};const scope1_sz=\-scope1_start
+	const stackinitpush=2*dwsz
+	#mov e(r)bp e(r)sp
+	const scope2_start=\;char scope2={moveatregthemodrm,0xec};const scope2_sz=\-scope2_start
+	#mov e(r)bx e(r)sp
+	const scope3_start=\;char scope3={moveatregthemodrm,0xdc};const scope3_sz=\-scope3_start
+	#sub e(r)bx dword
+	const scope4_start=\;char scope4={0x81,0xeb}
+	data *scopestack=0;const scope4_sz=\-scope4_start
+
+	setcall err addtosec(#scope1,(scope1_sz),container);if err!=(noerror);return err;endif
+	setcall err rex_w_if64();if err!=(noerror);return err;endif
+	setcall err addtosec(#scope2,(scope2_sz),container);if err!=(noerror);return err;endif
+	setcall err rex_w_if64();if err!=(noerror);return err;endif
+	setcall err addtosec(#scope3,(scope3_sz),container);if err!=(noerror);return err;endif
+
+	sd bool;setcall bool align_stack()
+	if bool=(TRUE)
+		setcall err rex_w_if64();if err!=(noerror);return err;endif
+		setcall err addtosec(#scope4,(scope4_sz),container);if err!=(noerror);return err;endif
+		data set=0;call ramp_index(set,container) #here is storing the sum when stackvariables(ebx) is required
+	endif
+
+	setcall err align_entryscope()
+	return err
+endfunction
+
+#
+function entryscope_verify_code()
+	data ptrfnavailable%ptrfnavailable
+	data one=1
+	if ptrfnavailable#=one
+		data ptrinnerfunction%globalinnerfunction
+		if ptrinnerfunction#!=(TRUE)
+			data two=2
+			set ptrfnavailable# two
+			call entryscope()
+		endif
+	endif
+endfunction
+
+
+#er
+function addtocode_decstack(sd for_64)
+	char movtostack=moveatmemtheproc
+	char modrm#1
+	data rampindex#1
+
+	vdata stack^movtostack
+	vdata ptrcodesec%%ptr_codesec
+
+	sd err
+	if for_64=(TRUE)
+		call rex_w(#err);if err!=(noerror);return err;endif
+	endif
+
+	setcall rampindex addramp(#err)
+	#is with sub now     neg rampindex
+	if err=(noerror)
+		sd size
+		if rampindex<^0x80    #disp8 is signed
+			setcall modrm formmodrm((disp8),0,(ebxregnumber))
+			set size 3
+		else
+			setcall modrm formmodrm((disp32),0,(ebxregnumber))
+			set size 6
+		endelse
+		setcall err addtosec(stack,size,ptrcodesec)
+	endif
+	return err
+endfunction
+#er
+function addtocodeforstack(sd rightstackpointer,sd for_64)
+	#s^s
+	data noerr=noerror
+
+	sd err
+	setcall err writetake((eaxregnumber),rightstackpointer)
+	if err!=noerr
+		return err
+	endif
+
+	setcall err addtocode_decstack(for_64)
+	return err
+endfunction
+#er
+function addtocodefordata(sd value,sd for_64,sd ext)
+	char code=ateaximm
+	data val#1
+
+	sd err
+	setcall err reloc64_ante();If err!=(noerror);Return err;EndIf
+	data ptrcodesec%%ptr_codesec
+	set val value
+	setcall err addtosec(#code,5,ptrcodesec);If err!=(noerror);Return err;EndIf
+	setcall err reloc64_post_base_extension(ptrcodesec,ext);If err!=(noerror);Return err;EndIf
+
+	setcall err addtocode_decstack(for_64)
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/stack/stack.s
+++ /dev/null
@@ -1,170 +0,0 @@
-
-
-#set(0)/get(1) index
-function ramp_index(data mode,data container)
-	data reg#1
-	data set=0
-	if mode=set
-		data ptrreg^reg
-		#const ramppointer^reg
-		call getcontReg(container,ptrreg)
-		data dword=4
-		sub reg dword
-	else
-		return reg
-	endelse
-endfunction
-
-
-#typenumber
-function stackfilter(data nr,data ptrstack)
-	data totalmemvariables=totalmemvariables
-	data numberofvars=numberofvars
-	data false=0
-	data true=1
-	set ptrstack# false
-	if nr>=totalmemvariables
-		if nr<numberofvars
-			sub nr totalmemvariables
-			set ptrstack# true
-		endif
-	endif
-	return nr
-endfunction
-
-
-#p
-function getptrramp()
-	data code#1
-	data ptrcode^code
-	data ptrcodesec%%ptr_codesec
-	call getcont(ptrcodesec,ptrcode)
-	data get=1
-	addcall code ramp_index(get)
-	return code
-endfunction
-#ind(before)
-function growramp(sd value,sv perr)
-	vdata ptrramp#1
-	setcall ptrramp getptrramp()
-	sd ret;set ret ptrramp#
-	setcall perr# maxsectioncheck(value,ptrramp)
-	return ret
-endfunction
-#ind(before)
-function addramp(sv perr)
-	sd index
-	setcall index stack64_enlarge((dwsz))
-	data ramp#1
-	setcall ramp growramp(index,perr)
-	return ramp
-endfunction
-#ind
-function getramp_ebxrel()
-	data ptrramp#1
-	setcall ptrramp getptrramp()
-	return ptrramp#
-endfunction
-
-#er
-function entryscope()
-	data container%%ptr_codesec
-	sd err
-	#push ebx,push ebp
-	const scope1_start=\;char scope1={0x53,0x55};const scope1_sz=\-scope1_start
-	const stackinitpush=2*dwsz
-	#mov e(r)bp e(r)sp
-	const scope2_start=\;char scope2={moveatregthemodrm,0xec};const scope2_sz=\-scope2_start
-	#mov e(r)bx e(r)sp
-	const scope3_start=\;char scope3={moveatregthemodrm,0xdc};const scope3_sz=\-scope3_start
-	#sub e(r)bx dword
-	const scope4_start=\;char scope4={0x81,0xeb}
-	data *scopestack=0;const scope4_sz=\-scope4_start
-
-	setcall err addtosec(#scope1,(scope1_sz),container);if err!=(noerror);return err;endif
-	setcall err rex_w_if64();if err!=(noerror);return err;endif
-	setcall err addtosec(#scope2,(scope2_sz),container);if err!=(noerror);return err;endif
-	setcall err rex_w_if64();if err!=(noerror);return err;endif
-	setcall err addtosec(#scope3,(scope3_sz),container);if err!=(noerror);return err;endif
-	setcall err rex_w_if64();if err!=(noerror);return err;endif
-	setcall err addtosec(#scope4,(scope4_sz),container);if err!=(noerror);return err;endif
-	if err=(noerror)
-		data set=0;call ramp_index(set,container)
-		setcall err align_entryscope()
-	endif
-	return err
-endfunction
-
-#
-function entryscope_verify_code()
-	data ptrfnavailable%ptrfnavailable
-	data one=1
-	if ptrfnavailable#=one
-		data ptrinnerfunction%globalinnerfunction
-		if ptrinnerfunction#!=(TRUE)
-			data two=2
-			set ptrfnavailable# two
-			call entryscope()
-		endif
-	endif
-endfunction
-
-
-#er
-function addtocode_decstack(sd for_64)
-	char movtostack=moveatmemtheproc
-	char modrm#1
-	data rampindex#1
-
-	vdata stack^movtostack
-	vdata ptrcodesec%%ptr_codesec
-
-	sd err
-	if for_64=(TRUE)
-		call rex_w(#err);if err!=(noerror);return err;endif
-	endif
-
-	setcall rampindex addramp(#err)
-	#is with sub now     neg rampindex
-	if err=(noerror)
-		sd size
-		if rampindex<^0x80    #disp8 is signed
-			setcall modrm formmodrm((disp8),0,(ebxregnumber))
-			set size 3
-		else
-			setcall modrm formmodrm((disp32),0,(ebxregnumber))
-			set size 6
-		endelse
-		setcall err addtosec(stack,size,ptrcodesec)
-	endif
-	return err
-endfunction
-#er
-function addtocodeforstack(sd rightstackpointer,sd for_64)
-	#s^s
-	data noerr=noerror
-
-	sd err
-	setcall err writetake((eaxregnumber),rightstackpointer)
-	if err!=noerr
-		return err
-	endif
-
-	setcall err addtocode_decstack(for_64)
-	return err
-endfunction
-#er
-function addtocodefordata(sd value,sd for_64,sd ext)
-	char code=ateaximm
-	data val#1
-
-	sd err
-	setcall err reloc64_ante();If err!=(noerror);Return err;EndIf
-	data ptrcodesec%%ptr_codesec
-	set val value
-	setcall err addtosec(#code,5,ptrcodesec);If err!=(noerror);Return err;EndIf
-	setcall err reloc64_post_base_extension(ptrcodesec,ext);If err!=(noerror);Return err;EndIf
-
-	setcall err addtocode_decstack(for_64)
-	return err
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/stack/stack_inits.oc
@@ -0,0 +1,65 @@
+
+
+
+#mask bit
+function data_get_maskbit(sd pointer,sd bit)
+	add pointer (maskoffset)
+	and bit pointer#
+	return bit
+endfunction
+function importbit(sd pointer)
+	sd bit
+	setcall bit data_get_maskbit(pointer,(idatabitfunction))
+	return bit
+endfunction
+function stackbit(sd pointer)
+	sd bit
+	setcall bit data_get_maskbit(pointer,(stackbit))
+	return bit
+endfunction
+function stackrelativebit(sd pointer)
+	sd bit
+	setcall bit data_get_maskbit(pointer,(stackrelativebit))
+	return bit
+endfunction
+function datapointbit(sd pointer)
+	sd bit
+	setcall bit data_get_maskbit(pointer,(datapointbit))
+	return bit
+endfunction
+function expandbit(sd pointer)
+	sd bit
+	setcall bit data_get_maskbit(pointer,(expandbit))
+	return bit
+endfunction
+function expandbit_wrap(sd pointer)
+	vdata ptr_nobits_virtual%ptr_nobits_virtual
+	if ptr_nobits_virtual#=(Yes)
+		sd bit
+		setcall bit data_get_maskbit(pointer,(expandbit))
+		return bit
+	endif
+	return 0
+endfunction
+function pointbit(sd pointer)
+	sd bit
+	setcall bit data_get_maskbit(pointer,(pointbit))
+	return bit
+endfunction
+function suffixbit(sd pointer)
+	sd bit
+	setcall bit data_get_maskbit(pointer,(suffixbit))
+	return bit
+endfunction
+
+function stack_get_relative(sd location)
+	sd mask
+	set mask location
+	add mask (maskoffset)
+	set mask mask#
+	and mask (stackrelativebit)
+	if mask=0
+		return (ebxregnumber)
+	endif
+	return (ebpregnumber)
+endfunction
--- ocompiler-1.orig/src/files/functions/stack/stack_inits.s
+++ /dev/null
@@ -1,65 +0,0 @@
-
-
-
-#mask bit
-function data_get_maskbit(sd pointer,sd bit)
-	add pointer (maskoffset)
-	and bit pointer#
-	return bit
-endfunction
-function importbit(sd pointer)
-	sd bit
-	setcall bit data_get_maskbit(pointer,(idatabitfunction))
-	return bit
-endfunction
-function stackbit(sd pointer)
-	sd bit
-	setcall bit data_get_maskbit(pointer,(stackbit))
-	return bit
-endfunction
-function stackrelativebit(sd pointer)
-	sd bit
-	setcall bit data_get_maskbit(pointer,(stackrelativebit))
-	return bit
-endfunction
-function datapointbit(sd pointer)
-	sd bit
-	setcall bit data_get_maskbit(pointer,(datapointbit))
-	return bit
-endfunction
-function expandbit(sd pointer)
-	sd bit
-	setcall bit data_get_maskbit(pointer,(expandbit))
-	return bit
-endfunction
-function expandbit_wrap(sd pointer)
-	vdata ptr_nobits_virtual%ptr_nobits_virtual
-	if ptr_nobits_virtual#=(Yes)
-		sd bit
-		setcall bit data_get_maskbit(pointer,(expandbit))
-		return bit
-	endif
-	return 0
-endfunction
-function pointbit(sd pointer)
-	sd bit
-	setcall bit data_get_maskbit(pointer,(pointbit))
-	return bit
-endfunction
-function suffixbit(sd pointer)
-	sd bit
-	setcall bit data_get_maskbit(pointer,(suffixbit))
-	return bit
-endfunction
-
-function stack_get_relative(sd location)
-	sd mask
-	set mask location
-	add mask (maskoffset)
-	set mask mask#
-	and mask (stackrelativebit)
-	if mask=0
-		return (ebxregnumber)
-	endif
-	return (ebpregnumber)
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/values/numbersandconstants.oc
@@ -0,0 +1,479 @@
+
+
+#bool numeric
+Function is_numeric(char c)
+	Char zero={asciizero}
+	Char nine={asciinine}
+	Data false=FALSE
+	Data true=TRUE
+	If c<zero
+		Return false
+	ElseIf c>nine
+		Return false
+	EndElseIf
+	Return true
+EndFunction
+
+#bool
+Function memtoint(str content,data size,data outvalue,data minusbool)
+	#if size==0 not required in the program, it already comes at least 1
+
+	Data value#1
+	Data number#1
+
+	data multx#1
+	Set value 0
+	set multx 1
+
+	Add content size
+	While size!=0
+		Data bool#1
+		Char byte#1
+
+		Dec content
+		Set byte content#
+		SetCall bool is_numeric(byte)
+		If bool=(FALSE)
+			Return (FALSE)
+		EndIf
+		Sub byte (asciizero)
+		Set number byte
+
+		const bil_1=1000*1000*1000
+		const bil_2=2*bil_1
+		const max_int=0x80<<8<<8<<8
+		const max_int_bil_2_rest=max_int-bil_2   #147 483 648
+		if multx=(bil_1)
+			if size!=1    #0 is not
+				return (FALSE)
+			elseif number=2
+				if value=(max_int_bil_2_rest)
+					if minusbool=(FALSE)
+						#2 147 483 648 is the first positive overflow
+						return (FALSE)
+					endif
+				elseif value>(max_int_bil_2_rest)
+					#2 147 483 649-2 999 999 999
+					return (FALSE)
+				endelseif
+			elseif number>2
+				#3 xxx xxx xxx-9 xxx xxx xxx
+				return (FALSE)
+			endelseif
+		endif
+
+		mult number multx
+		Add value number
+		mult multx 10
+		Dec size
+	EndWhile
+	Set outvalue# value
+	Return (TRUE)
+EndFunction
+
+const nothex_value=-1
+
+#out -1 or the converted number
+Function hexnr(char byte)
+	Char Asciizero={asciizero}
+	Char Asciinine={asciinine}
+	Char AsciiA={asciiA}
+	Char AsciiF={asciiF}
+	Char Asciia={asciia}
+	Char Asciif={asciif}
+	Char afternine={10}
+	If byte<Asciizero
+		Return (nothex_value)
+	ElseIf byte<=Asciinine
+		Sub byte Asciizero
+	ElseIf byte<AsciiA
+		Return (nothex_value)
+	ElseIf byte<=AsciiF
+		Sub byte AsciiA
+		Add byte afternine
+	ElseIf byte<Asciia
+		Return (nothex_value)
+	ElseIf byte<=Asciif
+		Sub byte Asciia
+		Add byte afternine
+	Else
+		Return (nothex_value)
+	EndElse
+	Return byte
+EndFunction
+
+#bool
+Function memtohex(vstr content,data size,data outvalue)
+	Data bool#1
+	vStr pc^content
+	Data ps^size
+
+	SetCall bool stratmem(pc,ps,"0X")
+	If bool=(TRUE)
+		Data val#1
+		Set val 0
+		if size!=0
+			While content#=(asciizero)
+				inc content
+				dec size
+				if size=0
+					break  #no return. set outval is required
+				endif
+			endwhile
+			if size>8  #signed compare? not using alloc on sign bit (see at addtosec)
+				return (FALSE)
+			endif
+			Char byte#1
+			Data nr#1
+			Data multp#1
+
+			Set multp 1
+			Add content size
+			While size!=0
+				Dec content
+				Dec size
+				Set byte content#
+				SetCall nr hexnr(byte)
+				If nr=(nothex_value)
+					Return (FALSE)
+				EndIf
+				Mult nr multp
+				Add val nr
+				Data hextimes=16
+				Mult multp hextimes
+			EndWhile
+		endif
+		Set outvalue# val
+		Return (TRUE)
+	EndIf
+	return (FALSE)
+EndFunction
+
+#bool
+function memtooct(ss content,sd size,sd outvalue)
+	if content#=(asciizero)
+		while content#=(asciizero)
+			inc content
+			dec size
+			if size=0
+				break  #no return. set outval is required
+			endif
+		endwhile
+		#32/3=10+2/3 10 digits on 30 bits and 1 or 3 on the last 2 bits
+		if size=11
+			if content#!=(asciione)
+				if content#!=(asciithree)
+					return (FALSE)
+				endif
+			endif
+		elseif size>11   #same signed compare
+			return (FALSE)
+		endelseif
+		sd val=0
+		sd mult=1
+		add content size
+		while size!=0
+			dec content
+			sd b;set b content#
+			if b<=(asciieight)
+				if b>=(asciizero)
+					sub b (asciizero)
+					mult b mult
+					add val b
+					mult mult 8
+					dec size
+					continue
+				endif
+			endif
+			return (FALSE)
+		endwhile
+		Set outvalue# val
+		return (TRUE)
+	endif
+	return (FALSE)
+endfunction
+
+const calculationmark=asciibs
+#error
+function numbertoint(vstrx content,datax size,datax outval,datax minusbool)
+	Data bool#1
+	#test to see if the calculationmark sign is present
+	if content#=(calculationmark)
+		sd err
+
+		if size=1
+			#the current data cursor
+			setcall outval# get_img_vdata_dataReg()
+
+			setcall err xfile_add_char_ifif((Xfile_numbers_type_idata))
+			return err
+		endif
+
+		vdata p_parses%ptr_parses
+		inc content
+		charx against#1
+		set against content#
+		if against=(calculationmark)
+			if size=2
+				#the current virtual data cursor
+				#main.ptr_nobits_virtual not yet at ocompiler, we have WinMain/main or (NULL)
+				vdata ptr_nobits_virtual%ptr_nobits_virtual
+				if ptr_nobits_virtual#=(No)
+					if p_parses#=(pass_init)
+						return "At the moment, \\\\ is not implemented here."
+					endif
+				endif
+				setcall outval# get_img_vdata_dataSize()
+
+				setcall err xfile_add_char_ifif((Xfile_numbers_type_idatax))
+				return err
+			endif
+			inc content
+			sub size 2
+
+			if p_parses#=(pass_init)
+				return "At the moment, \\\\func is not implemented here."  #after pass_init is the calloc for scopes
+			endif
+			setcall err xfile_add_char_if((Xfile_numbers_type_fsizeX))  #next in get_scope_pos
+			if err=(noerror)
+				setcall err get_sizeoffunction(content,size,outval,(TRUE))
+			endif
+			return err
+		endif
+
+		dec size
+		sd dot_offset;setcall dot_offset valinmem(content,size,(asciidot))
+		if dot_offset!=size
+			if p_parses#=(pass_init)
+				return "At the moment, \\a.b or \\a.b\\ are not implemented here."  #after pass_init is the calloc for scopes
+			endif
+			#suffixed,casted, nobody is stopping them (casted will not reach here, will be xor)
+			#	and suffix+0 at def, else is a comment;at code is ok
+			ss pointer=-1;add pointer content;add pointer size
+			datax data#1;datax low#1;datax sufix#1
+			if pointer#!=(calculationmark)
+				#size of variable
+				setcall err xfile_add_char_if((Xfile_numbers_type_vsizeVar))
+				if err=(noerror)
+					setcall err getarg_dot_any(content,size,dot_offset,#data,#low,#sufix)
+					if err=(noerror)
+						if low!=0
+							set outval# (bsz)
+						else
+							set outval# (dwsz)
+							sd test;setcall test stackbit(data)
+							if test=0
+								if sufix=(sufix_false)
+									setcall test datapointbit(data)
+									if test!=0
+										set outval# (qwsz)
+									endif
+								else
+									setcall test pointbit(data) #it has 64 check
+									if test!=0
+										set outval# (qwsz)
+									endif
+								endelse
+							else
+								if sufix=(sufix_false)
+									setcall outval# stack64_enlarge(outval#)
+								else
+									setcall test pointbit(data) #it has 64 check
+									if test!=0
+										set outval# (qwsz)
+									endif
+								endelse
+							endelse
+						endelse
+
+						if sufix=(sufix_false)
+							add data (maskoffset_reserve)
+							sd shortvalue;setcall shortvalue s_to_i(data)
+							if shortvalue=0
+								return "Great reserve size is not implemented yet."
+							endif
+							mult outval# shortvalue
+						endif
+					endif
+				endif
+			else
+				# [calculation]a.b[calculation] offset
+				dec size
+
+				setcall err xfile_add_char_if((Xfile_numbers_type_voffsetVar))  #next in get_scope_pos
+				if err=(noerror)
+					setcall err getarg_base(content,size,dot_offset,#data,#low,#sufix,outval)
+					if err=(noerror)
+						if sufix!=(sufix_false)
+							return "Not using offset of suffix."
+						endif
+						sub outval# data#
+						neg outval#
+					endif
+				endif
+			endelse
+		else
+			if p_parses#=(pass_init)
+				return "At the moment, \\func is not implemented here."  #after pass_init is the calloc for scopes
+			endif
+			setcall err xfile_add_char_if((Xfile_numbers_type_fsize))  #next in get_scope_pos
+			if err=(noerror)
+				setcall err get_sizeoffunction(content,size,outval,(FALSE))
+			endif
+		endelse
+		return err
+	#test for : sign (the size of a stack value, 4B on 32-bits, 8B on 64-bits)
+	char int_size=asciicolon
+	elseif content#=int_size
+		if size!=1;return "The text after the size of an integer sign isn't recognized.";endif
+		sd b;setcall b is_for_64()
+		if b=(FALSE);set outval# (dwsz)
+		else;set outval# (qwsz);endelse
+
+		setcall err xfile_add_char_ifif((Xfile_numbers_type_ilong))
+		return err
+	endelseif
+	#0X ?
+	SetCall bool memtohex(content,size,outval)
+	If bool=(TRUE)
+		setcall err xfile_add_base_ifif((Xfile_numbers_type_thex),content,size)
+		return err
+	endif
+	#0 ?
+	SetCall bool memtooct(content,size,outval)
+	If bool=(TRUE)
+		setcall err xfile_add_base_ifif((Xfile_numbers_type_toct),content,size)
+		return err
+	endif
+	#decimal number
+	SetCall bool memtoint(content,size,outval,minusbool)
+	If bool=(TRUE)
+		setcall err xfile_add_base_ifif((Xfile_numbers_type_tdecimal),content,size)
+		return err
+	endif
+	Char _intvalerr="Integer(dec/oct/hex) value not recognized."
+	vStr intvallerr^_intvalerr
+	Return intvallerr
+endfunction
+
+#size of function
+function get_sizeoffunction(sd content,sd size,sd outval,sd is_expand)
+	sd err
+	sd pos
+	setcall err get_scope_pos(content,size,#pos)
+	if err=(noerror)
+		setcall outval# get_scope_data_size(pos,is_expand)
+	endif
+	return err
+endfunction
+
+#err pointer
+Function numbersconstants(str content,data size,data outval)
+	Str intconsterr="Integer(dec/hex) or constant value expected."
+	If size=0
+		Return intconsterr
+	EndIf
+
+	sd xprefixes=Xfile_numbers_prefix_none
+
+	char not=not_number
+	sd notbool=FALSE
+	if content#=not
+		set notbool (TRUE)
+		inc content
+		dec size
+		If size=0
+			Return intconsterr
+		EndIf
+		or xprefixes (Xfile_numbers_prefix_not)
+	endif
+	sd minusbool=FALSE
+	if content#=(asciiminus)
+		set minusbool (TRUE)
+		inc content
+		dec size
+		If size=0
+			Return intconsterr
+		EndIf
+		or xprefixes (Xfile_numbers_prefix_neg)
+	endif
+
+	sd err
+	setcall err xfile_add_char_ifif(xprefixes)
+	if err=(noerror)
+		sd bool
+		setcall bool is_variable_char_not_numeric(content#)
+		If bool=(FALSE)
+			setcall err numbertoint(content,size,outval,minusbool)
+		Else
+			Data constr%%ptr_constants
+			Data pointer#1
+			SetCall pointer vars(content,size,constr)
+			If pointer=0
+				Char unconst="Undefined constant name."
+				Str ptruncost^unconst
+				Return ptruncost
+			EndIf
+			Set outval# pointer#
+
+			setcall err xfile_add_base_ifif((Xfile_numbers_type_tconstant),content,size)
+		EndElse
+		if err=(noerror)
+			if notbool=(TRUE)
+				not outval#
+			endif
+			if minusbool=(TRUE)
+				mult outval# -1
+			endif
+		endif
+	endif
+	return err
+EndFunction
+
+#er
+function parenthesis_size(ss content,sd size,sd ptr_sz)
+	sd opens=1
+	data z=0
+	sd mark
+	data noerr=noerror
+	sd last
+	Char closefnexp="Close parenthesis sign (')') expected."
+	Str closeerr^closefnexp
+
+	set mark content
+	set last content
+	add last size
+	while content!=last
+		if content#=(asciidoublequote)
+			sd er
+			setcall er quotes_forward(#content,last,0)
+			if er!=(noerror)
+				return er
+			endif
+		endif
+		if content=last
+			return closeerr
+		endif
+		Char fnbegin=asciiparenthesisstart
+		Char fnend=asciiparenthesisend
+		if content#=fnend
+			dec opens
+			if opens=z
+				sub content mark
+				set ptr_sz# content
+				return noerr
+			endif
+		elseif content#=fnbegin
+			inc opens
+		endelseif
+		inc content
+	endwhile
+	Return closeerr
+endfunction
+
+#len
+function dwtomem(sd dw,ss mem)
+	sd len
+	setcall len sprintf(mem,"%u",dw)
+	return len
+endfunction
--- ocompiler-1.orig/src/files/functions/values/numbersandconstants.s
+++ /dev/null
@@ -1,479 +0,0 @@
-
-
-#bool numeric
-Function is_numeric(char c)
-	Char zero={asciizero}
-	Char nine={asciinine}
-	Data false=FALSE
-	Data true=TRUE
-	If c<zero
-		Return false
-	ElseIf c>nine
-		Return false
-	EndElseIf
-	Return true
-EndFunction
-
-#bool
-Function memtoint(str content,data size,data outvalue,data minusbool)
-	#if size==0 not required in the program, it already comes at least 1
-
-	Data value#1
-	Data number#1
-
-	data multx#1
-	Set value 0
-	set multx 1
-
-	Add content size
-	While size!=0
-		Data bool#1
-		Char byte#1
-
-		Dec content
-		Set byte content#
-		SetCall bool is_numeric(byte)
-		If bool=(FALSE)
-			Return (FALSE)
-		EndIf
-		Sub byte (asciizero)
-		Set number byte
-
-		const bil_1=1000*1000*1000
-		const bil_2=2*bil_1
-		const max_int=0x80<<8<<8<<8
-		const max_int_bil_2_rest=max_int-bil_2   #147 483 648
-		if multx=(bil_1)
-			if size!=1    #0 is not
-				return (FALSE)
-			elseif number=2
-				if value=(max_int_bil_2_rest)
-					if minusbool=(FALSE)
-						#2 147 483 648 is the first positive overflow
-						return (FALSE)
-					endif
-				elseif value>(max_int_bil_2_rest)
-					#2 147 483 649-2 999 999 999
-					return (FALSE)
-				endelseif
-			elseif number>2
-				#3 xxx xxx xxx-9 xxx xxx xxx
-				return (FALSE)
-			endelseif
-		endif
-
-		mult number multx
-		Add value number
-		mult multx 10
-		Dec size
-	EndWhile
-	Set outvalue# value
-	Return (TRUE)
-EndFunction
-
-const nothex_value=-1
-
-#out -1 or the converted number
-Function hexnr(char byte)
-	Char Asciizero={asciizero}
-	Char Asciinine={asciinine}
-	Char AsciiA={asciiA}
-	Char AsciiF={asciiF}
-	Char Asciia={asciia}
-	Char Asciif={asciif}
-	Char afternine={10}
-	If byte<Asciizero
-		Return (nothex_value)
-	ElseIf byte<=Asciinine
-		Sub byte Asciizero
-	ElseIf byte<AsciiA
-		Return (nothex_value)
-	ElseIf byte<=AsciiF
-		Sub byte AsciiA
-		Add byte afternine
-	ElseIf byte<Asciia
-		Return (nothex_value)
-	ElseIf byte<=Asciif
-		Sub byte Asciia
-		Add byte afternine
-	Else
-		Return (nothex_value)
-	EndElse
-	Return byte
-EndFunction
-
-#bool
-Function memtohex(vstr content,data size,data outvalue)
-	Data bool#1
-	vStr pc^content
-	Data ps^size
-
-	SetCall bool stratmem(pc,ps,"0X")
-	If bool=(TRUE)
-		Data val#1
-		Set val 0
-		if size!=0
-			While content#=(asciizero)
-				inc content
-				dec size
-				if size=0
-					break  #no return. set outval is required
-				endif
-			endwhile
-			if size>8  #signed compare? not using alloc on sign bit (see at addtosec)
-				return (FALSE)
-			endif
-			Char byte#1
-			Data nr#1
-			Data multp#1
-
-			Set multp 1
-			Add content size
-			While size!=0
-				Dec content
-				Dec size
-				Set byte content#
-				SetCall nr hexnr(byte)
-				If nr=(nothex_value)
-					Return (FALSE)
-				EndIf
-				Mult nr multp
-				Add val nr
-				Data hextimes=16
-				Mult multp hextimes
-			EndWhile
-		endif
-		Set outvalue# val
-		Return (TRUE)
-	EndIf
-	return (FALSE)
-EndFunction
-
-#bool
-function memtooct(ss content,sd size,sd outvalue)
-	if content#=(asciizero)
-		while content#=(asciizero)
-			inc content
-			dec size
-			if size=0
-				break  #no return. set outval is required
-			endif
-		endwhile
-		#32/3=10+2/3 10 digits on 30 bits and 1 or 3 on the last 2 bits
-		if size=11
-			if content#!=(asciione)
-				if content#!=(asciithree)
-					return (FALSE)
-				endif
-			endif
-		elseif size>11   #same signed compare
-			return (FALSE)
-		endelseif
-		sd val=0
-		sd mult=1
-		add content size
-		while size!=0
-			dec content
-			sd b;set b content#
-			if b<=(asciieight)
-				if b>=(asciizero)
-					sub b (asciizero)
-					mult b mult
-					add val b
-					mult mult 8
-					dec size
-					continue
-				endif
-			endif
-			return (FALSE)
-		endwhile
-		Set outvalue# val
-		return (TRUE)
-	endif
-	return (FALSE)
-endfunction
-
-const calculationmark=asciibs
-#error
-function numbertoint(vstrx content,datax size,datax outval,datax minusbool)
-	Data bool#1
-	#test to see if the calculationmark sign is present
-	if content#=(calculationmark)
-		sd err
-
-		if size=1
-			#the current data cursor
-			setcall outval# get_img_vdata_dataReg()
-
-			setcall err xfile_add_char_ifif((Xfile_numbers_type_idata))
-			return err
-		endif
-
-		vdata p_parses%ptr_parses
-		inc content
-		charx against#1
-		set against content#
-		if against=(calculationmark)
-			if size=2
-				#the current virtual data cursor
-				#main.ptr_nobits_virtual not yet at ocompiler, we have WinMain/main or (NULL)
-				vdata ptr_nobits_virtual%ptr_nobits_virtual
-				if ptr_nobits_virtual#=(No)
-					if p_parses#=(pass_init)
-						return "At the moment, \\\\ is not implemented here."
-					endif
-				endif
-				setcall outval# get_img_vdata_dataSize()
-
-				setcall err xfile_add_char_ifif((Xfile_numbers_type_idatax))
-				return err
-			endif
-			inc content
-			sub size 2
-
-			if p_parses#=(pass_init)
-				return "At the moment, \\\\func is not implemented here."  #after pass_init is the calloc for scopes
-			endif
-			setcall err xfile_add_char_if((Xfile_numbers_type_fsizeX))  #next in get_scope_pos
-			if err=(noerror)
-				setcall err get_sizeoffunction(content,size,outval,(TRUE))
-			endif
-			return err
-		endif
-
-		dec size
-		sd dot_offset;setcall dot_offset valinmem(content,size,(asciidot))
-		if dot_offset!=size
-			if p_parses#=(pass_init)
-				return "At the moment, \\a.b or \\a.b\\ are not implemented here."  #after pass_init is the calloc for scopes
-			endif
-			#suffixed,casted, nobody is stopping them (casted will not reach here, will be xor)
-			#	and suffix+0 at def, else is a comment;at code is ok
-			ss pointer=-1;add pointer content;add pointer size
-			datax data#1;datax low#1;datax sufix#1
-			if pointer#!=(calculationmark)
-				#size of variable
-				setcall err xfile_add_char_if((Xfile_numbers_type_vsizeVar))
-				if err=(noerror)
-					setcall err getarg_dot_any(content,size,dot_offset,#data,#low,#sufix)
-					if err=(noerror)
-						if low!=0
-							set outval# (bsz)
-						else
-							set outval# (dwsz)
-							sd test;setcall test stackbit(data)
-							if test=0
-								if sufix=(sufix_false)
-									setcall test datapointbit(data)
-									if test!=0
-										set outval# (qwsz)
-									endif
-								else
-									setcall test pointbit(data) #it has 64 check
-									if test!=0
-										set outval# (qwsz)
-									endif
-								endelse
-							else
-								if sufix=(sufix_false)
-									setcall outval# stack64_enlarge(outval#)
-								else
-									setcall test pointbit(data) #it has 64 check
-									if test!=0
-										set outval# (qwsz)
-									endif
-								endelse
-							endelse
-						endelse
-
-						if sufix=(sufix_false)
-							add data (maskoffset_reserve)
-							sd shortvalue;setcall shortvalue s_to_i(data)
-							if shortvalue=0
-								return "Great reserve size is not implemented yet."
-							endif
-							mult outval# shortvalue
-						endif
-					endif
-				endif
-			else
-				# [calculation]a.b[calculation] offset
-				dec size
-
-				setcall err xfile_add_char_if((Xfile_numbers_type_voffsetVar))  #next in get_scope_pos
-				if err=(noerror)
-					setcall err getarg_base(content,size,dot_offset,#data,#low,#sufix,outval)
-					if err=(noerror)
-						if sufix!=(sufix_false)
-							return "Not using offset of suffix."
-						endif
-						sub outval# data#
-						neg outval#
-					endif
-				endif
-			endelse
-		else
-			if p_parses#=(pass_init)
-				return "At the moment, \\func is not implemented here."  #after pass_init is the calloc for scopes
-			endif
-			setcall err xfile_add_char_if((Xfile_numbers_type_fsize))  #next in get_scope_pos
-			if err=(noerror)
-				setcall err get_sizeoffunction(content,size,outval,(FALSE))
-			endif
-		endelse
-		return err
-	#test for : sign (the size of a stack value, 4B on 32-bits, 8B on 64-bits)
-	char int_size=asciicolon
-	elseif content#=int_size
-		if size!=1;return "The text after the size of an integer sign isn't recognized.";endif
-		sd b;setcall b is_for_64()
-		if b=(FALSE);set outval# (dwsz)
-		else;set outval# (qwsz);endelse
-
-		setcall err xfile_add_char_ifif((Xfile_numbers_type_ilong))
-		return err
-	endelseif
-	#0X ?
-	SetCall bool memtohex(content,size,outval)
-	If bool=(TRUE)
-		setcall err xfile_add_base_ifif((Xfile_numbers_type_thex),content,size)
-		return err
-	endif
-	#0 ?
-	SetCall bool memtooct(content,size,outval)
-	If bool=(TRUE)
-		setcall err xfile_add_base_ifif((Xfile_numbers_type_toct),content,size)
-		return err
-	endif
-	#decimal number
-	SetCall bool memtoint(content,size,outval,minusbool)
-	If bool=(TRUE)
-		setcall err xfile_add_base_ifif((Xfile_numbers_type_tdecimal),content,size)
-		return err
-	endif
-	Char _intvalerr="Integer(dec/oct/hex) value not recognized."
-	vStr intvallerr^_intvalerr
-	Return intvallerr
-endfunction
-
-#size of function
-function get_sizeoffunction(sd content,sd size,sd outval,sd is_expand)
-	sd err
-	sd pos
-	setcall err get_scope_pos(content,size,#pos)
-	if err=(noerror)
-		setcall outval# get_scope_data_size(pos,is_expand)
-	endif
-	return err
-endfunction
-
-#err pointer
-Function numbersconstants(str content,data size,data outval)
-	Str intconsterr="Integer(dec/hex) or constant value expected."
-	If size=0
-		Return intconsterr
-	EndIf
-
-	sd xprefixes=Xfile_numbers_prefix_none
-
-	char not=not_number
-	sd notbool=FALSE
-	if content#=not
-		set notbool (TRUE)
-		inc content
-		dec size
-		If size=0
-			Return intconsterr
-		EndIf
-		or xprefixes (Xfile_numbers_prefix_not)
-	endif
-	sd minusbool=FALSE
-	if content#=(asciiminus)
-		set minusbool (TRUE)
-		inc content
-		dec size
-		If size=0
-			Return intconsterr
-		EndIf
-		or xprefixes (Xfile_numbers_prefix_neg)
-	endif
-
-	sd err
-	setcall err xfile_add_char_ifif(xprefixes)
-	if err=(noerror)
-		sd bool
-		setcall bool is_variable_char_not_numeric(content#)
-		If bool=(FALSE)
-			setcall err numbertoint(content,size,outval,minusbool)
-		Else
-			Data constr%%ptr_constants
-			Data pointer#1
-			SetCall pointer vars(content,size,constr)
-			If pointer=0
-				Char unconst="Undefined constant name."
-				Str ptruncost^unconst
-				Return ptruncost
-			EndIf
-			Set outval# pointer#
-
-			setcall err xfile_add_base_ifif((Xfile_numbers_type_tconstant),content,size)
-		EndElse
-		if err=(noerror)
-			if notbool=(TRUE)
-				not outval#
-			endif
-			if minusbool=(TRUE)
-				mult outval# -1
-			endif
-		endif
-	endif
-	return err
-EndFunction
-
-#er
-function parenthesis_size(ss content,sd size,sd ptr_sz)
-	sd opens=1
-	data z=0
-	sd mark
-	data noerr=noerror
-	sd last
-	Char closefnexp="Close parenthesis sign (')') expected."
-	Str closeerr^closefnexp
-
-	set mark content
-	set last content
-	add last size
-	while content!=last
-		if content#=(asciidoublequote)
-			sd er
-			setcall er quotes_forward(#content,last,0)
-			if er!=(noerror)
-				return er
-			endif
-		endif
-		if content=last
-			return closeerr
-		endif
-		Char fnbegin=asciiparenthesisstart
-		Char fnend=asciiparenthesisend
-		if content#=fnend
-			dec opens
-			if opens=z
-				sub content mark
-				set ptr_sz# content
-				return noerr
-			endif
-		elseif content#=fnbegin
-			inc opens
-		endelseif
-		inc content
-	endwhile
-	Return closeerr
-endfunction
-
-#len
-function dwtomem(sd dw,ss mem)
-	sd len
-	setcall len sprintf(mem,"%u",dw)
-	return len
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/values/operations.oc
@@ -0,0 +1,589 @@
+
+
+Const unreadyNumber=0
+Const addNumber=Xfile_numbers_operation_add
+Const subNumber=Xfile_numbers_operation_sub
+Const mulNumber=Xfile_numbers_operation_mul
+Const divNumber=Xfile_numbers_operation_div
+Const divuNumber=Xfile_numbers_operation_divu
+Const andNumber=Xfile_numbers_operation_and
+Const orNumber=Xfile_numbers_operation_or
+Const xorNumber=Xfile_numbers_operation_xor
+Const powNumber=Xfile_numbers_operation_pow
+Const remNumber=Xfile_numbers_operation_rem
+Const remuNumber=Xfile_numbers_operation_remu
+Const shlNumber=Xfile_numbers_operation_shl
+Const sarNumber=Xfile_numbers_operation_sar
+Const shrNumber=Xfile_numbers_operation_shr
+Const equalNumber=Xfile_numbers_operation_equal
+Const inequalNumber=Xfile_numbers_operation_inequal
+Const lessNumber=Xfile_numbers_operation_less
+Const greaterNumber=Xfile_numbers_operation_greater
+Const lessequalNumber=Xfile_numbers_operation_lessequal
+Const greaterequalNumber=Xfile_numbers_operation_greaterequal
+Const andlogicalNumber=Xfile_numbers_operation_logicaland
+Const orlogicalNumber=Xfile_numbers_operation_logicalor
+Const unsignedlessNumber=Xfile_numbers_operation_unsignedless
+Const unsignedgreaterNumber=Xfile_numbers_operation_unsignedgreater
+Const unsignedlessequalNumber=Xfile_numbers_operation_unsignedlessequal
+Const unsignedgreaterequalNumber=Xfile_numbers_operation_unsignedgreaterequal
+Const parityNumber=Xfile_numbers_operation_parity
+Const oddNumber=Xfile_numbers_operation_odd
+#asciiminus and asciinot for one arg
+
+#err
+function const_security()
+	sd p%p_over_pref
+	if p#=(TRUE)
+		vstr err="Overflow at constants."
+		call Message(err)
+		sd w%p_w_as_e
+		if w#=(TRUE)
+			return err
+		endif
+	endif
+	return (noerror)
+endfunction
+#err
+function const_security_ex(sd p_once)
+	if p_once#=0
+		sd err;setcall err const_security()
+		set p_once# 1
+	endif
+	return (noerror)
+endfunction
+#err
+function shift_right(sd a,sd n)
+	#at 64? 1 shl 63 is last one
+	if n>^31
+		if a<0
+			set a# -1
+		else
+			set a# 0   #here is clear that 30 is maximum but will be hardcoded
+		endelse
+	else
+		while n>0
+			sar1 a#
+			dec n
+		endwhile
+	endelse
+endfunction
+#err
+function shift_uright(sd a,sd n)
+	if n>^31
+		set a# 0
+	else
+		while n>0
+			shr1 a#
+			dec n
+		endwhile
+	endelse
+endfunction
+#err
+function shift_left(sd a,sd n)
+	if a#!=0 #a can be 0 and how_was can't catch there
+		sd once=0
+		while n>^0
+			sd how_was;set how_was a#
+			shl1 a#
+			if a#<^how_was
+				sd err
+				setcall err const_security_ex(#once)
+				If err!=(noerror);return err;endif
+			endif
+			dec n
+		endwhile
+	endif
+	return (noerror)
+endfunction
+
+#err pointer
+Function operation(sv ptrcontent,sd size,sd inoutvalue,sd number)
+	ss content
+	set content ptrcontent#
+	sd newitem
+	sd ptrnewitem^newitem
+	sd errptr
+	Data noerr=noerror
+
+	if content#!=(asciiparenthesisstart)
+		#not needing set newitem 0
+		SetCall errptr numbersconstants(content,size,ptrnewitem)
+	else
+		inc content;sub size 2
+		setcall errptr xfile_add_char_ifif((Xfile_numbers_parenthesis_open))
+		if errptr=(noerror)
+			setcall errptr parseoperations_base(#content,#size,size,ptrnewitem,(FALSE),(Xfile_numbers_parenthesis_close))
+		endif
+	endelse
+	If errptr!=noerr
+		set ptrcontent# content
+		Return errptr
+	EndIf
+
+	setcall errptr operation_core(inoutvalue,number,newitem)
+	return errptr
+EndFunction
+
+#err
+function operation_core(sd inoutvalue,sd number,sd newitem)
+	sd errptr
+	sd currentitem
+	sd how_was
+	sd how_is
+	Set currentitem inoutvalue#
+	If number=(addNumber)
+		set how_was currentitem
+		Add currentitem newitem
+		if currentitem<^how_was
+			setcall errptr const_security()
+			if errptr!=(noerror);return errptr;endif
+		endif
+	ElseIf number=(subNumber)
+		Sub currentitem newitem
+	ElseIf number=(mulNumber)
+		set how_was currentitem
+		Mult currentitem newitem
+		set how_is currentitem
+		divu how_is newitem
+		if how_was!=how_is
+			setcall errptr const_security()
+			if errptr!=(noerror);return errptr;endif
+		endif
+	ElseIf number=(divNumber)
+		If newitem=0
+			Char zerodiv="Division by 0 error."
+			vStr ptrzerodiv^zerodiv
+			Return ptrzerodiv
+		EndIf
+		Div currentitem newitem
+	ElseIf number=(divuNumber)
+		If newitem=0
+			Return ptrzerodiv
+		EndIf
+		Divu currentitem newitem
+	ElseIf number=(andNumber)
+		And currentitem newitem
+	ElseIf number=(orNumber)
+		Or currentitem newitem
+	ElseIf number=(xorNumber)
+		Xor currentitem newitem
+	ElseIf number=(powNumber)
+	#unsigned newitem/currentitem is the first step i think
+		if currentitem=1
+			#1/(1 power n) and positive, currentitem unchanged
+		elseif currentitem=0
+			if newitem=0
+				return "0 pow 0 is undefined."
+			endif
+			#if newitem<0 #	#is 1/(0 power n) #	Return ptrzerodiv #endif #currentitem unchanged
+		#elseif newitem<0 #	#is 1/(>1) #	set currentitem 0
+		elseif newitem=0
+			set currentitem 1
+		#elseif newitem=1 #currentitem unchanged
+		else
+			sd once=0
+			sd item;set item currentitem
+			while newitem!=1
+				set how_was currentitem
+				mult currentitem item
+				set how_is currentitem
+				divu how_is item
+				if how_was!=how_is
+					SetCall errptr const_security_ex(#once)
+					If errptr!=(noerror);return errptr;endif
+				endif
+				dec newitem
+			endwhile
+		endelse
+	ElseIf number=(remNumber)
+		If newitem=0
+			Return ptrzerodiv
+		EndIf
+		Rem currentitem newitem
+	ElseIf number=(remuNumber)
+		If newitem=0
+			Return ptrzerodiv
+		EndIf
+		Remu currentitem newitem
+	ElseIf number=(shlNumber)
+		SetCall errptr shift_left(#currentitem,newitem)
+		If errptr!=(noerror);return errptr;endif
+	ElseIf number=(sarNumber)
+		Call shift_right(#currentitem,newitem)
+	elseIf number=(shrNumber)
+		Call shift_uright(#currentitem,newitem)
+	ElseIf number=(equalNumber)
+		if currentitem=newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	ElseIf number=(inequalNumber)
+		if currentitem!=newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	ElseIf number=(lessNumber)
+		if currentitem<newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	ElseIf number=(greaterNumber)
+		if currentitem>newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	ElseIf number=(lessequalNumber)
+		if currentitem<=newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	ElseIf number=(greaterequalNumber)
+		if currentitem>=newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	ElseIf number=(andlogicalNumber)
+		if currentitem!=(FALSE)
+			if newitem!=(FALSE)
+				set currentitem (TRUE)  #example: is 7 will be 1
+			else
+				set currentitem (FALSE)
+			endelse
+		endif
+	ElseIf number=(orlogicalNumber)
+		if currentitem!=(FALSE)
+			set currentitem (TRUE)
+		elseif newitem!=(FALSE)
+			set currentitem (TRUE)
+		endelseif
+	ElseIf number=(unsignedlessNumber)
+		if currentitem<^newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	ElseIf number=(unsignedgreaterNumber)
+		if currentitem>^newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	ElseIf number=(unsignedlessequalNumber)
+		if currentitem<=^newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	ElseIf number=(unsignedgreaterequalNumber)
+		if currentitem>=^newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	ElseIf number=(parityNumber)
+		if currentitem!newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	Else
+	#If number=(oddNumber)
+		if currentitem!!newitem
+			set currentitem (TRUE)
+		else
+			set currentitem (FALSE)
+		endelse
+	EndElse
+
+	Set inoutvalue# currentitem
+	Return (noerror)
+endfunction
+
+#bool
+Function signop(char byte,sv outval)
+	Data false=FALSE
+	Data true=TRUE
+
+	If byte=(addNumber)
+	ElseIf byte=(subNumber)
+	ElseIf byte=(mulNumber)
+	ElseIf byte=(divNumber)
+	ElseIf byte=(andNumber)
+	ElseIf byte=(orNumber)
+	ElseIf byte=(xorNumber)
+	ElseIf byte=(powNumber)
+	ElseIf byte=(remNumber)
+	ElseIf byte=(lessNumber)
+	ElseIf byte=(greaterNumber)
+	ElseIf byte=(parityNumber)
+	ElseIf byte=(equalNumber)
+	Else
+		return false
+	EndElse
+	set outval# byte
+	Return true
+EndFunction
+
+#err
+Function oneoperation(sd ptrcontent,ss initial,ss content,sd val,sd op)
+	sd errptr
+
+	if op=(unreadyNumber)
+		set op (addNumber)
+	else
+		setcall errptr xfile_add_char_ifif(op)
+		if errptr!=(noerror);Return errptr;endif
+	endelse
+
+	sd size
+
+	Set size content
+	Sub size initial
+
+	#with cursor adjuster for errors
+	SetCall errptr operation(#initial,size,val,op)
+	If errptr!=(noerror)
+		Set ptrcontent# initial
+		Return errptr
+	EndIf
+	Return (noerror)
+EndFunction
+
+#err
+function operation_test(sv ptrcontent,sd initial,sv ptrcursor,sd end,sd ptrval,sd pnumber,sd pnr,sd pbool)
+	ss content;set content ptrcursor#
+	if initial!=content ##to ignore -n
+		ss test;set test content;dec test
+		if test#=(not_number) #to ignore ~-n
+			if initial=test ##if not this, a~-b will anyway stop at a~, but this test is logic
+				return (noerror)
+			endif
+		endif
+		sd err
+		SetCall err oneoperation(ptrcontent,initial,content,ptrval,pnumber#)
+		If err=(noerror)
+			call multisignoperation(pnr,ptrcursor,end)
+			set pnumber# pnr#
+			Set pbool# (TRUE)
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
+
+#err pointer
+Function parseoperations(sd ptrcontent,sd ptrsize,sd sz,sd outvalue,sd comments)
+	sd er;setcall er parseoperations_base(ptrcontent,ptrsize,sz,outvalue,comments,(Xfile_numbers_done))
+	return er
+EndFunction
+#err pointer
+Function parseoperations_base(sd ptrcontent,sd ptrsize,sd sz,sd outvalue,sd comments,sd xfile_numbers)
+	ss content
+	ss initial
+	sd number
+	sd val
+	sd ptrval^val
+	Data zero=0
+	sd errptr
+	Data noerr=noerror
+
+	Set content ptrcontent#
+
+	Set initial content
+	Set number (unreadyNumber)
+	Set val zero
+
+	sd bool
+	Data false=FALSE
+	Data true=TRUE
+	sd nr
+	sd pnr^nr
+	sd find
+
+	sd end;set end content;add end sz
+
+	Set bool false
+	#<end?maybe unsigned cursor
+	While content!=end
+		SetCall find signop(content#,pnr)
+		if find=true
+			setcall errptr operation_test(ptrcontent,initial,#content,end,ptrval,#number,pnr,#bool)
+			if errptr!=noerr
+				return errptr
+			endif
+		elseif content#=(asciiparenthesisstart)
+			inc content
+			sd rest_sz;set rest_sz end;sub rest_sz content
+			sd insz
+			setcall errptr parenthesis_size(content,rest_sz,#insz)
+			if errptr!=(noerror)
+				set ptrcontent# content  ##for error marker
+				return errptr
+			endif
+			add content insz
+		endelseif
+
+		Inc content
+		If bool=true
+			setcall content mem_spaces(content,end)
+			Set initial content
+			Set bool false
+		EndIf
+	EndWhile
+
+	#allow line end comment
+	if comments=(TRUE)
+		sd szz
+		set szz end;sub szz initial
+		sd size
+		setcall size find_whitespaceORcomment(initial,szz)
+		sub szz size
+		sub content szz
+	endif
+	#oneoperation is with cursor adjuster for errors
+	SetCall errptr oneoperation(ptrcontent,initial,content,ptrval,number)
+	If errptr!=noerr
+		Return errptr
+	EndIf
+	Set outvalue# val
+
+	if comments=(TRUE)
+		sub sz szz
+	endif
+	Call advancecursors(ptrcontent,ptrsize,sz)
+
+	setcall errptr xfile_add_char_ifif(xfile_numbers)
+	Return errptr
+EndFunction
+
+function multisignoperation(ss pnr,sv pcontent,sd end)
+	sd nr;set nr pnr#
+	ss content
+	if nr!=(lessNumber)
+		if nr!=(greaterNumber)
+			if nr!=(divNumber)
+				if nr!=(remNumber)
+					if nr!=(parityNumber)
+						#Why does && (AND) have higher priority over || (OR) operator?
+						#C++ does it that way because C did it that way.
+						#and is somehow like multiplication
+						#or is somehow like addition
+						if nr!=(andNumber)
+							if nr!=(orNumber)
+								ret
+							endif
+							set content pcontent#
+							inc content
+							if content!=end ##error is catched how was before
+								if content#=(orNumber)
+									set pnr# (orlogicalNumber)
+									set pcontent# content
+								endif
+							endif
+						else
+							set content pcontent#
+							inc content
+							if content!=end
+								if content#=(andNumber)
+									set pnr# (andlogicalNumber)
+									set pcontent# content
+								endif
+							endif
+						endelse
+					else
+						set content pcontent#
+						inc content
+						if content!=end
+							if content#=(equalNumber)
+								set pnr# (inequalNumber)
+								set pcontent# content
+							elseif content#=(parityNumber)
+								set pnr# (oddNumber)
+								set pcontent# content
+							endelseif
+						endif
+					endelse
+				else
+					set content pcontent#
+					inc content
+					if content!=end
+						if content#=(remNumber)
+							set pnr# (remuNumber)
+							set pcontent# content
+						endif
+					endif
+				endelse
+			else
+				set content pcontent#
+				inc content
+				if content!=end
+					if content#=(divNumber)
+						set pnr# (divuNumber)
+						set pcontent# content
+					endif
+				endif
+			endelse
+		else
+			set content pcontent#
+			inc content
+			if content!=end
+				if content#=(greaterNumber)
+					set pcontent# content
+					inc content
+					if content!=end ##else is an error and 'set pnr#' is not important
+						if content#!=(greaterNumber)
+							set pnr# (sarNumber)
+						else
+							set pnr# (shrNumber)
+							set pcontent# content
+						endelse
+					endif
+				elseif content#=(equalNumber)
+					set pcontent# content
+					inc content
+					if content!=end
+						if content#!=(castascii)
+							set pnr# (greaterequalNumber)
+						else
+							set pnr# (unsignedgreaterequalNumber)
+							set pcontent# content
+						endelse
+					endif
+				elseif content#=(castascii)
+					set pnr# (unsignedgreaterNumber)
+					set pcontent# content
+				endelseif
+			endif
+		endelse
+	else
+		set content pcontent#
+		inc content
+		if content!=end
+			if content#=(lessNumber)
+				set pnr# (shlNumber)
+				set pcontent# content
+			elseif content#=(equalNumber)
+				set pcontent# content
+				inc content
+				if content!=end
+					if content#!=(castascii)
+						set pnr# (lessequalNumber)
+					else
+						set pnr# (unsignedlessequalNumber)
+						set pcontent# content
+					endelse
+				endif
+			elseif content#=(castascii)
+				set pnr# (unsignedlessNumber)
+				set pcontent# content
+			endelseif
+		endif
+	endelse
+endfunction
--- ocompiler-1.orig/src/files/functions/values/operations.s
+++ /dev/null
@@ -1,589 +0,0 @@
-
-
-Const unreadyNumber=0
-Const addNumber=Xfile_numbers_operation_add
-Const subNumber=Xfile_numbers_operation_sub
-Const mulNumber=Xfile_numbers_operation_mul
-Const divNumber=Xfile_numbers_operation_div
-Const divuNumber=Xfile_numbers_operation_divu
-Const andNumber=Xfile_numbers_operation_and
-Const orNumber=Xfile_numbers_operation_or
-Const xorNumber=Xfile_numbers_operation_xor
-Const powNumber=Xfile_numbers_operation_pow
-Const remNumber=Xfile_numbers_operation_rem
-Const remuNumber=Xfile_numbers_operation_remu
-Const shlNumber=Xfile_numbers_operation_shl
-Const sarNumber=Xfile_numbers_operation_sar
-Const shrNumber=Xfile_numbers_operation_shr
-Const equalNumber=Xfile_numbers_operation_equal
-Const inequalNumber=Xfile_numbers_operation_inequal
-Const lessNumber=Xfile_numbers_operation_less
-Const greaterNumber=Xfile_numbers_operation_greater
-Const lessequalNumber=Xfile_numbers_operation_lessequal
-Const greaterequalNumber=Xfile_numbers_operation_greaterequal
-Const andlogicalNumber=Xfile_numbers_operation_logicaland
-Const orlogicalNumber=Xfile_numbers_operation_logicalor
-Const unsignedlessNumber=Xfile_numbers_operation_unsignedless
-Const unsignedgreaterNumber=Xfile_numbers_operation_unsignedgreater
-Const unsignedlessequalNumber=Xfile_numbers_operation_unsignedlessequal
-Const unsignedgreaterequalNumber=Xfile_numbers_operation_unsignedgreaterequal
-Const parityNumber=Xfile_numbers_operation_parity
-Const oddNumber=Xfile_numbers_operation_odd
-#asciiminus and asciinot for one arg
-
-#err
-function const_security()
-	sd p%p_over_pref
-	if p#=(TRUE)
-		vstr err="Overflow at constants."
-		call Message(err)
-		sd w%p_w_as_e
-		if w#=(TRUE)
-			return err
-		endif
-	endif
-	return (noerror)
-endfunction
-#err
-function const_security_ex(sd p_once)
-	if p_once#=0
-		sd err;setcall err const_security()
-		set p_once# 1
-	endif
-	return (noerror)
-endfunction
-#err
-function shift_right(sd a,sd n)
-	#at 64? 1 shl 63 is last one
-	if n>^31
-		if a<0
-			set a# -1
-		else
-			set a# 0   #here is clear that 30 is maximum but will be hardcoded
-		endelse
-	else
-		while n>0
-			sar1 a#
-			dec n
-		endwhile
-	endelse
-endfunction
-#err
-function shift_uright(sd a,sd n)
-	if n>^31
-		set a# 0
-	else
-		while n>0
-			shr1 a#
-			dec n
-		endwhile
-	endelse
-endfunction
-#err
-function shift_left(sd a,sd n)
-	if a#!=0 #a can be 0 and how_was can't catch there
-		sd once=0
-		while n>^0
-			sd how_was;set how_was a#
-			shl1 a#
-			if a#<^how_was
-				sd err
-				setcall err const_security_ex(#once)
-				If err!=(noerror);return err;endif
-			endif
-			dec n
-		endwhile
-	endif
-	return (noerror)
-endfunction
-
-#err pointer
-Function operation(sv ptrcontent,sd size,sd inoutvalue,sd number)
-	ss content
-	set content ptrcontent#
-	sd newitem
-	sd ptrnewitem^newitem
-	sd errptr
-	Data noerr=noerror
-
-	if content#!=(asciiparenthesisstart)
-		#not needing set newitem 0
-		SetCall errptr numbersconstants(content,size,ptrnewitem)
-	else
-		inc content;sub size 2
-		setcall errptr xfile_add_char_ifif((Xfile_numbers_parenthesis_open))
-		if errptr=(noerror)
-			setcall errptr parseoperations_base(#content,#size,size,ptrnewitem,(FALSE),(Xfile_numbers_parenthesis_close))
-		endif
-	endelse
-	If errptr!=noerr
-		set ptrcontent# content
-		Return errptr
-	EndIf
-
-	setcall errptr operation_core(inoutvalue,number,newitem)
-	return errptr
-EndFunction
-
-#err
-function operation_core(sd inoutvalue,sd number,sd newitem)
-	sd errptr
-	sd currentitem
-	sd how_was
-	sd how_is
-	Set currentitem inoutvalue#
-	If number=(addNumber)
-		set how_was currentitem
-		Add currentitem newitem
-		if currentitem<^how_was
-			setcall errptr const_security()
-			if errptr!=(noerror);return errptr;endif
-		endif
-	ElseIf number=(subNumber)
-		Sub currentitem newitem
-	ElseIf number=(mulNumber)
-		set how_was currentitem
-		Mult currentitem newitem
-		set how_is currentitem
-		divu how_is newitem
-		if how_was!=how_is
-			setcall errptr const_security()
-			if errptr!=(noerror);return errptr;endif
-		endif
-	ElseIf number=(divNumber)
-		If newitem=0
-			Char zerodiv="Division by 0 error."
-			vStr ptrzerodiv^zerodiv
-			Return ptrzerodiv
-		EndIf
-		Div currentitem newitem
-	ElseIf number=(divuNumber)
-		If newitem=0
-			Return ptrzerodiv
-		EndIf
-		Divu currentitem newitem
-	ElseIf number=(andNumber)
-		And currentitem newitem
-	ElseIf number=(orNumber)
-		Or currentitem newitem
-	ElseIf number=(xorNumber)
-		Xor currentitem newitem
-	ElseIf number=(powNumber)
-	#unsigned newitem/currentitem is the first step i think
-		if currentitem=1
-			#1/(1 power n) and positive, currentitem unchanged
-		elseif currentitem=0
-			if newitem=0
-				return "0 pow 0 is undefined."
-			endif
-			#if newitem<0 #	#is 1/(0 power n) #	Return ptrzerodiv #endif #currentitem unchanged
-		#elseif newitem<0 #	#is 1/(>1) #	set currentitem 0
-		elseif newitem=0
-			set currentitem 1
-		#elseif newitem=1 #currentitem unchanged
-		else
-			sd once=0
-			sd item;set item currentitem
-			while newitem!=1
-				set how_was currentitem
-				mult currentitem item
-				set how_is currentitem
-				divu how_is item
-				if how_was!=how_is
-					SetCall errptr const_security_ex(#once)
-					If errptr!=(noerror);return errptr;endif
-				endif
-				dec newitem
-			endwhile
-		endelse
-	ElseIf number=(remNumber)
-		If newitem=0
-			Return ptrzerodiv
-		EndIf
-		Rem currentitem newitem
-	ElseIf number=(remuNumber)
-		If newitem=0
-			Return ptrzerodiv
-		EndIf
-		Remu currentitem newitem
-	ElseIf number=(shlNumber)
-		SetCall errptr shift_left(#currentitem,newitem)
-		If errptr!=(noerror);return errptr;endif
-	ElseIf number=(sarNumber)
-		Call shift_right(#currentitem,newitem)
-	elseIf number=(shrNumber)
-		Call shift_uright(#currentitem,newitem)
-	ElseIf number=(equalNumber)
-		if currentitem=newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	ElseIf number=(inequalNumber)
-		if currentitem!=newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	ElseIf number=(lessNumber)
-		if currentitem<newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	ElseIf number=(greaterNumber)
-		if currentitem>newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	ElseIf number=(lessequalNumber)
-		if currentitem<=newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	ElseIf number=(greaterequalNumber)
-		if currentitem>=newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	ElseIf number=(andlogicalNumber)
-		if currentitem!=(FALSE)
-			if newitem!=(FALSE)
-				set currentitem (TRUE)  #example: is 7 will be 1
-			else
-				set currentitem (FALSE)
-			endelse
-		endif
-	ElseIf number=(orlogicalNumber)
-		if currentitem!=(FALSE)
-			set currentitem (TRUE)
-		elseif newitem!=(FALSE)
-			set currentitem (TRUE)
-		endelseif
-	ElseIf number=(unsignedlessNumber)
-		if currentitem<^newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	ElseIf number=(unsignedgreaterNumber)
-		if currentitem>^newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	ElseIf number=(unsignedlessequalNumber)
-		if currentitem<=^newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	ElseIf number=(unsignedgreaterequalNumber)
-		if currentitem>=^newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	ElseIf number=(parityNumber)
-		if currentitem!newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	Else
-	#If number=(oddNumber)
-		if currentitem!!newitem
-			set currentitem (TRUE)
-		else
-			set currentitem (FALSE)
-		endelse
-	EndElse
-
-	Set inoutvalue# currentitem
-	Return (noerror)
-endfunction
-
-#bool
-Function signop(char byte,sv outval)
-	Data false=FALSE
-	Data true=TRUE
-
-	If byte=(addNumber)
-	ElseIf byte=(subNumber)
-	ElseIf byte=(mulNumber)
-	ElseIf byte=(divNumber)
-	ElseIf byte=(andNumber)
-	ElseIf byte=(orNumber)
-	ElseIf byte=(xorNumber)
-	ElseIf byte=(powNumber)
-	ElseIf byte=(remNumber)
-	ElseIf byte=(lessNumber)
-	ElseIf byte=(greaterNumber)
-	ElseIf byte=(parityNumber)
-	ElseIf byte=(equalNumber)
-	Else
-		return false
-	EndElse
-	set outval# byte
-	Return true
-EndFunction
-
-#err
-Function oneoperation(sd ptrcontent,ss initial,ss content,sd val,sd op)
-	sd errptr
-
-	if op=(unreadyNumber)
-		set op (addNumber)
-	else
-		setcall errptr xfile_add_char_ifif(op)
-		if errptr!=(noerror);Return errptr;endif
-	endelse
-
-	sd size
-
-	Set size content
-	Sub size initial
-
-	#with cursor adjuster for errors
-	SetCall errptr operation(#initial,size,val,op)
-	If errptr!=(noerror)
-		Set ptrcontent# initial
-		Return errptr
-	EndIf
-	Return (noerror)
-EndFunction
-
-#err
-function operation_test(sv ptrcontent,sd initial,sv ptrcursor,sd end,sd ptrval,sd pnumber,sd pnr,sd pbool)
-	ss content;set content ptrcursor#
-	if initial!=content ##to ignore -n
-		ss test;set test content;dec test
-		if test#=(not_number) #to ignore ~-n
-			if initial=test ##if not this, a~-b will anyway stop at a~, but this test is logic
-				return (noerror)
-			endif
-		endif
-		sd err
-		SetCall err oneoperation(ptrcontent,initial,content,ptrval,pnumber#)
-		If err=(noerror)
-			call multisignoperation(pnr,ptrcursor,end)
-			set pnumber# pnr#
-			Set pbool# (TRUE)
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
-
-#err pointer
-Function parseoperations(sd ptrcontent,sd ptrsize,sd sz,sd outvalue,sd comments)
-	sd er;setcall er parseoperations_base(ptrcontent,ptrsize,sz,outvalue,comments,(Xfile_numbers_done))
-	return er
-EndFunction
-#err pointer
-Function parseoperations_base(sd ptrcontent,sd ptrsize,sd sz,sd outvalue,sd comments,sd xfile_numbers)
-	ss content
-	ss initial
-	sd number
-	sd val
-	sd ptrval^val
-	Data zero=0
-	sd errptr
-	Data noerr=noerror
-
-	Set content ptrcontent#
-
-	Set initial content
-	Set number (unreadyNumber)
-	Set val zero
-
-	sd bool
-	Data false=FALSE
-	Data true=TRUE
-	sd nr
-	sd pnr^nr
-	sd find
-
-	sd end;set end content;add end sz
-
-	Set bool false
-	#<end?maybe unsigned cursor
-	While content!=end
-		SetCall find signop(content#,pnr)
-		if find=true
-			setcall errptr operation_test(ptrcontent,initial,#content,end,ptrval,#number,pnr,#bool)
-			if errptr!=noerr
-				return errptr
-			endif
-		elseif content#=(asciiparenthesisstart)
-			inc content
-			sd rest_sz;set rest_sz end;sub rest_sz content
-			sd insz
-			setcall errptr parenthesis_size(content,rest_sz,#insz)
-			if errptr!=(noerror)
-				set ptrcontent# content  ##for error marker
-				return errptr
-			endif
-			add content insz
-		endelseif
-
-		Inc content
-		If bool=true
-			setcall content mem_spaces(content,end)
-			Set initial content
-			Set bool false
-		EndIf
-	EndWhile
-
-	#allow line end comment
-	if comments=(TRUE)
-		sd szz
-		set szz end;sub szz initial
-		sd size
-		setcall size find_whitespaceORcomment(initial,szz)
-		sub szz size
-		sub content szz
-	endif
-	#oneoperation is with cursor adjuster for errors
-	SetCall errptr oneoperation(ptrcontent,initial,content,ptrval,number)
-	If errptr!=noerr
-		Return errptr
-	EndIf
-	Set outvalue# val
-
-	if comments=(TRUE)
-		sub sz szz
-	endif
-	Call advancecursors(ptrcontent,ptrsize,sz)
-
-	setcall errptr xfile_add_char_ifif(xfile_numbers)
-	Return errptr
-EndFunction
-
-function multisignoperation(ss pnr,sv pcontent,sd end)
-	sd nr;set nr pnr#
-	ss content
-	if nr!=(lessNumber)
-		if nr!=(greaterNumber)
-			if nr!=(divNumber)
-				if nr!=(remNumber)
-					if nr!=(parityNumber)
-						#Why does && (AND) have higher priority over || (OR) operator?
-						#C++ does it that way because C did it that way.
-						#and is somehow like multiplication
-						#or is somehow like addition
-						if nr!=(andNumber)
-							if nr!=(orNumber)
-								ret
-							endif
-							set content pcontent#
-							inc content
-							if content!=end ##error is catched how was before
-								if content#=(orNumber)
-									set pnr# (orlogicalNumber)
-									set pcontent# content
-								endif
-							endif
-						else
-							set content pcontent#
-							inc content
-							if content!=end
-								if content#=(andNumber)
-									set pnr# (andlogicalNumber)
-									set pcontent# content
-								endif
-							endif
-						endelse
-					else
-						set content pcontent#
-						inc content
-						if content!=end
-							if content#=(equalNumber)
-								set pnr# (inequalNumber)
-								set pcontent# content
-							elseif content#=(parityNumber)
-								set pnr# (oddNumber)
-								set pcontent# content
-							endelseif
-						endif
-					endelse
-				else
-					set content pcontent#
-					inc content
-					if content!=end
-						if content#=(remNumber)
-							set pnr# (remuNumber)
-							set pcontent# content
-						endif
-					endif
-				endelse
-			else
-				set content pcontent#
-				inc content
-				if content!=end
-					if content#=(divNumber)
-						set pnr# (divuNumber)
-						set pcontent# content
-					endif
-				endif
-			endelse
-		else
-			set content pcontent#
-			inc content
-			if content!=end
-				if content#=(greaterNumber)
-					set pcontent# content
-					inc content
-					if content!=end ##else is an error and 'set pnr#' is not important
-						if content#!=(greaterNumber)
-							set pnr# (sarNumber)
-						else
-							set pnr# (shrNumber)
-							set pcontent# content
-						endelse
-					endif
-				elseif content#=(equalNumber)
-					set pcontent# content
-					inc content
-					if content!=end
-						if content#!=(castascii)
-							set pnr# (greaterequalNumber)
-						else
-							set pnr# (unsignedgreaterequalNumber)
-							set pcontent# content
-						endelse
-					endif
-				elseif content#=(castascii)
-					set pnr# (unsignedgreaterNumber)
-					set pcontent# content
-				endelseif
-			endif
-		endelse
-	else
-		set content pcontent#
-		inc content
-		if content!=end
-			if content#=(lessNumber)
-				set pnr# (shlNumber)
-				set pcontent# content
-			elseif content#=(equalNumber)
-				set pcontent# content
-				inc content
-				if content!=end
-					if content#!=(castascii)
-						set pnr# (lessequalNumber)
-					else
-						set pnr# (unsignedlessequalNumber)
-						set pcontent# content
-					endelse
-				endif
-			elseif content#=(castascii)
-				set pnr# (unsignedlessNumber)
-				set pcontent# content
-			endelseif
-		endif
-	endelse
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/xfile.oc
@@ -0,0 +1,100 @@
+
+const Xfile_function_not_x=Xfile_function_traw
+const Xfile_decltype_const=Xfile_decltype_longInt+1
+
+#err
+function xfile_add_int(sd int)
+	sd err;setcall err writefile_errversion(main.xfile,#int,(Xfile_sz_int))
+	return err
+endfunction
+#err
+function xfile_add_int_if(sd int)
+	if main.xfile!=(openno)
+		sd err;setcall err xfile_add_int(int)
+		return err
+	endif
+	return (noerror)
+endfunction
+function xfile_add_char(sd type)
+	sd err;setcall err writefile_errversion(main.xfile,#type,(Xfile_sz_char))
+	return err
+endfunction
+function xfile_add_char_if(sd type)
+	if main.xfile!=(openno)
+		sd err;setcall err writefile_errversion(main.xfile,#type,(Xfile_sz_char))
+		return err
+	endif
+	return (noerror)
+endfunction
+function xfile_add_char_ifif(sd type)
+	if main.parses=(pass_write)
+		sd err;setcall err xfile_add_char_if(type)
+		return err
+	endif
+	return (noerror)
+endfunction
+function xfile_add_string(sd text,sd size)
+	sd err;setcall err writefile_errversion(main.xfile,#size,(Xfile_sz_int))
+	if err=(noerror)
+		setcall err writefile_errversion(main.xfile,text,size)
+	endif
+	return err
+endfunction
+function xfile_add_string_if(sd text,sd size)
+	if main.xfile!=(openno)
+		sd err
+		setcall err xfile_add_string(text,size)
+		return err
+	endif
+	return (noerror)
+endfunction
+function xfile_add_string_ifif(sd text,sd size)
+	if main.parses=(pass_write)
+		sd err
+		setcall err xfile_add_string_if(text,size)
+		return err
+	endif
+	return (noerror)
+endfunction
+function xfile_add_base(sd type,sd text,sd size)
+	sd err;setcall err writefile_errversion(main.xfile,#type,(Xfile_sz_char))
+	if err=(noerror)
+		setcall err xfile_add_string(text,size)
+	endif
+	return err
+endfunction
+function xfile_add_base_if(sd type,sd text,sd size)
+	if main.xfile!=(openno)
+		sd err;setcall err xfile_add_base(type,text,size)
+		return err
+	endif
+	return (noerror)
+endfunction
+function xfile_add_base_ifif(sd type,sd text,sd size)
+	if main.parses=(pass_write)
+		sd err;setcall err xfile_add_base_if(type,text,size)
+		return err
+	endif
+	return (noerror)
+endfunction
+function xfile_add_base_area_if(sd type,sd start,sd end)
+	sub end start
+	sd e;setcall e xfile_add_base_if(type,start,end)
+	return e
+endfunction
+function xfile_add_comment_ifif(sd start,sd end,sd comment)
+	if main.parses=(pass_write)
+		inc start ##one for commentascii
+		sd e;setcall e xfile_add_base_area_if(comment,start,end)
+		return e
+	endif
+	return (noerror)
+endfunction
+function xfile_add_comment_multi_ifif(sd start,sd end)
+	if main.parses=(pass_write)
+		add start 2 #one for commentascii and one for asciiexclamationmark
+		sd e;setcall e xfile_add_base_area_if((Xfile_commentmulti),start,end)
+		return e
+	endif
+	return (noerror)
+endfunction
--- ocompiler-1.orig/src/files/functions/xfile.s
+++ /dev/null
@@ -1,100 +0,0 @@
-
-const Xfile_function_not_x=Xfile_function_traw
-const Xfile_decltype_const=Xfile_decltype_longInt+1
-
-#err
-function xfile_add_int(sd int)
-	sd err;setcall err writefile_errversion(main.xfile,#int,(Xfile_sz_int))
-	return err
-endfunction
-#err
-function xfile_add_int_if(sd int)
-	if main.xfile!=(openno)
-		sd err;setcall err xfile_add_int(int)
-		return err
-	endif
-	return (noerror)
-endfunction
-function xfile_add_char(sd type)
-	sd err;setcall err writefile_errversion(main.xfile,#type,(Xfile_sz_char))
-	return err
-endfunction
-function xfile_add_char_if(sd type)
-	if main.xfile!=(openno)
-		sd err;setcall err writefile_errversion(main.xfile,#type,(Xfile_sz_char))
-		return err
-	endif
-	return (noerror)
-endfunction
-function xfile_add_char_ifif(sd type)
-	if main.parses=(pass_write)
-		sd err;setcall err xfile_add_char_if(type)
-		return err
-	endif
-	return (noerror)
-endfunction
-function xfile_add_string(sd text,sd size)
-	sd err;setcall err writefile_errversion(main.xfile,#size,(Xfile_sz_int))
-	if err=(noerror)
-		setcall err writefile_errversion(main.xfile,text,size)
-	endif
-	return err
-endfunction
-function xfile_add_string_if(sd text,sd size)
-	if main.xfile!=(openno)
-		sd err
-		setcall err xfile_add_string(text,size)
-		return err
-	endif
-	return (noerror)
-endfunction
-function xfile_add_string_ifif(sd text,sd size)
-	if main.parses=(pass_write)
-		sd err
-		setcall err xfile_add_string_if(text,size)
-		return err
-	endif
-	return (noerror)
-endfunction
-function xfile_add_base(sd type,sd text,sd size)
-	sd err;setcall err writefile_errversion(main.xfile,#type,(Xfile_sz_char))
-	if err=(noerror)
-		setcall err xfile_add_string(text,size)
-	endif
-	return err
-endfunction
-function xfile_add_base_if(sd type,sd text,sd size)
-	if main.xfile!=(openno)
-		sd err;setcall err xfile_add_base(type,text,size)
-		return err
-	endif
-	return (noerror)
-endfunction
-function xfile_add_base_ifif(sd type,sd text,sd size)
-	if main.parses=(pass_write)
-		sd err;setcall err xfile_add_base_if(type,text,size)
-		return err
-	endif
-	return (noerror)
-endfunction
-function xfile_add_base_area_if(sd type,sd start,sd end)
-	sub end start
-	sd e;setcall e xfile_add_base_if(type,start,end)
-	return e
-endfunction
-function xfile_add_comment_ifif(sd start,sd end,sd comment)
-	if main.parses=(pass_write)
-		inc start ##one for commentascii
-		sd e;setcall e xfile_add_base_area_if(comment,start,end)
-		return e
-	endif
-	return (noerror)
-endfunction
-function xfile_add_comment_multi_ifif(sd start,sd end)
-	if main.parses=(pass_write)
-		add start 2 #one for commentascii and one for asciiexclamationmark
-		sd e;setcall e xfile_add_base_area_if((Xfile_commentmulti),start,end)
-		return e
-	endif
-	return (noerror)
-endfunction
--- /dev/null
+++ ocompiler-1/src/files/functions/xfile_details.oc
@@ -0,0 +1,331 @@
+
+#err
+function xfile_add_declare_if(sd decltype,sd is_stack,sd is_expand,ss content,sd size,sd sign,sd reloc,sd relocx)
+	if main.xfile!=(openno)
+		sd err
+		if decltype=(Xfile_decltype_const)
+			setcall err xfile_add_char((Xfile_declfield_const))
+		else
+			if is_stack=(TRUE)
+				setcall err xfile_add_char((Xfile_declfield_stack))
+			else
+				setcall err xfile_add_char((Xfile_declfield_data))
+				if err=(noerror)
+					if is_expand=(TRUE)
+						setcall err xfile_add_char((Xfile_declfield_data_expand))
+					else
+						setcall err xfile_add_char((Xfile_declfield_data_concrete))
+					endelse
+				endif
+			endelse
+			if err=(noerror)
+				setcall err xfile_add_char(decltype)
+				if err=(noerror)
+					if content#=(throwlesssign)
+						setcall err xfile_add_char((Xfile_declfeature_throwless))
+						call stepcursors(#content,#size)
+					elseif content#=(unrefsign)
+						setcall err xfile_add_char((Xfile_declfeature_unref))
+						call stepcursors(#content,#size)
+					else
+						setcall err xfile_add_char((Xfile_declfeature_normal))
+					endelse
+				endif
+			endif
+		endelse
+		if err=(noerror)
+			setcall err xfile_add_string(content,size)
+			if sign!=(sign_not_required)
+				if err=(noerror)
+					if sign=(assignsign)
+						if reloc=(FALSE)
+							setcall err xfile_add_char((Xfile_declsign_equal))
+						elseif relocx=(FALSE)
+							setcall err xfile_add_char((Xfile_declsign_ereloc))
+						else
+							setcall err xfile_add_char((Xfile_declsign_erelocx))
+						endelse
+					elseif sign=(reservesign)
+						setcall err xfile_add_char((Xfile_declsign_reserve))
+					elseif sign=(pointersigndeclare)
+						setcall err xfile_add_char((Xfile_declsign_pointer))
+					else
+					#if sign==(nosign) reserve
+						setcall err xfile_add_char((Xfile_declsign_reserve))
+					endelse
+				endif
+			endif
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
+
+#err
+function xfile_add_fndef_if(sd content,sd sz,sd fn,sd x_or_not_x,sd varargs)
+	if main.xfile!=(openno)
+		sd err
+		setcall err xfile_add_base((Xfile_functiondef),content,sz)
+		if err=(noerror)
+			setcall err xfile_add_char(fn)
+			if err=(noerror)
+				if x_or_not_x!=(Xfile_function_not_x)
+					if varargs=0
+						setcall err xfile_add_char((Xfile_function_e_normal))
+					else
+						setcall err xfile_add_char((Xfile_function_e_varargs))
+					endelse
+				endif
+			endif
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
+
+#err
+function xfile_add_varsufix_if(sd content,sd size,sd sufix,sd cast)
+	if main.xfile!=(openno)
+		sd err;setcall err xfile_add_string(content,size)
+		if err=(noerror)
+			setcall err xfile_add_char(sufix)
+			if sufix=(Xfile_suffix_true)
+				if err=(noerror)
+					setcall err xfile_add_char(cast)
+				endif
+			endif
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
+
+data xf_commas#1;data xf_pos#1
+#err
+function xfile_prepare_commas_if()
+	if main.xfile!=(openno)
+		sd err
+		setcall main.xf_pos seekfile(main.xfile,0,(SEEK_CUR),#err)
+		if main.xf_pos=-1
+			return err
+		endif
+		set main.xf_commas 0
+	endif
+	return (noerror)
+endfunction
+function xfile_inc_commas_if()
+	if main.xfile!=(openno)
+		inc main.xf_commas
+	endif
+endfunction
+#err
+function xfile_add_commas_if()
+	if main.xfile!=(openno)
+		sd err
+		sd off;setcall off seekfile(main.xfile,0,(SEEK_CUR),#err)
+		if off=-1;return err;endif
+		sub off main.xf_pos
+		sd mem
+		setcall err mem_alloc(off,#mem)
+		if err=(noerror)
+			sd sz
+			setcall sz seekfile(main.xfile,main.xf_pos,(SEEK_SET),#err)
+			if sz!=-1
+				setcall err readfile(main.xfile,mem,off)
+				if err=(noerror)
+					setcall sz seekfile(main.xfile,main.xf_pos,(SEEK_SET),#err)
+					if sz!=-1
+						call lseek(main.xfile,0,(SEEK_CUR))
+						setcall err xfile_add_int(main.xf_commas)
+						if err=(noerror)
+							call lseek(main.xfile,0,(SEEK_CUR))
+							setcall err writefile_errversion(main.xfile,mem,off)
+							call lseek(main.xfile,0,(SEEK_CUR))
+						endif
+					endif
+				endif
+			endif
+			call free(mem)
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
+#err
+function xfile_add_commas_interncall_if(sd content,sd size,sd sz)
+	if main.xfile!=(openno)
+		sd p;setcall p nr_of_args_64need_p_get();set p# 0
+		sd err
+		SetCall err enumcommas(#content,#size,sz,(FALSE),(pass_calls)) #there are 6 more arguments but are not used
+		if err=(noerror)
+			setcall err xfile_add_int(p#)
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
+
+#err
+function xfile_add_call_if(sd content,sd size,sd subtype)
+	if main.xfile!=(openno)
+		sd err
+		and subtype (x_callx_flag|x_callg_flag)
+		if subtype=0
+			setcall err xfile_add_char((Xfile_arg_call_normal)) #not forced extern
+		elseif subtype=(x_callx_flag)
+			setcall err xfile_add_char((Xfile_arg_call_extern)) #forced extern
+		elseif subtype=(x_callg_flag)
+			setcall err xfile_add_char((Xfile_arg_call_skipaftercall))
+		else
+		#if subtype!0
+			setcall err xfile_add_char((Xfile_arg_call_extern|Xfile_arg_call_skipaftercall))
+		endelse
+		if err=(noerror)
+			setcall err xfile_add_string(content,size)
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
+#err
+function xfile_add_callret(sd action,sd subtype)
+	sd err
+
+	setcall err xfile_add_char(action)
+	if err=(noerror)
+		#this can go also with primsec with a test against CALL_primsec, add that flag at getcommand, but still there is a wrong cosmetic at subtype_test=0 and not subtype_test=CALL_primsec in a case
+		setcall subtype callret_flag(subtype)
+		if subtype=0
+			setcall err xfile_add_char((Xfile_call_normal))
+		else
+			setcall err xfile_add_char((Xfile_call_ret))
+		endelse
+	endif
+
+	return err
+endfunction
+#err
+function xfile_add_callret_if(sd action,sd subtype)
+	if main.xfile!=(openno)
+		sd err
+		setcall err xfile_add_callret(action,subtype)
+		return err
+	endif
+	return (noerror)
+endfunction
+#err
+function xfile_add_callret_ifif(sd action,sd subtype)
+	if main.parses=(pass_write)
+		sd err
+		setcall err xfile_add_callret_if(action,subtype)
+		return err
+	endif
+	return (noerror)
+endfunction
+
+#err
+function xfile_add_end_if()
+	sd err;setcall err xfile_add_char_if((Xfile_end));return err
+endfunction
+#err
+function xfile_add_end_ifif()
+	if main.parses=(pass_write)
+		sd err;setcall err xfile_add_end_if();return err
+	endif
+	return (noerror)
+endfunction
+
+#err
+function xfile_add_format_if(sd format,sd ignore)
+	if main.xfile!=(openno)
+		sd err
+		setcall err xfile_add_char((Xfile_format))
+		if err=(noerror)
+			if format=(elf_unix)
+				sd ptrobject%ptrobject
+				if ptrobject#=(TRUE)
+					sd b;setcall b is_for_64()
+					if b=(TRUE)
+						if ignore=(FALSE)
+							setcall err xfile_add_char((Xfile_format_elfobj64))
+						else
+							setcall err xfile_add_char((Xfile_format_elfobj64ig))
+						endelse
+					else
+						if ignore=(FALSE)
+							setcall err xfile_add_char((Xfile_format_elfobj))
+						else
+							setcall err xfile_add_char((Xfile_format_elfobjig))
+						endelse
+					endelse
+				else
+					setcall err xfile_add_char((Xfile_format_elf))
+				endelse
+			else
+				setcall err xfile_add_char((Xfile_format_exe))
+			endelse
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
+
+#err
+function xfile_add_import_if(sv pcontent,sd psize,sd subtype)
+	if main.xfile!=(openno)
+		sd err
+		setcall err xfile_add_char((Xfile_import))
+		if err=(noerror)
+			setcall err xfile_add_char(subtype)
+			if err=(noerror)
+				Datax impquotsz#1
+				Datax impescapes#1
+				#the spelling errors were at pass init
+				Call quotinmem(pcontent,psize,#impquotsz,#impescapes)
+				setcall err addtosecstresc_xfile(pcontent,psize,impquotsz,impescapes,main.ptrtempdata)
+				if err=(noerror)
+					Call spaces(pcontent,psize)
+					sd imp_size;setcall imp_size find_whitespaceORcomment(pcontent#,psize#)
+					setcall err xfile_add_string(pcontent#,imp_size) #not a spelling error
+					call advancecursors(pcontent,psize,psize#) #,imp_size  spelling was at pass_init
+				endif
+			endif
+		endif
+		return err
+	endif
+	call advancecursors(pcontent,psize,psize#)
+	return (noerror)
+endfunction
+
+#err
+function xfile_add_library_if(sv pcontent,sd psize)
+	if main.xfile!=(openno)
+		sd err
+		setcall err xfile_add_char((Xfile_library))
+		if err=(noerror)
+			Datax impquotsz#1
+			Datax impescapes#1
+			#the spelling errors were at pass init
+			Call quotinmem(pcontent,psize,#impquotsz,#impescapes)
+			setcall err addtosecstresc_xfile(pcontent,psize,impquotsz,impescapes,main.ptrtempdata)
+			#here a low chances error, not a spelling error, spelling was at pass init
+			call advancecursors(pcontent,psize,psize#)
+		endif
+		return err
+	endif
+	call advancecursors(pcontent,psize,psize#)
+	return (noerror)
+endfunction
+
+#err
+function xfile_add_override_if(sd name,sd size,sd value)
+	if main.xfile!=(openno)
+		sd err
+		setcall err xfile_add_base((Xfile_override),name,size)
+		if err=(noerror)
+			setcall err xfile_add_char(value)
+		endif
+		return err
+	endif
+	return (noerror)
+endfunction
--- ocompiler-1.orig/src/files/functions/xfile_details.s
+++ /dev/null
@@ -1,331 +0,0 @@
-
-#err
-function xfile_add_declare_if(sd decltype,sd is_stack,sd is_expand,ss content,sd size,sd sign,sd reloc,sd relocx)
-	if main.xfile!=(openno)
-		sd err
-		if decltype=(Xfile_decltype_const)
-			setcall err xfile_add_char((Xfile_declfield_const))
-		else
-			if is_stack=(TRUE)
-				setcall err xfile_add_char((Xfile_declfield_stack))
-			else
-				setcall err xfile_add_char((Xfile_declfield_data))
-				if err=(noerror)
-					if is_expand=(TRUE)
-						setcall err xfile_add_char((Xfile_declfield_data_expand))
-					else
-						setcall err xfile_add_char((Xfile_declfield_data_concrete))
-					endelse
-				endif
-			endelse
-			if err=(noerror)
-				setcall err xfile_add_char(decltype)
-				if err=(noerror)
-					if content#=(throwlesssign)
-						setcall err xfile_add_char((Xfile_declfeature_throwless))
-						call stepcursors(#content,#size)
-					elseif content#=(unrefsign)
-						setcall err xfile_add_char((Xfile_declfeature_unref))
-						call stepcursors(#content,#size)
-					else
-						setcall err xfile_add_char((Xfile_declfeature_normal))
-					endelse
-				endif
-			endif
-		endelse
-		if err=(noerror)
-			setcall err xfile_add_string(content,size)
-			if sign!=(sign_not_required)
-				if err=(noerror)
-					if sign=(assignsign)
-						if reloc=(FALSE)
-							setcall err xfile_add_char((Xfile_declsign_equal))
-						elseif relocx=(FALSE)
-							setcall err xfile_add_char((Xfile_declsign_ereloc))
-						else
-							setcall err xfile_add_char((Xfile_declsign_erelocx))
-						endelse
-					elseif sign=(reservesign)
-						setcall err xfile_add_char((Xfile_declsign_reserve))
-					elseif sign=(pointersigndeclare)
-						setcall err xfile_add_char((Xfile_declsign_pointer))
-					else
-					#if sign==(nosign) reserve
-						setcall err xfile_add_char((Xfile_declsign_reserve))
-					endelse
-				endif
-			endif
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
-
-#err
-function xfile_add_fndef_if(sd content,sd sz,sd fn,sd x_or_not_x,sd varargs)
-	if main.xfile!=(openno)
-		sd err
-		setcall err xfile_add_base((Xfile_functiondef),content,sz)
-		if err=(noerror)
-			setcall err xfile_add_char(fn)
-			if err=(noerror)
-				if x_or_not_x!=(Xfile_function_not_x)
-					if varargs=0
-						setcall err xfile_add_char((Xfile_function_e_normal))
-					else
-						setcall err xfile_add_char((Xfile_function_e_varargs))
-					endelse
-				endif
-			endif
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
-
-#err
-function xfile_add_varsufix_if(sd content,sd size,sd sufix,sd cast)
-	if main.xfile!=(openno)
-		sd err;setcall err xfile_add_string(content,size)
-		if err=(noerror)
-			setcall err xfile_add_char(sufix)
-			if sufix=(Xfile_suffix_true)
-				if err=(noerror)
-					setcall err xfile_add_char(cast)
-				endif
-			endif
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
-
-data xf_commas#1;data xf_pos#1
-#err
-function xfile_prepare_commas_if()
-	if main.xfile!=(openno)
-		sd err
-		setcall main.xf_pos seekfile(main.xfile,0,(SEEK_CUR),#err)
-		if main.xf_pos=-1
-			return err
-		endif
-		set main.xf_commas 0
-	endif
-	return (noerror)
-endfunction
-function xfile_inc_commas_if()
-	if main.xfile!=(openno)
-		inc main.xf_commas
-	endif
-endfunction
-#err
-function xfile_add_commas_if()
-	if main.xfile!=(openno)
-		sd err
-		sd off;setcall off seekfile(main.xfile,0,(SEEK_CUR),#err)
-		if off=-1;return err;endif
-		sub off main.xf_pos
-		sd mem
-		setcall err mem_alloc(off,#mem)
-		if err=(noerror)
-			sd sz
-			setcall sz seekfile(main.xfile,main.xf_pos,(SEEK_SET),#err)
-			if sz!=-1
-				setcall err readfile(main.xfile,mem,off)
-				if err=(noerror)
-					setcall sz seekfile(main.xfile,main.xf_pos,(SEEK_SET),#err)
-					if sz!=-1
-						call lseek(main.xfile,0,(SEEK_CUR))
-						setcall err xfile_add_int(main.xf_commas)
-						if err=(noerror)
-							call lseek(main.xfile,0,(SEEK_CUR))
-							setcall err writefile_errversion(main.xfile,mem,off)
-							call lseek(main.xfile,0,(SEEK_CUR))
-						endif
-					endif
-				endif
-			endif
-			call free(mem)
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
-#err
-function xfile_add_commas_interncall_if(sd content,sd size,sd sz)
-	if main.xfile!=(openno)
-		sd p;setcall p nr_of_args_64need_p_get();set p# 0
-		sd err
-		SetCall err enumcommas(#content,#size,sz,(FALSE),(pass_calls)) #there are 6 more arguments but are not used
-		if err=(noerror)
-			setcall err xfile_add_int(p#)
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
-
-#err
-function xfile_add_call_if(sd content,sd size,sd subtype)
-	if main.xfile!=(openno)
-		sd err
-		and subtype (x_callx_flag|x_callg_flag)
-		if subtype=0
-			setcall err xfile_add_char((Xfile_arg_call_normal)) #not forced extern
-		elseif subtype=(x_callx_flag)
-			setcall err xfile_add_char((Xfile_arg_call_extern)) #forced extern
-		elseif subtype=(x_callg_flag)
-			setcall err xfile_add_char((Xfile_arg_call_skipaftercall))
-		else
-		#if subtype!0
-			setcall err xfile_add_char((Xfile_arg_call_extern|Xfile_arg_call_skipaftercall))
-		endelse
-		if err=(noerror)
-			setcall err xfile_add_string(content,size)
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
-#err
-function xfile_add_callret(sd action,sd subtype)
-	sd err
-
-	setcall err xfile_add_char(action)
-	if err=(noerror)
-		#this can go also with primsec with a test against CALL_primsec, add that flag at getcommand, but still there is a wrong cosmetic at subtype_test=0 and not subtype_test=CALL_primsec in a case
-		setcall subtype callret_flag(subtype)
-		if subtype=0
-			setcall err xfile_add_char((Xfile_call_normal))
-		else
-			setcall err xfile_add_char((Xfile_call_ret))
-		endelse
-	endif
-
-	return err
-endfunction
-#err
-function xfile_add_callret_if(sd action,sd subtype)
-	if main.xfile!=(openno)
-		sd err
-		setcall err xfile_add_callret(action,subtype)
-		return err
-	endif
-	return (noerror)
-endfunction
-#err
-function xfile_add_callret_ifif(sd action,sd subtype)
-	if main.parses=(pass_write)
-		sd err
-		setcall err xfile_add_callret_if(action,subtype)
-		return err
-	endif
-	return (noerror)
-endfunction
-
-#err
-function xfile_add_end_if()
-	sd err;setcall err xfile_add_char_if((Xfile_end));return err
-endfunction
-#err
-function xfile_add_end_ifif()
-	if main.parses=(pass_write)
-		sd err;setcall err xfile_add_end_if();return err
-	endif
-	return (noerror)
-endfunction
-
-#err
-function xfile_add_format_if(sd format,sd ignore)
-	if main.xfile!=(openno)
-		sd err
-		setcall err xfile_add_char((Xfile_format))
-		if err=(noerror)
-			if format=(elf_unix)
-				sd ptrobject%ptrobject
-				if ptrobject#=(TRUE)
-					sd b;setcall b is_for_64()
-					if b=(TRUE)
-						if ignore=(FALSE)
-							setcall err xfile_add_char((Xfile_format_elfobj64))
-						else
-							setcall err xfile_add_char((Xfile_format_elfobj64ig))
-						endelse
-					else
-						if ignore=(FALSE)
-							setcall err xfile_add_char((Xfile_format_elfobj))
-						else
-							setcall err xfile_add_char((Xfile_format_elfobjig))
-						endelse
-					endelse
-				else
-					setcall err xfile_add_char((Xfile_format_elf))
-				endelse
-			else
-				setcall err xfile_add_char((Xfile_format_exe))
-			endelse
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
-
-#err
-function xfile_add_import_if(sv pcontent,sd psize,sd subtype)
-	if main.xfile!=(openno)
-		sd err
-		setcall err xfile_add_char((Xfile_import))
-		if err=(noerror)
-			setcall err xfile_add_char(subtype)
-			if err=(noerror)
-				Datax impquotsz#1
-				Datax impescapes#1
-				#the spelling errors were at pass init
-				Call quotinmem(pcontent,psize,#impquotsz,#impescapes)
-				setcall err addtosecstresc_xfile(pcontent,psize,impquotsz,impescapes,main.ptrtempdata)
-				if err=(noerror)
-					Call spaces(pcontent,psize)
-					sd imp_size;setcall imp_size find_whitespaceORcomment(pcontent#,psize#)
-					setcall err xfile_add_string(pcontent#,imp_size) #not a spelling error
-					call advancecursors(pcontent,psize,psize#) #,imp_size  spelling was at pass_init
-				endif
-			endif
-		endif
-		return err
-	endif
-	call advancecursors(pcontent,psize,psize#)
-	return (noerror)
-endfunction
-
-#err
-function xfile_add_library_if(sv pcontent,sd psize)
-	if main.xfile!=(openno)
-		sd err
-		setcall err xfile_add_char((Xfile_library))
-		if err=(noerror)
-			Datax impquotsz#1
-			Datax impescapes#1
-			#the spelling errors were at pass init
-			Call quotinmem(pcontent,psize,#impquotsz,#impescapes)
-			setcall err addtosecstresc_xfile(pcontent,psize,impquotsz,impescapes,main.ptrtempdata)
-			#here a low chances error, not a spelling error, spelling was at pass init
-			call advancecursors(pcontent,psize,psize#)
-		endif
-		return err
-	endif
-	call advancecursors(pcontent,psize,psize#)
-	return (noerror)
-endfunction
-
-#err
-function xfile_add_override_if(sd name,sd size,sd value)
-	if main.xfile!=(openno)
-		sd err
-		setcall err xfile_add_base((Xfile_override),name,size)
-		if err=(noerror)
-			setcall err xfile_add_char(value)
-		endif
-		return err
-	endif
-	return (noerror)
-endfunction
--- ocompiler-1.orig/src/files/headers/header.h
+++ ocompiler-1/src/files/headers/header.h
@@ -494,9 +494,8 @@ const throwlesssign=asciiand
 
 const call_align_no=0
 const call_align_yes_all=1
-#const call_align_yes_arg_sha=2
-const call_align_yes_arg=3
-const last_call_align_input=call_align_yes_arg
+const call_align_yes_pushedArgs=2
+const maximum_conf_digit=call_align_yes_pushedArgs  #7 cases when maximum is 2
 data call_align#1
 const ptr_call_align^call_align
 
@@ -530,3 +529,6 @@ const aftercall_disable=0
 data xbool#1
 data xfile#1
 charx xfile_sharp_comment#1
+
+charx endfunction_has_write#1
+charx endfunction_has_write_marker#1
--- /dev/null
+++ ocompiler-1/src/files/inits/inits.oc
@@ -0,0 +1,110 @@
+
+
+
+#fileformat#
+#file format variable
+
+Set fileformat pe_exec
+Set formatdefined 0
+
+#set default imagebase for data
+Data default_imagebase=pe_imagebase
+Set imagebaseoffset default_imagebase
+
+#start of data, here and at format command
+Set startofdata page_sectionalignment
+
+Set object false
+#fileformat#
+
+#for function in function rule
+Set innerfunction false
+
+Set programentrypoint zero
+
+
+#sort the commands
+Call sortallcommands()
+
+
+#the detailed functions and entry point informations
+#main alloc error msg
+Char entrystartfile#shortstrsize
+Str ptrentrystartfile^entrystartfile
+Data entrylinenumber#1
+
+Set fnavailable one
+
+
+#implibsstarted for closing at the end and for import parts; is here because 0 bytes src is something and asking for this at end
+Set implibsstarted false
+
+#fn info text is at preferences
+
+#pref
+sd prefix
+setcall prefix prefix_bool()
+set prefix# 0
+
+set dummyEntryReg 0
+call add_ref_to_sec(ptrdummyEntry,0,(dummy_mask),(NULL),0)
+
+sd var
+setcall var function_in_code()
+set var# 0
+
+#64bit
+#is init , is tested at any import and is set TRUE/FALSE only at elfobj... syntax
+sd p_is_for_64_value;setcall p_is_for_64_value p_is_for_64();set p_is_for_64_value# (FALSE)
+#call stack64_op_set_get((TRUE),(FALSE))
+call val64_init()
+
+#afterCall
+vdata g_e_b_p#1;setcall g_e_b_p global_err_pBool();set g_e_b_p# (FALSE)
+
+set warn_hidden_whitespaces_times 0
+
+sd convention_64
+setcall convention_64 p_neg_is_for_64()
+
+#ss init_argmasks
+#setcall init_argmasks argmasks()
+#set init_argmasks# 0
+
+if includedir=(TRUE)
+	set fileendchar (log_fileend)
+else
+	set fileendchar (log_fileend_old)
+endelse
+
+#this is init at start because we don't want to compare if 64 every time
+sd rel64_blankinit%p_elf64_r_info_type
+set rel64_blankinit# (R_X86_64_32)
+
+sd el_or_e=FALSE
+
+#needing also at pass call and pass write
+set functionTagIndex 0
+
+call resetisimm()
+
+#this is init at main.oc and used after that
+#but since #! needed at first pass too
+set datasecSize 0
+#set nobitssecReg 0
+
+sd p_b
+setcall p_b is_for_64_is_impX_or_fnX_p_get()
+set p_b# (FALSE)
+
+#this is declared here for no entry/fn tags
+call scope64_set((FALSE))
+
+vdata ptrprevLineD%%ptrprevLineD
+#set ptrprevLineD# 0    #set acording to includes
+vdata ptrcodeRegD%%ptrcodeRegD
+set ptrcodeRegD# 0
+
+call vars_log_reset() #to let next variables be ".var"
+
+set xfile_sharp_comment 0
--- ocompiler-1.orig/src/files/inits/inits.s
+++ /dev/null
@@ -1,110 +0,0 @@
-
-
-
-#fileformat#
-#file format variable
-
-Set fileformat pe_exec
-Set formatdefined 0
-
-#set default imagebase for data
-Data default_imagebase=pe_imagebase
-Set imagebaseoffset default_imagebase
-
-#start of data, here and at format command
-Set startofdata page_sectionalignment
-
-Set object false
-#fileformat#
-
-#for function in function rule
-Set innerfunction false
-
-Set programentrypoint zero
-
-
-#sort the commands
-Call sortallcommands()
-
-
-#the detailed functions and entry point informations
-#main alloc error msg
-Char entrystartfile#shortstrsize
-Str ptrentrystartfile^entrystartfile
-Data entrylinenumber#1
-
-Set fnavailable one
-
-
-#implibsstarted for closing at the end and for import parts; is here because 0 bytes src is something and asking for this at end
-Set implibsstarted false
-
-#fn info text is at preferences
-
-#pref
-sd prefix
-setcall prefix prefix_bool()
-set prefix# 0
-
-set dummyEntryReg 0
-call add_ref_to_sec(ptrdummyEntry,0,(dummy_mask),(NULL),0)
-
-sd var
-setcall var function_in_code()
-set var# 0
-
-#64bit
-#is init , is tested at any import and is set TRUE/FALSE only at elfobj... syntax
-sd p_is_for_64_value;setcall p_is_for_64_value p_is_for_64();set p_is_for_64_value# (FALSE)
-#call stack64_op_set_get((TRUE),(FALSE))
-call val64_init()
-
-#afterCall
-vdata g_e_b_p#1;setcall g_e_b_p global_err_pBool();set g_e_b_p# (FALSE)
-
-set warn_hidden_whitespaces_times 0
-
-sd convention_64
-setcall convention_64 p_neg_is_for_64()
-
-#ss init_argmasks
-#setcall init_argmasks argmasks()
-#set init_argmasks# 0
-
-if includedir=(TRUE)
-	set fileendchar (log_fileend)
-else
-	set fileendchar (log_fileend_old)
-endelse
-
-#this is init at start because we don't want to compare if 64 every time
-sd rel64_blankinit%p_elf64_r_info_type
-set rel64_blankinit# (R_X86_64_32)
-
-sd el_or_e=FALSE
-
-#needing also at pass call and pass write
-set functionTagIndex 0
-
-call resetisimm()
-
-#this is init at main.s and used after that
-#but since #! needed at first pass too
-set datasecSize 0
-#set nobitssecReg 0
-
-sd p_b
-setcall p_b is_for_64_is_impX_or_fnX_p_get()
-set p_b# (FALSE)
-
-#this is declared here for no entry/fn tags
-call scope64_set((FALSE))
-
-vdata ptrprevLineD%%ptrprevLineD
-#set ptrprevLineD# 0    #set acording to includes
-vdata ptrcodeRegD%%ptrcodeRegD
-set ptrcodeRegD# 0
-
-call vars_log_reset() #to let next variables be ".var"
-
-set xfile_sharp_comment 0
--- /dev/null
+++ ocompiler-1/src/files/inits_top.oc
@@ -0,0 +1,14 @@
+
+
+#containers initialisations
+Data containersptr%%containersbegin
+#Data containerssize=containerssize
+
+#for reg and for freeings
+Call memset(containersptr,null,containerssize)
+
+Set allocerrormsg null
+
+set safecurrentdirtopath (NULL)
+
+call initpreferences()
--- ocompiler-1.orig/src/files/inits_top.s
+++ /dev/null
@@ -1,14 +0,0 @@
-
-
-#containers initialisations
-Data containersptr%%containersbegin
-#Data containerssize=containerssize
-
-#for reg and for freeings
-Call memset(containersptr,null,containerssize)
-
-Set allocerrormsg null
-
-set safecurrentdirtopath (NULL)
-
-call initpreferences()
--- /dev/null
+++ ocompiler-1/src/linux/files/platform.oc
@@ -0,0 +1,9 @@
+
+
+function platform_free()
+endfunction
+
+function exitMessage(ss s)
+	call Message(s)
+	call errorexit()
+endfunction
--- ocompiler-1.orig/src/linux/files/platform.s
+++ /dev/null
@@ -1,9 +0,0 @@
-
-
-function platform_free()
-endfunction
-
-function exitMessage(ss s)
-	call Message(s)
-	call errorexit()
-endfunction
--- /dev/null
+++ ocompiler-1/src/linux/files/prefextra.oc
@@ -0,0 +1,93 @@
+
+const variable_convention=lin_convention
+
+#err
+function prefextra(ss prefpath,sd ptrpreferencessize,sd ptrpreferencescontent,ss scrpath)
+	sd err
+	setcall err prefextra_helper(prefpath,ptrpreferencessize,ptrpreferencescontent,scrpath)
+	if err!=(noerror)
+		Call Message(err)
+	endif
+	return err
+endfunction
+#err
+function prefextra_helper(ss prefpath,sd ptrpreferencessize,sd ptrpreferencescontent,ss scrpath)
+	sd err
+	sd s2;setcall s2 strlen(prefpath)
+	sd mem
+	sd a
+
+	#first verify in home
+	ss homestr="HOME"
+	ss envhome
+	setcall envhome getenv(homestr)
+	if envhome!=(NULL)
+		sd s1;sd s3=2
+		setcall s1 strlen(envhome);add s3 s1;add s3 s2
+		setcall err memoryalloc(s3,#mem)
+		if err=(noerror)
+			call memtomem(mem,envhome,s1)
+			ss p;set p mem;add p s1;set p# (asciislash);inc p
+			call memtomem(p,prefpath,s2);add p s2;set p# (NULL)
+			setcall a access(mem,(F_OK))
+			if a=0
+				SetCall err file_get_content_ofs(mem,ptrpreferencessize,ptrpreferencescontent,(NULL))
+				if err=(noerror)
+					call free(mem)
+					return (noerror)
+				endif
+				call safeMessage(err)  #openfile has alloc err msg
+			endif
+			call free(mem)
+		else
+			return err
+		endelse
+	else
+		call Message("Getenv error on HOME.")
+	endelse
+
+	#second verify in etc, more at Makefile about etcinclude
+
+	sd size;setcall size strlen(scrpath)
+	include "../../etcinclude.oc"
+	if size>etchelper
+		sd test;set test scrpath
+		add test size
+		sub test etchelper
+		sd cmp;setcall cmp memcmp(etc_helper,test,etchelper) #an example when testing from src folder, is not usr/bin/o / bin/o
+		if cmp=0
+			sub size etchelper
+			sd sz=3+1+1
+			sd allsize;set allsize size
+			add allsize sz
+			add allsize s2
+			setcall err memoryalloc(allsize,#mem)
+			if err=(noerror)
+				call memtomem(mem,scrpath,size)
+				set scrpath mem
+				add scrpath size
+				call memtomem(scrpath,"etc/",(3+1))
+				add scrpath (3+1)
+				call memtomem(scrpath,prefpath,s2)
+				add scrpath s2
+				set scrpath# (NULL)
+				setcall a access(mem,(F_OK))
+				if a=0
+					SetCall err file_get_content_ofs(mem,ptrpreferencessize,ptrpreferencescontent,(NULL)) #openfile has alloc err msg
+					if err=(noerror)
+						call free(mem)
+						return (noerror)
+					endif
+					Call safeMessage(err)  #openfile has alloc err msg
+				endif
+				call free(mem)
+			else
+				return err
+			endelse
+		endif
+	endif
+
+	call Message("No preferences file found in etc.")
+
+	return "No preferences file found in HOME. The file is here: https://raw.githubusercontent.com/colin-i/o/master/ocompiler.conf"
+endfunction
--- ocompiler-1.orig/src/linux/files/prefextra.s
+++ /dev/null
@@ -1,93 +0,0 @@
-
-const variable_convention=lin_convention
-
-#err
-function prefextra(ss prefpath,sd ptrpreferencessize,sd ptrpreferencescontent,ss scrpath)
-	sd err
-	setcall err prefextra_helper(prefpath,ptrpreferencessize,ptrpreferencescontent,scrpath)
-	if err!=(noerror)
-		Call Message(err)
-	endif
-	return err
-endfunction
-#err
-function prefextra_helper(ss prefpath,sd ptrpreferencessize,sd ptrpreferencescontent,ss scrpath)
-	sd err
-	sd s2;setcall s2 strlen(prefpath)
-	sd mem
-	sd a
-
-	#first verify in home
-	ss homestr="HOME"
-	ss envhome
-	setcall envhome getenv(homestr)
-	if envhome!=(NULL)
-		sd s1;sd s3=2
-		setcall s1 strlen(envhome);add s3 s1;add s3 s2
-		setcall err memoryalloc(s3,#mem)
-		if err=(noerror)
-			call memtomem(mem,envhome,s1)
-			ss p;set p mem;add p s1;set p# (asciislash);inc p
-			call memtomem(p,prefpath,s2);add p s2;set p# (NULL)
-			setcall a access(mem,(F_OK))
-			if a=0
-				SetCall err file_get_content_ofs(mem,ptrpreferencessize,ptrpreferencescontent,(NULL))
-				if err=(noerror)
-					call free(mem)
-					return (noerror)
-				endif
-				call safeMessage(err)  #openfile has alloc err msg
-			endif
-			call free(mem)
-		else
-			return err
-		endelse
-	else
-		call Message("Getenv error on HOME.")
-	endelse
-
-	#second verify in etc, more at Makefile about etcinclude
-
-	sd size;setcall size strlen(scrpath)
-	include "../../etcinclude.s"
-	if size>etchelper
-		sd test;set test scrpath
-		add test size
-		sub test etchelper
-		sd cmp;setcall cmp memcmp(etc_helper,test,etchelper) #an example when testing from src folder, is not usr/bin/o / bin/o
-		if cmp=0
-			sub size etchelper
-			sd sz=3+1+1
-			sd allsize;set allsize size
-			add allsize sz
-			add allsize s2
-			setcall err memoryalloc(allsize,#mem)
-			if err=(noerror)
-				call memtomem(mem,scrpath,size)
-				set scrpath mem
-				add scrpath size
-				call memtomem(scrpath,"etc/",(3+1))
-				add scrpath (3+1)
-				call memtomem(scrpath,prefpath,s2)
-				add scrpath s2
-				set scrpath# (NULL)
-				setcall a access(mem,(F_OK))
-				if a=0
-					SetCall err file_get_content_ofs(mem,ptrpreferencessize,ptrpreferencescontent,(NULL)) #openfile has alloc err msg
-					if err=(noerror)
-						call free(mem)
-						return (noerror)
-					endif
-					Call safeMessage(err)  #openfile has alloc err msg
-				endif
-				call free(mem)
-			else
-				return err
-			endelse
-		endif
-	endif
-
-	call Message("No preferences file found in etc.")
-
-	return "No preferences file found in HOME. The file is here: https://raw.githubusercontent.com/colin-i/o/master/ocompiler.conf"
-endfunction
--- /dev/null
+++ ocompiler-1/src/linux/files/xgetfile.oc
@@ -0,0 +1,105 @@
+
+if argc<1
+	Char cmdscripterr="Cannot parse to input file name."
+	Str ptrcmdscripterr^cmdscripterr
+	call exitMessage(ptrcmdscripterr)
+endif
+
+if argc<2
+	Char cmdnoinput="O Compiler - usage: o \"filename\" [[pref1 value1]...[prefN valueN]]"
+	char moreinfo="Documentation is here: https://colin-i.github.io/o.html"
+	ss moreinfo_helper^moreinfo
+	dec moreinfo_helper;set moreinfo_helper# (asciireturn)
+	call exitMessage(#cmdnoinput)
+EndIf
+
+
+#if the file was executed from the PATH, then the root folder it is searched
+Data argumentssize#1
+str scriptfullname#1
+char slash=asciislash
+data slashtest#1
+
+setcall argumentssize strlen(argv0)
+setcall slashtest valinmem(argv0,argumentssize,slash)
+if slashtest!=argumentssize
+	set scriptfullname argv0
+else
+	data accessresult#1
+	str envpath#1
+	str pathstr="PATH"
+	set scriptfullname null
+	setcall envpath getenv(pathstr)
+	if envpath=null
+		str enverr="Getenv error on PATH."
+		call Message(enverr)
+	else
+		data sizeofpath#1
+		setcall sizeofpath strlen(envpath)
+		set accessresult (negative)
+		while sizeofpath!=zero
+			char pathdelim=":"
+			data sizeoffolder#1
+			setcall sizeoffolder valinmem(envpath,sizeofpath,pathdelim)
+
+			data sizetocreate#1
+			set sizetocreate sizeoffolder
+			#this one is if '/' needs to be added after the folder
+			inc sizetocreate
+			add sizetocreate argumentssize
+			inc sizetocreate
+			setcall scriptfullname memalloc(sizetocreate)
+			if scriptfullname=null
+				set sizeofpath zero
+			else
+				#do not work on null PATH parts
+				if sizeoffolder!=null
+					str scrpointer#1
+					set scrpointer scriptfullname
+					call memtomem(scrpointer,envpath,sizeoffolder)
+					add scrpointer sizeoffolder
+					dec scrpointer
+
+					char slashcompare#1
+					set slashcompare scrpointer#
+					inc scrpointer
+					if slashcompare!=slash
+						set scrpointer# slash
+						inc scrpointer
+					endif
+					call memtomem(scrpointer,argv0,argumentssize)
+					add scrpointer argumentssize
+					set scrpointer# null
+
+					data runaccess=X_OK
+					setcall accessresult access(scriptfullname,runaccess)
+				endif
+				if accessresult=zero
+					#continue with this path to preferences
+					set sizeofpath zero
+				else
+					call free(scriptfullname)
+					set scriptfullname null
+					add envpath sizeoffolder
+					sub sizeofpath sizeoffolder
+					if envpath#=pathdelim
+						inc envpath
+						dec sizeofpath
+					endif
+				endelse
+			endelse
+		endwhile
+	endelse
+endelse
+
+if scriptfullname=null
+	str patherr="Pathfind error."
+	call Message(patherr)
+else
+	call setpreferences(scriptfullname)
+	if scriptfullname!=argv0
+		call free(scriptfullname)
+	endif
+endelse
+
+set path_nofree argv1
--- ocompiler-1.orig/src/linux/files/xgetfile.s
+++ /dev/null
@@ -1,105 +0,0 @@
-
-if argc<1
-	Char cmdscripterr="Cannot parse to input file name."
-	Str ptrcmdscripterr^cmdscripterr
-	call exitMessage(ptrcmdscripterr)
-endif
-
-if argc<2
-	Char cmdnoinput="O Compiler - usage: o \"filename\" [[pref1 value1]...[prefN valueN]]"
-	char moreinfo="Documentation is here: https://colin-i.github.io/o.html"
-	ss moreinfo_helper^moreinfo
-	dec moreinfo_helper;set moreinfo_helper# (asciireturn)
-	call exitMessage(#cmdnoinput)
-EndIf
-
-
-#if the file was executed from the PATH, then the root folder it is searched
-Data argumentssize#1
-str scriptfullname#1
-char slash=asciislash
-data slashtest#1
-
-setcall argumentssize strlen(argv0)
-setcall slashtest valinmem(argv0,argumentssize,slash)
-if slashtest!=argumentssize
-	set scriptfullname argv0
-else
-	data accessresult#1
-	str envpath#1
-	str pathstr="PATH"
-	set scriptfullname null
-	setcall envpath getenv(pathstr)
-	if envpath=null
-		str enverr="Getenv error on PATH."
-		call Message(enverr)
-	else
-		data sizeofpath#1
-		setcall sizeofpath strlen(envpath)
-		set accessresult (negative)
-		while sizeofpath!=zero
-			char pathdelim=":"
-			data sizeoffolder#1
-			setcall sizeoffolder valinmem(envpath,sizeofpath,pathdelim)
-
-			data sizetocreate#1
-			set sizetocreate sizeoffolder
-			#this one is if '/' needs to be added after the folder
-			inc sizetocreate
-			add sizetocreate argumentssize
-			inc sizetocreate
-			setcall scriptfullname memalloc(sizetocreate)
-			if scriptfullname=null
-				set sizeofpath zero
-			else
-				#do not work on null PATH parts
-				if sizeoffolder!=null
-					str scrpointer#1
-					set scrpointer scriptfullname
-					call memtomem(scrpointer,envpath,sizeoffolder)
-					add scrpointer sizeoffolder
-					dec scrpointer
-
-					char slashcompare#1
-					set slashcompare scrpointer#
-					inc scrpointer
-					if slashcompare!=slash
-						set scrpointer# slash
-						inc scrpointer
-					endif
-					call memtomem(scrpointer,argv0,argumentssize)
-					add scrpointer argumentssize
-					set scrpointer# null
-
-					data runaccess=X_OK
-					setcall accessresult access(scriptfullname,runaccess)
-				endif
-				if accessresult=zero
-					#continue with this path to preferences
-					set sizeofpath zero
-				else
-					call free(scriptfullname)
-					set scriptfullname null
-					add envpath sizeoffolder
-					sub sizeofpath sizeoffolder
-					if envpath#=pathdelim
-						inc envpath
-						dec sizeofpath
-					endif
-				endelse
-			endelse
-		endwhile
-	endelse
-endelse
-
-if scriptfullname=null
-	str patherr="Pathfind error."
-	call Message(patherr)
-else
-	call setpreferences(scriptfullname)
-	if scriptfullname!=argv0
-		call free(scriptfullname)
-	endif
-endelse
-
-set path_nofree argv1
--- ocompiler-1.orig/src/linux/head.h
+++ ocompiler-1/src/linux/head.h
@@ -5,6 +5,6 @@ Include "./files/xheaders.h"
 Include "../files/headers.h"
 
 #functions
-include "./files/platform.s"
-include "./files/prefextra.s"
-Include "../files/functions.s"
+include "./files/platform.oc"
+include "./files/prefextra.oc"
+Include "../files/functions.oc"
--- /dev/null
+++ ocompiler-1/src/linux/o.oc
@@ -0,0 +1,25 @@
+
+#linux elf exec
+
+Format Elf
+
+Include "./files/ximports.h"
+
+Function Message(str text)
+	data stderrorobject_init^^stderr
+	data stderrorobject#1
+
+	set stderrorobject stderrorobject_init#
+	set stderrorobject stderrorobject#
+
+	Char visiblemessagedata={0x0a,0}
+	Str visiblemessage^visiblemessagedata
+
+	Call fprintf(stderrorobject,visiblemessage)
+	Call fprintf(stderrorobject,text)
+	Call fprintf(stderrorobject,visiblemessage)
+EndFunction
+
+Include "./head.h"
+
+Include "./text.oc"
--- ocompiler-1.orig/src/linux/o.s
+++ /dev/null
@@ -1,25 +0,0 @@
-
-#linux elf exec
-
-Format Elf
-
-Include "./files/ximports.h"
-
-Function Message(str text)
-	data stderrorobject_init^^stderr
-	data stderrorobject#1
-
-	set stderrorobject stderrorobject_init#
-	set stderrorobject stderrorobject#
-
-	Char visiblemessagedata={0x0a,0}
-	Str visiblemessage^visiblemessagedata
-
-	Call fprintf(stderrorobject,visiblemessage)
-	Call fprintf(stderrorobject,text)
-	Call fprintf(stderrorobject,visiblemessage)
-EndFunction
-
-Include "./head.h"
-
-Include "./text.s"
--- /dev/null
+++ ocompiler-1/src/linux/obj.oc
@@ -0,0 +1,28 @@
+
+#linux elf rel format
+
+Format ElfObj
+
+Include "./files/xcomimports.h"
+
+Function Message(str text)
+#binutils-x86-64-linux-gnu:amd64 (2.37.50.20220106-2ubuntu1, 2.37.90.20220126-0ubuntu1)
+#ld will take stderr in data through rel.dyn only with another presence in text
+#	data stderrorobject_init^stderr
+#	data stderrorobject#1
+	sd stderrorobject^stderr
+	set stderrorobject stderrorobject#
+
+	Char visiblemessagedata={0x0a,0}
+	Str visiblemessage^visiblemessagedata
+
+	Call fprintf(stderrorobject,visiblemessage)
+	Call fprintf(stderrorobject,text)
+	Call fprintf(stderrorobject,visiblemessage)
+EndFunction
+
+Include "./head.h"
+
+Include "./text.oc"
+
+
--- ocompiler-1.orig/src/linux/obj.s
+++ /dev/null
@@ -1,28 +0,0 @@
-
-#linux elf rel format
-
-Format ElfObj
-
-Include "./files/xcomimports.h"
-
-Function Message(str text)
-#binutils-x86-64-linux-gnu:amd64 (2.37.50.20220106-2ubuntu1, 2.37.90.20220126-0ubuntu1)
-#ld will take stderr in data through rel.dyn only with another presence in text
-#	data stderrorobject_init^stderr
-#	data stderrorobject#1
-	sd stderrorobject^stderr
-	set stderrorobject stderrorobject#
-
-	Char visiblemessagedata={0x0a,0}
-	Str visiblemessage^visiblemessagedata
-
-	Call fprintf(stderrorobject,visiblemessage)
-	Call fprintf(stderrorobject,text)
-	Call fprintf(stderrorobject,visiblemessage)
-EndFunction
-
-Include "./head.h"
-
-Include "./text.s"
-
-
--- /dev/null
+++ ocompiler-1/src/linux/text.oc
@@ -0,0 +1,16 @@
+
+EntryRaw main(sd argc,ss argv0,ss argv1)
+
+#main
+Include "../files/inits_top.oc"
+
+Include "./files/xgetfile.oc"
+
+setcall errormsg comline_parse(argc,#argv0)
+if errormsg!=(noerror)
+	call exitMessage(errormsg)
+endif
+
+Include "../files/actions.oc"
+
+Exit zero
--- ocompiler-1.orig/src/linux/text.s
+++ /dev/null
@@ -1,16 +0,0 @@
-
-EntryRaw main(sd argc,ss argv0,ss argv1)
-
-#main
-Include "../files/inits_top.s"
-
-Include "./files/xgetfile.s"
-
-setcall errormsg comline_parse(argc,#argv0)
-if errormsg!=(noerror)
-	call exitMessage(errormsg)
-endif
-
-Include "../files/actions.s"
-
-Exit zero
--- /dev/null
+++ ocompiler-1/src/windows/files/platform.oc
@@ -0,0 +1,36 @@
+
+function platform_free()
+	sd a%p_argv
+	if a#!=(NULL)
+		call free(a#)
+	endif
+	sd b%p_path_free
+	if b#!=(NULL)
+		call free(b#)
+	endif
+endfunction
+
+function argv_to_ansi(sd argc,sd argv)
+	mult argc :
+	add argc argv
+	while argv!=argc
+		call wide_to_ansi(argv#)
+		incst argv
+	endwhile
+endfunction
+
+function wide_to_ansi(ss in)
+	ss out
+	set out in
+	dec out
+	char n=0;char x#1
+	while 0=0
+		inc out
+		set x in#
+		set out# x
+		if x=n
+			ret
+		endif
+		add in 2
+	endwhile
+endfunction
--- ocompiler-1.orig/src/windows/files/platform.s
+++ /dev/null
@@ -1,36 +0,0 @@
-
-function platform_free()
-	sd a%p_argv
-	if a#!=(NULL)
-		call free(a#)
-	endif
-	sd b%p_path_free
-	if b#!=(NULL)
-		call free(b#)
-	endif
-endfunction
-
-function argv_to_ansi(sd argc,sd argv)
-	mult argc :
-	add argc argv
-	while argv!=argc
-		call wide_to_ansi(argv#)
-		incst argv
-	endwhile
-endfunction
-
-function wide_to_ansi(ss in)
-	ss out
-	set out in
-	dec out
-	char n=0;char x#1
-	while 0=0
-		inc out
-		set x in#
-		set out# x
-		if x=n
-			ret
-		endif
-		add in 2
-	endwhile
-endfunction
--- /dev/null
+++ ocompiler-1/src/windows/files/prefextra.oc
@@ -0,0 +1,8 @@
+
+const variable_convention=ms_convention
+
+#Const error=-1 is at header
+
+function prefextra(ss *file,sd *ptrpreferencessize,sd *ptrpreferencescontent,ss *scrpath)
+	return (error)
+endfunction
--- ocompiler-1.orig/src/windows/files/prefextra.s
+++ /dev/null
@@ -1,8 +0,0 @@
-
-const variable_convention=ms_convention
-
-#Const error=-1 is at header
-
-function prefextra(ss *file,sd *ptrpreferencessize,sd *ptrpreferencescontent,ss *scrpath)
-	return (error)
-endfunction
--- /dev/null
+++ ocompiler-1/src/windows/files/winend.oc
@@ -0,0 +1,24 @@
+
+
+
+If openfilenamemethod=true
+	Data timeatend#1
+	SetCall timeatend GetTickCount()
+	Sub timeatend timeatbegin
+	Data MillisecperSec=1000
+	Data seconds#1
+	Set seconds timeatend
+	Div seconds MillisecperSec
+	Data SectoMil#1
+	Set SectoMil seconds
+	Mult SectoMil MillisecperSec
+	Sub timeatend SectoMil
+	Const sizeofouttime=100
+	Char outtime#sizeofouttime
+	Str ptrouttime^outtime
+	Char outtimeformat="Done. %u.%u seconds"
+	Str ptrouttimeformat^outtimeformat
+
+	Call sprintf(ptrouttime,ptrouttimeformat,seconds,timeatend)
+	Call MessageBox(null,ptrouttime,"Time",null)
+EndIf
--- ocompiler-1.orig/src/windows/files/winend.s
+++ /dev/null
@@ -1,24 +0,0 @@
-
-
-
-If openfilenamemethod=true
-	Data timeatend#1
-	SetCall timeatend GetTickCount()
-	Sub timeatend timeatbegin
-	Data MillisecperSec=1000
-	Data seconds#1
-	Set seconds timeatend
-	Div seconds MillisecperSec
-	Data SectoMil#1
-	Set SectoMil seconds
-	Mult SectoMil MillisecperSec
-	Sub timeatend SectoMil
-	Const sizeofouttime=100
-	Char outtime#sizeofouttime
-	Str ptrouttime^outtime
-	Char outtimeformat="Done. %u.%u seconds"
-	Str ptrouttimeformat^outtimeformat
-
-	Call sprintf(ptrouttime,ptrouttimeformat,seconds,timeatend)
-	Call MessageBox(null,ptrouttime,"Time",null)
-EndIf
--- /dev/null
+++ ocompiler-1/src/windows/files/wingetfile.oc
@@ -0,0 +1,13 @@
+
+
+Set path_nofree (NULL)
+Include "./wingetfile/getfilefromcommand.oc"
+set path_free (NULL)
+If path_nofree=null
+	#open file name
+	Include "./wingetfile/getfilefromopenfilename.oc"
+	set path_nofree path_free
+	Data timeatbegin#1
+	SetCall timeatbegin GetTickCount()
+	Set openfilenamemethod true
+EndIf
--- ocompiler-1.orig/src/windows/files/wingetfile.s
+++ /dev/null
@@ -1,13 +0,0 @@
-
-
-Set path_nofree (NULL)
-Include "./wingetfile/getfilefromcommand.s"
-set path_free (NULL)
-If path_nofree=null
-	#open file name
-	Include "./wingetfile/getfilefromopenfilename.s"
-	set path_nofree path_free
-	Data timeatbegin#1
-	SetCall timeatbegin GetTickCount()
-	Set openfilenamemethod true
-EndIf
--- /dev/null
+++ ocompiler-1/src/windows/files/wingetfile/getfilefromcommand.oc
@@ -0,0 +1,25 @@
+
+
+sd command_name
+#sd commname_size
+
+SetCall command_name GetCommandName()
+
+#this is so bugged but accepted , strlen is ansi, but no wide path in this program, so first XX00h will stop
+#anyway argv0 can't be '\0'
+#SetCall commname_size strlen(command_name)
+#If commname_size!=zero
+setcall argv CommandLineToArgvW(command_name,#argc)
+if argv!=(NULL)
+	#here is the start of mem worries for windows
+	call argv_to_ansi(argc,argv)
+	if argc>0 #is this logic?
+		call setpreferences(argv#)
+		if argc>1
+			set path_nofree argv
+			incst path_nofree
+			set path_nofree path_nofree#
+		endif
+	endif
+endif
+#EndIf
--- ocompiler-1.orig/src/windows/files/wingetfile/getfilefromcommand.s
+++ /dev/null
@@ -1,25 +0,0 @@
-
-
-sd command_name
-#sd commname_size
-
-SetCall command_name GetCommandName()
-
-#this is so bugged but accepted , strlen is ansi, but no wide path in this program, so first XX00h will stop
-#anyway argv0 can't be '\0'
-#SetCall commname_size strlen(command_name)
-#If commname_size!=zero
-setcall argv CommandLineToArgvW(command_name,#argc)
-if argv!=(NULL)
-	#here is the start of mem worries for windows
-	call argv_to_ansi(argc,argv)
-	if argc>0 #is this logic?
-		call setpreferences(argv#)
-		if argc>1
-			set path_nofree argv
-			incst path_nofree
-			set path_nofree path_nofree#
-		endif
-	endif
-endif
-#EndIf
--- /dev/null
+++ ocompiler-1/src/windows/files/wingetfile/getfilefromopenfilename.oc
@@ -0,0 +1,62 @@
+
+#OPENFILENAME
+Const OFN_FILEMUSTEXIST=0x1000
+Const OFN_PATHMUSTEXIST=0x0800
+
+Const ofnFlags=OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST
+
+Str ofnfiltermemvalue#1
+
+setcall path_free memalloc(flag_max_path)
+if path_free=(NULL)
+	#memalloc has message
+	call errexit()
+endif
+set path_free# 0
+
+Include "./getfilefromopenfilename/lpstrFilter.oc"
+
+
+Data ofnlStructSize=0x58
+Data *ofnhwndOwner=0
+Data *ofnhInstance=0
+Str ofnfiltermem#1
+Set ofnfiltermem ofnfiltermemvalue
+
+Data *ofnlpstrCustomFilter=0
+Data *ofnnMaxCustFilter=0
+Data *ofnnFilterIndex=0
+Str ofnlpstrFile#1
+Set ofnlpstrFile path_free
+
+Data ofnnMaxFile#1
+Set ofnnMaxFile flag_max_path
+Data *ofnlpstrFileTitle=0
+Data *ofnnMaxFileTitle=0
+Data *ofnlpstrInitialDir=0
+
+Data *ofnlpstrTitle=0
+Data *ofnFlags=ofnFlags
+Data *ofnnFileOffset=0
+Data *ofnnFileExtension=0
+Data *ofnlpstrDefExt=0
+
+Data *ofnlCustData=0
+Data *ofnlpfnHook=0
+Data *ofnlpTemplateName=0
+#if (_WIN32_WINNT >= 0x0500)
+Data *ofnpvReserved=0
+
+Data *ofndwReserved=0
+Data *ofnFlagsEx=0
+#endif
+
+Data OFNfile^ofnlStructSize
+Data openfilenameresult#1
+SetCall openfilenameresult GetOpenFileName(OFNfile)
+
+Call free(ofnfiltermem)
+
+If openfilenameresult=zero
+	Call msgerrexit("No file selected or an error occurs.")
+EndIf
--- ocompiler-1.orig/src/windows/files/wingetfile/getfilefromopenfilename.s
+++ /dev/null
@@ -1,62 +0,0 @@
-
-#OPENFILENAME
-Const OFN_FILEMUSTEXIST=0x1000
-Const OFN_PATHMUSTEXIST=0x0800
-
-Const ofnFlags=OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST
-
-Str ofnfiltermemvalue#1
-
-setcall path_free memalloc(flag_max_path)
-if path_free=(NULL)
-	#memalloc has message
-	call errexit()
-endif
-set path_free# 0
-
-Include "./getfilefromopenfilename/lpstrFilter.s"
-
-
-Data ofnlStructSize=0x58
-Data *ofnhwndOwner=0
-Data *ofnhInstance=0
-Str ofnfiltermem#1
-Set ofnfiltermem ofnfiltermemvalue
-
-Data *ofnlpstrCustomFilter=0
-Data *ofnnMaxCustFilter=0
-Data *ofnnFilterIndex=0
-Str ofnlpstrFile#1
-Set ofnlpstrFile path_free
-
-Data ofnnMaxFile#1
-Set ofnnMaxFile flag_max_path
-Data *ofnlpstrFileTitle=0
-Data *ofnnMaxFileTitle=0
-Data *ofnlpstrInitialDir=0
-
-Data *ofnlpstrTitle=0
-Data *ofnFlags=ofnFlags
-Data *ofnnFileOffset=0
-Data *ofnnFileExtension=0
-Data *ofnlpstrDefExt=0
-
-Data *ofnlCustData=0
-Data *ofnlpfnHook=0
-Data *ofnlpTemplateName=0
-#if (_WIN32_WINNT >= 0x0500)
-Data *ofnpvReserved=0
-
-Data *ofndwReserved=0
-Data *ofnFlagsEx=0
-#endif
-
-Data OFNfile^ofnlStructSize
-Data openfilenameresult#1
-SetCall openfilenameresult GetOpenFileName(OFNfile)
-
-Call free(ofnfiltermem)
-
-If openfilenameresult=zero
-	Call msgerrexit("No file selected or an error occurs.")
-EndIf
--- /dev/null
+++ ocompiler-1/src/windows/files/wingetfile/getfilefromopenfilename/lpstrFilter.oc
@@ -0,0 +1,37 @@
+
+
+Char allfiles="All Files (*.*)"
+Str ptrallfiles^allfiles
+Char filter2="*.*"
+Str ptrfilter2^filter2
+char nullstr=""
+
+Data ofnfiltersize#1
+Data str1sz#1
+Data filter2sz#1
+
+SetCall str1sz strlen(ptrallfiles)
+SetCall filter2sz strlen(ptrfilter2)
+Set ofnfiltersize str1sz
+Add ofnfiltersize bytesize
+Add ofnfiltersize filter2sz
+Add ofnfiltersize bytesize
+Add ofnfiltersize bytesize
+SetCall ofnfiltermemvalue memalloc(ofnfiltersize)
+If ofnfiltermemvalue=null
+	Call errexit()
+EndIf
+Str cursor#1
+Set cursor ofnfiltermemvalue
+Set cursor# nullstr
+Call strcat(cursor,ptrallfiles)
+Add cursor str1sz
+Set cursor# nullstr
+Add cursor bytesize
+Set cursor# nullstr
+Call strcat(cursor,ptrfilter2)
+Add cursor filter2sz
+Set cursor# nullstr
+Add cursor bytesize
+Set cursor# nullstr
+
--- ocompiler-1.orig/src/windows/files/wingetfile/getfilefromopenfilename/lpstrFilter.s
+++ /dev/null
@@ -1,37 +0,0 @@
-
-
-Char allfiles="All Files (*.*)"
-Str ptrallfiles^allfiles
-Char filter2="*.*"
-Str ptrfilter2^filter2
-char nullstr=""
-
-Data ofnfiltersize#1
-Data str1sz#1
-Data filter2sz#1
-
-SetCall str1sz strlen(ptrallfiles)
-SetCall filter2sz strlen(ptrfilter2)
-Set ofnfiltersize str1sz
-Add ofnfiltersize bytesize
-Add ofnfiltersize filter2sz
-Add ofnfiltersize bytesize
-Add ofnfiltersize bytesize
-SetCall ofnfiltermemvalue memalloc(ofnfiltersize)
-If ofnfiltermemvalue=null
-	Call errexit()
-EndIf
-Str cursor#1
-Set cursor ofnfiltermemvalue
-Set cursor# nullstr
-Call strcat(cursor,ptrallfiles)
-Add cursor str1sz
-Set cursor# nullstr
-Add cursor bytesize
-Set cursor# nullstr
-Call strcat(cursor,ptrfilter2)
-Add cursor filter2sz
-Set cursor# nullstr
-Add cursor bytesize
-Set cursor# nullstr
-
--- ocompiler-1.orig/src/windows/head.h
+++ ocompiler-1/src/windows/head.h
@@ -5,10 +5,10 @@ Include "./files/winheaders.h"
 Include "../files/headers.h"
 
 #functions
-include "./files/prefextra.s"
+include "./files/prefextra.oc"
 Function Message(str text)
 	Data null=NULL
 	Call MessageBox(null,text,null,null)
 EndFunction
-include "./files/platform.s"
-Include "../files/functions.s"
+include "./files/platform.oc"
+Include "../files/functions.oc"
--- /dev/null
+++ ocompiler-1/src/windows/o.oc
@@ -0,0 +1,12 @@
+
+
+#windows exe build
+
+Format Exe
+
+Include "./files/winimports.h"
+
+Include "./head.h"
+
+entry main() #more at obj.oc
+Include "./text.oc"
--- ocompiler-1.orig/src/windows/o.s
+++ /dev/null
@@ -1,12 +0,0 @@
-
-
-#windows exe build
-
-Format Exe
-
-Include "./files/winimports.h"
-
-Include "./head.h"
-
-entry main() #more at obj.s
-Include "./text.s"
--- /dev/null
+++ ocompiler-1/src/windows/obj.oc
@@ -0,0 +1,13 @@
+
+Include "./head.h"
+
+#gcc(i686/x86_64) will ask for WinMain, but it has argc,argv entry, there are some additional steps
+#old remark: gcc want -8 at inplace instead of 0
+
+#gcc:
+#	int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR lpCmdLine, int nCmdShow)
+#but lpCmdLine is a structure, the string is after some bytes
+
+#Entry _WinMain@16()
+entry main()  #since .x , c and relocs (% and %%) is complicated
+	Include "./text.oc"
--- ocompiler-1.orig/src/windows/obj.s
+++ /dev/null
@@ -1,13 +0,0 @@
-
-Include "./head.h"
-
-#gcc(i686/x86_64) will ask for WinMain, but it has argc,argv entry, there are some additional steps
-#old remark: gcc want -8 at inplace instead of 0
-
-#gcc:
-#	int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR lpCmdLine, int nCmdShow)
-#but lpCmdLine is a structure, the string is after some bytes
-
-#Entry _WinMain@16()
-entry main()  #since .x , c and relocs (% and %%) is complicated
-	Include "./text.s"
--- /dev/null
+++ ocompiler-1/src/windows/obj32.oc
@@ -0,0 +1,8 @@
+
+
+#windows elf rel format
+
+Format ElfObj
+
+Include "./files/winobjimports.h"
+Include "./obj.oc"
--- ocompiler-1.orig/src/windows/obj32.s
+++ /dev/null
@@ -1,8 +0,0 @@
-
-
-#windows elf rel format
-
-Format ElfObj
-
-Include "./files/winobjimports.h"
-Include "./obj.s"
--- /dev/null
+++ ocompiler-1/src/windows/obj64.oc
@@ -0,0 +1,7 @@
+
+#windows elf rel format, with 64 code
+
+Format ElfObj64
+
+Include "./files/winobj64imports.h"
+Include "./obj.oc"
--- ocompiler-1.orig/src/windows/obj64.s
+++ /dev/null
@@ -1,7 +0,0 @@
-
-#windows elf rel format, with 64 code
-
-Format ElfObj64
-
-Include "./files/winobj64imports.h"
-Include "./obj.s"
--- /dev/null
+++ ocompiler-1/src/windows/text.oc
@@ -0,0 +1,23 @@
+
+
+#main
+
+Include "../files/inits_top.oc"
+
+set argv (NULL)
+Data openfilenamemethod#1
+Set openfilenamemethod false
+Include "./files/wingetfile.oc"
+
+if argv!=(NULL)
+	setcall errormsg comline_parse(argc,argv)
+	if errormsg!=(noerror)
+		call msgerrexit(errormsg)
+	endif
+endif
+
+Include "../files/actions.oc"
+
+Include "./files/winend.oc"
+
+Call exit(zero)
--- ocompiler-1.orig/src/windows/text.s
+++ /dev/null
@@ -1,23 +0,0 @@
-
-
-#main
-
-Include "../files/inits_top.s"
-
-set argv (NULL)
-Data openfilenamemethod#1
-Set openfilenamemethod false
-Include "./files/wingetfile.s"
-
-if argv!=(NULL)
-	setcall errormsg comline_parse(argc,argv)
-	if errormsg!=(noerror)
-		call msgerrexit(errormsg)
-	endif
-endif
-
-Include "../files/actions.s"
-
-Include "./files/winend.s"
-
-Call exit(zero)
--- ocompiler-1.orig/tests/a
+++ ocompiler-1/tests/a
@@ -7,9 +7,9 @@ OFLAGS+=" nul_res_pref 1"
 
 comp () {
 	if [ "${edb}" = "0" ]; then
-		edb --run ${OCOMP} ${1}.s ${OFLAGS} || exit 1
+		edb --run ${OCOMP} ${1}.oc ${OFLAGS} || exit 1
 	else
-		${OCOMP} ${1}.s ${OFLAGS} || exit 1
+		${OCOMP} ${1}.oc ${OFLAGS} || exit 1
 	fi
 }
 if [ -z "${ex}" ]; then
@@ -25,7 +25,7 @@ if [ -z "${ex}" ]; then
 	objs=
 	for f in "${@}"; do
 		comp ${f}
-		logs+=" ${f}.s.log"
+		logs+=" ${f}.oc.log"
 		objs+=" ${f}.o"
 	done
 	${OLINK} ${logs} || exit 1
--- /dev/null
+++ ocompiler-1/tests/acall/32.oc
@@ -0,0 +1,8 @@
+
+format elfobj
+
+importx "printf" printf
+
+include "a.oc"
+
+exit 0
--- ocompiler-1.orig/tests/acall/32.s
+++ /dev/null
@@ -1,8 +0,0 @@
-
-format elfobj
-
-importx "printf" printf
-
-include "a.s"
-
-exit 0
--- /dev/null
+++ ocompiler-1/tests/acall/32w.oc
@@ -0,0 +1,8 @@
+
+format elfobj
+
+importx "_printf" printf
+
+include "a.oc"
+
+return 0
--- ocompiler-1.orig/tests/acall/32w.s
+++ /dev/null
@@ -1,8 +0,0 @@
-
-format elfobj
-
-importx "_printf" printf
-
-include "a.s"
-
-return 0
--- /dev/null
+++ ocompiler-1/tests/acall/64.oc
@@ -0,0 +1,8 @@
+
+format elfobj64
+
+importx "printf" printf
+
+include "a.oc"
+
+return 0
--- ocompiler-1.orig/tests/acall/64.s
+++ /dev/null
@@ -1,8 +0,0 @@
-
-format elfobj64
-
-importx "printf" printf
-
-include "a.s"
-
-return 0
--- /dev/null
+++ ocompiler-1/tests/acall/a.oc
@@ -0,0 +1,26 @@
+
+vdata *=0
+
+#aftercall test
+aftercall *test
+
+function a()
+	call b()
+	call c()
+endfunction
+
+function b()
+	call printf("test\n")
+endfunction
+function c()
+	call printf("test2\n")
+endfunction
+
+entry main()
+value &e^a
+#i3
+call e()
+aftercallenable
+call e()
+aftercalldisable
+call e()
--- ocompiler-1.orig/tests/acall/a.s
+++ /dev/null
@@ -1,26 +0,0 @@
-
-vdata *=0
-
-#aftercall test
-aftercall *test
-
-function a()
-	call b()
-	call c()
-endfunction
-
-function b()
-	call printf("test\n")
-endfunction
-function c()
-	call printf("test2\n")
-endfunction
-
-entry main()
-value &e^a
-#i3
-call e()
-aftercallenable
-call e()
-aftercalldisable
-call e()
--- /dev/null
+++ ocompiler-1/tests/acall/b.oc
@@ -0,0 +1,4 @@
+
+format elfobj64
+
+aftercallimport test #com
--- ocompiler-1.orig/tests/acall/b.s
+++ /dev/null
@@ -1,4 +0,0 @@
-
-format elfobj64
-
-importaftercall test #com
--- /dev/null
+++ ocompiler-1/tests/acall/e.oc
@@ -0,0 +1,9 @@
+
+format elf
+
+library "libc.so.6"
+importx "printf" printf
+
+include "a.oc"
+
+exit 0
--- ocompiler-1.orig/tests/acall/e.s
+++ /dev/null
@@ -1,9 +0,0 @@
-
-format elf
-
-library "libc.so.6"
-importx "printf" printf
-
-include "a.s"
-
-exit 0
--- /dev/null
+++ ocompiler-1/tests/acall/ew.oc
@@ -0,0 +1,7 @@
+
+library "msvcrt.dll"
+importx "printf" printf
+
+include "a.oc"
+
+return 0
--- ocompiler-1.orig/tests/acall/ew.s
+++ /dev/null
@@ -1,7 +0,0 @@
-
-library "msvcrt.dll"
-importx "printf" printf
-
-include "a.s"
-
-return 0
--- /dev/null
+++ ocompiler-1/tests/call/call-ret.oc
@@ -0,0 +1,13 @@
+
+format elfobj64
+
+function a()
+endfunction
+
+entry main()
+
+sv b
+hex 144;call a()
+hex 144;callex a b 2
+hex 144;callret a()
+hex 144;callexret a b 2
--- ocompiler-1.orig/tests/call/call-ret.s
+++ /dev/null
@@ -1,13 +0,0 @@
-
-format elfobj64
-
-function a()
-endfunction
-
-entry main()
-
-sv b
-hex 144;call a()
-hex 144;callex a b 2
-hex 144;callret a()
-hex 144;callexret a b 2
--- /dev/null
+++ ocompiler-1/tests/call/call-var.oc
@@ -0,0 +1,11 @@
+
+format elfobj
+
+data a#1
+call a()
+vdata c#1
+call c()
+value e#1
+call e()
+sv h#1
+call h()
--- ocompiler-1.orig/tests/call/call-var.s
+++ /dev/null
@@ -1,11 +0,0 @@
-
-format elfobj
-
-data a#1
-call a()
-vdata c#1
-call c()
-value e#1
-call e()
-sv h#1
-call h()
--- /dev/null
+++ ocompiler-1/tests/call/call-var64.oc
@@ -0,0 +1,11 @@
+
+format elfobj64
+
+data a#1
+#call a()
+vdata c#1
+#call c()
+value e#1
+call e()
+sv h#1
+call h()
--- ocompiler-1.orig/tests/call/call-var64.s
+++ /dev/null
@@ -1,11 +0,0 @@
-
-format elfobj64
-
-data a#1
-#call a()
-vdata c#1
-#call c()
-value e#1
-call e()
-sv h#1
-call h()
--- /dev/null
+++ ocompiler-1/tests/call/callg.oc
@@ -0,0 +1,26 @@
+
+format elfobj64
+
+aftercall z
+
+sv a
+
+hex 144,144
+call a()
+hex 144
+callg a()
+
+hex 144,144
+callex a a a
+hex 144
+callexg a a a
+
+hex 144,144
+set a a()
+hex 144
+setg a a()
+
+hex 144,144
+setx a a()
+hex 144
+setxg a a()
--- ocompiler-1.orig/tests/call/callg.s
+++ /dev/null
@@ -1,26 +0,0 @@
-
-format elfobj64
-
-aftercall z
-
-sv a
-
-hex 144,144
-call a()
-hex 144
-callg a()
-
-hex 144,144
-callex a a a
-hex 144
-callexg a a a
-
-hex 144,144
-set a a()
-hex 144
-setg a a()
-
-hex 144,144
-setx a a()
-hex 144
-setxg a a()
--- /dev/null
+++ ocompiler-1/tests/call/callx.oc
@@ -0,0 +1,14 @@
+
+format elfobj64
+
+value a#1
+function b()
+endfunction
+
+entry main()
+hex 144;call a(1)
+hex 144;call b(1)
+hex 144;callx a(1)
+hex 144;callx b(1)
+hex 144;setxcall a b(2)
+i3
--- ocompiler-1.orig/tests/call/callx.s
+++ /dev/null
@@ -1,14 +0,0 @@
-
-format elfobj64
-
-value a#1
-function b()
-endfunction
-
-entry main()
-hex 144;call a(1)
-hex 144;call b(1)
-hex 144;callx a(1)
-hex 144;callx b(1)
-hex 144;setxcall a b(2)
-i3
--- /dev/null
+++ ocompiler-1/tests/comments.oc
@@ -0,0 +1,18 @@
+
+include "comments.h"
+
+     #wqeqweqwe
+
+     #!
+qwe
+ !
+
+entry test()    #123
+
+sd a=1  #456
+set a a ##789
+set a 1 #abc
+
+#def
+
+#!zz
--- ocompiler-1.orig/tests/comments.s
+++ /dev/null
@@ -1,18 +0,0 @@
-
-include "comments.h"
-
-     #wqeqweqwe
-
-     #!
-qwe
- !
-
-entry test()    #123
-
-sd a=1  #456
-set a a ##789
-set a 1 #abc
-
-#def
-
-#!zz
--- /dev/null
+++ ocompiler-1/tests/cond.oc
@@ -0,0 +1,26 @@
+
+format elfobj64
+entry main()
+if 1=1
+elseif 1=1
+endelseif
+while 1=1
+break
+continue
+endwhile
+
+if 1>=^1
+elseif 1<^1
+elseif 1!=1
+elseif 1=1
+elseif 1>^1
+elseif 1<=^1
+elseif 1>=1
+elseif 1<1
+elseif 1>1
+elseif 1<=1
+endelseif
+if 4!1
+end
+if 2!!1
+end
--- ocompiler-1.orig/tests/cond.s
+++ /dev/null
@@ -1,26 +0,0 @@
-
-format elfobj64
-entry main()
-if 1=1
-elseif 1=1
-endelseif
-while 1=1
-break
-continue
-endwhile
-
-if 1>=^1
-elseif 1<^1
-elseif 1!=1
-elseif 1=1
-elseif 1>^1
-elseif 1<=^1
-elseif 1>=1
-elseif 1<1
-elseif 1>1
-elseif 1<=1
-endelseif
-if 4!1
-end
-if 2!!1
-end
--- /dev/null
+++ ocompiler-1/tests/declare.oc
@@ -0,0 +1,35 @@
+
+format elfobj64
+
+char a=~-1-(~1+1)
+
+data b={2,2}
+
+value c%1
+sv d
+value *d#1
+value &dd^c
+
+str e#1
+vstr f#1
+ss g="qweqwe"
+
+vdata h#1
+sd i#1
+
+const j=1
+
+#value k%
+value k%%1
+
+valuex l#1
+
+#return 1+
+return 1+1
+
+vstr *z="123"
+value *z^dd
+
+word w^a
+vword ww^a
+sw www^a
--- ocompiler-1.orig/tests/declare.s
+++ /dev/null
@@ -1,35 +0,0 @@
-
-format elfobj64
-
-char a=~-1-(~1+1)
-
-data b={2,2}
-
-value c%1
-sv d
-value *d#1
-value &dd^c
-
-str e#1
-vstr f#1
-ss g="qweqwe"
-
-vdata h#1
-sd i#1
-
-const j=1
-
-#value k%
-value k%%1
-
-valuex l#1
-
-#return 1+
-return 1+1
-
-vstr *z="123"
-value *z^dd
-
-word w^a
-vword ww^a
-sw www^a
--- /dev/null
+++ ocompiler-1/tests/declareN.oc
@@ -0,0 +1,22 @@
+
+format elfobj64
+
+function b()
+char a=1
+value aa^a
+return aa#s^
+endfunction
+
+#const a=\b.a\
+const a=1
+
+char *z=:
+char *z=\
+char *z=\\
+char *z=1
+char *z=0xf
+char *z=a
+char *z=\b
+char *z=\\b
+char *z=\b.a
+char *z=\b.a\
--- ocompiler-1.orig/tests/declareN.s
+++ /dev/null
@@ -1,22 +0,0 @@
-
-format elfobj64
-
-function b()
-char a=1
-value aa^a
-return aa#s^
-endfunction
-
-#const a=\b.a\
-const a=1
-
-char *z=:
-char *z=\
-char *z=\\
-char *z=1
-char *z=0xf
-char *z=a
-char *z=\b
-char *z=\\b
-char *z=\b.a
-char *z=\b.a\
--- /dev/null
+++ ocompiler-1/tests/decocthex.oc
@@ -0,0 +1,10 @@
+
+#data *=2147483648
+data *=-2147483648
+#data *=0x000000000000000000000000000000000000000001FFffFFff
+data * =0x000000000000000000000000000000000000000000FFffFFff
+data * =000000000000000000000000000
+#data *=00000000000777777777777
+#data *=0000000000077777777777
+data * =0000000000037777777777
+data * =0000000000017777777777
--- ocompiler-1.orig/tests/decocthex.s
+++ /dev/null
@@ -1,10 +0,0 @@
-
-#data *=2147483648
-data *=-2147483648
-#data *=0x000000000000000000000000000000000000000001FFffFFff
-data * =0x000000000000000000000000000000000000000000FFffFFff
-data * =000000000000000000000000000
-#data *=00000000000777777777777
-#data *=0000000000077777777777
-data * =0000000000037777777777
-data * =0000000000017777777777
--- /dev/null
+++ ocompiler-1/tests/div.oc
@@ -0,0 +1,22 @@
+
+format elfobj64
+
+char a#1
+data b#1
+value c#1
+
+entry main()
+
+hex 144,144,144,144//1
+div a a
+hex 144,144,144,144%%999
+div b b
+hex 144,144,144,144
+div c c
+
+hex 144,144,144,144
+divu a a
+hex 144,144,144,144
+divu b b
+hex 144,144,144,144
+divu c c
--- ocompiler-1.orig/tests/div.s
+++ /dev/null
@@ -1,22 +0,0 @@
-
-format elfobj64
-
-char a#1
-data b#1
-value c#1
-
-entry main()
-
-hex 144,144,144,144//1
-div a a
-hex 144,144,144,144%%999
-div b b
-hex 144,144,144,144
-div c c
-
-hex 144,144,144,144
-divu a a
-hex 144,144,144,144
-divu b b
-hex 144,144,144,144
-divu c c
--- /dev/null
+++ ocompiler-1/tests/end.oc
@@ -0,0 +1,16 @@
+
+format elfobj
+
+function a()
+	while 1=2
+		if 3=4
+		elseif 5=6
+		end
+		if 7=8
+		else
+		end
+		if 9=10
+			break
+		end
+	end
+end
--- ocompiler-1.orig/tests/end.s
+++ /dev/null
@@ -1,16 +0,0 @@
-
-format elfobj
-
-function a()
-	while 1=2
-		if 3=4
-		elseif 5=6
-		end
-		if 7=8
-		else
-		end
-		if 9=10
-			break
-		end
-	end
-end
--- /dev/null
+++ ocompiler-1/tests/function.oc
@@ -0,0 +1,13 @@
+
+format elfobj
+
+function test(char a,data b,str c,value d,sv e,vstr f,ss g,vdata h,sd i,valuex j)
+endfunction
+
+functionx test2()
+endfunction
+
+functionxx test3()
+endfunction
+
+entry test4(word a,vword b,sw c)
--- ocompiler-1.orig/tests/function.s
+++ /dev/null
@@ -1,13 +0,0 @@
-
-format elfobj
-
-function test(char a,data b,str c,value d,sv e,vstr f,ss g,vdata h,sd i,valuex j)
-endfunction
-
-functionx test2()
-endfunction
-
-functionxx test3()
-endfunction
-
-entry test4(word a,vword b,sw c)
--- /dev/null
+++ ocompiler-1/tests/function2.oc
@@ -0,0 +1,2 @@
+
+entryraw test()
--- ocompiler-1.orig/tests/function2.s
+++ /dev/null
@@ -1,2 +0,0 @@
-
-entryraw test()
--- /dev/null
+++ ocompiler-1/tests/hex.oc
@@ -0,0 +1,2 @@
+
+hex 1,2,3
\ No newline at end of file
--- ocompiler-1.orig/tests/hex.s
+++ /dev/null
@@ -1,2 +0,0 @@
-
-hex 1,2,3
\ No newline at end of file
--- /dev/null
+++ ocompiler-1/tests/include.oc
@@ -0,0 +1,7 @@
+
+include "include.h"
+einclude "include.h" "fakefile"
+
+override include_sec 1
+include "include.h"
+include "fakefile" "include.h"
--- ocompiler-1.orig/tests/include.s
+++ /dev/null
@@ -1,7 +0,0 @@
-
-include "include.h"
-einclude "include.h" "fakefile"
-
-override include_sec 1
-include "include.h"
-include "fakefile" "include.h"
--- /dev/null
+++ ocompiler-1/tests/offsetofvar.oc
@@ -0,0 +1,27 @@
+
+format elfobj64
+
+data *#7
+data b#1
+
+function a()
+data *#3
+data b#1
+datax *#5
+datax c#1
+sd *
+sd d
+endfunction
+
+entry main()
+
+importx "printf" printf
+
+vstr info="%d\n"
+
+call printf(info,(\a.b\))    #12
+call printf(info,(\a.c\))    #20
+call printf(info,(\a.d\))    #8
+call printf(info,(\main.b\)) #28
+
+return 0
--- ocompiler-1.orig/tests/offsetofvar.s
+++ /dev/null
@@ -1,27 +0,0 @@
-
-format elfobj64
-
-data *#7
-data b#1
-
-function a()
-data *#3
-data b#1
-datax *#5
-datax c#1
-sd *
-sd d
-endfunction
-
-entry main()
-
-importx "printf" printf
-
-vstr info="%d\n"
-
-call printf(info,(\a.b\))    #12
-call printf(info,(\a.c\))    #20
-call printf(info,(\a.d\))    #8
-call printf(info,(\main.b\)) #28
-
-return 0
--- /dev/null
+++ ocompiler-1/tests/onearg.oc
@@ -0,0 +1,26 @@
+
+format elfobj64
+
+function b()
+data a#1
+endfunction
+
+entry main()
+
+vstr a="qwer"
+
+return 2
+inc #a:b.a
+inc #a
+incst #b.a
+dec a
+decst a
+neg a
+not a
+shl1 a
+shr1 a
+sar1 b.a
+exit 3
+return "asdf"
+return main.a#:a
+return b
--- ocompiler-1.orig/tests/onearg.s
+++ /dev/null
@@ -1,26 +0,0 @@
-
-format elfobj64
-
-function b()
-data a#1
-endfunction
-
-entry main()
-
-vstr a="qwer"
-
-return 2
-inc #a:b.a
-inc #a
-incst #b.a
-dec a
-decst a
-neg a
-not a
-shl1 a
-shr1 a
-sar1 b.a
-exit 3
-return "asdf"
-return main.a#:a
-return b
--- /dev/null
+++ ocompiler-1/tests/operations.oc
@@ -0,0 +1,24 @@
+
+format elfobj
+
+const a=1
+#               add sub mul div   divu           rem   remu     pow and or  xor not shl1 sar1  shr1   equal inequal less greater lessEqual greaterEqual logicalAnd logicalOr unsignedLess  unsignedGreater unsignedLessEqual unsignedGreaterEqual parity odd  neg
+char *examples={3+2,6-4,5*5,32/10,-1//0x10000000,32%10,-1%%0x10,3$2,7&2,5|2,7^2,~0, 2<<2,8>>3,-1>>>25,7=7,  7!=7,   2<3, 2>3,    9<=9,     9>=9,        1&&0,      0||1,     1<^0xffFFffFF,1>^0xffFFffFF,  -1<=^-2,          -1>=^0,              4!1,   2!!1,-a}
+#hex:           5   2   19  3     f              2     f        9     2 7   5   ff  8    1     7f     1     0       1    0       1         1            0          1         1             0               0                 1                    1      1    ff
+
+override w_as_e 0
+data *overflows=2$31  #80..
+data *=2$32           #0    overflow
+data *=2$33           #0    1 overflow message
+data *=1<<31          #80..
+data *=1<<32          #0    overflow
+data *=0<<1111        #0    direct
+data *=0x80000000>>31 #ff..
+data *=0x80000000>>32 #ff.. direct
+data *=0x40000000>>31 #0    direct
+data *=0x80000000>>>31#1
+data *=0x80000000>>>32#0    direct
+data *=0xffFFffFE+1   #ff
+data *=0xffFFffFE+2   #0    overflow
+data *=0x40000000*2   #80
+data *=0x40000000*4   #00   overflow
--- ocompiler-1.orig/tests/operations.s
+++ /dev/null
@@ -1,24 +0,0 @@
-
-format elfobj
-
-const a=1
-#               add sub mul div   divu           rem   remu     pow and or  xor not shl1 sar1  shr1   equal inequal less greater lessEqual greaterEqual logicalAnd logicalOr unsignedLess  unsignedGreater unsignedLessEqual unsignedGreaterEqual parity odd  neg
-char *examples={3+2,6-4,5*5,32/10,-1//0x10000000,32%10,-1%%0x10,3$2,7&2,5|2,7^2,~0, 2<<2,8>>3,-1>>>25,7=7,  7!=7,   2<3, 2>3,    9<=9,     9>=9,        1&&0,      0||1,     1<^0xffFFffFF,1>^0xffFFffFF,  -1<=^-2,          -1>=^0,              4!1,   2!!1,-a}
-#hex:           5   2   19  3     f              2     f        9     2 7   5   ff  8    1     7f     1     0       1    0       1         1            0          1         1             0               0                 1                    1      1    ff
-
-override w_as_e 0
-data *overflows=2$31  #80..
-data *=2$32           #0    overflow
-data *=2$33           #0    1 overflow message
-data *=1<<31          #80..
-data *=1<<32          #0    overflow
-data *=0<<1111        #0    direct
-data *=0x80000000>>31 #ff..
-data *=0x80000000>>32 #ff.. direct
-data *=0x40000000>>31 #0    direct
-data *=0x80000000>>>31#1
-data *=0x80000000>>>32#0    direct
-data *=0xffFFffFE+1   #ff
-data *=0xffFFffFE+2   #0    overflow
-data *=0x40000000*2   #80
-data *=0x40000000*4   #00   overflow
--- /dev/null
+++ ocompiler-1/tests/pass_call.oc
@@ -0,0 +1,17 @@
+
+format elfobj64
+
+importx "q" q
+
+function a()
+call q(q,q,q,q,q,q,q)
+call q(q,q,q,q,q,q,q)
+call q(q,q,q,q,q,q,q,q)
+endfunction
+
+function b()
+sv test
+call q()
+endfunction
+
+entry main()
--- /dev/null
+++ ocompiler-1/tests/primsec.oc
@@ -0,0 +1,15 @@
+
+format elfobj64
+
+value a=0
+
+set a 1
+add a 2
+sub a 3
+mult a 4
+div a 5
+rem a 6
+and a 7
+or a 8
+xor a a(a,a)
+xorxcall a a(a,a)
--- ocompiler-1.orig/tests/primsec.s
+++ /dev/null
@@ -1,15 +0,0 @@
-
-format elfobj64
-
-value a=0
-
-set a 1
-add a 2
-sub a 3
-mult a 4
-div a 5
-rem a 6
-and a 7
-or a 8
-xor a a(a,a)
-xorxcall a a(a,a)
--- /dev/null
+++ ocompiler-1/tests/ret.oc
@@ -0,0 +1,21 @@
+
+format elfobj
+
+orphan off #test
+
+function end_ret_test0()
+ret
+endfunction
+function end_ret_test1()
+return 15
+endfunction
+function end_ret_test2()
+endfunction
+
+entry main()
+ret
+override exit_end 1
+ret
+override exit_end 0 #test
+ret
+exit 2
--- ocompiler-1.orig/tests/ret.s
+++ /dev/null
@@ -1,16 +0,0 @@
-
-format elfobj
-
-orphan off #test
-
-function inner()
-ret
-endfunction
-
-entry main()
-ret
-override exit_end 1
-ret
-override exit_end 0 #test
-ret
-exit 2
--- /dev/null
+++ ocompiler-1/tests/sizeoffn.oc
@@ -0,0 +1,37 @@
+
+format elfobj64
+
+importx "printf" printf
+
+#data *#\main  #\ error
+data *#1;datax *#1;data *#2
+
+vstr p="%u\n"
+
+function f1()
+data *#1;datax *#2;data *#2
+call printf(main.p,(\\f1))   #8
+call printf(main.p,(\f1))    #12
+data *#1;datax *#1
+endfunction
+
+data *#1;datax *#3;data *#2
+
+function f2()
+data *#1;datax *#4;data *#1
+call printf(main.p,(\\f1))   #12
+call printf(main.p,(\f1))    #16
+call printf(main.p,(\\main)) #16
+call printf(main.p,(\main))  #36
+endfunction
+
+data *#1;datax *#1
+
+entry main()
+#const not_here=\\f1         #same error
+call f1()
+call f2()
+
+call printf(p,(\\main))        #20
+call printf(p,(\main))        #40
+return 0
--- ocompiler-1.orig/tests/sizeoffn.s
+++ /dev/null
@@ -1,37 +0,0 @@
-
-format elfobj64
-
-importx "printf" printf
-
-#data *#\main  #\ error
-data *#1;datax *#1;data *#2
-
-vstr p="%u\n"
-
-function f1()
-data *#1;datax *#2;data *#2
-call printf(main.p,(\\f1))   #8
-call printf(main.p,(\f1))    #12
-data *#1;datax *#1
-endfunction
-
-data *#1;datax *#3;data *#2
-
-function f2()
-data *#1;datax *#4;data *#1
-call printf(main.p,(\\f1))   #12
-call printf(main.p,(\f1))    #16
-call printf(main.p,(\\main)) #16
-call printf(main.p,(\main))  #36
-endfunction
-
-data *#1;datax *#1
-
-entry main()
-#const not_here=\\f1         #same error
-call f1()
-call f2()
-
-call printf(p,(\\main))        #20
-call printf(p,(\main))        #40
-return 0
--- /dev/null
+++ ocompiler-1/tests/sizeofvar.oc
@@ -0,0 +1,37 @@
+
+format elfobj64
+
+importx "printf" printf
+
+entry main()
+
+char a=1
+data b=2
+value c=3
+vdata d=1
+vstr e=1
+
+sv f=1
+
+char g#66123
+
+charx aa#2
+datax bb#3
+valuex cc#4
+
+call printf("%d\n",(\main.a))  #1
+call printf("%d\n",(\main.b))  #4
+call printf("%d\n",(\main.c))  #8
+call printf("%d\n",(\main.c#)) #8
+call printf("%d\n",(\main.d#)) #4
+call printf("%d\n",(\main.e#)) #1
+
+call printf("%d\n",(\main.f))  #8
+call printf("%d\n",(\main.f#)) #8
+
+call printf("%d\n",(\main.aa)) #2
+call printf("%d\n",(\main.bb)) #12
+call printf("%d\n",(\main.cc)) #32
+
+#return (\main.g)    #error
+return 0
--- ocompiler-1.orig/tests/sizeofvar.s
+++ /dev/null
@@ -1,37 +0,0 @@
-
-format elfobj64
-
-importx "printf" printf
-
-entry main()
-
-char a=1
-data b=2
-value c=3
-vdata d=1
-vstr e=1
-
-sv f=1
-
-char g#66123
-
-charx aa#2
-datax bb#3
-valuex cc#4
-
-call printf("%d\n",(\main.a))  #1
-call printf("%d\n",(\main.b))  #4
-call printf("%d\n",(\main.c))  #8
-call printf("%d\n",(\main.c#)) #8
-call printf("%d\n",(\main.d#)) #4
-call printf("%d\n",(\main.e#)) #1
-
-call printf("%d\n",(\main.f))  #8
-call printf("%d\n",(\main.f#)) #8
-
-call printf("%d\n",(\main.aa)) #2
-call printf("%d\n",(\main.bb)) #12
-call printf("%d\n",(\main.cc)) #32
-
-#return (\main.g)    #error
-return 0
--- /dev/null
+++ ocompiler-1/tests/template.oc
@@ -0,0 +1,45 @@
+
+format elfobj64
+
+valuex x#1
+valuex y#1
+
+function file()
+	valuex path#1
+	valuex lines#1
+	datax a#1
+endfunction
+
+function line()
+	datax a#1
+endfunction
+
+entry main(sd *,sd c)
+sd *#1
+sd n#1
+sd nn#1
+value *=0x77
+value test#1;value test2#1;data a#1
+sv aux^test
+value auxdata^test
+
+set test:file.a 4
+set test:line.a 4
+
+set n:main.n 4
+add n:main.c 4
+
+set test:main.y 4
+add test:y 4
+add test:main.test 4
+add test:test 4
+
+#not this right now
+#set aux#:file.a 4
+set auxdata#:file.a 4
+
+set aux#:file.path 2
+add aux#:file.lines 2
+add test test2
+add test nn
+return test    ##28
--- ocompiler-1.orig/tests/template.s
+++ /dev/null
@@ -1,45 +0,0 @@
-
-format elfobj64
-
-valuex x#1
-valuex y#1
-
-function file()
-	valuex path#1
-	valuex lines#1
-	datax a#1
-endfunction
-
-function line()
-	datax a#1
-endfunction
-
-entry main(sd *,sd c)
-sd *#1
-sd n#1
-sd nn#1
-value *=0x77
-value test#1;value test2#1;data a#1
-sv aux^test
-value auxdata^test
-
-set test:file.a 4
-set test:line.a 4
-
-set n:main.n 4
-add n:main.c 4
-
-set test:main.y 4
-add test:y 4
-add test:main.test 4
-add test:test 4
-
-#not this right now
-#set aux#:file.a 4
-set auxdata#:file.a 4
-
-set aux#:file.path 2
-add aux#:file.lines 2
-add test test2
-add test nn
-return test    ##28
--- /dev/null
+++ ocompiler-1/tests/unref.oc
@@ -0,0 +1,7 @@
+
+format elfobj64
+
+include "unref.h"
+
+entry main()
+return a.d
--- ocompiler-1.orig/tests/unref.s
+++ /dev/null
@@ -1,7 +0,0 @@
-
-format elfobj64
-
-include "unref.h"
-
-entry main()
-return a.d
--- /dev/null
+++ ocompiler-1/tests/unref2.oc
@@ -0,0 +1,6 @@
+
+format elfobj64
+
+include "unref.h"
+
+call a(a.c,(b))
--- ocompiler-1.orig/tests/unref2.s
+++ /dev/null
@@ -1,6 +0,0 @@
-
-format elfobj64
-
-include "unref.h"
-
-call a(a.c,(b))
