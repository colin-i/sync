Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 sirc (1-jammy12) jammy; urgency=medium
 .
   * organizer
Author: bc <bc@bc-Type1ProductConfigId>

---
The information above should follow the Patch Tagging Guidelines, please
checkout https://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: (upstream|backport|vendor|other), (<patch-url>|commit:<commit-id>)
Bug: <upstream-bugtracker-url>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: (no|not-needed|<patch-forwarded-url>)
Applied-Upstream: <version>, (<commit-url>|commit:<commid-id>)
Reviewed-By: <name and email of someone who approved/reviewed the patch>
Last-Update: 2024-02-23

--- sirc-1.orig/configure.ac
+++ sirc-1/configure.ac
@@ -29,7 +29,7 @@ AC_MSG_RESULT($enable_cflags_setting)
 
 #AC_DEFINE_UNQUOTED(HOMEDIR,[$(echo "\"$(cd ~; pwd)/\"")],[~ cannot be "q q"])
 AC_PROG_CC
-AC_CHECK_HEADERS(libgen.h fcntl.h netdb.h netinet/in.h openssl/ssl.h pthread.h signal.h stdio.h stdlib.h string.h sys/socket.h time.h unistd.h)
+AC_CHECK_HEADERS(libgen.h fcntl.h netdb.h netinet/in.h openssl/ssl.h pthread.h signal.h stdio.h stdlib.h string.h sys/socket.h sys/stat.h time.h unistd.h)
 #limits.h
 
 start_cflgs="$CFLAGS"
--- sirc-1.orig/headless
+++ sirc-1/headless
@@ -2,10 +2,25 @@
 #1 remove
 
 cp Makefile mk
-a="\-DHAVE_STDIO_H=1 \-DHAVE_STDLIB_H=1 \-DHAVE_STRING_H=1 \-DHAVE_INTTYPES_H=1 \-DHAVE_STDINT_H=1 \-DHAVE_STRINGS_H=1 \-DHAVE_SYS_STAT_H=1 \-DHAVE_SYS_TYPES_H=1 \-DHAVE_UNISTD_H=1 \-DSTDC_HEADERS=1 \-DHAVE_LIBGEN_H=1 \-DHAVE_FCNTL_H=1 \-DHAVE_NETDB_H=1 \-DHAVE_NETINET_IN_H=1 \-DHAVE_OPENSSL_SSL_H=1 \-DHAVE_PTHREAD_H=1 \-DHAVE_SIGNAL_H=1 \-DHAVE_STDIO_H=1 \-DHAVE_STDLIB_H=1 \-DHAVE_STRING_H=1 \-DHAVE_SYS_SOCKET_H=1 \-DHAVE_TIME_H=1 \-DHAVE_UNISTD_H=1 \-DFN_G_MEMDUP2=1 \-DHAVE_GTK_GTK_H=1"
+
+#replace common headers that are coming from a script
+a="\-DHAVE_STDIO_H=1 \-DHAVE_STDLIB_H=1 \-DHAVE_STRING_H=1 \-DHAVE_INTTYPES_H=1 \-DHAVE_STDINT_H=1 \-DHAVE_STRINGS_H=1 \-DHAVE_SYS_STAT_H=1 \-DHAVE_SYS_TYPES_H=1 \-DHAVE_UNISTD_H=1 \-DSTDC_HEADERS=1"
+grep --color "${a}" mk
+sed -i "s/${a}//g" mk
+grep --color "${a}" mk
+
+#replace our headers
+a="\-DHAVE_LIBGEN_H=1 \-DHAVE_FCNTL_H=1 \-DHAVE_NETDB_H=1 \-DHAVE_NETINET_IN_H=1 \-DHAVE_OPENSSL_SSL_H=1 \-DHAVE_PTHREAD_H=1 \-DHAVE_SIGNAL_H=1 \-DHAVE_STDIO_H=1 \-DHAVE_STDLIB_H=1 \-DHAVE_STRING_H=1 \-DHAVE_SYS_SOCKET_H=1 \-DHAVE_SYS_STAT_H=1 \-DHAVE_TIME_H=1 \-DHAVE_UNISTD_H=1 \-DFN_G_MEMDUP2=1 \-DHAVE_GTK_GTK_H=1"
 grep --color "${a}" mk
 sed -i "s/${a}//g" mk
 grep --color "${a}" mk
+
+#replace c only headers
+a="\-DHAVE_STDBOOL_H=1 \-DHAVE_STDDEF_H=1"
+grep --color "${a}" mk
+sed -i "s/${a}//g" mk
+grep --color "${a}" mk
+
 make -f mk
 
 if [ -n "${1}" ]; then rm mk; fi
--- /dev/null
+++ sirc-1/icon.h
@@ -0,0 +1,8 @@
+
+static const unsigned char icon16[]={
+ 0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff
+,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff
+,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xff,0xff
+,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8
+//3840
+};
--- sirc-1.orig/inc/gtk.h
+++ sirc-1/inc/gtk.h
@@ -17,7 +17,9 @@ typedef gulong GType;
 typedef signed long long gint64;
 typedef double gdouble;
 typedef void GApplication;
+typedef void GClosure;
 typedef void GDateTime;
+typedef void GDir;
 typedef void GError;
 typedef void GVariant;
 typedef void GVariantDict;
@@ -37,6 +39,7 @@ typedef void GtkComboBox;
 typedef void GtkComboBoxText;
 typedef void GtkContainer;
 typedef void GtkDialog;
+typedef void GtkEditable;
 typedef void GtkEntry;
 typedef void GtkEntryBuffer;
 typedef void GtkLabel;
@@ -46,12 +49,15 @@ typedef void GtkMenuItem;
 typedef void GtkMenuShell;
 typedef void GtkNotebook;
 typedef void GtkPaned;
+typedef void GtkRadioButton;
 typedef void GtkRadioMenuItem;
 typedef void GtkScrolledWindow;
 typedef void GtkTextBuffer;
 typedef void GtkTextMark;
+typedef void GtkTreeSortable;
 typedef void GtkTextTagTable;
 typedef void GtkTextView;
+typedef void GtkToggleButton;
 typedef void GtkTooltip;
 typedef void GtkTreeModel;
 typedef void GtkTreePath;
@@ -67,10 +73,13 @@ typedef void *GClosureNotify;
 typedef void (*GDestroyNotify)(gpointer data);
 typedef void *GdkPixbufDestroyNotify;
 typedef gboolean(*GSourceFunc)(gpointer user_data);
+
 typedef enum{G_APPLICATION_FLAGS_NONE}
  GApplicationFlags;
 typedef enum{G_CONNECT_SWAPPED = 1 << 1}
-GConnectFlags;//_BEFORE G_CONNECT_AFTER = 1 << 0,
+ GConnectFlags;//_BEFORE G_CONNECT_AFTER = 1 << 0,
+typedef enum{  G_FILE_TEST_IS_DIR = 1 << 2 }// G_FILE_TEST_IS_REGULAR = 1 << 0,  G_FILE_TEST_IS_SYMLINK = 1 << 1,       ,  G_FILE_TEST_IS_EXECUTABLE = 1 << 3,  G_FILE_TEST_EXISTS = 1 << 4 }
+ GFileTest;
 typedef enum{  G_OPTION_ARG_NONE,  G_OPTION_ARG_STRING,  G_OPTION_ARG_INT,  G_OPTION_ARG_CALLBACK,  G_OPTION_ARG_FILENAME}//,  G_OPTION_ARG_STRING_ARRAY,  G_OPTION_ARG_FILENAME_ARRAY,  G_OPTION_ARG_DOUBLE,  G_OPTION_ARG_INT64
  GOptionArg;
 typedef enum{G_OPTION_FLAG_IN_MAIN = 1 << 1,G_OPTION_FLAG_OPTIONAL_ARG = 1 << 5}
@@ -84,25 +93,31 @@ typedef enum{GDK_KEY_PRESS = 8}
  GdkEventType;
 typedef enum{  GDK_GRAVITY_NORTH_WEST = 1}
  GdkGravity;
-typedef enum{GTK_ORIENTATION_HORIZONTAL,GTK_ORIENTATION_VERTICAL}
- GtkOrientation;
+typedef enum{ GTK_BUTTONS_NONE, GTK_BUTTONS_OK, GTK_BUTTONS_CLOSE, GTK_BUTTONS_CANCEL, GTK_BUTTONS_YES_NO }//, GTK_BUTTONS_OK_CANCEL }
+ GtkButtonsType;
 typedef enum{  GTK_DIALOG_MODAL = 1 << 0, GTK_DIALOG_DESTROY_WITH_PARENT = 1 << 1}//, GTK_DIALOG_USE_HEADER_BAR = 1 << 2
  GtkDialogFlags;
 typedef enum{  GTK_ICON_SIZE_INVALID,  GTK_ICON_SIZE_MENU}
  GtkIconSize;
-typedef enum{GDK_SHIFT_MASK = 1 << 0, GDK_LOCK_MASK = 1 << 1, GDK_CONTROL_MASK = 1 << 2}
+typedef enum{ GTK_MESSAGE_INFO, GTK_MESSAGE_WARNING, GTK_MESSAGE_QUESTION }
+ GtkMessageType;
+typedef enum{GDK_SHIFT_MASK = 1 << 0, GDK_CONTROL_MASK = 1 << 2} // GDK_LOCK_MASK = 1 << 1,
  GdkModifierType;
+typedef enum{GTK_ORIENTATION_HORIZONTAL,GTK_ORIENTATION_VERTICAL}
+ GtkOrientation;
 typedef enum{  GTK_PACK_START,  GTK_PACK_END}
  GtkPackType;
 typedef enum{  GTK_POLICY_ALWAYS,  GTK_POLICY_AUTOMATIC,  GTK_POLICY_NEVER,  GTK_POLICY_EXTERNAL}
  GtkPolicyType;
 typedef enum{  GTK_RELIEF_NORMAL,  GTK_RELIEF_HALF,  GTK_RELIEF_NONE}
  GtkReliefStyle;
-typedef enum{  GTK_RESPONSE_NONE = -1,GTK_RESPONSE_OK = -5}//, GTK_RESPONSE_REJECT = -2,GTK_RESPONSE_ACCEPT = -3,GTK_RESPONSE_DELETE_EVENT = -4
+typedef enum{ GTK_RESPONSE_NONE = -1, GTK_RESPONSE_OK = -5, GTK_RESPONSE_CANCEL = -6, GTK_RESPONSE_YES = -8 }//, GTK_RESPONSE_REJECT = -2,GTK_RESPONSE_ACCEPT = -3,GTK_RESPONSE_DELETE_EVENT = -4
  GtkResponseType;
+typedef enum{ GTK_SORT_ASCENDING,  GTK_SORT_DESCENDING }
+ GtkSortType;
 typedef enum{  GTK_WRAP_NONE,  GTK_WRAP_CHAR,  GTK_WRAP_WORD,  GTK_WRAP_WORD_CHAR}
  GtkWrapMode;
-typedef struct _GClosure GClosure;
+
 typedef struct _GList GList;
 struct _GList
 {
@@ -135,6 +150,14 @@ struct _GSList
   gpointer data;
   GSList *next;
 };
+typedef struct{
+  GType g_type;
+} GTypeClass;
+typedef struct{
+  GTypeClass *g_class;
+} GTypeInstance;
+
+typedef struct _GdkAtom *GdkAtom;
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wpadded"
 typedef struct GdkEventKey {
@@ -178,24 +201,19 @@ typedef struct _GtkTreeIter
   gpointer user_data2;
   gpointer user_data3;
 }GtkTreeIter;
-typedef struct{
-  GType g_type;
-} GTypeClass;
-typedef struct{
-  GTypeClass *g_class;
-} GTypeInstance;
-typedef struct _GdkAtom *GdkAtom;
 
 #define G_CALLBACK(f) ((GCallback)(f))
 #define G_TYPE_FROM_CLASS(g_class) (((GTypeClass*) (g_class))->g_type)
 #define G_TYPE_FROM_INSTANCE(instance) (G_TYPE_FROM_CLASS (((GTypeInstance*) (instance))->g_class))
 #define G_TYPE_FUNDAMENTAL_SHIFT (2)
 #define G_TYPE_MAKE_FUNDAMENTAL(x) ((GType) ((x) << G_TYPE_FUNDAMENTAL_SHIFT))
+#define G_TYPE_INT G_TYPE_MAKE_FUNDAMENTAL (6)
 #define G_TYPE_STRING G_TYPE_MAKE_FUNDAMENTAL (16)
 #define G_VARIANT_TYPE_STRING ((const GVariantType *) "s")
 #define GUINT_TO_POINTER(u) ((gpointer) (guint) (u))
 #define GDK_SELECTION_CLIPBOARD ((GdkAtom)GUINT_TO_POINTER(69))
 #define GDK_KEY_C 0x043
+#define GDK_KEY_O 0x04F
 #define GDK_KEY_Q 0x051
 #define GDK_KEY_T 0x054
 #define GDK_KEY_X 0x058
@@ -206,197 +224,231 @@ typedef struct _GdkAtom *GdkAtom;
 extern "C" {
 #endif
 
+//gio
 void g_application_add_main_option (GApplication *application, const char *long_name, char short_name, GOptionFlags flags, GOptionArg arg, const char *description, const char *arg_description);
 void g_application_add_main_option_entries (GApplication *application,const GOptionEntry *entries);
 void g_application_quit (GApplication *application);
-int g_application_run (GApplication *application,int argc,char **argv);
-gint g_date_time_get_hour (GDateTime *datetime);
-gint g_date_time_get_minute (GDateTime *datetime);
-gint g_date_time_get_second (GDateTime *datetime);
+int  g_application_run (GApplication *application,int argc,char **argv);
+
+//glib
+gint        g_date_time_get_hour (GDateTime *datetime);
+gint        g_date_time_get_minute (GDateTime *datetime);
+gint        g_date_time_get_second (GDateTime *datetime);
 GDateTime * g_date_time_new_now_local (void);
-gint64 g_date_time_to_unix (GDateTime *datetime);
-void g_date_time_unref (GDateTime *datetime);
-void g_free (gpointer mem);
+gint64      g_date_time_to_unix (GDateTime *datetime);
+void        g_date_time_unref (GDateTime *datetime);
+void         g_dir_close (GDir *dir);
+GDir *       g_dir_open (const gchar *path, guint flags, GError **error);
+const gchar *g_dir_read_name (GDir *dir);
+gboolean g_file_test (const gchar *filename, GFileTest test);
+void g_free (gpointer mem);//it isn't in general. g_free() frees a memory chunk with the registered free function in the GLib's memory VTable, which by default is libc's free() -- and then g_free() and free() are equivalent. But if for a reason or another the VTable is set to another one, a plain free() may be invalid since the memory may not have been allocated by libc's malloc(), calloc() or realloc().
 guint g_idle_add (GSourceFunc function,gpointer data);
-void g_list_free (GList *list);
-GList* g_list_last (GList *list);
+void    g_list_free (GList *list);
+GList*  g_list_last (GList *list);
 #define g_list_next(list) ((list) ? (((GList *)(list))->next) : nullptr)
+gchar *g_markup_printf_escaped (const char *format, ...);
 #ifdef FN_G_MEMDUP2
 	gpointer g_memdup2 (gconstpointer mem, gsize byte_size);
 #else
 	gpointer g_memdup (gconstpointer mem, guint byte_size);
 #endif
-gpointer g_object_ref (gpointer object);
-void g_object_set (gpointer object, const gchar *first_property_name, ...) __attribute__((__sentinel__));
-void g_object_unref (gpointer object);
-void g_queue_free_full (GQueue *queue,GDestroyNotify free_func);
-GQueue *g_queue_new (void);
-gpointer g_queue_pop_head (GQueue *queue);
-void g_queue_push_tail (GQueue *queue,gpointer data);
-gulong g_signal_connect_data (gpointer instance,const gchar *detailed_signal,GCallback c_handler,gpointer data,GClosureNotify destroy_data,GConnectFlags connect_flags);
-void g_signal_handler_block (gpointer instance, gulong handler_id);
-gulong g_signal_handler_find (gpointer instance,GSignalMatchType mask,guint signal_id,GQuark detail,GClosure *closure,gpointer func,gpointer data);
-void g_signal_handler_unblock (gpointer instance, gulong handler_id);
-guint g_signal_lookup (const gchar *name, GType itype);
+void      g_queue_free_full (GQueue *queue,GDestroyNotify free_func);
+GQueue *  g_queue_new (void);
+gpointer  g_queue_pop_head (GQueue *queue);
+void      g_queue_push_tail (GQueue *queue,gpointer data);
 gboolean g_source_remove (guint tag);
 gboolean g_spawn_command_line_async (const gchar *command_line, GError **error);
-gchar * g_strdup ( const gchar *str );
 guint g_timeout_add (guint interval, GSourceFunc function, gpointer data);
 char *g_uri_unescape_string (const char *escaped_string, const char *illegal_characters);
-gboolean g_variant_dict_contains (GVariantDict *dict, const gchar *key);
-gboolean g_variant_dict_lookup (GVariantDict *dict, const gchar *key, const gchar *format_string, ...);
-GVariant * g_variant_dict_lookup_value (GVariantDict *dict, const gchar *key, const GVariantType *expected_type);
-const gchar * g_variant_get_string (GVariant *value, gsize *length);
-void g_variant_unref (GVariant *value);
+gchar * g_strdup ( const gchar *str );
+gboolean     g_variant_dict_contains (GVariantDict *dict, const gchar *key);
+gboolean     g_variant_dict_lookup (GVariantDict *dict, const gchar *key, const gchar *format_string, ...);
+GVariant *   g_variant_dict_lookup_value (GVariantDict *dict, const gchar *key, const GVariantType *expected_type);
+const gchar *g_variant_get_string (GVariant *value, gsize *length);
+void         g_variant_unref (GVariant *value);
+
+gpointer g_object_ref (gpointer object);
+void     g_object_set (gpointer object, const gchar *first_property_name, ...) __attribute__((__sentinel__));
+void     g_object_unref (gpointer object);
+gulong g_signal_connect_data (gpointer instance,const gchar *detailed_signal,GCallback c_handler,gpointer data,GClosureNotify destroy_data,GConnectFlags connect_flags);
+void   g_signal_emit_by_name (gpointer instance, const gchar *detailed_signal, ...);
+void   g_signal_handler_block (gpointer instance, gulong handler_id);
+guint  g_signal_handlers_disconnect_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
+gulong g_signal_handler_find (gpointer instance,GSignalMatchType mask,guint signal_id,GQuark detail,GClosure *closure,gpointer func,gpointer data);
+void   g_signal_handler_unblock (gpointer instance, gulong handler_id);
+guint  g_signal_lookup (const gchar *name, GType itype);
+
 guint gdk_keyval_to_upper (guint keyval) __attribute__((__const__));
 GdkPixbuf *gdk_pixbuf_new_from_data (const guchar *data,GdkColorspace colorspace,gboolean has_alpha,int bits_per_sample,int width, int height,int rowstride,GdkPixbufDestroyNotify destroy_fn,gpointer destroy_fn_data);
+
 void gtk_adjustment_set_value (GtkAdjustment *adjustment, gdouble value);
-GtkApplication * gtk_application_new (const gchar *application_id, GApplicationFlags flags);
-GtkWidget * gtk_application_window_new (GtkApplication *application);
+GtkApplication *gtk_application_new (const gchar *application_id, GApplicationFlags flags);
+GtkWidget *     gtk_application_window_new (GtkApplication *application);
 GtkWidget *gtk_bin_get_child (GtkBin *bin);
-GType gtk_box_get_type (void) __attribute__((__const__));
-GtkWidget* gtk_box_new (GtkOrientation orientation,gint spacing);
-void gtk_box_pack_end (GtkBox *box, GtkWidget *child, gboolean expand, gboolean fill, guint padding);
-void gtk_box_pack_start (GtkBox *box,GtkWidget *child,gboolean expand,gboolean fill,guint padding);
-void gtk_button_clicked (GtkButton *button);
+GType       gtk_box_get_type (void) __attribute__((__const__));
+GtkWidget*  gtk_box_new (GtkOrientation orientation,gint spacing);
+void        gtk_box_pack_end (GtkBox *box, GtkWidget *child, gboolean expand, gboolean fill, guint padding);
+void        gtk_box_pack_start (GtkBox *box,GtkWidget *child,gboolean expand,gboolean fill,guint padding);
+void         gtk_button_clicked (GtkButton *button);
 const gchar *gtk_button_get_label (GtkButton *button);
-GType gtk_button_get_type (void) __attribute__((__const__));
-GtkWidget* gtk_button_new (void);
-GtkWidget* gtk_button_new_with_label (const gchar *label);
-void gtk_button_set_label (GtkButton *button, const gchar *label);
-void gtk_button_set_image (GtkButton *button, GtkWidget *image);
-void gtk_button_set_relief (GtkButton *button, GtkReliefStyle relief);
+GType        gtk_button_get_type (void) __attribute__((__const__));
+GtkWidget*   gtk_button_new (void);
+GtkWidget*   gtk_button_new_with_label (const gchar *label);
+void         gtk_button_set_image (GtkButton *button, GtkWidget *image);
+void         gtk_button_set_label (GtkButton *button, const gchar *label);
+void         gtk_button_set_relief (GtkButton *button, GtkReliefStyle relief);
 GtkCellRenderer *gtk_cell_renderer_text_new (void);
-gboolean gtk_check_menu_item_get_active (GtkCheckMenuItem *check_menu_item);
+GtkWidget *gtk_check_button_new_with_mnemonic (const gchar *label);
+gboolean   gtk_check_menu_item_get_active (GtkCheckMenuItem *check_menu_item);
 GtkWidget* gtk_check_menu_item_new_with_label (const gchar *label);
-void gtk_check_menu_item_set_active (GtkCheckMenuItem *check_menu_item, gboolean is_active);
+void       gtk_check_menu_item_set_active (GtkCheckMenuItem *check_menu_item, gboolean is_active);
 GtkClipboard *gtk_clipboard_get (GdkAtom selection);
-void gtk_clipboard_set_text (GtkClipboard *clipboard,const gchar *text,gint len);
-gint gtk_combo_box_get_active (GtkComboBox *combo_box);
+void          gtk_clipboard_set_text (GtkClipboard *clipboard,const gchar *text,gint len);
+gint         gtk_combo_box_get_active (GtkComboBox *combo_box);
 GtkTreeModel*gtk_combo_box_get_model (GtkComboBox *combo_box);
-void gtk_combo_box_set_active (GtkComboBox *combo_box, gint index_);
-void gtk_combo_box_text_append_text (GtkComboBoxText *combo_box, const gchar *text);
-GtkWidget* gtk_combo_box_text_new (void);
-GtkWidget* gtk_combo_box_text_new_with_entry (void);
-void gtk_combo_box_text_remove (GtkComboBoxText *combo_box, gint position);
-void gtk_container_add (GtkContainer *container, GtkWidget *widget);
-GList* gtk_container_get_children (GtkContainer *container);
-void gtk_container_remove (GtkContainer *container, GtkWidget *widget);
-void gtk_container_set_border_width (GtkContainer *container,guint border_width);
-GtkWidget * gtk_dialog_get_content_area (GtkDialog *dialog);
+void         gtk_combo_box_set_active (GtkComboBox *combo_box, gint index_);
+void         gtk_combo_box_text_append_text (GtkComboBoxText *combo_box, const gchar *text);
+gchar *      gtk_combo_box_text_get_active_text (GtkComboBoxText *combo_box);
+GtkWidget*   gtk_combo_box_text_new (void);
+GtkWidget*   gtk_combo_box_text_new_with_entry (void);
+void         gtk_combo_box_text_remove (GtkComboBoxText *combo_box, gint position);
+void   gtk_container_add (GtkContainer *container, GtkWidget *widget);
+GList* gtk_container_get_children (GtkContainer *container);//[transfer container] You should free this list using g_list_free() when you are done with it
+void   gtk_container_remove (GtkContainer *container, GtkWidget *widget);
+void   gtk_container_set_border_width (GtkContainer *container,guint border_width);
+GtkWidget *gtk_dialog_get_content_area (GtkDialog *dialog);
 GtkWidget *gtk_dialog_get_widget_for_response (GtkDialog *dialog, gint response_id);
 GtkWidget* gtk_dialog_new_with_buttons (const gchar *title,  GtkWindow *parent, GtkDialogFlags flags, const gchar *first_button_text, ...) __attribute__((__sentinel__));
-guint gtk_entry_buffer_delete_text (GtkEntryBuffer *buffer, guint position, gint n_chars);
-const gchar* gtk_entry_buffer_get_text (GtkEntryBuffer *buffer);
-guint gtk_entry_buffer_insert_text (GtkEntryBuffer *buffer,guint position,const gchar *chars,gint n_chars);
+gint       gtk_dialog_run (GtkDialog *dialog);
+void gtk_editable_set_position (GtkEditable *editable, gint position);
+guint           gtk_entry_buffer_delete_text (GtkEntryBuffer *buffer, guint position, gint n_chars);
+const gchar*    gtk_entry_buffer_get_text (GtkEntryBuffer *buffer);
+guint           gtk_entry_buffer_insert_text (GtkEntryBuffer *buffer,guint position,const gchar *chars,gint n_chars);
 GtkEntryBuffer *gtk_entry_get_buffer (GtkEntry *entry);
-const gchar *gtk_entry_get_text (GtkEntry *entry);
-GtkWidget* gtk_entry_new (void);
-void gtk_entry_set_placeholder_text (GtkEntry *entry, const gchar *text);
-void gtk_entry_set_text (GtkEntry *entry, const gchar *text);
-GType gtk_image_get_type (void) __attribute__((__const__));
+const gchar *   gtk_entry_get_text (GtkEntry *entry);
+GtkWidget*      gtk_entry_new (void);
+void            gtk_entry_set_placeholder_text (GtkEntry *entry, const gchar *text);
+void            gtk_entry_set_text (GtkEntry *entry, const gchar *text);
+GType      gtk_image_get_type (void) __attribute__((__const__));
 GtkWidget* gtk_image_new_from_icon_name (const gchar *icon_name, GtkIconSize size);
-GtkWidget *gtk_label_get_mnemonic_widget (GtkLabel *label);
-void gtk_label_set_mnemonic_widget (GtkLabel *label, GtkWidget *widget);
+GtkWidget *  gtk_label_get_mnemonic_widget (GtkLabel *label);
+gboolean     gtk_label_get_use_markup (GtkLabel *label);
+void         gtk_label_set_markup (GtkLabel *label, const gchar *str);
+void         gtk_label_set_mnemonic_widget (GtkLabel *label, GtkWidget *widget);
+void         gtk_label_set_text (GtkLabel *label, const gchar *str);
 const gchar* gtk_label_get_text (GtkLabel *label);
-GtkWidget* gtk_label_new (const gchar *str);
-void gtk_list_store_append (GtkListStore *list_store, GtkTreeIter *iter);
-void gtk_list_store_clear (GtkListStore *list_store);
-void gtk_list_store_insert_after (GtkListStore *list_store, GtkTreeIter *iter, GtkTreeIter *sibling);
-void gtk_list_store_insert_before (GtkListStore *list_store, GtkTreeIter *iter, GtkTreeIter *sibling);
-void gtk_list_store_move_after (GtkListStore *store, GtkTreeIter *iter, GtkTreeIter *position);
-void gtk_list_store_move_before (GtkListStore *store, GtkTreeIter *iter, GtkTreeIter *position);
+GtkWidget*   gtk_label_new (const gchar *str);
+void          gtk_list_store_append (GtkListStore *list_store, GtkTreeIter *iter);
+void          gtk_list_store_clear (GtkListStore *list_store);
+void          gtk_list_store_insert_after (GtkListStore *list_store, GtkTreeIter *iter, GtkTreeIter *sibling);
+void          gtk_list_store_insert_before (GtkListStore *list_store, GtkTreeIter *iter, GtkTreeIter *sibling);
+void          gtk_list_store_move_after (GtkListStore *store, GtkTreeIter *iter, GtkTreeIter *position);
+void          gtk_list_store_move_before (GtkListStore *store, GtkTreeIter *iter, GtkTreeIter *position);
 GtkListStore *gtk_list_store_new (gint n_columns, ...);
-void gtk_list_store_prepend (GtkListStore *list_store, GtkTreeIter *iter);
-gboolean gtk_list_store_remove (GtkListStore *list_store, GtkTreeIter *iter);
-void gtk_list_store_set (GtkListStore *list_store, GtkTreeIter *iter, ...);
-void gtk_list_store_swap (GtkListStore *store, GtkTreeIter *a, GtkTreeIter *b);
-const gchar *gtk_menu_item_get_label (GtkMenuItem *menu_item);
-GtkWidget* gtk_menu_item_new_with_label (const gchar *label);
-void gtk_menu_item_set_submenu (GtkMenuItem *menu_item, GtkWidget *submenu);
-GtkWidget* gtk_menu_new (void);
-void gtk_menu_popup_at_pointer (GtkMenu *menu, const GdkEvent *trigger_event);
-void gtk_menu_popup_at_widget (GtkMenu *menu, GtkWidget *widget, GdkGravity widget_anchor, GdkGravity menu_anchor, const GdkEvent *trigger_event);
-void gtk_menu_shell_append (GtkMenuShell *menu_shell, GtkWidget *child);
-gint gtk_notebook_append_page_menu (GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label, GtkWidget *menu_label);
-GtkWidget* gtk_notebook_get_action_widget (GtkNotebook *notebook, GtkPackType pack_type);
-gint gtk_notebook_get_current_page (GtkNotebook *notebook);
+void          gtk_list_store_prepend (GtkListStore *list_store, GtkTreeIter *iter);
+gboolean      gtk_list_store_remove (GtkListStore *list_store, GtkTreeIter *iter);
+void          gtk_list_store_set (GtkListStore *list_store, GtkTreeIter *iter, ...);
+void          gtk_list_store_swap (GtkListStore *store, GtkTreeIter *a, GtkTreeIter *b);
+const gchar*gtk_menu_item_get_label (GtkMenuItem *menu_item);
+GtkWidget*  gtk_menu_item_new_with_label (const gchar *label);
+void        gtk_menu_item_set_submenu (GtkMenuItem *menu_item, GtkWidget *submenu);
+GtkWidget*  gtk_menu_new (void);
+void        gtk_menu_popup_at_pointer (GtkMenu *menu, const GdkEvent *trigger_event);
+void        gtk_menu_popup_at_widget (GtkMenu *menu, GtkWidget *widget, GdkGravity widget_anchor, GdkGravity menu_anchor, const GdkEvent *trigger_event);
+void        gtk_menu_shell_append (GtkMenuShell *menu_shell, GtkWidget *child);
+GtkWidget *gtk_message_dialog_new (GtkWindow *parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, const gchar *message_format, ...);
+gint         gtk_notebook_append_page_menu (GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label, GtkWidget *menu_label);
+GtkWidget*   gtk_notebook_get_action_widget (GtkNotebook *notebook, GtkPackType pack_type);
+gint         gtk_notebook_get_current_page (GtkNotebook *notebook);
 const gchar *gtk_notebook_get_menu_label_text (GtkNotebook *notebook, GtkWidget *child);
-GtkWidget* gtk_notebook_get_nth_page (GtkNotebook *notebook, gint page_num);
-GtkWidget * gtk_notebook_get_tab_label (GtkNotebook *notebook, GtkWidget *child);
-GType gtk_notebook_get_type (void) __attribute__((__const__));
-GtkWidget * gtk_notebook_new (void);
-gint gtk_notebook_page_num (GtkNotebook *notebook, GtkWidget *child);
-void gtk_notebook_popup_enable (GtkNotebook *notebook);
-void gtk_notebook_remove_page (GtkNotebook *notebook, gint page_num);
-void gtk_notebook_set_action_widget (GtkNotebook *notebook, GtkWidget *widget, GtkPackType pack_type);
-void gtk_notebook_set_current_page (GtkNotebook *notebook, gint page_num);
-void gtk_notebook_set_scrollable (GtkNotebook *notebook, gboolean scrollable);
-void gtk_notebook_set_tab_reorderable (GtkNotebook *notebook, GtkWidget *child, gboolean reorderable);
+GtkWidget*   gtk_notebook_get_nth_page (GtkNotebook *notebook, gint page_num);
+GtkWidget *  gtk_notebook_get_tab_label (GtkNotebook *notebook, GtkWidget *child);
+GType        gtk_notebook_get_type (void) __attribute__((__const__));
+GtkWidget *  gtk_notebook_new (void);
+gint         gtk_notebook_page_num (GtkNotebook *notebook, GtkWidget *child);
+void         gtk_notebook_popup_enable (GtkNotebook *notebook);
+void         gtk_notebook_remove_page (GtkNotebook *notebook, gint page_num);
+void         gtk_notebook_set_action_widget (GtkNotebook *notebook, GtkWidget *widget, GtkPackType pack_type);
+void         gtk_notebook_set_current_page (GtkNotebook *notebook, gint page_num);
+void         gtk_notebook_set_menu_label_text (GtkNotebook *notebook, GtkWidget *child, const gchar *menu_text);
+void         gtk_notebook_set_scrollable (GtkNotebook *notebook, gboolean scrollable);
+void         gtk_notebook_set_tab_label_text (GtkNotebook *notebook, GtkWidget *child, const gchar *tab_text);
+void         gtk_notebook_set_tab_reorderable (GtkNotebook *notebook, GtkWidget *child, gboolean reorderable);
 GtkWidget *gtk_paned_get_child1 (GtkPaned *paned);
 GtkWidget *gtk_paned_get_child2 (GtkPaned *paned);
-GtkWidget * gtk_paned_new (GtkOrientation orientation);
-void gtk_paned_pack1 (GtkPaned *paned, GtkWidget *child, gboolean resize, gboolean shrink);
-void gtk_paned_pack2 (GtkPaned *paned, GtkWidget *child, gboolean resize, gboolean shrink);
-GSList* gtk_radio_menu_item_get_group (GtkRadioMenuItem *radio_menu_item);
-GtkWidget* gtk_radio_menu_item_new_with_label (GSList *group, const gchar *label);
+GtkWidget *gtk_paned_new (GtkOrientation orientation);
+void       gtk_paned_pack1 (GtkPaned *paned, GtkWidget *child, gboolean resize, gboolean shrink);
+void       gtk_paned_pack2 (GtkPaned *paned, GtkWidget *child, gboolean resize, gboolean shrink);
+GtkWidget * gtk_radio_button_new_with_label (GSList *group, const gchar *label);
+GtkWidget * gtk_radio_button_new_with_label_from_widget (GtkRadioButton *radio_group_member, const gchar *label);
+GSList*     gtk_radio_menu_item_get_group (GtkRadioMenuItem *radio_menu_item);
+GtkWidget*  gtk_radio_menu_item_new_with_label (GSList *group, const gchar *label);
 GtkAdjustment* gtk_scrolled_window_get_vadjustment (GtkScrolledWindow *scrolled_window);
-void gtk_scrolled_window_set_policy (GtkScrolledWindow *scrolled_window,GtkPolicyType hscrollbar_policy,GtkPolicyType vscrollbar_policy);
-GtkWidget* gtk_scrolled_window_new (GtkAdjustment *hadjustment,GtkAdjustment *vadjustment);
-void gtk_text_buffer_get_bounds (GtkTextBuffer *buffer,GtkTextIter *start,GtkTextIter *end);
-void gtk_text_buffer_get_end_iter (GtkTextBuffer *buffer, GtkTextIter *iter);
-gchar *gtk_text_buffer_get_text (GtkTextBuffer *buffer,const GtkTextIter *start,const GtkTextIter *end,gboolean include_hidden_chars);
-void gtk_text_buffer_insert (GtkTextBuffer *buffer,GtkTextIter *iter,const gchar *text,gint len);
-void gtk_text_buffer_set_text (GtkTextBuffer *buffer, const gchar *text, gint len);
+void           gtk_scrolled_window_set_policy (GtkScrolledWindow *scrolled_window,GtkPolicyType hscrollbar_policy,GtkPolicyType vscrollbar_policy);
+GtkWidget*     gtk_scrolled_window_new (GtkAdjustment *hadjustment,GtkAdjustment *vadjustment);
+void   gtk_text_buffer_get_bounds (GtkTextBuffer *buffer,GtkTextIter *start,GtkTextIter *end);
+void   gtk_text_buffer_get_end_iter (GtkTextBuffer *buffer, GtkTextIter *iter);
+gchar *gtk_text_buffer_get_slice (GtkTextBuffer *buffer,const GtkTextIter *start,const GtkTextIter *end,gboolean include_hidden_chars);
+void   gtk_text_buffer_insert (GtkTextBuffer *buffer,GtkTextIter *iter,const gchar *text,gint len);
+void   gtk_text_buffer_set_text (GtkTextBuffer *buffer, const gchar *text, gint len);
 GtkTextBuffer* gtk_text_view_get_buffer(GtkTextView *);
-void gtk_text_view_get_iter_location (GtkTextView *text_view, const GtkTextIter *iter, GdkRectangle *location);
-void gtk_text_view_get_visible_rect (GtkTreeView *tree_view, GdkRectangle *visible_rect);
-GtkWidget * gtk_text_view_new (void);
-void gtk_text_view_set_wrap_mode (GtkTextView *text_view, GtkWrapMode wrap_mode);
-void gtk_text_view_set_editable (GtkTextView *text_view,gboolean setting);
-void gtk_tooltip_set_text (GtkTooltip *tooltip, const gchar *text);
-void gtk_tree_model_get (GtkTreeModel *tree_model, GtkTreeIter *iter, ...);
-gboolean gtk_tree_model_get_iter_first(GtkTreeModel *tree_model, GtkTreeIter *iter);
-gboolean gtk_tree_model_get_iter_from_string (GtkTreeModel *tree_model, GtkTreeIter *iter, const gchar *path_string);
+void           gtk_text_view_get_iter_location (GtkTextView *text_view, const GtkTextIter *iter, GdkRectangle *location);
+GType          gtk_text_view_get_type (void) __attribute__ ((__const__));
+void           gtk_text_view_get_visible_rect (GtkTextView *tree_view, GdkRectangle *visible_rect);
+GtkWidget *    gtk_text_view_new (void);
+void           gtk_text_view_set_wrap_mode (GtkTextView *text_view, GtkWrapMode wrap_mode);
+void           gtk_text_view_set_editable (GtkTextView *text_view,gboolean setting);
+gboolean gtk_toggle_button_get_active (GtkToggleButton *toggle_button);
+void     gtk_toggle_button_set_active (GtkToggleButton *toggle_button, gboolean is_active);
+void     gtk_tooltip_set_text (GtkTooltip *tooltip, const gchar *text);
+void         gtk_tree_model_get (GtkTreeModel *tree_model, GtkTreeIter *iter, ...);
+gboolean     gtk_tree_model_get_iter_first(GtkTreeModel *tree_model, GtkTreeIter *iter);
+gboolean     gtk_tree_model_get_iter_from_string (GtkTreeModel *tree_model, GtkTreeIter *iter, const gchar *path_string);
 GtkTreePath *gtk_tree_model_get_path (GtkTreeModel *tree_model,GtkTreeIter *iter);
-gint gtk_tree_model_iter_n_children (GtkTreeModel *tree_model, GtkTreeIter *iter);
-gboolean gtk_tree_model_iter_next (GtkTreeModel *tree_model, GtkTreeIter *iter);
-gboolean gtk_tree_model_iter_nth_child (GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent, gint n);
-gboolean gtk_tree_model_iter_previous (GtkTreeModel *tree_model, GtkTreeIter *iter);
+gint         gtk_tree_model_iter_n_children (GtkTreeModel *tree_model, GtkTreeIter *iter);
+gboolean     gtk_tree_model_iter_next (GtkTreeModel *tree_model, GtkTreeIter *iter);
+gboolean     gtk_tree_model_iter_nth_child (GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent, gint n);
+gboolean     gtk_tree_model_iter_previous (GtkTreeModel *tree_model, GtkTreeIter *iter);
 gint *gtk_tree_path_get_indices (GtkTreePath *path);
-void gtk_tree_path_free (GtkTreePath *path);
+void  gtk_tree_path_free (GtkTreePath *path);
 gboolean gtk_tree_selection_get_selected (GtkTreeSelection *selection,GtkTreeModel **model,GtkTreeIter *iter);
-gint gtk_tree_view_append_column (GtkTreeView *tree_view, GtkTreeViewColumn *column);
-GtkTreeViewColumn *gtk_tree_view_column_new_with_attributes (const gchar *title, GtkCellRenderer *cell, ...) __attribute__((__sentinel__));
-GtkTreeModel *gtk_tree_view_get_model (GtkTreeView *tree_view);
+gboolean gtk_tree_sortable_get_sort_column_id (GtkTreeSortable *sortable, gint *sort_column_id, GtkSortType *order);
+void     gtk_tree_sortable_set_sort_column_id (GtkTreeSortable *sortable, gint sort_column_id, GtkSortType order);
+gint              gtk_tree_view_append_column (GtkTreeView *tree_view, GtkTreeViewColumn *column);
+GtkTreeViewColumn*gtk_tree_view_column_new_with_attributes (const gchar *title, GtkCellRenderer *cell, ...) __attribute__((__sentinel__));
+void              gtk_tree_view_column_set_clickable (GtkTreeViewColumn *tree_column, gboolean clickable);
+void              gtk_tree_view_column_set_expand (GtkTreeViewColumn *tree_column, gboolean expand);
+void              gtk_tree_view_column_set_resizable (GtkTreeViewColumn *tree_column, gboolean resizable);
+GtkTreeModel *    gtk_tree_view_get_model (GtkTreeView *tree_view);
 GtkTreeSelection *gtk_tree_view_get_selection (GtkTreeView *tree_view);
-GtkWidget *gtk_tree_view_new (void);
-void gtk_tree_view_set_headers_visible (GtkTreeView *tree_view, gboolean headers_visible);
-void gtk_tree_view_set_model (GtkTreeView *tree_view, GtkTreeModel *model);
-gboolean gtk_widget_activate (GtkWidget *widget);
-void gtk_widget_destroy (GtkWidget *widget);
-void gtk_widget_hide (GtkWidget *widget);
+GtkWidget *       gtk_tree_view_new (void);
+GtkWidget *       gtk_tree_view_new_with_model (GtkTreeModel *model);
+void              gtk_tree_view_set_cursor (GtkTreeView *tree_view, GtkTreePath *path, GtkTreeViewColumn *focus_column, gboolean start_editing);
+void              gtk_tree_view_set_headers_visible (GtkTreeView *tree_view, gboolean headers_visible);
+void              gtk_tree_view_set_model (GtkTreeView *tree_view, GtkTreeModel *model);
+gboolean   gtk_widget_activate (GtkWidget *widget);
+void       gtk_widget_destroy (GtkWidget *widget);
+void       gtk_widget_hide (GtkWidget *widget);
 GtkWidget* gtk_widget_get_ancestor (GtkWidget *widget, GType widget_type);
-gboolean gtk_widget_get_has_tooltip (GtkWidget *widget);
-GtkWidget * gtk_widget_get_parent (GtkWidget *widget);
+gboolean   gtk_widget_get_has_tooltip (GtkWidget *widget);
+GtkWidget *gtk_widget_get_parent (GtkWidget *widget);
 GtkWidget* gtk_widget_get_toplevel (GtkWidget *widget);
-void gtk_widget_grab_focus (GtkWidget *widget);
-gboolean gtk_widget_is_focus (GtkWidget *widget);
-void gtk_widget_set_has_tooltip (GtkWidget *widget, gboolean has_tooltip);
-void gtk_widget_set_sensitive (GtkWidget *widget, gboolean sensitive);
-void gtk_widget_set_size_request (GtkWidget *widget,gint width,gint height);
-void gtk_widget_set_tooltip_text (GtkWidget *widget, const gchar *text);
-void gtk_widget_show (GtkWidget *widget);
-void gtk_widget_show_all (GtkWidget *widget);
-void gtk_window_close (GtkWindow *window);
-void gtk_window_get_size (GtkWindow *window,gint *width,gint *height);
-void gtk_window_iconify (GtkWindow *window);
+void       gtk_widget_grab_focus (GtkWidget *widget);
+gboolean   gtk_widget_is_focus (GtkWidget *widget);
+void       gtk_widget_set_has_tooltip (GtkWidget *widget, gboolean has_tooltip);
+void       gtk_widget_set_sensitive (GtkWidget *widget, gboolean sensitive);
+void       gtk_widget_set_size_request (GtkWidget *widget,gint width,gint height);
+void       gtk_widget_show (GtkWidget *widget);
+void       gtk_widget_show_all (GtkWidget *widget);
+void     gtk_window_close (GtkWindow *window);
+void     gtk_window_get_size (GtkWindow *window,gint *width,gint *height);
+void     gtk_window_iconify (GtkWindow *window);
 gboolean gtk_window_is_active (GtkWindow *window);
-void gtk_window_maximize (GtkWindow *window);
-void gtk_window_present (GtkWindow *window);
-void gtk_window_set_default_size (GtkWindow *window, gint width, gint height);
-void gtk_window_set_icon (GtkWindow *window, GdkPixbuf *icon);
-void gtk_window_set_title (GtkWindow *window,const gchar *title);
+void     gtk_window_maximize (GtkWindow *window);
+void     gtk_window_present (GtkWindow *window);
+void     gtk_window_set_default_size (GtkWindow *window, gint width, gint height);
+void     gtk_window_set_icon (GtkWindow *window, GdkPixbuf *icon);
+void     gtk_window_set_title (GtkWindow *window,const gchar *title);
 
 #ifdef __cplusplus
 }
--- /dev/null
+++ sirc-1/inc/stat.h
@@ -0,0 +1,12 @@
+
+typedef unsigned short mode_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int mkdir(const char *pathname, mode_t mode);
+
+#ifdef __cplusplus
+}
+#endif
--- sirc-1.orig/inc/stddef.h
+++ sirc-1/inc/stddef.h
@@ -1,2 +1,4 @@
 
 typedef long unsigned int size_t;
+typedef long int __ssize_t;
+typedef __ssize_t ssize_t;
--- sirc-1.orig/inc/stdio.h
+++ sirc-1/inc/stdio.h
@@ -3,11 +3,21 @@
 
 #define EOF (-1)
 
+typedef struct __sFILE FILE;
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+int fclose(FILE *stream);
+int fileno(FILE *stream);
+FILE *fopen(const char */*restrict*/ pathname, const char */*restrict*/ mode);
+size_t fread(void */*ptr[restrict .size * .nmemb]*/, size_t size, size_t nmemb, FILE */*restrict*/ stream);
+int fseek(FILE *stream, long offset, int whence);
+long ftell(FILE *stream);
+size_t fwrite(const void */*ptr[restrict .size * .nmemb]*/, size_t size, size_t nmemb, FILE */*restrict*/ stream);
 int getchar(void);
+ssize_t getdelim(char **/*restrict*/ lineptr, size_t */*restrict*/ n, int delim, FILE */*restrict*/ stream);
 int printf( const char * format, ... );
 int puts(const char*);
 int sscanf(const char *str, const char *format, ...);
--- sirc-1.orig/inc/time.h
+++ sirc-1/inc/time.h
@@ -1,6 +1,6 @@
 
 
-typedef long time_t;
+typedef long int time_t;
 
 #ifdef __cplusplus
 extern "C" {
--- sirc-1.orig/inc/unistd.h
+++ sirc-1/inc/unistd.h
@@ -1,8 +1,7 @@
 
 #include "inc/stddef.h"
 
-typedef int ssize_t;
-typedef long off_t;
+typedef long int off_t;
 
 #define F_OK 0
 
@@ -15,9 +14,12 @@ extern "C" {
 #endif
 
 int access(const char*,int);
+int chdir(const char *path);
 int close(int);
 off_t lseek(int,off_t,int);
+int ftruncate(int fd, off_t length);
 ssize_t read(int,void*,size_t);
+int rmdir(const char *pathname);
 unsigned int sleep(unsigned int seconds);
 int unlink(const char*);
 ssize_t write(int,const void*,size_t);
--- sirc-1.orig/main.c
+++ sirc-1/main.c
@@ -57,6 +57,11 @@
 #else
 #include "inc/socket.h"
 #endif
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#else
+#include "inc/stat.h"
+#endif
 #ifdef HAVE_TIME_H
 #include <time.h>
 #else
@@ -77,6 +82,8 @@
 #include "inc/gtk.h"
 #endif
 
+#include "icon.h"
+
 static GtkTextView *text_view;static GtkWidget*home_page;static GtkListStore*channels;
 static SSL *ssl=nullptr;static int plain_socket=-1;
 static int con_th=-1;//static GThread*con_th=nullptr;
@@ -84,15 +91,50 @@ static BOOL close_intention;
 #define ssl_con_try "Trying with SSL.\n"
 #define ssl_con_plain "Trying unencrypted.\n"
 #define irc_bsz 64
-//"510"
+//"there are 510 characters maximum allowed for the command and its parameters"
 #define irc_term "\r\n"
 #define irc_term_sz sizeof(irc_term)-1
-#define hostname_sz 512//arranging
-#define password_sz 505+1//fitting
+
+//#define _POSIX_HOST_NAME_MAX 255
+#define hostname_sz 256//arranging
+//at rfc level, for whois queries
+//and "Servers are uniquely identified by their name, which has a maximum length of sixty three (63)"
+//Back in ancient times (v1 era) the maximum was bumped up from 63 to 64 for user hostnames (for some reason).
+#define hostnamerfc_sz 64
+#define hostnamerfcnul_sz hostnamerfc_sz+1
+#define hostnamerfc_scan "%64s"
+#define chan_sz 50
+//"up to fifty (50) characters"
+#define channul_sz chan_sz+1
+#define channame_scan "%50s"
+#define name_sz 9
+#define prefix_name_sz 1+name_sz
+//"max. 9 characters"
+#define namenul_sz name_sz+1
+#define name_scan1 "%9"
+#define name_scan name_scan1 "s"
+#define mod_scan "%4s"
+//not official: "Ident userid limited to 10 chars" //I think that includes ~
+#define user_sz 10
+#define usernul_sz user_sz+1
+#define user_scan "%10s"
+
+//hostname -.0..9a..z
+#define nickname_start(a) ('A'<=*a&&*a<='}')
+//nick format: A..}
+//             -0..9; but not at [0]
+//~ for owners, +q, tilde ascii is after }
+//& for admins, +a
+//@ for full operators, +o
+//% for half operators, +h
+//+ for voiced users, +v
+
+#define password_sz 256
 #define password_con "PASS %s" irc_term
 #define nickname_con "NICK %s" irc_term
 static char*info_path_name=nullptr;
-#define home_string "*Home"
+#define not_a_nick_chan_host_start     "*"
+#define home_string not_a_nick_chan_host_start "Home"
 #define priv_msg_str "PRIVMSG"
 #define not_msg_str "NOTICE"
 #define mod_msg_str "MODE"
@@ -117,30 +159,26 @@ static char*info_path_name=nullptr;
 #define con_nr_nrs INT_CONV_STR(con_nr_min) "-" INT_CONV_STR(con_nr_max)
 //#define con_nr_righttype1 _con_nr_us
 //#define con_nr_righttype2 _con_nr_u
+
+//QTO
+//XC
 #define help_text "Most of the parameters are set at start.\n\
 Launch the program with --help argument for more info.\n\
 Send irc commands from the " home_string " tab. Other tabs are sending " priv_msg_str " messages.\n\
 \n\
 Keyboard\n\
 Ctrl+T = Tabs popup\n\
-Ctrl+C = Close tab\n\
+Shift+Ctrl+C = Close tab\n\
 Ctrl+Q = Shutdown connection\n\
-Ctrl+X = Exit program\n\
+Ctrl+O = Open organizer\n\
+Shift+Ctrl+X = Exit program\n\
 \n\
 Connection format:\n\
 [[nickname" parse_host_delim "]password" parse_host_left "]hostname[" parse_host_delim "port1[" parse_host_ports_delim "portN][" parse_host_ports_micro "portM...][" parse_host_ports_macro "portP...]]\n\
 A " parse_host_ports_macro_text " (" parse_host_ports_macro ") will override the connection type. Before " parse_host_ports_macro_text " are " con_nr_s " ports and after " parse_host_ports_macro_text " are " con_nr_u " ports.\n\
 Escape " parse_host_left " in password with the uri format (\"%40\").\n\
 e.g. newNick" parse_host_delim "a%40c" parse_host_left "127.0.0.1" parse_host_delim "7000" parse_host_ports_macro "6660" parse_host_ports_delim "6665" parse_host_ports_micro "6669"
-#define chan_sz 50
-#define channul_sz chan_sz+1
-//"up to fifty (50) characters"
-#define channame_scan "%50s"
-#define name_sz 9
-#define namenul_sz name_sz+1
-#define name_scan1 "%9"
-#define name_scan name_scan1 "s"
-#define mod_scan "%4s"
+
 struct data_len{
 	const char*data;size_t len;
 };
@@ -149,11 +187,17 @@ static GtkWidget*chan_menu;
 static GtkWidget*name_on_menu;static GtkWidget*name_off_menu;
 static unsigned int alert_counter=0;
 static GtkCheckMenuItem*show_time;static GtkCheckMenuItem*channels_counted;
+//#define LIST_ITEM_OR_ORG_ID1 0
 enum {
   LIST_ITEM = 0,
   N_COLUMNS
 };//connections org,channels
+
 #define number_of_args 23
+//QWERTYUIOP
+//ASDFgHJkL
+// ZXCVbNM
+
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wpadded"
 struct stk_s{
@@ -187,36 +231,73 @@ struct stk_s{
 	char args_short[number_of_args];
 	GtkWidget*organizer;
 	BOOL handle_command_line_callback_was_executed;
+
+	const char*proced_text;
+	BOOL proced_switch;
+	unsigned char proced_n;
+	char*proced_hostname;
+
+	GtkComboBox*organizer_dirs;GtkWidget*organizer_removeentry;
+	                           GtkWidget*organizer_removerule;
+	                           GtkToggleButton*organizer_del_confirmation;
+	GtkNotebook*organizer_notebook;
+	GtkWidget*organizer_entry_widget;GtkWidget*organizer_entry_widget_timestamp;
+	GtkListStore*organizer_entry_names;
+	GtkWidget*organizer_bot;
+	BOOL organizer_can_add_names;
 };
 static int autoconnect=-1;static BOOL autoconnect_pending=FALSE;
 static GSList*con_group;
-static const unsigned char icon16[]={
-0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff
-,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff
-,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8
-,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xff,0xff,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8,0x00,0xa2,0xe8
-//3842
-};
-static char chantypes[5]={'\0'};
-static char chanmodes[7]={'\0'};
-static char chanmodessigns[7]={'\0'};//& at whois
-static unsigned int maximummodes=0;
+
+static char chantypes[5];
+static char chanmodes[7];
+static char chanmodessigns[7];
+static unsigned int maximummodes;
+
 #define RPL_NONE -1
+#define RPL_ISUPPORT 5
+#define RPL_LUSERCHANNELS 254
+#define RPL_AWAY 301
+#define RPL_WHOISUSER 311
+#define RPL_WHOISSERVER 312
+#define RPL_WHOISIDLE 317
+#define RPL_ENDOFWHOIS 318
+#define RPL_WHOISCHANNELS 319
+#define RPL_WHOISSPECIAL 320
+#define RPL_WHOISACCOUNT 330
 #define RPL_LIST 322
+#define RPL_LISTEND 323
+#define RPL_TOPIC 332
 #define RPL_NAMREPLY 353
-#define show_from_clause(a,b,c) if(icmpAmemBstr(a,b))show_msg=c;
-#define show_to_clause(a) if(show_msg==a)show_msg=RPL_NONE;
-static int show_msg=RPL_NONE;
+#define RPL_ENDOFNAMES 366
+#define RPL_WHOISHOST 378
+#define RPL_WHOISMODES 379
+#define ERR_UNKNOWNERROR 400
+
 #define digits_in_uint 10
+#define digits_in_uintnul digits_in_uint+1
+#define digits_in_posInt 10
+#define digits_in_long 20
+#define digits_in_longnul digits_in_long+1
+//2 at 64, $((2**63))...
+
+#define show_from_clause(a,b,c) if(icmpAmemBstrlownotempty(a,b))show_msg=c;
+#define show_between_clause(a) if(show_msg!=a)showmsg=FALSE;
+#define show_to_clause(a) if(show_msg==a)show_msg=RPL_NONE;else showmsg=FALSE;
+static int show_msg=RPL_NONE;
 static int log_file=-1;
 static char*dummy=nullptr;
 static char**ignores;
 static BOOL can_send_data=FALSE;
-#define chans_str "channels"
-#define names_str "names"
-#define counting_the_list_size (sizeof(chans_str)>sizeof(names_str)?sizeof(chans_str):sizeof(names_str))
+#define chans_small_str "channels"
+#define names_small_str "names"
+#define counting_the_list_size (sizeof(chans_small_str)>sizeof(names_small_str)?sizeof(chans_small_str):sizeof(names_small_str))
 #define list_end_str " listed\n"
 #define autojoin_str "autojoin"
+#define join_str  "JOIN"
+#define names_str "NAMES"
+#define whois_str "WHOIS"
+#define counting_the_chanRel_size (sizeof(names_str)>sizeof(join_str)?sizeof(names_str):sizeof(join_str))
 enum{autoconnect_id,autojoin_id,dimensions_id,chan_min_id,chans_max_id,connection_number_id,hide_id,ignore_id,log_id,maximize_id,minimize_id,nick_id,password_id,refresh_id,right_id,run_id,send_history_id,timestamp_id,user_id,visible_id,welcome_id,welcomeNotice_id,removeconf_id};
 struct ajoin{
 	int c;//against get_active
@@ -242,9 +323,53 @@ static GQueue*send_entry_list;static GLi
 #define visible_char "i"
 #define visible_mod mod_remove_char visible_char
 #define wait_recon 10
-#define user_error "*Error"
-#define user_topic "*Topic"
-#define user_info "*Info"
+#define user_error not_a_nick_chan_host_start "Error"
+#define user_error2 user_error "2"
+#define user_topic not_a_nick_chan_host_start "Topic"
+#define user_info not_a_nick_chan_host_start "Info"
+
+#define homelocal ".local"
+#define homeshare "share"
+#define proj "sirc"
+#define folder_separator "/"
+#define folderseparator *folder_separator
+#define removed_string " removed"
+#define remove_ignored " ignored (maybe is not empty)"
+
+#define dirback ".."
+#define org_c "chans"
+#define org_u "users"
+#define org_g "global"
+//#define LIST_ITEM_OR_ORG_ID1 0
+enum {
+  ORG_ID1     = 0,
+  ORG_ID2     = 1,
+  ORG_GEN     = 2,
+  ORG_IDLE    = 3,
+  ORG_SERVER  = 4,
+  ORG_INDEX   = 5,
+  ORG_CONV    = 6,
+  ORG_N
+};
+struct org_col{
+	int pos;
+	GtkTreeSortable*sort;
+};
+#define org_new_names not_a_nick_chan_host_start "New"
+struct organizer_from_storage{
+	GtkComboBoxText*box;
+	const char*server;
+};
+#define movestart not_a_nick_chan_host_start "Move"
+
+#define LIST_ITEM_OR_ORG_ID1 0
+
+#define new_line "\n"
+
+struct name_pack{
+	gchar*name;
+	struct stk_s*ps;
+};
 
 #define contf_get_treev(pan) (GtkTreeView*)gtk_bin_get_child((GtkBin*)gtk_paned_get_child2((GtkPaned*)pan))
 #define contf_get_model(pan) gtk_tree_view_get_model(contf_get_treev(pan))
@@ -294,6 +419,7 @@ static void addattextmain(const char*dat
 	gtk_text_buffer_insert(text_buffer,&it,data,(int)len);
 	addattextview_scroll(b,text_view);
 }
+#define addattextmain_n(a,b) addattextmain(a new_line,(b+1))
 #define addattextmain_struct(s) addattextmain(s->data,s->len)
 static void addattextv(GtkTextView*v,const char*n,const char*msg){
 	GtkTextBuffer *text_buffer = gtk_text_view_get_buffer (v);
@@ -304,19 +430,30 @@ static void addattextv(GtkTextView*v,con
 	addtimestamp(text_buffer,&it);
 	gtk_text_buffer_insert(text_buffer,&it,": ",2);
 	gtk_text_buffer_insert(text_buffer,&it,msg,-1);
-	gtk_text_buffer_insert(text_buffer,&it,"\n",1);
+	gtk_text_buffer_insert(text_buffer,&it,new_line,1);
 	//
 	addattextview_scroll(b,v);
 }
 #define addatchans(n,msg,p) addattextv(contf_get_textv(p),n,msg)
-static void addatnames(const char*n,const char*msg,GtkWidget*p){
+static void addatnames(const char*n,const char*msg,GtkWidget*p,char*the_other_person){//the_other_person is null if  n  is the_other_person
 	addattextv((GtkTextView*)gtk_bin_get_child((GtkBin*)p),n,msg);
 	if(log_file!=-1){
-		write(log_file,n,strlen(n));
-		char buf[1+20+1+1];//2 at 64, $((2**63))...
+		if(the_other_person==nullptr){
+			write(log_file,n,strlen(n));
+			write(log_file," " not_a_nick_chan_host_start,1+sizeof(not_a_nick_chan_host_start)-1);
+		}else{
+			if(*n!=*not_a_nick_chan_host_start){//send message
+				write(log_file,not_a_nick_chan_host_start " ",sizeof(not_a_nick_chan_host_start)-1+1);
+			}else{//info/error message
+				write(log_file,n,strlen(n));
+				write(log_file," ",1);
+			}
+			write(log_file,the_other_person,strlen(the_other_person));
+		}
+		char buf[1+digits_in_long+1+1];
 		write(log_file,buf,(size_t)sprintf(buf," %ld ",time(nullptr)));//sizeof(time_t)==8?" %lld ":
 		write(log_file,msg,strlen(msg));
-		write(log_file,irc_term,irc_term_sz);
+		write(log_file,new_line,sizeof(new_line)-1);
 	}
 }
 static gboolean textviewthreadsfunc(gpointer b){
@@ -330,6 +467,7 @@ static void main_text(const char*b,size_
 	int out;sigwait(&threadset,&out);
 }
 #define main_text_s(b) main_text(b,sizeof(b)-1)
+//#define main_text_sn(a) main_text_s(a new_line)
 static int recv_data(char*b,int sz){
 	if(ssl!=nullptr)return SSL_read(ssl, b, sz);
 	return read(plain_socket,b,(size_t)sz);
@@ -417,7 +555,7 @@ static BOOL parse_host_str(const char*in
 			}
 		}
 		size_t psz=lsz-i;
-		char*p=(char*)
+		gchar*p=(char*)
 #ifdef FN_G_MEMDUP2
 		g_memdup2
 #else
@@ -425,10 +563,10 @@ static BOOL parse_host_str(const char*in
 #endif
 		(indata+i,psz+1);
 		p[psz]='\0';
-		char*up=g_uri_unescape_string(p,nullptr);
+		gchar*up=g_uri_unescape_string(p,nullptr);
 		g_free(p);
-		if(strlen(up)>=password_sz){free(up);return FALSE;}
-		strcpy(psw,up);free(up);
+		if(strlen(up)>=password_sz){g_free(up);return FALSE;}
+		strcpy(psw,up);g_free(up);
 		sz-=(size_t)(left+1-indata);indata=left+1;
 	}else if(ps->password!=nullptr)strcpy(psw,ps->password);
 	else *psw='\0';
@@ -509,7 +647,7 @@ static int pars_chan_counted(char*chan,u
 	GtkTreeIter it;int sum=0;
 	gboolean valid=gtk_tree_model_get_iter_first ((GtkTreeModel*)channels, &it);
 	while(valid){
-		char*text;
+		gchar*text;
 		gtk_tree_model_get ((GtkTreeModel*)channels, &it, 0, &text, -1);
 		char*c=strchr(text,' ');*c='\0';
 		unsigned int n=(unsigned int)atoi(c+1);
@@ -527,7 +665,7 @@ static int pars_chan_alpha(char*chan,uns
 	GtkTreeIter it;int n=0;
 	gboolean valid=gtk_tree_model_get_iter_first ((GtkTreeModel*)channels, &it);
 	while(valid){
-		char*text;
+		gchar*text;
 		gtk_tree_model_get ((GtkTreeModel*)channels, &it, 0, &text, -1);
 		char*c=strchr(text,' ');*c='\0';
 		int a=strcmp(chan,text);
@@ -669,18 +807,23 @@ static BOOL chan_not_joined(char*item_te
 	}
 	return b;
 }
+static void send_channel_related(char*antet,char*item_text,size_t i){
+	char buf[counting_the_chanRel_size+chan_sz+irc_term_sz];
+	size_t a=strlen(antet);
+	memcpy(buf,antet,a);buf[a]=' ';a++;
+	memcpy(buf+a,item_text,i);
+	memcpy(buf+a+i,irc_term,irc_term_sz);
+	send_data(buf,a+irc_term_sz+i);
+}
 static void send_join(char*item_text,size_t i){
-	char buf[5+chan_sz+irc_term_sz]="JOIN ";
-	memcpy(buf+5,item_text,i);
-	memcpy(buf+5+i,irc_term,irc_term_sz);
-	send_data(buf,5+irc_term_sz+i);
+	send_channel_related((char*)join_str,item_text,i);
 }
-static gboolean chan_join (GtkTreeView *tree,GdkEvent*ignored,GtkNotebook*notebook){
+static gboolean chan_join(GtkTreeView *tree,GdkEvent*ignored,GtkNotebook*notebook){
 	(void)ignored;
 	GtkTreeSelection *sel=gtk_tree_view_get_selection(tree);
 	GtkTreeIter iterator;
 	if(gtk_tree_selection_get_selected (sel,nullptr,&iterator)){//can be no channel
-		char*item_text;
+		gchar*item_text;
 		gtk_tree_model_get ((GtkTreeModel*)channels, &iterator, LIST_ITEM, &item_text, -1);
 		for(size_t i=0;;i++){
 			if(item_text[i]==' '){
@@ -689,7 +832,7 @@ static gboolean chan_join (GtkTreeView *
 				break;
 			}
 		}
-		free(item_text);
+		g_free(item_text);
 	}
 	return FALSE;//not care about other events
 }
@@ -716,24 +859,191 @@ static BOOL name_join_isnew(struct stk_s
 	}
 	return TRUE;
 }
-static GtkWidget* name_join_nb(char*t,GtkNotebook*nb){
-	GtkWidget*scrl=container_frame_name
-	GtkWidget*close;GtkWidget*mn=add_new_tab(scrl,t,&close,nb,name_on_menu,TRUE);
-	g_signal_connect_data (close, "clicked",G_CALLBACK (close_name),mn,nullptr,G_CONNECT_SWAPPED);//not "(GClosureNotify)gtk_widget_destroy" because at restart clear will be trouble
-	return scrl;
+
+static BOOL is_channel(const char*c){//prefixless names from notebook menu or from privmsg/invite incomings
+	for(int i=0;;i++)if(chantypes[i]==*c)return TRUE;
+		else if(chantypes[i]=='\0')return FALSE;
 }
-#define nickname_start(a) ('A'<=*a&&*a<='}')
-static gboolean name_join(GtkTreeView*tree,GdkEvent*ignored,struct stk_s*ps){
-	(void)ignored;
+#define nickname_prefixless(a) nickname_start(a)?a:a+1
+
+static BOOL to_organizer_folder(BOOL is_remove,BOOL remove){//for the moment this is the only chdir in the program
+	char*h=getenv("HOME");
+	if(h!=nullptr){
+		if(chdir(h)!=-1){
+			if(is_remove==FALSE){
+				if(chdir(homelocal)==-1){
+					if(mkdir(homelocal,0700)==-1)return FALSE;
+					if(chdir(homelocal)==-1)return FALSE;
+				}
+				if(chdir(homeshare)==-1){
+					if(mkdir(homeshare,0700)==-1)return FALSE;
+					if(chdir(homeshare)==-1)return FALSE;
+				}
+				if(chdir(proj)==-1){
+					if(mkdir(proj,0700)==-1)return FALSE;
+					if(chdir(proj)==-1)return FALSE;
+				}
+				return TRUE;
+			}else{
+				if(access(homelocal folder_separator homeshare folder_separator proj,F_OK)==0){
+					printf("%s%c%s%c%s%c%s",h,folderseparator,homelocal,folderseparator,homeshare,folderseparator,proj);
+					BOOL a;
+					if(remove==FALSE){
+						puts("");a=TRUE;
+					}else{
+						if(rmdir(homelocal folder_separator homeshare folder_separator proj)==0){puts(removed_string);a=TRUE;}
+						else{puts(remove_ignored);a=FALSE;}
+					}
+					if(a){
+						if(access(homelocal folder_separator homeshare,F_OK)==0){
+							printf("%s%c%s%c%s",h,folderseparator,homelocal,folderseparator,homeshare);
+							if(remove==FALSE){
+								puts("");a=TRUE;
+							}else{
+								if(rmdir(homelocal folder_separator homeshare)==0){puts(removed_string);a=TRUE;}
+								else{puts(remove_ignored);a=FALSE;}
+							}
+							if(a){
+								if(access(homelocal,F_OK)==0){
+									printf("%s%c%s",h,folderseparator,homelocal);
+									if(remove==FALSE){
+										puts("");
+									}else{
+										if(rmdir(homelocal)==0) puts(removed_string);
+										else puts(remove_ignored);
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	return FALSE;
+}
+#define to_organizer_folder_go to_organizer_folder(FALSE,FALSE)
+#define to_organizer_folder_server(s) to_organizer_folder_go&&chdir(s)==0
+#define to_organizer_folder_server_go to_organizer_folder_server(server_name(ps))
+static const gchar*server_name(struct stk_s*ps){
+	const gchar*n_main=gtk_notebook_get_menu_label_text(ps->notebook,home_page);
+	n_main+=sizeof(not_a_nick_chan_host_start)-1;
+	return n_main;
+	//char*n_main=ps->proced_hostname;//at reconect is not ok and is set in another thread
+}
+
+static BOOL org_nick_iter(GtkNotebook*nb,char*name,GtkTreeModel**tm,GtkTreeIter*it){
+	gint last=gtk_notebook_page_num(nb,gtk_notebook_get_nth_page(nb,-1));
+	for(int tab=1;tab<=last;tab++){
+		GtkWidget*sc=gtk_notebook_get_nth_page(nb,tab);//scroll
+		if(gtk_label_get_use_markup((GtkLabel*)gtk_notebook_get_tab_label(nb,sc))){//only at global, is too many checks at remove to add at local, where it can be in multiple channels
+			GtkWidget*tv=gtk_bin_get_child((GtkBin*)sc);
+			*tm=gtk_tree_view_get_model((GtkTreeView*)tv);
+
+			gboolean valid=gtk_tree_model_get_iter_first (*tm, it);
+			while(valid){
+				gchar*nick;
+				gtk_tree_model_get (*tm, it, ORG_ID1, &nick, -1);
+				int cmp=strcmp(nickname_prefixless(nick),name);
+				g_free(nick);
+				if(cmp==0)return TRUE;
+				valid = gtk_tree_model_iter_next(*tm, it);
+			}
+		}
+	}
+	return FALSE;
+}
+static unsigned int org_conv_total(){
+	GDir*entries=g_dir_open(".",0,nullptr);
+	unsigned int n=0;
+	if(entries!=nullptr){//something like a fast EACCES permission change, tested
+		while(g_dir_read_name(entries)!=nullptr)n++;
+		g_dir_close(entries);
+	}
+	return n;
+}
+static BOOL org_save_conv(char*user,char*text,const char*server){
+	size_t sz=strlen(text);
+	if(sz!=0){
+		if(to_organizer_folder_server(server)&&chdir(org_u)==0){
+			if( chdir(user)==0||(mkdir(user,0700)==0&&chdir(user)==0) ){
+				unsigned int n=org_conv_total();
+				char buf[digits_in_uintnul];sprintf(buf,"%u",n);
+				FILE*dest=fopen(buf,"wb");
+				if(dest!=nullptr){
+					BOOL ret=fwrite(text,sz,1,dest)==1;
+					fclose(dest);
+					return ret;
+				}
+			}
+		}
+	}
+	return FALSE;
+}
+static void name_closed(GtkTextView*tv,struct name_pack*nm){
+//signal at child destroy will not get notebook tab name at that point, and notebook page-removed same
+//destory is working at reconnect to another server for previous conversation. and for close everything is ok
+	//g_object_unref(tv);//is ok is not required, will be critical, and if is unowned(not this case) is "A floating object was finalized"
+	struct stk_s*ps=nm->ps;
+	if(ps->organizer!=nullptr){
+		const gchar*n_o=gtk_notebook_get_menu_label_text(ps->organizer_notebook,ps->organizer_entry_widget);
+		if(*n_o!=*org_new_names){
+			size_t n_o_sz=strchr(n_o,*not_a_nick_chan_host_start)-n_o;
+			const gchar*n_main=server_name(ps);
+			if(memcmp(n_o,n_main,n_o_sz)==0){//name can be in organizer server then
+				GtkTreeModel*tm;GtkTreeIter iter;
+				if(org_nick_iter(ps->organizer_notebook,nm->name,&tm,&iter)){
+					GtkTextBuffer*b=gtk_text_view_get_buffer(tv);
+					GtkTextIter start;GtkTextIter end;
+					gtk_text_buffer_get_bounds (b, &start, &end);
+					gchar*text = gtk_text_buffer_get_slice (b, &start, &end, TRUE);
+					//save to file
+					if(org_save_conv(nm->name,text,n_main)){
+						//increment iter count
+						gint count;
+						gtk_tree_model_get (tm, &iter, ORG_CONV, &count, -1);
+						count++;
+						gtk_list_store_set((GtkListStore*)tm,&iter,ORG_CONV,count,-1);
+					}
+					g_free(text);
+				}
+			}
+		}
+	}
+	g_free(nm->name);
+	free(nm);
+}
+
+#define destroy "destroy"
+static GtkWidget* name_join_nb(char*t,struct stk_s*ps){
+	struct name_pack*n=(struct name_pack*)malloc(sizeof(struct stk_s*));
+	if(n!=nullptr){
+		n->name=g_strdup(t);
+		n->ps=ps;
+		GtkWidget*tv;
+		GtkWidget*scrl=container_frame_name_out(&tv);
+		g_signal_connect_data (tv,destroy,G_CALLBACK (name_closed),n,nullptr,(GConnectFlags)0);
+		GtkWidget*close;GtkWidget*mn=add_new_tab(scrl,t,&close,ps->notebook,name_on_menu,TRUE);
+		g_signal_connect_data (close, "clicked",G_CALLBACK (close_name),mn,nullptr,G_CONNECT_SWAPPED);//not "(GClosureNotify)gtk_widget_destroy" because at restart clear will be trouble
+		return scrl;
+	}
+	return nullptr;
+}
+static void name_join_main(GtkTreeView*tree,struct stk_s*ps){
 	GtkTreeSelection *sel=gtk_tree_view_get_selection(tree);
 	GtkTreeIter iterator;
-	gtk_tree_selection_get_selected (sel,nullptr,&iterator);
-	char*item_text;
-	gtk_tree_model_get (gtk_tree_view_get_model(tree), &iterator, LIST_ITEM, &item_text, -1);
-	char*a=nickname_start(item_text)?item_text:item_text+1;
-	if(name_join_isnew(ps,a))
-		gtk_notebook_set_current_page(ps->notebook,gtk_notebook_page_num(ps->notebook,name_join_nb(a,ps->notebook)));
-	g_free(item_text);
+	if(gtk_tree_selection_get_selected (sel,nullptr,&iterator)){//this is required at org_chat call only
+		gchar*item_text;
+		gtk_tree_model_get (gtk_tree_view_get_model(tree), &iterator, LIST_ITEM_OR_ORG_ID1, &item_text, -1);
+		char*a=nickname_prefixless(item_text);
+		if(name_join_isnew(ps,a))
+			gtk_notebook_set_current_page(ps->notebook,gtk_notebook_page_num(ps->notebook,name_join_nb(a,ps)));
+		g_free(item_text);
+	}
+}
+static gboolean name_join(GtkTreeView*tree,GdkEvent*ignored,struct stk_s*ps){
+	(void)ignored;
+	name_join_main(tree,ps);
 	return FALSE;//not care about other events
 }
 static GtkWidget* page_from_str(char*c,GtkWidget*men){
@@ -756,13 +1066,14 @@ static GtkWidget* page_from_str(char*c,G
 	return pan;
 }
 #define chan_pan(c) page_from_str(c,chan_menu)
+#define name_on_pan(c) page_from_str(c,name_on_menu)
 #define name_off_pan(c) page_from_str(c,name_off_menu)
 #define name_to_list(c) contf_get_list(chan_pan(c))
 static void chan_change_nr_gain(GtkTreeIter*iter,char*chn,unsigned int nr){
 	GtkTreeIter it=*iter;
 	if(gtk_tree_model_iter_previous( (GtkTreeModel*)channels, &it)==FALSE)return;
 	for(;;){
-		char*text;
+		gchar*text;
 		char c[channul_sz];
 		unsigned int n;
 		gtk_tree_model_get ((GtkTreeModel*)channels, &it, 0, &text, -1);
@@ -782,7 +1093,7 @@ static void chan_change_nr_loss(GtkTreeI
 	GtkTreeIter it=*iter;
 	if(gtk_tree_model_iter_next( (GtkTreeModel*)channels, &it)==FALSE)return;
 	for(;;){
-		char*text;
+		gchar*text;
 		char c[channul_sz];
 		unsigned int n;
 		gtk_tree_model_get ((GtkTreeModel*)channels, &it, 0, &text, -1);
@@ -798,7 +1109,7 @@ static void chan_change_nr_loss(GtkTreeI
 	}
 	gtk_list_store_move_before(channels,iter,&it);
 }
-static BOOL get_chan_counted(const char*chan,char*c,GtkTreeIter*it,char**text){
+static BOOL get_chan_counted(const char*chan,char*c,GtkTreeIter*it,gchar**text){
 	gboolean valid=gtk_tree_model_get_iter_first ((GtkTreeModel*)channels, it);
 	while(valid){
 		gtk_tree_model_get ((GtkTreeModel*)channels, it, 0, text, -1);
@@ -809,7 +1120,7 @@ static BOOL get_chan_counted(const char*
 	}
 	return FALSE;
 }
-static BOOL get_chan_alpha(const char*chan,char*c,GtkTreeIter*it,char**text){
+static BOOL get_chan_alpha(const char*chan,char*c,GtkTreeIter*it,gchar**text){
 	gboolean valid=gtk_tree_model_get_iter_first ((GtkTreeModel*)channels, it);
 	while(valid){
 		gtk_tree_model_get ((GtkTreeModel*)channels, it, 0, text, -1);
@@ -825,7 +1136,7 @@ static BOOL get_chan_alpha(const char*ch
 static BOOL chan_change_nr(const char*chan,int v){
 	GtkTreeIter it;
 	//chan_min hidding
-	char c[chan_sz+1+digits_in_uint+1];char*text;
+	char c[chan_sz+1+digits_in_uint+1];gchar*text;
 	BOOL b;
 	gboolean ac=gtk_check_menu_item_get_active(channels_counted);
 	if(ac){b=get_chan_counted(chan,c,&it,&text);}
@@ -847,7 +1158,13 @@ static BOOL chan_change_nr(const char*ch
 	}
 	return FALSE;
 }
-#define listing_test(a,b) if(gtk_widget_get_has_tooltip(a)==FALSE){gtk_list_store_clear(b);gtk_widget_set_has_tooltip(a,TRUE);}
+static BOOL listing_test(GtkWidget*a,GtkListStore*b){
+	if(gtk_widget_get_has_tooltip(a)==FALSE){
+		gtk_list_store_clear(b);gtk_widget_set_has_tooltip(a,TRUE);
+		return TRUE;
+	}
+	return FALSE;
+}
 #define listing_info(a) "Adding " a "..."
 static gboolean home_page_tooltip (GtkWidget*ignored,int ignored2,int ignored3,gboolean ignored4,GtkTooltip*tooltip){
 	(void)ignored;(void)ignored2;(void)ignored3;(void)ignored4;
@@ -860,9 +1177,12 @@ static void pars_join(char*chan,struct s
 	GtkWidget*pan=chan_pan(chan);
 	if(pan==nullptr){//can be kick and let the channel window
 		pan=container_frame(ps->separator,G_CALLBACK(name_join),ps);
-		gtk_widget_set_tooltip_text(pan,listing_info("names"));//is also a NAMES flag here
+
+		//this was only stopping blank names clear, but now will stop organizer otherwise
+		//gtk_widget_set_tooltip_text(pan,listing_info("names"));//is also a NAMES flag here
+
 		GtkWidget*close;GtkWidget*lb=add_new_tab(pan,chan,&close,ps->notebook,chan_menu,FALSE);
-		g_signal_connect_data (close, "clicked",G_CALLBACK (close_channel),lb,nullptr,G_CONNECT_SWAPPED);
+		g_signal_connect_data (close, "clicked",G_CALLBACK (close_channel),lb,nullptr,G_CONNECT_SWAPPED);//but will close the notebook page only on PART received from the server
 	}
 	gtk_notebook_set_current_page(ps->notebook,gtk_notebook_page_num(ps->notebook,pan));
 	if(chan_change_nr(chan,1)==FALSE)if(test_to_add_chan(ps,1))pars_chan(chan,1,ps->chans_max);
@@ -873,7 +1193,7 @@ static void pars_join_user(char*channm,c
 	GtkTreeIter it;
 	gtk_tree_model_iter_nth_child((GtkTreeModel*)lst, &it, nullptr, gtk_tree_model_iter_n_children((GtkTreeModel*)lst,nullptr)-1);//at least one, we already joined
 	for(;;){
-		char*text;
+		gchar*text;
 		gtk_tree_model_get ((GtkTreeModel*)lst, &it, LIST_ITEM, &text, -1);
 		if(strcmp(nicknm,text)>0||nickname_start(text)==FALSE){
 			g_free(text);
@@ -911,7 +1231,7 @@ static void pars_part(char*c,GtkNotebook
 	g_list_free(lst);
 }
 static BOOL get_iter_unmodes(GtkListStore*lst,GtkTreeIter*it,char*nk){
-	char*txt;
+	gchar*txt;
 	gtk_tree_model_iter_nth_child((GtkTreeModel*)lst, it, nullptr, 
 		gtk_tree_model_iter_n_children((GtkTreeModel*)lst,nullptr)-1);
 	do{
@@ -925,7 +1245,7 @@ static BOOL get_iter_unmodes(GtkListStor
 	return FALSE;
 }
 static char get_iter_modes(GtkListStore*lst,GtkTreeIter*it,char*nk,BOOL notop){
-	char*txt;
+	gchar*txt;
 	gtk_tree_model_get_iter_first ((GtkTreeModel*)lst,it);
 	gtk_tree_model_get ((GtkTreeModel*)lst,it, 0, &txt, -1);
 	char lastmod=*txt^1;//to be dif at first compare
@@ -973,13 +1293,13 @@ static int nick_and_chan(char*a,char*b,c
 static void add_name_lowuser(GtkListStore*lst,char*t){
 	GtkTreeIter it;
 	GtkTreeIter i;
-	char*text;
+	gchar*text;
 	int n=gtk_tree_model_iter_n_children((GtkTreeModel*)lst,nullptr);
 	if(n>0){
 		gtk_tree_model_iter_nth_child((GtkTreeModel*)lst, &it, nullptr, n-1);
 		do{
 			gtk_tree_model_get ((GtkTreeModel*)lst, &it, 0, &text, -1);
-			if(strcmp(t,text)>0||nickname_start(text)==FALSE){
+			if(nickname_start(text)==FALSE||strcmp(t,text)>0){
 				g_free(text);
 				gtk_list_store_insert_after(lst,&i,&it);
 				gtk_list_store_set(lst, &i, LIST_ITEM, t, -1);
@@ -991,14 +1311,21 @@ static void add_name_lowuser(GtkListStor
 	gtk_list_store_prepend(lst,&it);
 	gtk_list_store_set(lst, &it, LIST_ITEM, t, -1);
 }
+static BOOL rank_compare(char*intruder,int intruder_rank,char*defender){
+	int defender_pos=strchr(chanmodessigns,*defender)-chanmodessigns;//example: ~&@%+ ~ is 0, + is 4
+	if(intruder_rank<defender_pos)return TRUE;//is reversed order
+	else if(intruder_rank==defender_pos)return strcmp(intruder,defender+1)<0;
+	return FALSE;
+}
 static void add_name_highuser(GtkListStore*lst,char*t){
 	GtkTreeIter it;
 	GtkTreeIter i;
-	char*text;
+	gchar*text;
 	if(gtk_tree_model_get_iter_first((GtkTreeModel*)lst, &it)){
+		int pos=strchr(chanmodessigns,*t)-chanmodessigns;//example: ~&@%+ ~ is 0, + is 4
 		do{
 			gtk_tree_model_get ((GtkTreeModel*)lst, &it, 0, &text, -1);
-			if(strcmp(t,text)<0||nickname_start(text)){
+			if(nickname_start(text)||rank_compare(t+1,pos,text)){
 				g_free(text);
 				gtk_list_store_insert_before(lst,&i,&it);
 				gtk_list_store_set(lst, &i, LIST_ITEM, t, -1);
@@ -1010,18 +1337,77 @@ static void add_name_highuser(GtkListSto
 	gtk_list_store_append(lst,&it);
 	gtk_list_store_set(lst, &it, LIST_ITEM, t, -1);
 }
-static void add_name(GtkListStore*lst,char*t){
+#define add_name_organizer_macro(l,i,n,x)\
+	gtk_list_store_append(l,&i);\
+	gtk_list_store_set(l, &i, ORG_ID1, n, ORG_IDLE, 0x7fFFffFF, ORG_INDEX, x, -1)
+	//here is at new entries ORG_CONV 0
+static void add_name_organizer(char*name,struct stk_s*ps){
+	if(ps->organizer!=nullptr){
+		if(ps->organizer_can_add_names){
+			GtkListStore*new_entries=ps->organizer_entry_names;
+			GtkTreeIter it;//=GtkTreeIter();
+			gint n=gtk_tree_model_iter_n_children((GtkTreeModel*)new_entries,nullptr);
+			add_name_organizer_macro(new_entries,it,name,n);
+		}
+	}
+}
+static void add_name(GtkListStore*lst,char*t,gpointer ps){
+	add_name_organizer(t,(struct stk_s*)ps);//show with prefix
 	if(nickname_start(t)){add_name_lowuser(lst,t);return;}
 	add_name_highuser(lst,t);
 }
-static void pars_names(GtkWidget*pan,char*b,size_t s){
+
+static char*server_channel_base(char*channel,size_t channel_size,const char*h){
+	size_t hs=strlen(h);
+	char*z=(char*)malloc(hs+1+channel_size+1);
+	if(z!=nullptr){
+		memcpy(z   ,h,hs);
+		z[hs]=*not_a_nick_chan_host_start;
+		hs++;
+		memcpy(z+hs,channel,channel_size);
+		z[hs+channel_size]='\0';
+	}
+	return z;
+}
+static char*server_channel(struct stk_s*ps,char*channel,size_t channel_size){
+	return server_channel_base(channel,channel_size,server_name(ps));
+}
+
+static void pars_names_org(struct stk_s*ps,char*serv_chan){
+	gtk_notebook_set_tab_label_text(ps->organizer_notebook,ps->organizer_entry_widget,serv_chan);
+	gtk_notebook_set_menu_label_text(ps->organizer_notebook,ps->organizer_entry_widget,serv_chan);
+}
+static void pars_names_org_inits(struct stk_s* ps,char*a){
+	ps->organizer_can_add_names=TRUE;
+	pars_names_org(ps,a);
+	gtk_widget_set_sensitive(ps->organizer_bot,TRUE);
+	char buf[digits_in_longnul];
+	sprintf(buf,"%ld",time(nullptr));
+	gtk_label_set_text((GtkLabel*)ps->organizer_entry_widget_timestamp,buf);
+}
+static void pars_names(GtkWidget*pan,char*b,size_t s,struct stk_s* ps,char*channm){
 	GtkListStore*lst=contf_get_list(pan);
-	listing_test(pan,lst)
+	if(listing_test(pan,lst)){//if first from a series of names until endNames
+		if(ps->organizer!=nullptr){
+			char*a=server_channel(ps,channm,strlen(channm));
+			if(a!=nullptr){
+				gchar*text=gtk_combo_box_text_get_active_text((GtkComboBoxText*)ps->organizer_dirs);
+				if(text!=nullptr){//can be a blank organizer too
+					if(strcmp(text,a)==0){
+						gtk_list_store_clear(ps->organizer_entry_names);//required in all cases
+						pars_names_org_inits(ps,a);
+					}else ps->organizer_can_add_names=FALSE;
+					g_free(text);
+				}else pars_names_org_inits(ps,a);
+				free(a);
+			}else ps->organizer_can_add_names=FALSE;
+		}
+	}
 	size_t j=0;
 	for(size_t i=0;i<s;i++){
-		if(b[i]==' '){b[i]='\0';add_name(lst,b+j);b[i]=' ';j=i+1;}
+		if(b[i]==' '){b[i]='\0';add_name(lst,b+j,ps);b[i]=' ';j=i+1;}
 	}
-	add_name(lst,b+j);
+	add_name(lst,b+j,ps);
 }
 static void pars_quit(char*nk){
 	GList*list=gtk_container_get_children((GtkContainer*)chan_menu);
@@ -1035,12 +1421,13 @@ static void pars_quit(char*nk){
 	}
 	g_list_free(ls);
 }
+
 static void pars_mod_set(GtkListStore*lst,char*n,int pos,BOOL plus){
 	GtkTreeIter it;char prevmod;
 	if(plus){
 		if(get_iter_unmodes(lst,&it,n)){
 			gtk_list_store_remove(lst,&it);
-			char buf[1+name_sz+1];*buf=chanmodessigns[pos];
+			char buf[prefix_name_sz+1];*buf=chanmodessigns[pos];
 			strcpy(buf+1,n);
 			add_name_highuser(lst,buf);
 			return;
@@ -1049,7 +1436,7 @@ static void pars_mod_set(GtkListStore*ls
 		if(prevmod!='\0'){
 			if(pos<(strchr(chanmodessigns,prevmod)-chanmodessigns)){
 				gtk_list_store_remove(lst,&it);
-				char buf[1+name_sz+1];*buf=chanmodessigns[pos];
+				char buf[prefix_name_sz+1];*buf=chanmodessigns[pos];
 				strcpy(buf+1,n);
 				add_name_highuser(lst,buf);
 			}
@@ -1063,7 +1450,7 @@ static void pars_mod_set(GtkListStore*ls
 				add_name_lowuser(lst,n);
 				if(chanmodessigns[spos+1]!='\0'){//can be downgraded
 					char downgraded[6+name_sz+irc_term_sz+1];
-					int sz=sprintf(downgraded,"WHOIS %s" irc_term,n);
+					int sz=sprintf(downgraded,whois_str " %s" irc_term,n);
 					send_data(downgraded,(size_t)sz);
 				}
 			}
@@ -1136,6 +1523,7 @@ static void pars_mod_self(struct stk_s*p
 	}
 	ps->visible=FALSE;
 }
+
 static gboolean force_focus(gpointer e){
 	gtk_widget_grab_focus((GtkWidget*)e);
 	return FALSE;
@@ -1160,10 +1548,7 @@ static void prealert(GtkNotebook*nb,GtkW
 		if(alert_widget(box)==nullptr)alert(box,nb);
 	}
 }
-static BOOL is_channel(const char*c){
-	for(int i=0;;i++)if(chantypes[i]==*c)return TRUE;
-		else if(chantypes[i]=='\0')return FALSE;
-}
+
 static void send_msg_type(char*usednick,const char*a,const char*text,GtkWidget*pg,const char*msg_irc_type){
 	const char s_msg[]=" :";
 	size_t len=strlen(msg_irc_type);size_t wid=sizeof(s_msg)-1;
@@ -1175,7 +1560,7 @@ static void send_msg_type(char*usednick,
 	memcpy(b+spc,s_msg,wid);spc+=wid;
 	memcpy(b+spc,text,sz);sz+=spc;
 	if(is_channel(a))addatchans(usednick,text,pg);
-	else addatnames(usednick,text,pg);
+	else addatnames(usednick,text,pg,(char*)a);
 	memcpy(b+sz,irc_term,irc_term_sz);
 	send_data(b,sz+irc_term_sz);
 	free(b);
@@ -1210,16 +1595,16 @@ if(ps->execute_newmsg!=nullptr)\
 		g_spawn_command_line_async(ps->execute_newmsg,nullptr);
 static void pars_pmsg_name(char*n,char*msg,struct stk_s*ps,BOOL is_privmsg,const char*frontname){
 	BOOL novel=TRUE;
-	GtkNotebook*nb=ps->notebook;
 	GList*list=gtk_container_get_children((GtkContainer*)name_on_menu);
 	if(list!=nullptr){
 		GList*lst=list;
+		GtkNotebook*nb=ps->notebook;
 		for(;;){
 			GtkWidget*menu_item=(GtkWidget*)list->data;
 			const char*d=gtk_menu_item_get_label((GtkMenuItem*)menu_item);
 			if(strcmp(n,d)==0){
 				GtkWidget*scrl=get_pan_from_menu(menu_item);
-				addatnames(frontname,msg,scrl);
+				addatnames(frontname,msg,scrl,nullptr);
 				prealert(nb,scrl);
 				if(is_privmsg)exec_nm
 				novel=FALSE;
@@ -1232,7 +1617,8 @@ static void pars_pmsg_name(char*n,char*m
 	}
 	if(novel){
 		if(talk_user(n)){
-			GtkWidget*scrl=name_join_nb(n,nb);addatnames(frontname,msg,scrl);
+			GtkWidget*scrl=name_join_nb(n,ps);addatnames(frontname,msg,scrl,nullptr);
+			GtkNotebook*nb=ps->notebook;
 			alert(gtk_notebook_get_tab_label(nb,scrl),nb);
 			if(is_privmsg){
 				if(ps->welcome!=nullptr){
@@ -1251,7 +1637,11 @@ static void pars_err(char*str,char*msg){
 		return;
 	}
 	pg=name_off_pan(str);
-	if(pg!=nullptr)addatnames(user_error,msg,pg);
+	if(pg!=nullptr)addatnames(user_error,msg,pg,str);//after user quits, ERR_NOSUCHNICK when sending and is not
+	else{
+		pg=name_on_pan(str);
+		if(pg!=nullptr)addatnames(user_error2,msg,pg,str);//after user changed nick, the program is not notified, and ERR_NOSUCHNICK comes in
+	}
 }
 static void line_switch(char*n,GtkWidget*from,GtkWidget*to,const char*msg){
 	GList*list=gtk_container_get_children((GtkContainer*)from);
@@ -1265,7 +1655,7 @@ static void line_switch(char*n,GtkWidget
 				gtk_container_remove((GtkContainer*)from, menu_item);
 				gtk_container_add((GtkContainer*)to, menu_item);
 				g_object_unref(menu_item);//to 1
-				addatnames(user_info,msg,get_pan_from_menu(menu_item));
+				addatnames(user_info,msg,get_pan_from_menu(menu_item),n);
 				break;
 			}
 			list=g_list_next(list);
@@ -1274,17 +1664,210 @@ static void line_switch(char*n,GtkWidget
 		g_list_free(lst);
 	}
 }
+
 static void counting_the_list(GtkWidget*w,const char*a){
 	gtk_widget_set_has_tooltip(w,FALSE);
-	char buf[digits_in_uint+counting_the_list_size+sizeof(list_end_str)];
+	char buf[digits_in_posInt+counting_the_list_size+sizeof(list_end_str)];
 	size_t n=(size_t)sprintf(buf,"%u %s" list_end_str,gtk_tree_model_iter_n_children(contf_get_model(w),nullptr),a);
 	if(w==home_page)addattextmain(buf,n);
 	else addatchans(user_info,buf,w);
 }
-static void names_end(GtkWidget*p,char*chan){
-	counting_the_list(p,names_str);
+
+static void org_move_indexed(GtkTreeModel*m,gint pos){
+	GtkTreeIter it;
+	gint i;GtkSortType s;
+	gboolean is_sorted=gtk_tree_sortable_get_sort_column_id ((GtkTreeSortable*)m, &i, &s);//unsorted is still indexed
+	if(is_sorted)gtk_tree_sortable_set_sort_column_id((GtkTreeSortable*)m,ORG_INDEX,GTK_SORT_ASCENDING);
+	if(gtk_tree_model_iter_nth_child(m, &it, nullptr, pos)){
+		do{
+			gtk_list_store_set((GtkListStore*)m, &it, ORG_INDEX, pos, -1);
+			pos++;
+		}while(gtk_tree_model_iter_next(m, &it));
+	}
+	if(is_sorted)gtk_tree_sortable_set_sort_column_id((GtkTreeSortable*)m,i,s);
+}
+
+static const char*org_getchan(struct stk_s*ps){
+	const gchar*text=gtk_notebook_get_menu_label_text(ps->organizer_notebook,ps->organizer_entry_widget);//Move is active for this label text
+	const char*a=strchr(text,*not_a_nick_chan_host_start);//invalid conversion from const char* to char*   char*a=strchr(text,*not_a_nick_chan_host_start) but man strchr: char *strchr
+	return a+1;
+}
+#define delim_init 10
+static BOOL append_lineSz_tofile(char*text,size_t sz,const char*fname){
+	FILE*f=fopen(fname,"ab");
+	if(f!=nullptr){
+		BOOL ret=FALSE;
+		if(fwrite(text,sz,1,f)==1){
+			char a='\n';
+			if(fwrite(&a,1,1,f)==1)
+				ret=TRUE;
+		}
+		fclose(f);
+		return ret;
+	}
+	return FALSE;
+}
+#define append_line_tofile(l,f) append_lineSz_tofile(l,strlen(l),f)
+static BOOL delete_line_fromfile_pref(const char*text,const char*fname,BOOL raw){
+	FILE*f=fopen(fname,"r+b");
+	if(f!=nullptr){//from here, in case file is manipulated somewhere else, the drive data can be overwrote or increased but not decreased.
+		BOOL ret=FALSE;
+		size_t len=strlen(text);
+		size_t sz=delim_init;
+		char*mem=(char*)malloc(delim_init);
+		if(mem!=nullptr){
+			while(getdelim(&mem,&sz,'\n',f)!=-1){
+				char*inplace;
+				if(raw)inplace=mem;
+				else inplace=nickname_prefixless(mem);
+				if(memcmp(text,inplace,len)==0){
+					if(inplace[len]=='\n'){
+						//move from this file location everything back len bytes
+						long here=ftell(f);
+						if(here!=-1){//if someone compiles for 32 and EINVAL, tested with truncate -s 2147483647 , and the error is at ftell not at getdelim or fseek
+							long back=here-1-len-(inplace-mem);// - prefix if was the case
+							fseek(f,0,SEEK_END);
+							long tel=ftell(f);
+							if(tel!=-1){//same
+								long moved=tel-here;
+								if(moved==0){
+									if(back==0){
+										if(unlink(fname)==0)//this is another descriptor, can be permission in the meantime
+											ret=TRUE;
+										//there's nothing to write, fclose will do nothing next
+									}else{
+										ftruncate(fileno(f),back);
+										ret=TRUE;
+									}
+								}else{
+									fseek(f,here,SEEK_SET);
+									void*m=malloc(moved);
+									if(m!=nullptr){
+										fread(m,moved,1,f);
+										fseek(f,back,SEEK_SET);
+										fwrite(m,moved,1,f);
+										ftruncate(fileno(f),back+moved);
+										free(m);
+										ret=TRUE;
+									}
+								}
+							}
+						}
+						break;
+					}
+				}
+			}
+			free(mem);
+		}
+		fclose(f);
+		return ret;
+	}
+	return FALSE;
+}
+#define delete_line_fromfile(text,fname) delete_line_fromfile_pref(text,fname,TRUE)
+
+static void org_modchanged(GtkNotebook*nb,GtkListStore*list,GtkTreeIter*iter,const char*chan){
+	if(chdir(org_c)==0){
+		if(chdir(chan)==0){
+			gint tab;gint pos;gint ix;
+			gtk_tree_model_get((GtkTreeModel*)list, iter, 3,&tab, 4,&pos, 5,&ix, -1);
+
+			GtkWidget*sc=gtk_notebook_get_nth_page(nb,tab);
+			const gchar*rule=gtk_notebook_get_menu_label_text(nb,sc);
+
+			GtkWidget*tv=gtk_bin_get_child((GtkBin*)sc);
+			GtkTreeModel*tm=gtk_tree_view_get_model((GtkTreeView*)tv);
+			gtk_tree_model_iter_nth_child(tm, iter, nullptr, pos);
+			gchar*old_nick_with_or_without_prefix;
+			gtk_tree_model_get(tm,iter, ORG_ID1,&old_nick_with_or_without_prefix, -1);
+
+			if(delete_line_fromfile(old_nick_with_or_without_prefix,rule)){//delete user from channel list
+				g_free(old_nick_with_or_without_prefix);
+				gtk_list_store_remove((GtkListStore*)tm,iter);
+				org_move_indexed(tm,ix);
+			}
+		}
+	}
+}
+static void org_names_end(struct stk_s* ps){//nick uniqueness
+	if(ps->organizer!=nullptr){
+		if(ps->organizer_can_add_names){
+			//second is for prefix, third for is_global to not change prefix there    , tab      ,pos       , and index at delete
+			GtkListStore*list=gtk_list_store_new(6,G_TYPE_STRING,G_TYPE_INT,G_TYPE_INT,G_TYPE_INT,G_TYPE_INT,G_TYPE_INT);
+			gtk_tree_sortable_set_sort_column_id((GtkTreeSortable*)list,0,GTK_SORT_ASCENDING);
+
+			GtkTreeIter it;gchar*nick;gboolean valid;GtkTreeIter iter;
+			gchar*nick_new;gint nick_new_pref;
+			GtkNotebook*nb=ps->organizer_notebook;
+			gint last=gtk_notebook_page_num(nb,gtk_notebook_get_nth_page(nb,-1));
+			for(int tab=1;tab<=last;tab++){
+				GtkWidget*sc=gtk_notebook_get_nth_page(nb,tab);//scroll
+				GtkWidget*tv=gtk_bin_get_child((GtkBin*)sc);
+				GtkTreeModel*tm=gtk_tree_view_get_model((GtkTreeView*)tv);
+				gboolean is_global=gtk_label_get_use_markup((GtkLabel*)gtk_notebook_get_tab_label(nb,sc));
+
+				valid=gtk_tree_model_get_iter_first (tm, &it);int pos=0;
+				while(valid){
+					gint index;
+					gtk_tree_model_get (tm, &it, ORG_ID1, &nick, ORG_INDEX, &index, -1);//ORG_ID2, &user,-1);
+					//char n_u[prefix_name_sz+1+prefix_name_sz+1];
+					//sprintf(n_u,"%s" defaultstart "%s",nick,user==nullptr?"":user);
+					gtk_list_store_append(list, &iter);
+					if nickname_start(nick) {nick_new=nick;nick_new_pref=0;}
+					else{nick_new=nick+1;nick_new_pref=*nick;}//not at is_global
+					gtk_list_store_set(list,&iter, 0,nick_new, 1,nick_new_pref, 2,is_global, 3,tab, 4,pos, 5,index, -1);
+					g_free(nick);//g_free(user);
+					valid = gtk_tree_model_iter_next(tm, &it);pos++;
+				}
+			}
+			GtkListStore*new_entries=ps->organizer_entry_names;
+			valid=gtk_tree_model_get_iter_first ((GtkTreeModel*)new_entries, &it);//then End of NAMES list can come without users, tested for unexistent channel
+			while(valid){
+				gtk_tree_model_get((GtkTreeModel*)new_entries, &it, ORG_ID1, &nick, -1);
+				if nickname_start(nick){nick_new=nick;nick_new_pref=0;}
+				else{nick_new=nick+1;nick_new_pref=*nick;}
+
+				gtk_list_store_append(list, &iter);
+				gtk_list_store_set(list,&iter,0,nick_new,-1);
+
+				//check only for previous if is same, is sorted
+				GtkTreeIter new_iter=iter;//delete this new iter and let prev which has_pref,is_global,tab,pos
+				if(gtk_tree_model_iter_previous((GtkTreeModel*)list, &iter)){
+					gchar*nickprev;
+					gtk_tree_model_get((GtkTreeModel*)list,&iter, 0,&nickprev, -1);
+					if(strcmp(nick_new,nickprev)==0){
+						gtk_list_store_remove(list,&new_iter);
+
+						gint old_pref;gint is_global;
+						gtk_tree_model_get((GtkTreeModel*)list, &iter, 1,&old_pref, 2,&is_global, -1);
+
+						if(is_global||old_pref==nick_new_pref){//is global with no prefix or local but same/no prefix
+							g_free(nickprev);g_free(nick);
+							valid=gtk_list_store_remove(new_entries,&it);//iter is next valid row
+							//ignore ORG_INDEX? it will look like a bug, 0,1,2  1 is at rules, 0,2  move from rules to first tab  0,2,2
+							//I don't need to move entry from rules back to new entries so don't care
+							//but someone who has only 2 lists and want to move between them will care
+							//adding that the prefix will be lost from global to local, as a side effect, remove the entry at moving back to new entries
+							continue;
+						//only when prefix can be changed   and  when prefix was changed, if one is changing many times can be moved from localNO to globalNO
+						}else if(to_organizer_folder_server_go)org_modchanged(nb,list,&iter,org_getchan(ps));
+						//       to remove from stored                                     //for to remove
+					}
+					g_free(nickprev);
+				}
+
+				g_free(nick);
+				valid = gtk_tree_model_iter_next((GtkTreeModel*)new_entries, &it);
+			}
+			g_object_unref(list);
+		}
+	}
+}
+static void names_end(GtkWidget*p,char*chan,gpointer ps){
+	org_names_end((struct stk_s*)ps);
+	counting_the_list(p,names_small_str);
 	char c[chan_sz+1+digits_in_uint+1];
-	GtkTreeIter it;char*text;
+	GtkTreeIter it;gchar*text;
 	BOOL b;
 	gboolean ac=gtk_check_menu_item_get_active(channels_counted);
 	if(ac){b=get_chan_counted(chan,c,&it,&text);}
@@ -1295,7 +1878,7 @@ static void names_end(GtkWidget*p,char*c
 		sscanf(text+len+1,"%u",&n);
 		g_free(text);
 		GtkListStore*list=contf_get_list(p);
-		int z=gtk_tree_model_iter_n_children ((GtkTreeModel*)list,nullptr);
+		int z=gtk_tree_model_iter_n_children((GtkTreeModel*)list,nullptr);
 		int dif=z-n;
 		if(dif==0)return;
 		if(ac){
@@ -1308,8 +1891,9 @@ static void names_end(GtkWidget*p,char*c
 }
 static void list_end(){
 	if(gtk_widget_get_has_tooltip(home_page))//can be zero channels and this
-		counting_the_list(home_page,chans_str);
+		counting_the_list(home_page,chans_small_str);
 }
+
 static void send_autojoin(struct stk_s*ps){
 	for(size_t i=0;i<ps->ajoins_sum;i++)
 		if(ps->ajoins[i].c==ps->active){
@@ -1323,6 +1907,46 @@ static void action_to_close(){
 	if(ssl!=nullptr)SSL_shutdown(ssl);
 	else if(plain_socket!=-1)shutdown(plain_socket,2);
 }
+
+static void whois_update(GtkNotebook*nb,int col,char*nick,char*text){
+	gint nb_page_index=gtk_notebook_get_current_page(nb);
+	GtkWidget*current=gtk_notebook_get_nth_page(nb,nb_page_index);//scroll
+	GtkWidget*tv=gtk_bin_get_child((GtkBin*)current);
+	GtkTreeModel*tm=gtk_tree_view_get_model((GtkTreeView*)tv);
+	GtkTreeIter it;
+	gboolean valid=gtk_tree_model_get_iter_first (tm, &it);
+	while(valid){//compare at first?yes, is coming from online, no rule to freeze organizer in the meantime yet
+		gchar*n;
+		gtk_tree_model_get (tm, &it, ORG_ID1, &n, -1);
+		if(strcmp(nickname_prefixless(n),nick)==0){
+			g_free(n);
+			gtk_list_store_set((GtkListStore*)tm,&it, col,text, -1);
+			return;
+		}
+		g_free(n);
+		valid = gtk_tree_model_iter_next(tm, &it);
+	}
+}
+static void whois_update_nr(GtkNotebook*nb,char*nick,int seconds){
+	gint nb_page_index=gtk_notebook_get_current_page(nb);
+	GtkWidget*current=gtk_notebook_get_nth_page(nb,nb_page_index);//scroll
+	GtkWidget*tv=gtk_bin_get_child((GtkBin*)current);
+	GtkTreeModel*tm=gtk_tree_view_get_model((GtkTreeView*)tv);
+	GtkTreeIter it;
+	gboolean valid=gtk_tree_model_get_iter_first (tm, &it);
+	while(valid){//compare at first? same
+		gchar*n;
+		gtk_tree_model_get (tm, &it, ORG_ID1, &n, -1);
+		if(strcmp(nickname_prefixless(n),nick)==0){
+			g_free(n);
+			gtk_list_store_set((GtkListStore*)tm,&it, ORG_IDLE,seconds, -1);
+			return;
+		}
+		g_free(n);
+		valid = gtk_tree_model_iter_next(tm, &it);
+	}
+}
+
 static gboolean incsafe(gpointer ps){
 	#pragma GCC diagnostic push
 	#pragma GCC diagnostic ignored "-Wcast-qual"
@@ -1339,7 +1963,13 @@ static gboolean incsafe(gpointer ps){
 		size_t ln=strlen(com);
 		char*b=strchr(a,' ')+1+ln;if(*b==' ')b++;
 		char channm[chan_sz+1+digits_in_uint+1];//+ to set the "chan nr" at join on the same string
+		char channm_simple[channul_sz];//this is extra but is good at compiler warnings
 		char nicknm[namenul_sz];
+		char username[usernul_sz];
+		char hostname[hostnamerfcnul_sz];
+		#define specialsz 32
+		#define specialsz_scan "%31s"
+		char special[specialsz];
 		char c;
 		BOOL is_privmsg=strcmp(com,priv_msg_str)==0;
 		if(is_privmsg||strcmp(com,not_msg_str)==0){
@@ -1348,7 +1978,7 @@ static gboolean incsafe(gpointer ps){
 					if(sscanf(b,channame_scan " %c",channm,&c)==2)pars_pmsg_chan(nicknm,channm,b+strlen(channm)+2,((struct stk_s*)ps)->notebook);
 				}else if(sscanf(b,name_scan " %c",channm,&c)==2)pars_pmsg_name(nicknm,b+strlen(channm)+2,(struct stk_s*)ps,is_privmsg,nicknm);
 			}
-		}else if(strcmp(com,"JOIN")==0){
+		}else if(strcmp(com,join_str)==0){
 			int resp=nick_and_chan(a,b,nicknm,channm,((struct stk_s*)ps)->nknnow);
 			if(resp==0)pars_join(channm,(struct stk_s*)ps);
 			else if(resp==1){pars_join_user(channm,nicknm);line_switch(nicknm,name_off_menu,name_on_menu,"User Join");}
@@ -1370,69 +2000,123 @@ static gboolean incsafe(gpointer ps){
 				pars_mod(channm,mod,nicknm);
 			else if(sscanf(b,"%*s :" mod_scan,mod)==1)pars_mod_self((struct stk_s*)ps,mod);
 		}else if(strcmp(com,"INVITE")==0){
-			if(nick_extract(a,nicknm)&&sscanf(b,"%*s " channame_scan,channm)==1){
+			if(nick_extract(a,nicknm)&&sscanf(b,"%*s " channame_scan,channm_simple)==1){
 				char buf[name_sz+sizeof(invite_str)+chan_sz];//invite_str size includes null
-				sprintf(buf,"%s" invite_str "%s",nicknm,channm);//is ok channm is only chan_sz here
+				sprintf(buf,"%s" invite_str "%s",nicknm,channm_simple);
 				pars_pmsg_name(nicknm,buf,(struct stk_s*)ps,TRUE,"*Invite");
 			}
 		}else if(strlen(com)!=3)showmsg=FALSE;
 		else{
 			showmsg=TRUE;
 			int d=atoi(com);//If no valid conversion could be performed, it returns zero;below,d==0
-			if(d==RPL_LIST){
-				if(show_msg!=RPL_LIST)showmsg=FALSE;
+
+			if(d==RPL_WHOISUSER){
+				show_between_clause(RPL_WHOISUSER) //then, show is true only at manual command whois
+				if(((struct stk_s*)ps)->organizer!=nullptr){
+					int s=sscanf(b,"%*s " name_scan " " user_scan,nicknm,username);//%*[~] is ok only when ~ is
+					if(s==2)whois_update(((struct stk_s*)ps)->organizer_notebook,ORG_ID2,nicknm,*username!='~'?username:username+1);
+				}
+			}else if(d==RPL_WHOISSERVER){// 	RFC1459 	<nick> <server> :<server_info>
+				show_between_clause(RPL_WHOISUSER)
+				if(((struct stk_s*)ps)->organizer!=nullptr){
+					int s=sscanf(b,"%*s " name_scan hostnamerfc_scan,nicknm,hostname);
+					if(s==2)whois_update(((struct stk_s*)ps)->organizer_notebook,ORG_SERVER,nicknm,hostname);
+				}
+			}else if(d==RPL_WHOISIDLE){
+				show_between_clause(RPL_WHOISUSER)
+				if(((struct stk_s*)ps)->organizer!=nullptr){
+					int seconds;
+					int s=sscanf(b,"%*s " name_scan " %u",nicknm,&seconds);
+					if(s==2)whois_update_nr(((struct stk_s*)ps)->organizer_notebook,nicknm,seconds);
+				}
+			}else if(d==RPL_WHOISCHANNELS){
+				show_between_clause(RPL_WHOISUSER)
+				b=strchr(b,' ');
+				if(b!=nullptr){
+					b++;if(sscanf(b,name_scan " %c",nicknm,&c)==2)
+						pars_wmod(nicknm,b+strlen(nicknm)+2);
+				}
+			}else if(d==RPL_WHOISSPECIAL){
+				show_between_clause(RPL_WHOISUSER)
+				if(((struct stk_s*)ps)->organizer!=nullptr){
+					int s=sscanf(b,"%*s " name_scan "  :identifies as " specialsz_scan,nicknm,special);//from https://scp-wiki.wikidot.com/chat-guide
+					if(s==2)whois_update(((struct stk_s*)ps)->organizer_notebook,ORG_GEN,nicknm,special);
+				}
+			}else if(d==RPL_WHOISACCOUNT){// "logged in as"
+				show_between_clause(RPL_WHOISUSER)
+			}else if(d==RPL_AWAY){
+				show_between_clause(RPL_WHOISUSER)
+			}else if(d==RPL_WHOISHOST){
+				show_between_clause(RPL_WHOISUSER)
+			}else if(d==RPL_WHOISMODES){
+				show_between_clause(RPL_WHOISUSER)
+			}else if(d==RPL_ENDOFWHOIS){
+				show_to_clause(RPL_WHOISUSER)
+
+			}else if(d==RPL_LIST){//if -f 0 or the option, this is rare
+				show_between_clause(RPL_LIST)
 				unsigned int e;
 				//if its >nr ,c is not 2
 				if(sscanf(b,"%*s " channame_scan " %u",channm,&e)==2)
 					if(test_to_add_chan(((struct stk_s*)ps),(int)e)){
-						listing_test(home_page,channels)
+						listing_test(home_page,channels);
 						pars_chan(channm,e,((struct stk_s*)ps)->chans_max);
 					}
 			}
 			//not on ircnet: else if(d==321)//RPL_LISTSTART
-			else if(d==323){//RPL_LISTEND
+			else if(d==RPL_LISTEND){
 				show_to_clause(RPL_LIST)
 				list_end();
+
 			}else if(d==RPL_NAMREPLY){
-				if(show_msg!=RPL_NAMREPLY)showmsg=FALSE;
+				show_between_clause(RPL_NAMREPLY)
 				if(sscanf(b,"%*s %*c " channame_scan,channm)==1){
 					GtkWidget*p=chan_pan(channm);
 					if(p!=nullptr){
 						b=strchr(b,':');//join #q:w is error
-						if(b!=nullptr)pars_names(p,b+1,s-(size_t)(b+1-a));
+						if(b!=nullptr)pars_names(p,b+1,s-(size_t)(b+1-a),(struct stk_s*)ps,channm);
 					}
 				}
-			}else if(d==366){//RPL_ENDOFNAMES
+			}else if(d==RPL_ENDOFNAMES){
 				show_to_clause(RPL_NAMREPLY)
 				if(sscanf(b,"%*s " channame_scan,channm)==1){
 					GtkWidget*p=chan_pan(channm);
-					if(p!=nullptr)names_end(p,channm);//at a join
+					if(p!=nullptr)names_end(p,channm,ps);//at a join
 				}
-			}else if(d==332){//RPL_TOPIC
+
+			}else if(d==RPL_TOPIC){
 				if(sscanf(b,name_scan " " channame_scan " %c",nicknm,channm,&c)==3)
 					addatchans(user_topic,b+strlen(nicknm)+1+strlen(channm)+2,chan_pan(channm));
-			}else if(d==319){//RPL_WHOISCHANNELS
-				b=strchr(b,' ');
-				if(b!=nullptr){
-					b++;if(sscanf(b,name_scan " %c",nicknm,&c)==2)
-						pars_wmod(nicknm,b+strlen(nicknm)+2);
-				}
-			}else if(d==5){//RPL_ISUPPORT
+			}else if(d==RPL_ISUPPORT){
 				char*e=strstr(b,"PREFIX=");
 				if(e!=nullptr){
 					sscanf(e+7,"(%6[^)])%6s",chanmodes,chanmodessigns);
 					maximummodes=strlen(chanmodessigns);
 				}
 				e=strstr(b,"CHANTYPES=");
-				if(e!=nullptr)sscanf(e+10,"%4s",chantypes);
-			}else if(d==254){//RPL_LUSERCHANNELS
+				if(e!=nullptr){
+					char chan_types[5];
+					if(sscanf(e+10,"%4s",chan_types)==1){
+						int i=0;
+						for(;;){
+							if(chan_types[i]==*not_a_nick_chan_host_start)//will be collision with homepage at least, and at least at organizer update decider
+								break;
+							i++;
+							if(chan_types[i]=='\0'){
+								strcpy(chantypes,chan_types);
+								break;
+							}
+						}
+					}
+				}
+			}else if(d==RPL_LUSERCHANNELS){
 				send_autojoin((struct stk_s*)ps);
 				//this not getting after first recv
 				//another solution can be after 376 RPL_ENDOFMOTD
 				//or after 1 second, not beautiful
 				send_list
-			}else if(d>400){//Error Replies.
-				switch(d){
+			}else if(d>=ERR_UNKNOWNERROR){//Error Replies.
+				//switch(d){
 					//porbably deprecated
 					//case 436://ERR_NICKCOLLISION
 					//case 464://ERR_PASSWDMISMATCH
@@ -1441,17 +2125,17 @@ static gboolean incsafe(gpointer ps){
 					//case 463://ERR_NOPERMFORHOST
 					//case 465://ERR_YOUREBANNEDCREEP
 					//
-					case 432://ERR_ERRONEUSNICKNAME
-					case 433://ERR_NICKNAMEINUSE
-						action_to_close();
-						break;
-					default:
-						b=strchr(b,' ');
-						if(b!=nullptr){
-							b++;if(sscanf(b,channame_scan " %c",channm,&c)==2)
-								pars_err(channm,b+strlen(channm)+2);
-						}
+					//case 432://ERR_ERRONEUSNICKNAME
+					//case 433://ERR_NICKNAMEINUSE
+					//	action_to_close();//why was to close at these two?
+					//	break;
+				//	default:
+				b=strchr(b,' ');
+				if(b!=nullptr){
+					b++;if(sscanf(b,channame_scan " %c",channm,&c)==2)
+						pars_err(channm,b+strlen(channm)+2);
 				}
+				//}
 			}else if(d==0)showmsg=FALSE;//"abc"
 		}
 	}else showmsg=FALSE;
@@ -1637,15 +2321,7 @@ static void clear_old_chat(GtkNotebook*n
 	start_old_clear(name_off_menu,nb);
 }
 static void proced_core(struct stk_s*ps,char*hostname,char*psw,char*nkn,unsigned short*ports,size_t port_last,size_t swtch){
-	unsigned char n;
-	if(swtch==not_a_switch){
-		GSList*lst=con_group;
-		n=con_nr_max;
-		for(;;){
-			if(gtk_check_menu_item_get_active((GtkCheckMenuItem*)lst->data))break;
-			lst=lst->next;n--;
-		}
-	}else n=_con_nr_s;
+	unsigned char n=ps->proced_n;
 	for(;;){
 		size_t port_i=0;
 		//if(swtch<=port_last&&(n==con_nr_righttype1||n==con_nr_righttype2))n--;//this is useless at :ssl;plain
@@ -1692,17 +2368,65 @@ static void proced_core(struct stk_s*ps,
 		}
 	}
 }
+static gboolean proced_connecting(gpointer b){
+//on main thread
+	chantypes[0]='\0';//no # ? will be one if CHANTYPES= , else channels are names, wrong but not fatal
+	chanmodes[0]='\0';
+	chanmodessigns[0]='\0';//when straight at whois modes
+	maximummodes=0;
+
+	struct stk_s*ps=(struct stk_s*)b;
+	clear_old_chat(ps->notebook);
+	addattextmain(ps->proced_text,-1);
+	unsigned char n;
+	if(ps->proced_switch){
+		GSList*lst=con_group;
+		n=con_nr_max;
+		for(;;){
+			if(gtk_check_menu_item_get_active((GtkCheckMenuItem*)lst->data))break;
+			lst=lst->next;n--;
+		}
+	}else n=_con_nr_s;
+	ps->proced_n=n;
+
+	if(ps->organizer!=nullptr){
+		const gchar*c=gtk_notebook_get_menu_label_text(ps->organizer_notebook,ps->organizer_entry_widget);//or at index 0
+		if(strcmp(c,ps->proced_hostname)!=0)
+			gtk_widget_set_sensitive(ps->organizer_bot,FALSE);//server was changed
+	}
+
+	char hostname[1+hostname_sz]={not_a_nick_chan_host_start};//only first is set in case of arrays
+	strcpy(hostname+1,ps->proced_hostname);
+	gtk_notebook_set_menu_label_text(ps->notebook,home_page,hostname);
+	gtk_notebook_set_tab_label_text(ps->notebook,home_page,hostname);
+
+	pthread_kill( threadid, SIGUSR1);
+	return FALSE;
+}
+static gboolean proced_disconnected(gpointer b){
+	struct stk_s*ps=(struct stk_s*)b;
+	gtk_notebook_set_current_page(ps->notebook,gtk_notebook_page_num(ps->notebook,home_page));
+	addattextmain(ps->proced_text,-1);
+	pthread_kill( threadid, SIGUSR1);
+	return FALSE;
+}
 static void proced(struct stk_s*ps){
 	char hostname[hostname_sz];
 	char psw[password_sz];char nkn[namenul_sz];
 	unsigned short*ports;size_t port_last;size_t swtch;
 	if(parse_host_str(ps->text,hostname,psw,nkn,&ports,&port_last,&swtch,ps)) {
-		main_text_s("Connecting...\n");
-		clear_old_chat(ps->notebook);
+		ps->proced_text="Connecting...\n";
+		ps->proced_switch=swtch==not_a_switch;
+		ps->proced_hostname=hostname;
+		g_idle_add(proced_connecting,ps);
+		int out;sigwait(&threadset,&out);
+
 		proced_core(ps,hostname,psw,nkn,ports,port_last,swtch);
 		free(ports);
-		main_text_s("Disconnected.\n");
-		gtk_notebook_set_current_page(ps->notebook,gtk_notebook_page_num(ps->notebook,home_page));
+
+		ps->proced_text="Disconnected.\n";
+		g_idle_add(proced_disconnected,ps);
+		sigwait(&threadset,&out);
 	}else main_text_s("Error: Wrong input. For format, press the vertical ellipsis button and then Help.\n");
 }
 static gpointer worker (gpointer ps)
@@ -1725,7 +2449,7 @@ static void save_combo_box(GtkTreeModel*
 			while(valid){
 				gchar*text;
 				gtk_tree_model_get (list, &it, 0, &text, -1);
-				if(i){if(write(f,"\n",1)!=1){g_free(text);break;}}
+				if(i){if(write(f,new_line,1)!=1){g_free(text);break;}}
 				else i=TRUE;
 				size_t sz=strlen(text);
 				if((size_t)write(f,text,sz)!=sz){g_free(text);break;}
@@ -1737,7 +2461,8 @@ static void save_combo_box(GtkTreeModel*
 	}
 }
 
-static void set_combo_box_text(GtkComboBox * box,const char*txt) 
+//is new netry or is not
+static BOOL set_combo_box_text(GtkComboBox * box,const char*txt)
 {
 	GtkTreeIter iter;
 	gboolean valid;
@@ -1753,15 +2478,15 @@ static void set_combo_box_text(GtkComboB
 		if (strcmp(item_text, txt) == 0) { 
 			gtk_combo_box_set_active(box, i);
 			g_free(item_text);
-			return;
+			return FALSE;
 		}    
 		g_free(item_text);
 		i++; 
 		valid = gtk_tree_model_iter_next( list_store, &iter);
 	}
 	gtk_combo_box_text_append_text((GtkComboBoxText*)box,txt);
-	save_combo_box(list_store);
 	gtk_combo_box_set_active(box, i);
+	return TRUE;
 }
 static void ignores_init(struct stk_s*ps,int active){
 	for(size_t i=0;i<ps->ignores_sum;i++){
@@ -1780,7 +2505,9 @@ static gboolean enter_recallback( gpoint
 			g_timeout_add(1000,enter_recallback,ps);
 			return FALSE;
 		}
-		set_combo_box_text((GtkComboBox*)((struct stk_s*)ps)->cbt,t);
+		if(set_combo_box_text((GtkComboBox*)((struct stk_s*)ps)->cbt,t)){
+			save_combo_box(gtk_combo_box_get_model((GtkComboBox*)((struct stk_s*)ps)->cbt));
+		}
 		int active=gtk_combo_box_get_active((GtkComboBox*)((struct stk_s*)ps)->cbt);
 		((struct stk_s*)ps)->text=t;((struct stk_s*)ps)->active=active;
 		ignores_init((struct stk_s*)ps,active);
@@ -1800,7 +2527,7 @@ static void info_path_name_set_val(const
 	info_path_name=(char*)malloc(i+2+j+5);
 	if(info_path_name!=nullptr){
 		memcpy(info_path_name,a,i);
-		info_path_name[i]='/';
+		info_path_name[i]=folderseparator;
 		info_path_name[i+1]='.';
 		char*c=info_path_name+i+2;
 		memcpy(c,b,j);
@@ -2012,42 +2739,47 @@ static void help_popup(struct stk_s*ps){
 	gtk_box_pack_start((GtkBox*)box, scrolled_window, TRUE, TRUE, 0);
 	gtk_widget_show_all (dialog);
 }
-static BOOL icmpAmemBstr(const char*s1,const char*s2){
-	for(size_t i=0;;i++){
+static BOOL icmpAmemBstrlownotempty(const char*s1,const char*s2){
+	char b=s2[0];
+	for(size_t i=0;;){
 		char a=s1[i];
-		char c=a-s2[i];
-		if(c!='\0'){
-			if('A'<=a&&a<='Z'){if(a+('a'-'A')!=s2[i])return FALSE;}
-			else if('a'<=a&&a<='z'){if(a-('a'-'A')!=s2[i])return FALSE;}
-			else if(s2[i]=='\0')return TRUE;
-			else return FALSE;
-		}else if(a=='\0')return TRUE;
+		if(a!=b){
+			a+='a'-'A';
+			if(a!=b)return FALSE;
+		}
+		i++;
+		b=s2[i];
+		if(b=='\0')return TRUE;
 	}
 }
 #define is_home(a) *a==*home_string
 static void send_activate(GtkEntry*entry,struct stk_s*ps){
 	GtkEntryBuffer*t=gtk_entry_get_buffer(entry);
-	const char*text=gtk_entry_buffer_get_text(t);
-	//
+	const gchar*text=gtk_entry_buffer_get_text(t);
+	size_t sz=strlen(text);
 	GtkWidget*pg=gtk_notebook_get_nth_page(ps->notebook,gtk_notebook_get_current_page(ps->notebook));
 	const char*a=gtk_notebook_get_menu_label_text(ps->notebook,pg);
-	if(is_home(a)){
-		show_from_clause(text,"list",RPL_LIST)
-		else show_from_clause(text,"names",RPL_NAMREPLY)
-		size_t sz=strlen(text);
-		char*b=(char*)malloc(sz+irc_term_sz);
-		if(b==nullptr)return;
-		memcpy(b,text,sz);
-		memcpy(b+sz,irc_term,irc_term_sz);
-		send_data(b,sz+irc_term_sz);
-		free(b);
-	}else send_msg(ps->nknnow,a,text,pg);
-	if(ps->send_history>0){
-		if(send_entry_list->length==ps->send_history)g_free(g_queue_pop_head(send_entry_list));
-		g_queue_push_tail(send_entry_list,g_strdup(text));
-		send_entry_list_cursor=nullptr;
+	if(sz!=0){//nothing to send else
+		if(is_home(a)){
+			show_from_clause(text,"list",RPL_LIST)
+			else show_from_clause(text,"names",RPL_NAMREPLY)
+			else show_from_clause(text,"whois",RPL_WHOISUSER)
+			char*b=(char*)malloc(sz+irc_term_sz);
+			if(b==nullptr)return;
+			memcpy(b,text,sz);
+			memcpy(b+sz,irc_term,irc_term_sz);
+			send_data(b,sz+irc_term_sz);
+			free(b);
+		}else send_msg(ps->nknnow,a,text,pg);
+		if(ps->send_history>0){
+			if(send_entry_list->length==ps->send_history)g_free(g_queue_pop_head(send_entry_list));
+			g_queue_push_tail(send_entry_list,g_strdup(text));
+			send_entry_list_cursor=nullptr;
+		}
+		gtk_entry_buffer_delete_text(t,0,-1);
+	}else if(is_home(a)){//enters there for visibility
+		addattextmain_n("",0);
 	}
-	gtk_entry_buffer_delete_text(t,0,-1);
 }
 #define menu_con_add_item(n,s,a,b,c,d)\
 a = gtk_radio_menu_item_new_with_label (b, s);\
@@ -2066,7 +2798,7 @@ static void clipboard_tev(GtkNotebook*no
 	else buffer=gtk_text_view_get_buffer((GtkTextView*)gtk_bin_get_child((GtkBin*)pg));
 	GtkTextIter start;GtkTextIter end;
 	gtk_text_buffer_get_bounds (buffer, &start, &end);
-	char*text = gtk_text_buffer_get_text (buffer, &start, &end, FALSE);
+	gchar*text = gtk_text_buffer_get_slice (buffer, &start, &end, TRUE);
 	//an allocated UTF-8 string
 	gtk_clipboard_set_text (gtk_clipboard_get(GDK_SELECTION_CLIPBOARD),text,-1);
 	g_free(text);
@@ -2077,13 +2809,29 @@ static void channels_sort(){
 static void chan_reMin_response (GtkDialog *dialog,gint response,int*chan_min){
 	if(response==GTK_RESPONSE_OK){
 		GList*l=gtk_container_get_children((GtkContainer*)gtk_dialog_get_content_area(dialog));
-		const char*text=gtk_entry_get_text((GtkEntry*)l->data);
+		const gchar*text=gtk_entry_get_text((GtkEntry*)l->data);
 		g_list_free(l);
-		*chan_min=atoi(text);
-		send_list_if
+		if(strlen(text)!=0){//else is like the placeholder
+			*chan_min=atoi(text);
+			send_list_if
+		}
 	}
 	gtk_widget_destroy((GtkWidget*)dialog);
 }
+static gboolean to_placeholder(GtkEntry*en,GdkEventKey*event){
+	if(event->type==GDK_KEY_PRESS){
+		if('0'<=event->keyval&&event->keyval<='9'){
+			GtkEntryBuffer*buf=gtk_entry_get_buffer(en);
+			//gtk_entry_buffer_insert_text(buf,gtk_entry_buffer_get_length(buf), //coming back there is not relevant at this point
+			//gtk_entry_buffer_set_text(buf, //this is delete text and isert at 0
+			gtk_entry_buffer_insert_text(buf,0,(const gchar*)&event->keyval,1);//this is the faster
+			gtk_widget_grab_focus((GtkWidget*)en);
+			gtk_editable_set_position((GtkEditable*)en, -1);//the text is selected all, need to move cursor to end
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
 static void chan_reMin(struct stk_s*ps){
 	GtkWidget *dialog = gtk_dialog_new_with_buttons ("Channel Minimum Users",
 			    ps->main_win, (GtkDialogFlags)(GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL),
@@ -2097,7 +2845,9 @@ static void chan_reMin(struct stk_s*ps){
 	GtkWidget*box=gtk_dialog_get_content_area((GtkDialog*)dialog);
 	gtk_box_pack_start((GtkBox*)box, entry, TRUE, TRUE, 0);
 
-	gtk_widget_grab_focus(gtk_dialog_get_widget_for_response((GtkDialog*)dialog, GTK_RESPONSE_OK));//this to see the placeholder
+	GtkWidget*wg=gtk_dialog_get_widget_for_response((GtkDialog*)dialog, GTK_RESPONSE_OK);
+	g_signal_connect_data (wg, "key-press-event",G_CALLBACK (to_placeholder),entry,nullptr,G_CONNECT_SWAPPED);//this will swap with first arg, not second GdkEventKey
+	gtk_widget_grab_focus(wg);//this to see the placeholder
 
 	gtk_widget_show_all (dialog);
 }
@@ -2115,49 +2865,7 @@ static void reload_tabs(GtkWidget*menu_f
 		g_list_free(lst);
 	}
 }
-static gboolean prog_key_press (struct stk_s*ps, GdkEventKey  *event){
-	if(event->type==GDK_KEY_PRESS){
-		if((event->state&GDK_CONTROL_MASK)!=0){
-			unsigned int K=gdk_keyval_to_upper(event->keyval);
-			if(K==GDK_KEY_T){
-				GList*lst=gtk_container_get_children((GtkContainer*)menuwithtabs);
-				GList*list=lst;
-				for(;;){
-					list=g_list_next(list);
-					if(list==nullptr)break;
-					gtk_widget_destroy((GtkWidget*)list->data);
-				}
-				g_list_free(lst);
-				reload_tabs(chan_menu,menuwithtabs,ps->notebook);
-				reload_tabs(name_on_menu,menuwithtabs,ps->notebook);
-				reload_tabs(name_off_menu,menuwithtabs,ps->notebook);
-				gtk_menu_popup_at_widget((GtkMenu*)menuwithtabs,(GtkWidget*)ps->notebook,GDK_GRAVITY_NORTH_WEST,GDK_GRAVITY_NORTH_WEST,nullptr);
-			}else if(K==GDK_KEY_C){
-				GtkWidget*pg=gtk_notebook_get_nth_page(ps->notebook,gtk_notebook_get_current_page(ps->notebook));
-				if(is_home(gtk_notebook_get_menu_label_text(ps->notebook,pg))==FALSE)gtk_button_clicked((GtkButton*)tab_close_button(ps->notebook,pg));
-			}else if(K==GDK_KEY_Q)action_to_close();
-			else if(K==GDK_KEY_X)g_application_quit(ps->app);
-		}else if(event->keyval==GDK_KEY_Up&&gtk_widget_is_focus(ps->sen_entry)){
-			if(send_entry_list_cursor!=send_entry_list->head){
-				send_entry_list_cursor=send_entry_list_cursor==nullptr?
-					send_entry_list->tail
-					:send_entry_list_cursor->prev;
-				gtk_entry_set_text((GtkEntry*)ps->sen_entry,(const char*)send_entry_list_cursor->data);
-				return TRUE;//lost focus other way
-			}
-		}else if(event->keyval==GDK_KEY_Down&&gtk_widget_is_focus(ps->sen_entry)){
-			if(send_entry_list_cursor!=nullptr){
-				send_entry_list_cursor=send_entry_list_cursor->next;
-				GtkEntryBuffer*buf=gtk_entry_get_buffer((GtkEntry*)ps->sen_entry);
-				gtk_entry_buffer_delete_text(buf,0,-1);
-				if(send_entry_list_cursor!=nullptr)gtk_entry_buffer_insert_text(buf,0,(const char*)send_entry_list_cursor->data,-1);
-				return TRUE;//is trying to switch focus
-			}
-		}
-	}
-	return FALSE;//propagation seems fine
-}
-static void gather_parse(size_t*sum,char*mem,struct ajoin**ons){
+static void gather_parse(size_t*sum,gchar*mem,struct ajoin**ons){
 	*sum=0;
 	for(size_t i=0;;i++){
 		BOOL b=mem[i]=='\0';
@@ -2206,7 +2914,7 @@ static void gather_parse(size_t*sum,char
 		j++;k=j;
 	}
 }
-static void gather_free(size_t sum,char*mem,struct ajoin*ins){
+static void gather_free(size_t sum,gchar*mem,struct ajoin*ins){
 	if(sum>0){
 		g_free(mem);
 		for(size_t i=0;i<sum;i++)if(ins[i].chans!=&dummy)
@@ -2215,61 +2923,942 @@ static void gather_free(size_t sum,char*
 	}
 }
 
-#define bind "Bind"
-#define unbind "UnBind"
-static void deciderfn(GtkButton*a){
-	if(strcmp(gtk_button_get_label(a),bind)==0)gtk_button_set_label(a,unbind);
-	else gtk_button_set_label(a,bind);
+static void deciderfn(struct stk_s*ps){
+	const char*b=gtk_notebook_get_menu_label_text(ps->notebook,gtk_notebook_get_nth_page(ps->notebook,gtk_notebook_get_current_page(ps->notebook)));
+	if(is_channel(b)){
+		size_t bs=strlen(b);
+		char*z=server_channel(ps,(char*)b,bs);
+		if(z!=nullptr){
+			int current=gtk_combo_box_get_active(ps->organizer_dirs);
+			if(set_combo_box_text(ps->organizer_dirs,z)==FALSE){//is an existent entry
+				if(gtk_combo_box_get_active(ps->organizer_dirs)==current){//is same entry already selected
+					gtk_widget_set_sensitive(ps->organizer_bot,FALSE);//will be TRUE when names comes in
+					send_channel_related((char*)names_str,(char*)b,bs);
+				}
+			}else gtk_widget_set_sensitive(ps->organizer_removeentry,TRUE);
+			free(z);
+		}
+	}
+	else{
+		#define org_pop_er "Must be in a channel"
+		addattextmain_n(org_pop_er,sizeof(org_pop_er)-1);
+	}
+}
+static void org_clear_rules(GtkNotebook*nb){
+	gint last=gtk_notebook_page_num(nb,gtk_notebook_get_nth_page(nb,-1));
+	for(int i=1;i<=last;i++){
+		GtkWidget*sc=gtk_notebook_get_nth_page(nb,i);//scroll
+		GtkWidget*tv=gtk_bin_get_child((GtkBin*)sc);
+		GtkTreeModel*tm=gtk_tree_view_get_model((GtkTreeView*)tv);
+		gtk_list_store_clear((GtkListStore*)tm);
+	}
+}
+static void org_repopulate(BOOL is_global,GtkNotebook*nb){
+	gint last=gtk_notebook_page_num(nb,gtk_notebook_get_nth_page(nb,-1));
+	for(int i=1;i<=last;i++){
+		GtkWidget*sc=gtk_notebook_get_nth_page(nb,i);//scroll
+		gboolean tab_is_global=gtk_label_get_use_markup((GtkLabel*)gtk_notebook_get_tab_label(nb,sc));
+		if(is_global==tab_is_global){
+			const gchar*rulename=gtk_notebook_get_menu_label_text(nb,sc);
+			FILE*f=fopen(rulename,"rb");
+			if(f!=nullptr){
+				size_t sz=delim_init;
+				char*mem=(char*)malloc(delim_init);
+				if(mem!=nullptr){
+					GtkWidget*tv=gtk_bin_get_child((GtkBin*)sc);
+					GtkListStore*tm=(GtkListStore*)gtk_tree_view_get_model((GtkTreeView*)tv);
+					int pos=0;
+					while(getdelim(&mem,&sz,'\n',f)!=-1){
+						mem[strlen(mem)-1]='\0';
+						GtkTreeIter iter;
+						add_name_organizer_macro(tm,iter,mem,pos);
+						pos++;
+					}
+					free(mem);
+				}
+				fclose(f);
+			}
+		}
+	}
+}
+static void org_repopulate_conv(GtkNotebook*nb){
+	gint last=gtk_notebook_page_num(nb,gtk_notebook_get_nth_page(nb,-1));
+	for(int i=1;i<=last;i++){
+		GtkWidget*sc=gtk_notebook_get_nth_page(nb,i);//scroll
+		if(gtk_label_get_use_markup((GtkLabel*)gtk_notebook_get_tab_label(nb,sc))){//conv only at global
+			GtkWidget*tv=gtk_bin_get_child((GtkBin*)sc);
+			GtkTreeModel*tm=gtk_tree_view_get_model((GtkTreeView*)tv);
+			GtkTreeIter iter;
+			gboolean valid = gtk_tree_model_get_iter_first (tm, &iter);
+			if(valid){
+				do{
+					gchar*nick;
+					gtk_tree_model_get (tm, &iter, ORG_ID1, &nick, -1);
+					if(g_file_test(nick,G_FILE_TEST_IS_DIR)){
+						if(chdir(nick)==0){
+							unsigned int n=org_conv_total();
+							gtk_list_store_set((GtkListStore*)tm,&iter, ORG_CONV, n, -1);
+							if(chdir("..")!=0){g_free(nick);return;}
+						}else{g_free(nick);return;}
+					}
+					g_free(nick);
+					valid = gtk_tree_model_iter_next(tm, &iter);
+				}while(valid);
+			}
+		}
+	}
+}
+static void org_changed(GtkComboBoxText *combo_box,struct stk_s*ps)//, gpointer user_data)
+{
+	gint current_pos=gtk_combo_box_get_active ((GtkComboBox*)combo_box);
+	if(current_pos!=-1){//this is the case when last entry is deleted
+		if(to_organizer_folder_go){//is possible to be in another folder
+			gchar*text=gtk_combo_box_text_get_active_text (combo_box);
+			//not this check, is the server folder there//if(*text!=chan..){//only if the folder is malevolently changed(this case is at list repopulation)
+			char*chan=strchr(text,*not_a_nick_chan_host_start);
+			//not this check, is the channel folder there//if(chan!=nullptr){//only if the folder is malevolently changed(this case is at list repopulation)
+			*chan='\0';
+			if(chdir(text)==0||(mkdir(text,0700)==0&&chdir(text)==0)){
+				if(chdir(org_g)==0||(mkdir(org_g,0700)==0&&chdir(org_g)==0)){
+					//empty current global/local
+					org_clear_rules(ps->organizer_notebook);
+
+					//retake global lists
+					org_repopulate(TRUE,ps->organizer_notebook);
+
+					if(chdir(dirback)==0){
+						if(chdir(org_c)==0||(mkdir(org_c,0700)==0&&chdir(org_c)==0)){
+							chan++;
+							if(chdir(chan)==0||(mkdir(chan,0700)==0&&chdir(chan)==0)){
+								//retake local lists
+								org_repopulate(FALSE,ps->organizer_notebook);
+
+								if(chdir(dirback)==0&&chdir(dirback)==0){
+									if(chdir(org_u)==0||(mkdir(org_u,0700)==0&&chdir(org_u)==0)){
+										//users conversations, here or at retake but there must malloc and form ../users/nick
+										org_repopulate_conv(ps->organizer_notebook);
+										//populate main tab
+										send_channel_related((char*)names_str,chan,strlen(chan));
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+			g_free(text);
+		}
+	}
+	gtk_widget_set_sensitive(ps->organizer_bot,FALSE);//will be TRUE when names comes in
+}
+
+static BOOL org_delconf(struct stk_s*ps){
+	if(gtk_toggle_button_get_active(ps->organizer_del_confirmation)){
+		GtkWidget*dialog=gtk_message_dialog_new((GtkWindow*)ps->organizer,GTK_DIALOG_DESTROY_WITH_PARENT/*modal will be at dialog_run*/,GTK_MESSAGE_QUESTION,GTK_BUTTONS_YES_NO,"Delete the list?");
+		gint response=gtk_dialog_run((GtkDialog*)dialog);
+		gtk_widget_destroy (dialog);
+		return response==GTK_RESPONSE_YES;
+	}
+	return TRUE;
 }
 
-static void organizer_populate(GtkWidget*window){
-	GtkNotebook*nb = (GtkNotebook*)gtk_notebook_new ();
+static void folder_rm(){//at lists is important to not let the file because can have duplicates if reparsed
+	GDir*entries=g_dir_open(".",0,nullptr);
+	if(entries!=nullptr){
+		for(;;){
+			const gchar*file=g_dir_read_name(entries);
+			if(file==nullptr)break;
+			unlink(file);//the list is not if no user is in the list, that will be -1 //!=0){r=-1;break;}
+		}
+		g_dir_close(entries);
+	}//else return -1;
+	//return 0;
+}
+static BOOL folder_enter_rm(const gchar*folder){
+	if(chdir(folder)==0){
+		folder_rm();
+		if(chdir("..")!=0)return FALSE;
+		rmdir(folder);
+	}
+	return TRUE;
+}
+static BOOL iterate_folders_enter_rm(){
+	GDir*entries=g_dir_open(".",0,nullptr);
+	if(entries!=nullptr){
+		for(;;){
+			const gchar*dir=g_dir_read_name(entries);
+			if(dir==nullptr)break;
+			if(g_file_test(dir,G_FILE_TEST_IS_DIR))
+				if(folder_enter_rm(dir)==FALSE){g_dir_close(entries);return FALSE;}
+		}
+		g_dir_close(entries);
+	}//else return -1;
+	return TRUE;
+}
+static void iterate_folders_enter(int (*f)(const char*, void*),void*data){
+	GDir*entries=g_dir_open(".",0,nullptr);
+	if(entries!=nullptr){
+		for(;;){
+			const gchar*dir=g_dir_read_name(entries);
+			if(dir==nullptr)break;
+			if(g_file_test(dir,G_FILE_TEST_IS_DIR)){
+				if(chdir(dir)==0){
+					if(f(dir,data)!=0)break;//{r=-1;break;}//has inner chdirs
+					if(chdir("..")!=0)break;//{r=-1;break;}
+				}else break;//{r=-1;break;}
+			}
+		}
+		g_dir_close(entries);
+	}//else return -1;
+}
+static BOOL iterate_folders_enter2(int (*f)(const char*),const char*data){
+	GDir*entries=g_dir_open(".",0,nullptr);
+	if(entries!=nullptr){
+		for(;;){
+			const gchar*dir=g_dir_read_name(entries);
+			if(dir==nullptr)break;
+			if(g_file_test(dir,G_FILE_TEST_IS_DIR)){
+				if(chdir(dir)==0){
+					if(f(data)!=0){g_dir_close(entries);return FALSE;}//has inner chdirs
+					if(chdir("..")!=0){g_dir_close(entries);return FALSE;}
+				}else break;//{r=-1;break;}
+			}
+		}
+		g_dir_close(entries);
+	}//else return -1;
+	return TRUE;
+}
+static void iterate_folders(void (*f)(const char*, void*),void*data){
+	GDir*entries=g_dir_open(".",0,nullptr);
+	if(entries!=nullptr){
+		for(;;){
+			const gchar*dir=g_dir_read_name(entries);
+			if(dir==nullptr)break;
+			if(g_file_test(dir,G_FILE_TEST_IS_DIR)){
+				f(dir,data);//!=0){r=-1;break;}
+			}
+		}
+		g_dir_close(entries);
+	}//else return -1;
+}
+
+static BOOL org_removechan_global(gchar*server){
+	if(chdir(org_g)==0){
+		folder_rm();//remove global lists
+		if(chdir(dirback)==0){
+			rmdir(org_g);
+			if(chdir(org_u)==0){
+				if(iterate_folders_enter_rm()){
+					if(chdir(dirback)==0){
+						rmdir(org_u);
+						if(chdir(dirback)==0){
+							rmdir(server);
+							return TRUE;
+						}
+					}
+				}
+			}
+		}
+	}
+	return FALSE;
+}
+static void org_removechan(struct stk_s*ps){
+	if(org_delconf(ps)){//is for preventing double click deletes
+		if(to_organizer_folder_go){//is possible to be in another folder
+			GtkComboBox *combo_box=ps->organizer_dirs;
+			gchar*text=gtk_combo_box_text_get_active_text((GtkComboBoxText*)combo_box);
+			char*chan=strchr(text,*not_a_nick_chan_host_start);
+			*chan='\0';chan++;
+			if(chdir(text)==0&&chdir(org_c)==0&&chdir(chan)==0){
+				folder_rm();//remove local lists
+				if(chdir(dirback)==0){
+					rmdir(chan);
+					if(chdir(dirback)==0){
+						if(rmdir(org_c)!=0||org_removechan_global(text)){//test to see if was not the last channel in server   or   remove restof the data
+							gtk_combo_box_text_remove((GtkComboBoxText*)combo_box,gtk_combo_box_get_active (combo_box));
+							if(gtk_tree_model_iter_n_children(gtk_combo_box_get_model(combo_box),nullptr)==0){//if was last overall
+								gtk_widget_set_sensitive(ps->organizer_removeentry,FALSE);
+								pars_names_org(ps,(char*)org_new_names);
+								gtk_list_store_clear(ps->organizer_entry_names);
+								org_clear_rules(ps->organizer_notebook);
+							}else{//there is segmentation at the moment if clicked again and nothing selected
+								gtk_combo_box_set_active(combo_box,0);
+							}
+						}
+					}
+				}
+			}
+			g_free(text);
+		}
+	}
+}
+
+void organizer_tab_column_click(struct org_col*st){
+	gint pos=st->pos;
+	GtkTreeSortable*sort=st->sort;
+	gint i;GtkSortType s;
+	gboolean b=gtk_tree_sortable_get_sort_column_id (sort, &i, &s);
+	// It returns TRUE unless the sort_column_id is GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
+	if(b){
+		if(i==pos){
+			if(s==GTK_SORT_DESCENDING)
+				gtk_tree_sortable_set_sort_column_id(sort,pos,GTK_SORT_ASCENDING);
+			else
+				gtk_tree_sortable_set_sort_column_id(sort,pos,GTK_SORT_DESCENDING);
+		}else{
+			gtk_tree_sortable_set_sort_column_id(sort,pos,GTK_SORT_DESCENDING);
+		}
+	}else{
+		gtk_tree_sortable_set_sort_column_id(sort,pos,GTK_SORT_DESCENDING);
+	}
+}
+static void organizer_tab_column_add(GtkTreeView*tree,char*name,int pos,GtkTreeSortable*sort){
+	struct org_col*s=(struct org_col*)malloc(sizeof(struct org_col));
+	if(s!=nullptr){
+		s->pos=pos;s->sort=sort;
+		GtkCellRenderer *renderer= gtk_cell_renderer_text_new();
+		GtkTreeViewColumn *column = gtk_tree_view_column_new_with_attributes(name, renderer, "text", pos, nullptr);//"value" at progress. btw is sorting G_TYPE_INT ok
+		g_signal_connect_data(column,"clicked",G_CALLBACK(organizer_tab_column_click),(gpointer)s,(GClosureNotify)free,G_CONNECT_SWAPPED);
+		gtk_tree_view_column_set_expand (column,TRUE);
+		gtk_tree_view_column_set_clickable(column,TRUE);
+		gtk_tree_view_column_set_resizable(column,TRUE);
+		gtk_tree_view_append_column(tree, column);
+	}
+}
+static GtkListStore* organizer_tab_add(GtkNotebook*nb,char*title,GtkWidget**child_out,gboolean is_global){
+	//                                                       nick             user           gender         idle in minutes server         id of append number of conversations
+	GtkTreeSortable*sort;
+	if(is_global)
+		sort=(GtkTreeSortable*)gtk_list_store_new(ORG_N,   G_TYPE_STRING,   G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INT,     G_TYPE_STRING, G_TYPE_INT,  G_TYPE_INT);//is already sortable
+	else
+		sort=(GtkTreeSortable*)gtk_list_store_new(ORG_N-1, G_TYPE_STRING,   G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INT,     G_TYPE_STRING, G_TYPE_INT);
+	//any filter can come here
+	//GtkTreeModel*sort=gtk_tree_model_sort_new_with_model(list);
+	//g_object_unref(list);
+
+	//GtkTreeIter it;gtk_list_store_append(list,&it);gtk_list_store_set(list, &it, 0, "a", 1, "x", 2,"x",3,1,-1);gtk_list_store_append(list,&it);gtk_list_store_set(list, &it, 0, "b", 1, "x", 2,"x",3,2,-1);
+
+	GtkWidget*treeV=gtk_tree_view_new_with_model((GtkTreeModel*)sort);
+	g_object_unref(sort);
+
+	organizer_tab_column_add((GtkTreeView*)treeV,(char*)"Id",ORG_ID1,sort);
+	organizer_tab_column_add((GtkTreeView*)treeV,(char*)"AKA",ORG_ID2,sort);
+	organizer_tab_column_add((GtkTreeView*)treeV,(char*)"Gender",ORG_GEN,sort);
+	organizer_tab_column_add((GtkTreeView*)treeV,(char*)"Idle",ORG_IDLE,sort);
+	organizer_tab_column_add((GtkTreeView*)treeV,(char*)"Server",ORG_SERVER,sort);
+	organizer_tab_column_add((GtkTreeView*)treeV,(char*)"Index",ORG_INDEX,sort);
+	if(is_global)
+		organizer_tab_column_add((GtkTreeView*)treeV,(char*)"Conversations",ORG_CONV,sort);
+
+	GtkWidget*scroll = gtk_scrolled_window_new(nullptr, nullptr);
+	if(child_out!=nullptr)//only at restore but that is the highest usage anyway
+		*child_out=scroll;
+	gtk_container_add((GtkContainer*)scroll,treeV);
+	GtkWidget*tab;
+	if(is_global){
+		tab = gtk_label_new (nullptr);
+		gchar *markup= g_markup_printf_escaped ("<u>\%s</u>", title);
+		gtk_label_set_markup (((GtkLabel*)tab), markup);
+		g_free(markup);
+	}else{
+		tab=gtk_label_new(title);
+	}
+	gtk_notebook_append_page_menu(nb,scroll,tab,gtk_label_new(title));
+	return (GtkListStore*)sort;
+}
+
+static void organizer_populate_dirs_chans(const char*dir,void*s){
+	char*nm=server_channel_base((char*)dir,strlen(dir),((struct organizer_from_storage*)s)->server);
+	if(nm!=nullptr){
+		gtk_combo_box_text_append_text(((struct organizer_from_storage*)s)->box,nm);
+		free(nm);
+	}
+}
+static int organizer_populate_dirs(const char*dir,void*box){
+	if(chdir("chans")==0){
+		struct organizer_from_storage s={(GtkComboBoxText*)box,dir};
+		iterate_folders(organizer_populate_dirs_chans,&s);//==0){
+		return chdir("..");
+	}
+	return 0;
+}
+
+#define localrules "_local"
+#define globalrules "_global"
+static BOOL org_storerule(const char*text,size_t sz,gboolean is_global){//this way or search at start for files
+	if(to_organizer_folder_go){
+		const char*fname;if(is_global)fname=globalrules;
+		else fname=localrules;
+		return append_lineSz_tofile((char*)text,sz,fname);
+	}
+	return FALSE;
+}
+
+static int org_deleterule_global(const gchar*rule){
+	if(chdir(org_g)==0){
+		FILE*users=fopen(rule,"rb");
+		if(users!=nullptr){
+			fseek(users,0,SEEK_END);
+			long end=ftell(users);
+			if(end!=-1){
+				char*mem=(char*)malloc(end+1);
+				if(mem!=nullptr){
+					fseek(users,0,SEEK_SET);
+					fread(mem,end,1,users);
+					mem[end]='\0';
+					fclose(users);
+					unlink(rule);   //remove the rule
+					if(chdir(dirback)!=0){free(mem);return -1;}
+					if(chdir(org_u)==0){// and at users remove conversations from what names rule has
+						char*name=mem;
+						for(;;){
+							char*next=strchr(name,'\n');
+							if(next==nullptr)break;
+							*next='\0';
+							if(folder_enter_rm(name)==FALSE){free(mem);return -1;}
+							next++;
+							name=next;
+						}
+						free(mem);
+					}else free(mem);
+				}else fclose(users);
+			}else fclose(users);
+		}
+		return chdir(dirback);//this is for org_u (or for org_g)
+	}
+	return 0;
+}
+static int org_deleterule_local(const gchar*rule){
+	if(chdir(org_c)==0){
+		GDir*channels=g_dir_open(".",0,nullptr);
+		if(channels!=nullptr){
+			for(;;){
+				const gchar*chan=g_dir_read_name(channels);
+				if(chan==nullptr)break;
+				if(chdir(chan)==0){
+					unlink(rule);
+					if(chdir(dirback)!=0){g_dir_close(channels);return -1;}
+				}
+			}
+			g_dir_close(channels);
+		}
+		return chdir(dirback);
+	}
+	return 0;
+}
+static BOOL org_deleterule(GtkLabel*label){
+	if(to_organizer_folder_go){
+		const gchar*rule=gtk_label_get_text(label);
+		gboolean is_global=gtk_label_get_use_markup(label);
+		if(is_global){
+			if(iterate_folders_enter2(org_deleterule_global,rule))//delete list/list_conversations at all servers
+				return delete_line_fromfile(rule,globalrules);
+		}
+		else if(iterate_folders_enter2(org_deleterule_local,rule))//delete list at all servers+channels
+			return delete_line_fromfile(rule,localrules);
+	}
+	return FALSE;
+}
+
+static void org_addrule(struct stk_s*ps){
+	GtkWidget*dialog= gtk_dialog_new_with_buttons ("Add Rule",(GtkWindow*)ps->organizer,(GtkDialogFlags)(GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL),
+			    "_Cancel",GTK_RESPONSE_CANCEL,"_OK",GTK_RESPONSE_OK,nullptr);
+	GtkWidget*content=gtk_dialog_get_content_area((GtkDialog*)dialog);
+	GtkWidget*options=gtk_box_new(GTK_ORIENTATION_VERTICAL,0);
+
+	GtkWidget*name=gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);
+
+	GtkWidget*nm=gtk_label_new("Name");
+	gtk_box_pack_start((GtkBox*)name,nm,FALSE,FALSE,0);
+	GtkWidget*entry = gtk_entry_new();
+	gtk_box_pack_start((GtkBox*)name, entry, TRUE, TRUE, 0);
+	gtk_box_pack_start((GtkBox*)options,name,TRUE,TRUE,0);
+
+	GtkWidget*scope=gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);
+	GtkWidget*r1=gtk_radio_button_new_with_label(nullptr,"Local");//no mnemonics here
+	gtk_box_pack_start((GtkBox*)scope,r1,FALSE,FALSE,0);
+	GtkWidget*r2=gtk_radio_button_new_with_label_from_widget((GtkRadioButton*)r1,"Global");
+	gtk_box_pack_start((GtkBox*)scope,r2,FALSE,FALSE,0);
+
+	gtk_box_pack_start((GtkBox*)options,scope,FALSE,FALSE,0);
+	gtk_box_pack_start((GtkBox*)content,options,TRUE,TRUE,0);
+	gtk_widget_show_all (dialog);//this to see the new widgets
+	int response=gtk_dialog_run((GtkDialog*)dialog);
+	if(response==GTK_RESPONSE_OK){
+		const gchar*text=gtk_entry_get_text((GtkEntry*)entry);
+		size_t sz=strlen(text);
+		if(sz!=0){
+			gboolean is_global=gtk_toggle_button_get_active((GtkToggleButton*)r2);
+			if(org_storerule(text,sz,is_global)){
+				GtkWidget*s;
+				organizer_tab_add(ps->organizer_notebook,(char*)text,&s,is_global);
+				gtk_widget_show_all(s);//to see the tab
+				gtk_widget_set_sensitive(ps->organizer_removerule,TRUE);
+			}
+		}
+	}
+	gtk_widget_destroy (dialog);
+}
+static void org_removerule(GtkWidget*thisone,struct stk_s*ps){
+	GtkNotebook*nb=ps->organizer_notebook;
+	gint index=gtk_notebook_get_current_page(nb);
+	if(index>0){//first page is with New
+		if(org_delconf(ps)){//is for preventing double click deletes
+			GtkWidget*current=gtk_notebook_get_nth_page(nb,index);//scroll
+			GtkWidget*label=gtk_notebook_get_tab_label(nb,current);
+			if(org_deleterule((GtkLabel*)label)){
+				gtk_notebook_remove_page(nb,index);
+				if(index==1){//maybe was last
+					if(gtk_notebook_page_num(nb,gtk_notebook_get_nth_page(nb,-1))==0){
+						gtk_widget_set_sensitive(thisone,FALSE);
+					}
+				}
+			}
+		}
+	}
+}
+//rules added
+static BOOL org_restorerule(const char*name,GtkNotebook*nb,BOOL is_global){
+	//already at organizer folder here
+	FILE*f=fopen(name,"rb");
+	if(f!=nullptr){
+		BOOL ret=FALSE;
+		size_t sz=delim_init;
+		char*mem=(char*)malloc(delim_init);
+		if(mem!=nullptr){
+			while(getdelim(&mem,&sz,'\n',f)!=-1){
+				mem[strlen(mem)-1]='\0';//even at last, that is the way we added
+				organizer_tab_add(nb,mem,nullptr,is_global);
+				ret=TRUE;
+			}
+			free(mem);
+		}
+		fclose(f);
+		return ret;
+	}
+	return FALSE;
+}
+
+static BOOL org_query_append_str(char**mem,size_t*sz,char*fast_append,size_t*all_size,char separator){
+	char extra=separator!=0?1:0;
+	size_t appended=strlen(fast_append);
+	size_t new_size=*sz+appended+extra;
+	if(new_size>*all_size){
+		char*m=(char*)realloc(*mem,new_size);
+		if(m==nullptr)return FALSE;
+		*mem=m;
+		*all_size=new_size;
+	}
+	if(separator!=0){
+		(*mem)[*sz]=separator;
+	}
+	memcpy(*mem+*sz+extra,fast_append,appended);
+	*sz=new_size;
+	return TRUE;
+}
+#define org_query_send if(org_query_append_str(&command,&sz,(char*)irc_term,&all_size,0))send_data(command,sz);
+static void org_query(GtkNotebook*nb){
+	GtkWidget*current=gtk_notebook_get_nth_page(nb,gtk_notebook_get_current_page(nb));//scroll
+	GtkWidget*tv=gtk_bin_get_child((GtkBin*)current);
+	GtkTreeModel*tm=gtk_tree_view_get_model((GtkTreeView*)tv);
+
+	//get current order
+	//-1(GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID) is critical without a func and -2(GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID) will not sort like original, so ORG_INDEX is required
+	gint pos;GtkSortType type;
+	gboolean orig_sort=gtk_tree_sortable_get_sort_column_id((GtkTreeSortable*)tm, &pos, &type);
+
+	//sort by ORG_SERVER
+	gtk_tree_sortable_set_sort_column_id((GtkTreeSortable*)tm,ORG_SERVER,GTK_SORT_ASCENDING);
+
+	//sending whois server n1,..,nN
+	GtkTreeIter iter;
+	gboolean valid = gtk_tree_model_get_iter_first (tm, &iter);
+	if(valid){//don't send wrong command if no names received
+		size_t all_size=0;
+		char*command=nullptr;
+		char*current_server=nullptr;BOOL current_server_is_solid=FALSE;
+		size_t sz;
+		BOOL ok;
+		do{
+			gchar*server;gchar*nick;
+			gtk_tree_model_get (tm, &iter, ORG_ID1, &nick, ORG_SERVER, &server, -1);//are these allocs NULL if not ok? so a simple access violation on NULL will be next
+			if(current_server==nullptr||strcmp(current_server,server==nullptr?"":server)!=0){
+				if(command!=nullptr){
+					org_query_send
+					if(current_server_is_solid)g_free(current_server);
+				}
+				sz=0;
+				if(server==nullptr){
+					current_server=(char*)"";current_server_is_solid=FALSE;
+				}else{
+					current_server=server;current_server_is_solid=TRUE;
+				}
+				if(ok=org_query_append_str(&command,&sz,(char*)whois_str,&all_size,0)){
+					if(ok=org_query_append_str(&command,&sz,current_server,&all_size,' ')){
+						if nickname_start(nick) {
+							ok=org_query_append_str(&command,&sz,nick,&all_size,' ');
+						}else ok=org_query_append_str(&command,&sz,nick+1,&all_size,' ');
+					}
+				}
+				g_free(nick);
+			}else{
+				if nickname_start(nick) {
+					ok=org_query_append_str(&command,&sz,nick,&all_size,',');
+				}else ok=org_query_append_str(&command,&sz,nick+1,&all_size,',');
+				g_free(nick);
+				g_free(server);//can be NULL if not set
+			}
+			if(ok==FALSE)break;
+			valid = gtk_tree_model_iter_next(tm, &iter);
+		}while(valid);
+		if(current_server!=nullptr){
+			if(current_server_is_solid)g_free(current_server);
+			if(command!=nullptr){
+				org_query_send
+				free(command);
+			}
+		}
+	}
+
+	//sort back
+	if(orig_sort==FALSE){
+		gtk_tree_sortable_set_sort_column_id((GtkTreeSortable*)tm,ORG_INDEX,GTK_SORT_ASCENDING);
+	}else{
+		gtk_tree_sortable_set_sort_column_id((GtkTreeSortable*)tm,pos,type);
+	}
+}
+
+static void org_chat(struct stk_s*ps){
+	GtkWidget*current=gtk_notebook_get_nth_page(ps->organizer_notebook,gtk_notebook_get_current_page(ps->organizer_notebook));//scroll
+	GtkWidget*tv=gtk_bin_get_child((GtkBin*)current);
+	name_join_main((GtkTreeView*)tv,ps);//will add an if inside the function
+	gtk_window_present(ps->main_win);
+}
+
+static void org_move_files_locToGlob(const char*chan,char*nick){
+	GDir*entries=g_dir_open(".",0,nullptr);
+	if(entries!=nullptr){
+		for(;;){
+			const gchar*dir=g_dir_read_name(entries);
+			if(dir==nullptr)break;
+			if(strcmp(dir,chan)!=0){
+				if(chdir(dir)==0){
+					GDir*rules=g_dir_open(".",0,nullptr);
+					if(rules!=nullptr){
+						const gchar*rule;
+						for(;;){
+							rule=g_dir_read_name(rules);
+							if(rule==nullptr)break;
+							delete_line_fromfile_pref(nick,rule,FALSE);
+						}
+						g_dir_close(rules);
+					}
+					if(chdir(dirback)!=0)break;
+				}
+			}
+		}
+		g_dir_close(entries);
+	}//else return FALSE;
+}
+static BOOL org_move_files(struct stk_s*ps,GtkWidget*prev_tab,gint prev_index,GtkWidget*current_tab,gint current_index,char*nick,gboolean is_global_previous,gboolean is_global){
+	if(to_organizer_folder_server_go){//used at least for a simple name remove (local->new_entries) to double_name+conversations remove(global->local)
+		GtkNotebook*nb=ps->organizer_notebook;
+		if(is_global_previous&&(is_global==FALSE)){//global->0/local
+			if(chdir(org_u)==0){
+				if(chdir(nick)==0){//is prefixless at global
+					GDir*entries=g_dir_open(".",0,nullptr);
+					if(entries!=nullptr){
+						for(;;){
+							const gchar*file=g_dir_read_name(entries);
+							if(file==nullptr)break;
+							unlink(file);
+						}
+						g_dir_close(entries);
+					}//else return FALSE;
+					if(chdir(dirback)==0){
+						rmdir(nick);
+					}else return FALSE;
+				}//else return FALSE;
+				if(chdir(dirback)!=0)return FALSE;
+			}//else return FALSE;
+		}
+		//see at global first, because is nearer than local at folders
+		if(is_global_previous||is_global){
+			if(chdir(org_g)==0){
+				//delete
+				if(is_global_previous)if(delete_line_fromfile(nick,gtk_notebook_get_menu_label_text(nb,prev_tab))==FALSE)return FALSE;
+				//write
+				if(is_global)if(append_line_tofile(nickname_prefixless(nick),gtk_notebook_get_menu_label_text(nb,current_tab))==FALSE)return FALSE;
+				//back
+				if(chdir(dirback)!=0)return FALSE;
+			}//else return FALSE;
+		}
+		//and at local
+		if(is_global_previous==FALSE||is_global==FALSE){
+			if(chdir(org_c)==0){
+				const char*chan=org_getchan(ps);
+				if(chdir(chan)==0){
+					//delete
+					BOOL from_local=is_global_previous==FALSE&&prev_index!=0;
+					if(from_local)if(delete_line_fromfile(nick,gtk_notebook_get_menu_label_text(nb,prev_tab))==FALSE)return FALSE;
+					//write
+					if(is_global==FALSE&&current_index!=0)if(append_line_tofile(nick,gtk_notebook_get_menu_label_text(nb,current_tab))==FALSE)return FALSE;
+					//as a side effect, local->global, must be server unique, then search in other server channels for uniqueness
+					if(from_local&&is_global){
+						if(chdir(dirback)!=0)return FALSE;//back
+						org_move_files_locToGlob(chan,nickname_prefixless(nick));//)==FALSE)return FALSE;
+					}
+				}//else return FALSE;
+			}//else return FALSE;
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+#define org_move_scan "%u" not_a_nick_chan_host_start "%u"
+static void org_move(GtkButton*button,struct stk_s*ps){
+	GtkNotebook*nb=ps->organizer_notebook;
+	const gchar*user=gtk_button_get_label(button);
+	//the attributions are not required if user click wrong, but this case is rare
+	gint nb_page_index=gtk_notebook_get_current_page(nb);
+	GtkWidget*current=gtk_notebook_get_nth_page(nb,nb_page_index);//scroll
+	GtkWidget*tv=gtk_bin_get_child((GtkBin*)current);
+	GtkTreeModel*tm=gtk_tree_view_get_model((GtkTreeView*)tv);
+	GtkTreeIter iterator;
+	if(*user==*movestart){
+		GtkTreeSelection *sel=gtk_tree_view_get_selection((GtkTreeView*)tv);
+		gboolean selected=gtk_tree_selection_get_selected (sel,nullptr,&iterator);
+		if(selected){
+			gchar*item_text;
+			gint tree_index=get_pos_from_model(tm,&iterator);
+			char*space=(char*)malloc(digits_in_posInt+1+digits_in_posInt+1);
+			if(space!=nullptr){
+				sprintf(space,org_move_scan,nb_page_index,tree_index);
+				gtk_button_set_label(button,space);
+				free(space);
+			}
+		}
+	}else{
+		gint tab,pos;
+		sscanf(user,org_move_scan,&tab,&pos);
+		if(tab!=nb_page_index){//this is same place
+			GtkWidget*previous=gtk_notebook_get_nth_page(nb,tab);
+			if(previous!=nullptr){//can be deleted between the clicks
+				GtkWidget*tvprev=gtk_bin_get_child((GtkBin*)previous);
+				GtkTreeModel*tmprev=gtk_tree_view_get_model((GtkTreeView*)tvprev);
+				if(gtk_tree_model_iter_nth_child(tmprev,&iterator,nullptr,pos)){//can be deleted between the clicks
+					gchar*a;gchar*b;gchar*c;gint d;gchar*e;
+					gint f,g;//indexes are not ok with holes, at sorting
+					gboolean prev_glob=gtk_label_get_use_markup((GtkLabel*)gtk_notebook_get_tab_label(nb,previous));
+					if(prev_glob)
+						gtk_tree_model_get(tmprev,&iterator,ORG_ID1,&a,ORG_ID2,&b,ORG_GEN,&c,ORG_IDLE,&d,ORG_SERVER,&e,ORG_INDEX,&f,ORG_CONV,&g,-1);
+					else
+						gtk_tree_model_get(tmprev,&iterator,ORG_ID1,&a,ORG_ID2,&b,ORG_GEN,&c,ORG_IDLE,&d,ORG_SERVER,&e,ORG_INDEX,&f,-1);
+					gboolean current_glob=gtk_label_get_use_markup((GtkLabel*)gtk_notebook_get_tab_label(nb,current));
+					if(org_move_files(ps,previous,tab,current,nb_page_index,a,prev_glob,current_glob)){
+						gtk_list_store_remove((GtkListStore*)tmprev,&iterator);
+						if(tab!=0)org_move_indexed(tmprev,f);//index sort is not relevant there, comment at org_names_end
+						if(nb_page_index!=0){//can't move back, there is a comment about this at org_names_end
+							gboolean is_global=gtk_label_get_use_markup((GtkLabel*)gtk_notebook_get_tab_label(nb,current));//at global, no channel prefix for the user, attention if wanting to go back at local with no prefix
+							char*current_nick;
+							if(is_global)current_nick=nickname_prefixless(a);
+							else current_nick=a;
+
+							gint n=gtk_tree_model_iter_n_children(tm,nullptr);
+							gtk_list_store_append((GtkListStore*)tm,&iterator);
+							if(current_glob){
+								if(prev_glob)gtk_list_store_set((GtkListStore*)tm, &iterator, ORG_ID1,current_nick,ORG_ID2,b,ORG_GEN,c,ORG_IDLE,d,ORG_SERVER,e,ORG_INDEX,n,ORG_CONV,g,-1);
+								else gtk_list_store_set((GtkListStore*)tm, &iterator, ORG_ID1,current_nick,ORG_ID2,b,ORG_GEN,c,ORG_IDLE,d,ORG_SERVER,e,ORG_INDEX,n,ORG_CONV,0,-1);
+							}else{
+								gtk_list_store_set((GtkListStore*)tm, &iterator, ORG_ID1,current_nick,ORG_ID2,b,ORG_GEN,c,ORG_IDLE,d,ORG_SERVER,e,ORG_INDEX,n,-1);
+							}
+							//and select the moved item
+							GtkTreePath * path = gtk_tree_model_get_path ( tm , &iterator );
+							gtk_tree_view_set_cursor((GtkTreeView*)tv,path,nullptr,FALSE);
+							gtk_tree_path_free(path);
+						}
+					}
+					g_free(a);g_free(b);g_free(c);g_free(e);
+				}
+			}
+		}
+		gtk_button_set_label(button,movestart);
+	}
+}
+
+static void organizer_populate(GtkWidget*window,struct stk_s*ps){
+	GtkWidget*box=gtk_box_new(GTK_ORIENTATION_VERTICAL,0);
 	GtkWidget*top=gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);
 
-	GtkWidget*decider=gtk_button_new_with_label(bind);
-	g_signal_connect_data (decider, "clicked",G_CALLBACK(deciderfn),nullptr,nullptr,(GConnectFlags)0);
+	GtkWidget*decider=gtk_button_new_with_label("Update");
+	g_signal_connect_data (decider, "clicked",G_CALLBACK(deciderfn),ps,nullptr,G_CONNECT_SWAPPED);
 	gtk_box_pack_start((GtkBox*)top,decider,FALSE,FALSE,0);
 
-	GtkWidget*dirs=gtk_combo_box_text_new();
+	GtkNotebook*nb = (GtkNotebook*)gtk_notebook_new ();  ps->organizer_notebook=nb;//here, attention at org_changed
+
+	GtkWidget*dirs=gtk_combo_box_text_new();	ps->organizer_dirs=(GtkComboBox*)dirs;
 	gtk_box_pack_start((GtkBox*)top,dirs,TRUE,TRUE,0);
+
+	iterate_folders_enter(organizer_populate_dirs,dirs);//read from stored data
+
+	GtkWidget*buttonspack=gtk_box_new(GTK_ORIENTATION_VERTICAL,0);
+	GtkWidget*buttons=gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);
+
+	GtkWidget*remove_chan=gtk_button_new_with_label("X");	ps->organizer_removeentry=remove_chan;
+	g_signal_connect_data (remove_chan, "clicked",G_CALLBACK(org_removechan),ps,nullptr,G_CONNECT_SWAPPED);
+	gtk_box_pack_start((GtkBox*)buttons,remove_chan,FALSE,FALSE,0);
 	GtkWidget*add_folder=gtk_button_new_with_label("+");
-	gtk_widget_set_sensitive (add_folder,FALSE);
-	gtk_box_pack_start((GtkBox*)top,add_folder,FALSE,FALSE,0);
-	GtkWidget*remove_folder=gtk_button_new_with_label("-");
-	gtk_widget_set_sensitive (remove_folder,FALSE);
-	gtk_box_pack_start((GtkBox*)top,remove_folder,FALSE,FALSE,0);
-	GtkWidget*box=gtk_box_new(GTK_ORIENTATION_VERTICAL,0);
+	g_signal_connect_data (add_folder, "clicked",G_CALLBACK(org_addrule),ps,nullptr,G_CONNECT_SWAPPED);
+	gtk_box_pack_start((GtkBox*)buttons,add_folder,FALSE,FALSE,0);
+	GtkWidget*remove_folder=gtk_button_new_with_label("-");    ps->organizer_removerule=remove_folder;
+	g_signal_connect_data (remove_folder, "clicked",G_CALLBACK(org_removerule),ps,nullptr,(GConnectFlags)0);
+	gtk_box_pack_start((GtkBox*)buttons,remove_folder,FALSE,FALSE,0);
+	gtk_box_pack_start((GtkBox*)buttonspack,buttons,FALSE,FALSE,0);
+
+	GtkWidget*del_confirmation=gtk_check_button_new_with_mnemonic("_Delete confirmation");//Alt+D
+	gtk_toggle_button_set_active((GtkToggleButton*)del_confirmation,TRUE);
+	gtk_box_pack_start((GtkBox*)buttonspack,del_confirmation,FALSE,FALSE,0);
+	ps->organizer_del_confirmation=(GtkToggleButton*)del_confirmation;
+
+	gtk_box_pack_start((GtkBox*)top,buttonspack,FALSE,FALSE,0);
 	gtk_box_pack_start((GtkBox*)box,top,FALSE,FALSE,0);
+
+	gtk_notebook_popup_enable(nb);
+	ps->organizer_entry_names=organizer_tab_add(nb,(char*)org_new_names,&ps->organizer_entry_widget,FALSE);
+	//and add rest of the rules if are defined
+	BOOL stored_rules=org_restorerule(localrules,nb,FALSE);
+	if(org_restorerule(globalrules,nb,TRUE)==FALSE&&stored_rules==FALSE)gtk_widget_set_sensitive (remove_folder,FALSE);
+	//
 	gtk_box_pack_start((GtkBox*)box,(GtkWidget*)nb,TRUE,TRUE,0);
+
+	GtkWidget*bot=gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);     ps->organizer_bot=bot;//used if repopulation and set active, changed callback
+
+	g_signal_connect_data (dirs, "changed",G_CALLBACK(org_changed),ps,nullptr,(GConnectFlags)0);
+	if(gtk_tree_model_iter_n_children(gtk_combo_box_get_model((GtkComboBox*)dirs),nullptr)==0){
+		//is after repopulation
+		gtk_widget_set_sensitive (remove_chan,FALSE);
+		gtk_widget_set_sensitive(bot,FALSE);//is set inside changed callback
+	}
+	else{//set active and chdir inside here after rules restore
+		gtk_combo_box_set_active((GtkComboBox*)dirs,0);
+	}
+
+	GtkWidget*move=gtk_button_new_with_label(movestart);
+	g_signal_connect_data (move, "clicked",G_CALLBACK(org_move),ps,nullptr,(GConnectFlags)0);
+	gtk_box_pack_start((GtkBox*)bot,move,FALSE,FALSE,0);
+	GtkWidget*query=gtk_button_new_with_label("Query");
+	g_signal_connect_data (query, "clicked",G_CALLBACK(org_query),nb,nullptr,G_CONNECT_SWAPPED);
+	gtk_box_pack_start((GtkBox*)bot,query,FALSE,FALSE,0);
+	GtkWidget*chat=gtk_button_new_with_label("Chat");
+	g_signal_connect_data (chat, "clicked",G_CALLBACK(org_chat),ps,nullptr,G_CONNECT_SWAPPED);
+	gtk_box_pack_start((GtkBox*)bot,chat,FALSE,FALSE,0);
+	ps->organizer_entry_widget_timestamp=gtk_label_new(nullptr);
+	gtk_box_pack_start((GtkBox*)bot,ps->organizer_entry_widget_timestamp,FALSE,FALSE,0);
+	gtk_box_pack_start((GtkBox*)box,bot,FALSE,FALSE,0);
+
 	gtk_container_add ((GtkContainer*)window, box);
 }
 
-static void organizer_destroy_from_mainclose(struct stk_s*ps){
+static void mainclose_names(GtkNotebook*nb,GtkWidget*men){
+	GList*list=gtk_container_get_children((GtkContainer*)men);
+	if(list!=nullptr){
+		GList*lst=list;
+		for(;;){
+			GtkWidget*nb_page=get_pan_from_menu(list->data);
+			GtkWidget*txv=gtk_bin_get_child((GtkBin*)nb_page);
+
+			g_signal_emit_by_name(txv,destroy);//can call normally but there is a malloc data for each one that is passed as func data, must find a way that way?
+			//and disconnect, if that malloc data, can disconnect the function only next
+			g_signal_handlers_disconnect_matched(txv,G_SIGNAL_MATCH_ID,g_signal_lookup(destroy, gtk_text_view_get_type()),0,nullptr,nullptr,nullptr);
+
+			list=g_list_next(list);
+			if(list==nullptr)break;
+		}
+		g_list_free(lst);
+	}
+}
+static void everything_destroy_from_mainclose(struct stk_s*ps){
 	gtk_widget_destroy(menuwithtabs);
-	if(ps->organizer!=nullptr)gtk_window_close((GtkWindow*)ps->organizer);
+	if(ps->organizer!=nullptr){
+		//need to save conversations and remove those handlers
+		mainclose_names(ps->notebook,name_on_menu);
+		mainclose_names(ps->notebook,name_off_menu);
+		gtk_window_close((GtkWindow*)ps->organizer);
+	}
 }
 static void organizer_destroy_from_selfclose(struct stk_s*ps){
+	//here is also coming from main close
 	ps->organizer=nullptr;
 }
 static void organizer_popup(struct stk_s*ps){
 	if(ps->organizer==nullptr){
-		GtkWidget *dialog = gtk_application_window_new ((GtkApplication*)ps->app);
-		ps->organizer=dialog;
-		//GtkWidget *dialog = gtk_dialog_new_with_buttons ("Organizer",  nullptr, (GtkDialogFlags)0,  "_Done",GTK_RESPONSE_NONE,nullptr);//still is on top
+		if(to_organizer_folder_go){
+			GtkWidget *win = gtk_application_window_new ((GtkApplication*)ps->app);
+			ps->organizer=win;
+			//GtkWidget *dialog = gtk_dialog_new_with_buttons("Organizer",  nullptr, (GtkDialogFlags)0,  "_Done",GTK_RESPONSE_NONE,nullptr);//still is on top
 
-		gtk_window_set_title ((GtkWindow*)dialog, "Organizer");
-		g_signal_connect_data (dialog,"destroy",G_CALLBACK(organizer_destroy_from_selfclose),ps,nullptr,G_CONNECT_SWAPPED);
+			gtk_window_set_title((GtkWindow*)win, "Organizer");
+			g_signal_connect_data(win,"destroy",G_CALLBACK(organizer_destroy_from_selfclose),ps,nullptr,G_CONNECT_SWAPPED);
 
-		int w;int h;
-		gtk_window_get_size (ps->main_win,&w,&h);w*=0xf;
-		gtk_window_set_default_size((GtkWindow*)dialog,w/0x10,h);//h is not doing right for this width
+			int w;int h;
+			gtk_window_get_size(ps->main_win,&w,&h);w*=0xf;
+			gtk_window_set_default_size((GtkWindow*)win,w/0x10,h);//h is not doing right for this width
 
-		organizer_populate(dialog);
+			organizer_populate(win,ps);
 
-		gtk_widget_show_all (dialog);
-		//gtk_window_unmaximize((GtkWindow*)dialog);//at this dims will be automaximized, at dims/2 will not be automaximized  //is not working here
+			gtk_widget_show_all(win);
+			//gtk_window_unmaximize((GtkWindow*)win);//at this dims will be automaximized, at dims/2 will not be automaximized  //is not working here
+		}
 	}else gtk_window_present((GtkWindow*)ps->organizer);
 }
+
+static gboolean prog_key_press (struct stk_s*ps, GdkEventKey  *event){
+	if(event->type==GDK_KEY_PRESS){
+		if((event->state&GDK_CONTROL_MASK)!=0){
+			unsigned int K=gdk_keyval_to_upper(event->keyval);
+			if((event->state&GDK_SHIFT_MASK)==0){
+				if(K==GDK_KEY_T){
+					GList*lst=gtk_container_get_children((GtkContainer*)menuwithtabs);
+					GList*list=lst;
+					for(;;){
+						list=g_list_next(list);
+						if(list==nullptr)break;
+						gtk_widget_destroy((GtkWidget*)list->data);
+					}
+					g_list_free(lst);
+					reload_tabs(chan_menu,menuwithtabs,ps->notebook);//sorted from here
+					reload_tabs(name_on_menu,menuwithtabs,ps->notebook);
+					reload_tabs(name_off_menu,menuwithtabs,ps->notebook);
+					gtk_menu_popup_at_widget((GtkMenu*)menuwithtabs,(GtkWidget*)ps->notebook,GDK_GRAVITY_NORTH_WEST,GDK_GRAVITY_NORTH_WEST,nullptr);
+				}else if(K==GDK_KEY_Q)action_to_close();
+				else if(K==GDK_KEY_O)organizer_popup(ps);
+			}else{
+				if(K==GDK_KEY_C){
+					GtkWidget*pg=gtk_notebook_get_nth_page(ps->notebook,gtk_notebook_get_current_page(ps->notebook));
+					if(is_home(gtk_notebook_get_menu_label_text(ps->notebook,pg))==FALSE)gtk_button_clicked((GtkButton*)tab_close_button(ps->notebook,pg));
+				}else if(K==GDK_KEY_X)g_application_quit(ps->app);
+			}
+		}else if(event->keyval==GDK_KEY_Up&&gtk_widget_is_focus(ps->sen_entry)){
+			if(send_entry_list_cursor!=send_entry_list->head){
+				send_entry_list_cursor=send_entry_list_cursor==nullptr?
+					send_entry_list->tail
+					:send_entry_list_cursor->prev;
+				gtk_entry_set_text((GtkEntry*)ps->sen_entry,(const char*)send_entry_list_cursor->data);
+			}
+			return TRUE;//lost focus other way
+		}else if(event->keyval==GDK_KEY_Down&&gtk_widget_is_focus(ps->sen_entry)){
+			if(send_entry_list_cursor!=nullptr){
+				send_entry_list_cursor=send_entry_list_cursor->next;
+				GtkEntryBuffer*buf=gtk_entry_get_buffer((GtkEntry*)ps->sen_entry);
+				gtk_entry_buffer_delete_text(buf,0,-1);
+				if(send_entry_list_cursor!=nullptr)gtk_entry_buffer_insert_text(buf,0,(const char*)send_entry_list_cursor->data,-1);
+			}
+			return TRUE;//is trying to switch focus
+		}
+	}
+	return FALSE;//propagation seems fine, for "other handlers"
+}
+
 static void
 activate (GtkApplication* app,
           struct stk_s*ps)
@@ -2279,9 +3868,9 @@ activate (GtkApplication* app,
 	GtkWidget *window = gtk_application_window_new (app);
 	menuwithtabs=gtk_menu_new();
 	//
-	g_signal_connect_data (window,"destroy",G_CALLBACK(organizer_destroy_from_mainclose),ps,nullptr,G_CONNECT_SWAPPED);
+	g_signal_connect_data (window,"destroy",G_CALLBACK(everything_destroy_from_mainclose),ps,nullptr,G_CONNECT_SWAPPED);
 	ps->organizer=nullptr;
-	//moved to organizer_destroy_from_mainclose: g_signal_connect_data (window,"destroy",G_CALLBACK(gtk_widget_destroy),menuwithtabs,nullptr,G_CONNECT_SWAPPED);
+	//moved to everything_destroy_from_mainclose: g_signal_connect_data (window,"destroy",G_CALLBACK(gtk_widget_destroy),menuwithtabs,nullptr,G_CONNECT_SWAPPED);
 	//
 	gtk_window_set_title ((GtkWindow*) window, "IRC");
 	if(ps->dim[0]!=-1)
@@ -2403,10 +3992,6 @@ activate (GtkApplication* app,
 	gtk_box_pack_start((GtkBox*)box,(GtkWidget*)ps->notebook,TRUE,TRUE,0);
 	gtk_box_pack_start((GtkBox*)box,ps->sen_entry,FALSE,FALSE,0);
 	gtk_container_add ((GtkContainer*)window, box);
-	//
-	if(ps->maximize)gtk_window_maximize((GtkWindow*)window);
-	if(ps->minimize)gtk_window_iconify((GtkWindow*)window);
-	//
 	gtk_widget_show_all (window);
 	ps->main_win=(GtkWindow*)window;
 	//
@@ -2415,6 +4000,9 @@ activate (GtkApplication* app,
 	g_signal_connect_data (ps->notebook, "switch-page",G_CALLBACK (nb_switch_page),ps->sen_entry,nullptr,(GConnectFlags)0);//this,before show,was critical;
 	info_path_name_restore((GtkComboBoxText*)en,entext,ps);
 	g_signal_connect_data (window, "key-press-event",G_CALLBACK (prog_key_press),ps,nullptr,G_CONNECT_SWAPPED);
+	//
+	if(ps->maximize)gtk_window_maximize((GtkWindow*)window);//problem? maybe is since dual monitor and only after reboot. gtk_test_widget_wait_for_draw(window) ?
+	if(ps->minimize)gtk_window_iconify((GtkWindow*)window);
 }
 static void parse_autojoin(struct stk_s*ps){
 	gather_parse(&ps->ajoins_sum,ps->ajoins_mem,&ps->ajoins);
@@ -2436,25 +4024,27 @@ static gboolean autoconnect_callback(con
 	return TRUE;
 }
 static void remove_config(){
+	puts("Would remove:");
 	if(info_path_name!=nullptr){
 		if(access(info_path_name,F_OK)==0){
-			puts("Would remove:");
 			puts(info_path_name);
-			puts("yes ?");
-			int e=getchar();
-			if(e=='y'){
-				e=getchar();
-				if(e=='e'){
-					e=getchar();
-					if(e=='s'){
-						if(unlink(info_path_name)==0)printf("%s removed\n",info_path_name);
-						return;
-					}
-				}
+		}
+	}
+	to_organizer_folder(TRUE,FALSE);
+	puts("yes ?");
+	int e=getchar();
+	if(e=='y'){
+		e=getchar();
+		if(e=='e'){
+			e=getchar();
+			if(e=='s'){
+				if(unlink(info_path_name)==0)printf("%s" removed_string new_line,info_path_name);
+				to_organizer_folder(TRUE,TRUE);
+				return;
 			}
-			puts("expecting \"yes\"");
 		}
 	}
+	puts("expecting \"yes\"");
 }
 
 //struct stack_dict { GHashTable *values;  gsize magic;};
@@ -2485,7 +4075,7 @@ static gint handle_local_options (struct
 	//4 refresh_id
 	//if (g_variant_dict_lookup (options,ps->args[refresh_id], "i", &ps->refresh)==FALSE)//but at 0 is not ok
 	//same for gpointer p;g_hash_table_lookup_extended(GVSD(options)->values,ps->args[refresh_id],nullptr,&p);//pointer(not getting the value)/0
-	char*temp;
+	gchar*temp;
 	if (g_variant_dict_lookup (options,ps->args[refresh_id], "s", &temp)){
 		if(sscanf(temp,"%u",&ps->refresh)!=1){//EOF is not, "" is error catched before entering the dict
 			puts("Refresh interval argument error");
@@ -2572,9 +4162,6 @@ int main (int    argc,
 		app = gtk_application_new (nullptr, G_APPLICATION_FLAGS_NONE);
 
 		//if(app!=nullptr){
-		//QWERTYUIOP
-		//ASDFgHJkL
-		// ZXCVbNM
 		ps.args[autoconnect_id]="autoconnect";ps.args_short[autoconnect_id]='a';
 		const GOptionEntry autoc[]={{ps.args[autoconnect_id],ps.args_short[autoconnect_id],G_OPTION_FLAG_IN_MAIN|G_OPTION_FLAG_OPTIONAL_ARG,G_OPTION_ARG_CALLBACK,(gpointer)autoconnect_callback,"[=INDEX] optional value: autoconnect to that index. Else, autoconnect to an autojoin connection (the reminder of unix days % autojoin total).","INDEX"}
 			,{nullptr,'\0',0,(GOptionArg)0,nullptr,nullptr,nullptr}};
@@ -2604,7 +4191,7 @@ int main (int    argc,
 		ps.args[password_id]="password";ps.args_short[password_id]='p';
 		g_application_add_main_option((GApplication*)app,ps.args[password_id],ps.args_short[password_id],G_OPTION_FLAG_IN_MAIN,G_OPTION_ARG_STRING,"Default password (blank overwrite with \"" parse_host_left "host...\", the format is at the g.u.i. help)","PASSWORD");
 		ps.args[refresh_id]="refresh";ps.args_short[refresh_id]='f';//when ARG_INT and comming 0 it will not go further into the dict to know, ARG_STRING can do it
-		g_application_add_main_option((GApplication*)app,ps.args[refresh_id],ps.args_short[refresh_id],G_OPTION_FLAG_IN_MAIN,G_OPTION_ARG_STRING,"Refresh channels interval in seconds. Default " INT_CONV_STR(default_refresh) ". Less than 1 to disable.","SECONDS");
+		g_application_add_main_option((GApplication*)app,ps.args[refresh_id],ps.args_short[refresh_id],G_OPTION_FLAG_IN_MAIN,G_OPTION_ARG_STRING,"Refresh channels interval in seconds. Default " INT_CONV_STR(default_refresh) ". Less than 1 to disable.","SECONDS");//-f -1 is valid less than 1
 		ps.args[right_id]="right";ps.args_short[right_id]='r';
 		g_application_add_main_option((GApplication*)app,ps.args[right_id],ps.args_short[right_id],G_OPTION_FLAG_IN_MAIN,G_OPTION_ARG_INT,"Right pane size, default " INT_CONV_STR(default_right),"WIDTH");
 		ps.args[run_id]="run";ps.args_short[run_id]='x';
@@ -2654,7 +4241,7 @@ int main (int    argc,
 	return EXIT_SUCCESS;
 }
 
-/* example entries for .sircinfo
+/*example entries for .sircinfo
 irc.libera.chat:6697
 chat.freenode.net:6697,7000,7070
 @bucharest.ro.eu.undernet.org:6660-6669
@@ -2665,3 +4252,4 @@ zonder:@irc.us.ircnet.net
 @127.0.0.1:6666-6667
 @127.0.0.1:6697;6667-6669
 */
+//example of rules for organizer:: local rules: staff/try . global rules: talks/far/have/no/male/not
--- /dev/null
+++ sirc-1/md
@@ -0,0 +1,2 @@
+
+autoreconf -i && ./configure CFLAGS=-g --disable-cpp && ./headless
--- sirc-1.orig/test
+++ sirc-1/test
@@ -1,5 +1,14 @@
 
-if [ -n "${1}" ]; then
+a=0
+if [ -n "${d}" ]; then #debug
 dbg="gdb --args "
 fi
-${dbg} ./sirc -z -t -f 0
+if [ -n "${s}" ]; then #another dummy user
+	if [ ${s} = 1 ]; then
+		extra="-y -n john"
+	else
+		extra="-y -n don"
+		a=1
+	fi
+fi
+${dbg} ./sirc -z -t -f 0 -a ${a} -j ${a},#w,#q ${extra} $@
