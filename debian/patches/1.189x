Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ovideo (1-189x) xenial; urgency=medium
 .
   * whiletrue
Author: bc <bc@bc-Type1ProductConfigId>

---
The information above should follow the Patch Tagging Guidelines, please
checkout https://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: (upstream|backport|vendor|other), (<patch-url>|commit:<commit-id>)
Bug: <upstream-bugtracker-url>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: (no|not-needed|<patch-forwarded-url>)
Applied-Upstream: <version>, (<commit-url>|commit:<commid-id>)
Reviewed-By: <name and email of someone who approved/reviewed the patch>
Last-Update: 2024-05-06

--- ovideo-1.orig/_fix/u
+++ ovideo-1/_fix/u
@@ -1,6 +1,6 @@
 
 for var in "$@"
 do
-	find -name "*.s" | xargs sed -i "0,/import \"${var}\"/s/import \"${var}\"/importx \"_${var}\"/w /dev/stdout"
+	find -name "*.oc" | xargs sed -i "0,/import \"${var}\"/s/import \"${var}\"/importx \"_${var}\"/w /dev/stdout"
 done
 
--- ovideo-1.orig/lin_make_objects
+++ ovideo-1/lin_make_objects
@@ -2,96 +2,96 @@
 #use Makefile
 exit
 
-o "_dif/dif~lin.s"
-o "_exec/ostream.s"
-o "_exec/start.s"
-o "_exec/mainhandles.s"
-o "_exec/uri.s"
-o "_exec/uristream.s"
-o "_exec/capture/save.s"
-o "_exec/mediainfo.s"
-o "_prepare/view.s"
-o "_prepare/pipe.s"
-o "_prepare/sel.s"
-o "_prepare/prevw.s"
-o "_prepare/paint.s"
-o "_prepare/stagempeg.s"
-o "_prepare/output/all.s"
-o "_prepare/output/stagefileoptions.s"
-o "_prepare/output/sound.s"
-o "_prepare/output/avi.s"
-o "_prepare/output/mkv.s"
-o "_prepare/frame/frame.s"
-o "_prepare/frame/add.s"
-o "_prepare/frame/remove.s"
-o "_prepare/frame/frametime.s"
-o "_prepare/frame/imagetools.s"
-o "_prepare/frame/scale.s"
-o "_prepare/frame/crop.s"
-o "_prepare/frame/pencil.s"
-o "_prepare/frame/screenshot.s"
-o "_prepare/frame/brightness.s"
-o "_prepare/frame/overlay.s"
-o "_prepare/frame/rotate.s"
-o "_prepare/effect/base.s"
-o "_prepare/effect/fade.s"
-o "_prepare/effect/move.s"
-o "_prepare/effect/scale_effect.s"
-o "_prepare/effect/reveal.s"
-o "_prepare/effect/reveal_shape.s"
-o "_prepare/effect/reveal_diagonal.s"
-o "_search/dialog.s"
-o "_search/dialog_fns.s"
-o "_search/parse.s"
-o "_search/previews.s"
-o "_exec/mix.s"
-o "_exec/help.s"
-o "_capture/capture.s"
-o "util/util.s"
-o "util/update.s"
-o "util/numbers.s"
-o "util/floating.s"
-o "util/lists.s"
-o "util/asm.s"
-o "media/audiovideo.s"
-o "media/jpeg.s"
-o "media/jpeg_enc.s"
-o "media/mpeg.s"
-o "media/mpeg_init.s"
-o "media/mpeg_enc.s"
-o "media/mpeg_pred.s"
-o "media/mpeg_code.s"
-o "media/mpeg_interframe.s"
-o "media/mp4.s"
-o "media/mp4_data.s"
-o "media/mpeg-avc_data.s"
-o "media/mpeg-avc_wrap.s"
-o "media/mpeg-avc_bs.s"
-o "media/mpeg-avc_encode.s"
-o "media/mpeg-avc_mb.s"
-o "media/mpeg-avc_block.s"
-o "media/mpeg-avc_action.s"
-o "media/mpeg-mp3_data.s"
-o "media/mpeg-mp3_tables.s"
-o "media/mpeg-mp3_wrap.s"
-o "media/mpeg-mp3_bs.s"
-o "media/mpeg-mp3_huffman.s"
-o "media/mpeg-mp3_input.s"
-o "media/mpeg-mp3_mdct.s"
-o "media/mpeg-mp3_encode.s"
-o "media/mpeg-mp3_iteration.s"
-o "media/mpeg-mp3_iteration_code.s"
-o "obj/containers.s"
-o "obj/items.s"
-o "obj/tool.s"
-o "obj/images.s"
-o "str/str.s"
-o "mem/alloc.s"
-o "mem/op.s"
-o "net/net-base.s"
-o "err/err.s"
-o "event/event.s"
-o "file-folder/file-base.s"
-o "file-folder/folder-base.s"
-o "interface/buttons.s"
-o "gnu/gst.s"
+o "_dif/dif~lin.oc"
+o "_exec/ostream.oc"
+o "_exec/start.oc"
+o "_exec/mainhandles.oc"
+o "_exec/uri.oc"
+o "_exec/uristream.oc"
+o "_exec/capture/save.oc"
+o "_exec/mediainfo.oc"
+o "_prepare/view.oc"
+o "_prepare/pipe.oc"
+o "_prepare/sel.oc"
+o "_prepare/prevw.oc"
+o "_prepare/paint.oc"
+o "_prepare/stagempeg.oc"
+o "_prepare/output/all.oc"
+o "_prepare/output/stagefileoptions.oc"
+o "_prepare/output/sound.oc"
+o "_prepare/output/avi.oc"
+o "_prepare/output/mkv.oc"
+o "_prepare/frame/frame.oc"
+o "_prepare/frame/add.oc"
+o "_prepare/frame/remove.oc"
+o "_prepare/frame/frametime.oc"
+o "_prepare/frame/imagetools.oc"
+o "_prepare/frame/scale.oc"
+o "_prepare/frame/crop.oc"
+o "_prepare/frame/pencil.oc"
+o "_prepare/frame/screenshot.oc"
+o "_prepare/frame/brightness.oc"
+o "_prepare/frame/overlay.oc"
+o "_prepare/frame/rotate.oc"
+o "_prepare/effect/base.oc"
+o "_prepare/effect/fade.oc"
+o "_prepare/effect/move.oc"
+o "_prepare/effect/scale_effect.oc"
+o "_prepare/effect/reveal.oc"
+o "_prepare/effect/reveal_shape.oc"
+o "_prepare/effect/reveal_diagonal.oc"
+o "_search/dialog.oc"
+o "_search/dialog_fns.oc"
+o "_search/parse.oc"
+o "_search/previews.oc"
+o "_exec/mix.oc"
+o "_exec/help.oc"
+o "_capture/capture.oc"
+o "util/util.oc"
+o "util/update.oc"
+o "util/numbers.oc"
+o "util/floating.oc"
+o "util/lists.oc"
+o "util/asm.oc"
+o "media/audiovideo.oc"
+o "media/jpeg.oc"
+o "media/jpeg_enc.oc"
+o "media/mpeg.oc"
+o "media/mpeg_init.oc"
+o "media/mpeg_enc.oc"
+o "media/mpeg_pred.oc"
+o "media/mpeg_code.oc"
+o "media/mpeg_interframe.oc"
+o "media/mp4.oc"
+o "media/mp4_data.oc"
+o "media/mpeg-avc_data.oc"
+o "media/mpeg-avc_wrap.oc"
+o "media/mpeg-avc_bs.oc"
+o "media/mpeg-avc_encode.oc"
+o "media/mpeg-avc_mb.oc"
+o "media/mpeg-avc_block.oc"
+o "media/mpeg-avc_action.oc"
+o "media/mpeg-mp3_data.oc"
+o "media/mpeg-mp3_tables.oc"
+o "media/mpeg-mp3_wrap.oc"
+o "media/mpeg-mp3_bs.oc"
+o "media/mpeg-mp3_huffman.oc"
+o "media/mpeg-mp3_input.oc"
+o "media/mpeg-mp3_mdct.oc"
+o "media/mpeg-mp3_encode.oc"
+o "media/mpeg-mp3_iteration.oc"
+o "media/mpeg-mp3_iteration_code.oc"
+o "obj/containers.oc"
+o "obj/items.oc"
+o "obj/tool.oc"
+o "obj/images.oc"
+o "str/str.oc"
+o "mem/alloc.oc"
+o "mem/op.oc"
+o "net/net-base.oc"
+o "err/err.oc"
+o "event/event.oc"
+o "file-folder/file-base.oc"
+o "file-folder/folder-base.oc"
+o "interface/buttons.oc"
+o "gnu/gst.oc"
--- ovideo-1.orig/soundrecorder/build.bat
+++ ovideo-1/soundrecorder/build.bat
@@ -1,3 +1,2 @@
-o.exe "src/record.s"
+o.exe "src/record.oc"
 ld -mi386pe -e record -s -o ./soundrec.exe ./src/record.o -lmsvcrt -lkernel32 -lwinmm -luser32
-
--- ovideo-1.orig/soundrecorder/src/Makefile
+++ ovideo-1/soundrecorder/src/Makefile
@@ -4,14 +4,15 @@ OCOMP=o
 endif
 
 ifndef linkerflags
-linkerflags=-O1 -s
+linkerflags=-O3 -s
+#             1
 endif
 
 OFLAGS = inplace_reloc 0
 
 projname=soundrecorder
 objname=${projname}.o
-srcname=${projname}.s
+srcname=${projname}.oc
 logname=${srcname}.log
 wprojname=${projname}.exe
 
@@ -26,7 +27,7 @@ link:
 	i686-w64-mingw32-ld ${linkerflags} ${objname} -o ${wprojname} -entry record \
 		 -lmsvcrt -lkernel32 -lwinmm -luser32
 
-%: %.s
+%: %.oc
 	${OCOMP} $< ${OFLAGS}
 
 clean:
--- /dev/null
+++ ovideo-1/soundrecorder/src/soundrecorder.oc
@@ -0,0 +1,591 @@
+
+
+format elfobj
+
+include "ascii.h"
+include "common.h"
+
+include "util.oc"
+include "values.oc"
+
+const WAVE_FORMAT_PCM=1
+
+#this program record sound from the default recording device and writes to the wav format
+
+#the mechanism is simple:
+#main thread:
+#flag stop
+#create event
+    #create thread
+        #openwav
+            #buffer,prepare,add
+                #buffer,prepare,add
+                    #start
+                        #flag ok,set event
+                        #getch
+                        #reset event,flag stop,wait event
+
+#second thread:
+    #wait event,verify flag ok
+        #get buffers and write
+        #verify flag stop
+            #1. continue
+            #2. finish all bufers and set event and return
+
+import "_CloseHandle@4" CloseHandle
+import "_fopen" fopen
+import "_fclose" fclose
+
+#bool
+function record_options(sd file)
+    import "_fseek" fseek
+    import "_ftell" ftell
+    str lengtherr="Options file length error"
+    sd len
+    sd fileresult
+
+    setcall fileresult fseek(file,0,(SEEK_END))
+    if fileresult!=0
+        call errors(lengtherr)
+        return 0
+    endif
+    setcall len ftell(file)
+    if len<=0
+        call errors(lengtherr)
+        return 0
+    endif
+    setcall fileresult fseek(file,0,(SEEK_SET))
+    if fileresult!=0
+        call errors(lengtherr)
+        return 0
+    endif
+
+    const max_options_length=100
+
+    char text#max_options_length
+    ss options_text^text
+
+    if len>=(max_options_length)
+        call errors(lengtherr)
+        return 0
+    endif
+
+    import "_fread" fread
+    sd readed
+    setcall readed fread(options_text,1,len,file)
+    if readed!=len
+        str readerr="Read error"
+        call errors(readerr)
+        return 0
+    endif
+    char spc=" "
+
+    ss safe
+    set safe options_text
+    add safe readed
+    set safe# spc
+    inc len
+
+    sd count=0
+    ss cursor
+    set cursor options_text
+    while len!=0
+        if cursor#=spc
+            import "_atoi" atoi
+            set cursor# 0
+            sd value
+            setcall value atoi(options_text)
+            if value<1
+                str lowval="Wrong option"
+                call errors(lowval)
+                return 0
+            endif
+            if count=0
+                call channels_value((value_set),value)
+            elseif count=1
+                call rate_value((value_set),value)
+            else
+                if value<8
+                    str lowbps="Wrong bps"
+                    call errors(lowbps)
+                    return 0
+                endif
+                call bps_value((value_set),value)
+            endelse
+            set options_text cursor
+            inc options_text
+            inc count
+        endif
+        inc cursor
+        dec len
+    endwhile
+    set cursor# 0
+
+    if count!=3
+        str index_expected="More options expected"
+        call errors(index_expected)
+        return 0
+    endif
+
+    return 1
+endfunction
+
+function record_sound()
+    call record_flag((value_set),(flag_stop))
+
+    import "_CreateEventA@16" CreateEvent
+    #HANDLE WINAPI CreateEvent(
+    #  __in_opt  LPSECURITY_ATTRIBUTES lpEventAttributes,
+    #  __in      BOOL bManualReset,
+    #  __in      BOOL bInitialState,
+    #  __in_opt  LPCTSTR lpName);
+
+    sd event
+    setcall event CreateEvent(0,0,0,0)
+
+    call record_event((value_set),event)
+
+    call record_createthread()
+
+    #in case we got errors, to stop the second thread
+    #knowing that Resetting an event that is already reset has no effect
+    import "_ResetEvent@4" ResetEvent
+    call ResetEvent(event)
+
+    call CloseHandle(event)
+
+    import "_exit" exit
+    call exit(1)
+endfunction
+
+function record_createthread()
+    import "_CreateThread@24" CreateThread
+
+    data f^record_second_thread
+
+    sd thread_id
+    sd p_thread_id^thread_id
+
+    sd thread
+    setcall thread CreateThread(0,0,f,0,0,p_thread_id)
+    if thread=0
+        return 0
+    endif
+
+    call record_fileandsizes(thread_id)
+
+    call CloseHandle(thread)
+endfunction
+
+####################
+
+function record_fileandsizes(sd thread_id)
+    import "_time" time
+    sd tm
+    setcall tm time()
+    import "_sprintf" sprintf
+    char filename_data#100
+    str filename^filename_data
+    str format="%u.wav"
+    call sprintf(filename,format,tm)
+
+    str wr="wb"
+    sd file
+    setcall file fopen(filename,wr)
+    if file=0
+        str err="Cannot open the output file."
+        call errors(err)
+        return 0
+    endif
+
+    call record_got_file(file,thread_id)
+
+    call fclose(file)
+endfunction
+
+function record_got_file(sd file,sd thread_id)
+#const _RIFF^riff
+const _RIFF=\
+    char riff={R,I,F,F}
+    data riffsize#1
+
+    char WAVE={W,A,V,E}
+    char *fmt={f,m,t,Space}
+    data fmtsize#1
+    #WAVEFORMATEX
+    char wFormatTag={WAVE_FORMAT_PCM,0}
+    char nChannels={1,0}
+    data nSamplesPerSec#1
+    data nAvgBytesPerSec#1
+    char nBlockAlign={2,0}
+    char wBitsPerSample={16,0}
+    #EX
+    #no extra data, simple PCM-format used
+    char *cbSize={0,0}
+
+    char datatag={d,a,t,a}
+    data datasize#1
+
+#const RIFF_^RIFF
+const RIFF_=\
+
+    data RIFF^riff
+    const RIFF_size=RIFF_-_RIFF
+
+    const _WAVEFORMATEX^wFormatTag
+    const WAVEFORMATEX_^datatag
+    set fmtsize (WAVEFORMATEX_-_WAVEFORMATEX)
+
+    setcall nChannels channels_value((value_get))
+    setcall nSamplesPerSec rate_value((value_get))
+    setcall wBitsPerSample bps_value((value_get))
+    setcall nBlockAlign blockalign_value()
+    setcall nAvgBytesPerSec avgbytespersec_value()
+
+    sd bool
+    setcall bool file_write(RIFF,(RIFF_size),file)
+    if bool=0
+        return 0
+    endif
+
+    #store file for buffer write
+    call record_file((value_set),file)
+
+    sd hwi
+    sd p_hwi^hwi
+    str WAVEFORMATEX^wFormatTag
+
+    import "_waveInOpen@24" waveInOpen
+    sd wavecall
+    setcall wavecall waveInOpen(p_hwi,0,WAVEFORMATEX,thread_id,0,(CALLBACK_THREAD))
+    if wavecall!=(MMSYSERR_NOERROR)
+        return 0
+    endif
+
+    call record_hwavein((value_set),hwi)
+
+    call record_got_wavein()
+
+    import "_waveInClose@4" waveInClose
+    call waveInClose(hwi)
+
+    #write riffsize and datasize
+    sd position
+    setcall position ftell(file)
+    if position=(INVALID_HANDLE)
+        str ertell="Get file position error"
+        call errors(ertell)
+        return 0
+    endif
+
+    set datasize position
+    sub datasize (RIFF_size)
+
+    sd even
+    set even position
+    and even 1
+    if even=1
+        str pad=""
+        setcall bool file_write(pad,1,file)
+        if bool!=1
+            return 0
+        endif
+        inc position
+    endif
+
+    set riffsize position
+    sub riffsize (4+4)
+
+    str endseekerr="File seek error"
+
+    sd seekint
+    SetCall seekint fseek(file,4,(SEEK_SET))
+    If seekint!=0
+        call errors(endseekerr)
+        return 0
+    endif
+
+    sd p_rifsz^riffsize
+    setcall bool file_write(p_rifsz,4,file)
+    if bool!=1
+        return 0
+    endif
+
+    const _RIFF_block_start^WAVE
+    const datasize_off^datasize
+
+    SetCall seekint fseek(file,(datasize_off-_RIFF_block_start),(SEEK_CUR))
+    If seekint!=0
+        call errors(endseekerr)
+        return 0
+    endif
+
+    sd p_datasize^datasize
+    call file_write(p_datasize,4,file)
+endfunction
+
+#get two buffers, when one is full, write it to file, in the same time, the other one can record
+
+function record_got_wavein()
+    sd len
+    setcall len BufferLength_value()
+    sd buffer
+    setcall buffer alloc(len)
+    if buffer=0
+        return 0
+    endif
+    import "_free" free
+
+    call record_prepare_buffer(buffer)
+
+    call free(buffer)
+endfunction
+
+function record_prepare_buffer(sd buffer)
+    data lpData#1
+    data dwBufferLength#1
+    data *dwBytesRecorded#1
+    data *dwUser#1
+    data *dwFlags=0
+    data *dwLoops#1
+    data *lpNext#1
+    data *reserved#1
+
+    sd wavehd^lpData
+
+#lpData, dwBufferLength, and dwFlags members must be set
+    set lpData buffer
+
+    setcall dwBufferLength BufferLength_value()
+
+    sd wavein
+    setcall wavein record_hwavein((value_get))
+
+    sd bool
+    setcall bool wavein_prepare(wavein,wavehd)
+    if bool!=1
+        return 0
+    endif
+
+    call record_prepare_add(wavein,wavehd)
+
+    import "_waveOutUnprepareHeader@12" waveInUnprepareHeader
+    call waveInUnprepareHeader(wavein,wavehd,(WAVEHDR_size))
+endfunction
+
+function record_prepare_add(sd wavein,sd wavehdr)
+    sd bool
+    setcall bool wavein_add(wavein,wavehdr)
+    if bool!=1
+        return 0
+    endif
+    call record_buffer_next()
+endfunction
+
+function record_buffer_next()
+    sd len
+    setcall len BufferLength_value()
+    sd buffer_2
+    setcall buffer_2 alloc(len)
+    if buffer_2=0
+        return 0
+    endif
+    call record_prepare_buffer_2(buffer_2)
+    call free(buffer_2)
+endfunction
+
+
+function record_prepare_buffer_2(sd buffer)
+    data lpData#1
+    data dwBufferLength#1
+    data *dwBytesRecorded#1
+    data *dwUser#1
+    data *dwFlags=0
+    data *dwLoops#1
+    data *lpNext#1
+    data *reserved#1
+
+    sd wavehd^lpData
+
+#lpData, dwBufferLength, and dwFlags members must be set
+    set lpData buffer
+
+    setcall dwBufferLength BufferLength_value()
+
+    sd wavein
+    setcall wavein record_hwavein((value_get))
+
+    sd bool
+    setcall bool wavein_prepare(wavein,wavehd)
+    if bool!=1
+        return 0
+    endif
+
+    call record_start(wavein,wavehd)
+
+    call waveInUnprepareHeader(wavein,wavehd,(WAVEHDR_size))
+endfunction
+
+function record_start(sd wavein,sd wavehdr)
+    sd bool
+    setcall bool wavein_add(wavein,wavehdr)
+    if bool!=1
+        return 0
+    endif
+
+    import "_waveInStart@4" waveInStart
+    sd mm
+    setcall mm waveInStart(wavein)
+    if mm!=(MMSYSERR_NOERROR)
+        return 0
+    endif
+
+    call record_dialog()
+
+    import "_waveInStop@4" waveInStop
+    call waveInStop(wavein)
+#create an event
+endfunction
+
+function record_dialog()
+    call record_buffers((value_set),2)
+
+    call record_flag((value_set),(flag_recording))
+
+    sd event
+    setcall event record_event((value_get))
+
+    import "_SetEvent@4" SetEvent
+    call SetEvent(event)
+
+    str info="Recording. Press any key to stop.."
+    call printf(info)
+
+    import "__getch" getch
+    call getch()
+
+    char nl={0xa,0}
+    str newline^nl
+
+    call printf(newline)
+
+    str done="Done"
+    call printf(done)
+
+    call printf(newline)
+
+    call ResetEvent(event)
+    call record_flag((value_set),(flag_stop))
+    import "_WaitForSingleObject@8" WaitForSingleObject
+    call WaitForSingleObject(event,(INFINITE))
+endfunction
+
+################
+
+
+
+
+
+
+
+function record_second_thread(sd *data)
+    sd event
+    setcall event record_event((value_get))
+
+    call WaitForSingleObject(event,(INFINITE))
+
+    sd flag
+    setcall flag record_flag((value_get))
+
+    if flag=(flag_stop)
+        return 0
+    endif
+
+    call record_loop_messages()
+
+    call SetEvent(event)
+endfunction
+
+function record_loop_messages()
+    #typedef struct tagMSG {
+    data hwnd#1
+    data message#1
+    data wParam#1
+    data lParam#1
+    data *time#1
+    #typedef struct tagPOINT {
+    data *x#1
+    data *y#1
+
+    sd msg^hwnd
+
+    import "_GetMessageA@16" GetMessage
+    sd looper=1
+    while looper!=-1
+        setcall looper GetMessage(msg,0,0,0)
+        if message=(MM_WIM_DATA)
+            call record_newbuffer(lParam)
+            sd flag
+            setcall flag record_flag((value_get))
+            if flag=(flag_stop)
+                sd buffers
+                setcall buffers record_buffers((value_get))
+                dec buffers
+                call record_buffers((value_set),buffers)
+                if buffers=0
+                    return 0
+                endif
+            else
+                sd bool
+                setcall bool wavein_add(wParam,lParam)
+                if bool!=1
+                    return 0
+                endif
+            endelse
+        endif
+    endwhile
+endfunction
+
+function record_newbuffer(sd waveinheader)
+    #typedef struct wavehdr_tag {
+      #LPSTR              lpData;
+      #DWORD              dwBufferLength;
+      #DWORD              dwBytesRecorded;
+      #..
+    sd buffer
+    set buffer waveinheader#
+    add waveinheader 8
+    sd length
+    set length waveinheader#
+
+    sd file
+    setcall file record_file((value_get))
+
+    call file_write(buffer,length,file)
+endfunction
+
+#main thread
+#entry
+entry record()
+
+str options="options.txt"
+str r="rb"
+sd file
+setcall file fopen(options,r)
+if file=0
+    str err="Cannot open options file."
+    call errors(err)
+    return 0
+endif
+
+sd bool
+setcall bool record_options(file)
+if bool!=1
+    return 0
+endif
+
+call record_sound()
+
+call fclose(file)
+
+return 0
--- ovideo-1.orig/soundrecorder/src/soundrecorder.s
+++ /dev/null
@@ -1,591 +0,0 @@
-
-
-format elfobj
-
-include "ascii.h"
-include "common.h"
-
-include "util.s"
-include "values.s"
-
-const WAVE_FORMAT_PCM=1
-
-#this program record sound from the default recording device and writes to the wav format
-
-#the mechanism is simple:
-#main thread:
-#flag stop
-#create event
-    #create thread
-        #openwav
-            #buffer,prepare,add
-                #buffer,prepare,add
-                    #start
-                        #flag ok,set event
-                        #getch
-                        #reset event,flag stop,wait event
-
-#second thread:
-    #wait event,verify flag ok
-        #get buffers and write
-        #verify flag stop
-            #1. continue
-            #2. finish all bufers and set event and return
-
-import "_CloseHandle@4" CloseHandle
-import "_fopen" fopen
-import "_fclose" fclose
-
-#bool
-function record_options(sd file)
-    import "_fseek" fseek
-    import "_ftell" ftell
-    str lengtherr="Options file length error"
-    sd len
-    sd fileresult
-
-    setcall fileresult fseek(file,0,(SEEK_END))
-    if fileresult!=0
-        call errors(lengtherr)
-        return 0
-    endif
-    setcall len ftell(file)
-    if len<=0
-        call errors(lengtherr)
-        return 0
-    endif
-    setcall fileresult fseek(file,0,(SEEK_SET))
-    if fileresult!=0
-        call errors(lengtherr)
-        return 0
-    endif
-
-    const max_options_length=100
-
-    char text#max_options_length
-    ss options_text^text
-
-    if len>=(max_options_length)
-        call errors(lengtherr)
-        return 0
-    endif
-
-    import "_fread" fread
-    sd readed
-    setcall readed fread(options_text,1,len,file)
-    if readed!=len
-        str readerr="Read error"
-        call errors(readerr)
-        return 0
-    endif
-    char spc=" "
-
-    ss safe
-    set safe options_text
-    add safe readed
-    set safe# spc
-    inc len
-
-    sd count=0
-    ss cursor
-    set cursor options_text
-    while len!=0
-        if cursor#==spc
-            import "_atoi" atoi
-            set cursor# 0
-            sd value
-            setcall value atoi(options_text)
-            if value<1
-                str lowval="Wrong option"
-                call errors(lowval)
-                return 0
-            endif
-            if count==0
-                call channels_value((value_set),value)
-            elseif count==1
-                call rate_value((value_set),value)
-            else
-                if value<8
-                    str lowbps="Wrong bps"
-                    call errors(lowbps)
-                    return 0
-                endif
-                call bps_value((value_set),value)
-            endelse
-            set options_text cursor
-            inc options_text
-            inc count
-        endif
-        inc cursor
-        dec len
-    endwhile
-    set cursor# 0
-
-    if count!=3
-        str index_expected="More options expected"
-        call errors(index_expected)
-        return 0
-    endif
-
-    return 1
-endfunction
-
-function record_sound()
-    call record_flag((value_set),(flag_stop))
-
-    import "_CreateEventA@16" CreateEvent
-    #HANDLE WINAPI CreateEvent(
-    #  __in_opt  LPSECURITY_ATTRIBUTES lpEventAttributes,
-    #  __in      BOOL bManualReset,
-    #  __in      BOOL bInitialState,
-    #  __in_opt  LPCTSTR lpName);
-
-    sd event
-    setcall event CreateEvent(0,0,0,0)
-
-    call record_event((value_set),event)
-
-    call record_createthread()
-
-    #in case we got errors, to stop the second thread
-    #knowing that Resetting an event that is already reset has no effect
-    import "_ResetEvent@4" ResetEvent
-    call ResetEvent(event)
-
-    call CloseHandle(event)
-
-    import "_exit" exit
-    call exit(1)
-endfunction
-
-function record_createthread()
-    import "_CreateThread@24" CreateThread
-
-    data f^record_second_thread
-
-    sd thread_id
-    sd p_thread_id^thread_id
-
-    sd thread
-    setcall thread CreateThread(0,0,f,0,0,p_thread_id)
-    if thread==0
-        return 0
-    endif
-
-    call record_fileandsizes(thread_id)
-
-    call CloseHandle(thread)
-endfunction
-
-####################
-
-function record_fileandsizes(sd thread_id)
-    import "_time" time
-    sd tm
-    setcall tm time()
-    import "_sprintf" sprintf
-    char filename_data#100
-    str filename^filename_data
-    str format="%u.wav"
-    call sprintf(filename,format,tm)
-
-    str wr="wb"
-    sd file
-    setcall file fopen(filename,wr)
-    if file==0
-        str err="Cannot open the output file."
-        call errors(err)
-        return 0
-    endif
-
-    call record_got_file(file,thread_id)
-
-    call fclose(file)
-endfunction
-
-function record_got_file(sd file,sd thread_id)
-#const _RIFF^riff
-const _RIFF=!
-    char riff={R,I,F,F}
-    data riffsize#1
-
-    char WAVE={W,A,V,E}
-    char *fmt={f,m,t,Space}
-    data fmtsize#1
-    #WAVEFORMATEX
-    char wFormatTag={WAVE_FORMAT_PCM,0}
-    char nChannels={1,0}
-    data nSamplesPerSec#1
-    data nAvgBytesPerSec#1
-    char nBlockAlign={2,0}
-    char wBitsPerSample={16,0}
-    #EX
-    #no extra data, simple PCM-format used
-    char *cbSize={0,0}
-
-    char datatag={d,a,t,a}
-    data datasize#1
-
-#const RIFF_^RIFF
-const RIFF_=!
-
-    data RIFF^riff
-    const RIFF_size=RIFF_-_RIFF
-
-    const _WAVEFORMATEX^wFormatTag
-    const WAVEFORMATEX_^datatag
-    set fmtsize (WAVEFORMATEX_-_WAVEFORMATEX)
-
-    setcall nChannels channels_value((value_get))
-    setcall nSamplesPerSec rate_value((value_get))
-    setcall wBitsPerSample bps_value((value_get))
-    setcall nBlockAlign blockalign_value()
-    setcall nAvgBytesPerSec avgbytespersec_value()
-
-    sd bool
-    setcall bool file_write(RIFF,(RIFF_size),file)
-    if bool==0
-        return 0
-    endif
-
-    #store file for buffer write
-    call record_file((value_set),file)
-
-    sd hwi
-    sd p_hwi^hwi
-    str WAVEFORMATEX^wFormatTag
-
-    import "_waveInOpen@24" waveInOpen
-    sd wavecall
-    setcall wavecall waveInOpen(p_hwi,0,WAVEFORMATEX,thread_id,0,(CALLBACK_THREAD))
-    if wavecall!=(MMSYSERR_NOERROR)
-        return 0
-    endif
-
-    call record_hwavein((value_set),hwi)
-
-    call record_got_wavein()
-
-    import "_waveInClose@4" waveInClose
-    call waveInClose(hwi)
-
-    #write riffsize and datasize
-    sd position
-    setcall position ftell(file)
-    if position==(INVALID_HANDLE)
-        str ertell="Get file position error"
-        call errors(ertell)
-        return 0
-    endif
-
-    set datasize position
-    sub datasize (RIFF_size)
-
-    sd even
-    set even position
-    and even 1
-    if even==1
-        str pad=""
-        setcall bool file_write(pad,1,file)
-        if bool!=1
-            return 0
-        endif
-        inc position
-    endif
-
-    set riffsize position
-    sub riffsize (4+4)
-
-    str endseekerr="File seek error"
-
-    sd seekint
-    SetCall seekint fseek(file,4,(SEEK_SET))
-    If seekint!=0
-        call errors(endseekerr)
-        return 0
-    endif
-
-    sd p_rifsz^riffsize
-    setcall bool file_write(p_rifsz,4,file)
-    if bool!=1
-        return 0
-    endif
-
-    const _RIFF_block_start^WAVE
-    const datasize_off^datasize
-
-    SetCall seekint fseek(file,(datasize_off-_RIFF_block_start),(SEEK_CUR))
-    If seekint!=0
-        call errors(endseekerr)
-        return 0
-    endif
-
-    sd p_datasize^datasize
-    call file_write(p_datasize,4,file)
-endfunction
-
-#get two buffers, when one is full, write it to file, in the same time, the other one can record
-
-function record_got_wavein()
-    sd len
-    setcall len BufferLength_value()
-    sd buffer
-    setcall buffer alloc(len)
-    if buffer==0
-        return 0
-    endif
-    import "_free" free
-
-    call record_prepare_buffer(buffer)
-
-    call free(buffer)
-endfunction
-
-function record_prepare_buffer(sd buffer)
-    data lpData#1
-    data dwBufferLength#1
-    data *dwBytesRecorded#1
-    data *dwUser#1
-    data *dwFlags=0
-    data *dwLoops#1
-    data *lpNext#1
-    data *reserved#1
-
-    sd wavehd^lpData
-
-#lpData, dwBufferLength, and dwFlags members must be set
-    set lpData buffer
-
-    setcall dwBufferLength BufferLength_value()
-
-    sd wavein
-    setcall wavein record_hwavein((value_get))
-
-    sd bool
-    setcall bool wavein_prepare(wavein,wavehd)
-    if bool!=1
-        return 0
-    endif
-
-    call record_prepare_add(wavein,wavehd)
-
-    import "_waveOutUnprepareHeader@12" waveInUnprepareHeader
-    call waveInUnprepareHeader(wavein,wavehd,(WAVEHDR_size))
-endfunction
-
-function record_prepare_add(sd wavein,sd wavehdr)
-    sd bool
-    setcall bool wavein_add(wavein,wavehdr)
-    if bool!=1
-        return 0
-    endif
-    call record_buffer_next()
-endfunction
-
-function record_buffer_next()
-    sd len
-    setcall len BufferLength_value()
-    sd buffer_2
-    setcall buffer_2 alloc(len)
-    if buffer_2==0
-        return 0
-    endif
-    call record_prepare_buffer_2(buffer_2)
-    call free(buffer_2)
-endfunction
-
-
-function record_prepare_buffer_2(sd buffer)
-    data lpData#1
-    data dwBufferLength#1
-    data *dwBytesRecorded#1
-    data *dwUser#1
-    data *dwFlags=0
-    data *dwLoops#1
-    data *lpNext#1
-    data *reserved#1
-
-    sd wavehd^lpData
-
-#lpData, dwBufferLength, and dwFlags members must be set
-    set lpData buffer
-
-    setcall dwBufferLength BufferLength_value()
-
-    sd wavein
-    setcall wavein record_hwavein((value_get))
-
-    sd bool
-    setcall bool wavein_prepare(wavein,wavehd)
-    if bool!=1
-        return 0
-    endif
-
-    call record_start(wavein,wavehd)
-
-    call waveInUnprepareHeader(wavein,wavehd,(WAVEHDR_size))
-endfunction
-
-function record_start(sd wavein,sd wavehdr)
-    sd bool
-    setcall bool wavein_add(wavein,wavehdr)
-    if bool!=1
-        return 0
-    endif
-
-    import "_waveInStart@4" waveInStart
-    sd mm
-    setcall mm waveInStart(wavein)
-    if mm!=(MMSYSERR_NOERROR)
-        return 0
-    endif
-
-    call record_dialog()
-
-    import "_waveInStop@4" waveInStop
-    call waveInStop(wavein)
-#create an event
-endfunction
-
-function record_dialog()
-    call record_buffers((value_set),2)
-
-    call record_flag((value_set),(flag_recording))
-
-    sd event
-    setcall event record_event((value_get))
-
-    import "_SetEvent@4" SetEvent
-    call SetEvent(event)
-
-    str info="Recording. Press any key to stop.."
-    call printf(info)
-
-    import "__getch" getch
-    call getch()
-
-    char nl={0xa,0}
-    str newline^nl
-
-    call printf(newline)
-
-    str done="Done"
-    call printf(done)
-
-    call printf(newline)
-
-    call ResetEvent(event)
-    call record_flag((value_set),(flag_stop))
-    import "_WaitForSingleObject@8" WaitForSingleObject
-    call WaitForSingleObject(event,(INFINITE))
-endfunction
-
-################
-
-
-
-
-
-
-
-function record_second_thread(sd *data)
-    sd event
-    setcall event record_event((value_get))
-
-    call WaitForSingleObject(event,(INFINITE))
-
-    sd flag
-    setcall flag record_flag((value_get))
-
-    if flag==(flag_stop)
-        return 0
-    endif
-
-    call record_loop_messages()
-
-    call SetEvent(event)
-endfunction
-
-function record_loop_messages()
-    #typedef struct tagMSG {
-    data hwnd#1
-    data message#1
-    data wParam#1
-    data lParam#1
-    data *time#1
-    #typedef struct tagPOINT {
-    data *x#1
-    data *y#1
-
-    sd msg^hwnd
-
-    import "_GetMessageA@16" GetMessage
-    sd looper=1
-    while looper!=-1
-        setcall looper GetMessage(msg,0,0,0)
-        if message==(MM_WIM_DATA)
-            call record_newbuffer(lParam)
-            sd flag
-            setcall flag record_flag((value_get))
-            if flag==(flag_stop)
-                sd buffers
-                setcall buffers record_buffers((value_get))
-                dec buffers
-                call record_buffers((value_set),buffers)
-                if buffers==0
-                    return 0
-                endif
-            else
-                sd bool
-                setcall bool wavein_add(wParam,lParam)
-                if bool!=1
-                    return 0
-                endif
-            endelse
-        endif
-    endwhile
-endfunction
-
-function record_newbuffer(sd waveinheader)
-    #typedef struct wavehdr_tag {
-      #LPSTR              lpData;
-      #DWORD              dwBufferLength;
-      #DWORD              dwBytesRecorded;
-      #..
-    sd buffer
-    set buffer waveinheader#
-    add waveinheader 8
-    sd length
-    set length waveinheader#
-
-    sd file
-    setcall file record_file((value_get))
-
-    call file_write(buffer,length,file)
-endfunction
-
-#main thread
-#entry
-entry record()
-
-str options="options.txt"
-str r="rb"
-sd file
-setcall file fopen(options,r)
-if file==0
-    str err="Cannot open options file."
-    call errors(err)
-    return 0
-endif
-
-sd bool
-setcall bool record_options(file)
-if bool!=1
-    return 0
-endif
-
-call record_sound()
-
-call fclose(file)
-
-return 0
--- /dev/null
+++ ovideo-1/soundrecorder/src/util.oc
@@ -0,0 +1,64 @@
+
+
+
+
+function errors(ss string)
+    import "_printf" printf
+    call printf(string)
+    return 0
+endfunction
+
+#bool
+function file_write(sd buffer,sd size,sd file)
+    if size=0
+        return 1
+    endif
+    sd sizewrote
+    import "_fwrite" fwrite
+    setcall sizewrote fwrite(buffer,1,size,file)
+    if sizewrote!=0
+        return 1
+    endif
+    str er="File write error."
+    call errors(er)
+    return 0
+endfunction
+
+#0/buffer
+function alloc(sd size)
+    import "_malloc" malloc
+    sd buffer
+    setcall buffer malloc(size)
+    if buffer=0
+        str er="Memory alloc error"
+        call errors(er)
+        return buffer
+    endif
+    return buffer
+endfunction
+
+#bool
+import "_waveInPrepareHeader@12" waveInPrepareHeader
+function wavein_prepare(sd hwavein,sd wavehdr)
+    sd mm
+    setcall mm waveInPrepareHeader(hwavein,wavehdr,(WAVEHDR_size))
+    if mm!=(MMSYSERR_NOERROR)
+        str er="WaveIn prepare header error"
+        call errors(er)
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+import "_waveInAddBuffer@12" waveInAddBuffer
+function wavein_add(sd hwavein,sd wavehdr)
+    sd mm
+    setcall mm waveInAddBuffer(hwavein,wavehdr,(WAVEHDR_size))
+    if mm!=(MMSYSERR_NOERROR)
+        str er="WaveIn add buffer error"
+        call errors(er)
+        return 0
+    endif
+    return 1
+endfunction
--- ovideo-1.orig/soundrecorder/src/util.s
+++ /dev/null
@@ -1,64 +0,0 @@
-
-
-
-
-function errors(ss string)
-    import "_printf" printf
-    call printf(string)
-    return 0
-endfunction
-
-#bool
-function file_write(sd buffer,sd size,sd file)
-    if size==0
-        return 1
-    endif
-    sd sizewrote
-    import "_fwrite" fwrite
-    setcall sizewrote fwrite(buffer,1,size,file)
-    if sizewrote!=0
-        return 1
-    endif
-    str er="File write error."
-    call errors(er)
-    return 0
-endfunction
-
-#0/buffer
-function alloc(sd size)
-    import "_malloc" malloc
-    sd buffer
-    setcall buffer malloc(size)
-    if buffer==0
-        str er="Memory alloc error"
-        call errors(er)
-        return buffer
-    endif
-    return buffer
-endfunction
-
-#bool
-import "_waveInPrepareHeader@12" waveInPrepareHeader
-function wavein_prepare(sd hwavein,sd wavehdr)
-    sd mm
-    setcall mm waveInPrepareHeader(hwavein,wavehdr,(WAVEHDR_size))
-    if mm!=(MMSYSERR_NOERROR)
-        str er="WaveIn prepare header error"
-        call errors(er)
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-import "_waveInAddBuffer@12" waveInAddBuffer
-function wavein_add(sd hwavein,sd wavehdr)
-    sd mm
-    setcall mm waveInAddBuffer(hwavein,wavehdr,(WAVEHDR_size))
-    if mm!=(MMSYSERR_NOERROR)
-        str er="WaveIn add buffer error"
-        call errors(er)
-        return 0
-    endif
-    return 1
-endfunction
--- /dev/null
+++ ovideo-1/soundrecorder/src/values.oc
@@ -0,0 +1,95 @@
+
+
+
+function record_flag(sd action,sd value)
+    data flag#1
+    if action=(value_set)
+        set flag value
+    else
+        return flag
+    endelse
+endfunction
+
+function record_event(sd action,sd value)
+    data event#1
+    if action=(value_set)
+        set event value
+    else
+        return event
+    endelse
+endfunction
+
+
+function record_file(sd action,sd value)
+    data file#1
+    if action=(value_set)
+        set file value
+    else
+        return file
+    endelse
+endfunction
+
+function record_hwavein(sd action,sd value)
+    data hwavein#1
+    if action=(value_set)
+        set hwavein value
+    else
+        return hwavein
+    endelse
+endfunction
+
+
+function record_buffers(sd action,sd value)
+    data buffers#1
+    if action=(value_set)
+        set buffers value
+    else
+        return buffers
+    endelse
+endfunction
+
+function channels_value(sd action,sd value)
+    data channels=1
+    if action=(value_set)
+        set channels value
+    else
+        return channels
+    endelse
+endfunction
+function rate_value(sd action,sd value)
+    data rate=22050
+    if action=(value_set)
+        set rate value
+    else
+        return rate
+    endelse
+endfunction
+function bps_value(sd action,sd value)
+    data bps=16
+    if action=(value_set)
+        set bps value
+    else
+        return bps
+    endelse
+endfunction
+
+function blockalign_value()
+    sd value
+    setcall value channels_value((value_get))
+    multcall value bps_value((value_get))
+    div value 8
+    return value
+endfunction
+function avgbytespersec_value()
+    sd value
+    setcall value blockalign_value()
+    multcall value rate_value((value_get))
+    return value
+endfunction
+
+function BufferLength_value()
+    sd value
+    setcall value avgbytespersec_value()
+    mult value 2
+    return value
+endfunction
--- ovideo-1.orig/soundrecorder/src/values.s
+++ /dev/null
@@ -1,95 +0,0 @@
-
-
-
-function record_flag(sd action,sd value)
-    data flag#1
-    if action==(value_set)
-        set flag value
-    else
-        return flag
-    endelse
-endfunction
-
-function record_event(sd action,sd value)
-    data event#1
-    if action==(value_set)
-        set event value
-    else
-        return event
-    endelse
-endfunction
-
-
-function record_file(sd action,sd value)
-    data file#1
-    if action==(value_set)
-        set file value
-    else
-        return file
-    endelse
-endfunction
-
-function record_hwavein(sd action,sd value)
-    data hwavein#1
-    if action==(value_set)
-        set hwavein value
-    else
-        return hwavein
-    endelse
-endfunction
-
-
-function record_buffers(sd action,sd value)
-    data buffers#1
-    if action==(value_set)
-        set buffers value
-    else
-        return buffers
-    endelse
-endfunction
-
-function channels_value(sd action,sd value)
-    data channels=1
-    if action==(value_set)
-        set channels value
-    else
-        return channels
-    endelse
-endfunction
-function rate_value(sd action,sd value)
-    data rate=22050
-    if action==(value_set)
-        set rate value
-    else
-        return rate
-    endelse
-endfunction
-function bps_value(sd action,sd value)
-    data bps=16
-    if action==(value_set)
-        set bps value
-    else
-        return bps
-    endelse
-endfunction
-
-function blockalign_value()
-    sd value
-    setcall value channels_value((value_get))
-    multcall value bps_value((value_get))
-    div value 8
-    return value
-endfunction
-function avgbytespersec_value()
-    sd value
-    setcall value blockalign_value()
-    multcall value rate_value((value_get))
-    return value
-endfunction
-
-function BufferLength_value()
-    sd value
-    setcall value avgbytespersec_value()
-    mult value 2
-    return value
-endfunction
--- ovideo-1.orig/src/Makefile
+++ ovideo-1/src/Makefile
@@ -4,7 +4,8 @@ OCOMP=o
 endif
 
 ifndef linkerflags
-linkerflags=-O1 -s
+linkerflags=-O3 -s
+#           -O1
 endif
 
 platform = lin
@@ -52,22 +53,38 @@ items_prefix=
 projname=ovideo
 wprojname=ovideo.exe
 lshare=_dif/share.txt
-logs :=
-obs :=
 sharefolderpackage=$(prefix)/share/ovideo
 sharefolder=$(DESTDIR)${sharefolderpackage}
 
-all: compile lnk
+$(eval obs = )
+$(foreach var,$(items),$(eval obs += ${items_prefix}${var}.o))
+$(eval logs = )
+$(foreach var,$(items),$(eval logs += ${items_prefix}${var}.oc.log))
 
-compile: share ${items} ounused
+ifeq (${platform},lin)
 
-ounused:
+all: ${projname}
+${projname}: ${lshare} ${obs}
 	ounused ${logs}
+	@echo
+	$(CC) -nostdlib ${linkerflags} ${obs} -o ${items_prefix}${projname} `pkg-config --libs gtk+-2.0 gstreamer-pbutils-0.10 gstreamer-interfaces-0.10 gstreamer-app-0.10` -lsoup-2.4 -ljpeg -lasound -lm -lpthread -lc
+${lshare}:
+	echo return \"${sharefolderpackage}\" > ${lshare}
 
-share:
-	if [ "${platform}" = "lin" ]; then \
-		echo return \"${sharefolderpackage}\" > ${lshare}; \
-	fi
+else
+
+all: ${wprojname}
+${wprojname}: ${obs}
+	ounused ${logs}
+	@echo
+	i686-w64-mingw32-ld --large-address-aware ${linkerflags} ${obs} -o ${wprojname} -entry _start --start-group \
+	`dpkg -L mingw-w64-i686-dev | grep '\.a' | sed 's/..$$//' | grep -o '[^\/]*$$' | sed 's/^lib/-l/' | xargs echo` \
+	--end-group -L`echo ~`/.wine/drive_c/gstreamer-sdk/0.10/x86/lib/ \
+	-lgtk-win32-2.0 -lgdk-win32-2.0 -lgdk_pixbuf-2.0 -lglib-2.0 -lgobject-2.0 -lgio-2.0 -lgthread-2.0 \
+	-lgstreamer-0.10 -lgstapp-0.10 -lgstinterfaces-0.10 -lgstpbutils-0.10 \
+	-lcairo -lpango-1.0 -lsoup-2.4 -ljpeg
+
+endif
 
 #at jammy libgtk2.0-dev:i386,libgstreamer-plugins-base1.0-dev:i386,libsoup2.4-dev:i386,libasound2-dev:i386
 
@@ -90,31 +107,21 @@ share:
 #		$(LD) ${linkerflags} -melf_i386 --dynamic-linker=/lib/ld-linux.so.2 ${obs} -o ${projname} -lc -lm `pkg-config --libs gtk+-2.0 gstreamer-pbutils-1.0 gstreamer-app-1.0` -ljpeg -lsoup-2.4 -lasound -lgthread-2.0; \
 #cc because -pthread not for ld
 #nostdlib because is complaining about main
-lnk:
-	if [ "${platform}" = "lin" ]; then \
-		$(CC) -nostdlib ${linkerflags} ${obs} -o ${items_prefix}${projname} `pkg-config --libs gtk+-2.0 gstreamer-pbutils-0.10 gstreamer-interfaces-0.10 gstreamer-app-0.10` -lsoup-2.4 -ljpeg -lasound -lm -lpthread -lc; \
-	else \
-		i686-w64-mingw32-ld --large-address-aware ${linkerflags} ${obs} -o ${wprojname} -entry _start --start-group \
-		`dpkg -L mingw-w64-i686-dev | grep '\.a' | sed 's/..$$//' | grep -o '[^\/]*$$' | sed 's/^lib/-l/' | xargs echo` \
-		--end-group -L`echo ~`/.wine/drive_c/gstreamer-sdk/0.10/x86/lib/ \
-		-lgtk-win32-2.0 -lgdk-win32-2.0 -lgdk_pixbuf-2.0 -lglib-2.0 -lgobject-2.0 -lgio-2.0 -lgthread-2.0 \
-		-lgstreamer-0.10 -lgstapp-0.10 -lgstinterfaces-0.10 -lgstpbutils-0.10 \
-		-lcairo -lpango-1.0 -lsoup-2.4 -ljpeg; \
-	fi
-fast:
-	$(eval obs = `printf ' ${items_prefix}%s.o' ${items}`)
-link: fast lnk
+
+#fast:
+#	$(eval obs = `printf ' ${items_prefix}%s.o' ${items}`)
+#link: fast lnk
 #snprintf with circular unresolved requirements
 #cos is in -lmingwex that will work with -lmingw32 -lmsvcrt
 #on win msvcr100 is old and at here is from old java-i586
 
-%: %.s
+%.o: %.oc
 	${OCOMP} $< ${OFLAGS}
-	$(eval logs += $@.s.log)
-	$(eval obs += $@.o)
+#	$(eval logs += $@.oc.log)
+#	$(eval obs += $@.o)
 
 clean:
-	-printf ' %s.s.log' ${items} | xargs rm -f
+	-printf ' %s.oc.log' ${items} | xargs rm -f
 	-printf ' %s.o' ${items} | xargs rm -f
 	-rm -f ${projname}
 	-rm -f ${lshare}
--- /dev/null
+++ ovideo-1/src/_capture/capture.oc
@@ -0,0 +1,1293 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+
+const left_coord=0
+const top_coord=1
+const width_coord=2
+const height_coord=3
+const capture_cursor=4
+const capture_temporary=5
+const capture_raw=6
+
+const value_setrect=value_custom
+
+function capture()
+    import "dialogfield" dialogfield
+    sd init^capture_init
+    sd set^capture_start
+    ss title="Capture"
+    call dialogfield(title,(GTK_DIALOG_MODAL),init,set)
+endfunction
+
+import "capture_alternative_init" capture_alternative_init
+import "capture_alternative_set" capture_alternative_set
+import "capture_alternative_prepare" capture_alternative_prepare
+import "capture_alternative_append" capture_alternative_append
+import "capture_alternative_free" capture_alternative_free
+
+function capture_init(sd vbox,sd *dialog)
+    import "labelfield_l" labelfield_l
+    ss text="Desktop Crop"
+    call labelfield_l(text,vbox)
+    import "tablefield_cells" tablefield_cells
+    import "labelfield_left_prepare" labelfield_left_prepare
+    importx "_gtk_entry_new" gtk_entry_new
+    sd left_text
+    sd left_entry
+    sd top_text
+    sd top_entry
+    sd width_text
+    sd width_entry
+    sd height_text
+    sd height_entry
+    sd size_text
+    sd size_entry
+    sd string
+
+    importx "_gtk_entry_set_text" gtk_entry_set_text
+    ss l="Left"
+    ss t="Top"
+    ss w="Width"
+    ss h="Height"
+    ss sz="File split size(bytes)"
+    #rect
+    setcall left_text labelfield_left_prepare(l)
+    setcall left_entry gtk_entry_new()
+    setcall string capture_left_string()
+    call gtk_entry_set_text(left_entry,string)
+    #
+    setcall top_text labelfield_left_prepare(t)
+    setcall top_entry gtk_entry_new()
+    setcall string capture_top_string()
+    call gtk_entry_set_text(top_entry,string)
+    #
+    setcall width_text labelfield_left_prepare(w)
+    setcall width_entry gtk_entry_new()
+    setcall string capture_width_string()
+    call gtk_entry_set_text(width_entry,string)
+    #
+    setcall height_text labelfield_left_prepare(h)
+    setcall height_entry gtk_entry_new()
+    setcall string capture_height_string()
+    call gtk_entry_set_text(height_entry,string)
+    #size limit
+    setcall size_text labelfield_left_prepare(sz)
+    setcall size_entry gtk_entry_new()
+    setcall string capture_size_string()
+    call gtk_entry_set_text(size_entry,string)
+    #set the values
+    sd cells^left_text
+    call tablefield_cells(vbox,5,2,cells)
+    call capture_rect((value_set),(left_coord),left_entry)
+    call capture_rect((value_set),(top_coord),top_entry)
+    call capture_rect((value_set),(width_coord),width_entry)
+    call capture_rect((value_set),(height_coord),height_entry)
+    call capture_split((value_set),size_entry)
+
+    importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
+    import "packstart_default" packstart_default
+
+    #cursor
+    importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
+    ss txt="Capture the cursor"
+    sd cursor
+    setcall cursor gtk_check_button_new_with_label(txt)
+    sd cursor_flag
+    setcall cursor_flag capture_cursor_option((value_get))
+    call gtk_toggle_button_set_active(cursor,cursor_flag)
+    call packstart_default(vbox,cursor)
+    call capture_rect((value_set),(capture_cursor),cursor)
+
+    #temp file
+    ss temp_txt="Temporary file first"
+    sd temp
+    setcall temp gtk_check_button_new_with_label(temp_txt)
+    importx "_gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
+    ss temp_info="Ignored if Raw file(s) selected"
+    call gtk_widget_set_tooltip_markup(temp,temp_info)
+    sd temp_flag
+    setcall temp_flag capture_temp_option((value_get))
+    call gtk_toggle_button_set_active(temp,temp_flag)
+    call packstart_default(vbox,temp)
+    call capture_rect((value_set),(capture_temporary),temp)
+    call capture_direct((value_set))
+
+    #raw file
+    ss raw_info="Raw file(s)"
+    sd raw
+    setcall raw gtk_check_button_new_with_label(raw_info)
+    call packstart_default(vbox,raw)
+    sd raw_flag
+    setcall raw_flag capture_raw_option((value_get))
+    call gtk_toggle_button_set_active(raw,raw_flag)
+    call capture_rect((value_set),(capture_raw),raw)
+
+    #alternative
+    call capture_alternative_init(vbox)
+endfunction
+
+importx "_g_object_unref" g_object_unref
+
+function capture_start()
+    #set capture rect, can return if arguments are not right
+    sd bool
+    setcall bool capture_rect((value_setrect))
+    if bool!=1
+        return 0
+    endif
+
+    #verify for output format
+    setcall bool capture_format()
+    if bool!=1
+        return 0
+    endif
+
+    #init max allowed
+    call capture_split((value_write))
+    #call the loop
+    call capture_files_loop((value_run))
+endfunction
+
+#bool
+function capture_format()
+    sd raw_flag
+    setcall raw_flag capture_raw_option((value_get))
+    if raw_flag=1
+        return 1
+    endif
+    import "stage_file_options_output" stage_file_options_output
+    sd output
+    setcall output stage_file_options_output()
+    sd capture_bool=1
+    if output<(format_mkv)
+        set capture_bool 0
+    else
+        if output>(format_mkv_last)
+            set capture_bool 0
+        else
+            import "stage_file_get_mkv_encoder" stage_file_get_mkv_encoder
+            sd encoder
+            setcall encoder stage_file_get_mkv_encoder()
+            if encoder!=(format_mkv_i420)
+                if encoder!=(format_mkv_mjpg)
+                    if encoder!=(format_mkv_rgb24)
+                        set capture_bool 0
+                    endif
+                endif
+            endif
+        endelse
+    endelse
+    if capture_bool=0
+        import "message_dialog" message_dialog
+        str txt="Capture with MKV(I420,MJPEG,RGB24) selected at Stage Options"
+        call message_dialog(txt)
+        return 0
+    endif
+    return 1
+endfunction
+
+function capture_files_loop(sd action)
+    data loop#1
+    if action=(value_set)
+        set loop 1
+    else
+        set loop 1
+
+        sd bool
+        setcall bool capture_pixbuf((value_set))
+        if bool!=1
+            return 0
+        endif
+
+        #tempfile
+        call capture_temp_file((value_set),0)
+
+        #don't display the result message inter-files
+        import "stage_file_options_info_message" stage_file_options_info_message
+        sd info
+        setcall info stage_file_options_info_message((value_get))
+        call stage_file_options_info_message((value_set),0)
+
+        #file index
+        sd file_index=0
+
+        #get the time and start the loop files
+        call capture_time((value_set))
+        while loop=1
+            #loop 1 can be if max size detected
+            set loop 0
+
+            # can be temp/raw
+            setcall bool capture_direct((value_run))
+            if bool=1
+            #mkv
+                import "mkvfile" mkvfile
+                call mkvfile((capture_flag_on),file_index)
+            endif
+
+            #next file index
+            inc file_index
+        endwhile
+        #restore info message
+        call stage_file_options_info_message((value_set),info)
+
+        sd temp_file
+        setcall temp_file capture_temp_file((value_get))
+        if temp_file!=0
+            importx "_fclose" fclose
+            call fclose(temp_file)
+        endif
+
+        call capture_pixbuf((value_unset))
+    endelse
+endfunction
+
+import "entry_to_int_min_N_max_M" entry_to_int_min_N_max_M
+
+const max_file_size=0x3fFFffFF
+
+const split_maxsize_value=value_custom
+
+function capture_split(sd action,sd value)
+    data split_entry#1
+    data maxsize#1
+
+    data p_maxsize^maxsize
+    if action=(value_set)
+        set split_entry value
+    elseif action=(value_get)
+        return split_entry
+    elseif action=(value_write)
+        sd bool
+        setcall bool entry_to_int_min_N_max_M(split_entry,p_maxsize,1,(max_file_size))
+        if bool!=1
+            set maxsize (max_file_size)
+        endif
+    elseif action=(split_maxsize_value)
+        return maxsize
+    else
+    #bool: 0 stop, 1 continue
+        #if action==(value_get)
+        #value is file
+        import "file_tell" file_tell
+        sd pos
+        sd p_pos^pos
+        sd err
+
+        setcall err file_tell(value,p_pos)
+        if err!=(noerror)
+            return 0
+        endif
+        if pos>=maxsize
+            call capture_files_loop((value_set))
+            return 0
+        endif
+        return 1
+    endelse
+endfunction
+
+importx "_gdk_get_default_root_window" gdk_get_default_root_window
+import "sleepMs" sleepMs
+import "texter" texter
+
+const value_init=0
+const value_screenshot=1
+
+function capture_rect(sd action,sd index,sd value)
+    #widgets
+    data left#1
+    data top#1
+    data width#1
+    data height#1
+    data cursor#1
+    data temporary#1
+    data raw#1
+
+    if action=(value_set)
+        if index=(left_coord)
+            set left value
+        elseif index=(top_coord)
+            set top value
+        elseif index=(width_coord)
+            set width value
+        elseif index=(height_coord)
+            set height value
+        elseif index=(capture_cursor)
+            set cursor value
+        elseif index=(capture_temporary)
+            set temporary value
+        else
+        #if index==(capture_raw)
+            set raw value
+        endelse
+    elseif action=(value_get)
+        return #left
+    else
+    #if action==(value_setrect)
+    #bool
+        importx "_gdk_drawable_get_size" gdk_drawable_get_size
+        sd root
+        setcall root gdk_get_default_root_window()
+        sd maxwidth
+        sd maxheight
+        sd p_maxwidth^maxwidth
+        sd p_maxheight^maxheight
+        call gdk_drawable_get_size(root,p_maxwidth,p_maxheight)
+
+        sd left_val
+        sd top_val
+        sd values
+        sd M
+        sd bool
+
+        #x
+        set M maxwidth
+        dec M
+        setcall values capture_rect_screenshot((value_init))
+        setcall bool entry_to_int_min_N_max_M(left,values,0,M)
+        if bool!=1
+            return 0
+        endif
+        set left_val values#
+        #y
+        set M maxheight
+        dec M
+        add values 4
+        setcall bool entry_to_int_min_N_max_M(top,values,0,M)
+        if bool!=1
+            return 0
+        endif
+        set top_val values#
+        #w
+        set M maxwidth
+        sub M left_val
+        add values 4
+        setcall bool entry_to_int_min_N_max_M(width,values,1,M)
+        if bool!=1
+            return 0
+        endif
+            #multiple of 4 for unstrided rgb24 cases
+        sd dworded
+        set dworded values#
+        and dworded 0x3
+        if dworded!=0
+            str dw_er="The Width must be a multiple of 4"
+            call texter(dw_er)
+            return 0
+        endif
+        #h
+        set M maxheight
+        sub M top_val
+        add values 4
+        setcall bool entry_to_int_min_N_max_M(height,values,1,M)
+        if bool!=1
+            return 0
+        endif
+        #cursor
+        importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
+        add values 4
+        setcall values# gtk_toggle_button_get_active(cursor)
+        #temporary
+        add values 4
+        setcall values# gtk_toggle_button_get_active(temporary)
+        #raw
+        add values 4
+        setcall values# gtk_toggle_button_get_active(raw)
+
+        import "file_write_forward_sys_folder_enter_leave" file_write_forward_sys_folder_enter_leave
+        data forw_capture^capture_settings_set_write
+        import "capture_file" capture_file
+        ss capture_fl_str
+        setcall capture_fl_str capture_file()
+        call file_write_forward_sys_folder_enter_leave(capture_fl_str,forw_capture)
+
+        return 1
+    endelse
+endfunction
+
+import "file_write" file_write
+
+function capture_left_string()
+    char c#dword_null
+    return #c
+endfunction
+function capture_top_string()
+    char c#dword_null
+    return #c
+endfunction
+function capture_width_string()
+    char c#dword_null
+    return #c
+endfunction
+function capture_height_string()
+    char c#dword_null
+    return #c
+endfunction
+function capture_size_string()
+    char c#dword_null
+    return #c
+endfunction
+import "file_write_string" file_write_string
+function capture_settings_set_write(sd capture_fl)
+    sd value
+    sd p_value^value
+    sd err
+    sd entries
+    sd bool
+    sd string
+    setcall entries capture_rect((value_get))
+    importx "_gtk_entry_get_text" gtk_entry_get_text
+
+    setcall string gtk_entry_get_text(entries#)
+    setcall bool file_write_string(string,capture_fl)
+    if bool!=1
+        return (void)
+    endif
+    add entries (DWORD)
+    #
+    setcall string gtk_entry_get_text(entries#)
+    setcall bool file_write_string(string,capture_fl)
+    if bool!=1
+        return (void)
+    endif
+    add entries (DWORD)
+    #
+    setcall string gtk_entry_get_text(entries#)
+    setcall bool file_write_string(string,capture_fl)
+    if bool!=1
+        return (void)
+    endif
+    add entries (DWORD)
+    #
+    setcall string gtk_entry_get_text(entries#)
+    setcall bool file_write_string(string,capture_fl)
+    if bool!=1
+        return (void)
+    endif
+    add entries (DWORD)
+    #
+    setcall entries capture_split((value_get))
+    setcall string gtk_entry_get_text(entries)
+    setcall bool file_write_string(string,capture_fl)
+    if bool!=1
+        return (void)
+    endif
+
+    setcall value capture_cursor_option((value_get))
+    setcall err file_write(p_value,4,capture_fl)
+    if err!=(noerror)
+        return (void)
+    endif
+    setcall value capture_temp_option((value_get))
+    setcall err file_write(p_value,4,capture_fl)
+    if err!=(noerror)
+        return (void)
+    endif
+    setcall value capture_raw_option((value_get))
+    setcall err file_write(p_value,4,capture_fl)
+    if err!=(noerror)
+        return (void)
+    endif
+endfunction
+
+function capture_time(sd action)
+    import "get_time" get_time
+    #start capture time
+    data starttime#1
+    #total frames captured
+    data totalframes#1
+    #time increment decided by fps
+    data timeincrement#1
+
+    import "stage_file_options_fps" stage_file_options_fps
+    sd fps
+    setcall fps stage_file_options_fps()
+    if action=(value_set)
+        setcall starttime get_time()
+        set totalframes 0
+        set timeincrement 1000
+        div timeincrement fps
+    else
+    #frame length return
+        #sleep time increment
+        call sleepMs(timeincrement)
+        #get correct time position
+        sd seconds
+        set seconds totalframes
+        div seconds fps
+        mult seconds 1000
+
+        import "rest" rest
+        sd nth_sec
+        setcall nth_sec rest(totalframes,fps)
+        mult nth_sec timeincrement
+
+        sd time
+        set time starttime
+        add time seconds
+        add time nth_sec
+
+        #get new time
+        sd newtime
+        setcall newtime get_time()
+        sub newtime time
+
+        #convert it to frames
+        import "get_higher" get_higher
+        sd newframes
+        div newtime timeincrement
+        setcall newframes get_higher(1,newtime)
+
+        #add new length to total frames
+        add totalframes newframes
+
+        return newframes
+    endelse
+endfunction
+
+function capture_obtain_screenshot()
+    call capture_rect_screenshot((value_screenshot))
+    sd pixbuf
+    setcall pixbuf capture_pixbuf((value_get))
+    return pixbuf
+endfunction
+
+const CAIRO_FORMAT_RGB24=1
+
+const sizeofrect=4*4
+const cursor_flag_pointer=sizeofrect
+const cursor_temp_pointer=cursor_flag_pointer+4
+const cursor_raw_pointer=cursor_temp_pointer+4
+
+function capture_rect_screenshot(sd action)
+    data x#1
+    data y#1
+    data wdt#1
+    data hgt#1
+    data cursor_option#1
+    data *temp_option#1
+    data *raw_option#1
+
+    data values_rect^x
+	if action=(value_init)
+    #get the pointer
+        return values_rect
+	endif
+    #if action==(value_screenshot)
+        sd temporary_flag
+        setcall temporary_flag capture_temp_flag((value_get))
+        if temporary_flag=0
+        #live screenshot
+            call capture_pixbuf((value_append),x,y,wdt,hgt,cursor_option)
+        else
+        #screenshot from temp file
+            call capture_read_temp_screenshot(wdt,hgt)
+        endelse
+endfunction
+
+importx "_cairo_destroy" cairo_destroy
+importx "_cairo_surface_destroy" cairo_surface_destroy
+function capture_free_cairo(sd cairo,sd surface)
+    call cairo_destroy(cairo)
+    call cairo_surface_destroy(surface)
+endfunction
+
+import "memalloc" memalloc
+importx "_free" free
+
+function capture_free_cairo_and_mem(sd cairo,sd surface,sd mem)
+    call capture_free_cairo(cairo,surface)
+    call free(mem)
+endfunction
+
+function capture_terminal(sd action,sd value)
+    data terminal#1
+    if action=(value_set)
+        set terminal value
+    else
+        return terminal
+    endelse
+endfunction
+
+function capture_free_stuff(sd cairo_flag,sd cairo,sd surface,sd mem)
+    if cairo_flag=1
+        #use cairo
+        call capture_free_cairo_and_mem(cairo,surface,mem)
+    else
+        call capture_alternative_free()
+    endelse
+endfunction
+function capture_free_more_stuff(sd cairo_flag,sd cairo,sd surface,sd mem,sd pixbuf)
+    call capture_free_stuff(cairo_flag,cairo,surface,mem)
+    call g_object_unref(pixbuf)
+endfunction
+
+import "bytes_swap_reverse" bytes_swap_reverse
+
+function capture_pixbuf(sd action,sd x,sd y,sd pix_width,sd pix_height,sd cursor_flag)
+    data pixbuf#1
+    data mem#1
+    data cairo_flag#1
+
+    data cairo#1
+    data surface#1
+
+	if action=(value_set)
+    #bool
+        sd bool
+        #init capture mem
+        import "rgb_get_all_sizes" rgb_get_all_sizes
+        sd width
+        sd height
+        sd wh^width
+        call capture_get_width_height(wh)
+        sd rowstr
+        sd p_rowstr^rowstr
+        sd sz
+        setcall sz rgb_get_all_sizes(width,height,p_rowstr)
+        sd term=0
+        sd p_term^term
+        set cairo_flag 1
+        sd p_flag^cairo_flag
+        call capture_alternative_set(p_flag,p_term)
+        if cairo_flag=1
+        #cairo is default
+            #cairo surface and cairo context
+            sd root
+            setcall root gdk_get_default_root_window()
+            importx "_cairo_image_surface_create" cairo_image_surface_create
+            setcall surface cairo_image_surface_create((CAIRO_FORMAT_RGB24),width,height)
+            if surface=0
+                str surf="Image surface error"
+                call texter(surf)
+                return 0
+            endif
+
+            importx "_cairo_create" cairo_create
+            setcall cairo cairo_create(surface)
+            sd x_value
+            sd y_value
+            sd p_xy_value^x_value
+            call capture_get_xy(p_xy_value)
+            importx "_gdk_cairo_set_source_window" gdk_cairo_set_source_window
+            sd double_x_low
+            sd double_x_high
+            sd double_y_low
+            sd double_y_high
+            sd double_x^double_x_low
+            sd double_y^double_y_low
+            import "int_to_double" int_to_double
+            sd value
+            set value x_value
+            mult value -1
+            call int_to_double(value,double_x)
+            set value y_value
+            mult value -1
+            call int_to_double(value,double_y)
+            call gdk_cairo_set_source_window(cairo,root,double_x_low,double_x_high,double_y_low,double_y_high)
+            #memory
+            setcall mem memalloc(sz)
+            if mem=0
+                call capture_free_cairo(cairo,surface)
+                return 0
+            endif
+        else
+            sd p_mem^mem
+            setcall bool capture_alternative_prepare(p_mem,width,height)
+            if bool!=1
+                return 0
+            endif
+        endelse
+        importx "_gdk_pixbuf_new_from_data" gdk_pixbuf_new_from_data
+        setcall pixbuf gdk_pixbuf_new_from_data(mem,(GDK_COLORSPACE_RGB),(FALSE),8,width,height,rowstr,0,0)
+        if pixbuf=0
+            call capture_free_stuff(cairo_flag,cairo,surface,mem)
+            return 0
+        endif
+        if term=1
+            setcall bool capture_alternative_prepare()
+            if bool!=1
+                call capture_free_more_stuff(cairo_flag,cairo,surface,mem,pixbuf)
+                return 0
+            endif
+            call capture_terminal((value_set),1)
+        endif
+        return 1
+	endif
+	if action=(value_get)
+        return pixbuf
+	endif
+	if action=(value_unset)
+        call capture_free_more_stuff(cairo_flag,cairo,surface,mem,pixbuf)
+        sd t
+        setcall t capture_terminal((value_get))
+        if t=1
+            call capture_alternative_free()
+            call capture_terminal((value_set),0)
+        endif
+	else
+    #if action==(value_append)
+        if cairo_flag=1
+            #use cairo
+            call capture_get_cairo_pixbuf(x,y,pix_width,pix_height,cursor_flag,cairo,surface)
+        else
+            call capture_alternative_append(x,y,pix_width,pix_height,cursor_flag)
+        endelse
+        sd raw_flag
+        setcall raw_flag capture_raw_option((value_get))
+        if raw_flag=0
+            sd encoder
+            setcall encoder stage_file_get_mkv_encoder()
+            if encoder!=(format_mkv_rgb24)
+                #reverse bytes
+                call bytes_swap_reverse(mem,pix_width,pix_height)
+            endif
+        endif
+	endelse
+endfunction
+
+
+function capture_cursor_option(sd action,sd value)
+    sd capture_set
+    setcall capture_set capture_rect_screenshot((value_set))
+    add capture_set (cursor_flag_pointer)
+    if action=(value_set)
+        set capture_set# value
+    else
+        return capture_set#
+    endelse
+endfunction
+function capture_temp_option(sd action,sd value)
+    sd capture_set
+    setcall capture_set capture_rect_screenshot((value_set))
+    add capture_set (cursor_temp_pointer)
+    if action=(value_set)
+        set capture_set# value
+    else
+        return capture_set#
+    endelse
+endfunction
+function capture_raw_option(sd action,sd value)
+    sd capture_set
+    setcall capture_set capture_rect_screenshot((value_set))
+    add capture_set (cursor_raw_pointer)
+    if action=(value_set)
+        set capture_set# value
+    else
+        return capture_set#
+    endelse
+endfunction
+
+
+########temp capture
+
+function capture_temp_flag(sd action,sd value)
+    data temp_flag#1
+    if action=(value_set)
+        set temp_flag value
+    else
+        return temp_flag
+    endelse
+endfunction
+
+function capture_direct(sd action)
+    data temp_viewed#1
+    if action=(value_set)
+        set temp_viewed 0
+        call capture_temp_flag((value_set),0)
+    else
+    #bool
+    #value_run
+        if temp_viewed=1
+            return 1
+        endif
+        set temp_viewed 1
+
+        sd direct_way
+        setcall direct_way capture_temp_option((value_get))
+        if direct_way=0
+            setcall direct_way capture_raw_option((value_get))
+        endif
+        if direct_way=0
+            return 1
+        endif
+
+        import "av_dialog_run" av_dialog_run
+        data forward^capture_direct_start
+        sd bool
+        setcall bool av_dialog_run(forward,0)
+
+        #temp flag
+        #before dialog run no;after dialog run for capture_take_screenshot
+        call capture_temp_flag((value_set),1)
+
+        return bool
+    endelse
+endfunction
+
+function capture_temp_file(sd action,sd value)
+    data temp_file#1
+    if action=(value_set)
+        set temp_file value
+    else
+        return temp_file
+    endelse
+endfunction
+function capture_direct_frames(sd action,sd value)
+    data temp_frames#1
+    if action=(value_set)
+        set temp_frames value
+    elseif action=(value_append)
+        inc temp_frames
+    else
+        #if action==(value_get)
+        return temp_frames
+    endelse
+endfunction
+
+function capture_get_xy(sd p_xy)
+    sd rect
+    setcall rect capture_rect_screenshot((value_init))
+    set p_xy# rect#
+    add p_xy 4
+    set p_xy# rect#
+endfunction
+
+function capture_get_width_height(sd wh)
+    sd rect
+    setcall rect capture_rect_screenshot((value_init))
+    add rect 8
+    set wh# rect#
+    add wh 4
+    add rect 4
+    set wh# rect#
+endfunction
+
+#bool
+function capture_direct_start(sd *data)
+    #init captured frames counter
+    call capture_direct_frames((value_set),0)
+
+    ss format
+    ss method
+    sd raw_flag
+    setcall raw_flag capture_raw_option((value_get))
+    if raw_flag=0
+#these formats are related to format_max
+        ss temp_format="temp"
+        ss temp_method="w+Db"
+        set format temp_format
+        set method temp_method
+    else
+        ss raw_method="wb"
+        setcall format capture_raw_extension()
+        set method raw_method
+    endelse
+    import "save_destination" save_destination
+    sd output_file
+    setcall output_file save_destination(format)
+
+    sd bool
+    setcall bool capture_direct_run(output_file,method)
+
+    if raw_flag=1
+    #here all raw files will be processed
+        call capture_raw_files(output_file)
+        set bool 0
+    endif
+
+    import "av_dialog_close" av_dialog_close
+    call av_dialog_close()
+    return bool
+endfunction
+
+function capture_raw_extension()
+#these formats are related to format_max
+    str raw_format="raw"
+    return raw_format
+endfunction
+
+#bool
+function capture_direct_run(sd output_file,sd method)
+    sd file
+    sd er
+    #open file
+    import "openfile" openfile
+    sd p_file^file
+    setcall er openfile(p_file,output_file,method)
+    if er!=(noerror)
+        return 0
+    endif
+    call capture_temp_file((value_set),file)
+
+    #get rect size
+    sd width
+    sd height
+    sd p_wh^width
+    call capture_get_width_height(p_wh)
+    import "rgb_get_size" rgb_get_size
+    sd rgb_rect_size
+    setcall rgb_rect_size rgb_get_size(width,height)
+    #draw a text
+    import "dialog_modal_texter_draw" dialog_modal_texter_draw
+    call dialog_modal_texter_draw("Recording..")
+    #loop the screenshots
+    whiletrue
+        #take screenshot
+        sd pixbuf
+        setcall pixbuf capture_obtain_screenshot()
+        if pixbuf=0
+            return 0
+        endif
+        #write screenshot
+        importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+        sd bytes
+        setcall bytes gdk_pixbuf_get_pixels(pixbuf)
+        setcall er file_write(bytes,rgb_rect_size,file)
+        if er!=(noerror)
+            return 0
+        endif
+        #take and write frame length
+        sd frames_rise
+        sd p_frames_rise^frames_rise
+        setcall frames_rise capture_time((value_get))
+        setcall er file_write(p_frames_rise,4,file)
+        if er!=(noerror)
+            return 0
+        endif
+        #count the screenshots
+        call capture_direct_frames((value_append))
+        #see if stop pressed
+        import "av_dialog_stop" av_dialog_stop
+        sd stop
+        setcall stop av_dialog_stop((value_get))
+        if stop=1
+            #seek at the start for reading
+            import "file_seek_set" file_seek_set
+            setcall er file_seek_set(file,0)
+            if er!=(noerror)
+                return 0
+            endif
+            return 1
+        endif
+    endwhile
+endfunction
+
+function capture_read_temp_screenshot(sd width,sd height)
+    sd pixbuf
+    setcall pixbuf capture_pixbuf((value_get))
+
+    sd bytes
+    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
+
+    sd size
+    setcall size rgb_get_size(width,height)
+
+    sd temp_file
+    setcall temp_file capture_temp_file((value_get))
+
+    import "file_read" file_read
+    call file_read(bytes,size,temp_file)
+endfunction
+
+
+
+
+
+
+########
+
+import "draw_default_cursor" draw_default_cursor
+
+function capture_get_cairo_pixbuf(sd x,sd y,sd wdt,sd hgt,sd cursor_flag,sd cairo,sd surface)
+    importx "_cairo_paint" cairo_paint
+    call cairo_paint(cairo)
+
+    if cursor_flag=1
+        sd root
+        setcall root gdk_get_default_root_window()
+        call draw_default_cursor(root,x,y,wdt,hgt,cairo)
+    endif
+
+    import "surface_to_pixbufdata" surface_to_pixbufdata
+    sd pixbuf
+    setcall pixbuf capture_pixbuf((value_get))
+    call surface_to_pixbufdata(surface,pixbuf)
+endfunction
+
+
+##file options
+function capture_get_data(sd mem,sd *size)
+    import "get_mem_int_advance" get_mem_int_advance
+    sd mem_sz^mem
+    sd err
+    sd value
+    sd p_value^value
+    sd dest
+
+    import "get_str_advance" get_str_advance
+    setcall dest capture_left_string()
+    setcall err get_str_advance(dest,(dword_null),mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    setcall dest capture_top_string()
+    setcall err get_str_advance(dest,(dword_null),mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    setcall dest capture_width_string()
+    setcall err get_str_advance(dest,(dword_null),mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    setcall dest capture_height_string()
+    setcall err get_str_advance(dest,(dword_null),mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    setcall dest capture_size_string()
+    setcall err get_str_advance(dest,(dword_null),mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+
+    setcall err get_mem_int_advance(p_value,mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    call capture_cursor_option((value_set),value)
+
+    setcall err get_mem_int_advance(p_value,mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    call capture_temp_option((value_set),value)
+
+    setcall err get_mem_int_advance(p_value,mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    call capture_raw_option((value_set),value)
+endfunction
+
+
+##raw files
+
+const raw_width_height_off=0
+const raw_nr_of_frames_off=raw_width_height_off+8
+const raw_frames_per_file_off=raw_nr_of_frames_off+4
+const raw_files_off=raw_frames_per_file_off+4
+
+const raw_size=raw_files_off+4
+
+const raw_get_value=value_extra
+
+function raw_structure(sd action,sd value)
+    data structure#1
+    if action=(value_set)
+        set structure value
+    elseif action=(value_get)
+        return structure
+    else
+        sd member
+        set member structure
+        add member value
+        return member#
+    endelse
+endfunction
+
+#write
+
+function capture_raw_files(sd output_file)
+    data width#1
+    data height#1
+    data nr_of_frames#1
+    data frames_per_file#1
+    data files#1
+
+    sd struct^width
+    call raw_structure((value_set),struct)
+
+    call capture_get_width_height(struct)
+
+    sd maxsize
+    setcall maxsize capture_split((split_maxsize_value))
+    sd frame_size
+    setcall frame_size rgb_get_size(width,height)
+    #add the frame length storage space
+    add frame_size 4
+    set frames_per_file maxsize
+    div frames_per_file frame_size
+    if frames_per_file=0
+        set frames_per_file 1
+    endif
+
+    set files 0
+
+    sd all_frames
+    setcall all_frames capture_direct_frames((value_get))
+    while all_frames!=0
+        if all_frames<=frames_per_file
+            set nr_of_frames all_frames
+            set all_frames 0
+        else
+            set nr_of_frames frames_per_file
+            sub all_frames frames_per_file
+        endelse
+
+        importx "_sprintf" sprintf
+        char outfile_data#100
+        str outfile^outfile_data
+        str outformat="%s.%u"
+        call sprintf(outfile,outformat,output_file,files)
+        import "file_write_forward" file_write_forward
+        data forward_raw^capture_raw_writeOnFile
+        call file_write_forward(outfile,forward_raw)
+
+        inc files
+    endwhile
+endfunction
+
+function capture_raw_writeOnFile(sd file)
+    sd struct
+    setcall struct raw_structure((value_get))
+    call file_write(struct,(raw_size),file)
+endfunction
+
+#read
+
+function capture_raw_read(ss filepath)
+    #values init
+    import "stage_read_values" stage_read_values
+    sd bool
+    setcall bool stage_read_values((value_set))
+    if bool!=1
+        return 0
+    endif
+
+    data f^capture_raw_read_start
+    call av_dialog_run(f,filepath)
+
+    #values write and free
+    call stage_read_values((value_write))
+    call stage_read_values((value_unset))
+endfunction
+
+function capture_raw_read_start(ss filepath)
+    import "file_forward_read" file_forward_read
+    data f_raw^capture_raw_read_file
+    call file_forward_read(filepath,f_raw)
+    call av_dialog_close()
+endfunction
+
+function capture_raw_read_file(sd file,sd path)
+    data struct_data#raw_size
+    data struct^struct_data
+    sd err
+    setcall err file_read(struct,(raw_size),file)
+    if err!=(noerror)
+        return 0
+    endif
+    call raw_structure((value_set),struct)
+
+    import "valinmemsens" valinmemsens
+    import "slen" slen
+    sd sz
+    setcall sz slen(path)
+    ss filepath
+    set filepath path
+    add filepath sz
+    char delim="."
+    setcall sz valinmemsens(filepath,sz,delim) #,(BACKWARD)
+    sub filepath sz
+    set filepath# 0
+
+    data f_raw^capture_raw_read_filedata
+    call file_forward_read(path,f_raw)
+endfunction
+
+function capture_raw_read_filedata(sd file)
+    sd width
+    sd height
+    sd frames_per_file
+    sd files_before
+    setcall width raw_structure((raw_get_value),(raw_width_height_off))
+    setcall height raw_structure((raw_get_value),(raw_width_height_off+4))
+    setcall frames_per_file raw_structure((raw_get_value),(raw_frames_per_file_off))
+    setcall files_before raw_structure((raw_get_value),(raw_files_off))
+
+    sd size
+    sd rgb_size
+    setcall size rgb_get_size(width,height)
+    set rgb_size size
+    add size 4
+    mult size frames_per_file
+
+    sd er
+    sd i=0
+    while i!=files_before
+        import "file_seek_dif_cursor" file_seek_dif_cursor
+        setcall er file_seek_dif_cursor(file,size)
+        if er!=(noerror)
+            return 0
+        endif
+        inc i
+    endwhile
+
+    sd nr_of_frames
+    setcall nr_of_frames raw_structure((raw_get_value),(raw_nr_of_frames_off))
+    set i 0
+
+    import "rgb_get_rowstride" rgb_get_rowstride
+    sd pixbuf
+    sd length
+    sd entry^pixbuf
+    sd p_length^length
+    sd rowstride
+    setcall rowstride rgb_get_rowstride(width)
+
+    while i!=nr_of_frames
+        sd stop
+        setcall stop av_dialog_stop((value_get))
+        if stop=1
+            return 0
+        endif
+
+        sd mem
+        setcall mem memalloc(rgb_size)
+        if mem=0
+            return 0
+        endif
+
+        setcall er file_read(mem,rgb_size,file)
+        if er!=(noerror)
+            return 0
+        endif
+        call bytes_swap_reverse(mem,width,height)
+        data free_mem^free
+        setcall pixbuf gdk_pixbuf_new_from_data(mem,(GDK_COLORSPACE_RGB),(FALSE),8,width,height,rowstride,free_mem,mem)
+
+        setcall er file_read(p_length,4,file)
+        if er!=(noerror)
+            return 0
+        endif
+
+        sd bool
+        setcall bool stage_read_values((value_append),entry,8)
+        if bool!=1
+            return 0
+        endif
+
+        #info display
+        import "av_display_info" av_display_info
+        call av_display_info((value_write),0,-1,rgb_size)
+
+        inc i
+    endwhile
+endfunction
--- ovideo-1.orig/src/_capture/capture.s
+++ /dev/null
@@ -1,1292 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-
-const left_coord=0
-const top_coord=1
-const width_coord=2
-const height_coord=3
-const capture_cursor=4
-const capture_temporary=5
-const capture_raw=6
-
-const value_setrect=value_custom
-
-function capture()
-    import "dialogfield" dialogfield
-    sd init^capture_init
-    sd set^capture_start
-    ss title="Capture"
-    call dialogfield(title,(GTK_DIALOG_MODAL),init,set)
-endfunction
-
-import "capture_alternative_init" capture_alternative_init
-import "capture_alternative_set" capture_alternative_set
-import "capture_alternative_prepare" capture_alternative_prepare
-import "capture_alternative_append" capture_alternative_append
-import "capture_alternative_free" capture_alternative_free
-
-function capture_init(sd vbox,sd *dialog)
-    import "labelfield_l" labelfield_l
-    ss text="Desktop Crop"
-    call labelfield_l(text,vbox)
-    import "tablefield_cells" tablefield_cells
-    import "labelfield_left_prepare" labelfield_left_prepare
-    importx "_gtk_entry_new" gtk_entry_new
-    sd left_text
-    sd left_entry
-    sd top_text
-    sd top_entry
-    sd width_text
-    sd width_entry
-    sd height_text
-    sd height_entry
-    sd size_text
-    sd size_entry
-    sd string
-
-    importx "_gtk_entry_set_text" gtk_entry_set_text
-    ss l="Left"
-    ss t="Top"
-    ss w="Width"
-    ss h="Height"
-    ss sz="File split size(bytes)"
-    #rect
-    setcall left_text labelfield_left_prepare(l)
-    setcall left_entry gtk_entry_new()
-    setcall string capture_left_string()
-    call gtk_entry_set_text(left_entry,string)
-    #
-    setcall top_text labelfield_left_prepare(t)
-    setcall top_entry gtk_entry_new()
-    setcall string capture_top_string()
-    call gtk_entry_set_text(top_entry,string)
-    #
-    setcall width_text labelfield_left_prepare(w)
-    setcall width_entry gtk_entry_new()
-    setcall string capture_width_string()
-    call gtk_entry_set_text(width_entry,string)
-    #
-    setcall height_text labelfield_left_prepare(h)
-    setcall height_entry gtk_entry_new()
-    setcall string capture_height_string()
-    call gtk_entry_set_text(height_entry,string)
-    #size limit
-    setcall size_text labelfield_left_prepare(sz)
-    setcall size_entry gtk_entry_new()
-    setcall string capture_size_string()
-    call gtk_entry_set_text(size_entry,string)
-    #set the values
-    sd cells^left_text
-    call tablefield_cells(vbox,5,2,cells)
-    call capture_rect((value_set),(left_coord),left_entry)
-    call capture_rect((value_set),(top_coord),top_entry)
-    call capture_rect((value_set),(width_coord),width_entry)
-    call capture_rect((value_set),(height_coord),height_entry)
-    call capture_split((value_set),size_entry)
-
-    importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
-    import "packstart_default" packstart_default
-
-    #cursor
-    importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
-    ss txt="Capture the cursor"
-    sd cursor
-    setcall cursor gtk_check_button_new_with_label(txt)
-    sd cursor_flag
-    setcall cursor_flag capture_cursor_option((value_get))
-    call gtk_toggle_button_set_active(cursor,cursor_flag)
-    call packstart_default(vbox,cursor)
-    call capture_rect((value_set),(capture_cursor),cursor)
-
-    #temp file
-    ss temp_txt="Temporary file first"
-    sd temp
-    setcall temp gtk_check_button_new_with_label(temp_txt)
-    importx "_gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
-    ss temp_info="Ignored if Raw file(s) selected"
-    call gtk_widget_set_tooltip_markup(temp,temp_info)
-    sd temp_flag
-    setcall temp_flag capture_temp_option((value_get))
-    call gtk_toggle_button_set_active(temp,temp_flag)
-    call packstart_default(vbox,temp)
-    call capture_rect((value_set),(capture_temporary),temp)
-    call capture_direct((value_set))
-
-    #raw file
-    ss raw_info="Raw file(s)"
-    sd raw
-    setcall raw gtk_check_button_new_with_label(raw_info)
-    call packstart_default(vbox,raw)
-    sd raw_flag
-    setcall raw_flag capture_raw_option((value_get))
-    call gtk_toggle_button_set_active(raw,raw_flag)
-    call capture_rect((value_set),(capture_raw),raw)
-
-    #alternative
-    call capture_alternative_init(vbox)
-endfunction
-
-importx "_g_object_unref" g_object_unref
-
-function capture_start()
-    #set capture rect, can return if arguments are not right
-    sd bool
-    setcall bool capture_rect((value_setrect))
-    if bool!=1
-        return 0
-    endif
-
-    #verify for output format
-    setcall bool capture_format()
-    if bool!=1
-        return 0
-    endif
-
-    #init max allowed
-    call capture_split((value_write))
-    #call the loop
-    call capture_files_loop((value_run))
-endfunction
-
-#bool
-function capture_format()
-    sd raw_flag
-    setcall raw_flag capture_raw_option((value_get))
-    if raw_flag==1
-        return 1
-    endif
-    import "stage_file_options_output" stage_file_options_output
-    sd output
-    setcall output stage_file_options_output()
-    sd capture_bool=1
-    if output<(format_mkv)
-        set capture_bool 0
-    else
-        if output>(format_mkv_last)
-            set capture_bool 0
-        else
-            import "stage_file_get_mkv_encoder" stage_file_get_mkv_encoder
-            sd encoder
-            setcall encoder stage_file_get_mkv_encoder()
-            if encoder!=(format_mkv_i420)
-                if encoder!=(format_mkv_mjpg)
-                    if encoder!=(format_mkv_rgb24)
-                        set capture_bool 0
-                    endif
-                endif
-            endif
-        endelse
-    endelse
-    if capture_bool==0
-        import "message_dialog" message_dialog
-        str txt="Capture with MKV(I420,MJPEG,RGB24) selected at Stage Options"
-        call message_dialog(txt)
-        return 0
-    endif
-    return 1
-endfunction
-
-function capture_files_loop(sd action)
-    data loop#1
-    if action==(value_set)
-        set loop 1
-    else
-        set loop 1
-
-        sd bool
-        setcall bool capture_pixbuf((value_set))
-        if bool!=1
-            return 0
-        endif
-
-        #tempfile
-        call capture_temp_file((value_set),0)
-
-        #don't display the result message inter-files
-        import "stage_file_options_info_message" stage_file_options_info_message
-        sd info
-        setcall info stage_file_options_info_message((value_get))
-        call stage_file_options_info_message((value_set),0)
-
-        #file index
-        sd file_index=0
-
-        #get the time and start the loop files
-        call capture_time((value_set))
-        while loop==1
-            #loop 1 can be if max size detected
-            set loop 0
-
-            # can be temp/raw
-            setcall bool capture_direct((value_run))
-            if bool==1
-            #mkv
-                import "mkvfile" mkvfile
-                call mkvfile((capture_flag_on),file_index)
-            endif
-
-            #next file index
-            inc file_index
-        endwhile
-        #restore info message
-        call stage_file_options_info_message((value_set),info)
-
-        sd temp_file
-        setcall temp_file capture_temp_file((value_get))
-        if temp_file!=0
-            importx "_fclose" fclose
-            call fclose(temp_file)
-        endif
-
-        call capture_pixbuf((value_unset))
-    endelse
-endfunction
-
-import "entry_to_int_min_N_max_M" entry_to_int_min_N_max_M
-
-const max_file_size=0x3fFFffFF
-
-const split_maxsize_value=value_custom
-
-function capture_split(sd action,sd value)
-    data split_entry#1
-    data maxsize#1
-
-    data p_maxsize^maxsize
-    if action==(value_set)
-        set split_entry value
-    elseif action==(value_get)
-        return split_entry
-    elseif action==(value_write)
-        sd bool
-        setcall bool entry_to_int_min_N_max_M(split_entry,p_maxsize,1,(max_file_size))
-        if bool!=1
-            set maxsize (max_file_size)
-        endif
-    elseif action==(split_maxsize_value)
-        return maxsize
-    else
-    #bool: 0 stop, 1 continue
-        #if action==(value_get)
-        #value is file
-        import "file_tell" file_tell
-        sd pos
-        sd p_pos^pos
-        sd err
-
-        setcall err file_tell(value,p_pos)
-        if err!=(noerror)
-            return 0
-        endif
-        if pos>=maxsize
-            call capture_files_loop((value_set))
-            return 0
-        endif
-        return 1
-    endelse
-endfunction
-
-importx "_gdk_get_default_root_window" gdk_get_default_root_window
-import "sleepMs" sleepMs
-import "texter" texter
-
-const value_init=0
-const value_screenshot=1
-
-function capture_rect(sd action,sd index,sd value)
-    #widgets
-    data left#1
-    data top#1
-    data width#1
-    data height#1
-    data cursor#1
-    data temporary#1
-    data raw#1
-
-    if action==(value_set)
-        if index==(left_coord)
-            set left value
-        elseif index==(top_coord)
-            set top value
-        elseif index==(width_coord)
-            set width value
-        elseif index==(height_coord)
-            set height value
-        elseif index==(capture_cursor)
-            set cursor value
-        elseif index==(capture_temporary)
-            set temporary value
-        else
-        #if index==(capture_raw)
-            set raw value
-        endelse
-    elseif action==(value_get)
-        return #left
-    else
-    #if action==(value_setrect)
-    #bool
-        importx "_gdk_drawable_get_size" gdk_drawable_get_size
-        sd root
-        setcall root gdk_get_default_root_window()
-        sd maxwidth
-        sd maxheight
-        sd p_maxwidth^maxwidth
-        sd p_maxheight^maxheight
-        call gdk_drawable_get_size(root,p_maxwidth,p_maxheight)
-
-        sd left_val
-        sd top_val
-        sd values
-        sd M
-        sd bool
-
-        #x
-        set M maxwidth
-        dec M
-        setcall values capture_rect_screenshot((value_init))
-        setcall bool entry_to_int_min_N_max_M(left,values,0,M)
-        if bool!=1
-            return 0
-        endif
-        set left_val values#
-        #y
-        set M maxheight
-        dec M
-        add values 4
-        setcall bool entry_to_int_min_N_max_M(top,values,0,M)
-        if bool!=1
-            return 0
-        endif
-        set top_val values#
-        #w
-        set M maxwidth
-        sub M left_val
-        add values 4
-        setcall bool entry_to_int_min_N_max_M(width,values,1,M)
-        if bool!=1
-            return 0
-        endif
-            #multiple of 4 for unstrided rgb24 cases
-        sd dworded
-        set dworded values#
-        and dworded 0x3
-        if dworded!=0
-            str dw_er="The Width must be a multiple of 4"
-            call texter(dw_er)
-            return 0
-        endif
-        #h
-        set M maxheight
-        sub M top_val
-        add values 4
-        setcall bool entry_to_int_min_N_max_M(height,values,1,M)
-        if bool!=1
-            return 0
-        endif
-        #cursor
-        importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
-        add values 4
-        setcall values# gtk_toggle_button_get_active(cursor)
-        #temporary
-        add values 4
-        setcall values# gtk_toggle_button_get_active(temporary)
-        #raw
-        add values 4
-        setcall values# gtk_toggle_button_get_active(raw)
-
-        import "file_write_forward_sys_folder_enter_leave" file_write_forward_sys_folder_enter_leave
-        data forw_capture^capture_settings_set_write
-        import "capture_file" capture_file
-        ss capture_fl_str
-        setcall capture_fl_str capture_file()
-        call file_write_forward_sys_folder_enter_leave(capture_fl_str,forw_capture)
-
-        return 1
-    endelse
-endfunction
-
-import "file_write" file_write
-
-function capture_left_string()
-    char c#dword_null
-    return #c
-endfunction
-function capture_top_string()
-    char c#dword_null
-    return #c
-endfunction
-function capture_width_string()
-    char c#dword_null
-    return #c
-endfunction
-function capture_height_string()
-    char c#dword_null
-    return #c
-endfunction
-function capture_size_string()
-    char c#dword_null
-    return #c
-endfunction
-import "file_write_string" file_write_string
-function capture_settings_set_write(sd capture_fl)
-    sd value
-    sd p_value^value
-    sd err
-    sd entries
-    sd bool
-    sd string
-    setcall entries capture_rect((value_get))
-    importx "_gtk_entry_get_text" gtk_entry_get_text
-
-    setcall string gtk_entry_get_text(entries#)
-    setcall bool file_write_string(string,capture_fl)
-    if bool!=1
-        return (void)
-    endif
-    add entries (DWORD)
-    #
-    setcall string gtk_entry_get_text(entries#)
-    setcall bool file_write_string(string,capture_fl)
-    if bool!=1
-        return (void)
-    endif
-    add entries (DWORD)
-    #
-    setcall string gtk_entry_get_text(entries#)
-    setcall bool file_write_string(string,capture_fl)
-    if bool!=1
-        return (void)
-    endif
-    add entries (DWORD)
-    #
-    setcall string gtk_entry_get_text(entries#)
-    setcall bool file_write_string(string,capture_fl)
-    if bool!=1
-        return (void)
-    endif
-    add entries (DWORD)
-    #
-    setcall entries capture_split((value_get))
-    setcall string gtk_entry_get_text(entries)
-    setcall bool file_write_string(string,capture_fl)
-    if bool!=1
-        return (void)
-    endif
-
-    setcall value capture_cursor_option((value_get))
-    setcall err file_write(p_value,4,capture_fl)
-    if err!=(noerror)
-        return (void)
-    endif
-    setcall value capture_temp_option((value_get))
-    setcall err file_write(p_value,4,capture_fl)
-    if err!=(noerror)
-        return (void)
-    endif
-    setcall value capture_raw_option((value_get))
-    setcall err file_write(p_value,4,capture_fl)
-    if err!=(noerror)
-        return (void)
-    endif
-endfunction
-
-function capture_time(sd action)
-    import "get_time" get_time
-    #start capture time
-    data starttime#1
-    #total frames captured
-    data totalframes#1
-    #time increment decided by fps
-    data timeincrement#1
-
-    import "stage_file_options_fps" stage_file_options_fps
-    sd fps
-    setcall fps stage_file_options_fps()
-    if action==(value_set)
-        setcall starttime get_time()
-        set totalframes 0
-        set timeincrement 1000
-        div timeincrement fps
-    else
-    #frame length return
-        #sleep time increment
-        call sleepMs(timeincrement)
-        #get correct time position
-        sd seconds
-        set seconds totalframes
-        div seconds fps
-        mult seconds 1000
-
-        import "rest" rest
-        sd nth_sec
-        setcall nth_sec rest(totalframes,fps)
-        mult nth_sec timeincrement
-
-        sd time
-        set time starttime
-        add time seconds
-        add time nth_sec
-
-        #get new time
-        sd newtime
-        setcall newtime get_time()
-        sub newtime time
-
-        #convert it to frames
-        import "get_higher" get_higher
-        sd newframes
-        div newtime timeincrement
-        setcall newframes get_higher(1,newtime)
-
-        #add new length to total frames
-        add totalframes newframes
-
-        return newframes
-    endelse
-endfunction
-
-function capture_obtain_screenshot()
-    call capture_rect_screenshot((value_screenshot))
-    sd pixbuf
-    setcall pixbuf capture_pixbuf((value_get))
-    return pixbuf
-endfunction
-
-const CAIRO_FORMAT_RGB24=1
-
-const sizeofrect=4*4
-const cursor_flag_pointer=sizeofrect
-const cursor_temp_pointer=cursor_flag_pointer+4
-const cursor_raw_pointer=cursor_temp_pointer+4
-
-function capture_rect_screenshot(sd action)
-    data x#1
-    data y#1
-    data wdt#1
-    data hgt#1
-    data cursor_option#1
-    data *temp_option#1
-    data *raw_option#1
-
-    data values_rect^x
-    if action==(value_init)
-    #get the pointer
-        return values_rect
-    else
-    #if action==(value_screenshot)
-        sd temporary_flag
-        setcall temporary_flag capture_temp_flag((value_get))
-        if temporary_flag==0
-        #live screenshot
-            call capture_pixbuf((value_append),x,y,wdt,hgt,cursor_option)
-        else
-        #screenshot from temp file
-            call capture_read_temp_screenshot(wdt,hgt)
-        endelse
-    endelse
-endfunction
-
-importx "_cairo_destroy" cairo_destroy
-importx "_cairo_surface_destroy" cairo_surface_destroy
-function capture_free_cairo(sd cairo,sd surface)
-    call cairo_destroy(cairo)
-    call cairo_surface_destroy(surface)
-endfunction
-
-import "memalloc" memalloc
-importx "_free" free
-
-function capture_free_cairo_and_mem(sd cairo,sd surface,sd mem)
-    call capture_free_cairo(cairo,surface)
-    call free(mem)
-endfunction
-
-function capture_terminal(sd action,sd value)
-    data terminal#1
-    if action==(value_set)
-        set terminal value
-    else
-        return terminal
-    endelse
-endfunction
-
-function capture_free_stuff(sd cairo_flag,sd cairo,sd surface,sd mem)
-    if cairo_flag==1
-        #use cairo
-        call capture_free_cairo_and_mem(cairo,surface,mem)
-    else
-        call capture_alternative_free()
-    endelse
-endfunction
-function capture_free_more_stuff(sd cairo_flag,sd cairo,sd surface,sd mem,sd pixbuf)
-    call capture_free_stuff(cairo_flag,cairo,surface,mem)
-    call g_object_unref(pixbuf)
-endfunction
-
-import "bytes_swap_reverse" bytes_swap_reverse
-
-function capture_pixbuf(sd action,sd x,sd y,sd pix_width,sd pix_height,sd cursor_flag)
-    data pixbuf#1
-    data mem#1
-    data cairo_flag#1
-
-    data cairo#1
-    data surface#1
-
-    if action==(value_set)
-    #bool
-        sd bool
-        #init capture mem
-        import "rgb_get_all_sizes" rgb_get_all_sizes
-        sd width
-        sd height
-        sd wh^width
-        call capture_get_width_height(wh)
-        sd rowstr
-        sd p_rowstr^rowstr
-        sd sz
-        setcall sz rgb_get_all_sizes(width,height,p_rowstr)
-        sd term=0
-        sd p_term^term
-        set cairo_flag 1
-        sd p_flag^cairo_flag
-        call capture_alternative_set(p_flag,p_term)
-        if cairo_flag==1
-        #cairo is default
-            #cairo surface and cairo context
-            sd root
-            setcall root gdk_get_default_root_window()
-            importx "_cairo_image_surface_create" cairo_image_surface_create
-            setcall surface cairo_image_surface_create((CAIRO_FORMAT_RGB24),width,height)
-            if surface==0
-                str surf="Image surface error"
-                call texter(surf)
-                return 0
-            endif
-
-            importx "_cairo_create" cairo_create
-            setcall cairo cairo_create(surface)
-            sd x_value
-            sd y_value
-            sd p_xy_value^x_value
-            call capture_get_xy(p_xy_value)
-            importx "_gdk_cairo_set_source_window" gdk_cairo_set_source_window
-            sd double_x_low
-            sd double_x_high
-            sd double_y_low
-            sd double_y_high
-            sd double_x^double_x_low
-            sd double_y^double_y_low
-            import "int_to_double" int_to_double
-            sd value
-            set value x_value
-            mult value -1
-            call int_to_double(value,double_x)
-            set value y_value
-            mult value -1
-            call int_to_double(value,double_y)
-            call gdk_cairo_set_source_window(cairo,root,double_x_low,double_x_high,double_y_low,double_y_high)
-            #memory
-            setcall mem memalloc(sz)
-            if mem==0
-                call capture_free_cairo(cairo,surface)
-                return 0
-            endif
-        else
-            sd p_mem^mem
-            setcall bool capture_alternative_prepare(p_mem,width,height)
-            if bool!=1
-                return 0
-            endif
-        endelse
-        importx "_gdk_pixbuf_new_from_data" gdk_pixbuf_new_from_data
-        setcall pixbuf gdk_pixbuf_new_from_data(mem,(GDK_COLORSPACE_RGB),(FALSE),8,width,height,rowstr,0,0)
-        if pixbuf==0
-            call capture_free_stuff(cairo_flag,cairo,surface,mem)
-            return 0
-        endif
-        if term==1
-            setcall bool capture_alternative_prepare()
-            if bool!=1
-                call capture_free_more_stuff(cairo_flag,cairo,surface,mem,pixbuf)
-                return 0
-            endif
-            call capture_terminal((value_set),1)
-        endif
-        return 1
-    elseif action==(value_get)
-        return pixbuf
-    elseif action==(value_unset)
-        call capture_free_more_stuff(cairo_flag,cairo,surface,mem,pixbuf)
-        sd t
-        setcall t capture_terminal((value_get))
-        if t==1
-            call capture_alternative_free()
-            call capture_terminal((value_set),0)
-        endif
-    else
-    #if action==(value_append)
-        if cairo_flag==1
-            #use cairo
-            call capture_get_cairo_pixbuf(x,y,pix_width,pix_height,cursor_flag,cairo,surface)
-        else
-            call capture_alternative_append(x,y,pix_width,pix_height,cursor_flag)
-        endelse
-        sd raw_flag
-        setcall raw_flag capture_raw_option((value_get))
-        if raw_flag==0
-            sd encoder
-            setcall encoder stage_file_get_mkv_encoder()
-            if encoder!=(format_mkv_rgb24)
-                #reverse bytes
-                call bytes_swap_reverse(mem,pix_width,pix_height)
-            endif
-        endif
-    endelse
-endfunction
-
-
-function capture_cursor_option(sd action,sd value)
-    sd capture_set
-    setcall capture_set capture_rect_screenshot((value_set))
-    add capture_set (cursor_flag_pointer)
-    if action==(value_set)
-        set capture_set# value
-    else
-        return capture_set#
-    endelse
-endfunction
-function capture_temp_option(sd action,sd value)
-    sd capture_set
-    setcall capture_set capture_rect_screenshot((value_set))
-    add capture_set (cursor_temp_pointer)
-    if action==(value_set)
-        set capture_set# value
-    else
-        return capture_set#
-    endelse
-endfunction
-function capture_raw_option(sd action,sd value)
-    sd capture_set
-    setcall capture_set capture_rect_screenshot((value_set))
-    add capture_set (cursor_raw_pointer)
-    if action==(value_set)
-        set capture_set# value
-    else
-        return capture_set#
-    endelse
-endfunction
-
-
-########temp capture
-
-function capture_temp_flag(sd action,sd value)
-    data temp_flag#1
-    if action==(value_set)
-        set temp_flag value
-    else
-        return temp_flag
-    endelse
-endfunction
-
-function capture_direct(sd action)
-    data temp_viewed#1
-    if action==(value_set)
-        set temp_viewed 0
-        call capture_temp_flag((value_set),0)
-    else
-    #bool
-    #value_run
-        if temp_viewed==1
-            return 1
-        endif
-        set temp_viewed 1
-
-        sd direct_way
-        setcall direct_way capture_temp_option((value_get))
-        if direct_way==0
-            setcall direct_way capture_raw_option((value_get))
-        endif
-        if direct_way==0
-            return 1
-        endif
-
-        import "av_dialog_run" av_dialog_run
-        data forward^capture_direct_start
-        sd bool
-        setcall bool av_dialog_run(forward,0)
-
-        #temp flag
-        #before dialog run no;after dialog run for capture_take_screenshot
-        call capture_temp_flag((value_set),1)
-
-        return bool
-    endelse
-endfunction
-
-function capture_temp_file(sd action,sd value)
-    data temp_file#1
-    if action==(value_set)
-        set temp_file value
-    else
-        return temp_file
-    endelse
-endfunction
-function capture_direct_frames(sd action,sd value)
-    data temp_frames#1
-    if action==(value_set)
-        set temp_frames value
-    elseif action==(value_append)
-        inc temp_frames
-    else
-        #if action==(value_get)
-        return temp_frames
-    endelse
-endfunction
-
-function capture_get_xy(sd p_xy)
-    sd rect
-    setcall rect capture_rect_screenshot((value_init))
-    set p_xy# rect#
-    add p_xy 4
-    set p_xy# rect#
-endfunction
-
-function capture_get_width_height(sd wh)
-    sd rect
-    setcall rect capture_rect_screenshot((value_init))
-    add rect 8
-    set wh# rect#
-    add wh 4
-    add rect 4
-    set wh# rect#
-endfunction
-
-#bool
-function capture_direct_start(sd *data)
-    #init captured frames counter
-    call capture_direct_frames((value_set),0)
-
-    ss format
-    ss method
-    sd raw_flag
-    setcall raw_flag capture_raw_option((value_get))
-    if raw_flag==0
-#these formats are related to format_max
-        ss temp_format="temp"
-        ss temp_method="w+Db"
-        set format temp_format
-        set method temp_method
-    else
-        ss raw_method="wb"
-        setcall format capture_raw_extension()
-        set method raw_method
-    endelse
-    import "save_destination" save_destination
-    sd output_file
-    setcall output_file save_destination(format)
-
-    sd bool
-    setcall bool capture_direct_run(output_file,method)
-
-    if raw_flag==1
-    #here all raw files will be processed
-        call capture_raw_files(output_file)
-        set bool 0
-    endif
-
-    import "av_dialog_close" av_dialog_close
-    call av_dialog_close()
-    return bool
-endfunction
-
-function capture_raw_extension()
-#these formats are related to format_max
-    str raw_format="raw"
-    return raw_format
-endfunction
-
-#bool
-function capture_direct_run(sd output_file,sd method)
-    sd file
-    sd er
-    #open file
-    import "openfile" openfile
-    sd p_file^file
-    setcall er openfile(p_file,output_file,method)
-    if er!=(noerror)
-        return 0
-    endif
-    call capture_temp_file((value_set),file)
-
-    #get rect size
-    sd width
-    sd height
-    sd p_wh^width
-    call capture_get_width_height(p_wh)
-    import "rgb_get_size" rgb_get_size
-    sd rgb_rect_size
-    setcall rgb_rect_size rgb_get_size(width,height)
-    #draw a text
-    import "dialog_modal_texter_draw" dialog_modal_texter_draw
-    call dialog_modal_texter_draw("Recording..")
-    #loop the screenshots
-    while 1==1
-        #take screenshot
-        sd pixbuf
-        setcall pixbuf capture_obtain_screenshot()
-        if pixbuf==0
-            return 0
-        endif
-        #write screenshot
-        importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-        sd bytes
-        setcall bytes gdk_pixbuf_get_pixels(pixbuf)
-        setcall er file_write(bytes,rgb_rect_size,file)
-        if er!=(noerror)
-            return 0
-        endif
-        #take and write frame length
-        sd frames_rise
-        sd p_frames_rise^frames_rise
-        setcall frames_rise capture_time((value_get))
-        setcall er file_write(p_frames_rise,4,file)
-        if er!=(noerror)
-            return 0
-        endif
-        #count the screenshots
-        call capture_direct_frames((value_append))
-        #see if stop pressed
-        import "av_dialog_stop" av_dialog_stop
-        sd stop
-        setcall stop av_dialog_stop((value_get))
-        if stop==1
-            #seek at the start for reading
-            import "file_seek_set" file_seek_set
-            setcall er file_seek_set(file,0)
-            if er!=(noerror)
-                return 0
-            endif
-            return 1
-        endif
-    endwhile
-endfunction
-
-function capture_read_temp_screenshot(sd width,sd height)
-    sd pixbuf
-    setcall pixbuf capture_pixbuf((value_get))
-
-    sd bytes
-    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
-
-    sd size
-    setcall size rgb_get_size(width,height)
-
-    sd temp_file
-    setcall temp_file capture_temp_file((value_get))
-
-    import "file_read" file_read
-    call file_read(bytes,size,temp_file)
-endfunction
-
-
-
-
-
-
-########
-
-import "draw_default_cursor" draw_default_cursor
-
-function capture_get_cairo_pixbuf(sd x,sd y,sd wdt,sd hgt,sd cursor_flag,sd cairo,sd surface)
-    importx "_cairo_paint" cairo_paint
-    call cairo_paint(cairo)
-
-    if cursor_flag==1
-        sd root
-        setcall root gdk_get_default_root_window()
-        call draw_default_cursor(root,x,y,wdt,hgt,cairo)
-    endif
-
-    import "surface_to_pixbufdata" surface_to_pixbufdata
-    sd pixbuf
-    setcall pixbuf capture_pixbuf((value_get))
-    call surface_to_pixbufdata(surface,pixbuf)
-endfunction
-
-
-##file options
-function capture_get_data(sd mem,sd *size)
-    import "get_mem_int_advance" get_mem_int_advance
-    sd mem_sz^mem
-    sd err
-    sd value
-    sd p_value^value
-    sd dest
-
-    import "get_str_advance" get_str_advance
-    setcall dest capture_left_string()
-    setcall err get_str_advance(dest,(dword_null),mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    setcall dest capture_top_string()
-    setcall err get_str_advance(dest,(dword_null),mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    setcall dest capture_width_string()
-    setcall err get_str_advance(dest,(dword_null),mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    setcall dest capture_height_string()
-    setcall err get_str_advance(dest,(dword_null),mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    setcall dest capture_size_string()
-    setcall err get_str_advance(dest,(dword_null),mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-
-    setcall err get_mem_int_advance(p_value,mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    call capture_cursor_option((value_set),value)
-
-    setcall err get_mem_int_advance(p_value,mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    call capture_temp_option((value_set),value)
-
-    setcall err get_mem_int_advance(p_value,mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    call capture_raw_option((value_set),value)
-endfunction
-
-
-##raw files
-
-const raw_width_height_off=0
-const raw_nr_of_frames_off=raw_width_height_off+8
-const raw_frames_per_file_off=raw_nr_of_frames_off+4
-const raw_files_off=raw_frames_per_file_off+4
-
-const raw_size=raw_files_off+4
-
-const raw_get_value=value_extra
-
-function raw_structure(sd action,sd value)
-    data structure#1
-    if action==(value_set)
-        set structure value
-    elseif action==(value_get)
-        return structure
-    else
-        sd member
-        set member structure
-        add member value
-        return member#
-    endelse
-endfunction
-
-#write
-
-function capture_raw_files(sd output_file)
-    data width#1
-    data height#1
-    data nr_of_frames#1
-    data frames_per_file#1
-    data files#1
-
-    sd struct^width
-    call raw_structure((value_set),struct)
-
-    call capture_get_width_height(struct)
-
-    sd maxsize
-    setcall maxsize capture_split((split_maxsize_value))
-    sd frame_size
-    setcall frame_size rgb_get_size(width,height)
-    #add the frame length storage space
-    add frame_size 4
-    set frames_per_file maxsize
-    div frames_per_file frame_size
-    if frames_per_file==0
-        set frames_per_file 1
-    endif
-
-    set files 0
-
-    sd all_frames
-    setcall all_frames capture_direct_frames((value_get))
-    while all_frames!=0
-        if all_frames<=frames_per_file
-            set nr_of_frames all_frames
-            set all_frames 0
-        else
-            set nr_of_frames frames_per_file
-            sub all_frames frames_per_file
-        endelse
-
-        importx "_sprintf" sprintf
-        char outfile_data#100
-        str outfile^outfile_data
-        str outformat="%s.%u"
-        call sprintf(outfile,outformat,output_file,files)
-        import "file_write_forward" file_write_forward
-        data forward_raw^capture_raw_writeOnFile
-        call file_write_forward(outfile,forward_raw)
-
-        inc files
-    endwhile
-endfunction
-
-function capture_raw_writeOnFile(sd file)
-    sd struct
-    setcall struct raw_structure((value_get))
-    call file_write(struct,(raw_size),file)
-endfunction
-
-#read
-
-function capture_raw_read(ss filepath)
-    #values init
-    import "stage_read_values" stage_read_values
-    sd bool
-    setcall bool stage_read_values((value_set))
-    if bool!=1
-        return 0
-    endif
-
-    data f^capture_raw_read_start
-    call av_dialog_run(f,filepath)
-
-    #values write and free
-    call stage_read_values((value_write))
-    call stage_read_values((value_unset))
-endfunction
-
-function capture_raw_read_start(ss filepath)
-    import "file_forward_read" file_forward_read
-    data f_raw^capture_raw_read_file
-    call file_forward_read(filepath,f_raw)
-    call av_dialog_close()
-endfunction
-
-function capture_raw_read_file(sd file,sd path)
-    data struct_data#raw_size
-    data struct^struct_data
-    sd err
-    setcall err file_read(struct,(raw_size),file)
-    if err!=(noerror)
-        return 0
-    endif
-    call raw_structure((value_set),struct)
-
-    import "valinmemsens" valinmemsens
-    import "slen" slen
-    sd sz
-    setcall sz slen(path)
-    ss filepath
-    set filepath path
-    add filepath sz
-    char delim="."
-    setcall sz valinmemsens(filepath,sz,delim) #,(BACKWARD)
-    sub filepath sz
-    set filepath# 0
-
-    data f_raw^capture_raw_read_filedata
-    call file_forward_read(path,f_raw)
-endfunction
-
-function capture_raw_read_filedata(sd file)
-    sd width
-    sd height
-    sd frames_per_file
-    sd files_before
-    setcall width raw_structure((raw_get_value),(raw_width_height_off))
-    setcall height raw_structure((raw_get_value),(raw_width_height_off+4))
-    setcall frames_per_file raw_structure((raw_get_value),(raw_frames_per_file_off))
-    setcall files_before raw_structure((raw_get_value),(raw_files_off))
-
-    sd size
-    sd rgb_size
-    setcall size rgb_get_size(width,height)
-    set rgb_size size
-    add size 4
-    mult size frames_per_file
-
-    sd er
-    sd i=0
-    while i!=files_before
-        import "file_seek_dif_cursor" file_seek_dif_cursor
-        setcall er file_seek_dif_cursor(file,size)
-        if er!=(noerror)
-            return 0
-        endif
-        inc i
-    endwhile
-
-    sd nr_of_frames
-    setcall nr_of_frames raw_structure((raw_get_value),(raw_nr_of_frames_off))
-    set i 0
-
-    import "rgb_get_rowstride" rgb_get_rowstride
-    sd pixbuf
-    sd length
-    sd entry^pixbuf
-    sd p_length^length
-    sd rowstride
-    setcall rowstride rgb_get_rowstride(width)
-
-    while i!=nr_of_frames
-        sd stop
-        setcall stop av_dialog_stop((value_get))
-        if stop==1
-            return 0
-        endif
-
-        sd mem
-        setcall mem memalloc(rgb_size)
-        if mem==0
-            return 0
-        endif
-
-        setcall er file_read(mem,rgb_size,file)
-        if er!=(noerror)
-            return 0
-        endif
-        call bytes_swap_reverse(mem,width,height)
-        data free_mem^free
-        setcall pixbuf gdk_pixbuf_new_from_data(mem,(GDK_COLORSPACE_RGB),(FALSE),8,width,height,rowstride,free_mem,mem)
-
-        setcall er file_read(p_length,4,file)
-        if er!=(noerror)
-            return 0
-        endif
-
-        sd bool
-        setcall bool stage_read_values((value_append),entry,8)
-        if bool!=1
-            return 0
-        endif
-
-        #info display
-        import "av_display_info" av_display_info
-        call av_display_info((value_write),0,-1,rgb_size)
-
-        inc i
-    endwhile
-endfunction
--- /dev/null
+++ ovideo-1/src/_dif/difl.oc
@@ -0,0 +1,8 @@
+
+entryraw _start(sd argc,sv *argv)
+
+import "init_args" init_args
+
+sd cmp;setcall cmp init_args(argc)
+
+if cmp!=0
--- ovideo-1.orig/src/_dif/difl.s
+++ /dev/null
@@ -1,8 +0,0 @@
-
-entryraw _start(sd argc,sv *argv)
-
-import "init_args" init_args
-
-sd cmp;setcall cmp init_args(argc)
-
-if cmp!=0
--- /dev/null
+++ ovideo-1/src/_dif/difw.oc
@@ -0,0 +1,8 @@
+
+entry _start()
+
+import "init_args" init_args
+
+sd cmp;setcall cmp init_args()
+
+if cmp!=0
--- ovideo-1.orig/src/_dif/difw.s
+++ /dev/null
@@ -1,8 +0,0 @@
-
-entry _start()
-
-import "init_args" init_args
-
-sd cmp;setcall cmp init_args()
-
-if cmp!=0
--- /dev/null
+++ ovideo-1/src/_dif/dif~lin.oc
@@ -0,0 +1,970 @@
+
+
+
+format elfobj
+
+override underscore_pref 0
+
+include "../_include/include.h"
+
+#Const X_OK=1
+#Const FORWARD=1
+
+import "setmemzero" setmemzero
+import "texter" texter
+
+function movetoScriptfolder(data forward)
+#on lin no, Script is alone in bin folder
+#at this first call img/version and then sys
+	call prog_init()
+	sd f
+	setcall f share_folder()
+	sd err
+	setcall err move_to_folder(f)
+	if err=(noerror)
+		call forward()
+		return (void)
+	endif
+	call texter(err)
+endfunction
+
+
+importx "__errno_location" errno
+#errno
+function geterrno()
+        data err#1
+        setcall err errno()
+        return err#
+endfunction
+
+
+
+importx "gdk_x11_drawable_get_xid" gdk_x11_drawable_get_xid
+function gdkGetdrawable(data window)
+    data windraw#1
+    setcall windraw gdk_x11_drawable_get_xid(window)
+    return windraw
+endfunction
+
+function system_variables_alignment_pad(data *value,data *greatest)
+    data noalignment=0
+    return noalignment
+endfunction
+
+import "time" time
+function timeNode(data ptrtime_t)
+    data time_t#1
+    setcall time_t time(ptrtime_t)
+    return time_t
+endfunction
+
+import "chdir" chd
+function chdr(str value)
+    data x#1
+    setcall x chd(value)
+    return x
+endfunction
+
+import "snprintf" snprintf
+function c_snprintf_strvaluedisp(str display,data max,str format,str text,data part2)
+    call snprintf(display,max,format,text,part2)
+endfunction
+
+
+
+importx "gtk_file_chooser_get_filename" gtk_file_chooser_get_filename
+function file_chooser_get_fname(sd dialog)
+    sd file
+    setcall file gtk_file_chooser_get_filename(dialog)
+    return file
+endfunction
+
+
+
+
+
+#jpeg
+
+function jpeg_get_jdestruct_size()
+    return (jdestruct_size_lin)
+endfunction
+
+function jpeg_get_jdestruct_output_width()
+    return (jdestruct_output_width_lin)
+endfunction
+function jpeg_get_jdestruct_output_height()
+    return (jdestruct_output_height_lin)
+endfunction
+function jpeg_get_jdestruct_output_components()
+    return (jdestruct_output_components_lin)
+endfunction
+
+#
+
+##times
+
+const CLOCK_MONOTONIC=1
+
+#milliseconds
+function get_time()
+    import "clock_gettime" clock_gettime
+    data sec#1
+    data nanoseconds#1
+
+    data timespec^sec
+    call clock_gettime((CLOCK_MONOTONIC),timespec)
+
+    mult sec 1000
+    div nanoseconds (1000*1000)
+
+    sd milliseconds
+    set milliseconds sec
+    add milliseconds nanoseconds
+    return milliseconds
+endfunction
+
+function sleepMs(sd value)
+    import "usleep" usleep
+
+    #milliseconds in, convert to microseconds
+    mult value 1000
+
+    call usleep(value)
+endfunction
+
+
+###capture alternative
+
+function term_toggle(sd action,sd value)
+    data term_entry#1
+    if action=(value_set)
+        set term_entry value
+    else
+        return term_entry
+    endelse
+endfunction
+
+function capture_alternative_init(sd vbox)
+    importx "gtk_check_button_new_with_label" gtk_check_button_new_with_label
+    importx "gtk_container_add" gtk_container_add
+    importx "gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
+    ss term_txt="Terminal(if exists)"
+    sd term_entry
+    setcall term_entry gtk_check_button_new_with_label(term_txt)
+    call term_toggle((value_set),term_entry)
+    str txt="Use only if the application has a terminal."
+    call gtk_widget_set_tooltip_markup(term_entry,txt)
+    call gtk_container_add(vbox,term_entry)
+endfunction
+function capture_alternative_set(sd *p_cairoflag,sd p_term)
+    sd t_entry
+    setcall t_entry term_toggle((value_get))
+    importx "gtk_toggle_button_get_active" gtk_toggle_button_get_active
+    setcall p_term# gtk_toggle_button_get_active(t_entry)
+endfunction
+#bool
+function capture_alternative_prepare()
+    importx "gtk_widget_hide_all" gtk_widget_hide_all
+    import "mainwidget" mainwidget
+    import "dialog_handle" dialog_handle
+    sd win
+    setcall win mainwidget()
+    call gtk_widget_hide_all(win)
+    setcall win dialog_handle()
+    call gtk_widget_hide_all(win)
+    import "message_dialog" message_dialog
+    str term_msg="Press ENTER in the terminal to stop."
+    call message_dialog(term_msg)
+    call capture_alt_ev((value_set))
+    #thread for getchar
+    import "getptrgerr" getptrgerr
+    sd ptrgerr
+    setcall ptrgerr getptrgerr()
+    importx "g_thread_create" g_thread_create
+    data forward^capture_alt_thread_proc
+    sd thread
+    setcall thread g_thread_create(forward,0,1,ptrgerr)
+    if thread=0
+        import "gerrtoerr" gerrtoerr
+        call gerrtoerr(ptrgerr)
+        call capture_alt_showback()
+        return 0
+    endif
+    call capture_alt_thread((value_set),thread)
+    call capture_alt_thread_dup((value_set),thread)
+    return 1
+endfunction
+function capture_alternative_append()
+endfunction
+function capture_alternative_free()
+    sd event
+    setcall event capture_alt_ev((value_get))
+    call closeevent(event)
+    importx "g_thread_join" g_thread_join
+    call capture_alt_thread_dup((value_set),0)
+    sd thread
+    setcall thread capture_alt_thread((value_get))
+    call g_thread_join(thread)
+    call capture_alt_showback()
+endfunction
+
+function capture_alt_showback()
+    importx "gtk_widget_show_all" gtk_widget_show_all
+    sd win
+    setcall win mainwidget()
+    call gtk_widget_show_all(win)
+    setcall win dialog_handle()
+    call gtk_widget_show_all(win)
+endfunction
+
+function capture_alt_ev(sd action)
+    #sem_t is required to keep it at even(?)(at 4?) address (something about to share it by processes and threads)
+    data ev#2*8+4
+    data event^ev
+    if action=(value_set)
+        import "multiple_of_nr" multiple_of_nr
+        setcall event multiple_of_nr(event,4)
+        call createevent(event)
+    else
+    #if action==(value_get)
+    #event
+        return event
+    endelse
+endfunction
+function capture_alt_ev_wait()
+    sd event
+    setcall event capture_alt_ev((value_get))
+    call waitevent(event)
+endfunction
+function capture_alt_ev_set()
+    sd event
+    setcall event capture_alt_ev((value_get))
+    call setevent(event)
+endfunction
+##events
+function createevent(sd event)
+    import "sem_init" sem_init
+    call sem_init(event,0,0)
+    #0 ok,-1 error(bad argument?)
+endfunction
+function waitevent(sd event)
+    import "sem_wait" sem_wait
+    call sem_wait(event)
+endfunction
+function closeevent(sd event)
+    import "sem_destroy" sem_destroy
+    call sem_destroy(event)
+endfunction
+function setevent(sd event)
+    import "sem_post" sem_post
+    call sem_post(event)
+endfunction
+
+function capture_alt_thread(sd action,sd value)
+    data thread#1
+    if action=(value_set)
+        set thread value
+    else
+        return thread
+    endelse
+endfunction
+function capture_alt_thread_dup(sd action,sd value)
+    data thread#1
+    if action=(value_set)
+        set thread value
+    else
+        return thread
+    endelse
+endfunction
+const nfdbits=8*4
+function fd_mask(sd d)
+    #define	__FD_MASK(d)	((__fd_mask) 1 << ((d) % __NFDBITS))
+    #__fd_mask=long int
+    #__NFDBITS	(8 * (int) sizeof (__fd_mask))
+    import "rest" rest
+    import "shl" shl
+    sd mask
+    setcall mask rest(d,(nfdbits))
+    setcall mask shl(1,mask)
+    return mask
+endfunction
+function fds_bits(sd fds,sd d)
+    #__FDS_BITS(set) ((set)->fds_bits)
+    #__fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
+    #__FD_SETSIZE		1024
+    sd elt
+    setcall elt fd_elt(d)
+
+    import "array_get_int" array_get_int
+    sd value
+    setcall value array_get_int(fds,elt)
+    return value
+endfunction
+function fd_elt(sd d)
+    #__FD_ELT(d)	((d) / __NFDBITS)
+    sd elt
+    set elt d
+    div elt (nfdbits)
+    return elt
+endfunction
+function capture_alt_thread_proc(sd *noArg)
+    whiletrue
+        const STDIN_FILENO=0
+        const fd_set_size=128
+        char filedescriptor_set#fd_set_size
+        data fds^filedescriptor_set
+        call setmemzero(fds,(fd_set_size))
+        #define __FD_SET(d, set) \
+            #((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))
+        import "array_set_int" array_set_int
+        sd value
+        sd elt
+        sd mask
+        setcall value fds_bits(fds,(STDIN_FILENO))
+        setcall elt fd_elt((STDIN_FILENO))
+        setcall mask fd_mask((STDIN_FILENO))
+
+        or value mask
+        call array_set_int(fds,elt,value)
+
+        import "select" select
+        sd tv_sec=100
+        sd *tv_usec=0
+        sd timeval^tv_sec
+        call select((STDIN_FILENO+1),fds,0,0,timeval)
+
+        setcall value fds_bits(fds,(STDIN_FILENO))
+        and value mask
+        if value!=0
+            import "av_dialog_stop" av_dialog_stop
+            call av_dialog_stop((value_set),1)
+            return 0
+        endif
+        sd thread_dup
+        setcall thread_dup capture_alt_thread_dup((value_get))
+        if thread_dup=0
+            return 0
+        endif
+    endwhile
+endfunction
+
+#file seek dif
+
+#er
+function file_seek_dif_cursor(sd file,sd off)
+    import "file_seek_cursor" file_seek_cursor
+    sd err
+    setcall err file_seek_cursor(file,off)
+    return err
+endfunction
+
+
+#sound preview
+
+const SND_PCM_STREAM_PLAYBACK=0
+const SND_PCM_ACCESS_RW_INTERLEAVED=3
+
+const SND_PCM_FORMAT_U8=1
+const SND_PCM_FORMAT_S16_LE=2
+
+const SND_PCM_NONBLOCK=1
+#const SND_PCM_ASYNC=2
+
+import "snd_pcm_open" snd_pcm_open
+import "snd_pcm_hw_params_malloc" snd_pcm_hw_params_malloc
+import "snd_pcm_hw_params_free" snd_pcm_hw_params_free
+import "snd_pcm_close" snd_pcm_close
+import "snd_pcm_writei" snd_pcm_writei
+import "snd_pcm_avail_update" snd_pcm_avail_update
+import "snd_pcm_get_params" snd_pcm_get_params
+
+import "snd_pcm_hw_params_any" snd_pcm_hw_params_any
+import "snd_pcm_hw_params_set_access" snd_pcm_hw_params_set_access
+import "snd_pcm_hw_params_set_format" snd_pcm_hw_params_set_format
+import "snd_pcm_hw_params_set_rate" snd_pcm_hw_params_set_rate
+import "snd_pcm_hw_params_set_channels" snd_pcm_hw_params_set_channels
+import "snd_pcm_hw_params" snd_pcm_hw_params
+import "snd_pcm_prepare" snd_pcm_prepare
+
+#bool
+function sound_preview_init()
+    sd handle
+    setcall handle sound_preview_playback_handle()
+    set handle# 0
+    str name="default"
+    sd err
+    setcall err snd_pcm_open(handle,name,(SND_PCM_STREAM_PLAYBACK),(SND_PCM_NONBLOCK))
+    if err<0
+        str er="Cannot open audio device"
+        call texter(er)
+        return 0
+    endif
+    sd hw_params
+    setcall err snd_pcm_hw_params_malloc(#hw_params)
+    if err<0
+        str hw_er="Cannot allocate hardware parameter structure"
+        call texter(hw_er)
+        call sound_preview_free()
+        return 0
+    endif
+    sd bool
+    setcall bool sound_preview_initialize(handle#,hw_params)
+    call snd_pcm_hw_params_free(hw_params)
+    if bool=0
+        call sound_preview_free()
+    endif
+	#set buffer size 0 needed for write
+	call alsa_write((value_extra))
+    return bool
+endfunction
+function sound_preview_free()
+    sd handle
+    setcall handle sound_preview_playback_handle()
+    if handle#!=0
+        call snd_pcm_close(handle#)
+        #in case a sound timeout will come
+        set handle# 0
+    endif
+endfunction
+import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
+function sound_preview_write_buffer(sd bf_pos,sd buffer_size,sd random_key)
+    sd bf
+    setcall bf stage_sound_alloc_getbytes()
+    sub bf_pos bf
+    call alsa_write((value_set),random_key,bf_pos,buffer_size)
+endfunction
+
+function sound_preview_playback_handle()
+    data playback_handle#1
+    return #playback_handle
+endfunction
+
+#bool
+function sound_preview_initialize(sd handle,sd hw_params)
+    sd err
+    setcall err snd_pcm_hw_params_any(handle,hw_params)
+    if err<0
+        str hwini_er="Cannot initialize hardware parameter structure"
+        call texter(hwini_er)
+        return 0
+    endif
+    setcall err snd_pcm_hw_params_set_access(handle,hw_params,(SND_PCM_ACCESS_RW_INTERLEAVED))
+    if err<0
+        str ac_er="Cannot set access type"
+        call texter(ac_er)
+        return 0
+    endif
+    import "stage_sound_bps" stage_sound_bps
+    sd bps
+    setcall bps stage_sound_bps((value_get))
+    if bps=8
+        setcall err snd_pcm_hw_params_set_format(handle,hw_params,(SND_PCM_FORMAT_U8))
+    else
+        setcall err snd_pcm_hw_params_set_format(handle,hw_params,(SND_PCM_FORMAT_S16_LE))
+    endelse
+    if err<0
+        str fr_er="Cannot set bits per sample"
+        call texter(fr_er)
+        return 0
+    endif
+    #last param is int *  dir, Sub unit direction
+    import "stage_sound_rate" stage_sound_rate
+    sd rate
+    setcall rate stage_sound_rate((value_get))
+    setcall err snd_pcm_hw_params_set_rate(handle,hw_params,rate,0)
+    if err<0
+        str rate_er="Cannot set sample rate"
+        call texter(rate_er)
+        return 0
+    endif
+    import "stage_sound_channels" stage_sound_channels
+    sd channels
+    setcall channels stage_sound_channels((value_get))
+    setcall err snd_pcm_hw_params_set_channels(handle,hw_params,channels)
+    if err<0
+        str ch_er="Cannot set channel count"
+        call texter(ch_er)
+        return 0
+    endif
+    setcall err snd_pcm_hw_params(handle,hw_params)
+    if err<0
+        str hwpar_er="Cannot set parameters"
+        call texter(hwpar_er)
+        return 0
+    endif
+    #
+    setcall err snd_pcm_prepare(handle)
+    if err<0
+        str inter_er="Cannot prepare audio interface for use"
+        call texter(inter_er)
+        return 0
+    endif
+    return 1
+endfunction
+
+function alsa_write(sd procedure,sd random_key,sd bf_pos,sd all_buffer_size)
+    # send in parts or all size
+    #values
+    sd handle
+    setcall handle sound_preview_playback_handle()
+    if handle#=0
+        return (void)
+    endif
+    data pos#1
+    data buffer_size#1
+    data wait_bufferfull_timeout#1
+    if procedure=(value_extra)
+        set buffer_size 0
+        set wait_bufferfull_timeout 0
+        call alsa_full_set((value_set),#wait_bufferfull_timeout)
+        return (void)
+    endif
+    #all values are in frames(blockalign values) except pos
+    importx "gdk_threads_add_timeout" gdk_threads_add_timeout
+    sd main_frames
+    sd period_size
+    sd err
+    import "stage_sound_blockalign" stage_sound_blockalign
+    sd blockalign
+    setcall blockalign stage_sound_blockalign()
+    if procedure=(value_set)
+        if buffer_size!=0
+            div all_buffer_size blockalign
+            add buffer_size all_buffer_size
+            if wait_bufferfull_timeout=1
+                #a timeout will resolve the new sound
+                return (void)
+            endif
+        else
+            set pos bf_pos
+            set buffer_size all_buffer_size
+            div buffer_size blockalign
+        endelse
+    endif
+    sd low_size
+    setcall low_size alsa_low_size(pos,buffer_size)
+    if low_size=1
+        return (void)
+    endif
+    #get available size
+    sd avail_size
+    setcall avail_size alsa_get_availsize(handle#)
+    if avail_size<0
+        return (void)
+    endif
+    #see the remaining size
+    sd write_size
+    set write_size buffer_size
+    if buffer_size>avail_size
+        set write_size avail_size
+    endif
+    #write the data
+    import "stage_sound_subsize" stage_sound_subsize
+    sd buffer
+    sd rawsize
+    set rawsize write_size
+    mult rawsize blockalign
+    set buffer pos
+    add buffer rawsize
+    sd currentsize
+    setcall currentsize stage_sound_subsize((value_get))
+    if buffer>currentsize
+        str sz_err="Size error"
+        call texter(sz_err)
+        return (void)
+    endif
+    sub buffer rawsize
+    addcall buffer stage_sound_alloc_getbytes()
+    #
+    sd frames_wrote
+    setcall frames_wrote snd_pcm_writei(handle#,buffer,write_size)
+    if frames_wrote!=write_size
+        str wrerr="Write to audio interface failed"
+        call texter(wrerr)
+        return (void)
+    endif
+    #timeout for next data
+    if buffer_size>avail_size
+        set wait_bufferfull_timeout 1
+        #set buffer and buffer size for next part
+        add pos rawsize
+        #wait half main buffer to be played
+        setcall err alsa_get_params(handle#,#main_frames,#period_size)
+        if err<0
+            return (void)
+        endif
+        div main_frames 2
+        #main_frames     x
+        #sample rate     1000 millisec
+        sd timeout_space=1000
+        mult timeout_space main_frames
+        divcall timeout_space stage_sound_rate((value_get))
+        data f^alsa_write_timeout_callback
+        call gdk_threads_add_timeout(timeout_space,f,random_key)
+    endif
+    sub buffer_size write_size
+    return (void)
+endfunction
+
+function alsa_full_set(sd procedure,sd ptr)
+    data p#1
+    if procedure=(value_set)
+        set p ptr
+    else
+        return p
+    endelse
+endfunction
+
+#alsa return
+function alsa_get_params(sd handle,sd frames,sd period)
+    sd err
+    setcall err snd_pcm_get_params(handle,frames,period)
+    if err<0
+        str geterr="Cannot get params"
+        call texter(geterr)
+    endif
+    return err
+endfunction
+#alsa return
+function alsa_get_availsize(sd handle)
+    sd avail_size
+    setcall avail_size snd_pcm_avail_update(handle)
+    if avail_size<0
+        str av_err="Avail size function error"
+        call texter(av_err)
+    endif
+    return avail_size
+endfunction
+
+function alsa_write_timeout_callback(sd key)
+    #reset the timeout pointer
+    sd p
+    setcall p alsa_full_set((value_get))
+    set p# 0
+    call alsa_write_and_verify_key(key)
+    #0 for not called again
+    return 0
+endfunction
+
+function alsa_write_and_verify_key(sd key)
+    sd k
+    import "sound_random_key" sound_random_key
+    setcall k sound_random_key()
+    if k#=key
+        #k#!=key means another frame pressed
+        call alsa_write((value_run),key)
+    endif
+endfunction
+
+function alsa_low_size(sd pos,sd buffer_size)
+    #reach a size for write limit
+    sd rate
+    setcall rate stage_sound_rate((value_get))
+    if buffer_size<rate
+        sd blockalign
+        setcall blockalign stage_sound_blockalign()
+        mult buffer_size blockalign
+        add pos buffer_size
+        sd currentsize
+        setcall currentsize stage_sound_subsize((value_get))
+        if pos<currentsize
+            #low_size= true, wait for more
+            return 1
+        endif
+    endif
+    return 0
+endfunction
+
+const SND_PCM_STATE_RUNNING=3
+
+#bool
+function sound_preview_end_and_no_errors()
+    import "snd_pcm_status_malloc" snd_pcm_status_malloc
+    import "snd_pcm_status_free" snd_pcm_status_free
+    sd handle
+    setcall handle sound_preview_playback_handle()
+    sd status
+    sd er
+    setcall er snd_pcm_status_malloc(#status)
+    if er<0
+        str alloc="snd_pcm_status_malloc error"
+        call texter(alloc)
+        return (FALSE)
+    endif
+    sd bool
+    setcall bool sound_preview_end_and_no_errors_continuation(handle#,status)
+    call snd_pcm_status_free(status)
+    return bool
+endfunction
+#bool
+function sound_preview_end_and_no_errors_continuation(sd handle,sd status)
+    import "snd_pcm_status" snd_pcm_status
+    import "snd_pcm_status_get_state" snd_pcm_status_get_state
+    sd er
+    setcall er snd_pcm_status(handle,status)
+    if er<0
+        str error="snd_pcm_status error"
+        call texter(error)
+        return (FALSE)
+    endif
+    sd state
+    setcall state snd_pcm_status_get_state(status)
+    if state=(SND_PCM_STATE_RUNNING)
+        return (FALSE)
+    endif
+    return (TRUE)
+endfunction
+
+
+#html 1
+#	enter leave  B
+#img
+#	enter leave data    1 at img enter leave at init A(has recurse in edit)   1 img edit enter leave at cover/frame B
+#	stage get image 1   at frames,selectframe B
+#version 1    A
+#
+#
+#captures
+#	init 1    A
+#	1         B
+#sys
+#	init 1    A
+#	sys enter leave 4(init 1 A ,dialog 1 B,stage 2 B)
+#
+#
+#1 at A to share from img to version, next to home: init_user, at sys
+#
+#this was with er, rest are with texter
+#
+#captures changes to home  return
+#sys 3 changes to home     enterleave
+#html changes to share     enterleave
+#img cover/frame to share  enterleave
+#img frames to share       return
+
+importx "getenv" getenv
+
+import "init_dir" init_dir
+import "dirch" dirch
+
+#e
+function move_to_folder(sd f)
+	sd change
+	setcall change chd(f)
+	if change!=0
+		return "Change dir error at init."
+	endif
+	return (noerror)
+endfunction
+#e
+function move_to_home()
+	sd f
+	sd er
+	setcall er home_folder(#f,(NULL))
+	if er=(noerror)
+		setcall er init_dir(f)
+		if er=(noerror)
+			setcall er move_to_folder(f)
+		endif
+	endif
+	return er
+endfunction
+function move_to_home_v()
+	sd f
+	setcall f home_folder_r((NULL))
+	if f!=(NULL)
+		call dirch(f)
+	endif
+endfunction
+function move_to_home_core(sv p)
+	sv mem
+	setcall mem home_folder_function()
+	set mem mem#
+	if mem!=(NULL)
+		sd f
+		sd h
+		setcall f home_folder_r(#h)
+		if f!=(NULL)
+			sd b
+			setcall b cat_absolute_verif(mem,h,f,p#)
+			if b=(TRUE)
+				set p# mem
+			endif
+		endif
+	endif
+endfunction
+function move_to_share_v()
+	sd f
+	setcall f share_folder()
+	call dirch(f)
+endfunction
+function move_to_share_core(sv p)
+	sv mem
+	setcall mem share_folder_function()
+	set mem mem#
+	if mem!=(NULL)
+		sd f
+		setcall f share_folder()
+		sd b
+		setcall b cat_absolute_verif(mem,f,p#,(NULL))
+		if b=(TRUE)
+			set p# mem
+		endif
+	endif
+endfunction
+importx "access" access
+#er
+function uninit_start()
+	sd f
+	sd er
+	setcall er home_folder(#f,(NULL))
+	if er=(noerror)
+		sd a;setcall a access(f,(F_OK))
+		if a=0
+			setcall er move_to_folder(f)
+		else
+			return (error)
+		endelse
+	endif
+	return er
+endfunction
+#path
+function real_path(sd p)
+importx "realpath" realpath
+	sd mem;setcall mem realpath(p,(NULL))
+	return mem
+endfunction
+
+#e
+function home_folder(sv pf,sv ph)
+	ss envpath
+	setcall envpath getenv("HOME")
+	if envpath!=(NULL)
+		vstr a="ovideo"
+		if ph=(NULL)
+			sd err
+			setcall err move_to_folder(envpath)
+			if err!=(noerror)
+				return err
+			endif
+			set pf# a
+		else
+			set ph# envpath
+			set pf# a
+		endelse
+		return (noerror)
+	endif
+	return "Getenv error at home folder."
+endfunction
+#string/0
+function home_folder_r(sd p)
+	sd er
+	sd f
+	setcall er home_folder(#f,p)
+	if er=(noerror)
+		return f
+	endif
+	call texter(er)
+	return (NULL)
+endfunction
+#string
+function share_folder()
+	include "share.txt"
+endfunction
+
+#cmp
+function init_args(sd argc)
+	if argc>1
+		sd er;setcall er uninit_start()
+		if er=(noerror)
+			import "uninit_print" uninit_print
+			import "uninit_print_entry" uninit_print_entry
+			sv c;sv s;setcall s uninit_print(#c)
+			vstr current_folder="."
+			call uninit_print_entry(current_folder)
+			import "uninit_decision" uninit_decision
+			sd b;setcall b uninit_decision()
+			if b=(TRUE)
+				import "uninit_delete" uninit_delete
+				call uninit_delete(s,c)
+				import "uninit_delete_folder" uninit_delete_folder
+				call uninit_delete_folder(current_folder)
+			endif
+		endif
+		return 0
+	endif
+	return -1
+endfunction
+
+const PATH_MAX=4096
+importx "malloc" malloc
+importx "free" free
+importx "strlen" strlen
+importx "sprintf" sprintf
+
+function prog_init()
+	sv a
+	setcall a home_folder_function()
+	set a# (NULL)
+	sv b
+	setcall b share_folder_function()
+	set b# (NULL)
+	vstr s="malloc error."
+	sd c
+	setcall c malloc((PATH_MAX))
+	if c!=(NULL)
+		set a# c
+		setcall c malloc((PATH_MAX))
+		if c!=(NULL)
+			set b# c
+			return (void)
+		endif
+	endif
+	call texter(s)
+endfunction
+function prog_free()
+	sv a
+	setcall a home_folder_function()
+	if a#!=(NULL)
+		call free(a#)
+		setcall a share_folder_function()
+		if a#!=(NULL)
+			call free(a#)
+		endif
+	endif
+endfunction
+
+function home_folder_function()
+	value p#1
+	return #p
+endfunction
+function share_folder_function()
+	value p#1
+	return #p
+endfunction
+
+function cat_absolute_verif(sd mem,sd v,sd v2,sd v3)
+	sd s
+	setcall s strlen(v)
+	inc s
+	addcall s strlen(v2)
+	if v3!=(NULL)
+		inc s
+		addcall s strlen(v3)
+	endif
+	if s<(PATH_MAX)
+		sd n
+		setcall n sprintf(mem,"%s/%s",v,v2)
+		if v3!=(NULL)
+			add mem n
+			call sprintf(mem,"/%s",v3)
+		endif
+		return (TRUE)
+	endif
+	call texter("path max error.")
+	return (FALSE)
+endfunction
+
+function ulltoa(sd low,sd high,sd str)
+	call sprintf(str,"%llu",low,high)
+endfunction
--- ovideo-1.orig/src/_dif/dif~lin.s
+++ /dev/null
@@ -1,970 +0,0 @@
-
-
-
-format elfobj
-
-override underscore_pref 0
-
-include "../_include/include.h"
-
-#Const X_OK=1
-#Const FORWARD=1
-
-import "setmemzero" setmemzero
-import "texter" texter
-
-function movetoScriptfolder(data forward)
-#on lin no, Script is alone in bin folder
-#at this first call img/version and then sys
-	call prog_init()
-	sd f
-	setcall f share_folder()
-	sd err
-	setcall err move_to_folder(f)
-	if err==(noerror)
-		call forward()
-		return (void)
-	endif
-	call texter(err)
-endfunction
-
-
-importx "__errno_location" errno
-#errno
-function geterrno()
-        data err#1
-        setcall err errno()
-        return err#
-endfunction
-
-
-
-importx "gdk_x11_drawable_get_xid" gdk_x11_drawable_get_xid
-function gdkGetdrawable(data window)
-    data windraw#1
-    setcall windraw gdk_x11_drawable_get_xid(window)
-    return windraw
-endfunction
-
-function system_variables_alignment_pad(data *value,data *greatest)
-    data noalignment=0
-    return noalignment
-endfunction
-
-import "time" time
-function timeNode(data ptrtime_t)
-    data time_t#1
-    setcall time_t time(ptrtime_t)
-    return time_t
-endfunction
-
-import "chdir" chd
-function chdr(str value)
-    data x#1
-    setcall x chd(value)
-    return x
-endfunction
-
-import "snprintf" snprintf
-function c_snprintf_strvaluedisp(str display,data max,str format,str text,data part2)
-    call snprintf(display,max,format,text,part2)
-endfunction
-
-
-
-importx "gtk_file_chooser_get_filename" gtk_file_chooser_get_filename
-function file_chooser_get_fname(sd dialog)
-    sd file
-    setcall file gtk_file_chooser_get_filename(dialog)
-    return file
-endfunction
-
-
-
-
-
-#jpeg
-
-function jpeg_get_jdestruct_size()
-    return (jdestruct_size_lin)
-endfunction
-
-function jpeg_get_jdestruct_output_width()
-    return (jdestruct_output_width_lin)
-endfunction
-function jpeg_get_jdestruct_output_height()
-    return (jdestruct_output_height_lin)
-endfunction
-function jpeg_get_jdestruct_output_components()
-    return (jdestruct_output_components_lin)
-endfunction
-
-#
-
-##times
-
-const CLOCK_MONOTONIC=1
-
-#milliseconds
-function get_time()
-    import "clock_gettime" clock_gettime
-    data sec#1
-    data nanoseconds#1
-
-    data timespec^sec
-    call clock_gettime((CLOCK_MONOTONIC),timespec)
-
-    mult sec 1000
-    div nanoseconds (1000*1000)
-
-    sd milliseconds
-    set milliseconds sec
-    add milliseconds nanoseconds
-    return milliseconds
-endfunction
-
-function sleepMs(sd value)
-    import "usleep" usleep
-
-    #milliseconds in, convert to microseconds
-    mult value 1000
-
-    call usleep(value)
-endfunction
-
-
-###capture alternative
-
-function term_toggle(sd action,sd value)
-    data term_entry#1
-    if action==(value_set)
-        set term_entry value
-    else
-        return term_entry
-    endelse
-endfunction
-
-function capture_alternative_init(sd vbox)
-    importx "gtk_check_button_new_with_label" gtk_check_button_new_with_label
-    importx "gtk_container_add" gtk_container_add
-    importx "gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
-    ss term_txt="Terminal(if exists)"
-    sd term_entry
-    setcall term_entry gtk_check_button_new_with_label(term_txt)
-    call term_toggle((value_set),term_entry)
-    str txt="Use only if the application has a terminal."
-    call gtk_widget_set_tooltip_markup(term_entry,txt)
-    call gtk_container_add(vbox,term_entry)
-endfunction
-function capture_alternative_set(sd *p_cairoflag,sd p_term)
-    sd t_entry
-    setcall t_entry term_toggle((value_get))
-    importx "gtk_toggle_button_get_active" gtk_toggle_button_get_active
-    setcall p_term# gtk_toggle_button_get_active(t_entry)
-endfunction
-#bool
-function capture_alternative_prepare()
-    importx "gtk_widget_hide_all" gtk_widget_hide_all
-    import "mainwidget" mainwidget
-    import "dialog_handle" dialog_handle
-    sd win
-    setcall win mainwidget()
-    call gtk_widget_hide_all(win)
-    setcall win dialog_handle()
-    call gtk_widget_hide_all(win)
-    import "message_dialog" message_dialog
-    str term_msg="Press ENTER in the terminal to stop."
-    call message_dialog(term_msg)
-    call capture_alt_ev((value_set))
-    #thread for getchar
-    import "getptrgerr" getptrgerr
-    sd ptrgerr
-    setcall ptrgerr getptrgerr()
-    importx "g_thread_create" g_thread_create
-    data forward^capture_alt_thread_proc
-    sd thread
-    setcall thread g_thread_create(forward,0,1,ptrgerr)
-    if thread==0
-        import "gerrtoerr" gerrtoerr
-        call gerrtoerr(ptrgerr)
-        call capture_alt_showback()
-        return 0
-    endif
-    call capture_alt_thread((value_set),thread)
-    call capture_alt_thread_dup((value_set),thread)
-    return 1
-endfunction
-function capture_alternative_append()
-endfunction
-function capture_alternative_free()
-    sd event
-    setcall event capture_alt_ev((value_get))
-    call closeevent(event)
-    importx "g_thread_join" g_thread_join
-    call capture_alt_thread_dup((value_set),0)
-    sd thread
-    setcall thread capture_alt_thread((value_get))
-    call g_thread_join(thread)
-    call capture_alt_showback()
-endfunction
-
-function capture_alt_showback()
-    importx "gtk_widget_show_all" gtk_widget_show_all
-    sd win
-    setcall win mainwidget()
-    call gtk_widget_show_all(win)
-    setcall win dialog_handle()
-    call gtk_widget_show_all(win)
-endfunction
-
-function capture_alt_ev(sd action)
-    #sem_t is required to keep it at even(?)(at 4?) address (something about to share it by processes and threads)
-    data ev#2*8+4
-    data event^ev
-    if action==(value_set)
-        import "multiple_of_nr" multiple_of_nr
-        setcall event multiple_of_nr(event,4)
-        call createevent(event)
-    else
-    #if action==(value_get)
-    #event
-        return event
-    endelse
-endfunction
-function capture_alt_ev_wait()
-    sd event
-    setcall event capture_alt_ev((value_get))
-    call waitevent(event)
-endfunction
-function capture_alt_ev_set()
-    sd event
-    setcall event capture_alt_ev((value_get))
-    call setevent(event)
-endfunction
-##events
-function createevent(sd event)
-    import "sem_init" sem_init
-    call sem_init(event,0,0)
-    #0 ok,-1 error(bad argument?)
-endfunction
-function waitevent(sd event)
-    import "sem_wait" sem_wait
-    call sem_wait(event)
-endfunction
-function closeevent(sd event)
-    import "sem_destroy" sem_destroy
-    call sem_destroy(event)
-endfunction
-function setevent(sd event)
-    import "sem_post" sem_post
-    call sem_post(event)
-endfunction
-
-function capture_alt_thread(sd action,sd value)
-    data thread#1
-    if action==(value_set)
-        set thread value
-    else
-        return thread
-    endelse
-endfunction
-function capture_alt_thread_dup(sd action,sd value)
-    data thread#1
-    if action==(value_set)
-        set thread value
-    else
-        return thread
-    endelse
-endfunction
-const nfdbits=8*4
-function fd_mask(sd d)
-    #define	__FD_MASK(d)	((__fd_mask) 1 << ((d) % __NFDBITS))
-    #__fd_mask=long int
-    #__NFDBITS	(8 * (int) sizeof (__fd_mask))
-    import "rest" rest
-    import "shl" shl
-    sd mask
-    setcall mask rest(d,(nfdbits))
-    setcall mask shl(1,mask)
-    return mask
-endfunction
-function fds_bits(sd fds,sd d)
-    #__FDS_BITS(set) ((set)->fds_bits)
-    #__fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
-    #__FD_SETSIZE		1024
-    sd elt
-    setcall elt fd_elt(d)
-
-    import "array_get_int" array_get_int
-    sd value
-    setcall value array_get_int(fds,elt)
-    return value
-endfunction
-function fd_elt(sd d)
-    #__FD_ELT(d)	((d) / __NFDBITS)
-    sd elt
-    set elt d
-    div elt (nfdbits)
-    return elt
-endfunction
-function capture_alt_thread_proc(sd *noArg)
-    while 1==1
-        const STDIN_FILENO=0
-        const fd_set_size=128
-        char filedescriptor_set#fd_set_size
-        data fds^filedescriptor_set
-        call setmemzero(fds,(fd_set_size))
-        #define __FD_SET(d, set) \
-            #((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))
-        import "array_set_int" array_set_int
-        sd value
-        sd elt
-        sd mask
-        setcall value fds_bits(fds,(STDIN_FILENO))
-        setcall elt fd_elt((STDIN_FILENO))
-        setcall mask fd_mask((STDIN_FILENO))
-
-        or value mask
-        call array_set_int(fds,elt,value)
-
-        import "select" select
-        sd tv_sec=100
-        sd *tv_usec=0
-        sd timeval^tv_sec
-        call select((STDIN_FILENO+1),fds,0,0,timeval)
-
-        setcall value fds_bits(fds,(STDIN_FILENO))
-        and value mask
-        if value!=0
-            import "av_dialog_stop" av_dialog_stop
-            call av_dialog_stop((value_set),1)
-            return 0
-        endif
-        sd thread_dup
-        setcall thread_dup capture_alt_thread_dup((value_get))
-        if thread_dup==0
-            return 0
-        endif
-    endwhile
-endfunction
-
-#file seek dif
-
-#er
-function file_seek_dif_cursor(sd file,sd off)
-    import "file_seek_cursor" file_seek_cursor
-    sd err
-    setcall err file_seek_cursor(file,off)
-    return err
-endfunction
-
-
-#sound preview
-
-const SND_PCM_STREAM_PLAYBACK=0
-const SND_PCM_ACCESS_RW_INTERLEAVED=3
-
-const SND_PCM_FORMAT_U8=1
-const SND_PCM_FORMAT_S16_LE=2
-
-const SND_PCM_NONBLOCK=1
-#const SND_PCM_ASYNC=2
-
-import "snd_pcm_open" snd_pcm_open
-import "snd_pcm_hw_params_malloc" snd_pcm_hw_params_malloc
-import "snd_pcm_hw_params_free" snd_pcm_hw_params_free
-import "snd_pcm_close" snd_pcm_close
-import "snd_pcm_writei" snd_pcm_writei
-import "snd_pcm_avail_update" snd_pcm_avail_update
-import "snd_pcm_get_params" snd_pcm_get_params
-
-import "snd_pcm_hw_params_any" snd_pcm_hw_params_any
-import "snd_pcm_hw_params_set_access" snd_pcm_hw_params_set_access
-import "snd_pcm_hw_params_set_format" snd_pcm_hw_params_set_format
-import "snd_pcm_hw_params_set_rate" snd_pcm_hw_params_set_rate
-import "snd_pcm_hw_params_set_channels" snd_pcm_hw_params_set_channels
-import "snd_pcm_hw_params" snd_pcm_hw_params
-import "snd_pcm_prepare" snd_pcm_prepare
-
-#bool
-function sound_preview_init()
-    sd handle
-    setcall handle sound_preview_playback_handle()
-    set handle# 0
-    str name="default"
-    sd err
-    setcall err snd_pcm_open(handle,name,(SND_PCM_STREAM_PLAYBACK),(SND_PCM_NONBLOCK))
-    if err<0
-        str er="Cannot open audio device"
-        call texter(er)
-        return 0
-    endif
-    sd hw_params
-    setcall err snd_pcm_hw_params_malloc(#hw_params)
-    if err<0
-        str hw_er="Cannot allocate hardware parameter structure"
-        call texter(hw_er)
-        call sound_preview_free()
-        return 0
-    endif
-    sd bool
-    setcall bool sound_preview_initialize(handle#,hw_params)
-    call snd_pcm_hw_params_free(hw_params)
-    if bool==0
-        call sound_preview_free()
-    endif
-	#set buffer size 0 needed for write
-	call alsa_write((value_extra))
-    return bool
-endfunction
-function sound_preview_free()
-    sd handle
-    setcall handle sound_preview_playback_handle()
-    if handle#!=0
-        call snd_pcm_close(handle#)
-        #in case a sound timeout will come
-        set handle# 0
-    endif
-endfunction
-import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
-function sound_preview_write_buffer(sd bf_pos,sd buffer_size,sd random_key)
-    sd bf
-    setcall bf stage_sound_alloc_getbytes()
-    sub bf_pos bf
-    call alsa_write((value_set),random_key,bf_pos,buffer_size)
-endfunction
-
-function sound_preview_playback_handle()
-    data playback_handle#1
-    return #playback_handle
-endfunction
-
-#bool
-function sound_preview_initialize(sd handle,sd hw_params)
-    sd err
-    setcall err snd_pcm_hw_params_any(handle,hw_params)
-    if err<0
-        str hwini_er="Cannot initialize hardware parameter structure"
-        call texter(hwini_er)
-        return 0
-    endif
-    setcall err snd_pcm_hw_params_set_access(handle,hw_params,(SND_PCM_ACCESS_RW_INTERLEAVED))
-    if err<0
-        str ac_er="Cannot set access type"
-        call texter(ac_er)
-        return 0
-    endif
-    import "stage_sound_bps" stage_sound_bps
-    sd bps
-    setcall bps stage_sound_bps((value_get))
-    if bps==8
-        setcall err snd_pcm_hw_params_set_format(handle,hw_params,(SND_PCM_FORMAT_U8))
-    else
-        setcall err snd_pcm_hw_params_set_format(handle,hw_params,(SND_PCM_FORMAT_S16_LE))
-    endelse
-    if err<0
-        str fr_er="Cannot set bits per sample"
-        call texter(fr_er)
-        return 0
-    endif
-    #last param is int *  dir, Sub unit direction
-    import "stage_sound_rate" stage_sound_rate
-    sd rate
-    setcall rate stage_sound_rate((value_get))
-    setcall err snd_pcm_hw_params_set_rate(handle,hw_params,rate,0)
-    if err<0
-        str rate_er="Cannot set sample rate"
-        call texter(rate_er)
-        return 0
-    endif
-    import "stage_sound_channels" stage_sound_channels
-    sd channels
-    setcall channels stage_sound_channels((value_get))
-    setcall err snd_pcm_hw_params_set_channels(handle,hw_params,channels)
-    if err<0
-        str ch_er="Cannot set channel count"
-        call texter(ch_er)
-        return 0
-    endif
-    setcall err snd_pcm_hw_params(handle,hw_params)
-    if err<0
-        str hwpar_er="Cannot set parameters"
-        call texter(hwpar_er)
-        return 0
-    endif
-    #
-    setcall err snd_pcm_prepare(handle)
-    if err<0
-        str inter_er="Cannot prepare audio interface for use"
-        call texter(inter_er)
-        return 0
-    endif
-    return 1
-endfunction
-
-function alsa_write(sd procedure,sd random_key,sd bf_pos,sd all_buffer_size)
-    # send in parts or all size
-    #values
-    sd handle
-    setcall handle sound_preview_playback_handle()
-    if handle#==0
-        return (void)
-    endif
-    data pos#1
-    data buffer_size#1
-    data wait_bufferfull_timeout#1
-    if procedure==(value_extra)
-        set buffer_size 0
-        set wait_bufferfull_timeout 0
-        call alsa_full_set((value_set),#wait_bufferfull_timeout)
-        return (void)
-    endif
-    #all values are in frames(blockalign values) except pos
-    importx "gdk_threads_add_timeout" gdk_threads_add_timeout
-    sd main_frames
-    sd period_size
-    sd err
-    import "stage_sound_blockalign" stage_sound_blockalign
-    sd blockalign
-    setcall blockalign stage_sound_blockalign()
-    if procedure==(value_set)
-        if buffer_size!=0
-            div all_buffer_size blockalign
-            add buffer_size all_buffer_size
-            if wait_bufferfull_timeout==1
-                #a timeout will resolve the new sound
-                return (void)
-            endif
-        else
-            set pos bf_pos
-            set buffer_size all_buffer_size
-            div buffer_size blockalign
-        endelse
-    endif
-    sd low_size
-    setcall low_size alsa_low_size(pos,buffer_size)
-    if low_size==1
-        return (void)
-    endif
-    #get available size
-    sd avail_size
-    setcall avail_size alsa_get_availsize(handle#)
-    if avail_size<0
-        return (void)
-    endif
-    #see the remaining size
-    sd write_size
-    set write_size buffer_size
-    if buffer_size>avail_size
-        set write_size avail_size
-    endif
-    #write the data
-    import "stage_sound_subsize" stage_sound_subsize
-    sd buffer
-    sd rawsize
-    set rawsize write_size
-    mult rawsize blockalign
-    set buffer pos
-    add buffer rawsize
-    sd currentsize
-    setcall currentsize stage_sound_subsize((value_get))
-    if buffer>currentsize
-        str sz_err="Size error"
-        call texter(sz_err)
-        return (void)
-    endif
-    sub buffer rawsize
-    addcall buffer stage_sound_alloc_getbytes()
-    #
-    sd frames_wrote
-    setcall frames_wrote snd_pcm_writei(handle#,buffer,write_size)
-    if frames_wrote!=write_size
-        str wrerr="Write to audio interface failed"
-        call texter(wrerr)
-        return (void)
-    endif
-    #timeout for next data
-    if buffer_size>avail_size
-        set wait_bufferfull_timeout 1
-        #set buffer and buffer size for next part
-        add pos rawsize
-        #wait half main buffer to be played
-        setcall err alsa_get_params(handle#,#main_frames,#period_size)
-        if err<0
-            return (void)
-        endif
-        div main_frames 2
-        #main_frames     x
-        #sample rate     1000 millisec
-        sd timeout_space=1000
-        mult timeout_space main_frames
-        divcall timeout_space stage_sound_rate((value_get))
-        data f^alsa_write_timeout_callback
-        call gdk_threads_add_timeout(timeout_space,f,random_key)
-    endif
-    sub buffer_size write_size
-    return (void)
-endfunction
-
-function alsa_full_set(sd procedure,sd ptr)
-    data p#1
-    if procedure==(value_set)
-        set p ptr
-    else
-        return p
-    endelse
-endfunction
-
-#alsa return
-function alsa_get_params(sd handle,sd frames,sd period)
-    sd err
-    setcall err snd_pcm_get_params(handle,frames,period)
-    if err<0
-        str geterr="Cannot get params"
-        call texter(geterr)
-    endif
-    return err
-endfunction
-#alsa return
-function alsa_get_availsize(sd handle)
-    sd avail_size
-    setcall avail_size snd_pcm_avail_update(handle)
-    if avail_size<0
-        str av_err="Avail size function error"
-        call texter(av_err)
-    endif
-    return avail_size
-endfunction
-
-function alsa_write_timeout_callback(sd key)
-    #reset the timeout pointer
-    sd p
-    setcall p alsa_full_set((value_get))
-    set p# 0
-    call alsa_write_and_verify_key(key)
-    #0 for not called again
-    return 0
-endfunction
-
-function alsa_write_and_verify_key(sd key)
-    sd k
-    import "sound_random_key" sound_random_key
-    setcall k sound_random_key()
-    if k#==key
-        #k#!=key means another frame pressed
-        call alsa_write((value_run),key)
-    endif
-endfunction
-
-function alsa_low_size(sd pos,sd buffer_size)
-    #reach a size for write limit
-    sd rate
-    setcall rate stage_sound_rate((value_get))
-    if buffer_size<rate
-        sd blockalign
-        setcall blockalign stage_sound_blockalign()
-        mult buffer_size blockalign
-        add pos buffer_size
-        sd currentsize
-        setcall currentsize stage_sound_subsize((value_get))
-        if pos<currentsize
-            #low_size= true, wait for more
-            return 1
-        endif
-    endif
-    return 0
-endfunction
-
-const SND_PCM_STATE_RUNNING=3
-
-#bool
-function sound_preview_end_and_no_errors()
-    import "snd_pcm_status_malloc" snd_pcm_status_malloc
-    import "snd_pcm_status_free" snd_pcm_status_free
-    sd handle
-    setcall handle sound_preview_playback_handle()
-    sd status
-    sd er
-    setcall er snd_pcm_status_malloc(#status)
-    if er<0
-        str alloc="snd_pcm_status_malloc error"
-        call texter(alloc)
-        return (FALSE)
-    endif
-    sd bool
-    setcall bool sound_preview_end_and_no_errors_continuation(handle#,status)
-    call snd_pcm_status_free(status)
-    return bool
-endfunction
-#bool
-function sound_preview_end_and_no_errors_continuation(sd handle,sd status)
-    import "snd_pcm_status" snd_pcm_status
-    import "snd_pcm_status_get_state" snd_pcm_status_get_state
-    sd er
-    setcall er snd_pcm_status(handle,status)
-    if er<0
-        str error="snd_pcm_status error"
-        call texter(error)
-        return (FALSE)
-    endif
-    sd state
-    setcall state snd_pcm_status_get_state(status)
-    if state==(SND_PCM_STATE_RUNNING)
-        return (FALSE)
-    endif
-    return (TRUE)
-endfunction
-
-
-#html 1
-#	enter leave  B
-#img
-#	enter leave data    1 at img enter leave at init A(has recurse in edit)   1 img edit enter leave at cover/frame B
-#	stage get image 1   at frames,selectframe B
-#version 1    A
-#
-#
-#captures
-#	init 1    A
-#	1         B
-#sys
-#	init 1    A
-#	sys enter leave 4(init 1 A ,dialog 1 B,stage 2 B)
-#
-#
-#1 at A to share from img to version, next to home: init_user, at sys
-#
-#this was with er, rest are with texter
-#
-#captures changes to home  return
-#sys 3 changes to home     enterleave
-#html changes to share     enterleave
-#img cover/frame to share  enterleave
-#img frames to share       return
-
-importx "getenv" getenv
-
-import "init_dir" init_dir
-import "dirch" dirch
-
-#e
-function move_to_folder(sd f)
-	sd change
-	setcall change chd(f)
-	if change!=0
-		return "Change dir error at init."
-	endif
-	return (noerror)
-endfunction
-#e
-function move_to_home()
-	sd f
-	sd er
-	setcall er home_folder(#f,(NULL))
-	if er==(noerror)
-		setcall er init_dir(f)
-		if er==(noerror)
-			setcall er move_to_folder(f)
-		endif
-	endif
-	return er
-endfunction
-function move_to_home_v()
-	sd f
-	setcall f home_folder_r((NULL))
-	if f!=(NULL)
-		call dirch(f)
-	endif
-endfunction
-function move_to_home_core(sv p)
-	sv mem
-	setcall mem home_folder_function()
-	set mem mem#
-	if mem!=(NULL)
-		sd f
-		sd h
-		setcall f home_folder_r(#h)
-		if f!=(NULL)
-			sd b
-			setcall b cat_absolute_verif(mem,h,f,p#)
-			if b==(TRUE)
-				set p# mem
-			endif
-		endif
-	endif
-endfunction
-function move_to_share_v()
-	sd f
-	setcall f share_folder()
-	call dirch(f)
-endfunction
-function move_to_share_core(sv p)
-	sv mem
-	setcall mem share_folder_function()
-	set mem mem#
-	if mem!=(NULL)
-		sd f
-		setcall f share_folder()
-		sd b
-		setcall b cat_absolute_verif(mem,f,p#,(NULL))
-		if b==(TRUE)
-			set p# mem
-		endif
-	endif
-endfunction
-importx "access" access
-#er
-function uninit_start()
-	sd f
-	sd er
-	setcall er home_folder(#f,(NULL))
-	if er==(noerror)
-		sd a;setcall a access(f,(F_OK))
-		if a==0
-			setcall er move_to_folder(f)
-		else
-			return (error)
-		endelse
-	endif
-	return er
-endfunction
-#path
-function real_path(sd p)
-importx "realpath" realpath
-	sd mem;setcall mem realpath(p,(NULL))
-	return mem
-endfunction
-
-#e
-function home_folder(sv pf,sv ph)
-	ss envpath
-	setcall envpath getenv("HOME")
-	if envpath!=(NULL)
-		vstr a="ovideo"
-		if ph==(NULL)
-			sd err
-			setcall err move_to_folder(envpath)
-			if err!=(noerror)
-				return err
-			endif
-			set pf# a
-		else
-			set ph# envpath
-			set pf# a
-		endelse
-		return (noerror)
-	endif
-	return "Getenv error at home folder."
-endfunction
-#string/0
-function home_folder_r(sd p)
-	sd er
-	sd f
-	setcall er home_folder(#f,p)
-	if er==(noerror)
-		return f
-	endif
-	call texter(er)
-	return (NULL)
-endfunction
-#string
-function share_folder()
-	include "share.txt"
-endfunction
-
-#cmp
-function init_args(sd argc)
-	if argc>1
-		sd er;setcall er uninit_start()
-		if er==(noerror)
-			import "uninit_print" uninit_print
-			import "uninit_print_entry" uninit_print_entry
-			sv c;sv s;setcall s uninit_print(#c)
-			vstr current_folder="."
-			call uninit_print_entry(current_folder)
-			import "uninit_decision" uninit_decision
-			sd b;setcall b uninit_decision()
-			if b==(TRUE)
-				import "uninit_delete" uninit_delete
-				call uninit_delete(s,c)
-				import "uninit_delete_folder" uninit_delete_folder
-				call uninit_delete_folder(current_folder)
-			endif
-		endif
-		return 0
-	endif
-	return -1
-endfunction
-
-const PATH_MAX=4096
-importx "malloc" malloc
-importx "free" free
-importx "strlen" strlen
-importx "sprintf" sprintf
-
-function prog_init()
-	sv a
-	setcall a home_folder_function()
-	set a# (NULL)
-	sv b
-	setcall b share_folder_function()
-	set b# (NULL)
-	vstr s="malloc error."
-	sd c
-	setcall c malloc((PATH_MAX))
-	if c!=(NULL)
-		set a# c
-		setcall c malloc((PATH_MAX))
-		if c!=(NULL)
-			set b# c
-			return (void)
-		endif
-	endif
-	call texter(s)
-endfunction
-function prog_free()
-	sv a
-	setcall a home_folder_function()
-	if a#!=(NULL)
-		call free(a#)
-		setcall a share_folder_function()
-		if a#!=(NULL)
-			call free(a#)
-		endif
-	endif
-endfunction
-
-function home_folder_function()
-	value p#1
-	return #p
-endfunction
-function share_folder_function()
-	value p#1
-	return #p
-endfunction
-
-function cat_absolute_verif(sd mem,sd v,sd v2,sd v3)
-	sd s
-	setcall s strlen(v)
-	inc s
-	addcall s strlen(v2)
-	if v3!=(NULL)
-		inc s
-		addcall s strlen(v3)
-	endif
-	if s<(PATH_MAX)
-		sd n
-		setcall n sprintf(mem,"%s/%s",v,v2)
-		if v3!=(NULL)
-			add mem n
-			call sprintf(mem,"/%s",v3)
-		endif
-		return (TRUE)
-	endif
-	call texter("path max error.")
-	return (FALSE)
-endfunction
-
-function ulltoa(sd low,sd high,sd str)
-	call sprintf(str,"%llu",low,high)
-endfunction
--- /dev/null
+++ ovideo-1/src/_dif/dif~win.oc
@@ -0,0 +1,988 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+Const GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2
+
+importx "_GetModuleFileNameA@12" GetModuleFileName
+importx "_free" free
+
+import "memoryalloc" memoryalloc
+import "texter" texter
+
+const MAX_PATH=260
+#err
+function Scriptfullpath(sv ptrfullpath)
+	data MAX_PATH=MAX_PATH
+	sd err
+	setcall err memoryalloc(MAX_PATH,ptrfullpath)
+	if err=(noerror)
+		data size#1
+		setcall size GetModuleFileName((NULL),ptrfullpath#,MAX_PATH)
+		if size!=(NULL)
+			return (noerror)
+		endif
+		call free(ptrfullpath#)
+		set err "Error."
+		call texter(err)
+	endif
+	return err
+endfunction
+
+import "dirch" dirch
+
+#void/err
+function movetoScriptfolder(data forward)
+	data path#1
+	data ptrpath^path
+	data err#1
+	data noerr=noerror
+	setcall err Scriptfullpath(ptrpath)
+	if err=noerr
+		data pointer#1
+		char z=0
+		setcall pointer endoffolders(path)
+		set pointer# z
+		setcall err dirch(path)
+		if err=noerr
+			call forward()
+		endif
+		call free(path)
+	endif
+	return err
+endfunction
+
+import "slen" slen
+
+
+#true if match or false
+Function filepathdelims(char chr)
+        char bslash="\\"
+        char slash="/"
+        Data true=TRUE
+        Data false=FALSE
+        If chr=bslash
+                Return true
+        EndIf
+        If chr=slash
+                Return true
+        EndIf
+        Return false
+EndFunction
+
+#folders ('c:\folder\file.txt' will be pointer starting at 'file.txt')
+Function endoffolders(ss path)
+    sd sz
+    setcall sz slen(path)
+    ss cursor
+    set cursor path
+    add cursor sz
+    sd i=0
+    while i<sz
+        dec cursor
+        sd bool
+        setcall bool filepathdelims(cursor#)
+        if bool=(TRUE)
+            inc cursor
+            return cursor
+        endif
+        inc i
+    endwhile
+    return path
+EndFunction
+
+importx "__get_errno" get_errno
+#errno
+function geterrno()
+    sd er
+    call get_errno(#er)
+    return er
+endfunction
+
+
+importx "_gdk_win32_drawable_get_handle" gdk_win32_drawable_get_handle
+function gdkGetdrawable(data window)
+    data windraw#1
+    setcall windraw gdk_win32_drawable_get_handle(window)
+    return windraw
+endfunction
+
+function system_variables_alignment_pad(data value,data greatest)
+    sub greatest value
+    return greatest
+endfunction
+
+
+importx "__time32" time
+function timeNode(data ptrtime_t)
+    data time_t#1
+    setcall time_t time(ptrtime_t)
+    return time_t
+endfunction
+
+importx "_chdir" chd
+function chdr(str value)
+    data x#1
+    setcall x chd(value)
+    return x
+endfunction
+
+importx "_snprintf" snprintf
+function c_snprintf_strvaluedisp(str display,data max,str format,str text,data part2)
+    call snprintf(display,max,format,text,part2)
+endfunction
+
+
+
+
+importx "_gtk_file_chooser_get_filename_utf8" gtk_file_chooser_get_filename_utf8
+function file_chooser_get_fname(sd dialog)
+    sd file
+    setcall file gtk_file_chooser_get_filename_utf8(dialog)
+    return file
+endfunction
+
+
+
+
+
+
+#jpeg
+
+function jpeg_get_jdestruct_size()
+    return (jdestruct_size_win)
+endfunction
+
+
+function jpeg_get_jdestruct_output_width()
+    return (jdestruct_output_width_win)
+endfunction
+function jpeg_get_jdestruct_output_height()
+    return (jdestruct_output_height_win)
+endfunction
+function jpeg_get_jdestruct_output_components()
+    return (jdestruct_output_components_win)
+endfunction
+
+#
+
+##times
+
+#milliseconds
+function get_time()
+    importx "_GetTickCount@0" GetTickCount
+    sd milliseconds
+    setcall milliseconds GetTickCount()
+    return milliseconds
+endfunction
+
+function sleepMs(sd value)
+    importx "_Sleep@4" Sleep
+    call Sleep(value)
+endfunction
+
+
+#######gdi alternative capture
+
+const SRCCOPY=0x00CC0020
+const DIB_RGB_COLORS=0
+
+function dest_dc(sd action,sd value)
+    data dc#1
+    if action=(value_set)
+        set dc value
+    else
+        return dc
+    endelse
+endfunction
+function dest_dib(sd action,sd value)
+    data dib#1
+    if action=(value_set)
+        set dib value
+    else
+        return dib
+    endelse
+endfunction
+function gdi_toggle(sd action,sd value)
+    data gdi_entry#1
+    if action=(value_set)
+        set gdi_entry value
+    else
+        return gdi_entry
+    endelse
+endfunction
+
+function capture_alternative_init(sd vbox)
+    importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
+    importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
+    importx "_gtk_container_add" gtk_container_add
+    ss gdi_txt="Use GDI"
+    sd gdi_entry
+    setcall gdi_entry gtk_check_button_new_with_label(gdi_txt)
+    call gdi_toggle((value_set),gdi_entry)
+    call gtk_toggle_button_set_active(gdi_entry,1)
+    call gtk_container_add(vbox,gdi_entry)
+
+##folder
+    import "hseparatorfield" hseparatorfield
+    call hseparatorfield(vbox)
+
+    importx "_gtk_table_new" gtk_table_new
+    importx "_gtk_table_attach" gtk_table_attach
+    import "buttonfield_prepare_with_label" buttonfield_prepare_with_label
+    import "connect_clicked" connect_clicked
+    importx "_gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
+    sd table
+    setcall table gtk_table_new(4,1,0)
+
+    ss onefolder="Folder captures to file"
+    sd one
+    setcall one buttonfield_prepare_with_label(onefolder)
+    data f_one^mass_folder
+    call connect_clicked(one,f_one)
+    ss inf="All mkv(i420,mjpeg,rgb) files from a folder to an avi(i420,mjpeg,mpg4-asp) file"
+    call gtk_widget_set_tooltip_markup(one,inf)
+    call gtk_table_attach(table,one,0,1,0,1,(GTK_FILL),0,0,0)
+
+    ss allfolders="Folder folders captures to files"
+    sd all
+    setcall all buttonfield_prepare_with_label(allfolders)
+    data f_many^mass_many_folders
+    call connect_clicked(all,f_many)
+    ss all_inf="All mkv(i420,mjpeg,rgb) files from a folder from all folders to avi(i420,mjpeg,mpg4-asp) files"
+    call gtk_widget_set_tooltip_markup(all,all_inf)
+    call gtk_table_attach(table,all,0,1,1,2,(GTK_FILL),0,0,0)
+
+    import "labelfield_left_prepare" labelfield_left_prepare
+    ss wr="Warning! This will remove the stage video and sound!"
+    sd info
+    setcall info labelfield_left_prepare(wr)
+    call gtk_table_attach(table,info,0,1,2,3,(GTK_FILL),0,0,0)
+
+    ss allfolders_poweroff="Folder folders captures + Shut Down"
+    sd all_poweroff
+    setcall all_poweroff buttonfield_prepare_with_label(allfolders_poweroff)
+    data f_many_poweroff^mass_many_folders_with_poweroff
+    call connect_clicked(all_poweroff,f_many_poweroff)
+    call gtk_table_attach(table,all_poweroff,0,1,3,4,(GTK_FILL),0,0,0)
+
+    import "packstart_default" packstart_default
+    call packstart_default(vbox,table)
+
+    call hseparatorfield(vbox)
+##
+endfunction
+function capture_alternative_set(sd p_no_alternative)
+    sd gdi_entry
+    setcall gdi_entry gdi_toggle((value_get))
+    importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
+    setcall p_no_alternative# gtk_toggle_button_get_active(gdi_entry)
+    xor p_no_alternative# 1
+endfunction
+#bool
+function capture_alternative_prepare(sd p_mem,sd pix_width,sd pix_height)
+    importx "_GetWindowDC@4" GetWindowDC
+    importx "_CreateCompatibleDC@4" CreateCompatibleDC
+    importx "_SelectObject@8" SelectObject
+    importx "_DeleteObject@4" DeleteObject
+    importx "_CreateDIBSection@24" CreateDIBSection
+
+    sd srcDC
+    setcall srcDC GetWindowDC(0)
+    sd destDC
+    setcall destDC CreateCompatibleDC(srcDC)
+    if destDC=0
+        str no_dc="DC error"
+        call texter(no_dc)
+        return 0
+    endif
+    call dest_dc((value_set),destDC)
+
+    #BITMAPINFO
+    data biSize=40
+    data biWidth#1
+    data biHeight#1
+    char *biPlanes={1,0}
+    char *biBitCount={24,0}
+    data *biCompression=0
+    data biSizeImage#1
+    data *biXPelsPerMeter=0
+    data *biYPelsPerMeter=0
+    data *biClrUsed=0
+    data *biClrImportant=0
+    char *bmiColors=0
+
+    data bitmap^biSize
+    set biWidth pix_width
+    set biHeight pix_height
+    import "rgb_get_size" rgb_get_size
+    setcall biSizeImage rgb_get_size(biWidth,biHeight)
+
+    sd dib
+    setcall dib CreateDIBSection(destDC,bitmap,(DIB_RGB_COLORS),p_mem,0,0)
+    if dib=0
+        call DeleteObject(destDC)
+        str no_dib="DIB error"
+        call texter(no_dib)
+        return 0
+    endif
+    call dest_dib((value_set),dib)
+    call SelectObject(destDC,dib)
+    return 1
+endfunction
+function capture_alternative_append(sd x,sd y,sd pix_width,sd pix_height,sd cursor_flag)
+    importx "_BitBlt@36" BitBlt
+    importx "_GetCursorInfo@4" GetCursorInfo
+    importx "_DrawIcon@16" DrawIcon
+    sd srcDC
+    setcall srcDC GetWindowDC(0)
+    sd destDC
+    setcall destDC dest_dc((value_get))
+    call BitBlt(destDC,0,0,pix_width,pix_height,srcDC,x,y,(SRCCOPY))
+    if cursor_flag=1
+        #CURSORINFO
+        data cbSize#1
+        data *flags#1
+        data hCursor#1
+        data ptScreenPos_x#1
+        data ptScreenPos_y#1
+
+        data CursorInfo^cbSize
+        set cbSize 20
+        call GetCursorInfo(CursorInfo)
+
+        sub ptScreenPos_x x
+        sub ptScreenPos_y y
+        call DrawIcon(destDC,ptScreenPos_x,ptScreenPos_y,hCursor)
+    endif
+endfunction
+function capture_alternative_free()
+    sd destDIB
+    setcall destDIB dest_dib((value_get))
+    call DeleteObject(destDIB)
+    sd destDC
+    setcall destDC dest_dc((value_get))
+    call DeleteObject(destDC)
+endfunction
+
+function capture_alt_ev_wait()
+endfunction
+function capture_alt_ev_set()
+endfunction
+
+###############mass capture to file
+
+function mass_folder()
+    sd foldername
+    setcall foldername mass_init_file()
+    call mass_foldername(foldername)
+endfunction
+
+function mass_foldername(ss foldername)
+    #don't display the result message inter-files
+    import "stage_file_options_info_message" stage_file_options_info_message
+    sd info
+    setcall info stage_file_options_info_message((value_get))
+    call stage_file_options_info_message((value_set),0)
+
+    ss spec="*.mkv"
+    data forwrd^mass_folder_file
+    sd counter=0
+    sd p_counter^counter
+    #fileiterate frees the foldername
+    #fileiterate returns if folder==0
+    call fileiterate(foldername,spec,forwrd,p_counter)
+
+    call stage_file_options_info_message((value_set),info)
+endfunction
+
+function fileiterate(ss foldername,ss spec,sd forward,sd data)
+    if foldername=0
+        return 0
+    endif
+    sd p_foldername^foldername
+    call fileiteration(p_foldername,spec,forward,data)
+    call free(foldername)
+endfunction
+
+function fileiteration(sd p_foldername,ss spec,sv forward,sd data)
+    sd folderlen
+    setcall folderlen slen(p_foldername#)
+    inc folderlen
+    sd speclen
+    setcall speclen slen(spec)
+    inc speclen
+
+    sd flen
+    set flen folderlen
+    add flen speclen
+
+    import "memrealloc" memrealloc
+    import "cpymem" cpymem
+    sd foldername
+    setcall foldername memrealloc(p_foldername#,flen)
+    if foldername=0
+        return 0
+    endif
+    set p_foldername# foldername
+
+    ss path
+    set path foldername
+    add path folderlen
+    dec path
+    char bslash="\\"
+    set path# bslash
+    inc path
+    call cpymem(path,spec,speclen)
+
+    data attrib#1
+    data *attrib_align#1
+    data *time_create#2
+    data *time_access#2
+    data *time_write#2
+    data *size#1
+    char name#260
+
+    data file_info^attrib
+    str fname^name
+    char reserve_name#260
+    str reserve^reserve_name
+
+    importx "__findfirst64i32" findfirst
+    importx "__findnext64i32" findnext
+    importx "__findclose" findclose
+
+    sd handle
+    setcall handle findfirst(foldername,file_info)
+    if handle=-1
+        return 0
+    endif
+    str onedot="."
+    str twodots=".."
+    sd cmp
+
+    set path fname
+    add path folderlen
+    sd end=0
+    while end=0
+        sd namelen
+        setcall namelen slen(fname)
+
+        import "cmpmem_s" cmpmem_s
+        sd verify=1
+        setcall cmp cmpmem_s(fname,namelen,onedot,1)
+        if cmp!=(equalCompare)
+            setcall cmp cmpmem_s(fname,namelen,twodots,2)
+        endif
+        if cmp=(equalCompare)
+            set verify 0
+        endif
+
+        if verify=1
+            inc namelen
+            call cpymem(reserve,fname,namelen)
+            call cpymem(fname,foldername,folderlen)
+            call cpymem(path,reserve,namelen)
+            call forward(fname,attrib,data)
+        endif
+        setcall end findnext(handle,file_info)
+    endwhile
+    call findclose(handle)
+endfunction
+
+function mass_folder_file(ss name,sd *attrib,sd p_counter)
+    import "stage_prepare" stage_prepare
+    call stage_prepare()
+    import "stage_mkv_read" stage_mkv_read
+    call stage_mkv_read(name)
+    if p_counter#=0
+        import "aviwrite" aviwrite
+        str location#1
+        sd counter
+        setcall counter files_counter((value_get))
+        setcall location aviwrite(1,counter)
+        inc counter
+        call files_counter((value_set),counter)
+    else
+        import "avi_write_fname" avi_write_fname
+        call avi_write_fname(location,(avi_expand))
+    endelse
+    inc p_counter#
+endfunction
+
+#foldername/0
+function mass_init_file()
+    import "is_local_avi" is_local_avi
+    sd bool
+    setcall bool is_local_avi()
+    if bool=0
+        import "message_dialog" message_dialog
+        ss er="Set avi(i420,mjpeg,mpg4-asp) from the Stage Options"
+        call message_dialog(er)
+        return 0
+    endif
+    call files_counter((value_set),0)
+    sd foldername
+    setcall foldername filechooserfield_folder()
+    return foldername
+endfunction
+
+##all folders
+
+function mass_many_folders()
+    call mass_many_folders_poweroff(0)
+endfunction
+function mass_many_folders_with_poweroff()
+    call mass_many_folders_poweroff(1)
+endfunction
+
+function mass_many_folders_poweroff(sd poweroff_flag)
+    sd foldername
+    setcall foldername mass_init_file()
+
+    ss nullstr="*"
+    data forwrd^mass_all_folders
+    #fileiterate frees the foldername
+    #fileiterate returns if folder==0
+    call fileiterate(foldername,nullstr,forwrd,0)
+
+    if foldername=0
+        return 0
+    endif
+    if poweroff_flag=1
+        call shutdown()
+    endif
+endfunction
+
+const _A_SUBDIR=0x10
+
+function mass_all_folders(ss filefolder_entry,sd attrib)
+    and attrib (_A_SUBDIR)
+    if attrib!=0
+        import "memalloc" memalloc
+        sd len
+        setcall len slen(filefolder_entry)
+        inc len
+        sd mem
+        setcall mem memalloc(len)
+        if mem=0
+            return 0
+        endif
+        call cpymem(mem,filefolder_entry,len)
+        call mass_foldername(mem)
+    endif
+endfunction
+
+function files_counter(sd action,sd value)
+    data counter#1
+    if action=(value_set)
+        set counter value
+    else
+        return counter
+    endelse
+endfunction
+
+const INFINITE=-1
+
+function shutdown()
+    importx "_CreateProcessA@40" CreateProcess
+    import "setmemzero" setmemzero
+    const startupsize=68
+    char startup#startupsize
+    str startupInfo^startup
+    call setmemzero(startupInfo,(startupsize))
+
+    data hprocess#1
+    data hthread#1
+    char *rest_hproc#16-4-4
+
+    data procinfo^hprocess
+
+    str comm="shutdown /p"
+    sd bool
+    setcall bool CreateProcess(0,comm,0,0,0,0,0,0,startupInfo,procinfo)
+    if bool=0
+        str er="CreateProcess failed"
+        call texter(er)
+        return 0
+    endif
+    importx "_WaitForSingleObject@8" WaitForSingleObject
+    importx "_CloseHandle@4" CloseHandle
+    call WaitForSingleObject(hprocess,(INFINITE))
+    call CloseHandle(hprocess)
+    call CloseHandle(hthread)
+endfunction
+
+
+#file seek dif
+
+#er
+function file_seek_dif_cursor(sd file,sd off)
+    importx "__fseeki64" fseek64
+    import "seek_err" seek_err
+    sd int
+    setcall int fseek64(file,off,0,(SEEK_CUR))
+    sd err
+    setcall err seek_err(int)
+    return err
+endfunction
+
+#sound preview
+importx "_waveOutOpen@24" waveOutOpen
+importx "_waveOutClose@4" waveOutClose
+importx "_waveOutReset@4" waveOutReset
+importx "_waveOutPrepareHeader@12" waveOutPrepareHeader
+importx "_waveOutUnprepareHeader@12" waveOutUnprepareHeader
+importx "_waveOutWrite@12" waveOutWrite
+
+import "stage_sound_channels" stage_sound_channels
+import "stage_sound_rate" stage_sound_rate
+import "stage_sound_bps" stage_sound_bps
+
+import "stage_sound_blockalign" stage_sound_blockalign
+import "stage_sound_avgbytespersec" stage_sound_avgbytespersec
+
+const MMSYSERR_NOERROR=0
+const WAVE_MAPPER=-1
+const CALLBACK_NULL=0
+#const CALLBACK_FUNCTION=0x30000
+#const WOM_DONE=0x3BD
+const WAVE_FORMAT_PCM=1
+
+function sound_preview_mm_hwaveout()
+    data hwaveout#1
+    return #hwaveout
+endfunction
+import "sound_preview_buffers" sound_preview_buffers
+function sound_mm_buffers()
+    data bf#1
+    return #bf
+endfunction
+function sound_mm_buffers_get()
+    sd bf
+    setcall bf sound_mm_buffers()
+    return bf#
+endfunction
+function sound_mm_buffers_set()
+    sd nmbr=10
+    addcall nmbr sound_preview_buffers()
+    sd bf
+    setcall bf sound_mm_buffers()
+    set bf# nmbr
+endfunction
+
+const sound_preview_buffers_max=128
+
+function sound_preview_write_buffer(sd buffer,sd buffer_size)
+    sd hwaveout
+    setcall hwaveout sound_preview_mm_hwaveout()
+    if hwaveout#=0
+        return (void)
+    endif
+	const wvhd=\
+    data lpData#1
+    data dwBufferLength#1
+    data *dwBytesRecorded#1
+    data *dwUser#1
+    data *dwFlags=0
+    data *dwLoops#1
+    data *lpNext#1
+    data *reserved#1
+    #lpData, dwBufferLength, and dwFlags members must be set
+#    const wvhd^lpData
+    const wvhd_size=\-wvhd
+    data wavehd%wvhd
+
+    set lpData buffer
+    set dwBufferLength buffer_size
+    data waveheaders_index#1
+    inc waveheaders_index
+
+    import "rest" rest
+    sd buffers_count
+    setcall buffers_count sound_mm_buffers_get()
+    sd pos
+    setcall pos rest(waveheaders_index,buffers_count)
+    sd waveheader
+    setcall waveheader sound_preview_mm_buffers(pos)
+    #unprepare if prepared
+    call sound_preview_buffers_unprep(pos)
+    #
+    call cpymem(waveheader,wavehd,(wvhd_size))
+
+    sd mm
+    setcall mm waveOutPrepareHeader(hwaveout#,waveheader,(wvhd_size))
+    if mm!=(MMSYSERR_NOERROR)
+        str er="Wave out prepare header error"
+        call texter(er)
+    endif
+    #set bool true
+    call sound_preview_buffers_set(pos)
+    setcall mm waveOutWrite(hwaveout#,waveheader,(wvhd_size))
+    if mm!=(MMSYSERR_NOERROR)
+        str wr_er="Wave out write error"
+        call texter(wr_er)
+    endif
+endfunction
+
+function sound_preview_mm_buffers(sd nr)
+    sd data_ptr
+    setcall data_ptr sound_preview_mm_buffers_data()
+    sd data
+    set data data_ptr#
+    mult nr (wvhd_size)
+    add data nr
+    return data
+endfunction
+function sound_preview_mm_buffers_data()
+    data ptr#1
+    return #ptr
+endfunction
+#function sound_preview_mm_buffers_data_set(sd value)
+#    sd data
+#    setcall data sound_preview_mm_buffers_data()
+#    set data# value
+#endfunction
+
+#
+function sound_preview_buffers_bool()
+    data buffers#sound_preview_buffers_max
+    return #buffers
+endfunction
+function sound_preview_buffers_unprep(sd nr,sd wavehdr)
+    sd bools
+    setcall bools sound_preview_buffers_bool()
+    mult nr (DWORD)
+    add bools nr
+    if bools#=1
+        sd hwo
+        setcall hwo sound_preview_mm_hwaveout()
+        sd waveheader
+        setcall waveheader sound_preview_mm_buffers(nr)
+        call waveOutUnprepareHeader(hwo#,wavehdr)
+        set bools# 0
+    endif
+endfunction
+function sound_preview_buffers_set(sd nr)
+    sd bools
+    setcall bools sound_preview_buffers_bool()
+    mult nr (DWORD)
+    add bools nr
+    set bools# 1
+endfunction
+
+#bool
+function sound_preview_init()
+    sd hwaveout
+    setcall hwaveout sound_preview_mm_hwaveout()
+    set hwaveout# 0
+    sd buffers
+    setcall buffers sound_preview_mm_buffers_data()
+    set buffers# 0
+    #
+    call sound_mm_buffers_set()
+    sd nr
+    setcall nr sound_mm_buffers_get()
+    if nr>(sound_preview_buffers_max)
+        str er="Set a lower fps for sound playback"
+        call texter(er)
+        return 0
+    endif
+    #
+    sd value
+    #WAVEFORMATEX
+    char wFormatTag={WAVE_FORMAT_PCM,0}
+    char nChannels#2
+    data nSamplesPerSec#1
+    data nAvgBytesPerSec#1
+    char nBlockAlign#2
+    char wBitsPerSample#2
+    #EX
+    #no extra data, simple PCM-format used
+    char *cbSize={0,0}
+    #
+    import "int_into_short" int_into_short
+    data WAVEFORMATEX^wFormatTag
+    setcall value stage_sound_channels((value_get))
+    call int_into_short(value,#nChannels)
+    setcall nSamplesPerSec stage_sound_rate((value_get))
+    setcall nAvgBytesPerSec stage_sound_avgbytespersec()
+    setcall value stage_sound_blockalign()
+    call int_into_short(value,#nBlockAlign)
+    setcall value stage_sound_bps((value_get))
+    call int_into_short(value,#wBitsPerSample)
+    #
+    #data f^sound_preview_mm_callback
+    sd res
+    setcall res waveOutOpen(hwaveout,(WAVE_MAPPER),WAVEFORMATEX,0,0,(CALLBACK_NULL))
+    if res!=(MMSYSERR_NOERROR)
+        return 0
+    endif
+    #
+    sd i=0
+    sd bf_bool
+    setcall bf_bool sound_preview_buffers_bool()
+    sd max
+    setcall max sound_mm_buffers_get()
+    while i<max
+        set bf_bool# 0
+        add bf_bool (DWORD)
+        inc i
+    endwhile
+    #
+    sd size=wvhd_size
+    mult size nr
+    sd buffers_space
+    setcall buffers_space memalloc(size)
+    if buffers_space=0
+        call sound_preview_free()
+        return 0
+    endif
+    set buffers# buffers_space
+    #
+    return 1
+endfunction
+
+function sound_preview_free()
+    sd pointer
+    setcall pointer sound_preview_mm_hwaveout()
+    sd hwaveout
+    set hwaveout pointer#
+    if hwaveout!=0
+        call waveOutReset(hwaveout)
+        sd i=0
+        sd max
+        setcall max sound_mm_buffers_get()
+        while i<max
+            call sound_preview_buffers_unprep(i)
+            inc i
+        endwhile
+        call waveOutClose(hwaveout)
+        sd buffers
+        setcall buffers sound_preview_mm_buffers_data()
+        if buffers#!=0
+            call free(buffers#)
+        endif
+    endif
+endfunction
+
+#bool
+function sound_preview_end_and_no_errors()
+    sd i=0
+    sd bools
+    setcall bools sound_preview_buffers_bool()
+    sd max
+    setcall max sound_mm_buffers_get()
+    while i<max
+        if bools#=(TRUE)
+            sd buffer
+            setcall buffer sound_preview_mm_buffers(i)
+            const off_lpData=0
+            const off_dwBufferLength=off_lpData+DWORD
+            const off_dwBytesRecorded=off_dwBufferLength+DWORD
+            const off_dwUser=off_dwBytesRecorded+DWORD
+            const off_dwFlags=off_dwUser+DWORD
+            const WHDR_DONE=1
+            add buffer (off_dwFlags)
+            sd flags
+            set flags buffer#
+            and flags (WHDR_DONE)
+            if flags=0
+                return (FALSE)
+            endif
+        endif
+        add bools (DWORD)
+        inc i
+    endwhile
+    return (TRUE)
+endfunction
+
+import "mainwidget" mainwidget
+importx "_gtk_file_chooser_dialog_new" gtk_file_chooser_dialog_new
+import "filechooserfield_dialog" filechooserfield_dialog
+
+#folder/0
+function filechooserfield_folder()
+    str select_folder="Select Folder"
+    sd main
+    setcall main mainwidget()
+    str GTK_STOCK_CANCEL="gtk-cancel"
+    data responsecancel=GTK_RESPONSE_CANCEL
+    str GTK_STOCK_OK="gtk-ok"
+    sd dialog
+    setcall dialog gtk_file_chooser_dialog_new(select_folder,main,(GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER),GTK_STOCK_CANCEL,responsecancel,GTK_STOCK_OK,(GTK_RESPONSE_ACCEPT),0)
+    sd filename
+    setcall filename filechooserfield_dialog(dialog)
+    return filename
+endfunction
+
+#e
+function move_to_home()
+	return (noerror)
+endfunction
+function move_to_home_v()
+endfunction
+function move_to_share_v()
+endfunction
+function move_to_home_core()
+endfunction
+function move_to_share_core()
+endfunction
+function prog_free()
+endfunction
+
+importx "_ulltoa" ulltoa_extern
+
+function ulltoa(sd low,sd high,sd instr)
+	call ulltoa_extern(low,high,instr,10)
+endfunction
+
+
+Importx "_GetCommandLineW@0" GetCommandName
+Importx "_CommandLineToArgvW@8" CommandLineToArgvW
+
+#cmp
+function init_args()
+	sd command_name
+	#sd commname_size
+	sd argc;sv argv
+
+	sd cmp=-1
+
+	SetCall command_name GetCommandName()
+
+	#this is so bugged but accepted , strlen is ansi, but no wide path in this program, so first XX00h will stop
+	#anyway argv0 can't be '\0'
+	#SetCall commname_size strlen(command_name)
+	#If commname_size!=0
+	setcall argv CommandLineToArgvW(command_name,#argc)
+	if argv!=(NULL)
+		if argc>1
+			set cmp 0
+			#sd a1=:;add a1 argv
+			#call wide_to_ansi(a1#) #same as ocompiler
+			#importx "_strcmp" strcmp
+			#setcall cmp strcmp(a1#,"--remove-config")
+
+			import "uninit_print" uninit_print
+			sv c;sv s;setcall s uninit_print(#c)
+			import "uninit_decision" uninit_decision
+			sd b;setcall b uninit_decision()
+			if b=(TRUE)
+				import "uninit_delete" uninit_delete
+				call uninit_delete(s,c)
+			endif
+		endif
+		call free(argv)
+	endif
+	#EndIf
+	return cmp
+endfunction
+importx "__fullpath" fullpath
+#path
+function real_path(sd path)
+	sd mem;setcall mem fullpath((NULL),path,(MAX_PATH))
+	return mem
+endfunction
--- ovideo-1.orig/src/_dif/dif~win.s
+++ /dev/null
@@ -1,988 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-Const GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2
-
-importx "_GetModuleFileNameA@12" GetModuleFileName
-importx "_free" free
-
-import "memoryalloc" memoryalloc
-import "texter" texter
-
-const MAX_PATH=260
-#err
-function Scriptfullpath(sv ptrfullpath)
-	data MAX_PATH=MAX_PATH
-	sd err
-	setcall err memoryalloc(MAX_PATH,ptrfullpath)
-	if err==(noerror)
-		data size#1
-		setcall size GetModuleFileName((NULL),ptrfullpath#,MAX_PATH)
-		if size!=(NULL)
-			return (noerror)
-		endif
-		call free(ptrfullpath#)
-		set err "Error."
-		call texter(err)
-	endif
-	return err
-endfunction
-
-import "dirch" dirch
-
-#void/err
-function movetoScriptfolder(data forward)
-	data path#1
-	data ptrpath^path
-	data err#1
-	data noerr=noerror
-	setcall err Scriptfullpath(ptrpath)
-	if err==noerr
-		data pointer#1
-		char z=0
-		setcall pointer endoffolders(path)
-		set pointer# z
-		setcall err dirch(path)
-		if err==noerr
-			call forward()
-		endif
-		call free(path)
-	endif
-	return err
-endfunction
-
-import "slen" slen
-
-
-#true if match or false
-Function filepathdelims(char chr)
-        char bslash="\\"
-        char slash="/"
-        Data true=TRUE
-        Data false=FALSE
-        If chr==bslash
-                Return true
-        EndIf
-        If chr==slash
-                Return true
-        EndIf
-        Return false
-EndFunction
-
-#folders ('c:\folder\file.txt' will be pointer starting at 'file.txt')
-Function endoffolders(ss path)
-    sd sz
-    setcall sz slen(path)
-    ss cursor
-    set cursor path
-    add cursor sz
-    sd i=0
-    while i<sz
-        dec cursor
-        sd bool
-        setcall bool filepathdelims(cursor#)
-        if bool==(TRUE)
-            inc cursor
-            return cursor
-        endif
-        inc i
-    endwhile
-    return path
-EndFunction
-
-importx "__get_errno" get_errno
-#errno
-function geterrno()
-    sd er
-    call get_errno(#er)
-    return er
-endfunction
-
-
-importx "_gdk_win32_drawable_get_handle" gdk_win32_drawable_get_handle
-function gdkGetdrawable(data window)
-    data windraw#1
-    setcall windraw gdk_win32_drawable_get_handle(window)
-    return windraw
-endfunction
-
-function system_variables_alignment_pad(data value,data greatest)
-    sub greatest value
-    return greatest
-endfunction
-
-
-importx "__time32" time
-function timeNode(data ptrtime_t)
-    data time_t#1
-    setcall time_t time(ptrtime_t)
-    return time_t
-endfunction
-
-importx "_chdir" chd
-function chdr(str value)
-    data x#1
-    setcall x chd(value)
-    return x
-endfunction
-
-importx "_snprintf" snprintf
-function c_snprintf_strvaluedisp(str display,data max,str format,str text,data part2)
-    call snprintf(display,max,format,text,part2)
-endfunction
-
-
-
-
-importx "_gtk_file_chooser_get_filename_utf8" gtk_file_chooser_get_filename_utf8
-function file_chooser_get_fname(sd dialog)
-    sd file
-    setcall file gtk_file_chooser_get_filename_utf8(dialog)
-    return file
-endfunction
-
-
-
-
-
-
-#jpeg
-
-function jpeg_get_jdestruct_size()
-    return (jdestruct_size_win)
-endfunction
-
-
-function jpeg_get_jdestruct_output_width()
-    return (jdestruct_output_width_win)
-endfunction
-function jpeg_get_jdestruct_output_height()
-    return (jdestruct_output_height_win)
-endfunction
-function jpeg_get_jdestruct_output_components()
-    return (jdestruct_output_components_win)
-endfunction
-
-#
-
-##times
-
-#milliseconds
-function get_time()
-    importx "_GetTickCount@0" GetTickCount
-    sd milliseconds
-    setcall milliseconds GetTickCount()
-    return milliseconds
-endfunction
-
-function sleepMs(sd value)
-    importx "_Sleep@4" Sleep
-    call Sleep(value)
-endfunction
-
-
-#######gdi alternative capture
-
-const SRCCOPY=0x00CC0020
-const DIB_RGB_COLORS=0
-
-function dest_dc(sd action,sd value)
-    data dc#1
-    if action==(value_set)
-        set dc value
-    else
-        return dc
-    endelse
-endfunction
-function dest_dib(sd action,sd value)
-    data dib#1
-    if action==(value_set)
-        set dib value
-    else
-        return dib
-    endelse
-endfunction
-function gdi_toggle(sd action,sd value)
-    data gdi_entry#1
-    if action==(value_set)
-        set gdi_entry value
-    else
-        return gdi_entry
-    endelse
-endfunction
-
-function capture_alternative_init(sd vbox)
-    importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
-    importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
-    importx "_gtk_container_add" gtk_container_add
-    ss gdi_txt="Use GDI"
-    sd gdi_entry
-    setcall gdi_entry gtk_check_button_new_with_label(gdi_txt)
-    call gdi_toggle((value_set),gdi_entry)
-    call gtk_toggle_button_set_active(gdi_entry,1)
-    call gtk_container_add(vbox,gdi_entry)
-
-##folder
-    import "hseparatorfield" hseparatorfield
-    call hseparatorfield(vbox)
-
-    importx "_gtk_table_new" gtk_table_new
-    importx "_gtk_table_attach" gtk_table_attach
-    import "buttonfield_prepare_with_label" buttonfield_prepare_with_label
-    import "connect_clicked" connect_clicked
-    importx "_gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
-    sd table
-    setcall table gtk_table_new(4,1,0)
-
-    ss onefolder="Folder captures to file"
-    sd one
-    setcall one buttonfield_prepare_with_label(onefolder)
-    data f_one^mass_folder
-    call connect_clicked(one,f_one)
-    ss inf="All mkv(i420,mjpeg,rgb) files from a folder to an avi(i420,mjpeg,mpg4-asp) file"
-    call gtk_widget_set_tooltip_markup(one,inf)
-    call gtk_table_attach(table,one,0,1,0,1,(GTK_FILL),0,0,0)
-
-    ss allfolders="Folder folders captures to files"
-    sd all
-    setcall all buttonfield_prepare_with_label(allfolders)
-    data f_many^mass_many_folders
-    call connect_clicked(all,f_many)
-    ss all_inf="All mkv(i420,mjpeg,rgb) files from a folder from all folders to avi(i420,mjpeg,mpg4-asp) files"
-    call gtk_widget_set_tooltip_markup(all,all_inf)
-    call gtk_table_attach(table,all,0,1,1,2,(GTK_FILL),0,0,0)
-
-    import "labelfield_left_prepare" labelfield_left_prepare
-    ss wr="Warning! This will remove the stage video and sound!"
-    sd info
-    setcall info labelfield_left_prepare(wr)
-    call gtk_table_attach(table,info,0,1,2,3,(GTK_FILL),0,0,0)
-
-    ss allfolders_poweroff="Folder folders captures + Shut Down"
-    sd all_poweroff
-    setcall all_poweroff buttonfield_prepare_with_label(allfolders_poweroff)
-    data f_many_poweroff^mass_many_folders_with_poweroff
-    call connect_clicked(all_poweroff,f_many_poweroff)
-    call gtk_table_attach(table,all_poweroff,0,1,3,4,(GTK_FILL),0,0,0)
-
-    import "packstart_default" packstart_default
-    call packstart_default(vbox,table)
-
-    call hseparatorfield(vbox)
-##
-endfunction
-function capture_alternative_set(sd p_no_alternative)
-    sd gdi_entry
-    setcall gdi_entry gdi_toggle((value_get))
-    importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
-    setcall p_no_alternative# gtk_toggle_button_get_active(gdi_entry)
-    xor p_no_alternative# 1
-endfunction
-#bool
-function capture_alternative_prepare(sd p_mem,sd pix_width,sd pix_height)
-    importx "_GetWindowDC@4" GetWindowDC
-    importx "_CreateCompatibleDC@4" CreateCompatibleDC
-    importx "_SelectObject@8" SelectObject
-    importx "_DeleteObject@4" DeleteObject
-    importx "_CreateDIBSection@24" CreateDIBSection
-
-    sd srcDC
-    setcall srcDC GetWindowDC(0)
-    sd destDC
-    setcall destDC CreateCompatibleDC(srcDC)
-    if destDC==0
-        str no_dc="DC error"
-        call texter(no_dc)
-        return 0
-    endif
-    call dest_dc((value_set),destDC)
-
-    #BITMAPINFO
-    data biSize=40
-    data biWidth#1
-    data biHeight#1
-    char *biPlanes={1,0}
-    char *biBitCount={24,0}
-    data *biCompression=0
-    data biSizeImage#1
-    data *biXPelsPerMeter=0
-    data *biYPelsPerMeter=0
-    data *biClrUsed=0
-    data *biClrImportant=0
-    char *bmiColors=0
-
-    data bitmap^biSize
-    set biWidth pix_width
-    set biHeight pix_height
-    import "rgb_get_size" rgb_get_size
-    setcall biSizeImage rgb_get_size(biWidth,biHeight)
-
-    sd dib
-    setcall dib CreateDIBSection(destDC,bitmap,(DIB_RGB_COLORS),p_mem,0,0)
-    if dib==0
-        call DeleteObject(destDC)
-        str no_dib="DIB error"
-        call texter(no_dib)
-        return 0
-    endif
-    call dest_dib((value_set),dib)
-    call SelectObject(destDC,dib)
-    return 1
-endfunction
-function capture_alternative_append(sd x,sd y,sd pix_width,sd pix_height,sd cursor_flag)
-    importx "_BitBlt@36" BitBlt
-    importx "_GetCursorInfo@4" GetCursorInfo
-    importx "_DrawIcon@16" DrawIcon
-    sd srcDC
-    setcall srcDC GetWindowDC(0)
-    sd destDC
-    setcall destDC dest_dc((value_get))
-    call BitBlt(destDC,0,0,pix_width,pix_height,srcDC,x,y,(SRCCOPY))
-    if cursor_flag==1
-        #CURSORINFO
-        data cbSize#1
-        data *flags#1
-        data hCursor#1
-        data ptScreenPos_x#1
-        data ptScreenPos_y#1
-
-        data CursorInfo^cbSize
-        set cbSize 20
-        call GetCursorInfo(CursorInfo)
-
-        sub ptScreenPos_x x
-        sub ptScreenPos_y y
-        call DrawIcon(destDC,ptScreenPos_x,ptScreenPos_y,hCursor)
-    endif
-endfunction
-function capture_alternative_free()
-    sd destDIB
-    setcall destDIB dest_dib((value_get))
-    call DeleteObject(destDIB)
-    sd destDC
-    setcall destDC dest_dc((value_get))
-    call DeleteObject(destDC)
-endfunction
-
-function capture_alt_ev_wait()
-endfunction
-function capture_alt_ev_set()
-endfunction
-
-###############mass capture to file
-
-function mass_folder()
-    sd foldername
-    setcall foldername mass_init_file()
-    call mass_foldername(foldername)
-endfunction
-
-function mass_foldername(ss foldername)
-    #don't display the result message inter-files
-    import "stage_file_options_info_message" stage_file_options_info_message
-    sd info
-    setcall info stage_file_options_info_message((value_get))
-    call stage_file_options_info_message((value_set),0)
-
-    ss spec="*.mkv"
-    data forwrd^mass_folder_file
-    sd counter=0
-    sd p_counter^counter
-    #fileiterate frees the foldername
-    #fileiterate returns if folder==0
-    call fileiterate(foldername,spec,forwrd,p_counter)
-
-    call stage_file_options_info_message((value_set),info)
-endfunction
-
-function fileiterate(ss foldername,ss spec,sd forward,sd data)
-    if foldername==0
-        return 0
-    endif
-    sd p_foldername^foldername
-    call fileiteration(p_foldername,spec,forward,data)
-    call free(foldername)
-endfunction
-
-function fileiteration(sd p_foldername,ss spec,sd forward,sd data)
-    sd folderlen
-    setcall folderlen slen(p_foldername#)
-    inc folderlen
-    sd speclen
-    setcall speclen slen(spec)
-    inc speclen
-
-    sd flen
-    set flen folderlen
-    add flen speclen
-
-    import "memrealloc" memrealloc
-    import "cpymem" cpymem
-    sd foldername
-    setcall foldername memrealloc(p_foldername#,flen)
-    if foldername==0
-        return 0
-    endif
-    set p_foldername# foldername
-
-    ss path
-    set path foldername
-    add path folderlen
-    dec path
-    char bslash="\\"
-    set path# bslash
-    inc path
-    call cpymem(path,spec,speclen)
-
-    data attrib#1
-    data *attrib_align#1
-    data *time_create#2
-    data *time_access#2
-    data *time_write#2
-    data *size#1
-    char name#260
-
-    data file_info^attrib
-    str fname^name
-    char reserve_name#260
-    str reserve^reserve_name
-
-    importx "__findfirst64i32" findfirst
-    importx "__findnext64i32" findnext
-    importx "__findclose" findclose
-
-    sd handle
-    setcall handle findfirst(foldername,file_info)
-    if handle==-1
-        return 0
-    endif
-    str onedot="."
-    str twodots=".."
-    sd cmp
-
-    set path fname
-    add path folderlen
-    sd end=0
-    while end==0
-        sd namelen
-        setcall namelen slen(fname)
-
-        import "cmpmem_s" cmpmem_s
-        sd verify=1
-        setcall cmp cmpmem_s(fname,namelen,onedot,1)
-        if cmp!=(equalCompare)
-            setcall cmp cmpmem_s(fname,namelen,twodots,2)
-        endif
-        if cmp==(equalCompare)
-            set verify 0
-        endif
-
-        if verify==1
-            inc namelen
-            call cpymem(reserve,fname,namelen)
-            call cpymem(fname,foldername,folderlen)
-            call cpymem(path,reserve,namelen)
-            call forward(fname,attrib,data)
-        endif
-        setcall end findnext(handle,file_info)
-    endwhile
-    call findclose(handle)
-endfunction
-
-function mass_folder_file(ss name,sd *attrib,sd p_counter)
-    import "stage_prepare" stage_prepare
-    call stage_prepare()
-    import "stage_mkv_read" stage_mkv_read
-    call stage_mkv_read(name)
-    if p_counter#==0
-        import "aviwrite" aviwrite
-        str location#1
-        sd counter
-        setcall counter files_counter((value_get))
-        setcall location aviwrite(1,counter)
-        inc counter
-        call files_counter((value_set),counter)
-    else
-        import "avi_write_fname" avi_write_fname
-        call avi_write_fname(location,(avi_expand))
-    endelse
-    inc p_counter#
-endfunction
-
-#foldername/0
-function mass_init_file()
-    import "is_local_avi" is_local_avi
-    sd bool
-    setcall bool is_local_avi()
-    if bool==0
-        import "message_dialog" message_dialog
-        ss er="Set avi(i420,mjpeg,mpg4-asp) from the Stage Options"
-        call message_dialog(er)
-        return 0
-    endif
-    call files_counter((value_set),0)
-    sd foldername
-    setcall foldername filechooserfield_folder()
-    return foldername
-endfunction
-
-##all folders
-
-function mass_many_folders()
-    call mass_many_folders_poweroff(0)
-endfunction
-function mass_many_folders_with_poweroff()
-    call mass_many_folders_poweroff(1)
-endfunction
-
-function mass_many_folders_poweroff(sd poweroff_flag)
-    sd foldername
-    setcall foldername mass_init_file()
-
-    ss nullstr="*"
-    data forwrd^mass_all_folders
-    #fileiterate frees the foldername
-    #fileiterate returns if folder==0
-    call fileiterate(foldername,nullstr,forwrd,0)
-
-    if foldername==0
-        return 0
-    endif
-    if poweroff_flag==1
-        call shutdown()
-    endif
-endfunction
-
-const _A_SUBDIR=0x10
-
-function mass_all_folders(ss filefolder_entry,sd attrib)
-    and attrib (_A_SUBDIR)
-    if attrib!=0
-        import "memalloc" memalloc
-        sd len
-        setcall len slen(filefolder_entry)
-        inc len
-        sd mem
-        setcall mem memalloc(len)
-        if mem==0
-            return 0
-        endif
-        call cpymem(mem,filefolder_entry,len)
-        call mass_foldername(mem)
-    endif
-endfunction
-
-function files_counter(sd action,sd value)
-    data counter#1
-    if action==(value_set)
-        set counter value
-    else
-        return counter
-    endelse
-endfunction
-
-const INFINITE=-1
-
-function shutdown()
-    importx "_CreateProcessA@40" CreateProcess
-    import "setmemzero" setmemzero
-    const startupsize=68
-    char startup#startupsize
-    str startupInfo^startup
-    call setmemzero(startupInfo,(startupsize))
-
-    data hprocess#1
-    data hthread#1
-    char *rest_hproc#16-4-4
-
-    data procinfo^hprocess
-
-    str comm="shutdown /p"
-    sd bool
-    setcall bool CreateProcess(0,comm,0,0,0,0,0,0,startupInfo,procinfo)
-    if bool==0
-        str er="CreateProcess failed"
-        call texter(er)
-        return 0
-    endif
-    importx "_WaitForSingleObject@8" WaitForSingleObject
-    importx "_CloseHandle@4" CloseHandle
-    call WaitForSingleObject(hprocess,(INFINITE))
-    call CloseHandle(hprocess)
-    call CloseHandle(hthread)
-endfunction
-
-
-#file seek dif
-
-#er
-function file_seek_dif_cursor(sd file,sd off)
-    importx "__fseeki64" fseek64
-    import "seek_err" seek_err
-    sd int
-    setcall int fseek64(file,off,0,(SEEK_CUR))
-    sd err
-    setcall err seek_err(int)
-    return err
-endfunction
-
-#sound preview
-importx "_waveOutOpen@24" waveOutOpen
-importx "_waveOutClose@4" waveOutClose
-importx "_waveOutReset@4" waveOutReset
-importx "_waveOutPrepareHeader@12" waveOutPrepareHeader
-importx "_waveOutUnprepareHeader@12" waveOutUnprepareHeader
-importx "_waveOutWrite@12" waveOutWrite
-
-import "stage_sound_channels" stage_sound_channels
-import "stage_sound_rate" stage_sound_rate
-import "stage_sound_bps" stage_sound_bps
-
-import "stage_sound_blockalign" stage_sound_blockalign
-import "stage_sound_avgbytespersec" stage_sound_avgbytespersec
-
-const MMSYSERR_NOERROR=0
-const WAVE_MAPPER=-1
-const CALLBACK_NULL=0
-#const CALLBACK_FUNCTION=0x30000
-#const WOM_DONE=0x3BD
-const WAVE_FORMAT_PCM=1
-
-function sound_preview_mm_hwaveout()
-    data hwaveout#1
-    return #hwaveout
-endfunction
-import "sound_preview_buffers" sound_preview_buffers
-function sound_mm_buffers()
-    data bf#1
-    return #bf
-endfunction
-function sound_mm_buffers_get()
-    sd bf
-    setcall bf sound_mm_buffers()
-    return bf#
-endfunction
-function sound_mm_buffers_set()
-    sd nmbr=10
-    addcall nmbr sound_preview_buffers()
-    sd bf
-    setcall bf sound_mm_buffers()
-    set bf# nmbr
-endfunction
-
-const sound_preview_buffers_max=128
-
-function sound_preview_write_buffer(sd buffer,sd buffer_size)
-    sd hwaveout
-    setcall hwaveout sound_preview_mm_hwaveout()
-    if hwaveout#==0
-        return (void)
-    endif
-	const wvhd=!
-    data lpData#1
-    data dwBufferLength#1
-    data *dwBytesRecorded#1
-    data *dwUser#1
-    data *dwFlags=0
-    data *dwLoops#1
-    data *lpNext#1
-    data *reserved#1
-    #lpData, dwBufferLength, and dwFlags members must be set
-#    const wvhd^lpData
-    const wvhd_size=!-wvhd
-    data wavehd%wvhd
-
-    set lpData buffer
-    set dwBufferLength buffer_size
-    data waveheaders_index#1
-    inc waveheaders_index
-
-    import "rest" rest
-    sd buffers_count
-    setcall buffers_count sound_mm_buffers_get()
-    sd pos
-    setcall pos rest(waveheaders_index,buffers_count)
-    sd waveheader
-    setcall waveheader sound_preview_mm_buffers(pos)
-    #unprepare if prepared
-    call sound_preview_buffers_unprep(pos)
-    #
-    call cpymem(waveheader,wavehd,(wvhd_size))
-
-    sd mm
-    setcall mm waveOutPrepareHeader(hwaveout#,waveheader,(wvhd_size))
-    if mm!=(MMSYSERR_NOERROR)
-        str er="Wave out prepare header error"
-        call texter(er)
-    endif
-    #set bool true
-    call sound_preview_buffers_set(pos)
-    setcall mm waveOutWrite(hwaveout#,waveheader,(wvhd_size))
-    if mm!=(MMSYSERR_NOERROR)
-        str wr_er="Wave out write error"
-        call texter(wr_er)
-    endif
-endfunction
-
-function sound_preview_mm_buffers(sd nr)
-    sd data_ptr
-    setcall data_ptr sound_preview_mm_buffers_data()
-    sd data
-    set data data_ptr#
-    mult nr (wvhd_size)
-    add data nr
-    return data
-endfunction
-function sound_preview_mm_buffers_data()
-    data ptr#1
-    return #ptr
-endfunction
-#function sound_preview_mm_buffers_data_set(sd value)
-#    sd data
-#    setcall data sound_preview_mm_buffers_data()
-#    set data# value
-#endfunction
-
-#
-function sound_preview_buffers_bool()
-    data buffers#sound_preview_buffers_max
-    return #buffers
-endfunction
-function sound_preview_buffers_unprep(sd nr,sd wavehdr)
-    sd bools
-    setcall bools sound_preview_buffers_bool()
-    mult nr (DWORD)
-    add bools nr
-    if bools#==1
-        sd hwo
-        setcall hwo sound_preview_mm_hwaveout()
-        sd waveheader
-        setcall waveheader sound_preview_mm_buffers(nr)
-        call waveOutUnprepareHeader(hwo#,wavehdr)
-        set bools# 0
-    endif
-endfunction
-function sound_preview_buffers_set(sd nr)
-    sd bools
-    setcall bools sound_preview_buffers_bool()
-    mult nr (DWORD)
-    add bools nr
-    set bools# 1
-endfunction
-
-#bool
-function sound_preview_init()
-    sd hwaveout
-    setcall hwaveout sound_preview_mm_hwaveout()
-    set hwaveout# 0
-    sd buffers
-    setcall buffers sound_preview_mm_buffers_data()
-    set buffers# 0
-    #
-    call sound_mm_buffers_set()
-    sd nr
-    setcall nr sound_mm_buffers_get()
-    if nr>(sound_preview_buffers_max)
-        str er="Set a lower fps for sound playback"
-        call texter(er)
-        return 0
-    endif
-    #
-    sd value
-    #WAVEFORMATEX
-    char wFormatTag={WAVE_FORMAT_PCM,0}
-    char nChannels#2
-    data nSamplesPerSec#1
-    data nAvgBytesPerSec#1
-    char nBlockAlign#2
-    char wBitsPerSample#2
-    #EX
-    #no extra data, simple PCM-format used
-    char *cbSize={0,0}
-    #
-    import "int_into_short" int_into_short
-    data WAVEFORMATEX^wFormatTag
-    setcall value stage_sound_channels((value_get))
-    call int_into_short(value,#nChannels)
-    setcall nSamplesPerSec stage_sound_rate((value_get))
-    setcall nAvgBytesPerSec stage_sound_avgbytespersec()
-    setcall value stage_sound_blockalign()
-    call int_into_short(value,#nBlockAlign)
-    setcall value stage_sound_bps((value_get))
-    call int_into_short(value,#wBitsPerSample)
-    #
-    #data f^sound_preview_mm_callback
-    sd res
-    setcall res waveOutOpen(hwaveout,(WAVE_MAPPER),WAVEFORMATEX,0,0,(CALLBACK_NULL))
-    if res!=(MMSYSERR_NOERROR)
-        return 0
-    endif
-    #
-    sd i=0
-    sd bf_bool
-    setcall bf_bool sound_preview_buffers_bool()
-    sd max
-    setcall max sound_mm_buffers_get()
-    while i<max
-        set bf_bool# 0
-        add bf_bool (DWORD)
-        inc i
-    endwhile
-    #
-    sd size=wvhd_size
-    mult size nr
-    sd buffers_space
-    setcall buffers_space memalloc(size)
-    if buffers_space==0
-        call sound_preview_free()
-        return 0
-    endif
-    set buffers# buffers_space
-    #
-    return 1
-endfunction
-
-function sound_preview_free()
-    sd pointer
-    setcall pointer sound_preview_mm_hwaveout()
-    sd hwaveout
-    set hwaveout pointer#
-    if hwaveout!=0
-        call waveOutReset(hwaveout)
-        sd i=0
-        sd max
-        setcall max sound_mm_buffers_get()
-        while i<max
-            call sound_preview_buffers_unprep(i)
-            inc i
-        endwhile
-        call waveOutClose(hwaveout)
-        sd buffers
-        setcall buffers sound_preview_mm_buffers_data()
-        if buffers#!=0
-            call free(buffers#)
-        endif
-    endif
-endfunction
-
-#bool
-function sound_preview_end_and_no_errors()
-    sd i=0
-    sd bools
-    setcall bools sound_preview_buffers_bool()
-    sd max
-    setcall max sound_mm_buffers_get()
-    while i<max
-        if bools#==(TRUE)
-            sd buffer
-            setcall buffer sound_preview_mm_buffers(i)
-            const off_lpData=0
-            const off_dwBufferLength=off_lpData+DWORD
-            const off_dwBytesRecorded=off_dwBufferLength+DWORD
-            const off_dwUser=off_dwBytesRecorded+DWORD
-            const off_dwFlags=off_dwUser+DWORD
-            const WHDR_DONE=1
-            add buffer (off_dwFlags)
-            sd flags
-            set flags buffer#
-            and flags (WHDR_DONE)
-            if flags==0
-                return (FALSE)
-            endif
-        endif
-        add bools (DWORD)
-        inc i
-    endwhile
-    return (TRUE)
-endfunction
-
-import "mainwidget" mainwidget
-importx "_gtk_file_chooser_dialog_new" gtk_file_chooser_dialog_new
-import "filechooserfield_dialog" filechooserfield_dialog
-
-#folder/0
-function filechooserfield_folder()
-    str select_folder="Select Folder"
-    sd main
-    setcall main mainwidget()
-    str GTK_STOCK_CANCEL="gtk-cancel"
-    data responsecancel=GTK_RESPONSE_CANCEL
-    str GTK_STOCK_OK="gtk-ok"
-    sd dialog
-    setcall dialog gtk_file_chooser_dialog_new(select_folder,main,(GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER),GTK_STOCK_CANCEL,responsecancel,GTK_STOCK_OK,(GTK_RESPONSE_ACCEPT),0)
-    sd filename
-    setcall filename filechooserfield_dialog(dialog)
-    return filename
-endfunction
-
-#e
-function move_to_home()
-	return (noerror)
-endfunction
-function move_to_home_v()
-endfunction
-function move_to_share_v()
-endfunction
-function move_to_home_core()
-endfunction
-function move_to_share_core()
-endfunction
-function prog_free()
-endfunction
-
-importx "_ulltoa" ulltoa_extern
-
-function ulltoa(sd low,sd high,sd instr)
-	call ulltoa_extern(low,high,instr,10)
-endfunction
-
-
-Importx "_GetCommandLineW@0" GetCommandName
-Importx "_CommandLineToArgvW@8" CommandLineToArgvW
-
-#cmp
-function init_args()
-	sd command_name
-	#sd commname_size
-	sd argc;sv argv
-
-	sd cmp=-1
-
-	SetCall command_name GetCommandName()
-
-	#this is so bugged but accepted , strlen is ansi, but no wide path in this program, so first XX00h will stop
-	#anyway argv0 can't be '\0'
-	#SetCall commname_size strlen(command_name)
-	#If commname_size!=0
-	setcall argv CommandLineToArgvW(command_name,#argc)
-	if argv!=(NULL)
-		if argc>1
-			set cmp 0
-			#sd a1=:;add a1 argv
-			#call wide_to_ansi(a1#) #same as ocompiler
-			#importx "_strcmp" strcmp
-			#setcall cmp strcmp(a1#,"--remove-config")
-
-			import "uninit_print" uninit_print
-			sv c;sv s;setcall s uninit_print(#c)
-			import "uninit_decision" uninit_decision
-			sd b;setcall b uninit_decision()
-			if b==(TRUE)
-				import "uninit_delete" uninit_delete
-				call uninit_delete(s,c)
-			endif
-		endif
-		call free(argv)
-	endif
-	#EndIf
-	return cmp
-endfunction
-importx "__fullpath" fullpath
-#path
-function real_path(sd path)
-	sd mem;setcall mem fullpath((NULL),path,(MAX_PATH))
-	return mem
-endfunction
--- /dev/null
+++ ovideo-1/src/_dif/lin.oc
@@ -0,0 +1,12 @@
+
+endif
+
+#old remark: exit() do segmentation nowadays (in this context)
+importx "exit" exit
+call exit(0)
+
+#importx "getpid" getpid
+#importx "kill" kill
+#sd pid
+#setcall pid getpid()
+#call kill(pid,9)
--- ovideo-1.orig/src/_dif/lin.s
+++ /dev/null
@@ -1,12 +0,0 @@
-
-endif
-
-#old remark: exit() do segmentation nowadays (in this context)
-importx "exit" exit
-call exit(0)
-
-#importx "getpid" getpid
-#importx "kill" kill
-#sd pid
-#setcall pid getpid()
-#call kill(pid,9)
--- /dev/null
+++ ovideo-1/src/_dif/win.oc
@@ -0,0 +1,5 @@
+
+endif
+
+importx "_exit" exit
+call exit(0)
--- ovideo-1.orig/src/_dif/win.s
+++ /dev/null
@@ -1,5 +0,0 @@
-
-endif
-
-importx "_exit" exit
-call exit(0)
--- /dev/null
+++ ovideo-1/src/_exec/capture/save.oc
@@ -0,0 +1,274 @@
+
+
+
+
+format elfobj
+
+import "timeNode" time
+importx "_sprintf" sprintf
+
+include "../../_include/include.h"
+
+function rec_get()
+    data recbin#1
+    const ptrrecbin^recbin
+    return recbin
+endfunction
+
+function rec_set(data value)
+    data ptrrecbin%ptrrecbin
+    set ptrrecbin# value
+endfunction
+
+import "set_pipe_null" set_pipe_null
+function rec_unset()
+    data rec#1
+    setcall rec rec_get()
+    data n=0
+    if rec!=n
+        call set_pipe_null(rec)
+        import "unset_pipe_and_watch" unset_pipe_and_watch
+        call unset_pipe_and_watch(rec)
+        call rec_set(n)
+    endif
+endfunction
+
+import "stream_error" stream_error
+function rec_stream_error(data *bus,data message)
+    call stream_error(message)
+    call rec_unset()
+endfunction
+
+function save_inform_saved(ss location)
+    str sv="File saved as: "
+    data ss=stringstring
+    import "strvaluedisp" strvaluedisp
+    call strvaluedisp(sv,location,ss)
+endfunction
+
+function rec_endofstream(data *bus,data *message,str passdata)
+    call save_inform_saved(passdata)
+    call rec_unset()
+endfunction
+
+import "connect_signal" connect_signal
+import "connect_signal_data" connect_signal_data
+function recSignals(data bus,data dest)
+    str eos="message::eos"
+    data end^rec_endofstream
+    call connect_signal_data(bus,eos,end,dest)
+
+    str error="message::error"
+    data errorfn^rec_stream_error
+    call connect_signal(bus,error,errorfn)
+endfunction
+
+function capture_folder()
+const capture_char_start=\
+	char folder="captures"
+const capture_char=\-capture_char_start-1
+	return #folder
+endfunction
+#ogg
+#temp
+#raw
+#jpeg
+
+#avi
+#mxf
+#mkv
+#mp4
+#   mux
+
+import "move_to_home_core" move_to_home_core
+function capture_path(ss format,sd extrabool,sd extranumber)
+	char capture_data#capture_char+1+dword_max+1+dword_max+1+format_max+1
+	ss capture_str^capture_data
+	ss folder
+	setcall folder capture_folder()
+	sd tm
+	setcall tm time(0)
+	ss fmt="%s/%s%u.%s"
+	ss extra
+	if extrabool=0
+		ss null=""
+		set extra null
+	else
+		sd extra_data#5
+		ss extra_str^extra_data
+		str f_extra="%u."
+		call sprintf(extra_str,f_extra,extranumber)
+		set extra extra_str
+	endelse
+	call sprintf(capture_str,fmt,folder,extra,tm,format)
+	call move_to_home_core(#capture_str)
+	return capture_str
+endfunction
+
+function save_destination(ss format)
+    sd path
+    setcall path capture_path(format,0)
+    return path
+endfunction
+
+
+
+str chain_uri#1
+data chain_streams#1
+const ptr_chain_uri^chain_uri
+const ptr_chain_streams^chain_streams
+
+function save_get_main_format()
+    str mediaform="uridecodebin uri=\"%s\" %s ! queue ! %s ! oggmux name=mux ! filesink location=\"%s\"%s"
+    return mediaform
+endfunction
+function save_get_sec_format()
+    str mediasecform=" %s ! queue ! %s ! mux."
+    return mediasecform
+endfunction
+function save_get_video_format()
+    str video="theoraenc"
+    return video
+endfunction
+function save_get_audio_format()
+    str audio="vorbisenc"
+    return audio
+endfunction
+function save_get_ogg_dest()
+#these formats are related to format_max
+    str format="ogg"
+    sd dest
+    setcall dest save_destination(format)
+    return dest
+endfunction
+
+#v
+function save_stream_dest_ready(str dest)
+    data ptrsrc%ptr_chain_uri
+    str src#1
+    set src ptrsrc#
+    data ptrstreams%ptr_chain_streams
+    str streams#1
+    set streams ptrstreams#
+
+    ss video
+    ss audio
+    setcall video save_get_video_format()
+    setcall audio save_get_audio_format()
+
+    str srcname="src"
+
+    str nullstr=""
+
+    data flagA=audio
+    data flagVA=audiovideo
+
+    char src_prop_data#20
+
+    str format#1
+    str sr#1
+    str sr_prop^src_prop_data
+    str m1#1
+    str dst#1
+    str secondstream#1
+    data *=0
+    sd strings^format
+
+    setcall format save_get_main_format()
+    set sr src
+    str nameformat="name=%s"
+    call sprintf(sr_prop,nameformat,srcname)
+    set dst dest
+
+    set m1 video
+    if streams=flagVA
+        str makename="%s."
+        char save_secname_data#15
+        str save_src_name^save_secname_data
+        call sprintf(save_src_name,makename,srcname)
+        char save_va_data#40
+        str save_va^save_va_data
+        ss secformat
+        setcall secformat save_get_sec_format()
+        call sprintf(save_va,secformat,save_src_name,audio)
+        set secondstream save_va
+    else
+        set secondstream nullstr
+        if streams=flagA
+            set m1 audio
+        endif
+    endelse
+
+    data mem#1
+    data ptrmem^mem
+
+    import "allocsum_null" allocsum_null
+    importx "_free" free
+    data err#1
+    setcall err allocsum_null(strings,ptrmem)
+    data noerr=noerror
+    if err!=noerr
+        return err
+    endif
+
+    call sprintf(mem,format,src,sr_prop,m1,dest,secondstream)
+
+    importx "_gst_parse_launch" gst_parse_launch
+
+    import "getptrgerr" getptrgerr
+    import "gerrtoerr" gerrtoerr
+    data ptrgerr#1
+    setcall ptrgerr getptrgerr()
+
+    data pipe#1
+    setcall pipe gst_parse_launch(mem,ptrgerr)
+    call free(mem)
+    data n=0
+    if pipe=n
+        call gerrtoerr(ptrgerr)
+        return ptrgerr
+    endif
+    import "add_bus_signal_watch" add_bus_signal_watch
+    call add_bus_signal_watch(pipe)
+    call rec_set(pipe)
+
+    import "bus_signals_data" bus_signals_data
+    data sg^recSignals
+    call bus_signals_data(pipe,sg,dest)
+
+    importx "_gst_element_set_state" gst_element_set_state
+    data play=GST_STATE_PLAYING
+    call gst_element_set_state(pipe,play)
+endfunction
+
+#v
+function save_stream_prepare_dest()
+    sd dest
+    setcall dest save_get_ogg_dest()
+    call save_stream_dest_ready(dest)
+endfunction
+
+#v
+function save_stream(str uri,data streams)
+    #unset the previous if any
+    call rec_unset()
+
+    data save_uri%ptr_chain_uri
+    set save_uri# uri
+    data save_streams%ptr_chain_streams
+    set save_streams# streams
+
+    call save_stream_prepare_dest()
+endfunction
+
+import "collect_info" collect_info
+#v
+function info_save_stream()
+    char rec="recording from"
+
+    str capture^rec
+    data *forward^save_stream
+    data st^capture
+
+    call collect_info(st)
+endfunction
--- ovideo-1.orig/src/_exec/capture/save.s
+++ /dev/null
@@ -1,274 +0,0 @@
-
-
-
-
-format elfobj
-
-import "timeNode" time
-importx "_sprintf" sprintf
-
-include "../../_include/include.h"
-
-function rec_get()
-    data recbin#1
-    const ptrrecbin^recbin
-    return recbin
-endfunction
-
-function rec_set(data value)
-    data ptrrecbin%ptrrecbin
-    set ptrrecbin# value
-endfunction
-
-import "set_pipe_null" set_pipe_null
-function rec_unset()
-    data rec#1
-    setcall rec rec_get()
-    data n=0
-    if rec!=n
-        call set_pipe_null(rec)
-        import "unset_pipe_and_watch" unset_pipe_and_watch
-        call unset_pipe_and_watch(rec)
-        call rec_set(n)
-    endif
-endfunction
-
-import "stream_error" stream_error
-function rec_stream_error(data *bus,data message)
-    call stream_error(message)
-    call rec_unset()
-endfunction
-
-function save_inform_saved(ss location)
-    str sv="File saved as: "
-    data ss=stringstring
-    import "strvaluedisp" strvaluedisp
-    call strvaluedisp(sv,location,ss)
-endfunction
-
-function rec_endofstream(data *bus,data *message,str passdata)
-    call save_inform_saved(passdata)
-    call rec_unset()
-endfunction
-
-import "connect_signal" connect_signal
-import "connect_signal_data" connect_signal_data
-function recSignals(data bus,data dest)
-    str eos="message::eos"
-    data end^rec_endofstream
-    call connect_signal_data(bus,eos,end,dest)
-
-    str error="message::error"
-    data errorfn^rec_stream_error
-    call connect_signal(bus,error,errorfn)
-endfunction
-
-function capture_folder()
-const capture_char_start=!
-	char folder="captures"
-const capture_char=!-capture_char_start-1
-	return #folder
-endfunction
-#ogg
-#temp
-#raw
-#jpeg
-
-#avi
-#mxf
-#mkv
-#mp4
-#   mux
-
-import "move_to_home_core" move_to_home_core
-function capture_path(ss format,sd extrabool,sd extranumber)
-	char capture_data#capture_char+1+dword_max+1+dword_max+1+format_max+1
-	ss capture_str^capture_data
-	ss folder
-	setcall folder capture_folder()
-	sd tm
-	setcall tm time(0)
-	ss fmt="%s/%s%u.%s"
-	ss extra
-	if extrabool==0
-		ss null=""
-		set extra null
-	else
-		sd extra_data#5
-		ss extra_str^extra_data
-		str f_extra="%u."
-		call sprintf(extra_str,f_extra,extranumber)
-		set extra extra_str
-	endelse
-	call sprintf(capture_str,fmt,folder,extra,tm,format)
-	call move_to_home_core(#capture_str)
-	return capture_str
-endfunction
-
-function save_destination(ss format)
-    sd path
-    setcall path capture_path(format,0)
-    return path
-endfunction
-
-
-
-str chain_uri#1
-data chain_streams#1
-const ptr_chain_uri^chain_uri
-const ptr_chain_streams^chain_streams
-
-function save_get_main_format()
-    str mediaform="uridecodebin uri=\"%s\" %s ! queue ! %s ! oggmux name=mux ! filesink location=\"%s\"%s"
-    return mediaform
-endfunction
-function save_get_sec_format()
-    str mediasecform=" %s ! queue ! %s ! mux."
-    return mediasecform
-endfunction
-function save_get_video_format()
-    str video="theoraenc"
-    return video
-endfunction
-function save_get_audio_format()
-    str audio="vorbisenc"
-    return audio
-endfunction
-function save_get_ogg_dest()
-#these formats are related to format_max
-    str format="ogg"
-    sd dest
-    setcall dest save_destination(format)
-    return dest
-endfunction
-
-#v
-function save_stream_dest_ready(str dest)
-    data ptrsrc%ptr_chain_uri
-    str src#1
-    set src ptrsrc#
-    data ptrstreams%ptr_chain_streams
-    str streams#1
-    set streams ptrstreams#
-
-    ss video
-    ss audio
-    setcall video save_get_video_format()
-    setcall audio save_get_audio_format()
-
-    str srcname="src"
-
-    str nullstr=""
-
-    data flagA=audio
-    data flagVA=audiovideo
-
-    char src_prop_data#20
-
-    str format#1
-    str sr#1
-    str sr_prop^src_prop_data
-    str m1#1
-    str dst#1
-    str secondstream#1
-    data *=0
-    sd strings^format
-
-    setcall format save_get_main_format()
-    set sr src
-    str nameformat="name=%s"
-    call sprintf(sr_prop,nameformat,srcname)
-    set dst dest
-
-    set m1 video
-    if streams==flagVA
-        str makename="%s."
-        char save_secname_data#15
-        str save_src_name^save_secname_data
-        call sprintf(save_src_name,makename,srcname)
-        char save_va_data#40
-        str save_va^save_va_data
-        ss secformat
-        setcall secformat save_get_sec_format()
-        call sprintf(save_va,secformat,save_src_name,audio)
-        set secondstream save_va
-    else
-        set secondstream nullstr
-        if streams==flagA
-            set m1 audio
-        endif
-    endelse
-
-    data mem#1
-    data ptrmem^mem
-
-    import "allocsum_null" allocsum_null
-    importx "_free" free
-    data err#1
-    setcall err allocsum_null(strings,ptrmem)
-    data noerr=noerror
-    if err!=noerr
-        return err
-    endif
-
-    call sprintf(mem,format,src,sr_prop,m1,dest,secondstream)
-
-    importx "_gst_parse_launch" gst_parse_launch
-
-    import "getptrgerr" getptrgerr
-    import "gerrtoerr" gerrtoerr
-    data ptrgerr#1
-    setcall ptrgerr getptrgerr()
-
-    data pipe#1
-    setcall pipe gst_parse_launch(mem,ptrgerr)
-    call free(mem)
-    data n=0
-    if pipe==n
-        call gerrtoerr(ptrgerr)
-        return ptrgerr
-    endif
-    import "add_bus_signal_watch" add_bus_signal_watch
-    call add_bus_signal_watch(pipe)
-    call rec_set(pipe)
-
-    import "bus_signals_data" bus_signals_data
-    data sg^recSignals
-    call bus_signals_data(pipe,sg,dest)
-
-    importx "_gst_element_set_state" gst_element_set_state
-    data play=GST_STATE_PLAYING
-    call gst_element_set_state(pipe,play)
-endfunction
-
-#v
-function save_stream_prepare_dest()
-    sd dest
-    setcall dest save_get_ogg_dest()
-    call save_stream_dest_ready(dest)
-endfunction
-
-#v
-function save_stream(str uri,data streams)
-    #unset the previous if any
-    call rec_unset()
-
-    data save_uri%ptr_chain_uri
-    set save_uri# uri
-    data save_streams%ptr_chain_streams
-    set save_streams# streams
-
-    call save_stream_prepare_dest()
-endfunction
-
-import "collect_info" collect_info
-#v
-function info_save_stream()
-    char rec="recording from"
-
-    str capture^rec
-    data *forward^save_stream
-    data st^capture
-
-    call collect_info(st)
-endfunction
--- /dev/null
+++ ovideo-1/src/_exec/help.oc
@@ -0,0 +1,65 @@
+
+
+format elfobj
+
+import "getptrgerr" getptrgerr
+import "gerrtoerr" gerrtoerr
+
+importx "_g_object_unref" g_object_unref
+
+function view_use_file_got_gappinfo_glist(sd gappinfo,sd glist)
+    sd ptrgerr
+    setcall ptrgerr getptrgerr()
+
+    sd launch_context=0
+    importx "_g_app_info_launch" g_app_info_launch
+    sd bool
+    setcall bool g_app_info_launch(gappinfo,glist,launch_context,ptrgerr)
+    sd z=0
+    if gappinfo=z
+        call gerrtoerr(ptrgerr)
+    endif
+endfunction
+
+function view_use_file_got_gfile_gappinfo(sd gfile,sd gappinfo)
+    sd list=0
+    importx "_g_list_append" g_list_append
+    importx "_g_list_free" g_list_free
+    setcall list g_list_append(list,gfile)
+    call view_use_file_got_gappinfo_glist(gappinfo,list)
+    call g_list_free(list)
+endfunction
+
+function view_use_file_got_gfile(sd gfile)
+    sd ptrgerr
+    setcall ptrgerr getptrgerr()
+
+    importx "_g_file_query_default_handler" g_file_query_default_handler
+    sd cancellable=0
+    sd appinfo
+    setcall appinfo g_file_query_default_handler(gfile,cancellable,ptrgerr)
+    sd z=0
+    if appinfo=z
+        call gerrtoerr(ptrgerr)
+    endif
+    call view_use_file_got_gfile_gappinfo(gfile,appinfo)
+    call g_object_unref(appinfo)
+endfunction
+
+function move_to_html()
+    ss filename="use.html"
+    sd file
+    importx "_g_file_new_for_path" g_file_new_for_path
+    setcall file g_file_new_for_path(filename)
+    call view_use_file_got_gfile(file)
+    call g_object_unref(file)
+endfunction
+
+import "move_to_share_v" move_to_share_v
+function view_use_file()
+	call move_to_share_v()
+	import "folder_enterleave" folder_enterleave
+	ss loc="html"
+	data f^move_to_html
+	call folder_enterleave(loc,f)
+endfunction
--- ovideo-1.orig/src/_exec/help.s
+++ /dev/null
@@ -1,65 +0,0 @@
-
-
-format elfobj
-
-import "getptrgerr" getptrgerr
-import "gerrtoerr" gerrtoerr
-
-importx "_g_object_unref" g_object_unref
-
-function view_use_file_got_gappinfo_glist(sd gappinfo,sd glist)
-    sd ptrgerr
-    setcall ptrgerr getptrgerr()
-
-    sd launch_context=0
-    importx "_g_app_info_launch" g_app_info_launch
-    sd bool
-    setcall bool g_app_info_launch(gappinfo,glist,launch_context,ptrgerr)
-    sd z=0
-    if gappinfo==z
-        call gerrtoerr(ptrgerr)
-    endif
-endfunction
-
-function view_use_file_got_gfile_gappinfo(sd gfile,sd gappinfo)
-    sd list=0
-    importx "_g_list_append" g_list_append
-    importx "_g_list_free" g_list_free
-    setcall list g_list_append(list,gfile)
-    call view_use_file_got_gappinfo_glist(gappinfo,list)
-    call g_list_free(list)
-endfunction
-
-function view_use_file_got_gfile(sd gfile)
-    sd ptrgerr
-    setcall ptrgerr getptrgerr()
-
-    importx "_g_file_query_default_handler" g_file_query_default_handler
-    sd cancellable=0
-    sd appinfo
-    setcall appinfo g_file_query_default_handler(gfile,cancellable,ptrgerr)
-    sd z=0
-    if appinfo==z
-        call gerrtoerr(ptrgerr)
-    endif
-    call view_use_file_got_gfile_gappinfo(gfile,appinfo)
-    call g_object_unref(appinfo)
-endfunction
-
-function move_to_html()
-    ss filename="use.html"
-    sd file
-    importx "_g_file_new_for_path" g_file_new_for_path
-    setcall file g_file_new_for_path(filename)
-    call view_use_file_got_gfile(file)
-    call g_object_unref(file)
-endfunction
-
-import "move_to_share_v" move_to_share_v
-function view_use_file()
-	call move_to_share_v()
-	import "folder_enterleave" folder_enterleave
-	ss loc="html"
-	data f^move_to_html
-	call folder_enterleave(loc,f)
-endfunction
--- /dev/null
+++ ovideo-1/src/_exec/init.oc
@@ -0,0 +1,252 @@
+
+format elfobj
+
+include "../_include/include.h" #files/olang.h
+
+importx "_strlen" strlen
+importx "_access" access
+importx "_mkdir" mkdir
+importx "_getcwd" getcwd
+importx "_free" free
+importx "_open" open
+importx "_write" write
+importx "_close" close
+importx "_sprintf" sprintf
+
+import "capture_folder" capture_folder
+import "sys_folder" sys_folder
+import "chdr" chdr
+import "move_to_home" move_to_home
+
+#err
+function init_user()
+	sd err
+	setcall err move_to_home()
+	if err=(noerror)
+		sd d
+		setcall d capture_folder()
+		setcall err init_dir(d)
+		if err=(noerror)
+			setcall d sys_folder()
+			setcall err init_dir(d)
+			if err=(noerror)
+				sd p
+				setcall p getcwd((NULL),0)
+				if p!=(NULL)
+					vstr cerr="chdir error at init user"
+					sd x
+					setcall x chdr(d)
+					if x=0
+						setcall err init_user_sys((NULL))
+						setcall x chdr(p)
+						if x!=0
+							set err cerr
+						endif
+					else
+						set err cerr
+					endelse
+					call free(p)
+				else
+					set err "getcwd error at init user"
+				endelse
+			endif
+		endif
+	endif
+	return err
+endfunction
+#e
+function init_user_sys(sv forward)
+	const start=\
+	char a="capture"
+	const biggest_string=7
+	const d1=\
+	char *={0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00}
+	const d11=\-d1
+	char *="jpeg"
+	const d2=\
+	char *={0x20,0x03,0x00,0x00}
+	const d22=\-d2
+	char *="mpeg"
+	const d3=\
+	char *={0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00}
+	const d33=\-d3
+	char *="search"
+	const d4=\
+	char *={0x73,0x72,0x63,0x3d,0x22,0x00,0x22,0x00,0x00,0x00}
+	const d44=\-d4
+	char *="sound"
+	const d5=\
+	char *={0x02,0x00,0x00,0x00,0x80,0xbb,0x00,0x00,0x10,0x00,0x00,0x00}
+	const d55=\-d5
+	char *="stage"
+	const d6=\
+	char *={0x0a,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00}
+	const d66=\-d6
+	char *="update"
+	const d7=\
+	char *={0x01,0x00,0x00,0x00}
+	const d77=\-d7
+	sd b=\-start
+	sd c^a
+	add b c
+	char e={d11,d22,d33,d44,d55,d66,d77}
+	ss f^e
+	sd err=noerror
+	while c!=b
+		setcall c init_sys(c,f#,#err,forward)
+		if err!=(noerror)
+			return err
+		endif
+		inc f
+	endwhile
+	return (noerror)
+endfunction
+
+function init_sys(sd c,sd sz,sd perr,sv forward)
+	sd len
+	setcall len strlen(c)
+	sd f
+	set f c
+	add c len
+	inc c
+	call init_sys_file(f,c,sz,perr,forward)
+	add c sz
+	return c
+endfunction
+
+#er
+function init_dir(sd f)
+	sd is
+	setcall is access(f,(F_OK))
+	#this looks useless check but we want mkdir to return success, then, it is ok, ignoring mkdir by others between these calls
+	if is=-1
+		setcall is mkdir(f,(flag_dmode))
+		if is!=0
+			return "mkdir error"
+		endif
+	endif
+	return (noerror)
+endfunction
+
+function init_sys_file(sd f,sd data,sd sz,sv perr,sv forward)
+	char buf#biggest_string+1+4+1
+	call sprintf(#buf,"%s.data",f)
+	sd is
+	setcall is access(#buf,(F_OK))
+	if forward=(NULL)
+		if is=-1
+			#open
+			const O_WRONLY=0x0001
+			sd fd
+			setcall fd open(#buf,(O_WRONLY|flag_O_BINARY|flag_O_CREAT),(flag_fmode))
+			#write
+			sd len
+			setcall len write(fd,data,sz)
+			#close
+			call close(fd)
+			if len!=sz
+				set perr# "write error at init user"
+			endif
+		endif
+	else
+		if is=0
+			call forward(#buf)
+		endif
+	endelse
+endfunction
+
+
+#d
+function uninit_folder(sv fn)
+	sd d;sd a
+	setcall d fn()
+	setcall a access(d,(F_OK))
+	if a=0
+		return d
+	endif
+	return (NULL)
+endfunction
+
+importx "_puts" puts
+import "sys_folder_enterleave" sys_folder_enterleave
+
+function uninit_sys_print()
+	call init_user_sys(uninit_print_entry)
+endfunction
+import "real_path" real_path
+function uninit_print_entry(sd f)
+	sd p;setcall p real_path(f)
+	if p!=(NULL)
+		call puts(p)
+		call free(p)
+	endif
+endfunction
+#sys folder
+function uninit_print(sv p_c)
+	call puts("Would remove:") #on linux there is main folder already
+	sd s;setcall s uninit_folder(sys_folder)
+	sd c;setcall c uninit_folder(capture_folder)
+	if s!=(NULL)
+		call sys_folder_enterleave(uninit_sys_print)
+		call uninit_print_entry(s)
+	endif
+	if c!=(NULL)
+		call uninit_print_entry(c)
+	endif
+	set p_c# c
+	return s
+endfunction
+importx "_getchar" getchar
+#b
+function uninit_decision()
+	call puts("yes ?")
+	sd c;setcall c getchar()
+	if c=(y)
+		setcall c getchar()
+		if c=(e)
+			setcall c getchar()
+			if c=(s)
+			#more chars can be, after this will exit anyway
+				return (TRUE)
+			endif
+		endif
+	endif
+	call puts("expecting \"yes\"")
+	return (FALSE)
+endfunction
+
+function uninit_delete(sd sys,sd captures)
+	if sys!=(NULL)
+		call sys_folder_enterleave(uninit_delete_sys)
+		call uninit_delete_folder(sys)
+	endif
+	if captures!=(NULL)
+		call uninit_delete_folder(captures)
+	endif
+endfunction
+function uninit_delete_sys()
+	call init_user_sys(uninit_delete_file)
+endfunction
+function uninit_delete_entry(sd entry,sv function)
+	sd p;setcall p real_path(entry)
+	if p!=(NULL)
+		sd x;setcall x function(p)
+		if x=0
+			call uninit_deleted(p)
+		endif
+		call free(p)
+	endif
+endfunction
+importx "_unlink" unlink
+function uninit_delete_file(sd file)
+	call uninit_delete_entry(file,unlink)
+endfunction
+importx "_printf" printf
+function uninit_deleted(sd s)
+	call printf("%s removed\n",s)
+endfunction
+importx "_rmdir" rmdir
+function uninit_delete_folder(sd folder)
+	call uninit_delete_entry(folder,rmdir)
+	#printf("%s ignored (maybe is not empty)\n",folder)
+endfunction
--- ovideo-1.orig/src/_exec/init.s
+++ /dev/null
@@ -1,252 +0,0 @@
-
-format elfobj
-
-include "../_include/include.h" #files/olang.h
-
-importx "_strlen" strlen
-importx "_access" access
-importx "_mkdir" mkdir
-importx "_getcwd" getcwd
-importx "_free" free
-importx "_open" open
-importx "_write" write
-importx "_close" close
-importx "_sprintf" sprintf
-
-import "capture_folder" capture_folder
-import "sys_folder" sys_folder
-import "chdr" chdr
-import "move_to_home" move_to_home
-
-#err
-function init_user()
-	sd err
-	setcall err move_to_home()
-	if err==(noerror)
-		sd d
-		setcall d capture_folder()
-		setcall err init_dir(d)
-		if err==(noerror)
-			setcall d sys_folder()
-			setcall err init_dir(d)
-			if err==(noerror)
-				sd p
-				setcall p getcwd((NULL),0)
-				if p!=(NULL)
-					vstr cerr="chdir error at init user"
-					sd x
-					setcall x chdr(d)
-					if x==0
-						setcall err init_user_sys((NULL))
-						setcall x chdr(p)
-						if x!=0
-							set err cerr
-						endif
-					else
-						set err cerr
-					endelse
-					call free(p)
-				else
-					set err "getcwd error at init user"
-				endelse
-			endif
-		endif
-	endif
-	return err
-endfunction
-#e
-function init_user_sys(sv forward)
-	const start=!
-	char a="capture"
-	const biggest_string=7
-	const d1=!
-	char *={0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00}
-	const d11=!-d1
-	char *="jpeg"
-	const d2=!
-	char *={0x20,0x03,0x00,0x00}
-	const d22=!-d2
-	char *="mpeg"
-	const d3=!
-	char *={0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00}
-	const d33=!-d3
-	char *="search"
-	const d4=!
-	char *={0x73,0x72,0x63,0x3d,0x22,0x00,0x22,0x00,0x00,0x00}
-	const d44=!-d4
-	char *="sound"
-	const d5=!
-	char *={0x02,0x00,0x00,0x00,0x80,0xbb,0x00,0x00,0x10,0x00,0x00,0x00}
-	const d55=!-d5
-	char *="stage"
-	const d6=!
-	char *={0x0a,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00}
-	const d66=!-d6
-	char *="update"
-	const d7=!
-	char *={0x01,0x00,0x00,0x00}
-	const d77=!-d7
-	sd b=!-start
-	sd c^a
-	add b c
-	char e={d11,d22,d33,d44,d55,d66,d77}
-	ss f^e
-	sd err=noerror
-	while c!=b
-		setcall c init_sys(c,f#,#err,forward)
-		if err!=(noerror)
-			return err
-		endif
-		inc f
-	endwhile
-	return (noerror)
-endfunction
-
-function init_sys(sd c,sd sz,sd perr,sv forward)
-	sd len
-	setcall len strlen(c)
-	sd f
-	set f c
-	add c len
-	inc c
-	call init_sys_file(f,c,sz,perr,forward)
-	add c sz
-	return c
-endfunction
-
-#er
-function init_dir(sd f)
-	sd is
-	setcall is access(f,(F_OK))
-	#this looks useless check but we want mkdir to return success, then, it is ok, ignoring mkdir by others between these calls
-	if is==-1
-		setcall is mkdir(f,(flag_dmode))
-		if is!=0
-			return "mkdir error"
-		endif
-	endif
-	return (noerror)
-endfunction
-
-function init_sys_file(sd f,sd data,sd sz,sv perr,sv forward)
-	char buf#biggest_string+1+4+1
-	call sprintf(#buf,"%s.data",f)
-	sd is
-	setcall is access(#buf,(F_OK))
-	if forward==(NULL)
-		if is==-1
-			#open
-			const O_WRONLY=0x0001
-			sd fd
-			setcall fd open(#buf,(O_WRONLY|flag_O_BINARY|flag_O_CREAT),(flag_fmode))
-			#write
-			sd len
-			setcall len write(fd,data,sz)
-			#close
-			call close(fd)
-			if len!=sz
-				set perr# "write error at init user"
-			endif
-		endif
-	else
-		if is==0
-			call forward(#buf)
-		endif
-	endelse
-endfunction
-
-
-#d
-function uninit_folder(sd fn)
-	sd d;sd a
-	setcall d fn()
-	setcall a access(d,(F_OK))
-	if a==0
-		return d
-	endif
-	return (NULL)
-endfunction
-
-importx "_puts" puts
-import "sys_folder_enterleave" sys_folder_enterleave
-
-function uninit_sys_print()
-	call init_user_sys(uninit_print_entry)
-endfunction
-import "real_path" real_path
-function uninit_print_entry(sd f)
-	sd p;setcall p real_path(f)
-	if p!=(NULL)
-		call puts(p)
-		call free(p)
-	endif
-endfunction
-#sys folder
-function uninit_print(sv p_c)
-	call puts("Would remove:") #on linux there is main folder already
-	sd s;setcall s uninit_folder(sys_folder)
-	sd c;setcall c uninit_folder(capture_folder)
-	if s!=(NULL)
-		call sys_folder_enterleave(uninit_sys_print)
-		call uninit_print_entry(s)
-	endif
-	if c!=(NULL)
-		call uninit_print_entry(c)
-	endif
-	set p_c# c
-	return s
-endfunction
-importx "_getchar" getchar
-#b
-function uninit_decision()
-	call puts("yes ?")
-	sd c;setcall c getchar()
-	if c==(y)
-		setcall c getchar()
-		if c==(e)
-			setcall c getchar()
-			if c==(s)
-			#more chars can be, after this will exit anyway
-				return (TRUE)
-			endif
-		endif
-	endif
-	call puts("expecting \"yes\"")
-	return (FALSE)
-endfunction
-
-function uninit_delete(sd sys,sd captures)
-	if sys!=(NULL)
-		call sys_folder_enterleave(uninit_delete_sys)
-		call uninit_delete_folder(sys)
-	endif
-	if captures!=(NULL)
-		call uninit_delete_folder(captures)
-	endif
-endfunction
-function uninit_delete_sys()
-	call init_user_sys(uninit_delete_file)
-endfunction
-function uninit_delete_entry(sd entry,sd function)
-	sd p;setcall p real_path(entry)
-	if p!=(NULL)
-		sd x;setcall x function(p)
-		if x==0
-			call uninit_deleted(p)
-		endif
-		call free(p)
-	endif
-endfunction
-importx "_unlink" unlink
-function uninit_delete_file(sd file)
-	call uninit_delete_entry(file,unlink)
-endfunction
-importx "_printf" printf
-function uninit_deleted(sd s)
-	call printf("%s removed\n",s)
-endfunction
-importx "_rmdir" rmdir
-function uninit_delete_folder(sd folder)
-	call uninit_delete_entry(folder,rmdir)
-	#printf("%s ignored (maybe is not empty)\n",folder)
-endfunction
--- /dev/null
+++ ovideo-1/src/_exec/mainhandles.oc
@@ -0,0 +1,102 @@
+
+
+format elfobj
+
+importx "_gtk_window_list_toplevels" gtk_window_list_toplevels
+importx "_g_list_free" g_list_free
+
+include "../_include/include.h"
+
+
+import "nthwidgetFromcontainer" nthwidgetFromcontainer
+import "firstwidgetFromcontainer" firstwidgetFromcontainer
+
+#########main
+#main window widget
+function mainwidget()
+        data GList#1
+        setcall GList gtk_window_list_toplevels()
+        data widget#1
+        set widget GList#
+        call g_list_free(GList)
+        return widget
+endfunction
+
+########vbox
+#vbox window widget
+function boxwidget()
+        data widget#1
+        setcall widget mainwidget()
+        setcall widget firstwidgetFromcontainer(widget)
+        return widget
+endfunction
+#vbox/nth
+function boxwidget_nth(data index)
+    data widget#1
+    setcall widget boxwidget()
+    setcall widget nthwidgetFromcontainer(widget,index)
+    return widget
+endfunction
+
+#######edit
+function editWidget()
+    data widget#1
+    Data i=mainwinEditIndex
+    setcall widget boxwidget_nth(i)
+    return widget
+endfunction
+#buffer, forward
+importx "_gtk_entry_get_text" gtk_entry_get_text
+function editWidgetBufferForwardData(data forward,data forwarddata)
+    data widget#1
+    setcall widget editWidget()
+    data buffertext#1
+    setcall buffertext gtk_entry_get_text(widget)
+    call forward(buffertext,forwarddata)
+endfunction
+function editWidgetBufferForward(data forward)
+    data n=0
+    call editWidgetBufferForwardData(forward,n)
+endfunction
+
+#######draw
+function drawwidget()
+    data widget#1
+    Data draw=mainwinDrawIndex
+    setcall widget boxwidget_nth(draw)
+    return widget
+endfunction
+
+#######buttons
+function buttonsalignWidget()
+    data widget#1
+    Data mainwinButtonsIndex=mainwinButtonsIndex
+    setcall widget boxwidget_nth(mainwinButtonsIndex)
+    return widget
+endfunction
+
+function buttonswidget()
+    data widget#1
+    setcall widget buttonsalignWidget()
+    setcall widget firstwidgetFromcontainer(widget)
+    return widget
+endfunction
+
+#######stage
+#stage window widget
+function stagewidget()
+    data widget#1
+    Data st=mainwinStageIndex
+    setcall widget boxwidget_nth(st)
+    return widget
+endfunction
+
+#######info
+#info window widget
+#function infowidget()
+#    data widget#1
+#    Data mainwinInfoIndex=mainwinInfoIndex
+#    setcall widget boxwidget_nth(mainwinInfoIndex)
+#    return widget
+#endfunction
+
--- ovideo-1.orig/src/_exec/mainhandles.s
+++ /dev/null
@@ -1,102 +0,0 @@
-
-
-format elfobj
-
-importx "_gtk_window_list_toplevels" gtk_window_list_toplevels
-importx "_g_list_free" g_list_free
-
-include "../_include/include.h"
-
-
-import "nthwidgetFromcontainer" nthwidgetFromcontainer
-import "firstwidgetFromcontainer" firstwidgetFromcontainer
-
-#########main
-#main window widget
-function mainwidget()
-        data GList#1
-        setcall GList gtk_window_list_toplevels()
-        data widget#1
-        set widget GList#
-        call g_list_free(GList)
-        return widget
-endfunction
-
-########vbox
-#vbox window widget
-function boxwidget()
-        data widget#1
-        setcall widget mainwidget()
-        setcall widget firstwidgetFromcontainer(widget)
-        return widget
-endfunction
-#vbox/nth
-function boxwidget_nth(data index)
-    data widget#1
-    setcall widget boxwidget()
-    setcall widget nthwidgetFromcontainer(widget,index)
-    return widget
-endfunction
-
-#######edit
-function editWidget()
-    data widget#1
-    Data i=mainwinEditIndex
-    setcall widget boxwidget_nth(i)
-    return widget
-endfunction
-#buffer, forward
-importx "_gtk_entry_get_text" gtk_entry_get_text
-function editWidgetBufferForwardData(data forward,data forwarddata)
-    data widget#1
-    setcall widget editWidget()
-    data buffertext#1
-    setcall buffertext gtk_entry_get_text(widget)
-    call forward(buffertext,forwarddata)
-endfunction
-function editWidgetBufferForward(data forward)
-    data n=0
-    call editWidgetBufferForwardData(forward,n)
-endfunction
-
-#######draw
-function drawwidget()
-    data widget#1
-    Data draw=mainwinDrawIndex
-    setcall widget boxwidget_nth(draw)
-    return widget
-endfunction
-
-#######buttons
-function buttonsalignWidget()
-    data widget#1
-    Data mainwinButtonsIndex=mainwinButtonsIndex
-    setcall widget boxwidget_nth(mainwinButtonsIndex)
-    return widget
-endfunction
-
-function buttonswidget()
-    data widget#1
-    setcall widget buttonsalignWidget()
-    setcall widget firstwidgetFromcontainer(widget)
-    return widget
-endfunction
-
-#######stage
-#stage window widget
-function stagewidget()
-    data widget#1
-    Data st=mainwinStageIndex
-    setcall widget boxwidget_nth(st)
-    return widget
-endfunction
-
-#######info
-#info window widget
-#function infowidget()
-#    data widget#1
-#    Data mainwinInfoIndex=mainwinInfoIndex
-#    setcall widget boxwidget_nth(mainwinInfoIndex)
-#    return widget
-#endfunction
-
--- /dev/null
+++ ovideo-1/src/_exec/mediainfo.oc
@@ -0,0 +1,197 @@
+
+
+
+format elfobj
+
+importx "_gst_discoverer_new" gst_discoverer_new
+importx "_gst_discoverer_start" gst_discoverer_start
+importx "_gst_discoverer_discover_uri_async" gst_discoverer_discover_uri_async
+importx "_gst_discoverer_stop" gst_discoverer_stop
+importx "_gst_discoverer_info_get_uri" gst_discoverer_info_get_uri
+importx "_gst_discoverer_info_get_result" gst_discoverer_info_get_result
+
+importx "_gst_object_unref" gst_object_unref
+
+import "strstrdisp" strstrdisp
+
+include "../_include/include.h"
+
+#v/e
+function on_discover(data *discoverer,data info,data gerror,data passdata)
+    str uri#1
+    setcall uri gst_discoverer_info_get_uri(info)
+
+    data result#1
+    setcall result gst_discoverer_info_get_result(info)
+
+    data ok=GST_DISCOVERER_OK
+    data invalid=GST_DISCOVERER_URI_INVALID
+    data error=GST_DISCOVERER_ERROR
+    data timeout=GST_DISCOVERER_TIMEOUT
+    data busy=GST_DISCOVERER_BUSY
+    data misses=GST_DISCOVERER_MISSING_PLUGINS
+
+    if result=ok
+        importx "_gst_discoverer_info_get_video_streams" gst_discoverer_info_get_video_streams
+        importx "_gst_discoverer_info_get_audio_streams" gst_discoverer_info_get_audio_streams
+        importx "_gst_discoverer_stream_info_list_free" gst_discoverer_stream_info_list_free
+        importx "_g_list_first" g_list_first
+
+        data videoinfo#1
+        data audioinfo#1
+
+        str video="Video"
+        str audio="Audio"
+        str both=" and "
+        str nullstring=""
+
+        setcall videoinfo gst_discoverer_info_get_video_streams(info)
+        setcall audioinfo gst_discoverer_info_get_audio_streams(info)
+
+        data videofirst#1
+        data audiofirst#1
+        setcall videofirst g_list_first(videoinfo)
+        setcall audiofirst g_list_first(audioinfo)
+
+        call gst_discoverer_stream_info_list_free(videoinfo)
+        call gst_discoverer_stream_info_list_free(audioinfo)
+
+        data flagV=video
+        data flagA=audio
+        data flagVA=audiovideo
+        data streams#1
+        str v#1
+        str conjunction#1
+        str a#1
+        data null=0
+
+        set streams flagVA
+        if videofirst!=null
+            set v video
+        else
+            set v nullstring
+            xor streams flagV
+        endelse
+        if audiofirst!=null
+            set a audio
+        else
+            set a nullstring
+            xor streams flagA
+        endelse
+        if streams=null
+            str nothingtodo="No video or audio discovered at: "
+            call strstrdisp(nothingtodo,uri)
+        else
+            if streams=flagVA
+                set conjunction both
+            else
+                set conjunction nullstring
+            endelse
+
+            importx "_sprintf" sprintf
+            str infodispformat="%s%s%s %s: "
+            char infodisp#40
+            str infotext^infodisp
+
+            call sprintf(infotext,infodispformat,v,conjunction,a,passdata#)
+            call strstrdisp(infotext,uri)
+
+            data dword=4
+            add passdata dword
+            data forward#1
+            set forward passdata#
+            if forward!=null
+                call forward(uri,streams)
+            endif
+        endelse
+    elseif result=invalid
+        str invuri="Invalid uri: "
+        call strstrdisp(invuri,uri)
+    elseif result=error
+        import "view_gerror_message" view_gerror_message
+        call view_gerror_message(gerror)
+    elseif result=timeout
+        str timeouterr="Timeout error. Uri: "
+        call strstrdisp(timeouterr,uri)
+    elseif result=busy
+        str busyerr="Busy error. Uri: "
+        call strstrdisp(busyerr,uri)
+    elseif result=misses
+        importx "_gst_discoverer_info_get_misc" gst_discoverer_info_get_misc
+        importx "_gst_structure_to_string" gst_structure_to_string
+        importx "_g_free" g_free
+        data st#1
+        setcall st gst_discoverer_info_get_misc(info)
+        str message#1
+        setcall message gst_structure_to_string(st)
+        str missing="Missing plugins: "
+        call strstrdisp(missing,message)
+        call g_free(message)
+    endelseif
+endfunction
+
+function on_finish(data discoverer)
+    call gst_discoverer_stop(discoverer)
+    call gst_object_unref(discoverer)
+endfunction
+
+
+function collect_info_got_src(str src,data discover)
+    data bool#1
+    setcall bool gst_discoverer_discover_uri_async(discover,src)
+    data false=0
+    if bool=false
+        str discerr="Uri media discover failed: "
+        call strstrdisp(discerr,src)
+        call gst_object_unref(discover)
+    endif
+endfunction
+
+function collect_info(str intrusion)
+    data dsc#1
+    data gstsec=GST_SECOND
+    data timeoutsec=10
+
+    import "mult64" mult64
+    data high#1
+    data low#1
+    data ptrhigh^high
+
+    setcall low mult64(gstsec,timeoutsec,ptrhigh)
+
+    import "getptrgerr" getptrgerr
+    import "gerrtoerr" gerrtoerr
+    data ptrgerr#1
+    setcall ptrgerr getptrgerr()
+    setcall dsc gst_discoverer_new(low,high,ptrgerr)
+    data n=0
+    if dsc=n
+        call gerrtoerr(ptrgerr)
+    endif
+
+    import "connect_signal_data" connect_signal_data
+    data discoveredcallback^on_discover
+    str discover="discovered"
+    call connect_signal_data(dsc,discover,discoveredcallback,intrusion)
+
+    import "connect_signal" connect_signal
+    data finishedcallback^on_finish
+    str finish="finished"
+    call connect_signal(dsc,finish,finishedcallback)
+
+    call gst_discoverer_start(dsc)
+
+    import "editWidgetBufferForwardData" editWidgetBufferForwardData
+    data f^collect_info_got_src
+    call editWidgetBufferForwardData(f,dsc)
+endfunction
+
+function gather_info()
+    char detected="detected at"
+
+    str discover^detected
+    data *noforward=0
+    data st^discover
+
+    call collect_info(st)
+endfunction
--- ovideo-1.orig/src/_exec/mediainfo.s
+++ /dev/null
@@ -1,197 +0,0 @@
-
-
-
-format elfobj
-
-importx "_gst_discoverer_new" gst_discoverer_new
-importx "_gst_discoverer_start" gst_discoverer_start
-importx "_gst_discoverer_discover_uri_async" gst_discoverer_discover_uri_async
-importx "_gst_discoverer_stop" gst_discoverer_stop
-importx "_gst_discoverer_info_get_uri" gst_discoverer_info_get_uri
-importx "_gst_discoverer_info_get_result" gst_discoverer_info_get_result
-
-importx "_gst_object_unref" gst_object_unref
-
-import "strstrdisp" strstrdisp
-
-include "../_include/include.h"
-
-#v/e
-function on_discover(data *discoverer,data info,data gerror,data passdata)
-    str uri#1
-    setcall uri gst_discoverer_info_get_uri(info)
-
-    data result#1
-    setcall result gst_discoverer_info_get_result(info)
-
-    data ok=GST_DISCOVERER_OK
-    data invalid=GST_DISCOVERER_URI_INVALID
-    data error=GST_DISCOVERER_ERROR
-    data timeout=GST_DISCOVERER_TIMEOUT
-    data busy=GST_DISCOVERER_BUSY
-    data misses=GST_DISCOVERER_MISSING_PLUGINS
-
-    if result==ok
-        importx "_gst_discoverer_info_get_video_streams" gst_discoverer_info_get_video_streams
-        importx "_gst_discoverer_info_get_audio_streams" gst_discoverer_info_get_audio_streams
-        importx "_gst_discoverer_stream_info_list_free" gst_discoverer_stream_info_list_free
-        importx "_g_list_first" g_list_first
-
-        data videoinfo#1
-        data audioinfo#1
-
-        str video="Video"
-        str audio="Audio"
-        str both=" and "
-        str nullstring=""
-
-        setcall videoinfo gst_discoverer_info_get_video_streams(info)
-        setcall audioinfo gst_discoverer_info_get_audio_streams(info)
-
-        data videofirst#1
-        data audiofirst#1
-        setcall videofirst g_list_first(videoinfo)
-        setcall audiofirst g_list_first(audioinfo)
-
-        call gst_discoverer_stream_info_list_free(videoinfo)
-        call gst_discoverer_stream_info_list_free(audioinfo)
-
-        data flagV=video
-        data flagA=audio
-        data flagVA=audiovideo
-        data streams#1
-        str v#1
-        str conjunction#1
-        str a#1
-        data null=0
-
-        set streams flagVA
-        if videofirst!=null
-            set v video
-        else
-            set v nullstring
-            xor streams flagV
-        endelse
-        if audiofirst!=null
-            set a audio
-        else
-            set a nullstring
-            xor streams flagA
-        endelse
-        if streams==null
-            str nothingtodo="No video or audio discovered at: "
-            call strstrdisp(nothingtodo,uri)
-        else
-            if streams==flagVA
-                set conjunction both
-            else
-                set conjunction nullstring
-            endelse
-
-            importx "_sprintf" sprintf
-            str infodispformat="%s%s%s %s: "
-            char infodisp#40
-            str infotext^infodisp
-
-            call sprintf(infotext,infodispformat,v,conjunction,a,passdata#)
-            call strstrdisp(infotext,uri)
-
-            data dword=4
-            add passdata dword
-            data forward#1
-            set forward passdata#
-            if forward!=null
-                call forward(uri,streams)
-            endif
-        endelse
-    elseif result==invalid
-        str invuri="Invalid uri: "
-        call strstrdisp(invuri,uri)
-    elseif result==error
-        import "view_gerror_message" view_gerror_message
-        call view_gerror_message(gerror)
-    elseif result==timeout
-        str timeouterr="Timeout error. Uri: "
-        call strstrdisp(timeouterr,uri)
-    elseif result==busy
-        str busyerr="Busy error. Uri: "
-        call strstrdisp(busyerr,uri)
-    elseif result==misses
-        importx "_gst_discoverer_info_get_misc" gst_discoverer_info_get_misc
-        importx "_gst_structure_to_string" gst_structure_to_string
-        importx "_g_free" g_free
-        data st#1
-        setcall st gst_discoverer_info_get_misc(info)
-        str message#1
-        setcall message gst_structure_to_string(st)
-        str missing="Missing plugins: "
-        call strstrdisp(missing,message)
-        call g_free(message)
-    endelseif
-endfunction
-
-function on_finish(data discoverer)
-    call gst_discoverer_stop(discoverer)
-    call gst_object_unref(discoverer)
-endfunction
-
-
-function collect_info_got_src(str src,data discover)
-    data bool#1
-    setcall bool gst_discoverer_discover_uri_async(discover,src)
-    data false=0
-    if bool==false
-        str discerr="Uri media discover failed: "
-        call strstrdisp(discerr,src)
-        call gst_object_unref(discover)
-    endif
-endfunction
-
-function collect_info(str intrusion)
-    data dsc#1
-    data gstsec=GST_SECOND
-    data timeoutsec=10
-
-    import "mult64" mult64
-    data high#1
-    data low#1
-    data ptrhigh^high
-
-    setcall low mult64(gstsec,timeoutsec,ptrhigh)
-
-    import "getptrgerr" getptrgerr
-    import "gerrtoerr" gerrtoerr
-    data ptrgerr#1
-    setcall ptrgerr getptrgerr()
-    setcall dsc gst_discoverer_new(low,high,ptrgerr)
-    data n=0
-    if dsc==n
-        call gerrtoerr(ptrgerr)
-    endif
-
-    import "connect_signal_data" connect_signal_data
-    data discoveredcallback^on_discover
-    str discover="discovered"
-    call connect_signal_data(dsc,discover,discoveredcallback,intrusion)
-
-    import "connect_signal" connect_signal
-    data finishedcallback^on_finish
-    str finish="finished"
-    call connect_signal(dsc,finish,finishedcallback)
-
-    call gst_discoverer_start(dsc)
-
-    import "editWidgetBufferForwardData" editWidgetBufferForwardData
-    data f^collect_info_got_src
-    call editWidgetBufferForwardData(f,dsc)
-endfunction
-
-function gather_info()
-    char detected="detected at"
-
-    str discover^detected
-    data *noforward=0
-    data st^discover
-
-    call collect_info(st)
-endfunction
--- /dev/null
+++ ovideo-1/src/_exec/mix.oc
@@ -0,0 +1,286 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+import "texter" texter
+
+#err
+function mix_timeout_verify(sd file)
+    data filelength#1
+    const ptr_filelength^filelength
+    sd newfilelength
+    sd ptr_newfilelength^newfilelength
+    import "file_length" file_length
+    sd err
+    setcall err file_length(file,ptr_newfilelength)
+    if err!=(noerror)
+        return err
+    endif
+    if filelength=newfilelength
+        str timeexpired="Timeout, stopped"
+        call texter(timeexpired)
+        data dialog#1
+        const ptr_dlg_for_time^dialog
+        importx "_gtk_dialog_response" gtk_dialog_response
+        call gtk_dialog_response(dialog,(GTK_RESPONSE_CANCEL))
+        return timeexpired
+    endif
+    set filelength newfilelength
+    return (noerror)
+endfunction
+
+importx "_gtk_entry_get_text" gtk_entry_get_text
+
+#timeout function 0 stop
+function mix_timeout(sd *data)
+    #terminates this loop if pipe was unset
+    data pipe#1
+    const ptr_pipe_for_timeout^pipe
+    if pipe=0
+        return 0
+    endif
+
+    #verify if file length was changed
+    str dest#1
+    const ptr_dest^dest
+    import "file_forward_read" file_forward_read
+    data f^mix_timeout_verify
+    sd err
+    setcall err file_forward_read(dest,f)
+    if err!=(noerror)
+        return 0
+    endif
+
+	#append one dot or set one dot
+	import "get_current_texter_pointer" get_current_texter_pointer
+	sd texter_ptr
+	setcall texter_ptr get_current_texter_pointer()
+	sd widget
+	set widget texter_ptr#
+	sd text
+	setcall text gtk_entry_get_text(widget)
+	sd pos
+	sd ptr_pos^pos
+	char onedot={Period,0}
+	import "slen" slen
+	setcall pos slen(text)
+	if pos=3
+		call texter(#onedot)
+		return 1
+	endif
+	importx "_gtk_editable_insert_text" gtk_editable_insert_text
+	call gtk_editable_insert_text(widget,#onedot,1,ptr_pos)
+	return 1
+endfunction
+
+function mix_init_save(sd vbox,sd dialog)
+    #modal with pipe signals
+    data pipe#1
+    const ptr_pipe^pipe
+    import "default_signals_for_modal" default_signals_for_modal
+    call default_signals_for_modal(pipe,dialog)
+
+    #label
+    str text="Muxing to file. Please wait..."
+    import "labelfield_l" labelfield_l
+    call labelfield_l(text,vbox)
+
+    #new texter
+    import "new_texter_modal" new_texter_modal
+    call new_texter_modal(vbox,dialog)
+
+    #pointer for timeout and close dialog
+    data ptr_dlg%ptr_dlg_for_time
+    set ptr_dlg# dialog
+endfunction
+function mix_done_save()
+    sd ptr_dest%ptr_dest
+    import "save_inform_saved" save_inform_saved
+    call save_inform_saved(ptr_dest#)
+endfunction
+
+importx "_sprintf" sprintf
+
+function mix_launch_got_command(sd command)
+    #create the pipe
+    import "launch_pipe_start" launch_pipe_start
+    sd ptr_pipe_tm%ptr_pipe_for_timeout
+    setcall ptr_pipe_tm# launch_pipe_start(command)
+    sd pipe
+    set pipe ptr_pipe_tm#
+    if pipe=0
+        return 0
+    endif
+    sd ptr_pipe%ptr_pipe
+    set ptr_pipe# pipe
+
+    #set the timeout interval
+    import "strtoint_positive" strtoint_positive
+    data tm#1
+    const ptr_tm^tm
+    sd timeout
+    sd ptr_timeout^timeout
+    ss text
+    setcall text gtk_entry_get_text(tm)
+    sd bool
+    setcall bool strtoint_positive(text,ptr_timeout)
+    if bool=0
+        return 0
+    endif
+    mult timeout 1000
+    data f^mix_timeout
+    importx "_gdk_threads_add_timeout" gdk_threads_add_timeout
+    call gdk_threads_add_timeout(timeout,f,0)
+    #and set the file length value to 0
+    sd ptr_length%ptr_filelength
+    set ptr_length# 0
+
+    #launch the modal waiter
+    sd init^mix_init_save
+    sd done^mix_done_save
+    str waiter="Mux save"
+
+    import "dialogfield_size_button" dialogfield_size_button
+    str GTK_STOCK_CANCEL="gtk-cancel"
+    call dialogfield_size_button(waiter,(GTK_DIALOG_MODAL),init,done,200,100,GTK_STOCK_CANCEL,(GTK_RESPONSE_CANCEL))
+
+    import "default_unref_ptr" default_unref_ptr
+    call default_unref_ptr(ptr_pipe_tm)
+endfunction
+
+import "allocsum_null" allocsum_null
+importx "_free" free
+
+function mix_launch_got_audio_string(sd audiostring)
+    data vid#1
+    const ptr_vid^vid
+
+    str format#1
+    str sr#1
+    str sr_prop#1
+    str video#1
+    str dst#1
+    str audio#1
+    data *=0
+    sd ptr_launchformat^format
+
+    str nullstr=""
+
+    import "save_get_main_format" save_get_main_format
+    import "save_get_video_format" save_get_video_format
+    import "save_get_ogg_dest" save_get_ogg_dest
+
+    setcall format save_get_main_format()
+    setcall sr gtk_entry_get_text(vid)
+    set sr_prop nullstr
+    setcall video save_get_video_format()
+    setcall dst save_get_ogg_dest()
+    sd ptr_destination%ptr_dest
+    set ptr_destination# dst
+    set audio audiostring
+
+    sd launchstring
+    sd ptr_launchstring^launchstring
+    sd err
+    setcall err allocsum_null(ptr_launchformat,ptr_launchstring)
+    if err!=(noerror)
+        return err
+    endif
+
+    call sprintf(launchstring,format,sr,sr_prop,video,dst,audio)
+    call mix_launch_got_command(launchstring)
+
+    call free(launchstring)
+endfunction
+
+
+function mix_launch()
+    data snd#1
+    const ptr_snd^snd
+
+    import "save_get_sec_format" save_get_sec_format
+    import "save_get_audio_format" save_get_audio_format
+
+    char audio_vars_data#40
+
+    #let first space otherelse will be pipe start unable
+    ss audiogetformat=" uridecodebin uri=\"%s\"%s"
+    ss audioloc#1
+    ss audio_vars^audio_vars_data
+    ss *=0
+    sd ptr_audio_uri^audiogetformat
+
+    str nullstr=""
+
+    setcall audioloc gtk_entry_get_text(snd)
+
+    sd audioformat
+    setcall audioformat save_get_sec_format()
+    sd audio
+    setcall audio save_get_audio_format()
+    call sprintf(audio_vars,audioformat,nullstr,audio)
+
+    sd audiostring
+    sd ptr_audiostring^audiostring
+    sd err
+    setcall err allocsum_null(ptr_audio_uri,ptr_audiostring)
+    if err!=(noerror)
+        return err
+    endif
+
+    call sprintf(audiostring,audiogetformat,audioloc,audio_vars)
+    call mix_launch_got_audio_string(audiostring)
+
+    call free(audiostring)
+endfunction
+
+
+function mix_init(sd vbox,sd *dialog)
+    sd video
+    sd entryv
+    sd audio
+    sd entrya
+    sd timeout
+    sd entryt
+    sd cells^video
+
+    data rows=3
+    data cols=2
+
+    importx "_gtk_entry_new" gtk_entry_new
+
+    import "labelfield_left_prepare" labelfield_left_prepare
+
+    str v="Video source uri"
+    setcall video labelfield_left_prepare(v)
+    setcall entryv gtk_entry_new()
+    sd vd%ptr_vid
+    set vd# entryv
+    str a="Audio source uri"
+    setcall audio labelfield_left_prepare(a)
+    setcall entrya gtk_entry_new()
+    sd sd%ptr_snd
+    set sd# entrya
+    str t="Inactivity timeout in seconds"
+    setcall timeout labelfield_left_prepare(t)
+    setcall entryt gtk_entry_new()
+    sd tm%ptr_tm
+    set tm# entryt
+
+    importx "_gtk_entry_set_text" gtk_entry_set_text
+    str defaulttimeout="10"
+    call gtk_entry_set_text(entryt,defaulttimeout)
+
+    import "tablefield_cells" tablefield_cells
+    call tablefield_cells(vbox,rows,cols,cells)
+endfunction
+
+function mix_start()
+    ss title="Audio Video Mix"
+    data init^mix_init
+    data do^mix_launch
+    import "dialogfield" dialogfield
+    call dialogfield(title,(GTK_DIALOG_MODAL),init,do)
+endfunction
--- ovideo-1.orig/src/_exec/mix.s
+++ /dev/null
@@ -1,286 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-import "texter" texter
-
-#err
-function mix_timeout_verify(sd file)
-    data filelength#1
-    const ptr_filelength^filelength
-    sd newfilelength
-    sd ptr_newfilelength^newfilelength
-    import "file_length" file_length
-    sd err
-    setcall err file_length(file,ptr_newfilelength)
-    if err!=(noerror)
-        return err
-    endif
-    if filelength==newfilelength
-        str timeexpired="Timeout, stopped"
-        call texter(timeexpired)
-        data dialog#1
-        const ptr_dlg_for_time^dialog
-        importx "_gtk_dialog_response" gtk_dialog_response
-        call gtk_dialog_response(dialog,(GTK_RESPONSE_CANCEL))
-        return timeexpired
-    endif
-    set filelength newfilelength
-    return (noerror)
-endfunction
-
-importx "_gtk_entry_get_text" gtk_entry_get_text
-
-#timeout function 0 stop
-function mix_timeout(sd *data)
-    #terminates this loop if pipe was unset
-    data pipe#1
-    const ptr_pipe_for_timeout^pipe
-    if pipe==0
-        return 0
-    endif
-
-    #verify if file length was changed
-    str dest#1
-    const ptr_dest^dest
-    import "file_forward_read" file_forward_read
-    data f^mix_timeout_verify
-    sd err
-    setcall err file_forward_read(dest,f)
-    if err!=(noerror)
-        return 0
-    endif
-
-	#append one dot or set one dot
-	import "get_current_texter_pointer" get_current_texter_pointer
-	sd texter_ptr
-	setcall texter_ptr get_current_texter_pointer()
-	sd widget
-	set widget texter_ptr#
-	sd text
-	setcall text gtk_entry_get_text(widget)
-	sd pos
-	sd ptr_pos^pos
-	char onedot={Period,0}
-	import "slen" slen
-	setcall pos slen(text)
-	if pos==3
-		call texter(#onedot)
-		return 1
-	endif
-	importx "_gtk_editable_insert_text" gtk_editable_insert_text
-	call gtk_editable_insert_text(widget,#onedot,1,ptr_pos)
-	return 1
-endfunction
-
-function mix_init_save(sd vbox,sd dialog)
-    #modal with pipe signals
-    data pipe#1
-    const ptr_pipe^pipe
-    import "default_signals_for_modal" default_signals_for_modal
-    call default_signals_for_modal(pipe,dialog)
-
-    #label
-    str text="Muxing to file. Please wait..."
-    import "labelfield_l" labelfield_l
-    call labelfield_l(text,vbox)
-
-    #new texter
-    import "new_texter_modal" new_texter_modal
-    call new_texter_modal(vbox,dialog)
-
-    #pointer for timeout and close dialog
-    data ptr_dlg%ptr_dlg_for_time
-    set ptr_dlg# dialog
-endfunction
-function mix_done_save()
-    sd ptr_dest%ptr_dest
-    import "save_inform_saved" save_inform_saved
-    call save_inform_saved(ptr_dest#)
-endfunction
-
-importx "_sprintf" sprintf
-
-function mix_launch_got_command(sd command)
-    #create the pipe
-    import "launch_pipe_start" launch_pipe_start
-    sd ptr_pipe_tm%ptr_pipe_for_timeout
-    setcall ptr_pipe_tm# launch_pipe_start(command)
-    sd pipe
-    set pipe ptr_pipe_tm#
-    if pipe==0
-        return 0
-    endif
-    sd ptr_pipe%ptr_pipe
-    set ptr_pipe# pipe
-
-    #set the timeout interval
-    import "strtoint_positive" strtoint_positive
-    data tm#1
-    const ptr_tm^tm
-    sd timeout
-    sd ptr_timeout^timeout
-    ss text
-    setcall text gtk_entry_get_text(tm)
-    sd bool
-    setcall bool strtoint_positive(text,ptr_timeout)
-    if bool==0
-        return 0
-    endif
-    mult timeout 1000
-    data f^mix_timeout
-    importx "_gdk_threads_add_timeout" gdk_threads_add_timeout
-    call gdk_threads_add_timeout(timeout,f,0)
-    #and set the file length value to 0
-    sd ptr_length%ptr_filelength
-    set ptr_length# 0
-
-    #launch the modal waiter
-    sd init^mix_init_save
-    sd done^mix_done_save
-    str waiter="Mux save"
-
-    import "dialogfield_size_button" dialogfield_size_button
-    str GTK_STOCK_CANCEL="gtk-cancel"
-    call dialogfield_size_button(waiter,(GTK_DIALOG_MODAL),init,done,200,100,GTK_STOCK_CANCEL,(GTK_RESPONSE_CANCEL))
-
-    import "default_unref_ptr" default_unref_ptr
-    call default_unref_ptr(ptr_pipe_tm)
-endfunction
-
-import "allocsum_null" allocsum_null
-importx "_free" free
-
-function mix_launch_got_audio_string(sd audiostring)
-    data vid#1
-    const ptr_vid^vid
-
-    str format#1
-    str sr#1
-    str sr_prop#1
-    str video#1
-    str dst#1
-    str audio#1
-    data *=0
-    sd ptr_launchformat^format
-
-    str nullstr=""
-
-    import "save_get_main_format" save_get_main_format
-    import "save_get_video_format" save_get_video_format
-    import "save_get_ogg_dest" save_get_ogg_dest
-
-    setcall format save_get_main_format()
-    setcall sr gtk_entry_get_text(vid)
-    set sr_prop nullstr
-    setcall video save_get_video_format()
-    setcall dst save_get_ogg_dest()
-    sd ptr_destination%ptr_dest
-    set ptr_destination# dst
-    set audio audiostring
-
-    sd launchstring
-    sd ptr_launchstring^launchstring
-    sd err
-    setcall err allocsum_null(ptr_launchformat,ptr_launchstring)
-    if err!=(noerror)
-        return err
-    endif
-
-    call sprintf(launchstring,format,sr,sr_prop,video,dst,audio)
-    call mix_launch_got_command(launchstring)
-
-    call free(launchstring)
-endfunction
-
-
-function mix_launch()
-    data snd#1
-    const ptr_snd^snd
-
-    import "save_get_sec_format" save_get_sec_format
-    import "save_get_audio_format" save_get_audio_format
-
-    char audio_vars_data#40
-
-    #let first space otherelse will be pipe start unable
-    ss audiogetformat=" uridecodebin uri=\"%s\"%s"
-    ss audioloc#1
-    ss audio_vars^audio_vars_data
-    ss *=0
-    sd ptr_audio_uri^audiogetformat
-
-    str nullstr=""
-
-    setcall audioloc gtk_entry_get_text(snd)
-
-    sd audioformat
-    setcall audioformat save_get_sec_format()
-    sd audio
-    setcall audio save_get_audio_format()
-    call sprintf(audio_vars,audioformat,nullstr,audio)
-
-    sd audiostring
-    sd ptr_audiostring^audiostring
-    sd err
-    setcall err allocsum_null(ptr_audio_uri,ptr_audiostring)
-    if err!=(noerror)
-        return err
-    endif
-
-    call sprintf(audiostring,audiogetformat,audioloc,audio_vars)
-    call mix_launch_got_audio_string(audiostring)
-
-    call free(audiostring)
-endfunction
-
-
-function mix_init(sd vbox,sd *dialog)
-    sd video
-    sd entryv
-    sd audio
-    sd entrya
-    sd timeout
-    sd entryt
-    sd cells^video
-
-    data rows=3
-    data cols=2
-
-    importx "_gtk_entry_new" gtk_entry_new
-
-    import "labelfield_left_prepare" labelfield_left_prepare
-
-    str v="Video source uri"
-    setcall video labelfield_left_prepare(v)
-    setcall entryv gtk_entry_new()
-    sd vd%ptr_vid
-    set vd# entryv
-    str a="Audio source uri"
-    setcall audio labelfield_left_prepare(a)
-    setcall entrya gtk_entry_new()
-    sd sd%ptr_snd
-    set sd# entrya
-    str t="Inactivity timeout in seconds"
-    setcall timeout labelfield_left_prepare(t)
-    setcall entryt gtk_entry_new()
-    sd tm%ptr_tm
-    set tm# entryt
-
-    importx "_gtk_entry_set_text" gtk_entry_set_text
-    str defaulttimeout="10"
-    call gtk_entry_set_text(entryt,defaulttimeout)
-
-    import "tablefield_cells" tablefield_cells
-    call tablefield_cells(vbox,rows,cols,cells)
-endfunction
-
-function mix_start()
-    ss title="Audio Video Mix"
-    data init^mix_init
-    data do^mix_launch
-    import "dialogfield" dialogfield
-    call dialogfield(title,(GTK_DIALOG_MODAL),init,do)
-endfunction
--- /dev/null
+++ ovideo-1/src/_exec/ostream.oc
@@ -0,0 +1,48 @@
+
+format elfobj
+
+include "../_include/include.h"
+
+importx "_gtk_init" gtk_init
+importx "_gst_init" gst_init
+importx "_gtk_main" gtk_main
+#importx "_exit" exit
+
+import "initfn" initfn
+
+include "../_dif/difl.oc" "../_dif/difw.oc"
+
+call gtk_init(0,0)
+call gst_init(0,0)
+
+importx "_setlocale" setlocale
+call setlocale((LC_NUMERIC),"C") #"English" was ok
+#there are 3 sscanf getting the '.'
+
+importx "_g_thread_init" g_thread_init
+call g_thread_init(0)
+
+import "gstset" gstset
+call gstset()
+import "link_mass_remove" link_mass_remove
+call link_mass_remove((value_set),0)
+import "capture_terminal" capture_terminal
+call capture_terminal((value_set),0)
+import "sound_preview_bool" sound_preview_bool
+sd sound_prev
+setcall sound_prev sound_preview_bool()
+set sound_prev# 0
+
+call initfn()
+
+call gtk_main()
+
+import "gstunset" gstunset
+import "search_clear_memory" search_clear_memory
+import "prog_free" prog_free
+call gstunset()
+call search_clear_memory()
+call prog_free()
+
+#normal return no, gtk_main problems (in this context)
+include "../_dif/lin.oc" "../_dif/win.oc"
--- ovideo-1.orig/src/_exec/ostream.s
+++ /dev/null
@@ -1,48 +0,0 @@
-
-format elfobj
-
-include "../_include/include.h"
-
-importx "_gtk_init" gtk_init
-importx "_gst_init" gst_init
-importx "_gtk_main" gtk_main
-#importx "_exit" exit
-
-import "initfn" initfn
-
-include "../_dif/difl.s" "../_dif/difw.s"
-
-call gtk_init(0,0)
-call gst_init(0,0)
-
-importx "_setlocale" setlocale
-call setlocale((LC_NUMERIC),"C") #"English" was ok
-#there are 3 sscanf getting the '.'
-
-importx "_g_thread_init" g_thread_init
-call g_thread_init(0)
-
-import "gstset" gstset
-call gstset()
-import "link_mass_remove" link_mass_remove
-call link_mass_remove((value_set),0)
-import "capture_terminal" capture_terminal
-call capture_terminal((value_set),0)
-import "sound_preview_bool" sound_preview_bool
-sd sound_prev
-setcall sound_prev sound_preview_bool()
-set sound_prev# 0
-
-call initfn()
-
-call gtk_main()
-
-import "gstunset" gstunset
-import "search_clear_memory" search_clear_memory
-import "prog_free" prog_free
-call gstunset()
-call search_clear_memory()
-call prog_free()
-
-#normal return no, gtk_main problems (in this context)
-include "../_dif/lin.s" "../_dif/win.s"
--- /dev/null
+++ ovideo-1/src/_exec/start.oc
@@ -0,0 +1,257 @@
+
+
+
+
+format elfobj
+
+importx "_gtk_window_new" gtk_window_new
+importx "_gtk_window_set_title" gtk_window_set_title
+importx "_gtk_window_set_default_size" gtk_window_set_default_size
+importx "_gtk_main_quit" gtk_main_quit
+importx "_gtk_widget_show_all" gtk_widget_show_all
+
+importx "_g_signal_connect_data" g_signal_connect_data
+
+import "vboxfield" vboxfield
+import "editfieldEnter" editfieldEnter
+import "setwndicon" setwndicon
+import "mainwidget" mainwidget
+import "drawfield" drawfield
+import "streamuri" streamuri
+
+include "../_include/include.h"
+
+
+##########images
+import "movetoScriptfolder" movetoScriptfolder
+
+#returns the stage function for set click on stage button
+function buttons_combinations()
+    import "stage_start" stage_start
+    char button="prepare.bmp"
+    char *="Media edit panel"
+    data match^stage_start
+    data *=0
+
+    import "play_click" play_click
+    char *="play.bmp"
+    char *="Play the media"
+    data *^play_click
+    import "info_save_stream" info_save_stream
+    char *="save.bmp"
+    char *="Save the stream to a file"
+    data *^info_save_stream
+    import "gather_info" gather_info
+    char *="info.bmp"
+    char *="Detect if the stream has audio or video"
+    data *^gather_info
+    import "stop" stop
+    char *="close.bmp"
+    char *="Stop the play or the save actions"
+    data *^stop
+    data *=0
+
+    import "search_parse" search_parse
+    char *="search.bmp"
+    char *="Search for all streams at the uri using the rules from the search preferences"
+    data *^search_parse
+    import "show_preferences" show_preferences
+    char *="preferences.bmp"
+    char *="Display the search preferences window"
+    data *^show_preferences
+    data *=0
+
+    import "mix_start" mix_start
+    char *="mix.bmp"
+    char *="Mux video and audio from two uri-s"
+    data *^mix_start
+    data *=0
+
+    import "view_use_file" view_use_file
+    char *="help.bmp"
+    char *="View informations about the program"
+    data *^view_use_file
+    data *=0
+
+    data *=0
+
+    const ptrpoiner_init^button
+
+    return match
+endfunction
+
+function setsystems()
+    #call to check new version
+    import "update" update
+    call update()
+
+    #search markups
+    import "search_preferences_init" search_preferences_init
+    call search_preferences_init()
+
+    #stage file options
+    import "stage_file_options_init" stage_file_options_init
+    call stage_file_options_init()
+endfunction
+
+import "buttons_lots_ex" buttons_lots_ex
+
+function setimages()
+    #icon
+    str icon="1616.jpg"
+    data widget#1
+    setcall widget mainwidget()
+    call setwndicon(widget,icon)
+
+    #buttons
+    data buttons#1
+    import "buttonswidget" buttonswidget
+    setcall buttons buttonswidget()
+    data ptr%ptrpoiner_init
+    sd match
+    setcall match buttons_combinations()
+    data forward_stagebutton^stagebutton_forward
+    call buttons_lots_ex(ptr,buttons,match,forward_stagebutton)
+
+    #stage buttons
+    import "stage_buttons" stage_buttons
+    call stage_buttons()
+endfunction
+
+function stagebutton_forward(sd widget,sv function)
+    call function(widget)
+endfunction
+
+import "folder_enterleave" folder_enterleave
+import "folder_enterleave_data" folder_enterleave_data
+import "img_folder" img_folder
+
+function img_folder_enterleave(sd forward)
+    ss img
+    setcall img img_folder()
+    call folder_enterleave(img,forward)
+endfunction
+function img_folder_enterleave_data(sd forward,sd data)
+    ss img
+    setcall img img_folder()
+    call folder_enterleave_data(img,forward,data)
+endfunction
+
+function sys_folder()
+    str system="sys"
+    return system
+endfunction
+
+function sys_folder_enterleave(sd forward)
+    sd system
+    setcall system sys_folder()
+    call folder_enterleave(system,forward)
+endfunction
+
+import "init_user" init_user
+import "texter" texter
+
+#v
+function callbackprocessfolder()
+	#set stage trace sizes
+	import "stage_trace_min_size_set" stage_trace_min_size_set
+	call stage_trace_min_size_set()
+
+	#move to imgs
+	data imgforward^setimages
+	call img_folder_enterleave(imgforward)
+
+	sd err
+	setcall err init_user()
+	if err=(noerror)
+		#move to settings
+		data sysforward^setsystems
+		call sys_folder_enterleave(sysforward)
+		return (void)
+	endif
+	call texter(err)
+endfunction
+
+######main
+#void
+function initfn()
+    data null=NULL
+
+    data GTK_WINDOW_TOPLEVEL=GTK_WINDOW_TOPLEVEL
+    data window#1
+    setcall window gtk_window_new(GTK_WINDOW_TOPLEVEL)
+
+    char programname="OStream"
+    str program^programname
+    call gtk_window_set_title(window,program)
+
+    data width=800
+    #832
+    #848
+    data height=600
+    #624
+    #662
+    call gtk_window_set_default_size(window,width,height)
+
+    data ptr_gtk_main_quit^gtk_main_quit
+    char destr="destroy"
+    str destroy^destr
+    call g_signal_connect_data(window,destroy,ptr_gtk_main_quit,null,null,null)
+
+    data vbox#1
+    setcall vbox vboxfield(window)
+
+    data length=0xffff
+    data callback^streamuri
+    call editfieldEnter(vbox,length,callback)
+
+    data video#1
+    setcall video drawfield(vbox)
+    #gtk_widget_set_double_buffered(video_window,FALSE)
+
+    #to keep the stage frames
+    import "stage_sel_prepare_img_space" stage_sel_prepare_img_space
+    call stage_sel_prepare_img_space()
+    #add event expose
+    import "connect_signal" connect_signal
+    import "stage_paint_event" stage_paint_event
+    str expose="expose-event"
+    data f^stage_paint_event
+    call connect_signal(video,expose,f)
+
+    import "alignmentfield" alignmentfield
+    import "hboxfield_cnt" hboxfield_cnt
+    data alignment#1
+    setcall alignment alignmentfield(vbox)
+    data hbox#1
+    setcall hbox hboxfield_cnt(alignment)
+
+    import "stage_init" stage_init
+    sd edits
+    setcall edits stage_init()
+
+    #texter added
+    import "editinfofield_green" editinfofield_green
+    data maintexter#1
+    const ptr_maintexter^maintexter
+    setcall maintexter editinfofield_green(vbox)
+
+    import "gstplayinit" gstplayinit
+    call gstplayinit(video)
+
+    #get the process folder to load the images
+    data ptrcallback^callbackprocessfolder
+
+    call movetoScriptfolder(ptrcallback)
+
+    call gtk_widget_show_all(window)
+    #importx "_gtk_widget_hide_all" gtk_widget_hide_all
+    #call gtk_widget_hide_all(edits)
+endfunction
+#void
+
+function get_current_texter_pointer()
+    data retvalue%ptr_maintexter
+    return retvalue
+endfunction
+
--- ovideo-1.orig/src/_exec/start.s
+++ /dev/null
@@ -1,257 +0,0 @@
-
-
-
-
-format elfobj
-
-importx "_gtk_window_new" gtk_window_new
-importx "_gtk_window_set_title" gtk_window_set_title
-importx "_gtk_window_set_default_size" gtk_window_set_default_size
-importx "_gtk_main_quit" gtk_main_quit
-importx "_gtk_widget_show_all" gtk_widget_show_all
-
-importx "_g_signal_connect_data" g_signal_connect_data
-
-import "vboxfield" vboxfield
-import "editfieldEnter" editfieldEnter
-import "setwndicon" setwndicon
-import "mainwidget" mainwidget
-import "drawfield" drawfield
-import "streamuri" streamuri
-
-include "../_include/include.h"
-
-
-##########images
-import "movetoScriptfolder" movetoScriptfolder
-
-#returns the stage function for set click on stage button
-function buttons_combinations()
-    import "stage_start" stage_start
-    char button="prepare.bmp"
-    char *="Media edit panel"
-    data match^stage_start
-    data *=0
-
-    import "play_click" play_click
-    char *="play.bmp"
-    char *="Play the media"
-    data *^play_click
-    import "info_save_stream" info_save_stream
-    char *="save.bmp"
-    char *="Save the stream to a file"
-    data *^info_save_stream
-    import "gather_info" gather_info
-    char *="info.bmp"
-    char *="Detect if the stream has audio or video"
-    data *^gather_info
-    import "stop" stop
-    char *="close.bmp"
-    char *="Stop the play or the save actions"
-    data *^stop
-    data *=0
-
-    import "search_parse" search_parse
-    char *="search.bmp"
-    char *="Search for all streams at the uri using the rules from the search preferences"
-    data *^search_parse
-    import "show_preferences" show_preferences
-    char *="preferences.bmp"
-    char *="Display the search preferences window"
-    data *^show_preferences
-    data *=0
-
-    import "mix_start" mix_start
-    char *="mix.bmp"
-    char *="Mux video and audio from two uri-s"
-    data *^mix_start
-    data *=0
-
-    import "view_use_file" view_use_file
-    char *="help.bmp"
-    char *="View informations about the program"
-    data *^view_use_file
-    data *=0
-
-    data *=0
-
-    const ptrpoiner_init^button
-
-    return match
-endfunction
-
-function setsystems()
-    #call to check new version
-    import "update" update
-    call update()
-
-    #search markups
-    import "search_preferences_init" search_preferences_init
-    call search_preferences_init()
-
-    #stage file options
-    import "stage_file_options_init" stage_file_options_init
-    call stage_file_options_init()
-endfunction
-
-import "buttons_lots_ex" buttons_lots_ex
-
-function setimages()
-    #icon
-    str icon="1616.jpg"
-    data widget#1
-    setcall widget mainwidget()
-    call setwndicon(widget,icon)
-
-    #buttons
-    data buttons#1
-    import "buttonswidget" buttonswidget
-    setcall buttons buttonswidget()
-    data ptr%ptrpoiner_init
-    sd match
-    setcall match buttons_combinations()
-    data forward_stagebutton^stagebutton_forward
-    call buttons_lots_ex(ptr,buttons,match,forward_stagebutton)
-
-    #stage buttons
-    import "stage_buttons" stage_buttons
-    call stage_buttons()
-endfunction
-
-function stagebutton_forward(sd widget,sd function)
-    call function(widget)
-endfunction
-
-import "folder_enterleave" folder_enterleave
-import "folder_enterleave_data" folder_enterleave_data
-import "img_folder" img_folder
-
-function img_folder_enterleave(sd forward)
-    ss img
-    setcall img img_folder()
-    call folder_enterleave(img,forward)
-endfunction
-function img_folder_enterleave_data(sd forward,sd data)
-    ss img
-    setcall img img_folder()
-    call folder_enterleave_data(img,forward,data)
-endfunction
-
-function sys_folder()
-    str system="sys"
-    return system
-endfunction
-
-function sys_folder_enterleave(sd forward)
-    sd system
-    setcall system sys_folder()
-    call folder_enterleave(system,forward)
-endfunction
-
-import "init_user" init_user
-import "texter" texter
-
-#v
-function callbackprocessfolder()
-	#set stage trace sizes
-	import "stage_trace_min_size_set" stage_trace_min_size_set
-	call stage_trace_min_size_set()
-
-	#move to imgs
-	data imgforward^setimages
-	call img_folder_enterleave(imgforward)
-
-	sd err
-	setcall err init_user()
-	if err==(noerror)
-		#move to settings
-		data sysforward^setsystems
-		call sys_folder_enterleave(sysforward)
-		return (void)
-	endif
-	call texter(err)
-endfunction
-
-######main
-#void
-function initfn()
-    data null=NULL
-
-    data GTK_WINDOW_TOPLEVEL=GTK_WINDOW_TOPLEVEL
-    data window#1
-    setcall window gtk_window_new(GTK_WINDOW_TOPLEVEL)
-
-    char programname="OStream"
-    str program^programname
-    call gtk_window_set_title(window,program)
-
-    data width=800
-    #832
-    #848
-    data height=600
-    #624
-    #662
-    call gtk_window_set_default_size(window,width,height)
-
-    data ptr_gtk_main_quit^gtk_main_quit
-    char destr="destroy"
-    str destroy^destr
-    call g_signal_connect_data(window,destroy,ptr_gtk_main_quit,null,null,null)
-
-    data vbox#1
-    setcall vbox vboxfield(window)
-
-    data length=0xffff
-    data callback^streamuri
-    call editfieldEnter(vbox,length,callback)
-
-    data video#1
-    setcall video drawfield(vbox)
-    #gtk_widget_set_double_buffered(video_window,FALSE)
-
-    #to keep the stage frames
-    import "stage_sel_prepare_img_space" stage_sel_prepare_img_space
-    call stage_sel_prepare_img_space()
-    #add event expose
-    import "connect_signal" connect_signal
-    import "stage_paint_event" stage_paint_event
-    str expose="expose-event"
-    data f^stage_paint_event
-    call connect_signal(video,expose,f)
-
-    import "alignmentfield" alignmentfield
-    import "hboxfield_cnt" hboxfield_cnt
-    data alignment#1
-    setcall alignment alignmentfield(vbox)
-    data hbox#1
-    setcall hbox hboxfield_cnt(alignment)
-
-    import "stage_init" stage_init
-    sd edits
-    setcall edits stage_init()
-
-    #texter added
-    import "editinfofield_green" editinfofield_green
-    data maintexter#1
-    const ptr_maintexter^maintexter
-    setcall maintexter editinfofield_green(vbox)
-
-    import "gstplayinit" gstplayinit
-    call gstplayinit(video)
-
-    #get the process folder to load the images
-    data ptrcallback^callbackprocessfolder
-
-    call movetoScriptfolder(ptrcallback)
-
-    call gtk_widget_show_all(window)
-    #importx "_gtk_widget_hide_all" gtk_widget_hide_all
-    #call gtk_widget_hide_all(edits)
-endfunction
-#void
-
-function get_current_texter_pointer()
-    data retvalue%ptr_maintexter
-    return retvalue
-endfunction
-
--- /dev/null
+++ ovideo-1/src/_exec/uri.oc
@@ -0,0 +1,157 @@
+
+format elfobj
+
+import "texter" texter
+
+include "../_include/include.h"
+
+function setplaybin2(data value)
+    data playbin2#1
+    const propagateplaybin2^playbin2
+    set playbin2 value
+endfunction
+
+#playbin2
+function getplaybin2ptr()
+    data propagateplaybin2%propagateplaybin2
+    return propagateplaybin2
+endfunction
+
+#void gtkwidget::realize
+importx "_gtk_widget_get_window" gtk_widget_get_window
+importx "_gdk_window_ensure_native" gdk_window_ensure_native
+importx "_gst_x_overlay_set_window_handle" gst_x_overlay_set_window_handle
+importx "_gst_x_overlay_get_type" gst_x_overlay_get_type
+importx "_gst_implements_interface_cast" gst_implements_interface_cast
+importx "_gst_element_implements_interface" gst_element_implements_interface
+
+import "gdkGetdrawable" gdkGetdrawable
+
+function video_realize(data widget)
+	data window#1
+	setcall window gtk_widget_get_window(widget)
+
+	data false=0
+	sd bool
+	setcall bool gdk_window_ensure_native(window)
+	if bool=false
+		str noNative="Couldn't create native window needed for GstXOverlay!"
+		call texter(noNative)
+	endif
+
+	#Pass it to playbin2, which implements XOverlay and will forward it to the video sink
+	#on >= ubuntu 12 with debs from 2012.11(almost same place with 2012.11 msi file) this is a not
+	sv playbin2
+	setcall playbin2 getplaybin2ptr()
+	set playbin2 playbin2#
+	sd overlaytype
+	setcall overlaytype gst_x_overlay_get_type()
+	setcall bool gst_element_implements_interface(playbin2,overlaytype)
+	if bool=(TRUE)
+		sd interfacecast
+		setcall interfacecast gst_implements_interface_cast(playbin2,overlaytype)
+		sd drawablehandle
+		setcall drawablehandle gdkGetdrawable(window)
+		call gst_x_overlay_set_window_handle(interfacecast,drawablehandle)
+		return (void)
+	endif
+	import "printer" printer
+	call printer("gst_element_implements_interface false.")
+endfunction
+
+import "unset_playbool" unset_playbool
+
+function gstset()
+    data null=0
+    call setplaybin2(null)
+    call unset_playbool()
+endfunction
+
+importx "_gst_element_set_state" gst_element_set_state
+function set_pipe_null(data pipe)
+    call gst_element_set_state(pipe,(GST_STATE_NULL))
+endfunction
+
+#locations: 1. end of stream;
+#           2. top level window closing;
+#           3. stream start(stop 1,start 2);
+#           4. stop click
+#rec: same and also unref at error
+function nullifyplaybin()
+    data playbin2ptr#1
+    setcall playbin2ptr getplaybin2ptr()
+    call set_pipe_null(playbin2ptr#)
+    call unset_playbool()
+endfunction
+
+import "rec_unset" rec_unset
+function gstunset()
+    #playbin
+    data playbin2ptr#1
+    setcall playbin2ptr getplaybin2ptr()
+    data playbin#1
+    set playbin playbin2ptr#
+    data null=0
+    if playbin!=null
+        call nullifyplaybin()
+        import "unset_pipe_and_watch" unset_pipe_and_watch
+        call unset_pipe_and_watch(playbin)
+    endif
+    call rec_unset()
+endfunction
+
+import "connect_signal" connect_signal
+function addSignals(data bus,sd *callbackdata)
+    import "endofstream" endofstream
+    str eos="message::eos"
+    data endofstreamfn^endofstream
+    call connect_signal(bus,eos,endofstreamfn)
+
+    import "streamerror" streamerror
+    str error="message::error"
+    data errorfn^streamerror
+    call connect_signal(bus,error,errorfn)
+
+    import "statechanged" statechanged
+    str state_changed="message::state-changed"
+    data state^statechanged
+    call connect_signal(bus,state_changed,state)
+endfunction
+
+importx "_gst_element_factory_make" gst_element_factory_make
+#void/err
+function gstplayinit(data videowidget)
+    data null=0
+
+    import "rec_set" rec_set
+    call rec_set(null)
+
+    data playbin2ptr#1
+    str playbin2str="playbin2"
+    setcall playbin2ptr getplaybin2ptr()
+
+    setcall playbin2ptr# gst_element_factory_make(playbin2str,playbin2str)
+    #needing gstreamer0.10-plugins-good
+
+    data playbin2#1
+    set playbin2 playbin2ptr#
+
+    if playbin2=null
+        str factoryerr="Not all elements could be created."
+        call texter(factoryerr)
+        return factoryerr
+    endif
+    import "add_bus_signal_watch" add_bus_signal_watch
+    call add_bus_signal_watch(playbin2)
+
+    #draw area
+    data v_realize^video_realize
+    str callrealize="realize"
+    call connect_signal(videowidget,callrealize,v_realize)
+
+    import "bus_signals" bus_signals
+    #bus signals
+    data add_signals^addSignals
+    call bus_signals(playbin2,add_signals)
+endfunction
+
--- ovideo-1.orig/src/_exec/uri.s
+++ /dev/null
@@ -1,157 +0,0 @@
-
-format elfobj
-
-import "texter" texter
-
-include "../_include/include.h"
-
-function setplaybin2(data value)
-    data playbin2#1
-    const propagateplaybin2^playbin2
-    set playbin2 value
-endfunction
-
-#playbin2
-function getplaybin2ptr()
-    data propagateplaybin2%propagateplaybin2
-    return propagateplaybin2
-endfunction
-
-#void gtkwidget::realize
-importx "_gtk_widget_get_window" gtk_widget_get_window
-importx "_gdk_window_ensure_native" gdk_window_ensure_native
-importx "_gst_x_overlay_set_window_handle" gst_x_overlay_set_window_handle
-importx "_gst_x_overlay_get_type" gst_x_overlay_get_type
-importx "_gst_implements_interface_cast" gst_implements_interface_cast
-importx "_gst_element_implements_interface" gst_element_implements_interface
-
-import "gdkGetdrawable" gdkGetdrawable
-
-function video_realize(data widget)
-	data window#1
-	setcall window gtk_widget_get_window(widget)
-
-	data false=0
-	sd bool
-	setcall bool gdk_window_ensure_native(window)
-	if bool==false
-		str noNative="Couldn't create native window needed for GstXOverlay!"
-		call texter(noNative)
-	endif
-
-	#Pass it to playbin2, which implements XOverlay and will forward it to the video sink
-	#on >= ubuntu 12 with debs from 2012.11(almost same place with 2012.11 msi file) this is a not
-	sv playbin2
-	setcall playbin2 getplaybin2ptr()
-	set playbin2 playbin2#
-	sd overlaytype
-	setcall overlaytype gst_x_overlay_get_type()
-	setcall bool gst_element_implements_interface(playbin2,overlaytype)
-	if bool==(TRUE)
-		sd interfacecast
-		setcall interfacecast gst_implements_interface_cast(playbin2,overlaytype)
-		sd drawablehandle
-		setcall drawablehandle gdkGetdrawable(window)
-		call gst_x_overlay_set_window_handle(interfacecast,drawablehandle)
-		return (void)
-	endif
-	import "printer" printer
-	call printer("gst_element_implements_interface false.")
-endfunction
-
-import "unset_playbool" unset_playbool
-
-function gstset()
-    data null=0
-    call setplaybin2(null)
-    call unset_playbool()
-endfunction
-
-importx "_gst_element_set_state" gst_element_set_state
-function set_pipe_null(data pipe)
-    call gst_element_set_state(pipe,(GST_STATE_NULL))
-endfunction
-
-#locations: 1. end of stream;
-#           2. top level window closing;
-#           3. stream start(stop 1,start 2);
-#           4. stop click
-#rec: same and also unref at error
-function nullifyplaybin()
-    data playbin2ptr#1
-    setcall playbin2ptr getplaybin2ptr()
-    call set_pipe_null(playbin2ptr#)
-    call unset_playbool()
-endfunction
-
-import "rec_unset" rec_unset
-function gstunset()
-    #playbin
-    data playbin2ptr#1
-    setcall playbin2ptr getplaybin2ptr()
-    data playbin#1
-    set playbin playbin2ptr#
-    data null=0
-    if playbin!=null
-        call nullifyplaybin()
-        import "unset_pipe_and_watch" unset_pipe_and_watch
-        call unset_pipe_and_watch(playbin)
-    endif
-    call rec_unset()
-endfunction
-
-import "connect_signal" connect_signal
-function addSignals(data bus,sd *callbackdata)
-    import "endofstream" endofstream
-    str eos="message::eos"
-    data endofstreamfn^endofstream
-    call connect_signal(bus,eos,endofstreamfn)
-
-    import "streamerror" streamerror
-    str error="message::error"
-    data errorfn^streamerror
-    call connect_signal(bus,error,errorfn)
-
-    import "statechanged" statechanged
-    str state_changed="message::state-changed"
-    data state^statechanged
-    call connect_signal(bus,state_changed,state)
-endfunction
-
-importx "_gst_element_factory_make" gst_element_factory_make
-#void/err
-function gstplayinit(data videowidget)
-    data null=0
-
-    import "rec_set" rec_set
-    call rec_set(null)
-
-    data playbin2ptr#1
-    str playbin2str="playbin2"
-    setcall playbin2ptr getplaybin2ptr()
-
-    setcall playbin2ptr# gst_element_factory_make(playbin2str,playbin2str)
-    #needing gstreamer0.10-plugins-good
-
-    data playbin2#1
-    set playbin2 playbin2ptr#
-
-    if playbin2==null
-        str factoryerr="Not all elements could be created."
-        call texter(factoryerr)
-        return factoryerr
-    endif
-    import "add_bus_signal_watch" add_bus_signal_watch
-    call add_bus_signal_watch(playbin2)
-
-    #draw area
-    data v_realize^video_realize
-    str callrealize="realize"
-    call connect_signal(videowidget,callrealize,v_realize)
-
-    import "bus_signals" bus_signals
-    #bus signals
-    data add_signals^addSignals
-    call bus_signals(playbin2,add_signals)
-endfunction
-
--- /dev/null
+++ ovideo-1/src/_exec/uristream.oc
@@ -0,0 +1,365 @@
+
+format elfobj
+
+include "../_include/include.h"
+
+importx "_sprintf" sprintf
+importx "_sscanf" sscanf
+importx "_strlen" strlen
+
+import "getplaybin2ptr" getplaybin2ptr
+
+import "nullifyplaybin" nullifyplaybin
+import "texter" texter
+function endofstream()
+    str eos="End Of Stream"
+    call texter(eos)
+    call nullifyplaybin()
+endfunction
+
+importx "_gst_message_parse_error" gst_message_parse_error
+import "getptrgerr" getptrgerr
+import "gerrtoerr" gerrtoerr
+function stream_error(data message)
+    data ptrgerr#1
+    setcall ptrgerr getptrgerr()
+    data null=NULL
+    call gst_message_parse_error(message,ptrgerr,null)
+    call gerrtoerr(ptrgerr)
+endfunction
+function streamerror(data *bus,data message)
+    call stream_error(message)
+endfunction
+
+import "ulltoa" ulltoa
+
+const u64bytes=20
+#18,446,744,073,684,385,791
+
+function ldiv_lowdivisor(sv p,sd dividendlow,sd dividendhigh,sd divisor)
+	#sd input#(4/:*3)+3
+	char input#u64bytes+1
+	ss instr^input
+
+	#%llu linux ok
+	#windows? %I64u this is not working
+	#call sprintf(instr,"%llu",dividendlow,dividendhigh)
+	#call texter(instr)
+	call ulltoa(dividendlow,dividendhigh,instr)
+
+	# As result can be very large store it in string
+	#sd quotient#(4/:*3)+3
+	char quotient#u64bytes
+	sd rem
+	ss dest;set dest instr
+	addcall dest strlen(instr)
+	setcall dest ldiv_lowdivisor_s(#quotient,instr,dest,divisor,#rem)
+	if instr!=dest
+		# set quotient and remainder
+
+		#set dest# 0;call sscanf(#quotient,"%llu",p) #same as above but _strtoull is problematic at libmingwex.a
+		call memto64(#quotient,dest,p)
+
+		add p (2*:)
+		set p# rem
+	else
+		# If divisor is greater than number
+		set p# 0
+		add p :
+		set p# 0
+		add p :
+		set p# dividendlow
+	endelse
+endfunction
+function ldiv_lowdivisor_s(ss outstr,ss instr,ss dest,sd divisor,sd p_rem)
+	sd start;set start instr
+	if divisor>(0xcCCccCC) #(this-1)*10+9 equal 0x7f...F7 +0xa equal 0x8...1
+		#there will be troubles in two places without this
+		dec dest
+		if instr=dest
+			return start
+		endif
+		set dest# 0
+		div divisor 10
+	endif
+	# Find prefix of number that is larger than divisor.
+	sd n
+	sd temp
+	set temp instr#
+	sub temp (_0)
+	while temp<divisor
+		inc instr
+		if instr=dest
+			return start
+		endif
+		set n instr#
+		sub n (_0)
+		#sd test
+		#...
+		#dec instr
+		#else
+		mult temp 10
+		add temp n
+	endwhile
+	# Repeatedly divide divisor with temp. After every division, update temp to include one more digit.
+	while instr!=dest
+		# Store result in answer i.e. temp / divisor
+		set n temp
+		div n divisor
+		add n (_0)
+		set outstr# n
+		inc outstr
+		# Take next digit of number
+		rem temp divisor
+		inc instr
+		if instr!=dest
+			mult temp 10
+			add temp instr#
+			sub temp (_0)
+		endif
+	endwhile
+	set p_rem# temp
+	return outstr
+endfunction
+function memto64(sd in,ss dest,sd out)
+	const hconv64=16+1
+	char h#hconv64
+	#sd h#(4/:*2)+3
+	ss hex^h
+	add hex (hconv64-1)
+	sd sz;set sz hex
+	set hex# 0
+	char quotient#u64bytes
+	sd in2;set in2 #quotient
+	sd rem
+
+	sd prev
+	set prev dest
+	setcall dest ldiv_lowdivisor_s(in2,in,dest,16,#rem)
+	while in!=dest
+		dec hex
+		setcall hex# inttohchar(rem)
+		sd aux;set aux in2
+		set in2 in;set in aux
+		set prev dest
+		setcall dest ldiv_lowdivisor_s(in2,in,dest,16,#rem)
+	endwhile
+	set prev# 0;call sscanf(in,"%u",#rem)
+	dec hex;setcall hex# inttohchar(rem)
+
+	sd high
+	sub sz hex
+	if sz>8
+		set high hex
+		sub sz 8
+		add hex sz
+	else
+		set high (NULL)
+	endelse
+	call sscanf(hex,"%x",out)
+	add out :
+	if high!=(NULL)
+		set hex# 0
+		call sscanf(high,"%x",out)
+		return (void)
+	endif
+	set out# 0
+endfunction
+function inttohchar(sd a)
+	if a<10
+		add a (_0)
+	else
+		add a (A-10)
+	endelse
+	return a
+endfunction
+
+function splitGstClockTime(data ptrclock,data ptrtime)
+    data dword=4
+
+    data clockLow#1
+    data clockHigh#1
+    data ptrH#1
+    data ptrM#1
+    data ptrS#1
+    set clockLow ptrclock#
+    add ptrclock dword
+    set clockHigh ptrclock#
+    set ptrH ptrtime
+    add ptrtime dword
+    set ptrM ptrtime
+    add ptrtime dword
+    set ptrS ptrtime
+
+    data nomLow#1
+    #data nomHigh=0
+    sd resLow
+    sd resHigh
+    sd remLow
+    #data *remHigh#1
+    sd ptrresult^resLow
+
+    data gstsec=GST_SECOND
+    set nomLow gstsec
+    call ldiv_lowdivisor(ptrresult,clockLow,clockHigh,nomLow) #,nomHigh
+
+    data secinH=3600
+    set nomLow secinH
+    call ldiv_lowdivisor(ptrresult,resLow,resHigh,nomLow) #,nomHigh
+
+    set ptrH# resLow
+
+    data thenumber=60
+    data x#1
+    set x remLow
+    div x thenumber
+    set ptrM# x
+
+    mult x thenumber
+    sub remLow x
+    set ptrS# remLow
+endfunction
+
+importx "_gst_element_query_position" gst_element_query_position
+#false=stop timer,true=displayed
+function streamtimer(data *data)
+	data playbool#1
+	const globalplaybool^playbool
+	data true=1
+	data false=0
+
+	if playbool=true
+		data duration64low#1
+		data *duration64high#1
+		data ptrduration^duration64low
+		const ptrduration^duration64low
+
+		data current64low#1
+		data *current64high#1
+		data ptrcurrent^current64low
+
+		data bool#1
+		data ptrplaybin#1
+		data format=GST_FORMAT_TIME
+		data ptrformat^format
+
+		setcall ptrplaybin getplaybin2ptr()
+		setcall bool gst_element_query_position(ptrplaybin#,ptrformat,ptrcurrent)
+		if bool=false
+			str poserr="Could not query current position."
+			call texter(poserr)
+		else
+			char printduration#10+1+2+1+2+3+10+1+2+1+2+1
+			str print^printduration
+
+			data durH#1
+			data durM#1
+			data durS#1
+			data posH#1
+			data posM#1
+			data posS#1
+
+			data ptrdur^durH
+			data ptrpos^posH
+
+			call splitGstClockTime(ptrduration,ptrdur)
+			call splitGstClockTime(ptrcurrent,ptrpos)
+
+			str timeformat="%u:%02u:%02u / %u:%02u:%02u"
+			call sprintf(print,timeformat,posH,posM,posS,durH,durM,durS)
+			call texter(print)
+			return true
+		endelse
+	endif
+	data threadID=-1
+	const p_threadID^threadID
+	set threadID -1
+	return false
+endfunction
+
+function unset_playbool()
+    data ptr%globalplaybool
+    data false=0
+    set ptr# false
+endfunction
+function get_playbool()
+    data ptr%globalplaybool
+    return ptr#
+endfunction
+
+importx "_gst_message_parse_state_changed" gst_message_parse_state_changed
+importx "_gdk_threads_add_timeout" gdk_threads_add_timeout
+function statechanged(data *bus,data message)
+	data newstate#1
+	data ptrnewstate^newstate
+	data null=0
+	call gst_message_parse_state_changed(message,null,ptrnewstate,null)
+
+	data GST_STATE_PLAYING=GST_STATE_PLAYING
+	if newstate=GST_STATE_PLAYING
+		data quadword=8
+
+		sd duration%ptrduration
+
+		import "setmem" setmem
+		call setmem(duration,quadword,(GST_CLOCK_TIME_NONE_lowhigh))
+
+		importx "_gst_element_query_duration" gst_element_query_duration
+		data format=GST_FORMAT_TIME
+		data ptrformat^format
+		data ptrplaybin#1
+		setcall ptrplaybin getplaybin2ptr()
+		call gst_element_query_duration(ptrplaybin#,ptrformat,duration)
+
+		if duration#!=(GST_CLOCK_TIME_NONE_lowhigh)
+			add duration (DWORD)
+			if duration#!=(GST_CLOCK_TIME_NONE_lowhigh)
+				vdata p_threadID%p_threadID
+				if p_threadID#<0
+
+					data ptrplaybool%globalplaybool
+					data true=1
+
+					set ptrplaybool# true
+					data msec=1000
+					data tm^streamtimer
+					setcall p_threadID# gdk_threads_add_timeout(msec,tm,null)
+
+					str playing="Playing..."
+					call texter(playing)
+				endif
+			endif
+		endif
+	endif
+endfunction
+
+import "rec_unset" rec_unset
+function stop()
+    call nullifyplaybin()
+    call rec_unset()
+    str stopped="Stopped"
+    call texter(stopped)
+endfunction
+
+importx "_g_object_set" g_object_set
+importx "_gst_element_set_state" gst_element_set_state
+#void
+function streamuri(data buffer)
+    call nullifyplaybin()
+
+    data playbin2ptr#1
+    setcall playbin2ptr getplaybin2ptr()
+
+    data null=0
+    str uri="uri"
+    call g_object_set(playbin2ptr#,uri,buffer,null)
+
+    data GST_STATE_PLAYING=GST_STATE_PLAYING
+    call gst_element_set_state(playbin2ptr#,GST_STATE_PLAYING)
+endfunction
+
+function play_click()
+    import "editWidgetBufferForward" editWidgetBufferForward
+    data forward^streamuri
+    call editWidgetBufferForward(forward)
+endfunction
--- ovideo-1.orig/src/_exec/uristream.s
+++ /dev/null
@@ -1,365 +0,0 @@
-
-format elfobj
-
-include "../_include/include.h"
-
-importx "_sprintf" sprintf
-importx "_sscanf" sscanf
-importx "_strlen" strlen
-
-import "getplaybin2ptr" getplaybin2ptr
-
-import "nullifyplaybin" nullifyplaybin
-import "texter" texter
-function endofstream()
-    str eos="End Of Stream"
-    call texter(eos)
-    call nullifyplaybin()
-endfunction
-
-importx "_gst_message_parse_error" gst_message_parse_error
-import "getptrgerr" getptrgerr
-import "gerrtoerr" gerrtoerr
-function stream_error(data message)
-    data ptrgerr#1
-    setcall ptrgerr getptrgerr()
-    data null=NULL
-    call gst_message_parse_error(message,ptrgerr,null)
-    call gerrtoerr(ptrgerr)
-endfunction
-function streamerror(data *bus,data message)
-    call stream_error(message)
-endfunction
-
-import "ulltoa" ulltoa
-
-const u64bytes=20
-#18,446,744,073,684,385,791
-
-function ldiv_lowdivisor(sv p,sd dividendlow,sd dividendhigh,sd divisor)
-	#sd input#(4/:*3)+3
-	char input#u64bytes+1
-	ss instr^input
-
-	#%llu linux ok
-	#windows? %I64u this is not working
-	#call sprintf(instr,"%llu",dividendlow,dividendhigh)
-	#call texter(instr)
-	call ulltoa(dividendlow,dividendhigh,instr)
-
-	# As result can be very large store it in string
-	#sd quotient#(4/:*3)+3
-	char quotient#u64bytes
-	sd rem
-	ss dest;set dest instr
-	addcall dest strlen(instr)
-	setcall dest ldiv_lowdivisor_s(#quotient,instr,dest,divisor,#rem)
-	if instr!=dest
-		# set quotient and remainder
-
-		#set dest# 0;call sscanf(#quotient,"%llu",p) #same as above but _strtoull is problematic at libmingwex.a
-		call memto64(#quotient,dest,p)
-
-		add p (2*:)
-		set p# rem
-	else
-		# If divisor is greater than number
-		set p# 0
-		add p :
-		set p# 0
-		add p :
-		set p# dividendlow
-	endelse
-endfunction
-function ldiv_lowdivisor_s(ss outstr,ss instr,ss dest,sd divisor,sd p_rem)
-	sd start;set start instr
-	if divisor>(0xcCCccCC) #(this-1)*10+9=0x7f...F7 +0xa=0x8...1
-		#there will be troubles in two places without this
-		dec dest
-		if instr==dest
-			return start
-		endif
-		set dest# 0
-		div divisor 10
-	endif
-	# Find prefix of number that is larger than divisor.
-	sd n
-	sd temp
-	set temp instr#
-	sub temp (_0)
-	while temp<divisor
-		inc instr
-		if instr==dest
-			return start
-		endif
-		set n instr#
-		sub n (_0)
-		#sd test
-		#...
-		#dec instr
-		#else
-		mult temp 10
-		add temp n
-	endwhile
-	# Repeatedly divide divisor with temp. After every division, update temp to include one more digit.
-	while instr!=dest
-		# Store result in answer i.e. temp / divisor
-		set n temp
-		div n divisor
-		add n (_0)
-		set outstr# n
-		inc outstr
-		# Take next digit of number
-		rem temp divisor
-		inc instr
-		if instr!=dest
-			mult temp 10
-			add temp instr#
-			sub temp (_0)
-		endif
-	endwhile
-	set p_rem# temp
-	return outstr
-endfunction
-function memto64(sd in,ss dest,sd out)
-	const hconv64=16+1
-	char h#hconv64
-	#sd h#(4/:*2)+3
-	ss hex^h
-	add hex (hconv64-1)
-	sd sz;set sz hex
-	set hex# 0
-	char quotient#u64bytes
-	sd in2;set in2 #quotient
-	sd rem
-
-	sd prev
-	set prev dest
-	setcall dest ldiv_lowdivisor_s(in2,in,dest,16,#rem)
-	while in!=dest
-		dec hex
-		setcall hex# inttohchar(rem)
-		sd aux;set aux in2
-		set in2 in;set in aux
-		set prev dest
-		setcall dest ldiv_lowdivisor_s(in2,in,dest,16,#rem)
-	endwhile
-	set prev# 0;call sscanf(in,"%u",#rem)
-	dec hex;setcall hex# inttohchar(rem)
-
-	sd high
-	sub sz hex
-	if sz>8
-		set high hex
-		sub sz 8
-		add hex sz
-	else
-		set high (NULL)
-	endelse
-	call sscanf(hex,"%x",out)
-	add out :
-	if high!=(NULL)
-		set hex# 0
-		call sscanf(high,"%x",out)
-		return (void)
-	endif
-	set out# 0
-endfunction
-function inttohchar(sd a)
-	if a<10
-		add a (_0)
-	else
-		add a (A-10)
-	endelse
-	return a
-endfunction
-
-function splitGstClockTime(data ptrclock,data ptrtime)
-    data dword=4
-
-    data clockLow#1
-    data clockHigh#1
-    data ptrH#1
-    data ptrM#1
-    data ptrS#1
-    set clockLow ptrclock#
-    add ptrclock dword
-    set clockHigh ptrclock#
-    set ptrH ptrtime
-    add ptrtime dword
-    set ptrM ptrtime
-    add ptrtime dword
-    set ptrS ptrtime
-
-    data nomLow#1
-    #data nomHigh=0
-    sd resLow
-    sd resHigh
-    sd remLow
-    #data *remHigh#1
-    sd ptrresult^resLow
-
-    data gstsec=GST_SECOND
-    set nomLow gstsec
-    call ldiv_lowdivisor(ptrresult,clockLow,clockHigh,nomLow) #,nomHigh
-
-    data secinH=3600
-    set nomLow secinH
-    call ldiv_lowdivisor(ptrresult,resLow,resHigh,nomLow) #,nomHigh
-
-    set ptrH# resLow
-
-    data thenumber=60
-    data x#1
-    set x remLow
-    div x thenumber
-    set ptrM# x
-
-    mult x thenumber
-    sub remLow x
-    set ptrS# remLow
-endfunction
-
-importx "_gst_element_query_position" gst_element_query_position
-#false=stop timer,true=displayed
-function streamtimer(data *data)
-	data playbool#1
-	const globalplaybool^playbool
-	data true=1
-	data false=0
-
-	if playbool==true
-		data duration64low#1
-		data *duration64high#1
-		data ptrduration^duration64low
-		const ptrduration^duration64low
-
-		data current64low#1
-		data *current64high#1
-		data ptrcurrent^current64low
-
-		data bool#1
-		data ptrplaybin#1
-		data format=GST_FORMAT_TIME
-		data ptrformat^format
-
-		setcall ptrplaybin getplaybin2ptr()
-		setcall bool gst_element_query_position(ptrplaybin#,ptrformat,ptrcurrent)
-		if bool==false
-			str poserr="Could not query current position."
-			call texter(poserr)
-		else
-			char printduration#10+1+2+1+2+3+10+1+2+1+2+1
-			str print^printduration
-
-			data durH#1
-			data durM#1
-			data durS#1
-			data posH#1
-			data posM#1
-			data posS#1
-
-			data ptrdur^durH
-			data ptrpos^posH
-
-			call splitGstClockTime(ptrduration,ptrdur)
-			call splitGstClockTime(ptrcurrent,ptrpos)
-
-			str timeformat="%u:%02u:%02u / %u:%02u:%02u"
-			call sprintf(print,timeformat,posH,posM,posS,durH,durM,durS)
-			call texter(print)
-			return true
-		endelse
-	endif
-	data threadID=-1
-	const p_threadID^threadID
-	set threadID -1
-	return false
-endfunction
-
-function unset_playbool()
-    data ptr%globalplaybool
-    data false=0
-    set ptr# false
-endfunction
-function get_playbool()
-    data ptr%globalplaybool
-    return ptr#
-endfunction
-
-importx "_gst_message_parse_state_changed" gst_message_parse_state_changed
-importx "_gdk_threads_add_timeout" gdk_threads_add_timeout
-function statechanged(data *bus,data message)
-	data newstate#1
-	data ptrnewstate^newstate
-	data null=0
-	call gst_message_parse_state_changed(message,null,ptrnewstate,null)
-
-	data GST_STATE_PLAYING=GST_STATE_PLAYING
-	if newstate==GST_STATE_PLAYING
-		data quadword=8
-
-		sd duration%ptrduration
-
-		import "setmem" setmem
-		call setmem(duration,quadword,(GST_CLOCK_TIME_NONE_lowhigh))
-
-		importx "_gst_element_query_duration" gst_element_query_duration
-		data format=GST_FORMAT_TIME
-		data ptrformat^format
-		data ptrplaybin#1
-		setcall ptrplaybin getplaybin2ptr()
-		call gst_element_query_duration(ptrplaybin#,ptrformat,duration)
-
-		if duration#!=(GST_CLOCK_TIME_NONE_lowhigh)
-			add duration (DWORD)
-			if duration#!=(GST_CLOCK_TIME_NONE_lowhigh)
-				vdata p_threadID%p_threadID
-				if p_threadID#<0
-
-					data ptrplaybool%globalplaybool
-					data true=1
-
-					set ptrplaybool# true
-					data msec=1000
-					data tm^streamtimer
-					setcall p_threadID# gdk_threads_add_timeout(msec,tm,null)
-
-					str playing="Playing..."
-					call texter(playing)
-				endif
-			endif
-		endif
-	endif
-endfunction
-
-import "rec_unset" rec_unset
-function stop()
-    call nullifyplaybin()
-    call rec_unset()
-    str stopped="Stopped"
-    call texter(stopped)
-endfunction
-
-importx "_g_object_set" g_object_set
-importx "_gst_element_set_state" gst_element_set_state
-#void
-function streamuri(data buffer)
-    call nullifyplaybin()
-
-    data playbin2ptr#1
-    setcall playbin2ptr getplaybin2ptr()
-
-    data null=0
-    str uri="uri"
-    call g_object_set(playbin2ptr#,uri,buffer,null)
-
-    data GST_STATE_PLAYING=GST_STATE_PLAYING
-    call gst_element_set_state(playbin2ptr#,GST_STATE_PLAYING)
-endfunction
-
-function play_click()
-    import "editWidgetBufferForward" editWidgetBufferForward
-    data forward^streamuri
-    call editWidgetBufferForward(forward)
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/effect/base.oc
@@ -0,0 +1,433 @@
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+import "hboxfield_cnt" hboxfield_cnt
+
+##the number of frames
+
+data nr_frames_entry#1
+const p_nr_frames_entry^nr_frames_entry
+
+function stage_effect_get_nr_frames_entry()
+    sd p%p_nr_frames_entry
+    return p#
+endfunction
+
+function stage_effect_nr_frames(sd vbox)
+    sd hbox
+    import "labelfield_l" labelfield_l
+    #the effect frames
+    setcall hbox hboxfield_cnt(vbox)
+    ss text="Effect number of frames: "
+    call labelfield_l(text,hbox)
+    import "editfield_pack" editfield_pack
+    sd p_edit%p_nr_frames_entry
+    setcall p_edit# editfield_pack(hbox)
+endfunction
+
+importx "_gtk_entry_get_text" gtk_entry_get_text
+importx "_gtk_radio_button_new_with_label" gtk_radio_button_new_with_label
+importx "_gtk_radio_button_get_group" gtk_radio_button_get_group
+
+##in or out
+
+#out return
+function stage_effect_in_out(sd vbox,ss t_in,ss t_out)
+    sd hbox
+    setcall hbox hboxfield_cnt(vbox)
+
+    sd in
+    setcall in gtk_radio_button_new_with_label(0,t_in)
+
+    sd radiogroup
+    setcall radiogroup gtk_radio_button_get_group(in)
+
+    sd out
+    setcall out gtk_radio_button_new_with_label(radiogroup,t_out)
+
+    import "packstart_default" packstart_default
+    call packstart_default(hbox,in)
+    call packstart_default(hbox,out)
+
+    return out
+endfunction
+
+##background
+
+data color_button#1
+const p_color_button^color_button
+data image_button#1
+const p_image_button^image_button
+
+function stage_effect_get_image_button()
+    sd p_image_button%p_image_button
+    return p_image_button#
+endfunction
+function stage_effect_get_color_button()
+    sd p_color_button%p_color_button
+    return p_color_button#
+endfunction
+
+import "labelfield_left_default" labelfield_left_default
+
+function stage_effect_background(sd vbox)
+    import "hseparatorfield" hseparatorfield
+
+    call hseparatorfield(vbox)
+
+    #color
+    sd p_color%p_color_button
+    ss color_text="Color: "
+    import "colorbuttonfield_leftlabel" colorbuttonfield_leftlabel
+    setcall p_color# colorbuttonfield_leftlabel(color_text,vbox)
+
+    ss text1="Selected frame OVER Color."
+    call labelfield_left_default(text1,vbox)
+
+    ss text_or="OR"
+    call labelfield_left_default(text_or,vbox)
+
+    import "fchooserbuttonfield_open" fchooserbuttonfield_open
+    ss text2="Image from file fit (color at free space) OVER Selected frame:"
+    call labelfield_left_default(text2,vbox)
+    sd p_image_button%p_image_button
+    ss ib_text="Image"
+    setcall p_image_button# fchooserbuttonfield_open(vbox,ib_text)
+
+    call hseparatorfield(vbox)
+endfunction
+
+##effect loop function
+
+function stage_effect_new(sv forward,sd data)
+    sd bool
+    data nr#1
+    #the effect frames
+    sd nr_edit
+    setcall nr_edit stage_effect_get_nr_frames_entry()
+    sd nr_text
+    setcall nr_text gtk_entry_get_text(nr_edit)
+    sd p_nr^nr
+    import "strtoint_positive_twoorgreater" strtoint_positive_twoorgreater
+    setcall bool strtoint_positive_twoorgreater(nr_text,p_nr)
+    if bool=0
+        set nr 2
+    endif
+
+    #get sel position
+    import "stage_get_sel_pos" stage_get_sel_pos
+    sd pos
+    setcall pos stage_get_sel_pos()
+    #total positions for reorder compare
+    import "stage_get_frames" stage_get_frames
+    sd total_pos
+    setcall total_pos stage_get_frames()
+    #new frames pos(without sel,that is also a new frame)
+    inc pos
+    #frames container for reorder
+    import "stage_get_frames_container" stage_get_frames_container
+    sd box
+    setcall box stage_get_frames_container()
+    #newframepos
+    sd newframepos
+    set newframepos pos
+    #nr-1
+    sd last_index
+    set last_index nr
+    dec last_index
+
+    #new frames with length like sel
+    import "stage_get_sel_fr_length" stage_get_sel_fr_length
+    sd length
+    setcall length stage_get_sel_fr_length()
+    import "stage_frame_time_numbers" stage_frame_time_numbers
+    call stage_frame_time_numbers((stage_frame_time_insert),pos,length,last_index)
+
+    #pixbuf for the effect
+    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
+    sd pixbuf
+    sd p_pixbuf^pixbuf
+    call stage_get_sel_pixbuf(p_pixbuf)
+
+    #test for not accessing invalid memory
+    #import "rgb_test" rgb_test
+    #setcall bool rgb_test(pixbuf)
+    #if bool==0
+    #    return 0
+    #endif
+
+    #get dimensions
+    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+    importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+    sd w
+    setcall w gdk_pixbuf_get_width(pixbuf)
+    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+    sd h
+    setcall h gdk_pixbuf_get_height(pixbuf)
+    importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
+    sd rowstride
+    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
+
+    #color and new image
+    #color from bytes to dword
+    import "color_widget_get_color_to_rgb" color_widget_get_color_to_rgb
+    sd colors_entry
+    setcall colors_entry stage_effect_get_color_button()
+    sd uint_color
+    setcall uint_color color_widget_get_color_to_rgb(colors_entry)
+    #animation pixbuf from new image or the selected frame
+    sd animpixbuf
+    importx "_g_object_unref" g_object_unref
+
+    sd newimage_entry
+    setcall newimage_entry stage_effect_get_image_button()
+    import "file_chooser_get_fname" file_chooser_get_fname
+    import "new_pixbuf_color" new_pixbuf_color
+    sd filename
+    setcall filename file_chooser_get_fname(newimage_entry)
+    if filename=0
+        set animpixbuf pixbuf
+    else
+        setcall animpixbuf new_pixbuf_color(w,h,uint_color)
+        if animpixbuf=0
+            return 0
+        endif
+        import "pixbuf_from_file" pixbuf_from_file
+        sd filepixbuf
+        setcall filepixbuf pixbuf_from_file(filename)
+        if filepixbuf=0
+            return 0
+        endif
+        import "stage_pixbuf_in_container_pixbuf" stage_pixbuf_in_container_pixbuf
+        call stage_pixbuf_in_container_pixbuf(filepixbuf,animpixbuf)
+        call g_object_unref(filepixbuf)
+        importx "_g_free" g_free
+        call g_free(filename)
+    endelse
+
+    #get the in/out value
+    sd in_out_entry
+    setcall in_out_entry stage_effect_inout(1)
+    importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
+    sd in_out
+    setcall in_out gtk_toggle_button_get_active(in_out_entry)
+
+    import "stage_get_sel_parent" stage_get_sel_parent
+    import "stage_new_click_area" stage_new_click_area
+    sd effectpixbuf
+    sd k=0
+    while k!=nr
+        sd ebox
+        sd p_ebox^ebox
+        if k=0
+            call stage_get_sel_parent(p_ebox)
+        else
+            setcall ebox stage_new_click_area()
+            if pos!=total_pos
+                #insert the frame
+                importx "_gtk_box_reorder_child" gtk_box_reorder_child
+                call gtk_box_reorder_child(box,ebox,newframepos)
+            endif
+        endelse
+
+        if filename=0
+            #background is color
+            setcall effectpixbuf new_pixbuf_color(w,h,uint_color)
+        else
+            #background is selected frame
+            import "pixbuf_copy" pixbuf_copy
+            setcall effectpixbuf pixbuf_copy(pixbuf)
+        endelse
+        if effectpixbuf=0
+            return 0
+        endif
+
+        #transform
+        sd pixels
+        setcall pixels gdk_pixbuf_get_pixels(effectpixbuf)
+        sd animpix
+        setcall animpix gdk_pixbuf_get_pixels(animpixbuf)
+
+        #function stage_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd animpixbuf,sd in_out)
+        call forward(data,k,nr,pixels,w,h,rowstride,animpix,animpixbuf,in_out)
+
+        if k=0
+            #set the transformed pixbuf and display it
+            import "object_set_dword_name" object_set_dword_name
+            call object_set_dword_name(ebox,effectpixbuf)
+            import "stage_redraw" stage_redraw
+            call stage_redraw()
+        else
+            #add pixbuf to frame
+            import "stage_pixbuf_to_container" stage_pixbuf_to_container
+            call stage_pixbuf_to_container(effectpixbuf,ebox)
+            inc newframepos
+        endelse
+        inc k
+    endwhile
+
+    call g_object_unref(pixbuf)
+
+    if filename!=0
+        call g_object_unref(animpixbuf)
+    endif
+endfunction
+
+##entry,inout and background
+
+function stage_effect_common_fields(sd vbox,ss in_text,ss out_text)
+    call stage_effect_nr_frames(vbox)
+    sd in_out
+    setcall in_out stage_effect_in_out(vbox,in_text,out_text)
+    call stage_effect_inout(0,in_out)
+    call stage_effect_background(vbox)
+endfunction
+
+function stage_effect_inout(sd part,sd value)
+    data in_out#1
+    if part=0
+        set in_out value
+    else
+        return in_out
+    endelse
+endfunction
+
+
+
+function stage_effect_orientation(sd part,sd argument,sd use_center_bool,sd text)
+	if part=0
+    #returns the frame
+        data use_center#1
+        set use_center use_center_bool
+
+        sd vbox
+        set vbox argument
+        #frame
+        import "framefield" framefield
+        sd frame
+        setcall frame framefield(vbox,text)
+
+        sd framechild
+        import "tablefield" tablefield
+        setcall framechild tablefield(frame,3,3)
+
+        data o_top_left#1
+        data o_top#1
+        data o_top_right#1
+        data o_left#1
+        data o_center#1
+        data o_right#1
+        data o_bottom_left#1
+        data o_bottom#1
+        data *o_bottom_right#1
+        ss o_top_left_text="Top-Left"
+        ss *o_top_text="Top"
+        ss *o_top_right_text="Top-Right"
+        ss *o_left_text="Left"
+        ss *o_center_text="Center"
+        ss *o_right_text="Right"
+        ss *o_bottom_left_text="Bottom-Left"
+        ss *o_bottom_text="Bottom"
+        ss *o_bottom_right_text="Bottom-Right"
+
+        import "table_attach" table_attach
+        sd p_orientation^o_top_left
+        sd p_text_orientation^o_top_left_text
+        sd o_y=0
+        sd radio=0
+        while o_y!=3
+            sd o_x
+            set o_x 0
+            while o_x!=3
+                sd skip
+                set skip (FALSE)
+                if use_center=(FALSE)
+                    if o_y=1
+                        if o_x=1
+                            set skip (TRUE)
+                        endif
+                    endif
+                endif
+                if skip=(FALSE)
+                    if radio!=0
+                        setcall radio gtk_radio_button_get_group(radio)
+                    endif
+                    setcall radio gtk_radio_button_new_with_label(radio,p_text_orientation#)
+
+                    call table_attach(framechild,radio,o_x,o_y)
+                endif
+
+                set p_orientation# radio
+                add p_orientation 4
+                add p_text_orientation 4
+                inc o_x
+            endwhile
+            inc o_y
+        endwhile
+        importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
+        call gtk_toggle_button_set_active(o_center,1)
+        return frame
+	endif
+        sd p_top
+        set p_top argument
+
+        sd bool
+
+        #top-left
+        setcall bool gtk_toggle_button_get_active(o_top_left)
+        if bool=1
+            set p_top# -1
+            return -1
+        endif
+        #top
+        setcall bool gtk_toggle_button_get_active(o_top)
+        if bool=1
+            set p_top# -1
+            return 0
+        endif
+        #top-right
+        setcall bool gtk_toggle_button_get_active(o_top_right)
+        if bool=1
+            set p_top# -1
+            return 1
+        endif
+        #left
+        setcall bool gtk_toggle_button_get_active(o_left)
+        if bool=1
+            set p_top# 0
+            return -1
+        endif
+        #center
+        if use_center=(TRUE)
+            setcall bool gtk_toggle_button_get_active(o_center)
+            if bool=1
+                set p_top# 0
+                return 0
+            endif
+        endif
+        #right
+        setcall bool gtk_toggle_button_get_active(o_right)
+        if bool=1
+            set p_top# 0
+            return 1
+        endif
+        #bottom-left
+        setcall bool gtk_toggle_button_get_active(o_bottom_left)
+        if bool=1
+            set p_top# 1
+            return -1
+        endif
+        #bottom
+        setcall bool gtk_toggle_button_get_active(o_bottom)
+        if bool=1
+            set p_top# 1
+            return 0
+        endif
+        #bottom-right
+        set p_top# 1
+        return 1
+endfunction
--- ovideo-1.orig/src/_prepare/effect/base.s
+++ /dev/null
@@ -1,434 +0,0 @@
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-import "hboxfield_cnt" hboxfield_cnt
-
-##the number of frames
-
-data nr_frames_entry#1
-const p_nr_frames_entry^nr_frames_entry
-
-function stage_effect_get_nr_frames_entry()
-    sd p%p_nr_frames_entry
-    return p#
-endfunction
-
-function stage_effect_nr_frames(sd vbox)
-    sd hbox
-    import "labelfield_l" labelfield_l
-    #the effect frames
-    setcall hbox hboxfield_cnt(vbox)
-    ss text="Effect number of frames: "
-    call labelfield_l(text,hbox)
-    import "editfield_pack" editfield_pack
-    sd p_edit%p_nr_frames_entry
-    setcall p_edit# editfield_pack(hbox)
-endfunction
-
-importx "_gtk_entry_get_text" gtk_entry_get_text
-importx "_gtk_radio_button_new_with_label" gtk_radio_button_new_with_label
-importx "_gtk_radio_button_get_group" gtk_radio_button_get_group
-
-##in or out
-
-#out return
-function stage_effect_in_out(sd vbox,ss t_in,ss t_out)
-    sd hbox
-    setcall hbox hboxfield_cnt(vbox)
-
-    sd in
-    setcall in gtk_radio_button_new_with_label(0,t_in)
-
-    sd radiogroup
-    setcall radiogroup gtk_radio_button_get_group(in)
-
-    sd out
-    setcall out gtk_radio_button_new_with_label(radiogroup,t_out)
-
-    import "packstart_default" packstart_default
-    call packstart_default(hbox,in)
-    call packstart_default(hbox,out)
-
-    return out
-endfunction
-
-##background
-
-data color_button#1
-const p_color_button^color_button
-data image_button#1
-const p_image_button^image_button
-
-function stage_effect_get_image_button()
-    sd p_image_button%p_image_button
-    return p_image_button#
-endfunction
-function stage_effect_get_color_button()
-    sd p_color_button%p_color_button
-    return p_color_button#
-endfunction
-
-import "labelfield_left_default" labelfield_left_default
-
-function stage_effect_background(sd vbox)
-    import "hseparatorfield" hseparatorfield
-
-    call hseparatorfield(vbox)
-
-    #color
-    sd p_color%p_color_button
-    ss color_text="Color: "
-    import "colorbuttonfield_leftlabel" colorbuttonfield_leftlabel
-    setcall p_color# colorbuttonfield_leftlabel(color_text,vbox)
-
-    ss text1="Selected frame OVER Color."
-    call labelfield_left_default(text1,vbox)
-
-    ss text_or="OR"
-    call labelfield_left_default(text_or,vbox)
-
-    import "fchooserbuttonfield_open" fchooserbuttonfield_open
-    ss text2="Image from file fit (color at free space) OVER Selected frame:"
-    call labelfield_left_default(text2,vbox)
-    sd p_image_button%p_image_button
-    ss ib_text="Image"
-    setcall p_image_button# fchooserbuttonfield_open(vbox,ib_text)
-
-    call hseparatorfield(vbox)
-endfunction
-
-##effect loop function
-
-function stage_effect_new(sd forward,sd data)
-    sd bool
-    data nr#1
-    #the effect frames
-    sd nr_edit
-    setcall nr_edit stage_effect_get_nr_frames_entry()
-    sd nr_text
-    setcall nr_text gtk_entry_get_text(nr_edit)
-    sd p_nr^nr
-    import "strtoint_positive_twoorgreater" strtoint_positive_twoorgreater
-    setcall bool strtoint_positive_twoorgreater(nr_text,p_nr)
-    if bool==0
-        set nr 2
-    endif
-
-    #get sel position
-    import "stage_get_sel_pos" stage_get_sel_pos
-    sd pos
-    setcall pos stage_get_sel_pos()
-    #total positions for reorder compare
-    import "stage_get_frames" stage_get_frames
-    sd total_pos
-    setcall total_pos stage_get_frames()
-    #new frames pos(without sel,that is also a new frame)
-    inc pos
-    #frames container for reorder
-    import "stage_get_frames_container" stage_get_frames_container
-    sd box
-    setcall box stage_get_frames_container()
-    #newframepos
-    sd newframepos
-    set newframepos pos
-    #nr-1
-    sd last_index
-    set last_index nr
-    dec last_index
-
-    #new frames with length like sel
-    import "stage_get_sel_fr_length" stage_get_sel_fr_length
-    sd length
-    setcall length stage_get_sel_fr_length()
-    import "stage_frame_time_numbers" stage_frame_time_numbers
-    call stage_frame_time_numbers((stage_frame_time_insert),pos,length,last_index)
-
-    #pixbuf for the effect
-    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
-    sd pixbuf
-    sd p_pixbuf^pixbuf
-    call stage_get_sel_pixbuf(p_pixbuf)
-
-    #test for not accessing invalid memory
-    #import "rgb_test" rgb_test
-    #setcall bool rgb_test(pixbuf)
-    #if bool==0
-    #    return 0
-    #endif
-
-    #get dimensions
-    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-    importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-    sd w
-    setcall w gdk_pixbuf_get_width(pixbuf)
-    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-    sd h
-    setcall h gdk_pixbuf_get_height(pixbuf)
-    importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
-    sd rowstride
-    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
-
-    #color and new image
-    #color from bytes to dword
-    import "color_widget_get_color_to_rgb" color_widget_get_color_to_rgb
-    sd colors_entry
-    setcall colors_entry stage_effect_get_color_button()
-    sd uint_color
-    setcall uint_color color_widget_get_color_to_rgb(colors_entry)
-    #animation pixbuf from new image or the selected frame
-    sd animpixbuf
-    importx "_g_object_unref" g_object_unref
-
-    sd newimage_entry
-    setcall newimage_entry stage_effect_get_image_button()
-    import "file_chooser_get_fname" file_chooser_get_fname
-    import "new_pixbuf_color" new_pixbuf_color
-    sd filename
-    setcall filename file_chooser_get_fname(newimage_entry)
-    if filename==0
-        set animpixbuf pixbuf
-    else
-        setcall animpixbuf new_pixbuf_color(w,h,uint_color)
-        if animpixbuf==0
-            return 0
-        endif
-        import "pixbuf_from_file" pixbuf_from_file
-        sd filepixbuf
-        setcall filepixbuf pixbuf_from_file(filename)
-        if filepixbuf==0
-            return 0
-        endif
-        import "stage_pixbuf_in_container_pixbuf" stage_pixbuf_in_container_pixbuf
-        call stage_pixbuf_in_container_pixbuf(filepixbuf,animpixbuf)
-        call g_object_unref(filepixbuf)
-        importx "_g_free" g_free
-        call g_free(filename)
-    endelse
-
-    #get the in/out value
-    sd in_out_entry
-    setcall in_out_entry stage_effect_inout(1)
-    importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
-    sd in_out
-    setcall in_out gtk_toggle_button_get_active(in_out_entry)
-
-    import "stage_get_sel_parent" stage_get_sel_parent
-    import "stage_new_click_area" stage_new_click_area
-    sd effectpixbuf
-    sd k=0
-    while k!=nr
-        sd ebox
-        sd p_ebox^ebox
-        if k==0
-            call stage_get_sel_parent(p_ebox)
-        else
-            setcall ebox stage_new_click_area()
-            if pos!=total_pos
-                #insert the frame
-                importx "_gtk_box_reorder_child" gtk_box_reorder_child
-                call gtk_box_reorder_child(box,ebox,newframepos)
-            endif
-        endelse
-
-        if filename==0
-            #background is color
-            setcall effectpixbuf new_pixbuf_color(w,h,uint_color)
-        else
-            #background is selected frame
-            import "pixbuf_copy" pixbuf_copy
-            setcall effectpixbuf pixbuf_copy(pixbuf)
-        endelse
-        if effectpixbuf==0
-            return 0
-        endif
-
-        #transform
-        sd pixels
-        setcall pixels gdk_pixbuf_get_pixels(effectpixbuf)
-        sd animpix
-        setcall animpix gdk_pixbuf_get_pixels(animpixbuf)
-
-        #function stage_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd animpixbuf,sd in_out)
-        call forward(data,k,nr,pixels,w,h,rowstride,animpix,animpixbuf,in_out)
-
-        if k==0
-            #set the transformed pixbuf and display it
-            import "object_set_dword_name" object_set_dword_name
-            call object_set_dword_name(ebox,effectpixbuf)
-            import "stage_redraw" stage_redraw
-            call stage_redraw()
-        else
-            #add pixbuf to frame
-            import "stage_pixbuf_to_container" stage_pixbuf_to_container
-            call stage_pixbuf_to_container(effectpixbuf,ebox)
-            inc newframepos
-        endelse
-        inc k
-    endwhile
-
-    call g_object_unref(pixbuf)
-
-    if filename!=0
-        call g_object_unref(animpixbuf)
-    endif
-endfunction
-
-##entry,inout and background
-
-function stage_effect_common_fields(sd vbox,ss in_text,ss out_text)
-    call stage_effect_nr_frames(vbox)
-    sd in_out
-    setcall in_out stage_effect_in_out(vbox,in_text,out_text)
-    call stage_effect_inout(0,in_out)
-    call stage_effect_background(vbox)
-endfunction
-
-function stage_effect_inout(sd part,sd value)
-    data in_out#1
-    if part==0
-        set in_out value
-    else
-        return in_out
-    endelse
-endfunction
-
-
-
-function stage_effect_orientation(sd part,sd argument,sd use_center_bool,sd text)
-    if part==0
-    #returns the frame
-        data use_center#1
-        set use_center use_center_bool
-
-        sd vbox
-        set vbox argument
-        #frame
-        import "framefield" framefield
-        sd frame
-        setcall frame framefield(vbox,text)
-
-        sd framechild
-        import "tablefield" tablefield
-        setcall framechild tablefield(frame,3,3)
-
-        data o_top_left#1
-        data o_top#1
-        data o_top_right#1
-        data o_left#1
-        data o_center#1
-        data o_right#1
-        data o_bottom_left#1
-        data o_bottom#1
-        data *o_bottom_right#1
-        ss o_top_left_text="Top-Left"
-        ss *o_top_text="Top"
-        ss *o_top_right_text="Top-Right"
-        ss *o_left_text="Left"
-        ss *o_center_text="Center"
-        ss *o_right_text="Right"
-        ss *o_bottom_left_text="Bottom-Left"
-        ss *o_bottom_text="Bottom"
-        ss *o_bottom_right_text="Bottom-Right"
-
-        import "table_attach" table_attach
-        sd p_orientation^o_top_left
-        sd p_text_orientation^o_top_left_text
-        sd o_y=0
-        sd radio=0
-        while o_y!=3
-            sd o_x
-            set o_x 0
-            while o_x!=3
-                sd skip
-                set skip (FALSE)
-                if use_center==(FALSE)
-                    if o_y==1
-                        if o_x==1
-                            set skip (TRUE)
-                        endif
-                    endif
-                endif
-                if skip==(FALSE)
-                    if radio!=0
-                        setcall radio gtk_radio_button_get_group(radio)
-                    endif
-                    setcall radio gtk_radio_button_new_with_label(radio,p_text_orientation#)
-
-                    call table_attach(framechild,radio,o_x,o_y)
-                endif
-
-                set p_orientation# radio
-                add p_orientation 4
-                add p_text_orientation 4
-                inc o_x
-            endwhile
-            inc o_y
-        endwhile
-        importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
-        call gtk_toggle_button_set_active(o_center,1)
-        return frame
-    else
-        sd p_top
-        set p_top argument
-
-        sd bool
-
-        #top-left
-        setcall bool gtk_toggle_button_get_active(o_top_left)
-        if bool==1
-            set p_top# -1
-            return -1
-        endif
-        #top
-        setcall bool gtk_toggle_button_get_active(o_top)
-        if bool==1
-            set p_top# -1
-            return 0
-        endif
-        #top-right
-        setcall bool gtk_toggle_button_get_active(o_top_right)
-        if bool==1
-            set p_top# -1
-            return 1
-        endif
-        #left
-        setcall bool gtk_toggle_button_get_active(o_left)
-        if bool==1
-            set p_top# 0
-            return -1
-        endif
-        #center
-        if use_center==(TRUE)
-            setcall bool gtk_toggle_button_get_active(o_center)
-            if bool==1
-                set p_top# 0
-                return 0
-            endif
-        endif
-        #right
-        setcall bool gtk_toggle_button_get_active(o_right)
-        if bool==1
-            set p_top# 0
-            return 1
-        endif
-        #bottom-left
-        setcall bool gtk_toggle_button_get_active(o_bottom_left)
-        if bool==1
-            set p_top# 1
-            return -1
-        endif
-        #bottom
-        setcall bool gtk_toggle_button_get_active(o_bottom)
-        if bool==1
-            set p_top# 1
-            return 0
-        endif
-        #bottom-right
-        set p_top# 1
-        return 1
-    endelse
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/effect/fade.oc
@@ -0,0 +1,78 @@
+
+
+format elfobj
+
+function stage_fade()
+    ss title="Fade In/Fade Out effect"
+    data init^stage_fade_init
+    data do^stage_fade_set
+    import "stage_frame_dialog" stage_frame_dialog
+    call stage_frame_dialog(init,do,title)
+endfunction
+
+function stage_fade_init(sd vbox,sd *dialog)
+    import "stage_effect_common_fields" stage_effect_common_fields
+    #the in or out
+    ss fadeintext="Fade In"
+    ss fadeouttext="Fade Out"
+    call stage_effect_common_fields(vbox,fadeintext,fadeouttext)
+endfunction
+
+function stage_fade_set()
+    data f^stage_fade_tool
+    import "stage_effect_new" stage_effect_new
+    call stage_effect_new(f,1)
+endfunction
+
+function stage_fade_tool(sd *part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd *animpixbuf,sd in_out)
+    #nr-1
+    sd last_index
+    set last_index nr
+    dec last_index
+
+    sd j=0
+    while j!=h
+        sd i=0
+        while i!=w
+            import "rgb_px_get" rgb_px_get
+            import "rgb_uint_to_colors" rgb_uint_to_colors
+
+            sd valuepixel
+            setcall valuepixel rgb_px_get(pixels,i,j,8,3,rowstride)
+            sd red_bg
+            sd green_bg
+            sd blue_bg
+            sd colors_bg^red_bg
+            call rgb_uint_to_colors(valuepixel,colors_bg)
+
+            setcall valuepixel rgb_px_get(animpixels,i,j,8,3,rowstride)
+            sd red
+            sd green
+            sd blue
+            sd colors^red
+            call rgb_uint_to_colors(valuepixel,colors)
+
+            const fadein=0
+            #const fadeout=1
+            import "rule3_offset" rule3_offset
+            if in_out=(fadein)
+                setcall red rule3_offset(k,last_index,red_bg,red)
+                setcall green rule3_offset(k,last_index,green_bg,green)
+                setcall blue rule3_offset(k,last_index,blue_bg,blue)
+            else
+                setcall red rule3_offset(k,last_index,red,red_bg)
+                setcall green rule3_offset(k,last_index,green,green_bg)
+                setcall blue rule3_offset(k,last_index,blue,blue_bg)
+            endelse
+
+            import "rgb_colors_to_uint" rgb_colors_to_uint
+            setcall valuepixel rgb_colors_to_uint(colors)
+
+            import "rgb_px_set" rgb_px_set
+            call rgb_px_set(valuepixel,pixels,i,j,8,3,rowstride)
+
+            inc i
+        endwhile
+        inc j
+    endwhile
+endfunction
--- ovideo-1.orig/src/_prepare/effect/fade.s
+++ /dev/null
@@ -1,78 +0,0 @@
-
-
-format elfobj
-
-function stage_fade()
-    ss title="Fade In/Fade Out effect"
-    data init^stage_fade_init
-    data do^stage_fade_set
-    import "stage_frame_dialog" stage_frame_dialog
-    call stage_frame_dialog(init,do,title)
-endfunction
-
-function stage_fade_init(sd vbox,sd *dialog)
-    import "stage_effect_common_fields" stage_effect_common_fields
-    #the in or out
-    ss fadeintext="Fade In"
-    ss fadeouttext="Fade Out"
-    call stage_effect_common_fields(vbox,fadeintext,fadeouttext)
-endfunction
-
-function stage_fade_set()
-    data f^stage_fade_tool
-    import "stage_effect_new" stage_effect_new
-    call stage_effect_new(f,1)
-endfunction
-
-function stage_fade_tool(sd *part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd *animpixbuf,sd in_out)
-    #nr-1
-    sd last_index
-    set last_index nr
-    dec last_index
-
-    sd j=0
-    while j!=h
-        sd i=0
-        while i!=w
-            import "rgb_px_get" rgb_px_get
-            import "rgb_uint_to_colors" rgb_uint_to_colors
-
-            sd valuepixel
-            setcall valuepixel rgb_px_get(pixels,i,j,8,3,rowstride)
-            sd red_bg
-            sd green_bg
-            sd blue_bg
-            sd colors_bg^red_bg
-            call rgb_uint_to_colors(valuepixel,colors_bg)
-
-            setcall valuepixel rgb_px_get(animpixels,i,j,8,3,rowstride)
-            sd red
-            sd green
-            sd blue
-            sd colors^red
-            call rgb_uint_to_colors(valuepixel,colors)
-
-            const fadein=0
-            #const fadeout=1
-            import "rule3_offset" rule3_offset
-            if in_out==(fadein)
-                setcall red rule3_offset(k,last_index,red_bg,red)
-                setcall green rule3_offset(k,last_index,green_bg,green)
-                setcall blue rule3_offset(k,last_index,blue_bg,blue)
-            else
-                setcall red rule3_offset(k,last_index,red,red_bg)
-                setcall green rule3_offset(k,last_index,green,green_bg)
-                setcall blue rule3_offset(k,last_index,blue,blue_bg)
-            endelse
-
-            import "rgb_colors_to_uint" rgb_colors_to_uint
-            setcall valuepixel rgb_colors_to_uint(colors)
-
-            import "rgb_px_set" rgb_px_set
-            call rgb_px_set(valuepixel,pixels,i,j,8,3,rowstride)
-
-            inc i
-        endwhile
-        inc j
-    endwhile
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/effect/move.oc
@@ -0,0 +1,205 @@
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+const stage_move_cover_set=0
+const stage_move_cover_get=1
+
+const stage_move_select=0
+const stage_cover_select=1
+
+const stage_move_cover_move_or_cover=0
+const stage_move_cover_in_text=1
+const stage_move_cover_out_text=2
+const stage_move_cover_direction_text=3
+
+import "stage_frame_dialog" stage_frame_dialog
+function stage_move()
+    call stage_move_cover_effect((stage_move_cover_set),(stage_move_select))
+    ss title="Move In/Move Out effect"
+    call stage_move_cover_start(title)
+endfunction
+function stage_cover()
+    call stage_move_cover_effect((stage_move_cover_set),(stage_cover_select))
+    ss title="Uncover/Cover effect"
+    call stage_move_cover_start(title)
+endfunction
+
+function stage_move_cover_start(ss title)
+    data init^stage_move_init
+    data do^stage_move_set
+    call stage_frame_dialog(init,do,title)
+endfunction
+
+function stage_move_cover_effect(sd action,sd value)
+
+    data effect#1
+    str in_text#1
+    str out_text#1
+    str direction_text#1
+
+    data p_values^effect
+
+    if action=(stage_move_cover_set)
+        set effect value
+        if effect=(stage_move_select)
+            ss move_in_text="Move In"
+            ss move_out_text="Move Out"
+            ss move_direction_text="Move in From/Move out To:"
+
+            set in_text move_in_text
+            set out_text move_out_text
+            set direction_text move_direction_text
+        else
+            ss cover_in_text="Uncover"
+            ss cover_out_text="Cover"
+            ss cover_direction_text="Uncover From/Cover To:"
+
+            set in_text cover_in_text
+            set out_text cover_out_text
+            set direction_text cover_direction_text
+        endelse
+    else
+    #value
+        mult value 4
+        add value p_values
+        return value#
+    endelse
+endfunction
+
+function stage_move_init(sd vbox,sd *dialog)
+    #common fields
+    #the in or out
+    import "stage_effect_common_fields" stage_effect_common_fields
+
+    ss in_text
+    ss out_text
+    setcall in_text stage_move_cover_effect((stage_move_cover_get),(stage_move_cover_in_text))
+    setcall out_text stage_move_cover_effect((stage_move_cover_get),(stage_move_cover_out_text))
+
+    call stage_effect_common_fields(vbox,in_text,out_text)
+
+    #the direction
+    ss text
+    setcall text stage_move_cover_effect((stage_move_cover_get),(stage_move_cover_direction_text))
+
+    import "stage_effect_orientation" stage_effect_orientation
+    call stage_effect_orientation(0,vbox,(FALSE),text)
+endfunction
+
+function stage_move_set()
+    call stage_move_tool(0)
+    data f^stage_move_tool
+    import "stage_effect_new" stage_effect_new
+    call stage_effect_new(f,1)
+endfunction
+
+function stage_move_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd *animpixbuf,sd in_out)
+    data inits#1
+    if part=0
+        set inits 1
+        return 1
+    endif
+    if inits=1
+        set inits 0
+
+        data start_x#1
+        data start_y#1
+
+        data end_x#1
+        data end_y#1
+
+        sd x_coef
+        sd y_coef
+        sd p_y_coef^y_coef
+        setcall x_coef stage_effect_orientation(1,p_y_coef,(FALSE))
+
+        set start_x w
+        set start_y h
+        set end_x 0
+        set end_y 0
+
+        mult start_x x_coef
+        mult start_y y_coef
+
+        if in_out=(out_effect)
+            sd aux
+            set aux start_x
+            set start_x end_x
+            set end_x aux
+            set aux start_y
+            set start_y end_y
+            set end_y aux
+        endif
+
+        data last_index#1
+        set last_index nr
+        dec last_index
+    endif
+
+    sd frame_left
+    sd frame_top
+
+    import "rule3_offset" rule3_offset
+    #image coordinates at current frame
+    setcall frame_left rule3_offset(k,last_index,start_x,end_x)
+    setcall frame_top rule3_offset(k,last_index,start_y,end_y)
+
+    sd frame_right
+    sd frame_bottom
+    set frame_right frame_left
+    add frame_right w
+    set frame_bottom frame_top
+    add frame_bottom h
+
+    sd j=0
+    if frame_top>j
+        set j frame_top
+    endif
+    sd max_j
+    set max_j h
+    if frame_bottom<max_j
+        set max_j frame_bottom
+    endif
+    sd min_i=0
+    if frame_left>min_i
+        set min_i frame_left
+    endif
+    sd max_i
+    set max_i w
+    if frame_right<max_i
+        set max_i frame_right
+    endif
+
+    while j!=max_j
+        sd i
+        set i min_i
+        while i!=max_i
+            sd x
+            sd y
+            set x i
+            set y j
+            sd move_or_cover
+            setcall move_or_cover stage_move_cover_effect((stage_move_cover_get),(stage_move_cover_move_or_cover))
+            if move_or_cover=(stage_move_select)
+                sub x frame_left
+                sub y frame_top
+            endif
+
+            import "rgb_px_get" rgb_px_get
+            import "rgb_get_set" rgb_get_set
+            sd value
+            sd p_value^value
+            setcall value rgb_px_get(animpixels,x,y,8,3,rowstride)
+            call rgb_get_set(p_value,pixels,i,j,8,3,rowstride,(set_rgb))
+
+            inc i
+        endwhile
+        inc j
+    endwhile
+endfunction
+
+
--- ovideo-1.orig/src/_prepare/effect/move.s
+++ /dev/null
@@ -1,205 +0,0 @@
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-const stage_move_cover_set=0
-const stage_move_cover_get=1
-
-const stage_move_select=0
-const stage_cover_select=1
-
-const stage_move_cover_move_or_cover=0
-const stage_move_cover_in_text=1
-const stage_move_cover_out_text=2
-const stage_move_cover_direction_text=3
-
-import "stage_frame_dialog" stage_frame_dialog
-function stage_move()
-    call stage_move_cover_effect((stage_move_cover_set),(stage_move_select))
-    ss title="Move In/Move Out effect"
-    call stage_move_cover_start(title)
-endfunction
-function stage_cover()
-    call stage_move_cover_effect((stage_move_cover_set),(stage_cover_select))
-    ss title="Uncover/Cover effect"
-    call stage_move_cover_start(title)
-endfunction
-
-function stage_move_cover_start(ss title)
-    data init^stage_move_init
-    data do^stage_move_set
-    call stage_frame_dialog(init,do,title)
-endfunction
-
-function stage_move_cover_effect(sd action,sd value)
-
-    data effect#1
-    str in_text#1
-    str out_text#1
-    str direction_text#1
-
-    data p_values^effect
-
-    if action==(stage_move_cover_set)
-        set effect value
-        if effect==(stage_move_select)
-            ss move_in_text="Move In"
-            ss move_out_text="Move Out"
-            ss move_direction_text="Move in From/Move out To:"
-
-            set in_text move_in_text
-            set out_text move_out_text
-            set direction_text move_direction_text
-        else
-            ss cover_in_text="Uncover"
-            ss cover_out_text="Cover"
-            ss cover_direction_text="Uncover From/Cover To:"
-
-            set in_text cover_in_text
-            set out_text cover_out_text
-            set direction_text cover_direction_text
-        endelse
-    else
-    #value
-        mult value 4
-        add value p_values
-        return value#
-    endelse
-endfunction
-
-function stage_move_init(sd vbox,sd *dialog)
-    #common fields
-    #the in or out
-    import "stage_effect_common_fields" stage_effect_common_fields
-
-    ss in_text
-    ss out_text
-    setcall in_text stage_move_cover_effect((stage_move_cover_get),(stage_move_cover_in_text))
-    setcall out_text stage_move_cover_effect((stage_move_cover_get),(stage_move_cover_out_text))
-
-    call stage_effect_common_fields(vbox,in_text,out_text)
-
-    #the direction
-    ss text
-    setcall text stage_move_cover_effect((stage_move_cover_get),(stage_move_cover_direction_text))
-
-    import "stage_effect_orientation" stage_effect_orientation
-    call stage_effect_orientation(0,vbox,(FALSE),text)
-endfunction
-
-function stage_move_set()
-    call stage_move_tool(0)
-    data f^stage_move_tool
-    import "stage_effect_new" stage_effect_new
-    call stage_effect_new(f,1)
-endfunction
-
-function stage_move_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd *animpixbuf,sd in_out)
-    data inits#1
-    if part==0
-        set inits 1
-        return 1
-    endif
-    if inits==1
-        set inits 0
-
-        data start_x#1
-        data start_y#1
-
-        data end_x#1
-        data end_y#1
-
-        sd x_coef
-        sd y_coef
-        sd p_y_coef^y_coef
-        setcall x_coef stage_effect_orientation(1,p_y_coef,(FALSE))
-
-        set start_x w
-        set start_y h
-        set end_x 0
-        set end_y 0
-
-        mult start_x x_coef
-        mult start_y y_coef
-
-        if in_out==(out_effect)
-            sd aux
-            set aux start_x
-            set start_x end_x
-            set end_x aux
-            set aux start_y
-            set start_y end_y
-            set end_y aux
-        endif
-
-        data last_index#1
-        set last_index nr
-        dec last_index
-    endif
-
-    sd frame_left
-    sd frame_top
-
-    import "rule3_offset" rule3_offset
-    #image coordinates at current frame
-    setcall frame_left rule3_offset(k,last_index,start_x,end_x)
-    setcall frame_top rule3_offset(k,last_index,start_y,end_y)
-
-    sd frame_right
-    sd frame_bottom
-    set frame_right frame_left
-    add frame_right w
-    set frame_bottom frame_top
-    add frame_bottom h
-
-    sd j=0
-    if frame_top>j
-        set j frame_top
-    endif
-    sd max_j
-    set max_j h
-    if frame_bottom<max_j
-        set max_j frame_bottom
-    endif
-    sd min_i=0
-    if frame_left>min_i
-        set min_i frame_left
-    endif
-    sd max_i
-    set max_i w
-    if frame_right<max_i
-        set max_i frame_right
-    endif
-
-    while j!=max_j
-        sd i
-        set i min_i
-        while i!=max_i
-            sd x
-            sd y
-            set x i
-            set y j
-            sd move_or_cover
-            setcall move_or_cover stage_move_cover_effect((stage_move_cover_get),(stage_move_cover_move_or_cover))
-            if move_or_cover==(stage_move_select)
-                sub x frame_left
-                sub y frame_top
-            endif
-
-            import "rgb_px_get" rgb_px_get
-            import "rgb_get_set" rgb_get_set
-            sd value
-            sd p_value^value
-            setcall value rgb_px_get(animpixels,x,y,8,3,rowstride)
-            call rgb_get_set(p_value,pixels,i,j,8,3,rowstride,(set_rgb))
-
-            inc i
-        endwhile
-        inc j
-    endwhile
-endfunction
-
-
--- /dev/null
+++ ovideo-1/src/_prepare/effect/reveal.oc
@@ -0,0 +1,217 @@
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+function stage_cover_panel(sd action,sd button,sd backfn,sd panel)
+    data openbutton#1
+    data backfunction#1
+
+    data panelwidget#1
+
+    if action=(buttons_panel_open)
+        set openbutton button
+        set panelwidget panel
+        set backfunction backfn
+    else
+    #if action==(buttons_panel_close)
+        importx "_gtk_widget_destroy" gtk_widget_destroy
+        call gtk_widget_destroy(panelwidget)
+        import "connect_signal" connect_signal
+        str click="clicked"
+        call connect_signal(openbutton,click,backfunction)
+    endelse
+endfunction
+function stage_cover_panel_open(sd button,sd *user_data)
+    import "img_edit_folder_enterleave_data" img_edit_folder_enterleave_data
+    data f^stage_cover_panel_open_fn
+    sd p_data^button
+    call img_edit_folder_enterleave_data(f,p_data)
+endfunction
+function stage_cover_panel_open_fn(sd p_data)
+    sd button
+    sd user_data
+    set button p_data#
+    add p_data 4
+    set user_data p_data#
+
+    import "stage_cover" stage_cover
+    char cover_lot="cover.bmp"
+    char *="Uncover/Cover sides effects"
+    data *^stage_cover
+    #
+    char *="center_cover.bmp"
+    char *="Uncover/Cover center lines effects"
+    data *^stage_reveal_centerline
+    #
+    import "stage_reveal_rectangle" stage_reveal_rectangle
+    char *="rectangle_cover.bmp"
+    char *="Uncover/Cover rectangle effects"
+    data *^stage_reveal_rectangle
+    #
+    import "stage_reveal_diamond" stage_reveal_diamond
+    char *="diamond_cover.bmp"
+    char *="Uncover/Cover diamond effects"
+    data *^stage_reveal_diamond
+    #
+    import "stage_reveal_curve" stage_reveal_curve
+    char *="curve_cover.bmp"
+    char *="Uncover/Cover curve effects"
+    data *^stage_reveal_curve
+    #
+    import "stage_reveal_diagonal" stage_reveal_diagonal
+    char *="diagonal_cover.bmp"
+    char *="Uncover/Cover diagonal effects"
+    data *^stage_reveal_diagonal
+    #
+    data *=0
+    #
+    data *=0
+    #
+    data lots^cover_lot
+
+    import "stage_new_panel" stage_new_panel
+    sd newpanel
+    data f^stage_cover_panel_open
+    data closef^stage_cover_panel_close
+    setcall newpanel stage_new_panel(lots,button,f,user_data,closef)
+
+    call stage_cover_panel((buttons_panel_open),button,f,newpanel)
+endfunction
+function stage_cover_panel_close()
+    call stage_cover_panel((buttons_panel_close))
+endfunction
+
+
+
+
+
+
+
+function stage_reveal_centerline()
+    import "stage_frame_dialog" stage_frame_dialog
+    ss title="Uncover/Cover center lines effect"
+    data init^stage_reveal_centerline_init
+    data do^stage_reveal_centerline_set
+    call stage_frame_dialog(init,do,title)
+endfunction
+
+import "stage_effect_common_fields" stage_effect_common_fields
+
+function stage_reveal_centerline_init(sd vbox,sd *dialog)
+    call stage_effect_common_cover_fields(vbox)
+
+    ss wd="Width Axis"
+    ss hg="Height Axis"
+    data h#1
+    const ptr_h_axis^h
+    import "stage_effect_in_out" stage_effect_in_out
+    setcall h stage_effect_in_out(vbox,wd,hg)
+endfunction
+
+function stage_reveal_centerline_set()
+    call stage_reveal_centerline_tool(0)
+    data f^stage_reveal_centerline_tool
+    import "stage_effect_new" stage_effect_new
+    call stage_effect_new(f,1)
+endfunction
+
+function stage_reveal_centerline_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd *animpixbuf,sd in_out)
+    data init#1
+    if part=0
+        set init 0
+        return 0
+    endif
+    if init=0
+        data last_frame#1
+        set last_frame nr
+        dec last_frame
+
+        const width_axis=0
+        #const height_axis=1
+
+        importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
+
+        data axis#1
+        sd axis_entry%ptr_h_axis
+        setcall axis gtk_toggle_button_get_active(axis_entry#)
+
+        data start_width#1
+        data end_width#1
+        data start_height#1
+        data end_height#1
+
+
+        if in_out=(uncover)
+            set start_width 0
+            set end_width w
+            set start_height 0
+            set end_height h
+        else
+            set start_width w
+            set end_width 0
+            set start_height h
+            set end_height 0
+        endelse
+
+        set init 1
+    endif
+
+    import "rule3_offset" rule3_offset
+    import "centered" centered
+    sd left
+    sd top
+    sd right
+    sd bottom
+    if axis=(width_axis)
+        set left 0
+        set right w
+        setcall bottom rule3_offset(k,last_frame,start_height,end_height)
+        setcall top centered(h,bottom)
+        add bottom top
+    else
+        set top 0
+        set bottom h
+        setcall right rule3_offset(k,last_frame,start_width,end_width)
+        setcall left centered(w,right)
+        add right left
+    endelse
+
+    sd j
+    set j top
+    while j!=bottom
+        sd i
+        set i left
+        while i!=right
+            import "rgb_px_get" rgb_px_get
+            import "rgb_px_set" rgb_px_set
+            sd value
+            setcall value rgb_px_get(animpixels,i,j,8,3,rowstride)
+            call rgb_px_set(value,pixels,i,j,8,3,rowstride)
+            inc i
+        endwhile
+        inc j
+    endwhile
+endfunction
+
+
+
+
+
+
+
+
+
+
+
+
+
+#functions
+
+function stage_effect_common_cover_fields(sd vbox)
+    ss textin="Uncover"
+    ss textout="Cover"
+    call stage_effect_common_fields(vbox,textin,textout)
+endfunction
--- ovideo-1.orig/src/_prepare/effect/reveal.s
+++ /dev/null
@@ -1,217 +0,0 @@
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-function stage_cover_panel(sd action,sd button,sd backfn,sd panel)
-    data openbutton#1
-    data backfunction#1
-
-    data panelwidget#1
-
-    if action==(buttons_panel_open)
-        set openbutton button
-        set panelwidget panel
-        set backfunction backfn
-    else
-    #if action==(buttons_panel_close)
-        importx "_gtk_widget_destroy" gtk_widget_destroy
-        call gtk_widget_destroy(panelwidget)
-        import "connect_signal" connect_signal
-        str click="clicked"
-        call connect_signal(openbutton,click,backfunction)
-    endelse
-endfunction
-function stage_cover_panel_open(sd button,sd *user_data)
-    import "img_edit_folder_enterleave_data" img_edit_folder_enterleave_data
-    data f^stage_cover_panel_open_fn
-    sd p_data^button
-    call img_edit_folder_enterleave_data(f,p_data)
-endfunction
-function stage_cover_panel_open_fn(sd p_data)
-    sd button
-    sd user_data
-    set button p_data#
-    add p_data 4
-    set user_data p_data#
-
-    import "stage_cover" stage_cover
-    char cover_lot="cover.bmp"
-    char *="Uncover/Cover sides effects"
-    data *^stage_cover
-    #
-    char *="center_cover.bmp"
-    char *="Uncover/Cover center lines effects"
-    data *^stage_reveal_centerline
-    #
-    import "stage_reveal_rectangle" stage_reveal_rectangle
-    char *="rectangle_cover.bmp"
-    char *="Uncover/Cover rectangle effects"
-    data *^stage_reveal_rectangle
-    #
-    import "stage_reveal_diamond" stage_reveal_diamond
-    char *="diamond_cover.bmp"
-    char *="Uncover/Cover diamond effects"
-    data *^stage_reveal_diamond
-    #
-    import "stage_reveal_curve" stage_reveal_curve
-    char *="curve_cover.bmp"
-    char *="Uncover/Cover curve effects"
-    data *^stage_reveal_curve
-    #
-    import "stage_reveal_diagonal" stage_reveal_diagonal
-    char *="diagonal_cover.bmp"
-    char *="Uncover/Cover diagonal effects"
-    data *^stage_reveal_diagonal
-    #
-    data *=0
-    #
-    data *=0
-    #
-    data lots^cover_lot
-
-    import "stage_new_panel" stage_new_panel
-    sd newpanel
-    data f^stage_cover_panel_open
-    data closef^stage_cover_panel_close
-    setcall newpanel stage_new_panel(lots,button,f,user_data,closef)
-
-    call stage_cover_panel((buttons_panel_open),button,f,newpanel)
-endfunction
-function stage_cover_panel_close()
-    call stage_cover_panel((buttons_panel_close))
-endfunction
-
-
-
-
-
-
-
-function stage_reveal_centerline()
-    import "stage_frame_dialog" stage_frame_dialog
-    ss title="Uncover/Cover center lines effect"
-    data init^stage_reveal_centerline_init
-    data do^stage_reveal_centerline_set
-    call stage_frame_dialog(init,do,title)
-endfunction
-
-import "stage_effect_common_fields" stage_effect_common_fields
-
-function stage_reveal_centerline_init(sd vbox,sd *dialog)
-    call stage_effect_common_cover_fields(vbox)
-
-    ss wd="Width Axis"
-    ss hg="Height Axis"
-    data h#1
-    const ptr_h_axis^h
-    import "stage_effect_in_out" stage_effect_in_out
-    setcall h stage_effect_in_out(vbox,wd,hg)
-endfunction
-
-function stage_reveal_centerline_set()
-    call stage_reveal_centerline_tool(0)
-    data f^stage_reveal_centerline_tool
-    import "stage_effect_new" stage_effect_new
-    call stage_effect_new(f,1)
-endfunction
-
-function stage_reveal_centerline_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd *animpixbuf,sd in_out)
-    data init#1
-    if part==0
-        set init 0
-        return 0
-    endif
-    if init==0
-        data last_frame#1
-        set last_frame nr
-        dec last_frame
-
-        const width_axis=0
-        #const height_axis=1
-
-        importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
-
-        data axis#1
-        sd axis_entry%ptr_h_axis
-        setcall axis gtk_toggle_button_get_active(axis_entry#)
-
-        data start_width#1
-        data end_width#1
-        data start_height#1
-        data end_height#1
-
-
-        if in_out==(uncover)
-            set start_width 0
-            set end_width w
-            set start_height 0
-            set end_height h
-        else
-            set start_width w
-            set end_width 0
-            set start_height h
-            set end_height 0
-        endelse
-
-        set init 1
-    endif
-
-    import "rule3_offset" rule3_offset
-    import "centered" centered
-    sd left
-    sd top
-    sd right
-    sd bottom
-    if axis==(width_axis)
-        set left 0
-        set right w
-        setcall bottom rule3_offset(k,last_frame,start_height,end_height)
-        setcall top centered(h,bottom)
-        add bottom top
-    else
-        set top 0
-        set bottom h
-        setcall right rule3_offset(k,last_frame,start_width,end_width)
-        setcall left centered(w,right)
-        add right left
-    endelse
-
-    sd j
-    set j top
-    while j!=bottom
-        sd i
-        set i left
-        while i!=right
-            import "rgb_px_get" rgb_px_get
-            import "rgb_px_set" rgb_px_set
-            sd value
-            setcall value rgb_px_get(animpixels,i,j,8,3,rowstride)
-            call rgb_px_set(value,pixels,i,j,8,3,rowstride)
-            inc i
-        endwhile
-        inc j
-    endwhile
-endfunction
-
-
-
-
-
-
-
-
-
-
-
-
-
-#functions
-
-function stage_effect_common_cover_fields(sd vbox)
-    ss textin="Uncover"
-    ss textout="Cover"
-    call stage_effect_common_fields(vbox,textin,textout)
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/effect/reveal_diagonal.oc
@@ -0,0 +1,276 @@
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+const top_left=0
+const top_right=1
+const bottom_left=2
+const bottom_right=3
+
+function stage_reveal_diagonal()
+    import "stage_frame_dialog" stage_frame_dialog
+
+    ss title="Uncover/Cover diagonal effect"
+    data init^stage_reveal_diagonal_init
+    data do^stage_reveal_diagonal_set
+    call stage_frame_dialog(init,do,title)
+endfunction
+
+function stage_reveal_diagonal_init(sd vbox,sd *dialog)
+    import "stage_effect_common_cover_fields" stage_effect_common_cover_fields
+    call stage_effect_common_cover_fields(vbox)
+
+    call stage_effect_corner(0,vbox)
+endfunction
+
+function stage_reveal_diagonal_set()
+    call stage_reveal_diagonal_tool(0)
+    data f^stage_reveal_diagonal_tool
+    import "stage_effect_new" stage_effect_new
+    call stage_effect_new(f,1)
+endfunction
+
+function stage_reveal_diagonal_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd *animpixbuf,sd in_out)
+    data init#1
+    if part=0
+        set init 0
+        return 1
+    endif
+
+    data start_x#1
+    data end_x#1
+    data start_y#1
+    data end_y#1
+    data width_factor#1
+    data height_factor#1
+    data effect_side_x#1
+    data effect_side_y#1
+    const left_is_effect=0
+    #const right_is_effect=1
+    const top_is_effect=0
+    const bottom_is_effect=1
+    data diagonal#1
+    const first_diagonal=0
+    const second_diagonal=1
+
+    if init=0
+        set init 1
+
+        sd corners
+        setcall corners stage_effect_corner(1)
+        set start_x w
+        set end_x w
+        set start_y h
+        set end_y h
+        set width_factor 0
+        set height_factor 0
+        set effect_side_x 0
+        set effect_side_y 0
+        if corners=(top_left)
+            set start_x 0
+            set start_y 0
+
+            set diagonal (second_diagonal)
+        elseif corners=(top_right)
+            set end_x 0
+            set start_y 0
+
+            set height_factor 1
+
+            set effect_side_x 1
+
+            set diagonal (first_diagonal)
+        elseif corners=(bottom_left)
+            set start_x 0
+            set end_y 0
+
+            set width_factor 1
+
+            set effect_side_y 1
+
+            set diagonal (first_diagonal)
+        else
+            set end_x 0
+            set end_y 0
+
+            set width_factor 1
+            set height_factor 1
+
+            set effect_side_x 1
+            set effect_side_y 1
+
+            set diagonal (second_diagonal)
+        endelse
+        if in_out=(cover)
+            xor effect_side_x 1
+            xor effect_side_y 1
+        endif
+    endif
+
+    sd last_frame
+    set last_frame nr
+    dec last_frame
+
+    sd part_frame
+    set part_frame nr
+    div part_frame 2
+
+    if k=part_frame
+        xor width_factor 1
+        xor height_factor 1
+    endif
+    sd index
+    set index part_frame
+    if k>=part_frame
+        set index last_frame
+
+        sub k part_frame
+        sub index part_frame
+    endif
+
+    sd pointwidth_x
+    sd pointwidth_y
+    sd pointheight_x
+    sd pointheight_y
+
+    import "rule3_offset" rule3_offset
+
+    setcall pointwidth_x rule3_offset(k,index,start_x,end_x)
+    set pointwidth_y h
+    mult pointwidth_y width_factor
+
+    set pointheight_x w
+    mult pointheight_x height_factor
+    setcall pointheight_y rule3_offset(k,index,start_y,end_y)
+
+    sd diag_left
+    sd diag_top
+    sd diag_right
+    sd diag_bottom
+
+    import "get_lower" get_lower
+    import "get_higher" get_higher
+    setcall diag_left get_lower(pointwidth_x,pointheight_x)
+    setcall diag_top get_lower(pointwidth_y,pointheight_y)
+    setcall diag_right get_higher(pointwidth_x,pointheight_x)
+    setcall diag_bottom get_higher(pointwidth_y,pointheight_y)
+
+    import "rgb_copy" rgb_copy
+    if effect_side_y=(top_is_effect)
+        call rgb_copy(animpixels,pixels,0,0,w,diag_top,rowstride)
+    endif
+
+    sd j
+    set j diag_top
+    while j!=diag_bottom
+        import "rule3_two_offsets" rule3_two_offsets
+        sd x
+        if diagonal=(first_diagonal)
+            setcall x rule3_two_offsets(diag_top,j,diag_bottom,diag_left,diag_right)
+        else
+            setcall x rule3_two_offsets(diag_top,j,diag_bottom,diag_right,diag_left)
+        endelse
+        sd i
+        sd end_i
+        if effect_side_x=(left_is_effect)
+            set i 0
+            set end_i x
+        else
+            set i x
+            set end_i w
+        endelse
+        while i!=end_i
+            import "rgb_px_get" rgb_px_get
+            import "rgb_px_set" rgb_px_set
+            sd value
+            setcall value rgb_px_get(animpixels,i,j,8,3,rowstride)
+            call rgb_px_set(value,pixels,i,j,8,3,rowstride)
+
+            inc i
+        endwhile
+        inc j
+    endwhile
+
+    if effect_side_y=(bottom_is_effect)
+        call rgb_copy(animpixels,pixels,0,diag_bottom,w,h,rowstride)
+    endif
+endfunction
+
+
+
+
+function stage_effect_corner(sd part,sd vbox)
+	if part=0
+        #frame
+        import "framefield" framefield
+        str corner="Corner start"
+        sd frame
+        setcall frame framefield(vbox,corner)
+
+        sd framechild
+        import "tablefield" tablefield
+        setcall framechild tablefield(frame,2,2)
+
+        data c_top_left#1
+        data c_top_right#1
+        data c_bottom_left#1
+        data *c_bottom_right#1
+        ss c_top_left_text="Top-Left"
+        ss *o_top_right_text="Top-Right"
+        ss *o_bottom_left_text="Bottom-Left"
+        ss *o_bottom_right_text="Bottom-Right"
+
+        import "table_attach" table_attach
+        sd p_corner^c_top_left
+        sd p_text_corner^c_top_left_text
+        sd c_y=0
+        sd radio=0
+        while c_y!=2
+            sd c_x
+            set c_x 0
+            while c_x!=2
+                importx "_gtk_radio_button_get_group" gtk_radio_button_get_group
+                if radio!=0
+                    setcall radio gtk_radio_button_get_group(radio)
+                endif
+                importx "_gtk_radio_button_new_with_label" gtk_radio_button_new_with_label
+                setcall radio gtk_radio_button_new_with_label(radio,p_text_corner#)
+
+                call table_attach(framechild,radio,c_x,c_y)
+
+                set p_corner# radio
+                add p_corner 4
+                add p_text_corner 4
+                inc c_x
+            endwhile
+            inc c_y
+        endwhile
+        importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
+        call gtk_toggle_button_set_active(c_top_left,1)
+        return 0
+	endif
+        importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
+
+        sd bool
+
+        #top-left
+        setcall bool gtk_toggle_button_get_active(c_top_left)
+        if bool=1
+            return (top_left)
+        endif
+        #top-right
+        setcall bool gtk_toggle_button_get_active(c_top_right)
+        if bool=1
+            return (top_right)
+        endif
+        #bottom-left
+        setcall bool gtk_toggle_button_get_active(c_bottom_left)
+        if bool=1
+            return (bottom_left)
+        endif
+        #bottom
+        return (bottom_right)
+endfunction
--- ovideo-1.orig/src/_prepare/effect/reveal_diagonal.s
+++ /dev/null
@@ -1,277 +0,0 @@
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-const top_left=0
-const top_right=1
-const bottom_left=2
-const bottom_right=3
-
-function stage_reveal_diagonal()
-    import "stage_frame_dialog" stage_frame_dialog
-
-    ss title="Uncover/Cover diagonal effect"
-    data init^stage_reveal_diagonal_init
-    data do^stage_reveal_diagonal_set
-    call stage_frame_dialog(init,do,title)
-endfunction
-
-function stage_reveal_diagonal_init(sd vbox,sd *dialog)
-    import "stage_effect_common_cover_fields" stage_effect_common_cover_fields
-    call stage_effect_common_cover_fields(vbox)
-
-    call stage_effect_corner(0,vbox)
-endfunction
-
-function stage_reveal_diagonal_set()
-    call stage_reveal_diagonal_tool(0)
-    data f^stage_reveal_diagonal_tool
-    import "stage_effect_new" stage_effect_new
-    call stage_effect_new(f,1)
-endfunction
-
-function stage_reveal_diagonal_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd *animpixbuf,sd in_out)
-    data init#1
-    if part==0
-        set init 0
-        return 1
-    endif
-
-    data start_x#1
-    data end_x#1
-    data start_y#1
-    data end_y#1
-    data width_factor#1
-    data height_factor#1
-    data effect_side_x#1
-    data effect_side_y#1
-    const left_is_effect=0
-    #const right_is_effect=1
-    const top_is_effect=0
-    const bottom_is_effect=1
-    data diagonal#1
-    const first_diagonal=0
-    const second_diagonal=1
-
-    if init==0
-        set init 1
-
-        sd corners
-        setcall corners stage_effect_corner(1)
-        set start_x w
-        set end_x w
-        set start_y h
-        set end_y h
-        set width_factor 0
-        set height_factor 0
-        set effect_side_x 0
-        set effect_side_y 0
-        if corners==(top_left)
-            set start_x 0
-            set start_y 0
-
-            set diagonal (second_diagonal)
-        elseif corners==(top_right)
-            set end_x 0
-            set start_y 0
-
-            set height_factor 1
-
-            set effect_side_x 1
-
-            set diagonal (first_diagonal)
-        elseif corners==(bottom_left)
-            set start_x 0
-            set end_y 0
-
-            set width_factor 1
-
-            set effect_side_y 1
-
-            set diagonal (first_diagonal)
-        else
-            set end_x 0
-            set end_y 0
-
-            set width_factor 1
-            set height_factor 1
-
-            set effect_side_x 1
-            set effect_side_y 1
-
-            set diagonal (second_diagonal)
-        endelse
-        if in_out==(cover)
-            xor effect_side_x 1
-            xor effect_side_y 1
-        endif
-    endif
-
-    sd last_frame
-    set last_frame nr
-    dec last_frame
-
-    sd part_frame
-    set part_frame nr
-    div part_frame 2
-
-    if k==part_frame
-        xor width_factor 1
-        xor height_factor 1
-    endif
-    sd index
-    set index part_frame
-    if k>=part_frame
-        set index last_frame
-
-        sub k part_frame
-        sub index part_frame
-    endif
-
-    sd pointwidth_x
-    sd pointwidth_y
-    sd pointheight_x
-    sd pointheight_y
-
-    import "rule3_offset" rule3_offset
-
-    setcall pointwidth_x rule3_offset(k,index,start_x,end_x)
-    set pointwidth_y h
-    mult pointwidth_y width_factor
-
-    set pointheight_x w
-    mult pointheight_x height_factor
-    setcall pointheight_y rule3_offset(k,index,start_y,end_y)
-
-    sd diag_left
-    sd diag_top
-    sd diag_right
-    sd diag_bottom
-
-    import "get_lower" get_lower
-    import "get_higher" get_higher
-    setcall diag_left get_lower(pointwidth_x,pointheight_x)
-    setcall diag_top get_lower(pointwidth_y,pointheight_y)
-    setcall diag_right get_higher(pointwidth_x,pointheight_x)
-    setcall diag_bottom get_higher(pointwidth_y,pointheight_y)
-
-    import "rgb_copy" rgb_copy
-    if effect_side_y==(top_is_effect)
-        call rgb_copy(animpixels,pixels,0,0,w,diag_top,rowstride)
-    endif
-
-    sd j
-    set j diag_top
-    while j!=diag_bottom
-        import "rule3_two_offsets" rule3_two_offsets
-        sd x
-        if diagonal==(first_diagonal)
-            setcall x rule3_two_offsets(diag_top,j,diag_bottom,diag_left,diag_right)
-        else
-            setcall x rule3_two_offsets(diag_top,j,diag_bottom,diag_right,diag_left)
-        endelse
-        sd i
-        sd end_i
-        if effect_side_x==(left_is_effect)
-            set i 0
-            set end_i x
-        else
-            set i x
-            set end_i w
-        endelse
-        while i!=end_i
-            import "rgb_px_get" rgb_px_get
-            import "rgb_px_set" rgb_px_set
-            sd value
-            setcall value rgb_px_get(animpixels,i,j,8,3,rowstride)
-            call rgb_px_set(value,pixels,i,j,8,3,rowstride)
-
-            inc i
-        endwhile
-        inc j
-    endwhile
-
-    if effect_side_y==(bottom_is_effect)
-        call rgb_copy(animpixels,pixels,0,diag_bottom,w,h,rowstride)
-    endif
-endfunction
-
-
-
-
-function stage_effect_corner(sd part,sd vbox)
-    if part==0
-        #frame
-        import "framefield" framefield
-        str corner="Corner start"
-        sd frame
-        setcall frame framefield(vbox,corner)
-
-        sd framechild
-        import "tablefield" tablefield
-        setcall framechild tablefield(frame,2,2)
-
-        data c_top_left#1
-        data c_top_right#1
-        data c_bottom_left#1
-        data *c_bottom_right#1
-        ss c_top_left_text="Top-Left"
-        ss *o_top_right_text="Top-Right"
-        ss *o_bottom_left_text="Bottom-Left"
-        ss *o_bottom_right_text="Bottom-Right"
-
-        import "table_attach" table_attach
-        sd p_corner^c_top_left
-        sd p_text_corner^c_top_left_text
-        sd c_y=0
-        sd radio=0
-        while c_y!=2
-            sd c_x
-            set c_x 0
-            while c_x!=2
-                importx "_gtk_radio_button_get_group" gtk_radio_button_get_group
-                if radio!=0
-                    setcall radio gtk_radio_button_get_group(radio)
-                endif
-                importx "_gtk_radio_button_new_with_label" gtk_radio_button_new_with_label
-                setcall radio gtk_radio_button_new_with_label(radio,p_text_corner#)
-
-                call table_attach(framechild,radio,c_x,c_y)
-
-                set p_corner# radio
-                add p_corner 4
-                add p_text_corner 4
-                inc c_x
-            endwhile
-            inc c_y
-        endwhile
-        importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
-        call gtk_toggle_button_set_active(c_top_left,1)
-        return 0
-    else
-        importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
-
-        sd bool
-
-        #top-left
-        setcall bool gtk_toggle_button_get_active(c_top_left)
-        if bool==1
-            return (top_left)
-        endif
-        #top-right
-        setcall bool gtk_toggle_button_get_active(c_top_right)
-        if bool==1
-            return (top_right)
-        endif
-        #bottom-left
-        setcall bool gtk_toggle_button_get_active(c_bottom_left)
-        if bool==1
-            return (bottom_left)
-        endif
-        #bottom
-        return (bottom_right)
-    endelse
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/effect/reveal_shape.oc
@@ -0,0 +1,237 @@
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+const stage_reveal_shape_rectangle=0
+const stage_reveal_shape_diamond=1
+const stage_reveal_shape_curve=2
+
+function stage_reveal_rectangle()
+    call stage_reveal_shape_data(0,(stage_reveal_shape_rectangle))
+    ss title="Uncover/Cover rectangle effect"
+    call stage_reveal_shape(title)
+endfunction
+
+function stage_reveal_diamond()
+    call stage_reveal_shape_data(0,(stage_reveal_shape_diamond))
+    ss title="Uncover/Cover diamond effect"
+    call stage_reveal_shape(title)
+endfunction
+
+function stage_reveal_curve()
+    call stage_reveal_shape_data(0,(stage_reveal_shape_curve))
+    ss title="Uncover/Cover curve effect"
+    call stage_reveal_shape(title)
+endfunction
+
+
+function stage_reveal_shape_data(sd action,sd value)
+    if action=0
+        data shape#1
+        set shape value
+    else
+        return shape
+    endelse
+endfunction
+
+function stage_reveal_shape(ss title)
+    import "stage_frame_dialog" stage_frame_dialog
+    data init^stage_reveal_shape_init
+    data do^stage_reveal_shape_set
+    call stage_frame_dialog(init,do,title)
+endfunction
+
+function stage_reveal_shape_init(sd vbox,sd *dialog)
+    import "stage_effect_common_cover_fields" stage_effect_common_cover_fields
+    call stage_effect_common_cover_fields(vbox)
+endfunction
+
+function stage_reveal_shape_set()
+    call stage_reveal_shape_tool(0)
+    data f^stage_reveal_shape_tool
+    import "stage_effect_new" stage_effect_new
+    call stage_effect_new(f,1)
+endfunction
+
+function stage_reveal_shape_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd *animpixbuf,sd in_out)
+    data init#1
+    if part=0
+        set init 0
+        return 0
+    endif
+    if init=0
+        data last_frame#1
+        set last_frame nr
+        dec last_frame
+
+        data start_width#1
+        data end_width#1
+        data start_height#1
+        data end_height#1
+
+        if in_out=(uncover)
+            set start_width 0
+            set end_width w
+            set start_height 0
+            set end_height h
+        else
+            set start_width w
+            set end_width 0
+            set start_height h
+            set end_height 0
+        endelse
+
+        set init 1
+    endif
+
+    import "rule3_offset" rule3_offset
+    import "centered" centered
+
+    sd frame_width
+    sd frame_height
+
+    setcall frame_width rule3_offset(k,last_frame,start_width,end_width)
+    setcall frame_height rule3_offset(k,last_frame,start_height,end_height)
+
+    sd left
+    sd top
+    sd right
+    sd bottom
+
+    setcall left centered(w,frame_width)
+    setcall top centered(h,frame_height)
+
+    set right left
+    add right frame_width
+    set bottom top
+    add bottom frame_height
+
+
+    sd shape
+    setcall shape stage_reveal_shape_data(1)
+
+    import "rgb_px_get" rgb_px_get
+    import "rgb_px_set" rgb_px_set
+
+    sd i
+    sd j
+    sd value
+	if shape=(stage_reveal_shape_rectangle)
+        set j top
+        while j!=bottom
+            set i left
+            while i!=right
+                setcall value rgb_px_get(animpixels,i,j,8,3,rowstride)
+                call rgb_px_set(value,pixels,i,j,8,3,rowstride)
+                inc i
+            endwhile
+            inc j
+        endwhile
+        return 1
+	endif
+    #if shape==(stage_reveal_shape_diamond)||shape==(stage_reveal_shape_curve)
+        sd half_width
+        set half_width frame_width
+        div half_width 2
+        if half_width=0
+            return 0
+        endif
+        sd half_height
+        set half_height frame_height
+        div half_height 2
+        if half_height=0
+            return 0
+        endif
+
+        sd diamond_part_left
+        sd diamond_part_top
+        sd diamond_part_right
+        sd diamond_part_bottom
+
+        set diamond_part_left left
+        set diamond_part_top top
+        set diamond_part_right right
+        set diamond_part_bottom bottom
+
+        sub diamond_part_left half_width
+        sub diamond_part_top half_height
+        sub diamond_part_right half_width
+        sub diamond_part_bottom half_height
+
+        sd diamond_bottom
+        set diamond_bottom diamond_part_bottom
+        add diamond_bottom frame_height
+
+        set j diamond_part_top
+        while j!=diamond_bottom
+            sd bool
+            setcall bool stage_reveal_diamond_row(j,h)
+            if bool=1
+                sd start_x
+                sd end_x
+                sd start_y
+                sd end_y
+
+                import "rule3_two_offsets" rule3_two_offsets
+
+                if j<top
+                    set start_x diamond_part_right
+                    set end_x left
+                    set start_y diamond_part_top
+                    set end_y top
+                elseif j<diamond_part_bottom
+                    set start_x left
+                    set end_x diamond_part_left
+                    set start_y top
+                    set end_y diamond_part_bottom
+                elseif j<bottom
+                    set start_x diamond_part_left
+                    set end_x left
+                    set start_y diamond_part_bottom
+                    set end_y bottom
+                else
+                    set start_x left
+                    set end_x diamond_part_right
+                    set start_y bottom
+                    set end_y diamond_bottom
+                endelse
+                setcall i rule3_two_offsets(start_y,j,end_y,start_x,end_x)
+
+                if shape=(stage_reveal_shape_curve)
+                #curve
+                    if j<diamond_part_bottom
+                        setcall i rule3_two_offsets(diamond_part_top,j,diamond_part_bottom,i,diamond_part_left)
+                    else
+                        setcall i rule3_two_offsets(diamond_part_bottom,j,diamond_bottom,diamond_part_left,i)
+                    endelse
+                endif
+
+                if i<0
+                    set i 0
+                endif
+
+                sd z
+                set z w
+                sub z i
+
+                while i!=z
+                    setcall value rgb_px_get(animpixels,i,j,8,3,rowstride)
+                    call rgb_px_set(value,pixels,i,j,8,3,rowstride)
+                    inc i
+                endwhile
+            endif
+            inc j
+        endwhile
+endfunction
+
+function stage_reveal_diamond_row(sd j,sd height)
+	if j<0
+        return 0
+	endif
+	if j>=height
+        return 0
+	endif
+    return 1
+endfunction
--- ovideo-1.orig/src/_prepare/effect/reveal_shape.s
+++ /dev/null
@@ -1,237 +0,0 @@
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-const stage_reveal_shape_rectangle=0
-const stage_reveal_shape_diamond=1
-const stage_reveal_shape_curve=2
-
-function stage_reveal_rectangle()
-    call stage_reveal_shape_data(0,(stage_reveal_shape_rectangle))
-    ss title="Uncover/Cover rectangle effect"
-    call stage_reveal_shape(title)
-endfunction
-
-function stage_reveal_diamond()
-    call stage_reveal_shape_data(0,(stage_reveal_shape_diamond))
-    ss title="Uncover/Cover diamond effect"
-    call stage_reveal_shape(title)
-endfunction
-
-function stage_reveal_curve()
-    call stage_reveal_shape_data(0,(stage_reveal_shape_curve))
-    ss title="Uncover/Cover curve effect"
-    call stage_reveal_shape(title)
-endfunction
-
-
-function stage_reveal_shape_data(sd action,sd value)
-    if action==0
-        data shape#1
-        set shape value
-    else
-        return shape
-    endelse
-endfunction
-
-function stage_reveal_shape(ss title)
-    import "stage_frame_dialog" stage_frame_dialog
-    data init^stage_reveal_shape_init
-    data do^stage_reveal_shape_set
-    call stage_frame_dialog(init,do,title)
-endfunction
-
-function stage_reveal_shape_init(sd vbox,sd *dialog)
-    import "stage_effect_common_cover_fields" stage_effect_common_cover_fields
-    call stage_effect_common_cover_fields(vbox)
-endfunction
-
-function stage_reveal_shape_set()
-    call stage_reveal_shape_tool(0)
-    data f^stage_reveal_shape_tool
-    import "stage_effect_new" stage_effect_new
-    call stage_effect_new(f,1)
-endfunction
-
-function stage_reveal_shape_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd animpixels,sd *animpixbuf,sd in_out)
-    data init#1
-    if part==0
-        set init 0
-        return 0
-    endif
-    if init==0
-        data last_frame#1
-        set last_frame nr
-        dec last_frame
-
-        data start_width#1
-        data end_width#1
-        data start_height#1
-        data end_height#1
-
-        if in_out==(uncover)
-            set start_width 0
-            set end_width w
-            set start_height 0
-            set end_height h
-        else
-            set start_width w
-            set end_width 0
-            set start_height h
-            set end_height 0
-        endelse
-
-        set init 1
-    endif
-
-    import "rule3_offset" rule3_offset
-    import "centered" centered
-
-    sd frame_width
-    sd frame_height
-
-    setcall frame_width rule3_offset(k,last_frame,start_width,end_width)
-    setcall frame_height rule3_offset(k,last_frame,start_height,end_height)
-
-    sd left
-    sd top
-    sd right
-    sd bottom
-
-    setcall left centered(w,frame_width)
-    setcall top centered(h,frame_height)
-
-    set right left
-    add right frame_width
-    set bottom top
-    add bottom frame_height
-
-
-    sd shape
-    setcall shape stage_reveal_shape_data(1)
-
-    import "rgb_px_get" rgb_px_get
-    import "rgb_px_set" rgb_px_set
-
-    sd i
-    sd j
-    sd value
-    if shape==(stage_reveal_shape_rectangle)
-        set j top
-        while j!=bottom
-            set i left
-            while i!=right
-                setcall value rgb_px_get(animpixels,i,j,8,3,rowstride)
-                call rgb_px_set(value,pixels,i,j,8,3,rowstride)
-                inc i
-            endwhile
-            inc j
-        endwhile
-        return 1
-    else
-    #if shape==(stage_reveal_shape_diamond)||shape==(stage_reveal_shape_curve)
-        sd half_width
-        set half_width frame_width
-        div half_width 2
-        if half_width==0
-            return 0
-        endif
-        sd half_height
-        set half_height frame_height
-        div half_height 2
-        if half_height==0
-            return 0
-        endif
-
-        sd diamond_part_left
-        sd diamond_part_top
-        sd diamond_part_right
-        sd diamond_part_bottom
-
-        set diamond_part_left left
-        set diamond_part_top top
-        set diamond_part_right right
-        set diamond_part_bottom bottom
-
-        sub diamond_part_left half_width
-        sub diamond_part_top half_height
-        sub diamond_part_right half_width
-        sub diamond_part_bottom half_height
-
-        sd diamond_bottom
-        set diamond_bottom diamond_part_bottom
-        add diamond_bottom frame_height
-
-        set j diamond_part_top
-        while j!=diamond_bottom
-            sd bool
-            setcall bool stage_reveal_diamond_row(j,h)
-            if bool==1
-                sd start_x
-                sd end_x
-                sd start_y
-                sd end_y
-
-                import "rule3_two_offsets" rule3_two_offsets
-
-                if j<top
-                    set start_x diamond_part_right
-                    set end_x left
-                    set start_y diamond_part_top
-                    set end_y top
-                elseif j<diamond_part_bottom
-                    set start_x left
-                    set end_x diamond_part_left
-                    set start_y top
-                    set end_y diamond_part_bottom
-                elseif j<bottom
-                    set start_x diamond_part_left
-                    set end_x left
-                    set start_y diamond_part_bottom
-                    set end_y bottom
-                else
-                    set start_x left
-                    set end_x diamond_part_right
-                    set start_y bottom
-                    set end_y diamond_bottom
-                endelse
-                setcall i rule3_two_offsets(start_y,j,end_y,start_x,end_x)
-
-                if shape==(stage_reveal_shape_curve)
-                #curve
-                    if j<diamond_part_bottom
-                        setcall i rule3_two_offsets(diamond_part_top,j,diamond_part_bottom,i,diamond_part_left)
-                    else
-                        setcall i rule3_two_offsets(diamond_part_bottom,j,diamond_bottom,diamond_part_left,i)
-                    endelse
-                endif
-
-                if i<0
-                    set i 0
-                endif
-
-                sd z
-                set z w
-                sub z i
-
-                while i!=z
-                    setcall value rgb_px_get(animpixels,i,j,8,3,rowstride)
-                    call rgb_px_set(value,pixels,i,j,8,3,rowstride)
-                    inc i
-                endwhile
-            endif
-            inc j
-        endwhile
-    endelse
-endfunction
-
-function stage_reveal_diamond_row(sd j,sd height)
-    if j<0
-        return 0
-    elseif j>=height
-        return 0
-    endelseif
-    return 1
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/effect/scale_effect.oc
@@ -0,0 +1,198 @@
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+import "stage_frame_dialog" stage_frame_dialog
+
+function stage_effect_scale()
+    ss title="Scale In/Scale Out effect"
+    data init^stage_effect_scale_init
+    data do^stage_effect_scale_set
+    call stage_frame_dialog(init,do,title)
+endfunction
+
+function stage_effect_scale_init(sd vbox,sd *dialog)
+    import "stage_effect_common_fields" stage_effect_common_fields
+    #Common fields and start from image/end with image
+    ss in_text="Start from image"
+    ss out_text="End with image"
+    call stage_effect_common_fields(vbox,in_text,out_text)
+
+    #Scale to smaller size/Scale to greater size
+    import "stage_effect_in_out" stage_effect_in_out
+    ss low_text="Scale to smaller size"
+    ss high_text="Scale to greater size"
+    data higher_scale#1
+    const p_higher_scale^higher_scale
+    setcall higher_scale stage_effect_in_out(vbox,low_text,high_text)
+
+    call stage_effect_scale_orientation(0,vbox)
+endfunction
+
+function stage_effect_scale_set()
+    call stage_effect_scale_tool(0)
+    data f^stage_effect_scale_tool
+    import "stage_effect_new" stage_effect_new
+    call stage_effect_new(f,1)
+endfunction
+
+const start_from_image=0
+#const end_with_image=1
+
+importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
+
+function stage_effect_scale_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd *animpixels,sd animpixbuf,sd in_out)
+    data orientation_left_mult#1
+    data orientation_top_mult#1
+    if part=0
+        data init#1
+        set init 0
+        sd p_orientation_top_mult^orientation_top_mult
+        setcall orientation_left_mult stage_effect_scale_orientation(1,p_orientation_top_mult)
+
+        return 0
+    endif
+    if init=0
+        data start_rect_width#1
+        data start_rect_height#1
+
+        data end_rect_width#1
+        data end_rect_height#1
+
+        if in_out=(start_from_image)
+            set start_rect_width w
+            set start_rect_height h
+            set end_rect_width 0
+            set end_rect_height 0
+        else
+            set end_rect_width w
+            set end_rect_height h
+            set start_rect_width 0
+            set start_rect_height 0
+        endelse
+
+        data last_frame#1
+        set last_frame nr
+        dec last_frame
+
+        sd smaller_greater_entry%p_higher_scale
+        data smaller_greater#1
+        setcall smaller_greater gtk_toggle_button_get_active(smaller_greater_entry#)
+
+        const smaller=0
+        const greater=1
+
+        data subpixels#1
+        set subpixels 0
+        if in_out=(start_from_image)
+            if smaller_greater=(greater)
+                set subpixels 1
+            endif
+        else
+            if smaller_greater=(smaller)
+                set subpixels 1
+            endif
+        endelse
+
+        set init 1
+    endif
+
+    import "rule3_offset" rule3_offset
+    sd frame_width
+    sd frame_height
+    setcall frame_width rule3_offset(k,last_frame,start_rect_width,end_rect_width)
+    setcall frame_height rule3_offset(k,last_frame,start_rect_height,end_rect_height)
+
+	if frame_width<4
+        return 0
+	endif
+	if frame_height<4
+        return 0
+	endif
+
+    sd left
+    sd top
+    set left w
+    sub left frame_width
+    div left 2
+    set top h
+    sub top frame_height
+    div top 2
+
+    sd orientation_left_offset
+    set orientation_left_offset left
+    mult orientation_left_offset orientation_left_mult
+    setcall orientation_left_offset rule3_offset(k,last_frame,orientation_left_offset,0)
+    add left orientation_left_offset
+
+    sd orientation_top_offset
+    set orientation_top_offset top
+    mult orientation_top_offset orientation_top_mult
+    setcall orientation_top_offset rule3_offset(k,last_frame,orientation_top_offset,0)
+    add top orientation_top_offset
+
+    sd newpixbuf
+
+    import "pixbuf_scale" pixbuf_scale
+    importx "_g_object_unref" g_object_unref
+
+    if subpixels=0
+        setcall newpixbuf pixbuf_scale(animpixbuf,frame_width,frame_height)
+    else
+        importx "_gdk_pixbuf_new_subpixbuf" gdk_pixbuf_new_subpixbuf
+        sd croppixbuf
+        setcall croppixbuf gdk_pixbuf_new_subpixbuf(animpixbuf,left,top,frame_width,frame_height)
+        if croppixbuf=0
+            return 0
+        endif
+        setcall newpixbuf pixbuf_scale(croppixbuf,w,h)
+        call g_object_unref(croppixbuf)
+        set left 0
+        set top 0
+        set frame_width w
+        set frame_height h
+    endelse
+    if newpixbuf=0
+        return 0
+    endif
+
+    import "rgb_px_get" rgb_px_get
+    import "rgb_px_set" rgb_px_set
+    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+
+    import "rgb_get_all_sizes" rgb_get_all_sizes
+    sd rowstr
+    sd p_rowstr^rowstr
+    call rgb_get_all_sizes(frame_width,frame_height,p_rowstr)
+
+    ss newbytes
+    setcall newbytes gdk_pixbuf_get_pixels(newpixbuf)
+
+    sd left_off
+    set left_off left
+    sd j=0
+    while j!=frame_height
+        sd i=0
+        set left left_off
+        while i!=frame_width
+            sd value
+            setcall value rgb_px_get(newbytes,i,j,8,3,rowstr)
+            call rgb_px_set(value,pixels,left,top,8,3,rowstride)
+            inc left
+            inc i
+        endwhile
+        inc top
+        inc j
+    endwhile
+    call g_object_unref(newpixbuf)
+endfunction
+
+function stage_effect_scale_orientation(sd part,sd argument)
+    import "stage_effect_orientation" stage_effect_orientation
+    sd value
+    ss text="Orientation"
+    setcall value stage_effect_orientation(part,argument,(TRUE),text)
+    return value
+endfunction
--- ovideo-1.orig/src/_prepare/effect/scale_effect.s
+++ /dev/null
@@ -1,197 +0,0 @@
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-import "stage_frame_dialog" stage_frame_dialog
-
-function stage_effect_scale()
-    ss title="Scale In/Scale Out effect"
-    data init^stage_effect_scale_init
-    data do^stage_effect_scale_set
-    call stage_frame_dialog(init,do,title)
-endfunction
-
-function stage_effect_scale_init(sd vbox,sd *dialog)
-    import "stage_effect_common_fields" stage_effect_common_fields
-    #Common fields and start from image/end with image
-    ss in_text="Start from image"
-    ss out_text="End with image"
-    call stage_effect_common_fields(vbox,in_text,out_text)
-
-    #Scale to smaller size/Scale to greater size
-    import "stage_effect_in_out" stage_effect_in_out
-    ss low_text="Scale to smaller size"
-    ss high_text="Scale to greater size"
-    data higher_scale#1
-    const p_higher_scale^higher_scale
-    setcall higher_scale stage_effect_in_out(vbox,low_text,high_text)
-
-    call stage_effect_scale_orientation(0,vbox)
-endfunction
-
-function stage_effect_scale_set()
-    call stage_effect_scale_tool(0)
-    data f^stage_effect_scale_tool
-    import "stage_effect_new" stage_effect_new
-    call stage_effect_new(f,1)
-endfunction
-
-const start_from_image=0
-#const end_with_image=1
-
-importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
-
-function stage_effect_scale_tool(sd part,sd k,sd nr,sd pixels,sd w,sd h,sd rowstride,sd *animpixels,sd animpixbuf,sd in_out)
-    data orientation_left_mult#1
-    data orientation_top_mult#1
-    if part==0
-        data init#1
-        set init 0
-        sd p_orientation_top_mult^orientation_top_mult
-        setcall orientation_left_mult stage_effect_scale_orientation(1,p_orientation_top_mult)
-
-        return 0
-    endif
-    if init==0
-        data start_rect_width#1
-        data start_rect_height#1
-
-        data end_rect_width#1
-        data end_rect_height#1
-
-        if in_out==(start_from_image)
-            set start_rect_width w
-            set start_rect_height h
-            set end_rect_width 0
-            set end_rect_height 0
-        else
-            set end_rect_width w
-            set end_rect_height h
-            set start_rect_width 0
-            set start_rect_height 0
-        endelse
-
-        data last_frame#1
-        set last_frame nr
-        dec last_frame
-
-        sd smaller_greater_entry%p_higher_scale
-        data smaller_greater#1
-        setcall smaller_greater gtk_toggle_button_get_active(smaller_greater_entry#)
-
-        const smaller=0
-        const greater=1
-
-        data subpixels#1
-        set subpixels 0
-        if in_out==(start_from_image)
-            if smaller_greater==(greater)
-                set subpixels 1
-            endif
-        else
-            if smaller_greater==(smaller)
-                set subpixels 1
-            endif
-        endelse
-
-        set init 1
-    endif
-
-    import "rule3_offset" rule3_offset
-    sd frame_width
-    sd frame_height
-    setcall frame_width rule3_offset(k,last_frame,start_rect_width,end_rect_width)
-    setcall frame_height rule3_offset(k,last_frame,start_rect_height,end_rect_height)
-
-    if frame_width<4
-        return 0
-    elseif frame_height<4
-        return 0
-    endelseif
-
-    sd left
-    sd top
-    set left w
-    sub left frame_width
-    div left 2
-    set top h
-    sub top frame_height
-    div top 2
-
-    sd orientation_left_offset
-    set orientation_left_offset left
-    mult orientation_left_offset orientation_left_mult
-    setcall orientation_left_offset rule3_offset(k,last_frame,orientation_left_offset,0)
-    add left orientation_left_offset
-
-    sd orientation_top_offset
-    set orientation_top_offset top
-    mult orientation_top_offset orientation_top_mult
-    setcall orientation_top_offset rule3_offset(k,last_frame,orientation_top_offset,0)
-    add top orientation_top_offset
-
-    sd newpixbuf
-
-    import "pixbuf_scale" pixbuf_scale
-    importx "_g_object_unref" g_object_unref
-
-    if subpixels==0
-        setcall newpixbuf pixbuf_scale(animpixbuf,frame_width,frame_height)
-    else
-        importx "_gdk_pixbuf_new_subpixbuf" gdk_pixbuf_new_subpixbuf
-        sd croppixbuf
-        setcall croppixbuf gdk_pixbuf_new_subpixbuf(animpixbuf,left,top,frame_width,frame_height)
-        if croppixbuf==0
-            return 0
-        endif
-        setcall newpixbuf pixbuf_scale(croppixbuf,w,h)
-        call g_object_unref(croppixbuf)
-        set left 0
-        set top 0
-        set frame_width w
-        set frame_height h
-    endelse
-    if newpixbuf==0
-        return 0
-    endif
-
-    import "rgb_px_get" rgb_px_get
-    import "rgb_px_set" rgb_px_set
-    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-
-    import "rgb_get_all_sizes" rgb_get_all_sizes
-    sd rowstr
-    sd p_rowstr^rowstr
-    call rgb_get_all_sizes(frame_width,frame_height,p_rowstr)
-
-    ss newbytes
-    setcall newbytes gdk_pixbuf_get_pixels(newpixbuf)
-
-    sd left_off
-    set left_off left
-    sd j=0
-    while j!=frame_height
-        sd i=0
-        set left left_off
-        while i!=frame_width
-            sd value
-            setcall value rgb_px_get(newbytes,i,j,8,3,rowstr)
-            call rgb_px_set(value,pixels,left,top,8,3,rowstride)
-            inc left
-            inc i
-        endwhile
-        inc top
-        inc j
-    endwhile
-    call g_object_unref(newpixbuf)
-endfunction
-
-function stage_effect_scale_orientation(sd part,sd argument)
-    import "stage_effect_orientation" stage_effect_orientation
-    sd value
-    ss text="Orientation"
-    setcall value stage_effect_orientation(part,argument,(TRUE),text)
-    return value
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/frame/add.oc
@@ -0,0 +1,259 @@
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+import "filechooserfield_forward" filechooserfield_forward
+import "pixbuf_from_file" pixbuf_from_file
+
+#new frame
+function stage_new_frame()
+    data f^stage_new_frame_got_filename
+    call filechooserfield_forward(f)
+endfunction
+function stage_new_frame_got_filename(ss filename)
+    sd pixbuf
+    setcall pixbuf pixbuf_from_file(filename)
+    sd z=0
+    if pixbuf!=z
+        call stage_new_pixbuf(pixbuf)
+    endif
+endfunction
+function stage_new_pixbuf(sd pixbuf)
+    str text="Frame added. Total frames: "
+    import "stage_new_pix" stage_new_pix
+    call stage_new_pix(pixbuf,text)
+    import "stage_display_last" stage_display_last
+    call stage_display_last()
+endfunction
+
+
+function stage_filechooser_verify_noframes(sd forward_fn)
+    import "stage_get_sel" stage_get_sel
+    sd img
+    setcall img stage_get_sel()
+    if img=0
+        return 0
+    endif
+    call filechooserfield_forward(forward_fn)
+endfunction
+
+import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
+
+#new frame centered on existing
+function stage_add_centered()
+    data f^stage_add_centered_fn
+    call stage_filechooser_verify_noframes(f)
+endfunction
+function stage_add_centered_fn(sd filename)
+    sd newpixbuf
+    setcall newpixbuf pixbuf_from_file(filename)
+    if newpixbuf=0
+        return 0
+    endif
+    sd pixbuf
+    sd p_pixbuf^pixbuf
+    call stage_get_sel_pixbuf(p_pixbuf)
+    call stage_pixbuf_in_container_pixbuf(newpixbuf,pixbuf)
+    importx "_g_object_unref" g_object_unref
+    call g_object_unref(newpixbuf)
+    import "stage_redraw" stage_redraw
+    call stage_redraw()
+endfunction
+
+import "pixbuf_get_wh" pixbuf_get_wh
+
+function stage_pixbuf_in_container_pixbuf(sd newpixbuf,sd containerpixbuf)
+    sd width
+    sd height
+    sd p_height^height
+    sd p_new^width
+    sd c_width
+    sd c_height
+    sd p_c^c_width
+    call pixbuf_get_wh(newpixbuf,p_new)
+    call pixbuf_get_wh(containerpixbuf,p_c)
+
+    import "rectangle_fit_container_rectangle" rectangle_fit_container_rectangle
+    setcall width rectangle_fit_container_rectangle(width,height,c_width,c_height,p_height)
+
+    #test for not accessing invalid memory
+    #import "rgb_test" rgb_test
+    #sd bool
+    #setcall bool rgb_test(containerpixbuf)
+    #if bool==0
+    #    return 0
+    #endif
+    #setcall bool rgb_test(newpixbuf)
+    #if bool==0
+    #    return 0
+    #endif
+
+    import "pixbuf_scale_forward_data" pixbuf_scale_forward_data
+    data f^stage_pixbuf_in_container_pixbuf_set
+    call pixbuf_scale_forward_data(newpixbuf,width,height,f,containerpixbuf)
+endfunction
+
+function stage_pixbuf_in_container_pixbuf_set(sd newpixbuf,sd containerpixbuf)
+    sd width
+    sd height
+    sd c_width
+    sd c_height
+    sd p_new_coord^width
+    sd p_cnt_coord^c_width
+    call pixbuf_get_wh(newpixbuf,p_new_coord)
+    call pixbuf_get_wh(containerpixbuf,p_cnt_coord)
+
+    sd x=0
+    sd y=0
+    if width<c_width
+        set x c_width
+        sub x width
+        div x 2
+    elseif height<c_height
+        set y c_height
+        sub y height
+        div y 2
+    endelseif
+
+    import "rgb_pixbuf_get_pixel" rgb_pixbuf_get_pixel
+    import "rgb_pixbuf_set_pixel" rgb_pixbuf_set_pixel
+    sd j=0
+    sd x_off
+    set x_off x
+    while j!=height
+        sd i=0
+        set x x_off
+        while i!=width
+            sd value
+            setcall value rgb_pixbuf_get_pixel(newpixbuf,i,j,8,3)
+            call rgb_pixbuf_set_pixel(value,containerpixbuf,x,y,8,3)
+            inc x
+            inc i
+        endwhile
+        inc y
+        inc j
+    endwhile
+endfunction
+
+
+
+
+
+#new frame with defined color and width height from selected frame(or nothing if there is no frame)
+function stage_new_frame_form()
+    ss title="Add a frame"
+    import "dialogfield" dialogfield
+    data init^stage_new_frame_form_init
+    data on_ok^stage_new_frame_form_set
+    call dialogfield(title,(GTK_DIALOG_MODAL),init,on_ok)
+endfunction
+
+function stage_new_frame_form_init(sd vbox,sd *dialog)
+    import "stage_get_sel_pixbuf_nowarning" stage_get_sel_pixbuf_nowarning
+
+    sd px=0
+    sd p_px^px
+    call stage_get_sel_pixbuf_nowarning(p_px)
+
+    call stage_frame_form_data_init(vbox,px)
+endfunction
+
+function stage_new_frame_form_set()
+    sd pixbuf
+    setcall pixbuf stage_frame_form_data((stage_frame_form_data_pixbuf))
+    if pixbuf=0
+        return 0
+    endif
+    call stage_new_pixbuf(pixbuf)
+endfunction
+
+function stage_frame_form_data_init(sd vbox,sd pixbuf)
+    importx "_gtk_table_new" gtk_table_new
+    importx "_gtk_table_attach_defaults" gtk_table_attach_defaults
+    import "labelfield_left_prepare" labelfield_left_prepare
+    importx "_gtk_entry_new" gtk_entry_new
+    import "int_to_entry" int_to_entry
+
+    sd value
+    sd table
+    setcall table gtk_table_new(2,2,0)
+
+    ss w_text="Width: "
+    setcall value labelfield_left_prepare(w_text)
+    call gtk_table_attach_defaults(table,value,0,1,0,1)
+    setcall value gtk_entry_new()
+    if pixbuf!=0
+        importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+        sd wd
+        setcall wd gdk_pixbuf_get_width(pixbuf)
+        call int_to_entry(wd,value)
+    endif
+
+    call stage_frame_form_data((stage_frame_form_data_width),value)
+    call gtk_table_attach_defaults(table,value,1,2,0,1)
+
+    ss h_text="Height: "
+    setcall value labelfield_left_prepare(h_text)
+    call gtk_table_attach_defaults(table,value,0,1,1,2)
+    setcall value gtk_entry_new()
+    if pixbuf!=0
+        importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+        sd hg
+        setcall hg gdk_pixbuf_get_height(pixbuf)
+        call int_to_entry(hg,value)
+    endif
+    call stage_frame_form_data((stage_frame_form_data_height),value)
+    call gtk_table_attach_defaults(table,value,1,2,1,2)
+
+    importx "_gtk_container_add" gtk_container_add
+    call gtk_container_add(vbox,table)
+
+    import "colorbuttonfield_leftlabel" colorbuttonfield_leftlabel
+    ss bgcolor="Color: "
+    setcall value colorbuttonfield_leftlabel(bgcolor,vbox)
+    call stage_frame_form_data((stage_frame_form_data_color),value)
+endfunction
+
+function stage_frame_form_data(sd action,sd value)
+	if action=0
+        data width_entry#1
+        set width_entry value
+        return 0
+	endif
+	if action=1
+        data height_entry#1
+        set height_entry value
+        return 0
+	endif
+	if action=2
+        data color_entry#1
+        set color_entry value
+        return 0
+	endif
+
+    import "entry_to_nr_minValue" entry_to_nr_minValue
+
+    sd width
+    sd p_w^width
+    call entry_to_nr_minValue(width_entry,p_w,4)
+
+    sd height
+    sd p_h^height
+    call entry_to_nr_minValue(height_entry,p_h,4)
+
+    import "color_widget_get_color_to_rgb" color_widget_get_color_to_rgb
+    sd color
+    setcall color color_widget_get_color_to_rgb(color_entry)
+
+    import "new_pixbuf_color" new_pixbuf_color
+    sd pixbuf
+    setcall pixbuf new_pixbuf_color(width,height,color)
+    if pixbuf=0
+        return 0
+    endif
+
+    return pixbuf
+endfunction
+
--- ovideo-1.orig/src/_prepare/frame/add.s
+++ /dev/null
@@ -1,257 +0,0 @@
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-import "filechooserfield_forward" filechooserfield_forward
-import "pixbuf_from_file" pixbuf_from_file
-
-#new frame
-function stage_new_frame()
-    data f^stage_new_frame_got_filename
-    call filechooserfield_forward(f)
-endfunction
-function stage_new_frame_got_filename(ss filename)
-    sd pixbuf
-    setcall pixbuf pixbuf_from_file(filename)
-    sd z=0
-    if pixbuf!=z
-        call stage_new_pixbuf(pixbuf)
-    endif
-endfunction
-function stage_new_pixbuf(sd pixbuf)
-    str text="Frame added. Total frames: "
-    import "stage_new_pix" stage_new_pix
-    call stage_new_pix(pixbuf,text)
-    import "stage_display_last" stage_display_last
-    call stage_display_last()
-endfunction
-
-
-function stage_filechooser_verify_noframes(sd forward_fn)
-    import "stage_get_sel" stage_get_sel
-    sd img
-    setcall img stage_get_sel()
-    if img==0
-        return 0
-    endif
-    call filechooserfield_forward(forward_fn)
-endfunction
-
-import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
-
-#new frame centered on existing
-function stage_add_centered()
-    data f^stage_add_centered_fn
-    call stage_filechooser_verify_noframes(f)
-endfunction
-function stage_add_centered_fn(sd filename)
-    sd newpixbuf
-    setcall newpixbuf pixbuf_from_file(filename)
-    if newpixbuf==0
-        return 0
-    endif
-    sd pixbuf
-    sd p_pixbuf^pixbuf
-    call stage_get_sel_pixbuf(p_pixbuf)
-    call stage_pixbuf_in_container_pixbuf(newpixbuf,pixbuf)
-    importx "_g_object_unref" g_object_unref
-    call g_object_unref(newpixbuf)
-    import "stage_redraw" stage_redraw
-    call stage_redraw()
-endfunction
-
-import "pixbuf_get_wh" pixbuf_get_wh
-
-function stage_pixbuf_in_container_pixbuf(sd newpixbuf,sd containerpixbuf)
-    sd width
-    sd height
-    sd p_height^height
-    sd p_new^width
-    sd c_width
-    sd c_height
-    sd p_c^c_width
-    call pixbuf_get_wh(newpixbuf,p_new)
-    call pixbuf_get_wh(containerpixbuf,p_c)
-
-    import "rectangle_fit_container_rectangle" rectangle_fit_container_rectangle
-    setcall width rectangle_fit_container_rectangle(width,height,c_width,c_height,p_height)
-
-    #test for not accessing invalid memory
-    #import "rgb_test" rgb_test
-    #sd bool
-    #setcall bool rgb_test(containerpixbuf)
-    #if bool==0
-    #    return 0
-    #endif
-    #setcall bool rgb_test(newpixbuf)
-    #if bool==0
-    #    return 0
-    #endif
-
-    import "pixbuf_scale_forward_data" pixbuf_scale_forward_data
-    data f^stage_pixbuf_in_container_pixbuf_set
-    call pixbuf_scale_forward_data(newpixbuf,width,height,f,containerpixbuf)
-endfunction
-
-function stage_pixbuf_in_container_pixbuf_set(sd newpixbuf,sd containerpixbuf)
-    sd width
-    sd height
-    sd c_width
-    sd c_height
-    sd p_new_coord^width
-    sd p_cnt_coord^c_width
-    call pixbuf_get_wh(newpixbuf,p_new_coord)
-    call pixbuf_get_wh(containerpixbuf,p_cnt_coord)
-
-    sd x=0
-    sd y=0
-    if width<c_width
-        set x c_width
-        sub x width
-        div x 2
-    elseif height<c_height
-        set y c_height
-        sub y height
-        div y 2
-    endelseif
-
-    import "rgb_pixbuf_get_pixel" rgb_pixbuf_get_pixel
-    import "rgb_pixbuf_set_pixel" rgb_pixbuf_set_pixel
-    sd j=0
-    sd x_off
-    set x_off x
-    while j!=height
-        sd i=0
-        set x x_off
-        while i!=width
-            sd value
-            setcall value rgb_pixbuf_get_pixel(newpixbuf,i,j,8,3)
-            call rgb_pixbuf_set_pixel(value,containerpixbuf,x,y,8,3)
-            inc x
-            inc i
-        endwhile
-        inc y
-        inc j
-    endwhile
-endfunction
-
-
-
-
-
-#new frame with defined color and width height from selected frame(or nothing if there is no frame)
-function stage_new_frame_form()
-    ss title="Add a frame"
-    import "dialogfield" dialogfield
-    data init^stage_new_frame_form_init
-    data on_ok^stage_new_frame_form_set
-    call dialogfield(title,(GTK_DIALOG_MODAL),init,on_ok)
-endfunction
-
-function stage_new_frame_form_init(sd vbox,sd *dialog)
-    import "stage_get_sel_pixbuf_nowarning" stage_get_sel_pixbuf_nowarning
-
-    sd px=0
-    sd p_px^px
-    call stage_get_sel_pixbuf_nowarning(p_px)
-
-    call stage_frame_form_data_init(vbox,px)
-endfunction
-
-function stage_new_frame_form_set()
-    sd pixbuf
-    setcall pixbuf stage_frame_form_data((stage_frame_form_data_pixbuf))
-    if pixbuf==0
-        return 0
-    endif
-    call stage_new_pixbuf(pixbuf)
-endfunction
-
-function stage_frame_form_data_init(sd vbox,sd pixbuf)
-    importx "_gtk_table_new" gtk_table_new
-    importx "_gtk_table_attach_defaults" gtk_table_attach_defaults
-    import "labelfield_left_prepare" labelfield_left_prepare
-    importx "_gtk_entry_new" gtk_entry_new
-    import "int_to_entry" int_to_entry
-
-    sd value
-    sd table
-    setcall table gtk_table_new(2,2,0)
-
-    ss w_text="Width: "
-    setcall value labelfield_left_prepare(w_text)
-    call gtk_table_attach_defaults(table,value,0,1,0,1)
-    setcall value gtk_entry_new()
-    if pixbuf!=0
-        importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-        sd wd
-        setcall wd gdk_pixbuf_get_width(pixbuf)
-        call int_to_entry(wd,value)
-    endif
-
-    call stage_frame_form_data((stage_frame_form_data_width),value)
-    call gtk_table_attach_defaults(table,value,1,2,0,1)
-
-    ss h_text="Height: "
-    setcall value labelfield_left_prepare(h_text)
-    call gtk_table_attach_defaults(table,value,0,1,1,2)
-    setcall value gtk_entry_new()
-    if pixbuf!=0
-        importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-        sd hg
-        setcall hg gdk_pixbuf_get_height(pixbuf)
-        call int_to_entry(hg,value)
-    endif
-    call stage_frame_form_data((stage_frame_form_data_height),value)
-    call gtk_table_attach_defaults(table,value,1,2,1,2)
-
-    importx "_gtk_container_add" gtk_container_add
-    call gtk_container_add(vbox,table)
-
-    import "colorbuttonfield_leftlabel" colorbuttonfield_leftlabel
-    ss bgcolor="Color: "
-    setcall value colorbuttonfield_leftlabel(bgcolor,vbox)
-    call stage_frame_form_data((stage_frame_form_data_color),value)
-endfunction
-
-function stage_frame_form_data(sd action,sd value)
-    if action==0
-        data width_entry#1
-        set width_entry value
-        return 0
-    elseif action==1
-        data height_entry#1
-        set height_entry value
-        return 0
-    elseif action==2
-        data color_entry#1
-        set color_entry value
-        return 0
-    endelseif
-
-    import "entry_to_nr_minValue" entry_to_nr_minValue
-
-    sd width
-    sd p_w^width
-    call entry_to_nr_minValue(width_entry,p_w,4)
-
-    sd height
-    sd p_h^height
-    call entry_to_nr_minValue(height_entry,p_h,4)
-
-    import "color_widget_get_color_to_rgb" color_widget_get_color_to_rgb
-    sd color
-    setcall color color_widget_get_color_to_rgb(color_entry)
-
-    import "new_pixbuf_color" new_pixbuf_color
-    sd pixbuf
-    setcall pixbuf new_pixbuf_color(width,height,color)
-    if pixbuf==0
-        return 0
-    endif
-
-    return pixbuf
-endfunction
-
--- /dev/null
+++ ovideo-1/src/_prepare/frame/brightness.oc
@@ -0,0 +1,162 @@
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+function stage_brightness()
+    import "stage_frame_dialog" stage_frame_dialog
+    sd init^stage_brightness_init
+    sd set^stage_brightness_set
+    ss title="Image brightness"
+    call stage_frame_dialog(init,set,title)
+endfunction
+
+const brightness_half=50
+const brightness_max=brightness_half*2
+
+function stage_brightness_init(sd vbox,sd *dialog)
+    import "hboxfield_cnt" hboxfield_cnt
+    sd hbox
+    setcall hbox hboxfield_cnt(vbox)
+
+    import "labelfield_left_default" labelfield_left_default
+    str dark="Darken"
+    call labelfield_left_default(dark,hbox)
+
+    import "hscalefield" hscalefield
+    sd hscale
+    setcall hscale hscalefield(hbox,0,(brightness_max),1,(brightness_half))
+    importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
+    call gtk_widget_set_size_request(hscale,400,-1)
+    call hscale_entry((value_set),hscale)
+
+    str bright="Brighten"
+    call labelfield_left_default(bright,hbox)
+endfunction
+
+function hscale_entry(sd action,sd value)
+    data hscale#1
+    if action=(value_set)
+        set hscale value
+    else
+        return hscale
+    endelse
+endfunction
+
+function stage_brightness_set()
+    sd hscale
+    setcall hscale hscale_entry((value_get))
+    import "hscale_get" hscale_get
+    sd value
+    setcall value hscale_get(hscale)
+
+    const blacken=0
+    const whiten=0xFF
+    sd procedure
+    sd walked
+    if value<=(brightness_half)
+        set procedure (blacken)
+        set walked (brightness_half)
+        sub walked value
+    else
+        set procedure (whiten)
+        set walked value
+        sub walked (brightness_half)
+    endelse
+
+    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
+    sd pixbuf
+    sd ptr_pixbuf^pixbuf
+    call stage_get_sel_pixbuf(ptr_pixbuf)
+
+    import "pixbuf_get_wh" pixbuf_get_wh
+    sd w
+    sd h
+    sd wh^w
+    call pixbuf_get_wh(pixbuf,wh)
+    sd j=0
+    sd red
+    sd green
+    sd blue
+    sd colors^red
+    while j!=h
+        sd i=0
+        while i!=w
+            import "pixbuf_get_pixel" pixbuf_get_pixel
+            import "pixbuf_set_pixel" pixbuf_set_pixel
+            import "rgb_uint_to_colors" rgb_uint_to_colors
+
+            sd pixel
+            setcall pixel pixbuf_get_pixel(pixbuf,i,j)
+            call rgb_uint_to_colors(pixel,colors)
+
+            import "rule3_offset" rule3_offset
+
+            sd end_red
+            sd end_green
+            sd end_blue
+            sd end_colors^end_red
+            import "cpymem" cpymem
+            call cpymem(end_colors,colors,(3*4))
+
+            sd average_color
+            set average_color red
+            add average_color green
+            add average_color blue
+            if average_color!=0
+                div average_color 3
+            endif
+
+            if procedure=(blacken)
+                #sub colors to same level
+                sub end_red average_color
+                sub end_green average_color
+                sub end_blue average_color
+            else
+                #add colors to same level
+                add end_red average_color
+                add end_green average_color
+                add end_blue average_color
+            endelse
+
+            #advance according to horizontal scale
+            setcall red rule3_offset(walked,(brightness_half),red,end_red)
+            setcall green rule3_offset(walked,(brightness_half),green,end_green)
+            setcall blue rule3_offset(walked,(brightness_half),blue,end_blue)
+
+            #correct overflow
+            if procedure=(blacken)
+                if red<0
+                    set red 0
+                endif
+                if green<0
+                    set green 0
+                endif
+                if blue<0
+                    set blue 0
+                endif
+            else
+                if red>0xff
+                    set red 0xff
+                endif
+                if green>0xff
+                    set green 0xff
+                endif
+                if blue>0xff
+                    set blue 0xff
+                endif
+            endelse
+
+            import "rgb_colors_to_uint" rgb_colors_to_uint
+            setcall pixel rgb_colors_to_uint(colors)
+
+            call pixbuf_set_pixel(pixbuf,pixel,i,j)
+            inc i
+        endwhile
+        inc j
+    endwhile
+    import "stage_redraw" stage_redraw
+    call stage_redraw()
+endfunction
--- ovideo-1.orig/src/_prepare/frame/brightness.s
+++ /dev/null
@@ -1,162 +0,0 @@
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-function stage_brightness()
-    import "stage_frame_dialog" stage_frame_dialog
-    sd init^stage_brightness_init
-    sd set^stage_brightness_set
-    ss title="Image brightness"
-    call stage_frame_dialog(init,set,title)
-endfunction
-
-const brightness_half=50
-const brightness_max=brightness_half*2
-
-function stage_brightness_init(sd vbox,sd *dialog)
-    import "hboxfield_cnt" hboxfield_cnt
-    sd hbox
-    setcall hbox hboxfield_cnt(vbox)
-
-    import "labelfield_left_default" labelfield_left_default
-    str dark="Darken"
-    call labelfield_left_default(dark,hbox)
-
-    import "hscalefield" hscalefield
-    sd hscale
-    setcall hscale hscalefield(hbox,0,(brightness_max),1,(brightness_half))
-    importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
-    call gtk_widget_set_size_request(hscale,400,-1)
-    call hscale_entry((value_set),hscale)
-
-    str bright="Brighten"
-    call labelfield_left_default(bright,hbox)
-endfunction
-
-function hscale_entry(sd action,sd value)
-    data hscale#1
-    if action==(value_set)
-        set hscale value
-    else
-        return hscale
-    endelse
-endfunction
-
-function stage_brightness_set()
-    sd hscale
-    setcall hscale hscale_entry((value_get))
-    import "hscale_get" hscale_get
-    sd value
-    setcall value hscale_get(hscale)
-
-    const blacken=0
-    const whiten=0xFF
-    sd procedure
-    sd walked
-    if value<=(brightness_half)
-        set procedure (blacken)
-        set walked (brightness_half)
-        sub walked value
-    else
-        set procedure (whiten)
-        set walked value
-        sub walked (brightness_half)
-    endelse
-
-    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
-    sd pixbuf
-    sd ptr_pixbuf^pixbuf
-    call stage_get_sel_pixbuf(ptr_pixbuf)
-
-    import "pixbuf_get_wh" pixbuf_get_wh
-    sd w
-    sd h
-    sd wh^w
-    call pixbuf_get_wh(pixbuf,wh)
-    sd j=0
-    sd red
-    sd green
-    sd blue
-    sd colors^red
-    while j!=h
-        sd i=0
-        while i!=w
-            import "pixbuf_get_pixel" pixbuf_get_pixel
-            import "pixbuf_set_pixel" pixbuf_set_pixel
-            import "rgb_uint_to_colors" rgb_uint_to_colors
-
-            sd pixel
-            setcall pixel pixbuf_get_pixel(pixbuf,i,j)
-            call rgb_uint_to_colors(pixel,colors)
-
-            import "rule3_offset" rule3_offset
-
-            sd end_red
-            sd end_green
-            sd end_blue
-            sd end_colors^end_red
-            import "cpymem" cpymem
-            call cpymem(end_colors,colors,(3*4))
-
-            sd average_color
-            set average_color red
-            add average_color green
-            add average_color blue
-            if average_color!=0
-                div average_color 3
-            endif
-
-            if procedure==(blacken)
-                #sub colors to same level
-                sub end_red average_color
-                sub end_green average_color
-                sub end_blue average_color
-            else
-                #add colors to same level
-                add end_red average_color
-                add end_green average_color
-                add end_blue average_color
-            endelse
-
-            #advance according to horizontal scale
-            setcall red rule3_offset(walked,(brightness_half),red,end_red)
-            setcall green rule3_offset(walked,(brightness_half),green,end_green)
-            setcall blue rule3_offset(walked,(brightness_half),blue,end_blue)
-
-            #correct overflow
-            if procedure==(blacken)
-                if red<0
-                    set red 0
-                endif
-                if green<0
-                    set green 0
-                endif
-                if blue<0
-                    set blue 0
-                endif
-            else
-                if red>0xff
-                    set red 0xff
-                endif
-                if green>0xff
-                    set green 0xff
-                endif
-                if blue>0xff
-                    set blue 0xff
-                endif
-            endelse
-
-            import "rgb_colors_to_uint" rgb_colors_to_uint
-            setcall pixel rgb_colors_to_uint(colors)
-
-            call pixbuf_set_pixel(pixbuf,pixel,i,j)
-            inc i
-        endwhile
-        inc j
-    endwhile
-    import "stage_redraw" stage_redraw
-    call stage_redraw()
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/frame/crop.oc
@@ -0,0 +1,228 @@
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+function stage_crop()
+    import "stage_frame_dialog" stage_frame_dialog
+    ss title="Crop the selection"
+    data init^stage_crop_init
+    data on_ok^stage_crop_set
+    call stage_frame_dialog(init,on_ok,title)
+endfunction
+
+const stage_crop_tool_init=0
+const stage_crop_tool_input=1
+const stage_crop_tool_preview=2
+const stage_crop_tool_set=3
+
+importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
+const action_height=50
+
+function stage_crop_init(sd vbox,sd dialog)
+    sd dlg
+    setcall dlg stage_crop_dialog()
+    set dlg# dialog
+    call stage_crop_tool((stage_crop_tool_init),vbox)
+    importx "_gtk_dialog_get_action_area" gtk_dialog_get_action_area
+    sd abox
+    setcall abox gtk_dialog_get_action_area(dialog)
+    call gtk_widget_set_size_request(abox,-1,(action_height))
+endfunction
+
+function stage_crop_set()
+    call stage_crop_tool((stage_crop_tool_input))
+    call stage_crop_tool((stage_crop_tool_set))
+endfunction
+
+function stage_crop_tool(sd action,sd vbox)
+    if action=(stage_crop_tool_init)
+        import "hboxfield_cnt" hboxfield_cnt
+        sd hbox
+        setcall hbox hboxfield_cnt(vbox)
+
+        import "vboxfield" vboxfield
+        sd dimensions
+        setcall dimensions vboxfield(hbox)
+
+        import "label_and_edit" label_and_edit
+
+        ss left_t="Left: "
+        ss top_t="Top: "
+        ss right_t="Right: "
+        ss bottom_t="Bottom: "
+
+        data left_entry#1
+        data top_entry#1
+        data right_entry#1
+        data bottom_entry#1
+
+        setcall left_entry label_and_edit(dimensions,left_t)
+        setcall top_entry label_and_edit(dimensions,top_t)
+        setcall right_entry label_and_edit(dimensions,right_t)
+        setcall bottom_entry label_and_edit(dimensions,bottom_t)
+
+        import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
+        data pixbuf#1
+        sd p_pixbuf^pixbuf
+        call stage_get_sel_pixbuf(p_pixbuf)
+
+        data width_orig#1
+        data height_orig#1
+
+        importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+        importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+        setcall width_orig gdk_pixbuf_get_width(pixbuf)
+        setcall height_orig gdk_pixbuf_get_height(pixbuf)
+
+        sd text_data#100/4
+        ss text^text_data
+        ss format="%s: %u"
+        ss w="Original Width"
+        ss h="Original Height"
+
+        importx "_gtk_vbox_new" gtk_vbox_new
+        sd origs
+        setcall origs gtk_vbox_new(0,0)
+        import "boxpackstart" boxpackstart
+        call boxpackstart(vbox,origs,0,20)
+
+        importx "_sprintf" sprintf
+        import "labelfield_l" labelfield_l
+
+        call sprintf(text,format,w,width_orig)
+        call labelfield_l(text,origs)
+
+        call sprintf(text,format,h,height_orig)
+        call labelfield_l(text,origs)
+
+        data left#1
+        data top#1
+        data right#1
+        data bottom#1
+        set left 0
+        set top 0
+        set right width_orig
+        set bottom height_orig
+
+        import "buttonfield" buttonfield
+        import "connect_clicked" connect_clicked
+        importx "_gtk_button_set_label" gtk_button_set_label
+
+        sd button
+        setcall button buttonfield(dimensions)
+        ss pre="Preview"
+        call gtk_button_set_label(button,pre)
+        data f^stage_crop_preview
+        call connect_clicked(button,f)
+
+        #the maximize button
+        sd button_max
+        setcall button_max buttonfield(dimensions)
+        ss maximize="Maximize dialog"
+        call gtk_button_set_label(button_max,maximize)
+        data f_max^stage_crop_maximize
+        call connect_clicked(button_max,f_max)
+
+        import "drawfield" drawfield
+        data display#1
+        const p_display^display
+        setcall display drawfield(hbox)
+        call gtk_widget_set_size_request(display,320,240)
+        import "connect_signal" connect_signal
+        str expose="expose-event"
+        data fn^stage_crop_preview_expose
+        call connect_signal(display,expose,fn)
+    elseif action=(stage_crop_tool_input)
+    #preview or set
+        sd value
+        sd p_value^value
+        sd bool
+
+        import "entry_to_int_min_N_max_M" entry_to_int_min_N_max_M
+
+        setcall bool entry_to_int_min_N_max_M(right_entry,p_value,1,width_orig)
+        if bool!=0
+            set right value
+        endif
+        setcall bool entry_to_int_min_N_max_M(bottom_entry,p_value,1,height_orig)
+        if bool!=0
+            set bottom value
+        endif
+        sd max
+        set max right
+        dec max
+        setcall bool entry_to_int_min_N_max_M(left_entry,p_value,0,max)
+        if bool!=0
+            set left value
+        endif
+        set max bottom
+        dec max
+        setcall bool entry_to_int_min_N_max_M(top_entry,p_value,0,max)
+        if bool!=0
+            set top value
+        endif
+    else
+        import "pixbuf_new_subpixels" pixbuf_new_subpixels
+        sd croppixbuf
+        setcall croppixbuf pixbuf_new_subpixels(pixbuf,left,top,right,bottom)
+        if croppixbuf=0
+            return 0
+        endif
+
+        if action=(stage_crop_tool_preview)
+            import "widget_draw_pixbuf" widget_draw_pixbuf
+            call widget_draw_pixbuf(display,croppixbuf)
+            importx "_g_object_unref" g_object_unref
+            call g_object_unref(croppixbuf)
+        else
+        #if action==(stage_crop_tool_set)
+            import "stage_sel_replace_pixbuf" stage_sel_replace_pixbuf
+            call stage_sel_replace_pixbuf(croppixbuf)
+        endelse
+    endelse
+endfunction
+
+function stage_crop_preview(sd *widget,sd *data)
+    call stage_crop_tool((stage_crop_tool_input))
+    import "widget_redraw" widget_redraw
+    sd p%p_display
+    call widget_redraw(p#)
+    call stage_crop_tool((stage_crop_tool_preview))
+endfunction
+
+function stage_crop_preview_expose(sd *draw,sd *event,sd *data)
+    call stage_crop_tool((stage_crop_tool_preview))
+    #false to propagate all actions
+    return 0
+endfunction
+
+function stage_crop_dialog()
+    data dialog#1
+    return #dialog
+endfunction
+
+function stage_crop_maximize()
+    importx "_gtk_window_maximize" gtk_window_maximize
+    sd dlg
+    setcall dlg stage_crop_dialog()
+    sd dialog
+    set dialog dlg#
+    #
+    importx "_gtk_widget_get_window" gtk_widget_get_window
+    sd wind
+    importx "_gdk_window_get_width" gdk_window_get_width
+    importx "_gdk_window_get_height" gdk_window_get_height
+    call gtk_window_maximize(dialog)
+    setcall wind gtk_widget_get_window(dialog)
+    sd w
+    sd h
+    setcall w gdk_window_get_width(wind)
+    setcall h gdk_window_get_height(wind)
+    sub h (action_height)
+    #
+    importx "_gtk_window_resize" gtk_window_resize
+    call gtk_window_resize(dialog,w,h)
+endfunction
--- ovideo-1.orig/src/_prepare/frame/crop.s
+++ /dev/null
@@ -1,228 +0,0 @@
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-function stage_crop()
-    import "stage_frame_dialog" stage_frame_dialog
-    ss title="Crop the selection"
-    data init^stage_crop_init
-    data on_ok^stage_crop_set
-    call stage_frame_dialog(init,on_ok,title)
-endfunction
-
-const stage_crop_tool_init=0
-const stage_crop_tool_input=1
-const stage_crop_tool_preview=2
-const stage_crop_tool_set=3
-
-importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
-const action_height=50
-
-function stage_crop_init(sd vbox,sd dialog)
-    sd dlg
-    setcall dlg stage_crop_dialog()
-    set dlg# dialog
-    call stage_crop_tool((stage_crop_tool_init),vbox)
-    importx "_gtk_dialog_get_action_area" gtk_dialog_get_action_area
-    sd abox
-    setcall abox gtk_dialog_get_action_area(dialog)
-    call gtk_widget_set_size_request(abox,-1,(action_height))
-endfunction
-
-function stage_crop_set()
-    call stage_crop_tool((stage_crop_tool_input))
-    call stage_crop_tool((stage_crop_tool_set))
-endfunction
-
-function stage_crop_tool(sd action,sd vbox)
-    if action==(stage_crop_tool_init)
-        import "hboxfield_cnt" hboxfield_cnt
-        sd hbox
-        setcall hbox hboxfield_cnt(vbox)
-
-        import "vboxfield" vboxfield
-        sd dimensions
-        setcall dimensions vboxfield(hbox)
-
-        import "label_and_edit" label_and_edit
-
-        ss left_t="Left: "
-        ss top_t="Top: "
-        ss right_t="Right: "
-        ss bottom_t="Bottom: "
-
-        data left_entry#1
-        data top_entry#1
-        data right_entry#1
-        data bottom_entry#1
-
-        setcall left_entry label_and_edit(dimensions,left_t)
-        setcall top_entry label_and_edit(dimensions,top_t)
-        setcall right_entry label_and_edit(dimensions,right_t)
-        setcall bottom_entry label_and_edit(dimensions,bottom_t)
-
-        import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
-        data pixbuf#1
-        sd p_pixbuf^pixbuf
-        call stage_get_sel_pixbuf(p_pixbuf)
-
-        data width_orig#1
-        data height_orig#1
-
-        importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-        importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-        setcall width_orig gdk_pixbuf_get_width(pixbuf)
-        setcall height_orig gdk_pixbuf_get_height(pixbuf)
-
-        sd text_data#100/4
-        ss text^text_data
-        ss format="%s: %u"
-        ss w="Original Width"
-        ss h="Original Height"
-
-        importx "_gtk_vbox_new" gtk_vbox_new
-        sd origs
-        setcall origs gtk_vbox_new(0,0)
-        import "boxpackstart" boxpackstart
-        call boxpackstart(vbox,origs,0,20)
-
-        importx "_sprintf" sprintf
-        import "labelfield_l" labelfield_l
-
-        call sprintf(text,format,w,width_orig)
-        call labelfield_l(text,origs)
-
-        call sprintf(text,format,h,height_orig)
-        call labelfield_l(text,origs)
-
-        data left#1
-        data top#1
-        data right#1
-        data bottom#1
-        set left 0
-        set top 0
-        set right width_orig
-        set bottom height_orig
-
-        import "buttonfield" buttonfield
-        import "connect_clicked" connect_clicked
-        importx "_gtk_button_set_label" gtk_button_set_label
-
-        sd button
-        setcall button buttonfield(dimensions)
-        ss pre="Preview"
-        call gtk_button_set_label(button,pre)
-        data f^stage_crop_preview
-        call connect_clicked(button,f)
-
-        #the maximize button
-        sd button_max
-        setcall button_max buttonfield(dimensions)
-        ss maximize="Maximize dialog"
-        call gtk_button_set_label(button_max,maximize)
-        data f_max^stage_crop_maximize
-        call connect_clicked(button_max,f_max)
-
-        import "drawfield" drawfield
-        data display#1
-        const p_display^display
-        setcall display drawfield(hbox)
-        call gtk_widget_set_size_request(display,320,240)
-        import "connect_signal" connect_signal
-        str expose="expose-event"
-        data fn^stage_crop_preview_expose
-        call connect_signal(display,expose,fn)
-    elseif action==(stage_crop_tool_input)
-    #preview or set
-        sd value
-        sd p_value^value
-        sd bool
-
-        import "entry_to_int_min_N_max_M" entry_to_int_min_N_max_M
-
-        setcall bool entry_to_int_min_N_max_M(right_entry,p_value,1,width_orig)
-        if bool!=0
-            set right value
-        endif
-        setcall bool entry_to_int_min_N_max_M(bottom_entry,p_value,1,height_orig)
-        if bool!=0
-            set bottom value
-        endif
-        sd max
-        set max right
-        dec max
-        setcall bool entry_to_int_min_N_max_M(left_entry,p_value,0,max)
-        if bool!=0
-            set left value
-        endif
-        set max bottom
-        dec max
-        setcall bool entry_to_int_min_N_max_M(top_entry,p_value,0,max)
-        if bool!=0
-            set top value
-        endif
-    else
-        import "pixbuf_new_subpixels" pixbuf_new_subpixels
-        sd croppixbuf
-        setcall croppixbuf pixbuf_new_subpixels(pixbuf,left,top,right,bottom)
-        if croppixbuf==0
-            return 0
-        endif
-
-        if action==(stage_crop_tool_preview)
-            import "widget_draw_pixbuf" widget_draw_pixbuf
-            call widget_draw_pixbuf(display,croppixbuf)
-            importx "_g_object_unref" g_object_unref
-            call g_object_unref(croppixbuf)
-        else
-        #if action==(stage_crop_tool_set)
-            import "stage_sel_replace_pixbuf" stage_sel_replace_pixbuf
-            call stage_sel_replace_pixbuf(croppixbuf)
-        endelse
-    endelse
-endfunction
-
-function stage_crop_preview(sd *widget,sd *data)
-    call stage_crop_tool((stage_crop_tool_input))
-    import "widget_redraw" widget_redraw
-    sd p%p_display
-    call widget_redraw(p#)
-    call stage_crop_tool((stage_crop_tool_preview))
-endfunction
-
-function stage_crop_preview_expose(sd *draw,sd *event,sd *data)
-    call stage_crop_tool((stage_crop_tool_preview))
-    #false to propagate all actions
-    return 0
-endfunction
-
-function stage_crop_dialog()
-    data dialog#1
-    return #dialog
-endfunction
-
-function stage_crop_maximize()
-    importx "_gtk_window_maximize" gtk_window_maximize
-    sd dlg
-    setcall dlg stage_crop_dialog()
-    sd dialog
-    set dialog dlg#
-    #
-    importx "_gtk_widget_get_window" gtk_widget_get_window
-    sd wind
-    importx "_gdk_window_get_width" gdk_window_get_width
-    importx "_gdk_window_get_height" gdk_window_get_height
-    call gtk_window_maximize(dialog)
-    setcall wind gtk_widget_get_window(dialog)
-    sd w
-    sd h
-    setcall w gdk_window_get_width(wind)
-    setcall h gdk_window_get_height(wind)
-    sub h (action_height)
-    #
-    importx "_gtk_window_resize" gtk_window_resize
-    call gtk_window_resize(dialog,w,h)
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/frame/frame.oc
@@ -0,0 +1,121 @@
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+
+function stage_frame_panel(sd action,sd button,sd backfn,sd panel)
+    data openbutton#1
+    data backfunction#1
+
+    data panelwidget#1
+
+    if action=(buttons_panel_open)
+        set openbutton button
+        set panelwidget panel
+        set backfunction backfn
+    else
+    #if action==(buttons_panel_close)
+        importx "_gtk_widget_destroy" gtk_widget_destroy
+        call gtk_widget_destroy(panelwidget)
+        import "connect_signal" connect_signal
+        str click="clicked"
+        call connect_signal(openbutton,click,backfunction)
+    endelse
+endfunction
+function stage_frame_panel_open(sd button,sd *user_data)
+    import "img_edit_folder_enterleave_data" img_edit_folder_enterleave_data
+    data f^stage_frame_panel_open_fn
+    sd p_data^button
+    call img_edit_folder_enterleave_data(f,p_data)
+endfunction
+function stage_frame_panel_open_fn(sd p_data)
+    sd button
+    sd user_data
+    set button p_data#
+    add p_data 4
+    set user_data p_data#
+
+    import "stage_save_img" stage_save_img
+    char frame_lot="img.bmp"
+    char *="Save the current selection to a file"
+    data *^stage_save_img
+    #
+    import "stage_add_centered" stage_add_centered
+    char *="addcenter.bmp"
+    char *="Add an image scaled and centered on the selected frame"
+    data *^stage_add_centered
+    #
+    import "stage_color_under_image" stage_color_under_image
+    char *="addmargins.bmp"
+    char *="Create an image selecting width,height and color, then place over it the selected frame scaled and centered"
+    data *^stage_color_under_image
+    #
+    import "stage_scale_img" stage_scale_img
+    char *="scale.bmp"
+    char *="Scale the selection to new values"
+    data *^stage_scale_img
+    #
+    import "stage_crop" stage_crop
+    char *="crop.bmp"
+    char *="Crop the selection"
+    data *^stage_crop
+    #
+    import "stage_pencil" stage_pencil
+    char *="pencil.bmp"
+    char *="Pencil tool"
+    data *^stage_pencil
+    #
+    import "stage_screenshot" stage_screenshot
+    char *="screenshot.bmp"
+    char *="Print screen and add to stage button"
+    data *^stage_screenshot
+    #
+    import "stage_brightness" stage_brightness
+    char *="bright.bmp"
+    char *="Brighten or darken the selection"
+    data *^stage_brightness
+    #
+    import "stage_overlay" stage_overlay
+    char *="overlay.bmp"
+    char *="Add an image over selection"
+    data *^stage_overlay
+    #
+    import "stage_rotate_left" stage_rotate_left
+    char *="rotateleft.bmp"
+    char *="Rotate the selection 90 degrees at left"
+    data *^stage_rotate_left
+    #
+    import "stage_rotate_right" stage_rotate_right
+    char *="rotateright.bmp"
+    char *="Rotate the selection 90 degrees at right"
+    data *^stage_rotate_right
+    #
+    import "headline_dialog" headline_dialog
+    char *="headline.bmp"
+    char *="Draw headline text"
+    data *^headline_dialog
+    #
+    import "stage_lines" stage_lines
+    char *="resize.bmp"
+    char *="Add/Remove rows or columns at sides at all stage images"
+    data *^stage_lines
+    #
+    data *=0
+    #
+    data *=0
+    #
+    data lots^frame_lot
+
+    import "stage_new_panel" stage_new_panel
+    sd newpanel
+    data f^stage_frame_panel_open
+    data closef^stage_frame_panel_close
+    setcall newpanel stage_new_panel(lots,button,f,user_data,closef)
+
+    call stage_frame_panel((buttons_panel_open),button,f,newpanel)
+endfunction
+function stage_frame_panel_close()
+    call stage_frame_panel((buttons_panel_close))
+endfunction
--- ovideo-1.orig/src/_prepare/frame/frame.s
+++ /dev/null
@@ -1,121 +0,0 @@
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-
-function stage_frame_panel(sd action,sd button,sd backfn,sd panel)
-    data openbutton#1
-    data backfunction#1
-
-    data panelwidget#1
-
-    if action==(buttons_panel_open)
-        set openbutton button
-        set panelwidget panel
-        set backfunction backfn
-    else
-    #if action==(buttons_panel_close)
-        importx "_gtk_widget_destroy" gtk_widget_destroy
-        call gtk_widget_destroy(panelwidget)
-        import "connect_signal" connect_signal
-        str click="clicked"
-        call connect_signal(openbutton,click,backfunction)
-    endelse
-endfunction
-function stage_frame_panel_open(sd button,sd *user_data)
-    import "img_edit_folder_enterleave_data" img_edit_folder_enterleave_data
-    data f^stage_frame_panel_open_fn
-    sd p_data^button
-    call img_edit_folder_enterleave_data(f,p_data)
-endfunction
-function stage_frame_panel_open_fn(sd p_data)
-    sd button
-    sd user_data
-    set button p_data#
-    add p_data 4
-    set user_data p_data#
-
-    import "stage_save_img" stage_save_img
-    char frame_lot="img.bmp"
-    char *="Save the current selection to a file"
-    data *^stage_save_img
-    #
-    import "stage_add_centered" stage_add_centered
-    char *="addcenter.bmp"
-    char *="Add an image scaled and centered on the selected frame"
-    data *^stage_add_centered
-    #
-    import "stage_color_under_image" stage_color_under_image
-    char *="addmargins.bmp"
-    char *="Create an image selecting width,height and color, then place over it the selected frame scaled and centered"
-    data *^stage_color_under_image
-    #
-    import "stage_scale_img" stage_scale_img
-    char *="scale.bmp"
-    char *="Scale the selection to new values"
-    data *^stage_scale_img
-    #
-    import "stage_crop" stage_crop
-    char *="crop.bmp"
-    char *="Crop the selection"
-    data *^stage_crop
-    #
-    import "stage_pencil" stage_pencil
-    char *="pencil.bmp"
-    char *="Pencil tool"
-    data *^stage_pencil
-    #
-    import "stage_screenshot" stage_screenshot
-    char *="screenshot.bmp"
-    char *="Print screen and add to stage button"
-    data *^stage_screenshot
-    #
-    import "stage_brightness" stage_brightness
-    char *="bright.bmp"
-    char *="Brighten or darken the selection"
-    data *^stage_brightness
-    #
-    import "stage_overlay" stage_overlay
-    char *="overlay.bmp"
-    char *="Add an image over selection"
-    data *^stage_overlay
-    #
-    import "stage_rotate_left" stage_rotate_left
-    char *="rotateleft.bmp"
-    char *="Rotate the selection 90 degrees at left"
-    data *^stage_rotate_left
-    #
-    import "stage_rotate_right" stage_rotate_right
-    char *="rotateright.bmp"
-    char *="Rotate the selection 90 degrees at right"
-    data *^stage_rotate_right
-    #
-    import "headline_dialog" headline_dialog
-    char *="headline.bmp"
-    char *="Draw headline text"
-    data *^headline_dialog
-    #
-    import "stage_lines" stage_lines
-    char *="resize.bmp"
-    char *="Add/Remove rows or columns at sides at all stage images"
-    data *^stage_lines
-    #
-    data *=0
-    #
-    data *=0
-    #
-    data lots^frame_lot
-
-    import "stage_new_panel" stage_new_panel
-    sd newpanel
-    data f^stage_frame_panel_open
-    data closef^stage_frame_panel_close
-    setcall newpanel stage_new_panel(lots,button,f,user_data,closef)
-
-    call stage_frame_panel((buttons_panel_open),button,f,newpanel)
-endfunction
-function stage_frame_panel_close()
-    call stage_frame_panel((buttons_panel_close))
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/frame/frametime.oc
@@ -0,0 +1,535 @@
+
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+function stage_frame_time()
+    import "stage_get_sel" stage_get_sel
+    sd img
+    setcall img stage_get_sel()
+    if img=0
+        return 0
+    endif
+
+    import "dialogfield" dialogfield
+    ss title="Frame time length"
+    data init^stage_frame_time_init
+    data do^stage_frame_time_set
+    call dialogfield(title,(GTK_DIALOG_MODAL),init,do)
+endfunction
+
+import "stage_get_sel_parent" stage_get_sel_parent
+
+function stage_frame_time_init(sd vbox,sd *dialog)
+    import "hboxfield_cnt" hboxfield_cnt
+    sd hbox
+    setcall hbox hboxfield_cnt(vbox)
+
+    import "labelfield_l" labelfield_l
+    ss text="Frame length: "
+    call labelfield_l(text,hbox)
+    import "editfield_pack" editfield_pack
+    data number#1
+    const ptr_number^number
+    setcall number editfield_pack(hbox)
+
+    #get the position of the current frame and the length
+    sd container
+    sd ptr_container^container
+    call stage_get_sel_parent(ptr_container)
+    sd length
+    setcall length stage_get_fr_length(container)
+
+    #convert to string and set to edit
+    char nr#dword_null
+    str ptr_nr^nr
+    importx "_sprintf" sprintf
+    ss dw="%u"
+    call sprintf(ptr_nr,dw,length)
+    importx "_gtk_entry_set_text" gtk_entry_set_text
+    call gtk_entry_set_text(number,ptr_nr)
+endfunction
+import "stage_frame_index" stage_frame_index
+import "stage_sel_img_set" stage_sel_img_set
+function stage_frame_time_set()
+    data edit%ptr_number
+    importx "_gtk_entry_get_text" gtk_entry_get_text
+    ss text
+    setcall text gtk_entry_get_text(edit#)
+
+    import "strtoint_positive_not_zero" strtoint_positive_not_zero
+    sd value
+    sd ptr_value^value
+    sd bool
+    setcall bool strtoint_positive_not_zero(text,ptr_value)
+    if bool=0
+        return 0
+    endif
+
+    sd container
+    sd ptr_container^container
+    call stage_get_sel_parent(ptr_container)
+    sd pos
+    setcall pos stage_frame_index(container)
+    call stage_frame_time_numbers((stage_frame_time_set_frame_length),pos,value)
+    call stage_sel_img_set(container)
+    import "stage_display_info" stage_display_info
+    call stage_display_info(container)
+endfunction
+
+#method is defined at olang.h
+
+function stage_frame_time_numbers(sd method,sd index,sd newvalue,sd numberoftimes)
+	if method=(stage_frame_time_init)
+        #const stage_frame_time_init=0
+        data frames#1
+        data size#1
+        data ptr_frames^frames
+        set size 0
+        set frames 0
+        return 1
+	endif
+	if method=(stage_frame_time_append)
+        #const stage_frame_time_append=1
+        import "memoryrealloc" memoryrealloc
+        add size 4
+        sd err
+        setcall err memoryrealloc(ptr_frames,size)
+        if err=(noerror)
+            sd pointer
+            set pointer frames
+            add pointer size
+            sub pointer 4
+            set pointer# index
+        endif
+        return 1
+	endif
+	if method=(stage_frame_time_free)
+        #const stage_frame_time_free=2
+        importx "_free" free
+        if frames!=0
+            call free(frames)
+        endif
+        return 1
+	endif
+	if method=(stage_frame_time_get_at_index)
+    #get the index from the created database
+        mult index 4
+        if index>=size
+            return 1
+        endif
+        sd value
+        set value frames
+        add value index
+        return value#
+	endif
+	if method=(stage_frame_time_set_frame_length)
+    #modify a frame length
+        mult index 4
+        if index>=size
+            return 1
+        endif
+        sd loc
+        set loc frames
+        add loc index
+        set loc# newvalue
+        return 1
+	endif
+	if method=(stage_frame_time_insert)
+    #insert at index newvalue and numberoftimes
+        sd newzone
+        set newzone numberoftimes
+        mult newzone 4
+        add size newzone
+        setcall err memoryrealloc(ptr_frames,size)
+        if err=(noerror)
+            #take cursor for adding frames
+            sd walker
+            set walker index
+            mult walker 4
+            add walker frames
+            #
+            sd dest
+            set dest frames
+            add dest size
+            sd cursor
+            set cursor dest
+            sub cursor newzone
+
+            sd blocksize
+            set blocksize cursor
+            sub blocksize walker
+            while blocksize!=0
+                sub dest 4
+                sub cursor 4
+                set dest# cursor#
+                sub blocksize 4
+            endwhile
+            while newzone!=0
+                set walker# newvalue
+                add walker 4
+                sub newzone 4
+            endwhile
+        endif
+        return 1
+	endif
+	if method=(stage_frame_time_delete_frame)
+    #a frame was deleted
+        mult index 4
+        if index>=size
+            return 1
+        endif
+
+        sd mem_src_cursor
+        sd mem_dest_cursor
+        set mem_src_cursor frames
+        set mem_dest_cursor frames
+
+        add mem_dest_cursor index
+        add index 4
+        add mem_src_cursor index
+
+        while index!=size
+            set mem_dest_cursor# mem_src_cursor#
+            add mem_src_cursor 4
+            add mem_dest_cursor 4
+            add index 4
+        endwhile
+        sub size 4
+        return 1
+	endif
+	if method=(stage_frame_time_sum_at_index)
+    #length at pos returned
+        mult index 4
+        if index>=size
+            return 0
+        endif
+
+        sd frames_cursor
+        set frames_cursor frames
+        add frames_cursor index
+        sd length_at_pos=0
+        while index!=0
+            sub frames_cursor 4
+            add length_at_pos frames_cursor#
+            sub index 4
+        endwhile
+        return length_at_pos
+	endif
+    #if method==(stage_frame_time_total_sum)
+    #total length returned
+        sd frames_pointer
+        set frames_pointer frames
+        add frames_pointer size
+        sd total_length=0
+        while frames_pointer!=frames
+            sub frames_pointer 4
+            add total_length frames_pointer#
+        endwhile
+        return total_length
+endfunction
+
+
+#length of the stage eventbox
+function stage_get_fr_length(sd eventbox)
+    sd pos
+    setcall pos stage_frame_index(eventbox)
+    sd length
+    setcall length stage_frame_time_numbers((stage_frame_time_get_at_index),pos)
+    return length
+endfunction
+
+#length of the stage sel
+function stage_get_sel_fr_length()
+    sd container
+    sd ptr_container^container
+    call stage_get_sel_parent(ptr_container)
+    sd length
+    setcall length stage_get_fr_length(container)
+    return length
+endfunction
+
+const frame_unit_red=0xff
+const frame_unit_green=0
+const frame_unit_blue=0
+
+import "stage_sel_framebar_pixbuf" stage_sel_framebar_pixbuf
+importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+
+function stage_split_frame()
+    sd framebarpixbuf
+    setcall framebarpixbuf stage_sel_framebar_pixbuf()
+    if framebarpixbuf=0
+        return 0
+    endif
+
+    import "stage_get_sel_pos" stage_get_sel_pos
+    sd pos
+    setcall pos stage_get_sel_pos()
+    sd length
+    setcall length stage_frame_time_numbers((stage_frame_time_get_at_index),pos)
+
+    if length=1
+        import "texter" texter
+        ss lengthlow="Frame length must be greater than 1."
+        call texter(lengthlow)
+        return 0
+    endif
+
+    sd pixels
+    setcall pixels gdk_pixbuf_get_pixels(framebarpixbuf)
+    sd terminator
+    setcall terminator gdk_pixbuf_get_width(framebarpixbuf)
+
+    sd unit_size
+    set unit_size terminator
+    div unit_size length
+
+    mult terminator 3
+    add terminator pixels
+    sd cursor
+    set cursor pixels
+    sd noselection=0
+    #find the selected unit position
+    while cursor!=terminator
+        char unit_color_data={frame_unit_red,frame_unit_green,frame_unit_blue}
+        str unit_color^unit_color_data
+        import "cmpmem" cmpmem
+        sd memcmp
+        setcall memcmp cmpmem(cursor,unit_color,3)
+        if memcmp=(equalCompare)
+            sub cursor pixels
+            div cursor 3
+            set terminator cursor
+            set noselection 1
+        else
+            add cursor 3
+        endelse
+    endwhile
+
+    if noselection=0
+        str selerr="Press on the selection to create a frame slot."
+        call texter(selerr)
+        return 0
+    endif
+
+    div cursor unit_size
+    if cursor=0
+        str notatzero="Split the selection not from the first frame."
+        call texter(notatzero)
+        return 0
+    endif
+
+    #rearrange the previous part
+    #frame length
+    call stage_frame_time_numbers((stage_frame_time_set_frame_length),pos,cursor)
+    import "stage_new_click_area" stage_new_click_area
+    #frames container
+    import "stage_get_frames_container" stage_get_frames_container
+    sd box
+    setcall box stage_get_frames_container()
+    #frame objects
+    sd ebox
+    setcall ebox stage_new_click_area()
+    importx "_gtk_box_reorder_child" gtk_box_reorder_child
+    call gtk_box_reorder_child(box,ebox,pos)
+    #pixbuf to previous
+    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
+    sd pix
+    sd p_pix^pix
+    call stage_get_sel_pixbuf(p_pix)
+    import "pixbuf_copy" pixbuf_copy
+    sd prevpx
+    setcall prevpx pixbuf_copy(pix)
+    import "stage_pixbuf_to_container" stage_pixbuf_to_container
+    call stage_pixbuf_to_container(prevpx,ebox)
+
+    inc pos
+    sub length cursor
+    #new length for selection
+    call stage_frame_time_numbers((stage_frame_time_insert),pos,length,1)
+
+    #show at framebar the new length and show info about the new number of frames
+    sd ev
+    sd p_ev^ev
+    call stage_get_sel_parent(p_ev)
+    call stage_sel_img_set(ev)
+    call stage_display_info(ev)
+endfunction
+
+function stage_frame_unit_select(sd widget,sd event)
+    import "eventbutton_get_coords" eventbutton_get_coords
+    sd mouse_x
+    setcall mouse_x eventbutton_get_coords(event,0)
+
+    sd pixbuf
+
+    setcall pixbuf stage_sel_framebar_pixbuf()
+    sd length
+    setcall length stage_get_fr_length(widget)
+    sd width
+    setcall width gdk_pixbuf_get_width(pixbuf)
+    sd unit
+    set unit width
+    div unit length
+    div mouse_x unit
+    mult mouse_x unit
+
+    sd cursor1
+    sd cursor2
+
+    set cursor1 mouse_x
+    mult cursor1 3
+    addcall cursor1 gdk_pixbuf_get_pixels(pixbuf)
+
+    sd startpoint
+    set startpoint cursor1
+
+    set cursor2 unit
+    dec cursor2
+    mult cursor2 3
+    add cursor2 cursor1
+
+    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+    importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
+
+    sd height
+    setcall height gdk_pixbuf_get_height(pixbuf)
+    sd rowstride
+    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
+    import "color_pixel" color_pixel
+    while height!=0
+        call color_pixel((frame_unit_red),(frame_unit_green),(frame_unit_blue),cursor1)
+        call color_pixel((frame_unit_red),(frame_unit_green),(frame_unit_blue),cursor2)
+        add cursor1 rowstride
+        add cursor2 rowstride
+        dec height
+    endwhile
+    sub cursor1 rowstride
+    set cursor2 startpoint
+    while unit!=0
+        call color_pixel((frame_unit_red),(frame_unit_green),(frame_unit_blue),cursor1)
+        call color_pixel((frame_unit_red),(frame_unit_green),(frame_unit_blue),cursor2)
+        add cursor1 3
+        add cursor2 3
+        dec unit
+    endwhile
+endfunction
+
+#equalize
+
+function stage_frame_equalize()
+    import "stage_frame_dialog" stage_frame_dialog
+    data init^stage_frame_equalize_init
+    data on_ok^stage_frame_equalize_set
+    ss title="Equalize"
+    call stage_frame_dialog(init,on_ok,title)
+endfunction
+
+function stage_frame_equalize_edit(sd action,sd value)
+    data equalize_edit#1
+    if action=(value_set)
+        set equalize_edit value
+    else
+        return equalize_edit
+    endelse
+endfunction
+
+function stage_frame_equalize_init(sd vbox)
+    import "label_and_edit" label_and_edit
+    ss txt="Frame length "
+    sd edit
+    setcall edit label_and_edit(vbox,txt)
+    call stage_frame_equalize_edit((value_set),edit)
+endfunction
+
+function stage_frame_equalize_set()
+    #get the number
+    import "entry_to_int_min_N" entry_to_int_min_N
+    sd entry
+    setcall entry stage_frame_equalize_edit((value_get))
+    sd nr
+    sd p_nr^nr
+    sd bool
+    setcall bool entry_to_int_min_N(entry,p_nr,1)
+    if bool!=1
+        return 0
+    endif
+
+    #get sel pos
+    sd selpos
+    setcall selpos stage_get_sel_pos()
+
+    #calculate if equalization is possible
+    import "stage_get_frames" stage_get_frames
+    sd totalframes
+    setcall totalframes stage_get_frames()
+    sd equalization_end_frame
+    set equalization_end_frame selpos
+    sd dif=0
+    sd prev
+    sd can_be_truncation
+    sd loop=1
+    while loop=1
+        sd framelength
+        setcall framelength stage_frame_time_numbers((stage_frame_time_get_at_index),equalization_end_frame)
+        sub framelength nr
+        add dif framelength
+        set can_be_truncation nr
+        if dif=0
+            set loop 0
+        else
+            #test to truncate last equalization frame
+            sd sign_dif
+            set sign_dif dif
+            and sign_dif 0x80000000
+            if selpos!=equalization_end_frame
+                if sign_dif!=prev
+                    if dif<0
+                        mult dif -1
+                    endif
+                    sub can_be_truncation dif
+                    set loop 0
+                endif
+            endif
+            if loop!=0
+                set prev sign_dif
+
+                inc equalization_end_frame
+                if equalization_end_frame=totalframes
+                    str not_possible="Equalization not possible with the specified number"
+                    call texter(not_possible)
+                    return 0
+                endif
+            endif
+        endelse
+    endwhile
+    while selpos!=equalization_end_frame
+        call set_frame_length_and_redraw(selpos,nr)
+        inc selpos
+    endwhile
+    call set_frame_length_and_redraw(selpos,can_be_truncation)
+endfunction
+
+function set_frame_length_and_redraw(sd pos,sd nr)
+    call stage_frame_time_numbers((stage_frame_time_set_frame_length),pos,nr)
+    #display
+    import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
+    sd ebox
+    setcall ebox stage_nthwidgetFromcontainer(pos)
+    sd selpos
+    setcall selpos stage_get_sel_pos()
+    if selpos=pos
+        import "stage_sel_img" stage_sel_img
+        call stage_sel_img(ebox)
+    else
+        import "stage_unselected_frame" stage_unselected_frame
+        call stage_unselected_frame(ebox)
+    endelse
+    importx "_gtk_widget_show_all" gtk_widget_show_all
+    call gtk_widget_show_all(ebox)
+endfunction
--- ovideo-1.orig/src/_prepare/frame/frametime.s
+++ /dev/null
@@ -1,531 +0,0 @@
-
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-function stage_frame_time()
-    import "stage_get_sel" stage_get_sel
-    sd img
-    setcall img stage_get_sel()
-    if img==0
-        return 0
-    endif
-
-    import "dialogfield" dialogfield
-    ss title="Frame time length"
-    data init^stage_frame_time_init
-    data do^stage_frame_time_set
-    call dialogfield(title,(GTK_DIALOG_MODAL),init,do)
-endfunction
-
-import "stage_get_sel_parent" stage_get_sel_parent
-
-function stage_frame_time_init(sd vbox,sd *dialog)
-    import "hboxfield_cnt" hboxfield_cnt
-    sd hbox
-    setcall hbox hboxfield_cnt(vbox)
-
-    import "labelfield_l" labelfield_l
-    ss text="Frame length: "
-    call labelfield_l(text,hbox)
-    import "editfield_pack" editfield_pack
-    data number#1
-    const ptr_number^number
-    setcall number editfield_pack(hbox)
-
-    #get the position of the current frame and the length
-    sd container
-    sd ptr_container^container
-    call stage_get_sel_parent(ptr_container)
-    sd length
-    setcall length stage_get_fr_length(container)
-
-    #convert to string and set to edit
-    char nr#dword_null
-    str ptr_nr^nr
-    importx "_sprintf" sprintf
-    ss dw="%u"
-    call sprintf(ptr_nr,dw,length)
-    importx "_gtk_entry_set_text" gtk_entry_set_text
-    call gtk_entry_set_text(number,ptr_nr)
-endfunction
-import "stage_frame_index" stage_frame_index
-import "stage_sel_img_set" stage_sel_img_set
-function stage_frame_time_set()
-    data edit%ptr_number
-    importx "_gtk_entry_get_text" gtk_entry_get_text
-    ss text
-    setcall text gtk_entry_get_text(edit#)
-
-    import "strtoint_positive_not_zero" strtoint_positive_not_zero
-    sd value
-    sd ptr_value^value
-    sd bool
-    setcall bool strtoint_positive_not_zero(text,ptr_value)
-    if bool==0
-        return 0
-    endif
-
-    sd container
-    sd ptr_container^container
-    call stage_get_sel_parent(ptr_container)
-    sd pos
-    setcall pos stage_frame_index(container)
-    call stage_frame_time_numbers((stage_frame_time_set_frame_length),pos,value)
-    call stage_sel_img_set(container)
-    import "stage_display_info" stage_display_info
-    call stage_display_info(container)
-endfunction
-
-#method is defined at olang.h
-
-function stage_frame_time_numbers(sd method,sd arg1,sd newvalue,sd numberoftimes)
-    sd index
-    set index arg1
-    if method==(stage_frame_time_init)
-        #const stage_frame_time_init=0
-        data frames#1
-        data size#1
-        data ptr_frames^frames
-        set size 0
-        set frames 0
-        return 1
-    elseif method==(stage_frame_time_append)
-        #const stage_frame_time_append=1
-        import "memoryrealloc" memoryrealloc
-        add size 4
-        sd err
-        setcall err memoryrealloc(ptr_frames,size)
-        if err==(noerror)
-            sd pointer
-            set pointer frames
-            add pointer size
-            sub pointer 4
-            set pointer# arg1
-        endif
-        return 1
-    elseif method==(stage_frame_time_free)
-        #const stage_frame_time_free=2
-        importx "_free" free
-        if frames!=0
-            call free(frames)
-        endif
-        return 1
-    elseif method==(stage_frame_time_get_at_index)
-    #get the index from the created database
-        mult index 4
-        if index>=size
-            return 1
-        endif
-        sd value
-        set value frames
-        add value index
-        return value#
-    elseif method==(stage_frame_time_set_frame_length)
-    #modify a frame length
-        mult index 4
-        if index>=size
-            return 1
-        endif
-        sd loc
-        set loc frames
-        add loc index
-        set loc# newvalue
-        return 1
-    elseif method==(stage_frame_time_insert)
-    #insert at index newvalue and numberoftimes
-        sd newzone
-        set newzone numberoftimes
-        mult newzone 4
-        add size newzone
-        setcall err memoryrealloc(ptr_frames,size)
-        if err==(noerror)
-            #take cursor for adding frames
-            sd walker
-            set walker index
-            mult walker 4
-            add walker frames
-            #
-            sd dest
-            set dest frames
-            add dest size
-            sd cursor
-            set cursor dest
-            sub cursor newzone
-
-            sd blocksize
-            set blocksize cursor
-            sub blocksize walker
-            while blocksize!=0
-                sub dest 4
-                sub cursor 4
-                set dest# cursor#
-                sub blocksize 4
-            endwhile
-            while newzone!=0
-                set walker# newvalue
-                add walker 4
-                sub newzone 4
-            endwhile
-        endif
-        return 1
-    elseif method==(stage_frame_time_delete_frame)
-    #a frame was deleted
-        mult index 4
-        if index>=size
-            return 1
-        endif
-
-        sd mem_src_cursor
-        sd mem_dest_cursor
-        set mem_src_cursor frames
-        set mem_dest_cursor frames
-
-        add mem_dest_cursor index
-        add index 4
-        add mem_src_cursor index
-
-        while index!=size
-            set mem_dest_cursor# mem_src_cursor#
-            add mem_src_cursor 4
-            add mem_dest_cursor 4
-            add index 4
-        endwhile
-        sub size 4
-        return 1
-    elseif method==(stage_frame_time_sum_at_index)
-    #length at pos returned
-        mult index 4
-        if index>=size
-            return 0
-        endif
-
-        sd frames_cursor
-        set frames_cursor frames
-        add frames_cursor index
-        sd length_at_pos=0
-        while index!=0
-            sub frames_cursor 4
-            add length_at_pos frames_cursor#
-            sub index 4
-        endwhile
-        return length_at_pos
-    else
-    #if method==(stage_frame_time_total_sum)
-    #total length returned
-        sd frames_pointer
-        set frames_pointer frames
-        add frames_pointer size
-        sd total_length=0
-        while frames_pointer!=frames
-            sub frames_pointer 4
-            add total_length frames_pointer#
-        endwhile
-        return total_length
-    endelse
-endfunction
-
-
-#length of the stage eventbox
-function stage_get_fr_length(sd eventbox)
-    sd pos
-    setcall pos stage_frame_index(eventbox)
-    sd length
-    setcall length stage_frame_time_numbers((stage_frame_time_get_at_index),pos)
-    return length
-endfunction
-
-#length of the stage sel
-function stage_get_sel_fr_length()
-    sd container
-    sd ptr_container^container
-    call stage_get_sel_parent(ptr_container)
-    sd length
-    setcall length stage_get_fr_length(container)
-    return length
-endfunction
-
-const frame_unit_red=0xff
-const frame_unit_green=0
-const frame_unit_blue=0
-
-import "stage_sel_framebar_pixbuf" stage_sel_framebar_pixbuf
-importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-
-function stage_split_frame()
-    sd framebarpixbuf
-    setcall framebarpixbuf stage_sel_framebar_pixbuf()
-    if framebarpixbuf==0
-        return 0
-    endif
-
-    import "stage_get_sel_pos" stage_get_sel_pos
-    sd pos
-    setcall pos stage_get_sel_pos()
-    sd length
-    setcall length stage_frame_time_numbers((stage_frame_time_get_at_index),pos)
-
-    if length==1
-        import "texter" texter
-        ss lengthlow="Frame length must be greater than 1."
-        call texter(lengthlow)
-        return 0
-    endif
-
-    sd pixels
-    setcall pixels gdk_pixbuf_get_pixels(framebarpixbuf)
-    sd terminator
-    setcall terminator gdk_pixbuf_get_width(framebarpixbuf)
-
-    sd unit_size
-    set unit_size terminator
-    div unit_size length
-
-    mult terminator 3
-    add terminator pixels
-    sd cursor
-    set cursor pixels
-    sd noselection=0
-    #find the selected unit position
-    while cursor!=terminator
-        char unit_color_data={frame_unit_red,frame_unit_green,frame_unit_blue}
-        str unit_color^unit_color_data
-        import "cmpmem" cmpmem
-        sd memcmp
-        setcall memcmp cmpmem(cursor,unit_color,3)
-        if memcmp==(equalCompare)
-            sub cursor pixels
-            div cursor 3
-            set terminator cursor
-            set noselection 1
-        else
-            add cursor 3
-        endelse
-    endwhile
-
-    if noselection==0
-        str selerr="Press on the selection to create a frame slot."
-        call texter(selerr)
-        return 0
-    endif
-
-    div cursor unit_size
-    if cursor==0
-        str notatzero="Split the selection not from the first frame."
-        call texter(notatzero)
-        return 0
-    endif
-
-    #rearrange the previous part
-    #frame length
-    call stage_frame_time_numbers((stage_frame_time_set_frame_length),pos,cursor)
-    import "stage_new_click_area" stage_new_click_area
-    #frames container
-    import "stage_get_frames_container" stage_get_frames_container
-    sd box
-    setcall box stage_get_frames_container()
-    #frame objects
-    sd ebox
-    setcall ebox stage_new_click_area()
-    importx "_gtk_box_reorder_child" gtk_box_reorder_child
-    call gtk_box_reorder_child(box,ebox,pos)
-    #pixbuf to previous
-    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
-    sd pix
-    sd p_pix^pix
-    call stage_get_sel_pixbuf(p_pix)
-    import "pixbuf_copy" pixbuf_copy
-    sd prevpx
-    setcall prevpx pixbuf_copy(pix)
-    import "stage_pixbuf_to_container" stage_pixbuf_to_container
-    call stage_pixbuf_to_container(prevpx,ebox)
-
-    inc pos
-    sub length cursor
-    #new length for selection
-    call stage_frame_time_numbers((stage_frame_time_insert),pos,length,1)
-
-    #show at framebar the new length and show info about the new number of frames
-    sd ev
-    sd p_ev^ev
-    call stage_get_sel_parent(p_ev)
-    call stage_sel_img_set(ev)
-    call stage_display_info(ev)
-endfunction
-
-function stage_frame_unit_select(sd widget,sd event)
-    import "eventbutton_get_coords" eventbutton_get_coords
-    sd mouse_x
-    setcall mouse_x eventbutton_get_coords(event,0)
-
-    sd pixbuf
-
-    setcall pixbuf stage_sel_framebar_pixbuf()
-    sd length
-    setcall length stage_get_fr_length(widget)
-    sd width
-    setcall width gdk_pixbuf_get_width(pixbuf)
-    sd unit
-    set unit width
-    div unit length
-    div mouse_x unit
-    mult mouse_x unit
-
-    sd cursor1
-    sd cursor2
-
-    set cursor1 mouse_x
-    mult cursor1 3
-    addcall cursor1 gdk_pixbuf_get_pixels(pixbuf)
-
-    sd startpoint
-    set startpoint cursor1
-
-    set cursor2 unit
-    dec cursor2
-    mult cursor2 3
-    add cursor2 cursor1
-
-    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-    importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
-
-    sd height
-    setcall height gdk_pixbuf_get_height(pixbuf)
-    sd rowstride
-    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
-    import "color_pixel" color_pixel
-    while height!=0
-        call color_pixel((frame_unit_red),(frame_unit_green),(frame_unit_blue),cursor1)
-        call color_pixel((frame_unit_red),(frame_unit_green),(frame_unit_blue),cursor2)
-        add cursor1 rowstride
-        add cursor2 rowstride
-        dec height
-    endwhile
-    sub cursor1 rowstride
-    set cursor2 startpoint
-    while unit!=0
-        call color_pixel((frame_unit_red),(frame_unit_green),(frame_unit_blue),cursor1)
-        call color_pixel((frame_unit_red),(frame_unit_green),(frame_unit_blue),cursor2)
-        add cursor1 3
-        add cursor2 3
-        dec unit
-    endwhile
-endfunction
-
-#equalize
-
-function stage_frame_equalize()
-    import "stage_frame_dialog" stage_frame_dialog
-    data init^stage_frame_equalize_init
-    data on_ok^stage_frame_equalize_set
-    ss title="Equalize"
-    call stage_frame_dialog(init,on_ok,title)
-endfunction
-
-function stage_frame_equalize_edit(sd action,sd value)
-    data equalize_edit#1
-    if action==(value_set)
-        set equalize_edit value
-    else
-        return equalize_edit
-    endelse
-endfunction
-
-function stage_frame_equalize_init(sd vbox)
-    import "label_and_edit" label_and_edit
-    ss txt="Frame length "
-    sd edit
-    setcall edit label_and_edit(vbox,txt)
-    call stage_frame_equalize_edit((value_set),edit)
-endfunction
-
-function stage_frame_equalize_set()
-    #get the number
-    import "entry_to_int_min_N" entry_to_int_min_N
-    sd entry
-    setcall entry stage_frame_equalize_edit((value_get))
-    sd nr
-    sd p_nr^nr
-    sd bool
-    setcall bool entry_to_int_min_N(entry,p_nr,1)
-    if bool!=1
-        return 0
-    endif
-
-    #get sel pos
-    sd selpos
-    setcall selpos stage_get_sel_pos()
-
-    #calculate if equalization is possible
-    import "stage_get_frames" stage_get_frames
-    sd totalframes
-    setcall totalframes stage_get_frames()
-    sd equalization_end_frame
-    set equalization_end_frame selpos
-    sd dif=0
-    sd prev
-    sd can_be_truncation
-    sd loop=1
-    while loop==1
-        sd framelength
-        setcall framelength stage_frame_time_numbers((stage_frame_time_get_at_index),equalization_end_frame)
-        sub framelength nr
-        add dif framelength
-        set can_be_truncation nr
-        if dif==0
-            set loop 0
-        else
-            #test to truncate last equalization frame
-            sd sign_dif
-            set sign_dif dif
-            and sign_dif 0x80000000
-            if selpos!=equalization_end_frame
-                if sign_dif!=prev
-                    if dif<0
-                        mult dif -1
-                    endif
-                    sub can_be_truncation dif
-                    set loop 0
-                endif
-            endif
-            if loop!=0
-                set prev sign_dif
-
-                inc equalization_end_frame
-                if equalization_end_frame==totalframes
-                    str not_possible="Equalization not possible with the specified number"
-                    call texter(not_possible)
-                    return 0
-                endif
-            endif
-        endelse
-    endwhile
-    while selpos!=equalization_end_frame
-        call set_frame_length_and_redraw(selpos,nr)
-        inc selpos
-    endwhile
-    call set_frame_length_and_redraw(selpos,can_be_truncation)
-endfunction
-
-function set_frame_length_and_redraw(sd pos,sd nr)
-    call stage_frame_time_numbers((stage_frame_time_set_frame_length),pos,nr)
-    #display
-    import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
-    sd ebox
-    setcall ebox stage_nthwidgetFromcontainer(pos)
-    sd selpos
-    setcall selpos stage_get_sel_pos()
-    if selpos==pos
-        import "stage_sel_img" stage_sel_img
-        call stage_sel_img(ebox)
-    else
-        import "stage_unselected_frame" stage_unselected_frame
-        call stage_unselected_frame(ebox)
-    endelse
-    importx "_gtk_widget_show_all" gtk_widget_show_all
-    call gtk_widget_show_all(ebox)
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/frame/imagetools.oc
@@ -0,0 +1,892 @@
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+import "stage_frame_dialog" stage_frame_dialog
+
+function stage_color_under_image()
+    ss title="Color under image"
+    data init^stage_color_under_image_init
+    data on_ok^stage_color_under_image_set
+    call stage_frame_dialog(init,on_ok,title)
+endfunction
+
+function stage_color_under_image_init(sd vbox,sd *dialog)
+    import "stage_frame_form_data_init" stage_frame_form_data_init
+    call stage_frame_form_data_init(vbox,0)
+endfunction
+
+function stage_color_under_image_set()
+    import "stage_frame_form_data" stage_frame_form_data
+    sd newpixbuf
+    setcall newpixbuf stage_frame_form_data((stage_frame_form_data_pixbuf))
+    if newpixbuf=0
+        return 0
+    endif
+
+    sd pixbuf
+    sd p_pixbuf^pixbuf
+
+    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
+    call stage_get_sel_pixbuf(p_pixbuf)
+
+    import "stage_pixbuf_in_container_pixbuf" stage_pixbuf_in_container_pixbuf
+    call stage_pixbuf_in_container_pixbuf(pixbuf,newpixbuf)
+
+    import "stage_sel_replace_pixbuf" stage_sel_replace_pixbuf
+    call stage_sel_replace_pixbuf(newpixbuf)
+endfunction
+
+
+#headlights
+
+function headline_dialog()
+    import "frame_jobs" frame_jobs
+    sd bool
+    setcall bool frame_jobs()
+    if bool!=1
+        return 0
+    endif
+
+    ss title="Headlines"
+
+    importx "_gtk_dialog_new_with_buttons" gtk_dialog_new_with_buttons
+    import "mainwidget" mainwidget
+    sd window
+    setcall window mainwidget()
+
+    ss ok_button="OK"
+    ss close_button="Close"
+    sd dialog
+    setcall dialog gtk_dialog_new_with_buttons(title,window,(GTK_DIALOG_MODAL|GTK_DIALOG_DESTROY_WITH_PARENT),ok_button,(GTK_RESPONSE_OK),close_button,(GTK_RESPONSE_CANCEL),0)
+
+    importx "_gtk_dialog_get_content_area" gtk_dialog_get_content_area
+    sd vbox
+    setcall vbox gtk_dialog_get_content_area(dialog)
+
+    call headline_dlg((value_set),vbox)
+
+    importx "_gtk_widget_show_all" gtk_widget_show_all
+    call gtk_widget_show_all(dialog)
+
+    sd loop=1
+    while loop=1
+        importx "_gtk_dialog_run" gtk_dialog_run
+        sd resp
+        setcall resp gtk_dialog_run(dialog)
+        set loop 0
+        if resp=(GTK_RESPONSE_OK)
+            sd err
+            setcall err headline_dlg((value_get))
+            if err!=(noerror)
+                set loop 1
+                import "message_dialog" message_dialog
+                call message_dialog(err)
+            endif
+        endif
+    endwhile
+
+    importx "_gtk_widget_destroy" gtk_widget_destroy
+    call gtk_widget_destroy(dialog)
+endfunction
+
+function headline_dlg(sd action,sd vbox)
+    if action=(value_set)
+        data headline_txt#1
+        data headline_entry#1
+
+        data hsep1#1
+        data pos_chbox#1
+
+        data pos_txt#1
+        data left_txt#1
+        data left_entry#1
+        data top_txt#1
+        data top_entry#1
+
+        data location#1
+
+        data hsep2#1
+
+        data size_txt#1
+        data size_x#1
+        data color_txt#1
+        data color_x#1
+
+        data size_entry#1
+        data color_entry#1
+
+        data frames_txt#1
+        data frames_entry#1
+
+        importx "_gtk_table_new" gtk_table_new
+        importx "_gtk_table_attach" gtk_table_attach
+        const hl_rows=5
+        const hl_cols=2
+        sd table
+        setcall table gtk_table_new((hl_rows),(hl_cols),(FALSE))
+
+        import "labelfield_left_prepare" labelfield_left_prepare
+        importx "_gtk_entry_new" gtk_entry_new
+        importx "_gtk_hbox_new" gtk_hbox_new
+        import "packstart_default" packstart_default
+
+        sd j=0
+        sd j_next=1
+
+        #headline
+        ss hl="Headline "
+        setcall headline_txt labelfield_left_prepare(hl)
+        setcall headline_entry gtk_entry_new()
+        call gtk_table_attach(table,headline_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
+        call gtk_table_attach(table,headline_entry,1,2,j,j_next,(GTK_FILL),0,0,0)
+
+        #hsep1
+        importx "_gtk_hseparator_new" gtk_hseparator_new
+        setcall hsep1 gtk_hseparator_new()
+        inc j
+        inc j_next
+        call gtk_table_attach(table,hsep1,0,2,j,j_next,(GTK_FILL|GTK_EXPAND),0,0,10)
+
+        #coord or zone
+        importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
+        ss pos_chbox_txt="Use Coordinates"
+        setcall pos_chbox gtk_check_button_new_with_label(pos_chbox_txt)
+        inc j
+        inc j_next
+        call gtk_table_attach(table,pos_chbox,0,2,j,j_next,(GTK_FILL|GTK_EXPAND),0,0,0)
+
+        #pos
+        str pos_text="Coordinates:"
+        setcall pos_txt labelfield_left_prepare(pos_text)
+        inc j
+        inc j_next
+        call gtk_table_attach(table,pos_txt,0,2,j,j_next,(GTK_FILL),0,0,0)
+
+        #position
+        ss lf="Left"
+        setcall left_txt labelfield_left_prepare(lf)
+        setcall left_entry gtk_entry_new()
+        inc j
+        inc j_next
+        call gtk_table_attach(table,left_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
+        call gtk_table_attach(table,left_entry,1,2,j,j_next,(GTK_FILL),0,0,0)
+
+        ss tp="Top"
+        setcall top_txt labelfield_left_prepare(tp)
+        setcall top_entry gtk_entry_new()
+        inc j
+        inc j_next
+        call gtk_table_attach(table,top_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
+        call gtk_table_attach(table,top_entry,1,2,j,j_next,(GTK_FILL),0,0,0)
+
+        #location
+        import "stage_effect_orientation" stage_effect_orientation
+        ss loc="Location"
+        setcall location stage_effect_orientation(0,0,(TRUE),loc)
+        inc j
+        inc j_next
+        call gtk_table_attach(table,location,0,2,j,j_next,(GTK_FILL),0,0,0)
+
+        #hsep2
+        setcall hsep2 gtk_hseparator_new()
+        inc j
+        inc j_next
+        call gtk_table_attach(table,hsep2,0,2,j,j_next,(GTK_FILL|GTK_EXPAND),0,0,10)
+
+        #size
+        ss sz="Size"
+        setcall size_txt labelfield_left_prepare(sz)
+        importx "_gtk_combo_box_text_new" gtk_combo_box_text_new
+        setcall size_x gtk_hbox_new(0,0)
+        setcall size_entry gtk_combo_box_text_new()
+        call packstart_default(size_x,size_entry)
+        char str_data#30
+        str nr_ascii^str_data
+        str format="%u"
+        sd nr=10
+        importx "_sprintf" sprintf
+        while nr!=51
+            call sprintf(nr_ascii,format,nr)
+            importx "_gtk_combo_box_text_append_text" gtk_combo_box_text_append_text
+            call gtk_combo_box_text_append_text(size_entry,nr_ascii)
+            inc nr
+        endwhile
+        importx "_gtk_combo_box_set_active" gtk_combo_box_set_active
+        call gtk_combo_box_set_active(size_entry,10)
+        inc j
+        inc j_next
+        call gtk_table_attach(table,size_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
+        call gtk_table_attach(table,size_x,1,2,j,j_next,(GTK_FILL),0,0,0)
+
+        #color
+        ss cl="Color"
+        setcall color_txt labelfield_left_prepare(cl)
+        importx "_gtk_color_button_new" gtk_color_button_new
+        setcall color_x gtk_hbox_new(0,0)
+        setcall color_entry gtk_color_button_new()
+        call packstart_default(color_x,color_entry)
+        inc j
+        inc j_next
+        call gtk_table_attach(table,color_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
+        call gtk_table_attach(table,color_x,1,2,j,j_next,(GTK_FILL),0,0,0)
+
+        #frames
+        ss fr="Frames"
+        setcall frames_txt labelfield_left_prepare(fr)
+        setcall frames_entry gtk_entry_new()
+        inc j
+        inc j_next
+        call gtk_table_attach(table,frames_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
+        call gtk_table_attach(table,frames_entry,1,2,j,j_next,(GTK_FILL),0,0,0)
+
+        call packstart_default(vbox,table)
+    else
+        import "stage_get_selection_pixbuf" stage_get_selection_pixbuf
+        sd px
+        setcall px stage_get_selection_pixbuf()
+
+        #headlight
+        importx "_gtk_entry_get_text" gtk_entry_get_text
+        sd headline
+        setcall headline gtk_entry_get_text(headline_entry)
+
+        #coord or location
+        importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
+        sd coordinates_flag
+        setcall coordinates_flag gtk_toggle_button_get_active(pos_chbox)
+
+        sd x
+        sd y
+        sd p_y^y
+
+        if coordinates_flag=1
+            #test on coordinates
+            import "pixbuf_get_wh" pixbuf_get_wh
+            sd w
+            sd h
+            sd wh^w
+            call pixbuf_get_wh(px,wh)
+
+            import "strtoint" strtoint
+            str integer_err="Text coordinate to number failed"
+            str coord_err="Positive coordinate expected"
+            str toobig_err="A lower coordinate value expected"
+            sd p_x^x
+            setcall x gtk_entry_get_text(left_entry)
+            sd bool
+            setcall bool strtoint(x,p_x)
+            if bool=0
+                return integer_err
+            endif
+            if x<0
+                return coord_err
+            endif
+            if x>=w
+                return toobig_err
+            endif
+
+            setcall y gtk_entry_get_text(top_entry)
+            setcall bool strtoint(y,p_y)
+            if bool=0
+                return integer_err
+            endif
+            if y<0
+                return coord_err
+            endif
+            if y>=h
+                return toobig_err
+            endif
+            #
+        else
+            #location
+            setcall x stage_effect_orientation(1,p_y)
+        endelse
+
+        #size
+        importx "_gtk_combo_box_text_get_active_text" gtk_combo_box_text_get_active_text
+        sd sz_text
+        setcall sz_text gtk_combo_box_text_get_active_text(size_entry)
+        sd fontsize
+        sd p_fontsize^fontsize
+        call strtoint(sz_text,p_fontsize)
+
+        #color
+        import "color_widget_get_color" color_widget_get_color
+        sd color
+        setcall color color_widget_get_color(color_entry)
+
+        #number of frames
+        import "stage_get_sel_pos" stage_get_sel_pos
+        sd nr_text
+        sd frames
+        sd p_frames^frames
+        sd pos
+        setcall pos stage_get_sel_pos()
+        setcall nr_text gtk_entry_get_text(frames_entry)
+        setcall bool strtoint(nr_text,p_frames)
+        if bool=1
+            if frames<=0
+                str moreframes="More frames expected"
+                return moreframes
+            endif
+            import "stage_get_frames" stage_get_frames
+            sd totalframes
+            setcall totalframes stage_get_frames()
+            sub totalframes pos
+                #2 frames total, 1 is sel, 1 is available, frame>available is err
+            if frames>totalframes
+                str toomanyframes="Too many frames value"
+                return toomanyframes
+            endif
+        else
+            #set default 1 frame
+            set frames 1
+        endelse
+
+        while frames!=0
+            import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
+            sd ebox
+            setcall ebox stage_nthwidgetFromcontainer(pos)
+
+            import "object_get_dword_name" object_get_dword_name
+            sd pbuf
+            setcall pbuf object_get_dword_name(ebox)
+
+            import "pixbuf_draw_text" pixbuf_draw_text
+            sd newpixbuf
+            setcall newpixbuf pixbuf_draw_text(pbuf,headline,x,y,fontsize,color,coordinates_flag)
+
+            import "unref_pixbuf_frame" unref_pixbuf_frame
+            call unref_pixbuf_frame(ebox)
+
+            import "object_set_dword_name" object_set_dword_name
+            call object_set_dword_name(ebox,newpixbuf)
+
+            inc pos
+            dec frames
+        endwhile
+
+        import "stage_redraw" stage_redraw
+        call stage_redraw()
+
+        return (noerror)
+    endelse
+endfunction
+
+
+import "av_dialog_run_simple" av_dialog_run_simple
+import "av_dialog_close" av_dialog_close
+import "av_dialog_stop" av_dialog_stop
+
+function stage_lines()
+    ss title="Add/Remove lines"
+    data init^stage_lines_init
+    data on_ok^stage_lines_set
+    call stage_frame_dialog(init,on_ok,title)
+endfunction
+
+function stage_lines_init(sd vbox)
+    import "label_and_edit" label_and_edit
+    ss frames="Lines on a side: "
+    sd entry
+    setcall entry stage_line_entry()
+    setcall entry# label_and_edit(vbox,frames)
+    str default="1"
+    importx "_gtk_entry_set_text" gtk_entry_set_text
+    call gtk_entry_set_text(entry#,default)
+    #
+    importx "_gtk_radio_button_new_with_label" gtk_radio_button_new_with_label
+    importx "_gtk_radio_button_get_group" gtk_radio_button_get_group
+    ss add_text="Add"
+    sd add
+    setcall add gtk_radio_button_new_with_label(0,add_text)
+    sd add_rem_radiogroup
+    setcall add_rem_radiogroup gtk_radio_button_get_group(add)
+    ss rem_text="Remove"
+    sd rem
+    setcall rem gtk_radio_button_new_with_label(add_rem_radiogroup,rem_text)
+    sd add_remove_entry
+    setcall add_remove_entry stage_lines_add_remove_entry()
+    importx "_gtk_container_add" gtk_container_add
+    sd add_rem_hbox
+    setcall add_rem_hbox gtk_hbox_new(0,0)
+    call gtk_container_add(add_rem_hbox,add)
+    call gtk_container_add(add_rem_hbox,rem)
+    call gtk_container_add(vbox,add_rem_hbox)
+    set add_remove_entry# rem
+    #
+    ss color_text="Color: "
+    import "colorbuttonfield_leftlabel" colorbuttonfield_leftlabel
+    sd color_entry
+    setcall color_entry stage_line_color_entry()
+    setcall color_entry# colorbuttonfield_leftlabel(color_text,vbox)
+    #
+    ss row_text="Rows"
+    sd row
+    setcall row gtk_radio_button_new_with_label(0,row_text)
+    sd radiogroup
+    setcall radiogroup gtk_radio_button_get_group(row)
+    ss col_text="Columns"
+    sd col
+    setcall col gtk_radio_button_new_with_label(radiogroup,col_text)
+    sd row_col_entry
+    setcall row_col_entry stage_line_row_col_entry()
+    sd hbox
+    setcall hbox gtk_hbox_new(0,0)
+    call gtk_container_add(hbox,row)
+    call gtk_container_add(hbox,col)
+    call gtk_container_add(vbox,hbox)
+    set row_col_entry# col
+    #
+    import "hseparatorfield_nopad" hseparatorfield_nopad
+    call hseparatorfield_nopad(vbox)
+    sd start_entry
+    sd end_entry
+    sd start
+    sd end
+    setcall start_entry stage_lines_start_entry()
+    setcall end_entry stage_lines_end_entry()
+    setcall start stage_lines_start()
+    setcall end stage_lines_end()
+    set start# 0
+    setcall end# stage_get_frames()
+    ss start_text="Start frame: "
+    ss end_text="End frame: "
+    setcall start_entry# label_and_edit(vbox,start_text)
+    setcall end_entry# label_and_edit(vbox,end_text)
+endfunction
+
+function stage_lines_number()
+    data number#1
+    return #number
+endfunction
+function stage_line_entry()
+    data add_entry#1
+    return #add_entry
+endfunction
+function stage_line_color_entry()
+    data entry#1
+    return #entry
+endfunction
+function stage_line_color()
+    data color#1
+    return #color
+endfunction
+function stage_line_row_col_entry()
+    data entry#1
+    return #entry
+endfunction
+function stage_line_row_col()
+    data row_col#1
+    return #row_col
+endfunction
+function stage_lines_start_entry()
+    data start_entry#1
+    return #start_entry
+endfunction
+function stage_lines_end_entry()
+    data end_entry#1
+    return #end_entry
+endfunction
+function stage_lines_start()
+    data start#1
+    return #start
+endfunction
+function stage_lines_end()
+    data end#1
+    return #end
+endfunction
+function stage_lines_add_remove_entry()
+    data entry#1
+    return #entry
+endfunction
+function stage_lines_add_remove()
+    data add_remove#1
+    return #add_remove
+endfunction
+
+function stage_lines_set()
+    import "entry_to_int_min_N" entry_to_int_min_N
+    sd bool
+    sd entry
+    setcall entry stage_line_entry()
+    sd nr
+    setcall nr stage_lines_number()
+    setcall bool entry_to_int_min_N(entry#,nr,1)
+    if bool=(FALSE)
+        return (void)
+    endif
+    #get add/remove
+    sd add_rem_entry
+    setcall add_rem_entry stage_lines_add_remove_entry()
+    sd rem_active
+    setcall rem_active gtk_toggle_button_get_active(add_rem_entry#)
+    sd add_rem
+    setcall add_rem stage_lines_add_remove()
+    set add_rem# rem_active
+    #get color
+    import "color_widget_get_color_to_rgb" color_widget_get_color_to_rgb
+    import "dword_reverse" dword_reverse
+    sd color_entry
+    setcall color_entry stage_line_color_entry()
+    sd uint_color
+    setcall uint_color color_widget_get_color_to_rgb(color_entry#)
+    setcall uint_color dword_reverse(uint_color)
+    sd color
+    setcall color stage_line_color()
+    set color# uint_color
+    #get on row or or col
+    sd row_col_entry
+    setcall row_col_entry stage_line_row_col_entry()
+    sd col_active
+    setcall col_active gtk_toggle_button_get_active(row_col_entry#)
+    sd row_col
+    setcall row_col stage_line_row_col()
+    set row_col# col_active
+    #get [start,end]
+    sd start_entry
+    sd end_entry
+    sd start
+    sd end
+    setcall start_entry stage_lines_start_entry()
+    setcall end_entry stage_lines_end_entry()
+    setcall start stage_lines_start()
+    setcall end stage_lines_end()
+    sd value
+    setcall bool entry_to_int_min_N(start_entry#,#value,0)
+    if bool=(TRUE)
+        set start# value
+    endif
+    setcall bool entry_to_int_min_N(end_entry#,#value,0)
+    if bool=(TRUE)
+        set end# value
+    endif
+    #handle the selection first for conflicts with expose event
+    sd sel_pos
+    setcall sel_pos stage_get_sel_pos()
+    call stage_lines_modify_img(sel_pos)
+    #
+    import "stage_file_options_info_message" stage_file_options_info_message
+    sd info
+    setcall info stage_file_options_info_message((value_get))
+    call stage_file_options_info_message((value_set),0)
+    data f^stage_lines_thread
+    call av_dialog_run_simple(f)
+    #restore info message
+    call stage_file_options_info_message((value_set),info)
+endfunction
+
+function stage_lines_thread()
+    call stage_lines_thread_loop()
+    call av_dialog_close()
+    call stage_redraw()
+    str res="Resized"
+    import "texter" texter
+    call texter(res)
+endfunction
+
+import "stage_nthPixbufFromContainer" stage_nthPixbufFromContainer
+
+function stage_lines_thread_loop()
+    sd img_nr=0
+    sd sel_pos
+    setcall sel_pos stage_get_sel_pos()
+    sd nr_frames
+    setcall nr_frames stage_get_frames()
+    #loop
+    whiletrue
+        sd stop
+        setcall stop av_dialog_stop((value_get))
+        if stop=1
+            return (void)
+        endif
+        #
+        if img_nr!=sel_pos
+            call stage_lines_modify_img(img_nr)
+        endif
+        #
+        inc img_nr
+        if img_nr=nr_frames
+            return (void)
+        endif
+        #
+        import "dialog_modal_texter_draw" dialog_modal_texter_draw
+        sd totalframes
+        setcall totalframes stage_get_frames()
+        const imagetoolsbufstart=\
+        ss format="Images: %u/%u"
+        char buf#\-imagetoolsbufstart-2-2+dword_max+dword_max
+        str buffer^buf
+        call sprintf(buffer,format,img_nr,totalframes)
+        call dialog_modal_texter_draw(buffer)
+    endwhile
+endfunction
+
+function stage_lines_modify_img(sd img_nr)
+    sd start
+    sd end
+    setcall start stage_lines_start()
+    setcall end stage_lines_end()
+    if img_nr<start#
+        return (void)
+    endif
+    if end#<img_nr
+        return (void)
+    endif
+    #
+    sd pixbuf
+    setcall pixbuf stage_nthPixbufFromContainer(img_nr)
+    if pixbuf=0
+        return (void)
+    endif
+    #
+    sd number_ptr
+    setcall number_ptr stage_lines_number()
+    sd number
+    set number number_ptr#
+    #
+    sd w
+    sd h
+    sd wh^w
+    call pixbuf_get_wh(pixbuf,wh)
+    sd size
+    sd stride
+    import "rgb_get_all_sizes" rgb_get_all_sizes
+    sd p_stride^stride
+    setcall size rgb_get_all_sizes(w,h,p_stride)
+    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+    sd bytes
+    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
+    sd newmem=0
+    #
+    sd row_col
+    setcall row_col stage_line_row_col()
+    sd add_rem
+    setcall add_rem stage_lines_add_remove()
+    if add_rem#=0
+        if row_col#=0
+            call img_row_add(#newmem,w,#h,number,stride,bytes,size)
+        else
+            call img_col_add(#newmem,#w,h,number,#stride,bytes)
+        endelse
+    else
+        if row_col#=0
+            call img_row_remove(#newmem,#h,number,stride,bytes)
+        else
+            call img_col_remove(#newmem,#w,h,number,#stride,bytes)
+        endelse
+    endelse
+    if newmem=0
+        return (void)
+    endif
+    #
+    importx "_gdk_pixbuf_new_from_data" gdk_pixbuf_new_from_data
+    importx "_free" free
+    data free_callback^free
+    sd newpixbuf
+    setcall newpixbuf gdk_pixbuf_new_from_data(newmem,(GDK_COLORSPACE_RGB),(FALSE),8,w,h,stride,free_callback,newmem)
+    if newpixbuf=0
+        call free(newmem)
+        return (void)
+    endif
+    #
+    sd ebox
+    setcall ebox stage_nthwidgetFromcontainer(img_nr)
+    sd oldpixbuf
+    setcall oldpixbuf object_get_dword_name(ebox)
+        #
+    call object_set_dword_name(ebox,newpixbuf)
+        #
+    importx "_g_object_unref" g_object_unref
+    call g_object_unref(oldpixbuf)
+endfunction
+import "memalloc" memalloc
+import "cpymem" cpymem
+
+#add
+
+function img_row_add(sd p_newmem,sd w,sd p_h,sd number,sd stride,ss bytes,sd size)
+    sd newsize
+    set newsize size
+    #
+    sd newrows
+    set newrows number
+    mult newrows 2
+    mult newrows stride
+    add newsize newrows
+    #
+    sd newmem
+    setcall newmem memalloc(newsize)
+    if newmem=0
+        return (void)
+    endif
+    set p_newmem# newmem
+    sd cursor
+    sd color
+    setcall color stage_line_color()
+    #
+    sd i_top=0
+    while i_top<number
+        sd j_top=0
+        set cursor newmem
+        while j_top<w
+            call cpymem(cursor,color,3)
+            add cursor 3
+            inc j_top
+        endwhile
+        add newmem stride
+        inc i_top
+    endwhile
+    call cpymem(newmem,bytes,size)
+    add newmem size
+    sd i_bottom=0
+    while i_bottom<number
+        sd j_bottom=0
+        set cursor newmem
+        while j_bottom<w
+            call cpymem(cursor,color,3)
+            add cursor 3
+            inc j_bottom
+        endwhile
+        add newmem stride
+        inc i_bottom
+    endwhile
+    #
+    add p_h# number
+    add p_h# number
+endfunction
+
+function img_col_add(sd p_newmem,sd p_w,sd h,sd number,sd p_stride,ss prevpixels)
+    import "rgb_get_rowstride" rgb_get_rowstride
+    sd newsize
+    sd newwidth
+    set newwidth p_w#
+    add newwidth number
+    add newwidth number
+    sd prevstride
+    set prevstride p_stride#
+    setcall p_stride# rgb_get_rowstride(newwidth)
+    set newsize p_stride#
+    mult newsize h
+    #
+    sd newmem
+    setcall newmem memalloc(newsize)
+    if newmem=0
+        return (void)
+    endif
+    set p_newmem# newmem
+    sd color
+    setcall color stage_line_color()
+    #
+    sd prev_row_size
+    set prev_row_size p_w#
+    mult prev_row_size 3
+    sd cursor
+    sd y=0
+    while y<h
+        set cursor newmem
+        #
+        sd x_left=0
+        while x_left<number
+            call cpymem(cursor,color,3)
+            add cursor 3
+            inc x_left
+        endwhile
+        #
+        call cpymem(cursor,prevpixels,prev_row_size)
+        add prevpixels prevstride
+        add cursor prev_row_size
+        #
+        sd x_right=0
+        while x_right<number
+            call cpymem(cursor,color,3)
+            add cursor 3
+            inc x_right
+        endwhile
+        #
+        add newmem p_stride#
+        inc y
+    endwhile
+    #
+    set p_w# newwidth
+endfunction
+
+#remove
+
+function img_row_remove(sd p_newmem,sd p_h,sd number,sd stride,ss prevpixels)
+    sd newrows
+    set newrows number
+    mult newrows 2
+    if newrows>=p_h#
+        call texter("remove rows error")
+        return (void)
+    endif
+    sub p_h# newrows
+    #
+    sd newsize
+    set newsize p_h#
+    mult newsize stride
+
+    sd newmem
+    setcall newmem memalloc(newsize)
+    if newmem=0
+        return (void)
+    endif
+    set p_newmem# newmem
+
+    sd removesize
+    set removesize number
+    mult removesize stride
+    add prevpixels removesize
+
+    call cpymem(newmem,prevpixels,newsize)
+endfunction
+
+function img_col_remove(sd p_newmem,sd p_w,sd h,sd number,sd p_stride,ss prevpixels)
+    sd newcols
+    set newcols number
+    mult newcols 2
+    if newcols>=p_w#
+        call texter("remove cols error")
+        return (void)
+    endif
+    sub p_w# newcols
+    #
+    sd newstride
+    setcall newstride rgb_get_rowstride(p_w#)
+    #
+    sd newsize
+    set newsize newstride
+    mult newsize h
+    #
+    sd newmem
+    setcall newmem memalloc(newsize)
+    if newmem=0
+        return (void)
+    endif
+    set p_newmem# newmem
+    #
+    sd removesize
+    set removesize number
+    mult removesize 3
+    sd copysize
+    set copysize p_w#
+    mult copysize 3
+    #
+    ss old_cursor
+    sd j=0
+    while j<h
+        set old_cursor prevpixels
+        #
+        add old_cursor removesize
+        call cpymem(newmem,old_cursor,copysize)
+        #
+        add newmem newstride
+        add prevpixels p_stride#
+        inc j
+    endwhile
+    set p_stride# newstride
+endfunction
--- ovideo-1.orig/src/_prepare/frame/imagetools.s
+++ /dev/null
@@ -1,892 +0,0 @@
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-import "stage_frame_dialog" stage_frame_dialog
-
-function stage_color_under_image()
-    ss title="Color under image"
-    data init^stage_color_under_image_init
-    data on_ok^stage_color_under_image_set
-    call stage_frame_dialog(init,on_ok,title)
-endfunction
-
-function stage_color_under_image_init(sd vbox,sd *dialog)
-    import "stage_frame_form_data_init" stage_frame_form_data_init
-    call stage_frame_form_data_init(vbox,0)
-endfunction
-
-function stage_color_under_image_set()
-    import "stage_frame_form_data" stage_frame_form_data
-    sd newpixbuf
-    setcall newpixbuf stage_frame_form_data((stage_frame_form_data_pixbuf))
-    if newpixbuf==0
-        return 0
-    endif
-
-    sd pixbuf
-    sd p_pixbuf^pixbuf
-
-    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
-    call stage_get_sel_pixbuf(p_pixbuf)
-
-    import "stage_pixbuf_in_container_pixbuf" stage_pixbuf_in_container_pixbuf
-    call stage_pixbuf_in_container_pixbuf(pixbuf,newpixbuf)
-
-    import "stage_sel_replace_pixbuf" stage_sel_replace_pixbuf
-    call stage_sel_replace_pixbuf(newpixbuf)
-endfunction
-
-
-#headlights
-
-function headline_dialog()
-    import "frame_jobs" frame_jobs
-    sd bool
-    setcall bool frame_jobs()
-    if bool!=1
-        return 0
-    endif
-
-    ss title="Headlines"
-
-    importx "_gtk_dialog_new_with_buttons" gtk_dialog_new_with_buttons
-    import "mainwidget" mainwidget
-    sd window
-    setcall window mainwidget()
-
-    ss ok_button="OK"
-    ss close_button="Close"
-    sd dialog
-    setcall dialog gtk_dialog_new_with_buttons(title,window,(GTK_DIALOG_MODAL|GTK_DIALOG_DESTROY_WITH_PARENT),ok_button,(GTK_RESPONSE_OK),close_button,(GTK_RESPONSE_CANCEL),0)
-
-    importx "_gtk_dialog_get_content_area" gtk_dialog_get_content_area
-    sd vbox
-    setcall vbox gtk_dialog_get_content_area(dialog)
-
-    call headline_dlg((value_set),vbox)
-
-    importx "_gtk_widget_show_all" gtk_widget_show_all
-    call gtk_widget_show_all(dialog)
-
-    sd loop=1
-    while loop==1
-        importx "_gtk_dialog_run" gtk_dialog_run
-        sd resp
-        setcall resp gtk_dialog_run(dialog)
-        set loop 0
-        if resp==(GTK_RESPONSE_OK)
-            sd err
-            setcall err headline_dlg((value_get))
-            if err!=(noerror)
-                set loop 1
-                import "message_dialog" message_dialog
-                call message_dialog(err)
-            endif
-        endif
-    endwhile
-
-    importx "_gtk_widget_destroy" gtk_widget_destroy
-    call gtk_widget_destroy(dialog)
-endfunction
-
-function headline_dlg(sd action,sd vbox)
-    if action==(value_set)
-        data headline_txt#1
-        data headline_entry#1
-
-        data hsep1#1
-        data pos_chbox#1
-
-        data pos_txt#1
-        data left_txt#1
-        data left_entry#1
-        data top_txt#1
-        data top_entry#1
-
-        data location#1
-
-        data hsep2#1
-
-        data size_txt#1
-        data size_x#1
-        data color_txt#1
-        data color_x#1
-
-        data size_entry#1
-        data color_entry#1
-
-        data frames_txt#1
-        data frames_entry#1
-
-        importx "_gtk_table_new" gtk_table_new
-        importx "_gtk_table_attach" gtk_table_attach
-        const hl_rows=5
-        const hl_cols=2
-        sd table
-        setcall table gtk_table_new((hl_rows),(hl_cols),(FALSE))
-
-        import "labelfield_left_prepare" labelfield_left_prepare
-        importx "_gtk_entry_new" gtk_entry_new
-        importx "_gtk_hbox_new" gtk_hbox_new
-        import "packstart_default" packstart_default
-
-        sd j=0
-        sd j_next=1
-
-        #headline
-        ss hl="Headline "
-        setcall headline_txt labelfield_left_prepare(hl)
-        setcall headline_entry gtk_entry_new()
-        call gtk_table_attach(table,headline_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
-        call gtk_table_attach(table,headline_entry,1,2,j,j_next,(GTK_FILL),0,0,0)
-
-        #hsep1
-        importx "_gtk_hseparator_new" gtk_hseparator_new
-        setcall hsep1 gtk_hseparator_new()
-        inc j
-        inc j_next
-        call gtk_table_attach(table,hsep1,0,2,j,j_next,(GTK_FILL|GTK_EXPAND),0,0,10)
-
-        #coord or zone
-        importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
-        ss pos_chbox_txt="Use Coordinates"
-        setcall pos_chbox gtk_check_button_new_with_label(pos_chbox_txt)
-        inc j
-        inc j_next
-        call gtk_table_attach(table,pos_chbox,0,2,j,j_next,(GTK_FILL|GTK_EXPAND),0,0,0)
-
-        #pos
-        str pos_text="Coordinates:"
-        setcall pos_txt labelfield_left_prepare(pos_text)
-        inc j
-        inc j_next
-        call gtk_table_attach(table,pos_txt,0,2,j,j_next,(GTK_FILL),0,0,0)
-
-        #position
-        ss lf="Left"
-        setcall left_txt labelfield_left_prepare(lf)
-        setcall left_entry gtk_entry_new()
-        inc j
-        inc j_next
-        call gtk_table_attach(table,left_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
-        call gtk_table_attach(table,left_entry,1,2,j,j_next,(GTK_FILL),0,0,0)
-
-        ss tp="Top"
-        setcall top_txt labelfield_left_prepare(tp)
-        setcall top_entry gtk_entry_new()
-        inc j
-        inc j_next
-        call gtk_table_attach(table,top_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
-        call gtk_table_attach(table,top_entry,1,2,j,j_next,(GTK_FILL),0,0,0)
-
-        #location
-        import "stage_effect_orientation" stage_effect_orientation
-        ss loc="Location"
-        setcall location stage_effect_orientation(0,0,(TRUE),loc)
-        inc j
-        inc j_next
-        call gtk_table_attach(table,location,0,2,j,j_next,(GTK_FILL),0,0,0)
-
-        #hsep2
-        setcall hsep2 gtk_hseparator_new()
-        inc j
-        inc j_next
-        call gtk_table_attach(table,hsep2,0,2,j,j_next,(GTK_FILL|GTK_EXPAND),0,0,10)
-
-        #size
-        ss sz="Size"
-        setcall size_txt labelfield_left_prepare(sz)
-        importx "_gtk_combo_box_text_new" gtk_combo_box_text_new
-        setcall size_x gtk_hbox_new(0,0)
-        setcall size_entry gtk_combo_box_text_new()
-        call packstart_default(size_x,size_entry)
-        char str_data#30
-        str nr_ascii^str_data
-        str format="%u"
-        sd nr=10
-        importx "_sprintf" sprintf
-        while nr!=51
-            call sprintf(nr_ascii,format,nr)
-            importx "_gtk_combo_box_text_append_text" gtk_combo_box_text_append_text
-            call gtk_combo_box_text_append_text(size_entry,nr_ascii)
-            inc nr
-        endwhile
-        importx "_gtk_combo_box_set_active" gtk_combo_box_set_active
-        call gtk_combo_box_set_active(size_entry,10)
-        inc j
-        inc j_next
-        call gtk_table_attach(table,size_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
-        call gtk_table_attach(table,size_x,1,2,j,j_next,(GTK_FILL),0,0,0)
-
-        #color
-        ss cl="Color"
-        setcall color_txt labelfield_left_prepare(cl)
-        importx "_gtk_color_button_new" gtk_color_button_new
-        setcall color_x gtk_hbox_new(0,0)
-        setcall color_entry gtk_color_button_new()
-        call packstart_default(color_x,color_entry)
-        inc j
-        inc j_next
-        call gtk_table_attach(table,color_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
-        call gtk_table_attach(table,color_x,1,2,j,j_next,(GTK_FILL),0,0,0)
-
-        #frames
-        ss fr="Frames"
-        setcall frames_txt labelfield_left_prepare(fr)
-        setcall frames_entry gtk_entry_new()
-        inc j
-        inc j_next
-        call gtk_table_attach(table,frames_txt,0,1,j,j_next,(GTK_FILL),0,0,0)
-        call gtk_table_attach(table,frames_entry,1,2,j,j_next,(GTK_FILL),0,0,0)
-
-        call packstart_default(vbox,table)
-    else
-        import "stage_get_selection_pixbuf" stage_get_selection_pixbuf
-        sd px
-        setcall px stage_get_selection_pixbuf()
-
-        #headlight
-        importx "_gtk_entry_get_text" gtk_entry_get_text
-        sd headline
-        setcall headline gtk_entry_get_text(headline_entry)
-
-        #coord or location
-        importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
-        sd coordinates_flag
-        setcall coordinates_flag gtk_toggle_button_get_active(pos_chbox)
-
-        sd x
-        sd y
-        sd p_y^y
-
-        if coordinates_flag==1
-            #test on coordinates
-            import "pixbuf_get_wh" pixbuf_get_wh
-            sd w
-            sd h
-            sd wh^w
-            call pixbuf_get_wh(px,wh)
-
-            import "strtoint" strtoint
-            str integer_err="Text coordinate to number failed"
-            str coord_err="Positive coordinate expected"
-            str toobig_err="A lower coordinate value expected"
-            sd p_x^x
-            setcall x gtk_entry_get_text(left_entry)
-            sd bool
-            setcall bool strtoint(x,p_x)
-            if bool==0
-                return integer_err
-            endif
-            if x<0
-                return coord_err
-            endif
-            if x>=w
-                return toobig_err
-            endif
-
-            setcall y gtk_entry_get_text(top_entry)
-            setcall bool strtoint(y,p_y)
-            if bool==0
-                return integer_err
-            endif
-            if y<0
-                return coord_err
-            endif
-            if y>=h
-                return toobig_err
-            endif
-            #
-        else
-            #location
-            setcall x stage_effect_orientation(1,p_y)
-        endelse
-
-        #size
-        importx "_gtk_combo_box_text_get_active_text" gtk_combo_box_text_get_active_text
-        sd sz_text
-        setcall sz_text gtk_combo_box_text_get_active_text(size_entry)
-        sd fontsize
-        sd p_fontsize^fontsize
-        call strtoint(sz_text,p_fontsize)
-
-        #color
-        import "color_widget_get_color" color_widget_get_color
-        sd color
-        setcall color color_widget_get_color(color_entry)
-
-        #number of frames
-        import "stage_get_sel_pos" stage_get_sel_pos
-        sd nr_text
-        sd frames
-        sd p_frames^frames
-        sd pos
-        setcall pos stage_get_sel_pos()
-        setcall nr_text gtk_entry_get_text(frames_entry)
-        setcall bool strtoint(nr_text,p_frames)
-        if bool==1
-            if frames<=0
-                str moreframes="More frames expected"
-                return moreframes
-            endif
-            import "stage_get_frames" stage_get_frames
-            sd totalframes
-            setcall totalframes stage_get_frames()
-            sub totalframes pos
-                #2 frames total, 1 is sel, 1 is available, frame>available is err
-            if frames>totalframes
-                str toomanyframes="Too many frames value"
-                return toomanyframes
-            endif
-        else
-            #set default 1 frame
-            set frames 1
-        endelse
-
-        while frames!=0
-            import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
-            sd ebox
-            setcall ebox stage_nthwidgetFromcontainer(pos)
-
-            import "object_get_dword_name" object_get_dword_name
-            sd pbuf
-            setcall pbuf object_get_dword_name(ebox)
-
-            import "pixbuf_draw_text" pixbuf_draw_text
-            sd newpixbuf
-            setcall newpixbuf pixbuf_draw_text(pbuf,headline,x,y,fontsize,color,coordinates_flag)
-
-            import "unref_pixbuf_frame" unref_pixbuf_frame
-            call unref_pixbuf_frame(ebox)
-
-            import "object_set_dword_name" object_set_dword_name
-            call object_set_dword_name(ebox,newpixbuf)
-
-            inc pos
-            dec frames
-        endwhile
-
-        import "stage_redraw" stage_redraw
-        call stage_redraw()
-
-        return (noerror)
-    endelse
-endfunction
-
-
-import "av_dialog_run_simple" av_dialog_run_simple
-import "av_dialog_close" av_dialog_close
-import "av_dialog_stop" av_dialog_stop
-
-function stage_lines()
-    ss title="Add/Remove lines"
-    data init^stage_lines_init
-    data on_ok^stage_lines_set
-    call stage_frame_dialog(init,on_ok,title)
-endfunction
-
-function stage_lines_init(sd vbox)
-    import "label_and_edit" label_and_edit
-    ss frames="Lines on a side: "
-    sd entry
-    setcall entry stage_line_entry()
-    setcall entry# label_and_edit(vbox,frames)
-    str default="1"
-    importx "_gtk_entry_set_text" gtk_entry_set_text
-    call gtk_entry_set_text(entry#,default)
-    #
-    importx "_gtk_radio_button_new_with_label" gtk_radio_button_new_with_label
-    importx "_gtk_radio_button_get_group" gtk_radio_button_get_group
-    ss add_text="Add"
-    sd add
-    setcall add gtk_radio_button_new_with_label(0,add_text)
-    sd add_rem_radiogroup
-    setcall add_rem_radiogroup gtk_radio_button_get_group(add)
-    ss rem_text="Remove"
-    sd rem
-    setcall rem gtk_radio_button_new_with_label(add_rem_radiogroup,rem_text)
-    sd add_remove_entry
-    setcall add_remove_entry stage_lines_add_remove_entry()
-    importx "_gtk_container_add" gtk_container_add
-    sd add_rem_hbox
-    setcall add_rem_hbox gtk_hbox_new(0,0)
-    call gtk_container_add(add_rem_hbox,add)
-    call gtk_container_add(add_rem_hbox,rem)
-    call gtk_container_add(vbox,add_rem_hbox)
-    set add_remove_entry# rem
-    #
-    ss color_text="Color: "
-    import "colorbuttonfield_leftlabel" colorbuttonfield_leftlabel
-    sd color_entry
-    setcall color_entry stage_line_color_entry()
-    setcall color_entry# colorbuttonfield_leftlabel(color_text,vbox)
-    #
-    ss row_text="Rows"
-    sd row
-    setcall row gtk_radio_button_new_with_label(0,row_text)
-    sd radiogroup
-    setcall radiogroup gtk_radio_button_get_group(row)
-    ss col_text="Columns"
-    sd col
-    setcall col gtk_radio_button_new_with_label(radiogroup,col_text)
-    sd row_col_entry
-    setcall row_col_entry stage_line_row_col_entry()
-    sd hbox
-    setcall hbox gtk_hbox_new(0,0)
-    call gtk_container_add(hbox,row)
-    call gtk_container_add(hbox,col)
-    call gtk_container_add(vbox,hbox)
-    set row_col_entry# col
-    #
-    import "hseparatorfield_nopad" hseparatorfield_nopad
-    call hseparatorfield_nopad(vbox)
-    sd start_entry
-    sd end_entry
-    sd start
-    sd end
-    setcall start_entry stage_lines_start_entry()
-    setcall end_entry stage_lines_end_entry()
-    setcall start stage_lines_start()
-    setcall end stage_lines_end()
-    set start# 0
-    setcall end# stage_get_frames()
-    ss start_text="Start frame: "
-    ss end_text="End frame: "
-    setcall start_entry# label_and_edit(vbox,start_text)
-    setcall end_entry# label_and_edit(vbox,end_text)
-endfunction
-
-function stage_lines_number()
-    data number#1
-    return #number
-endfunction
-function stage_line_entry()
-    data add_entry#1
-    return #add_entry
-endfunction
-function stage_line_color_entry()
-    data entry#1
-    return #entry
-endfunction
-function stage_line_color()
-    data color#1
-    return #color
-endfunction
-function stage_line_row_col_entry()
-    data entry#1
-    return #entry
-endfunction
-function stage_line_row_col()
-    data row_col#1
-    return #row_col
-endfunction
-function stage_lines_start_entry()
-    data start_entry#1
-    return #start_entry
-endfunction
-function stage_lines_end_entry()
-    data end_entry#1
-    return #end_entry
-endfunction
-function stage_lines_start()
-    data start#1
-    return #start
-endfunction
-function stage_lines_end()
-    data end#1
-    return #end
-endfunction
-function stage_lines_add_remove_entry()
-    data entry#1
-    return #entry
-endfunction
-function stage_lines_add_remove()
-    data add_remove#1
-    return #add_remove
-endfunction
-
-function stage_lines_set()
-    import "entry_to_int_min_N" entry_to_int_min_N
-    sd bool
-    sd entry
-    setcall entry stage_line_entry()
-    sd nr
-    setcall nr stage_lines_number()
-    setcall bool entry_to_int_min_N(entry#,nr,1)
-    if bool==(FALSE)
-        return (void)
-    endif
-    #get add/remove
-    sd add_rem_entry
-    setcall add_rem_entry stage_lines_add_remove_entry()
-    sd rem_active
-    setcall rem_active gtk_toggle_button_get_active(add_rem_entry#)
-    sd add_rem
-    setcall add_rem stage_lines_add_remove()
-    set add_rem# rem_active
-    #get color
-    import "color_widget_get_color_to_rgb" color_widget_get_color_to_rgb
-    import "dword_reverse" dword_reverse
-    sd color_entry
-    setcall color_entry stage_line_color_entry()
-    sd uint_color
-    setcall uint_color color_widget_get_color_to_rgb(color_entry#)
-    setcall uint_color dword_reverse(uint_color)
-    sd color
-    setcall color stage_line_color()
-    set color# uint_color
-    #get on row or or col
-    sd row_col_entry
-    setcall row_col_entry stage_line_row_col_entry()
-    sd col_active
-    setcall col_active gtk_toggle_button_get_active(row_col_entry#)
-    sd row_col
-    setcall row_col stage_line_row_col()
-    set row_col# col_active
-    #get [start,end]
-    sd start_entry
-    sd end_entry
-    sd start
-    sd end
-    setcall start_entry stage_lines_start_entry()
-    setcall end_entry stage_lines_end_entry()
-    setcall start stage_lines_start()
-    setcall end stage_lines_end()
-    sd value
-    setcall bool entry_to_int_min_N(start_entry#,#value,0)
-    if bool==(TRUE)
-        set start# value
-    endif
-    setcall bool entry_to_int_min_N(end_entry#,#value,0)
-    if bool==(TRUE)
-        set end# value
-    endif
-    #handle the selection first for conflicts with expose event
-    sd sel_pos
-    setcall sel_pos stage_get_sel_pos()
-    call stage_lines_modify_img(sel_pos)
-    #
-    import "stage_file_options_info_message" stage_file_options_info_message
-    sd info
-    setcall info stage_file_options_info_message((value_get))
-    call stage_file_options_info_message((value_set),0)
-    data f^stage_lines_thread
-    call av_dialog_run_simple(f)
-    #restore info message
-    call stage_file_options_info_message((value_set),info)
-endfunction
-
-function stage_lines_thread()
-    call stage_lines_thread_loop()
-    call av_dialog_close()
-    call stage_redraw()
-    str res="Resized"
-    import "texter" texter
-    call texter(res)
-endfunction
-
-import "stage_nthPixbufFromContainer" stage_nthPixbufFromContainer
-
-function stage_lines_thread_loop()
-    sd img_nr=0
-    sd sel_pos
-    setcall sel_pos stage_get_sel_pos()
-    sd nr_frames
-    setcall nr_frames stage_get_frames()
-    #loop
-    while 1==1
-        sd stop
-        setcall stop av_dialog_stop((value_get))
-        if stop==1
-            return (void)
-        endif
-        #
-        if img_nr!=sel_pos
-            call stage_lines_modify_img(img_nr)
-        endif
-        #
-        inc img_nr
-        if img_nr==nr_frames
-            return (void)
-        endif
-        #
-        import "dialog_modal_texter_draw" dialog_modal_texter_draw
-        sd totalframes
-        setcall totalframes stage_get_frames()
-        const imagetoolsbufstart=!
-        ss format="Images: %u/%u"
-        char buf#!-imagetoolsbufstart-2-2+dword_max+dword_max
-        str buffer^buf
-        call sprintf(buffer,format,img_nr,totalframes)
-        call dialog_modal_texter_draw(buffer)
-    endwhile
-endfunction
-
-function stage_lines_modify_img(sd img_nr)
-    sd start
-    sd end
-    setcall start stage_lines_start()
-    setcall end stage_lines_end()
-    if img_nr<start#
-        return (void)
-    endif
-    if end#<img_nr
-        return (void)
-    endif
-    #
-    sd pixbuf
-    setcall pixbuf stage_nthPixbufFromContainer(img_nr)
-    if pixbuf==0
-        return (void)
-    endif
-    #
-    sd number_ptr
-    setcall number_ptr stage_lines_number()
-    sd number
-    set number number_ptr#
-    #
-    sd w
-    sd h
-    sd wh^w
-    call pixbuf_get_wh(pixbuf,wh)
-    sd size
-    sd stride
-    import "rgb_get_all_sizes" rgb_get_all_sizes
-    sd p_stride^stride
-    setcall size rgb_get_all_sizes(w,h,p_stride)
-    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-    sd bytes
-    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
-    sd newmem=0
-    #
-    sd row_col
-    setcall row_col stage_line_row_col()
-    sd add_rem
-    setcall add_rem stage_lines_add_remove()
-    if add_rem#==0
-        if row_col#==0
-            call img_row_add(#newmem,w,#h,number,stride,bytes,size)
-        else
-            call img_col_add(#newmem,#w,h,number,#stride,bytes)
-        endelse
-    else
-        if row_col#==0
-            call img_row_remove(#newmem,#h,number,stride,bytes)
-        else
-            call img_col_remove(#newmem,#w,h,number,#stride,bytes)
-        endelse
-    endelse
-    if newmem==0
-        return (void)
-    endif
-    #
-    importx "_gdk_pixbuf_new_from_data" gdk_pixbuf_new_from_data
-    importx "_free" free
-    data free_callback^free
-    sd newpixbuf
-    setcall newpixbuf gdk_pixbuf_new_from_data(newmem,(GDK_COLORSPACE_RGB),(FALSE),8,w,h,stride,free_callback,newmem)
-    if newpixbuf==0
-        call free(newmem)
-        return (void)
-    endif
-    #
-    sd ebox
-    setcall ebox stage_nthwidgetFromcontainer(img_nr)
-    sd oldpixbuf
-    setcall oldpixbuf object_get_dword_name(ebox)
-        #
-    call object_set_dword_name(ebox,newpixbuf)
-        #
-    importx "_g_object_unref" g_object_unref
-    call g_object_unref(oldpixbuf)
-endfunction
-import "memalloc" memalloc
-import "cpymem" cpymem
-
-#add
-
-function img_row_add(sd p_newmem,sd w,sd p_h,sd number,sd stride,ss bytes,sd size)
-    sd newsize
-    set newsize size
-    #
-    sd newrows
-    set newrows number
-    mult newrows 2
-    mult newrows stride
-    add newsize newrows
-    #
-    sd newmem
-    setcall newmem memalloc(newsize)
-    if newmem==0
-        return (void)
-    endif
-    set p_newmem# newmem
-    sd cursor
-    sd color
-    setcall color stage_line_color()
-    #
-    sd i_top=0
-    while i_top<number
-        sd j_top=0
-        set cursor newmem
-        while j_top<w
-            call cpymem(cursor,color,3)
-            add cursor 3
-            inc j_top
-        endwhile
-        add newmem stride
-        inc i_top
-    endwhile
-    call cpymem(newmem,bytes,size)
-    add newmem size
-    sd i_bottom=0
-    while i_bottom<number
-        sd j_bottom=0
-        set cursor newmem
-        while j_bottom<w
-            call cpymem(cursor,color,3)
-            add cursor 3
-            inc j_bottom
-        endwhile
-        add newmem stride
-        inc i_bottom
-    endwhile
-    #
-    add p_h# number
-    add p_h# number
-endfunction
-
-function img_col_add(sd p_newmem,sd p_w,sd h,sd number,sd p_stride,ss prevpixels)
-    import "rgb_get_rowstride" rgb_get_rowstride
-    sd newsize
-    sd newwidth
-    set newwidth p_w#
-    add newwidth number
-    add newwidth number
-    sd prevstride
-    set prevstride p_stride#
-    setcall p_stride# rgb_get_rowstride(newwidth)
-    set newsize p_stride#
-    mult newsize h
-    #
-    sd newmem
-    setcall newmem memalloc(newsize)
-    if newmem==0
-        return (void)
-    endif
-    set p_newmem# newmem
-    sd color
-    setcall color stage_line_color()
-    #
-    sd prev_row_size
-    set prev_row_size p_w#
-    mult prev_row_size 3
-    sd cursor
-    sd y=0
-    while y<h
-        set cursor newmem
-        #
-        sd x_left=0
-        while x_left<number
-            call cpymem(cursor,color,3)
-            add cursor 3
-            inc x_left
-        endwhile
-        #
-        call cpymem(cursor,prevpixels,prev_row_size)
-        add prevpixels prevstride
-        add cursor prev_row_size
-        #
-        sd x_right=0
-        while x_right<number
-            call cpymem(cursor,color,3)
-            add cursor 3
-            inc x_right
-        endwhile
-        #
-        add newmem p_stride#
-        inc y
-    endwhile
-    #
-    set p_w# newwidth
-endfunction
-
-#remove
-
-function img_row_remove(sd p_newmem,sd p_h,sd number,sd stride,ss prevpixels)
-    sd newrows
-    set newrows number
-    mult newrows 2
-    if newrows>=p_h#
-        call texter("remove rows error")
-        return (void)
-    endif
-    sub p_h# newrows
-    #
-    sd newsize
-    set newsize p_h#
-    mult newsize stride
-
-    sd newmem
-    setcall newmem memalloc(newsize)
-    if newmem==0
-        return (void)
-    endif
-    set p_newmem# newmem
-
-    sd removesize
-    set removesize number
-    mult removesize stride
-    add prevpixels removesize
-
-    call cpymem(newmem,prevpixels,newsize)
-endfunction
-
-function img_col_remove(sd p_newmem,sd p_w,sd h,sd number,sd p_stride,ss prevpixels)
-    sd newcols
-    set newcols number
-    mult newcols 2
-    if newcols>=p_w#
-        call texter("remove cols error")
-        return (void)
-    endif
-    sub p_w# newcols
-    #
-    sd newstride
-    setcall newstride rgb_get_rowstride(p_w#)
-    #
-    sd newsize
-    set newsize newstride
-    mult newsize h
-    #
-    sd newmem
-    setcall newmem memalloc(newsize)
-    if newmem==0
-        return (void)
-    endif
-    set p_newmem# newmem
-    #
-    sd removesize
-    set removesize number
-    mult removesize 3
-    sd copysize
-    set copysize p_w#
-    mult copysize 3
-    #
-    ss old_cursor
-    sd j=0
-    while j<h
-        set old_cursor prevpixels
-        #
-        add old_cursor removesize
-        call cpymem(newmem,old_cursor,copysize)
-        #
-        add newmem newstride
-        add prevpixels p_stride#
-        inc j
-    endwhile
-    set p_stride# newstride
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/frame/overlay.oc
@@ -0,0 +1,134 @@
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+function stage_overlay()
+    import "stage_frame_dialog" stage_frame_dialog
+    sd init^stage_overlay_init
+    sd set^stage_overlay_set
+    ss title="Image overlay"
+    call stage_frame_dialog(init,set,title)
+endfunction
+
+function stage_overlay_file(sd action,sd value)
+    data file#1
+    if action=(value_set)
+        set file value
+    else
+        return file
+    endelse
+endfunction
+
+function stage_overlay_init(sd vbox,sd *dialog)
+    #overlay file location
+    import "fchooserbuttonfield_open_label" fchooserbuttonfield_open_label
+    ss text="File "
+    sd file
+    setcall file fchooserbuttonfield_open_label(vbox,text)
+    call stage_overlay_file((value_set),file)
+
+    import "stage_effect_orientation" stage_effect_orientation
+    str position="Placement"
+    call stage_effect_orientation((value_set),vbox,(TRUE),position)
+endfunction
+
+function stage_overlay_set()
+    sd file_entry
+    setcall file_entry stage_overlay_file((value_get))
+
+    import "file_chooser_get_fname" file_chooser_get_fname
+    sd filename
+    setcall filename file_chooser_get_fname(file_entry)
+
+    if filename=0
+        return 0
+    endif
+
+    import "pixbuf_from_file" pixbuf_from_file
+    sd overlay
+    setcall overlay pixbuf_from_file(filename)
+
+    importx "_g_free" g_free
+    call g_free(filename)
+
+    if overlay=0
+        return 0
+    endif
+
+    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
+    sd layer
+    sd p_layer^layer
+    call stage_get_sel_pixbuf(p_layer)
+
+    sd x_factor
+    sd y_factor
+    sd p_y_factor^y_factor
+    setcall x_factor stage_effect_orientation((value_get),p_y_factor)
+
+    import "pixbuf_get_wh" pixbuf_get_wh
+    sd over_width
+    sd over_height
+    sd lay_width
+    sd lay_height
+    sd over^over_width
+    sd lay^lay_width
+    call pixbuf_get_wh(overlay,over)
+    call pixbuf_get_wh(layer,lay)
+
+    sd min_i
+    sd max_i
+    if over_width>lay_width
+        #the over image width is greater than the lay width
+        set min_i 0
+        set max_i lay_width
+    else
+        if x_factor=-1
+            set min_i 0
+        else
+            sd x_space
+            set x_space lay_width
+            sub x_space over_width
+            if x_factor=0
+                div x_space 2
+                set min_i x_space
+            else
+                set min_i x_space
+            endelse
+        endelse
+        set max_i min_i
+        add max_i over_width
+    endelse
+    sd min_j
+    sd max_j
+    if over_height>lay_height
+        #the over image height is greater than the lay height
+        set min_j 0
+        set max_j lay_height
+    else
+        if y_factor=-1
+            set min_j 0
+        else
+            sd y_space
+            set y_space lay_height
+            sub y_space over_height
+            if y_factor=0
+                div y_space 2
+                set min_j y_space
+            else
+                set min_j y_space
+            endelse
+        endelse
+        set max_j min_j
+        add max_j over_height
+    endelse
+
+    import "pixbuf_over_pixbuf" pixbuf_over_pixbuf
+    call pixbuf_over_pixbuf(overlay,layer,min_i,max_i,min_j,max_j)
+
+    import "stage_redraw" stage_redraw
+    call stage_redraw()
+endfunction
+
--- ovideo-1.orig/src/_prepare/frame/overlay.s
+++ /dev/null
@@ -1,134 +0,0 @@
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-function stage_overlay()
-    import "stage_frame_dialog" stage_frame_dialog
-    sd init^stage_overlay_init
-    sd set^stage_overlay_set
-    ss title="Image overlay"
-    call stage_frame_dialog(init,set,title)
-endfunction
-
-function stage_overlay_file(sd action,sd value)
-    data file#1
-    if action==(value_set)
-        set file value
-    else
-        return file
-    endelse
-endfunction
-
-function stage_overlay_init(sd vbox,sd *dialog)
-    #overlay file location
-    import "fchooserbuttonfield_open_label" fchooserbuttonfield_open_label
-    ss text="File "
-    sd file
-    setcall file fchooserbuttonfield_open_label(vbox,text)
-    call stage_overlay_file((value_set),file)
-
-    import "stage_effect_orientation" stage_effect_orientation
-    str position="Placement"
-    call stage_effect_orientation((value_set),vbox,(TRUE),position)
-endfunction
-
-function stage_overlay_set()
-    sd file_entry
-    setcall file_entry stage_overlay_file((value_get))
-
-    import "file_chooser_get_fname" file_chooser_get_fname
-    sd filename
-    setcall filename file_chooser_get_fname(file_entry)
-
-    if filename==0
-        return 0
-    endif
-
-    import "pixbuf_from_file" pixbuf_from_file
-    sd overlay
-    setcall overlay pixbuf_from_file(filename)
-
-    importx "_g_free" g_free
-    call g_free(filename)
-
-    if overlay==0
-        return 0
-    endif
-
-    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
-    sd layer
-    sd p_layer^layer
-    call stage_get_sel_pixbuf(p_layer)
-
-    sd x_factor
-    sd y_factor
-    sd p_y_factor^y_factor
-    setcall x_factor stage_effect_orientation((value_get),p_y_factor)
-
-    import "pixbuf_get_wh" pixbuf_get_wh
-    sd over_width
-    sd over_height
-    sd lay_width
-    sd lay_height
-    sd over^over_width
-    sd lay^lay_width
-    call pixbuf_get_wh(overlay,over)
-    call pixbuf_get_wh(layer,lay)
-
-    sd min_i
-    sd max_i
-    if over_width>lay_width
-        #the over image width is greater than the lay width
-        set min_i 0
-        set max_i lay_width
-    else
-        if x_factor==-1
-            set min_i 0
-        else
-            sd x_space
-            set x_space lay_width
-            sub x_space over_width
-            if x_factor==0
-                div x_space 2
-                set min_i x_space
-            else
-                set min_i x_space
-            endelse
-        endelse
-        set max_i min_i
-        add max_i over_width
-    endelse
-    sd min_j
-    sd max_j
-    if over_height>lay_height
-        #the over image height is greater than the lay height
-        set min_j 0
-        set max_j lay_height
-    else
-        if y_factor==-1
-            set min_j 0
-        else
-            sd y_space
-            set y_space lay_height
-            sub y_space over_height
-            if y_factor==0
-                div y_space 2
-                set min_j y_space
-            else
-                set min_j y_space
-            endelse
-        endelse
-        set max_j min_j
-        add max_j over_height
-    endelse
-
-    import "pixbuf_over_pixbuf" pixbuf_over_pixbuf
-    call pixbuf_over_pixbuf(overlay,layer,min_i,max_i,min_j,max_j)
-
-    import "stage_redraw" stage_redraw
-    call stage_redraw()
-endfunction
-
--- /dev/null
+++ ovideo-1/src/_prepare/frame/pencil.oc
@@ -0,0 +1,504 @@
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+importx "_gtk_widget_get_window" gtk_widget_get_window
+
+const stage_pencil_pixbuf_set=0
+const stage_pencil_pixbuf_get=1
+#const stage_pencil_pixbuf_on_ok=2
+#pixbuf
+function stage_pencil_pixbuf(sd action,sd value)
+    data pixbuf#1
+    if action=(stage_pencil_pixbuf_set)
+        set pixbuf value
+    elseif action=(stage_pencil_pixbuf_get)
+        return pixbuf
+    else
+    #if action==(stage_pencil_on_ok)
+    endelse
+endfunction
+
+const stage_pencil_cursor_set=0
+const stage_pencil_cursor_get=1
+const stage_pencil_cursor_free=2
+
+importx "_g_object_unref" g_object_unref
+
+#cursor
+function stage_pencil_cursor(sd action)
+    data cursor#1
+    if action=(stage_pencil_cursor_set)
+        importx "_gdk_cursor_new" gdk_cursor_new
+        setcall cursor gdk_cursor_new((GDK_PENCIL))
+    elseif action=(stage_pencil_cursor_get)
+        return cursor
+    else
+        importx "_gdk_cursor_unref" gdk_cursor_unref
+        call gdk_cursor_unref(cursor)
+    #if action==(stage_pencil_cursor_free)
+    endelse
+endfunction
+
+#color widget
+function stage_pencil_color(sd action,sd value)
+    data color#1
+    if action=(value_set)
+        set color value
+    else
+    #if action==(value_get)
+        return color
+    endelse
+endfunction
+
+#draw widget
+function stage_pencil_draw(sd action,sd value)
+    data drawfield#1
+    if action=(value_set)
+        set drawfield value
+    else
+    #if action==(value_get)
+        return drawfield
+    endelse
+endfunction
+
+function stage_pencil_zoomvalue(sd action,sd value)
+    data zoomfield#1
+    if action=(value_set)
+        set zoomfield value
+    else
+        import "hscale_get" hscale_get
+        sd pos
+        setcall pos hscale_get(zoomfield)
+        return pos
+    endelse
+endfunction
+
+function stage_pencil_size_entry()
+    data size_entry#1
+    return #size_entry
+endfunction
+
+##parts fns
+
+
+function stage_pencil()
+    sd pixbuf=0
+    sd p_pixbuf^pixbuf
+    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
+    call stage_get_sel_pixbuf(p_pixbuf)
+    if pixbuf=0
+        return 0
+    endif
+
+    import "pixbuf_copy" pixbuf_copy
+    sd workingpixbuf
+    setcall workingpixbuf pixbuf_copy(pixbuf)
+    if workingpixbuf=0
+        return 0
+    endif
+    call stage_pencil_pixbuf((stage_pencil_pixbuf_set),workingpixbuf)
+
+    #cursor in
+    call stage_pencil_cursor((stage_pencil_cursor_set))
+    #
+
+    import "stage_frame_dialog" stage_frame_dialog
+    ss title="Pencil window"
+    data init^stage_pencil_init
+    data on_ok^stage_pencil_set
+    call stage_frame_dialog(init,on_ok,title)
+
+    #cursor out
+    call stage_pencil_cursor((stage_pencil_cursor_free))
+    #
+
+    #unref the pixbuf, if required
+    setcall workingpixbuf stage_pencil_pixbuf((stage_pencil_pixbuf_get))
+    if workingpixbuf!=0
+        call g_object_unref(workingpixbuf)
+    endif
+endfunction
+
+importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
+
+const visible_area_width=640
+const visible_area_height=480
+
+function stage_pencil_init(sd vbox,sd *dialog)
+    import "hboxfield_cnt" hboxfield_cnt
+    sd hbox
+    setcall hbox hboxfield_cnt(vbox)
+    #
+    importx "_gtk_hbox_new" gtk_hbox_new
+    import "labelfield_l" labelfield_l
+    import "packstart_default" packstart_default
+    ss color="Pencil Color: "
+    sd colorwidget
+    sd color_hbox
+    setcall color_hbox gtk_hbox_new(0,0)
+    call labelfield_l(color,color_hbox)
+    importx "_gtk_color_button_new" gtk_color_button_new
+    setcall colorwidget gtk_color_button_new()
+    call packstart_default(color_hbox,colorwidget)
+    call stage_pencil_color((value_set),colorwidget)
+    call packstart_default(hbox,color_hbox)
+    #
+    importx "_gtk_vseparator_new" gtk_vseparator_new
+    sd sep
+    setcall sep gtk_vseparator_new()
+    call packstart_default(hbox,sep)
+    #pencil size
+    import "editfield_pack" editfield_pack
+    sd penc_sz_hbox
+    sd sz_en
+    setcall sz_en stage_pencil_size_entry()
+    str lb="Pencil size: "
+    setcall penc_sz_hbox gtk_hbox_new(0,0)
+    call labelfield_l(lb,penc_sz_hbox)
+    setcall sz_en# editfield_pack(penc_sz_hbox)
+    call packstart_default(hbox,penc_sz_hbox)
+    #
+    setcall sep gtk_vseparator_new()
+    call packstart_default(hbox,sep)
+    #
+    import "labelfield_left_default" labelfield_left_default
+    ss zm="Zoom"
+    call labelfield_left_default(zm,hbox)
+    import "hscalefield" hscalefield
+    sd zoom_wd
+    setcall zoom_wd hscalefield(hbox,1,16,1,1)
+    call stage_pencil_zoomvalue((value_set),zoom_wd)
+
+    import "scrollfield" scrollfield
+    sd scroll
+    setcall scroll scrollfield(vbox)
+    call gtk_widget_set_size_request(scroll,(visible_area_width),(visible_area_height))
+
+    import "eventboxfield_cnt" eventboxfield_cnt
+    sd ebox
+    setcall ebox eventboxfield_cnt(scroll)
+    import "drawfield_cnt" drawfield_cnt
+    sd drawing
+    setcall drawing drawfield_cnt(ebox)
+    call stage_pencil_draw((value_set),drawing)
+    #set the draw width knowing the zoom
+    call stage_pencil_drawsize()
+
+    import "connect_signal" connect_signal
+
+    #at main realize
+    str rel="realize"
+    data rel_fn^stage_pencil_realize
+    call connect_signal(drawing,rel,rel_fn)
+
+    #at expose draw the pixbuf
+    str expose="expose-event"
+    data exp^stage_pencil_expose
+    call connect_signal(drawing,expose,exp)
+
+    #zoom level changed
+    str ch="value-changed"
+    data changed^stage_pencil_drawsize
+    call connect_signal(zoom_wd,ch,changed)
+
+    #on click is the pencil color point
+    str press="button-press-event"
+    data clickfunction^stage_pencil_setpixel
+    call connect_signal(ebox,press,clickfunction)
+
+    #on mouse moving
+    str motion="motion-notify-event"
+    data motionfunction^stage_pencil_motion
+    call connect_signal(ebox,motion,motionfunction)
+
+    importx "_gtk_widget_add_events" gtk_widget_add_events
+    call gtk_widget_add_events(ebox,(GDK_BUTTON_PRESS_MASK|GDK_POINTER_MOTION_MASK))
+endfunction
+
+function stage_pencil_set()
+    sd workingpixbuf
+    setcall workingpixbuf stage_pencil_pixbuf((stage_pencil_pixbuf_get))
+    import "stage_sel_replace_pixbuf" stage_sel_replace_pixbuf
+    call stage_sel_replace_pixbuf(workingpixbuf)
+
+    #set 0 for not unreference it at the exit
+    call stage_pencil_pixbuf((stage_pencil_pixbuf_set),0)
+endfunction
+
+
+
+##signals
+
+function stage_pencil_realize(sd drawing,sd *data)
+    #pencil cursor over drawing area
+    importx "_gdk_window_set_cursor" gdk_window_set_cursor
+    sd window
+    setcall window gtk_widget_get_window(drawing)
+    sd cursor
+    setcall cursor stage_pencil_cursor((stage_pencil_cursor_get))
+    call gdk_window_set_cursor(window,cursor)
+endfunction
+
+importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+
+#bool false, continue events
+function stage_pencil_setpixel(sd *ebox,sd event,sd *data)
+    #get draw widget
+    sd drawfield
+    setcall drawfield stage_pencil_draw((value_get))
+    #get coords
+    import "eventbutton_get_coords" eventbutton_get_coords
+    sd mouse_x
+    sd mouse_y
+    sd p_mouse_y^mouse_y
+    setcall mouse_x eventbutton_get_coords(event,p_mouse_y)
+    #get the color
+    sd color_widget
+    setcall color_widget stage_pencil_color((value_get))
+    #convert to rgb
+    import "color_widget_get_color_to_rgb" color_widget_get_color_to_rgb
+    sd color
+    setcall color color_widget_get_color_to_rgb(color_widget)
+    #from little to big
+    import "dword_reverse" dword_reverse
+    setcall color dword_reverse(color)
+    #get pixbuf and zoom
+    sd pixbuf
+    setcall pixbuf stage_pencil_pixbuf((stage_pencil_pixbuf_get))
+    sd zoom_count
+    setcall zoom_count stage_pencil_zoomvalue((value_get))
+
+    #adjust to zoom
+    div mouse_x zoom_count
+    div mouse_y zoom_count
+    #get the pencil size
+    sd sz_en
+    setcall sz_en stage_pencil_size_entry()
+    import "memtoint" memtoint
+    importx "_gtk_entry_get_text" gtk_entry_get_text
+    import "slen" slen
+    sd pixel_value
+    ss txt
+    setcall txt gtk_entry_get_text(sz_en#)
+    sd sz
+    setcall sz slen(txt)
+    sd bool
+    setcall bool memtoint(txt,sz,#pixel_value)
+    if bool=(FALSE)
+        set pixel_value 1
+    elseif pixel_value<1
+        set pixel_value 1
+    endelseif
+    #test for be on the pixbuf
+    sd px_width
+    sd px_height
+    setcall px_width gdk_pixbuf_get_width(pixbuf)
+    setcall px_height gdk_pixbuf_get_height(pixbuf)
+	if mouse_x<0
+        return 0
+	endif
+	if mouse_y<0
+        return 0
+	endif
+	if mouse_x>=px_width
+        return 0
+	endif
+	if mouse_y>=px_height
+        return 0
+	endif
+    sd mouse_x_max
+    set mouse_x_max mouse_x
+    add mouse_x_max pixel_value
+    if mouse_x_max>px_width
+        set mouse_x_max px_width
+    endif
+    sd mouse_y_max
+    set mouse_y_max mouse_y
+    add mouse_y_max pixel_value
+    if mouse_y_max>px_height
+        set mouse_y_max px_height
+    endif
+    #set the pixel
+    sd x_cursor
+    sd y_cursor
+    set y_cursor mouse_y
+    while y_cursor<mouse_y_max
+        set x_cursor mouse_x
+        while x_cursor<mouse_x_max
+            import "pixbuf_set_pixel" pixbuf_set_pixel
+            call pixbuf_set_pixel(pixbuf,color,x_cursor,y_cursor)
+            inc x_cursor
+        endwhile
+        inc y_cursor
+    endwhile
+    #redraw the new area
+    #get width and height size
+    sd width_size
+    set width_size mouse_x_max
+    sub width_size mouse_x
+    sd height_size
+    set height_size mouse_y_max
+    sub height_size mouse_y
+    #get rect
+    mult mouse_x zoom_count
+    mult mouse_y zoom_count
+    sd left
+    sd top
+    sd width
+    sd height
+    sd rect^left
+    #set rect
+    set left mouse_x
+    set top mouse_y
+    set width zoom_count
+    set height zoom_count
+    mult width width_size
+    mult height height_size
+    #redraw
+    importx "_gdk_window_invalidate_rect" gdk_window_invalidate_rect
+    sd window
+    setcall window gtk_widget_get_window(drawfield)
+    call gdk_window_invalidate_rect(window,rect,0)
+    #return
+    return (FALSE)
+endfunction
+
+#bool false to continue
+function stage_pencil_motion(sd *widget,sd EventMotion,sd *data)
+    sd state
+    sd p_state^state
+    importx "_gdk_event_get_state" gdk_event_get_state
+    call gdk_event_get_state(EventMotion,p_state)
+    and state (GDK_BUTTON1_MASK)
+    if state!=0
+        call stage_pencil_setpixel(0,EventMotion)
+    endif
+    return (FALSE)
+endfunction
+
+const expose_return=FALSE
+#bool false to propagate
+function stage_pencil_expose(sd drawwidget,sd ev_expose,sd *data)
+    #ev_expose
+    sd draw_left
+    sd draw_top
+
+    sd left
+    sd top
+    sd right
+    sd bottom
+    #GdkEventType type;
+    #GdkWindow *window;
+    #gint8 send_event;
+    #GdkRectangle area;
+    #GdkRegion *region;
+    #gint count;
+
+    #get rect: left top width height; and zoom multiplier
+    import "structure_get_int" structure_get_int
+    setcall draw_left structure_get_int(ev_expose,(ev_expose_left))
+    set left draw_left
+    setcall draw_top structure_get_int(ev_expose,(4*DWORD))
+    set top draw_top
+    sd width
+    sd height
+    setcall width structure_get_int(ev_expose,(ev_expose_width))
+    setcall height structure_get_int(ev_expose,(6*DWORD))
+    sd zoom_count
+    setcall zoom_count stage_pencil_zoomvalue((value_get))
+    #to normal size
+    div left zoom_count
+    div top zoom_count
+    div width zoom_count
+    div height zoom_count
+    #more at rect for unpainted spaces(left top take floor, +1; width height can also take floor, +1)
+    add width 2
+    add height 2
+    #pixbuf width and height
+    sd px_width
+    sd px_height
+    sd pixbuf
+    setcall pixbuf stage_pencil_pixbuf((stage_pencil_pixbuf_get))
+    setcall px_width gdk_pixbuf_get_width(pixbuf)
+    setcall px_height gdk_pixbuf_get_height(pixbuf)
+    #corrections
+    if left<0
+        set left 0
+    endif
+    if top<0
+        set top 0
+    endif
+    #rigth and bottom
+    set right left
+    add right width
+    set bottom top
+    add bottom height
+    #get real right,bottom, correct width,height
+    if right>px_width
+        set right px_width
+        set width px_width
+        sub width left
+    endif
+    if bottom>px_height
+        set bottom px_height
+        set height px_height
+        sub height top
+    endif
+    #input event sometimes has negative width,height
+    if width<0
+        return (expose_return)
+    endif
+    if height<0
+        return (expose_return)
+    endif
+    #get pixbuf to draw
+    import "pixbuf_new_subpixels" pixbuf_new_subpixels
+    sd sub_pixbuf
+    setcall sub_pixbuf pixbuf_new_subpixels(pixbuf,left,top,right,bottom)
+    if sub_pixbuf!=0
+        import "pixbuf_scale" pixbuf_scale
+        sd zoomed_pixbuf
+        mult left zoom_count
+        mult top zoom_count
+        mult width zoom_count
+        mult height zoom_count
+        setcall zoomed_pixbuf pixbuf_scale(sub_pixbuf,width,height)
+        if zoomed_pixbuf!=0
+            sd drawable
+            setcall drawable gtk_widget_get_window(drawwidget)
+            importx "_gdk_draw_pixbuf" gdk_draw_pixbuf
+            call gdk_draw_pixbuf(drawable,0,zoomed_pixbuf,0,0,left,top,width,height,(GDK_RGB_DITHER_NONE),0,0)
+            call g_object_unref(zoomed_pixbuf)
+        endif
+        call g_object_unref(sub_pixbuf)
+    endif
+    return (expose_return)
+endfunction
+
+
+##other fns
+
+function stage_pencil_drawsize()
+    sd zoom_count
+    setcall zoom_count stage_pencil_zoomvalue((value_get))
+
+    sd width
+    sd height
+    sd pixbuf
+    setcall pixbuf stage_pencil_pixbuf((stage_pencil_pixbuf_get))
+    setcall width gdk_pixbuf_get_width(pixbuf)
+    setcall height gdk_pixbuf_get_height(pixbuf)
+
+    mult width zoom_count
+    mult height zoom_count
+
+    sd drawwidg
+    setcall drawwidg stage_pencil_draw((value_get))
+
+    call gtk_widget_set_size_request(drawwidg,width,height)
+endfunction
--- ovideo-1.orig/src/_prepare/frame/pencil.s
+++ /dev/null
@@ -1,501 +0,0 @@
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-importx "_gtk_widget_get_window" gtk_widget_get_window
-
-const stage_pencil_pixbuf_set=0
-const stage_pencil_pixbuf_get=1
-#const stage_pencil_pixbuf_on_ok=2
-#pixbuf
-function stage_pencil_pixbuf(sd action,sd value)
-    data pixbuf#1
-    if action==(stage_pencil_pixbuf_set)
-        set pixbuf value
-    elseif action==(stage_pencil_pixbuf_get)
-        return pixbuf
-    else
-    #if action==(stage_pencil_on_ok)
-    endelse
-endfunction
-
-const stage_pencil_cursor_set=0
-const stage_pencil_cursor_get=1
-const stage_pencil_cursor_free=2
-
-importx "_g_object_unref" g_object_unref
-
-#cursor
-function stage_pencil_cursor(sd action)
-    data cursor#1
-    if action==(stage_pencil_cursor_set)
-        importx "_gdk_cursor_new" gdk_cursor_new
-        setcall cursor gdk_cursor_new((GDK_PENCIL))
-    elseif action==(stage_pencil_cursor_get)
-        return cursor
-    else
-        importx "_gdk_cursor_unref" gdk_cursor_unref
-        call gdk_cursor_unref(cursor)
-    #if action==(stage_pencil_cursor_free)
-    endelse
-endfunction
-
-#color widget
-function stage_pencil_color(sd action,sd value)
-    data color#1
-    if action==(value_set)
-        set color value
-    else
-    #if action==(value_get)
-        return color
-    endelse
-endfunction
-
-#draw widget
-function stage_pencil_draw(sd action,sd value)
-    data drawfield#1
-    if action==(value_set)
-        set drawfield value
-    else
-    #if action==(value_get)
-        return drawfield
-    endelse
-endfunction
-
-function stage_pencil_zoomvalue(sd action,sd value)
-    data zoomfield#1
-    if action==(value_set)
-        set zoomfield value
-    else
-        import "hscale_get" hscale_get
-        sd pos
-        setcall pos hscale_get(zoomfield)
-        return pos
-    endelse
-endfunction
-
-function stage_pencil_size_entry()
-    data size_entry#1
-    return #size_entry
-endfunction
-
-##parts fns
-
-
-function stage_pencil()
-    sd pixbuf=0
-    sd p_pixbuf^pixbuf
-    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
-    call stage_get_sel_pixbuf(p_pixbuf)
-    if pixbuf==0
-        return 0
-    endif
-
-    import "pixbuf_copy" pixbuf_copy
-    sd workingpixbuf
-    setcall workingpixbuf pixbuf_copy(pixbuf)
-    if workingpixbuf==0
-        return 0
-    endif
-    call stage_pencil_pixbuf((stage_pencil_pixbuf_set),workingpixbuf)
-
-    #cursor in
-    call stage_pencil_cursor((stage_pencil_cursor_set))
-    #
-
-    import "stage_frame_dialog" stage_frame_dialog
-    ss title="Pencil window"
-    data init^stage_pencil_init
-    data on_ok^stage_pencil_set
-    call stage_frame_dialog(init,on_ok,title)
-
-    #cursor out
-    call stage_pencil_cursor((stage_pencil_cursor_free))
-    #
-
-    #unref the pixbuf, if required
-    setcall workingpixbuf stage_pencil_pixbuf((stage_pencil_pixbuf_get))
-    if workingpixbuf!=0
-        call g_object_unref(workingpixbuf)
-    endif
-endfunction
-
-importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
-
-const visible_area_width=640
-const visible_area_height=480
-
-function stage_pencil_init(sd vbox,sd *dialog)
-    import "hboxfield_cnt" hboxfield_cnt
-    sd hbox
-    setcall hbox hboxfield_cnt(vbox)
-    #
-    importx "_gtk_hbox_new" gtk_hbox_new
-    import "labelfield_l" labelfield_l
-    import "packstart_default" packstart_default
-    ss color="Pencil Color: "
-    sd colorwidget
-    sd color_hbox
-    setcall color_hbox gtk_hbox_new(0,0)
-    call labelfield_l(color,color_hbox)
-    importx "_gtk_color_button_new" gtk_color_button_new
-    setcall colorwidget gtk_color_button_new()
-    call packstart_default(color_hbox,colorwidget)
-    call stage_pencil_color((value_set),colorwidget)
-    call packstart_default(hbox,color_hbox)
-    #
-    importx "_gtk_vseparator_new" gtk_vseparator_new
-    sd sep
-    setcall sep gtk_vseparator_new()
-    call packstart_default(hbox,sep)
-    #pencil size
-    import "editfield_pack" editfield_pack
-    sd penc_sz_hbox
-    sd sz_en
-    setcall sz_en stage_pencil_size_entry()
-    str lb="Pencil size: "
-    setcall penc_sz_hbox gtk_hbox_new(0,0)
-    call labelfield_l(lb,penc_sz_hbox)
-    setcall sz_en# editfield_pack(penc_sz_hbox)
-    call packstart_default(hbox,penc_sz_hbox)
-    #
-    setcall sep gtk_vseparator_new()
-    call packstart_default(hbox,sep)
-    #
-    import "labelfield_left_default" labelfield_left_default
-    ss zm="Zoom"
-    call labelfield_left_default(zm,hbox)
-    import "hscalefield" hscalefield
-    sd zoom_wd
-    setcall zoom_wd hscalefield(hbox,1,16,1,1)
-    call stage_pencil_zoomvalue((value_set),zoom_wd)
-
-    import "scrollfield" scrollfield
-    sd scroll
-    setcall scroll scrollfield(vbox)
-    call gtk_widget_set_size_request(scroll,(visible_area_width),(visible_area_height))
-
-    import "eventboxfield_cnt" eventboxfield_cnt
-    sd ebox
-    setcall ebox eventboxfield_cnt(scroll)
-    import "drawfield_cnt" drawfield_cnt
-    sd drawing
-    setcall drawing drawfield_cnt(ebox)
-    call stage_pencil_draw((value_set),drawing)
-    #set the draw width knowing the zoom
-    call stage_pencil_drawsize()
-
-    import "connect_signal" connect_signal
-
-    #at main realize
-    str rel="realize"
-    data rel_fn^stage_pencil_realize
-    call connect_signal(drawing,rel,rel_fn)
-
-    #at expose draw the pixbuf
-    str expose="expose-event"
-    data exp^stage_pencil_expose
-    call connect_signal(drawing,expose,exp)
-
-    #zoom level changed
-    str ch="value-changed"
-    data changed^stage_pencil_drawsize
-    call connect_signal(zoom_wd,ch,changed)
-
-    #on click is the pencil color point
-    str press="button-press-event"
-    data clickfunction^stage_pencil_setpixel
-    call connect_signal(ebox,press,clickfunction)
-
-    #on mouse moving
-    str motion="motion-notify-event"
-    data motionfunction^stage_pencil_motion
-    call connect_signal(ebox,motion,motionfunction)
-
-    importx "_gtk_widget_add_events" gtk_widget_add_events
-    call gtk_widget_add_events(ebox,(GDK_BUTTON_PRESS_MASK|GDK_POINTER_MOTION_MASK))
-endfunction
-
-function stage_pencil_set()
-    sd workingpixbuf
-    setcall workingpixbuf stage_pencil_pixbuf((stage_pencil_pixbuf_get))
-    import "stage_sel_replace_pixbuf" stage_sel_replace_pixbuf
-    call stage_sel_replace_pixbuf(workingpixbuf)
-
-    #set 0 for not unreference it at the exit
-    call stage_pencil_pixbuf((stage_pencil_pixbuf_set),0)
-endfunction
-
-
-
-##signals
-
-function stage_pencil_realize(sd drawing,sd *data)
-    #pencil cursor over drawing area
-    importx "_gdk_window_set_cursor" gdk_window_set_cursor
-    sd window
-    setcall window gtk_widget_get_window(drawing)
-    sd cursor
-    setcall cursor stage_pencil_cursor((stage_pencil_cursor_get))
-    call gdk_window_set_cursor(window,cursor)
-endfunction
-
-importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-
-#bool false, continue events
-function stage_pencil_setpixel(sd *ebox,sd event,sd *data)
-    #get draw widget
-    sd drawfield
-    setcall drawfield stage_pencil_draw((value_get))
-    #get coords
-    import "eventbutton_get_coords" eventbutton_get_coords
-    sd mouse_x
-    sd mouse_y
-    sd p_mouse_y^mouse_y
-    setcall mouse_x eventbutton_get_coords(event,p_mouse_y)
-    #get the color
-    sd color_widget
-    setcall color_widget stage_pencil_color((value_get))
-    #convert to rgb
-    import "color_widget_get_color_to_rgb" color_widget_get_color_to_rgb
-    sd color
-    setcall color color_widget_get_color_to_rgb(color_widget)
-    #from little to big
-    import "dword_reverse" dword_reverse
-    setcall color dword_reverse(color)
-    #get pixbuf and zoom
-    sd pixbuf
-    setcall pixbuf stage_pencil_pixbuf((stage_pencil_pixbuf_get))
-    sd zoom_count
-    setcall zoom_count stage_pencil_zoomvalue((value_get))
-
-    #adjust to zoom
-    div mouse_x zoom_count
-    div mouse_y zoom_count
-    #get the pencil size
-    sd sz_en
-    setcall sz_en stage_pencil_size_entry()
-    import "memtoint" memtoint
-    importx "_gtk_entry_get_text" gtk_entry_get_text
-    import "slen" slen
-    sd pixel_value
-    ss txt
-    setcall txt gtk_entry_get_text(sz_en#)
-    sd sz
-    setcall sz slen(txt)
-    sd bool
-    setcall bool memtoint(txt,sz,#pixel_value)
-    if bool==(FALSE)
-        set pixel_value 1
-    elseif pixel_value<1
-        set pixel_value 1
-    endelseif
-    #test for be on the pixbuf
-    sd px_width
-    sd px_height
-    setcall px_width gdk_pixbuf_get_width(pixbuf)
-    setcall px_height gdk_pixbuf_get_height(pixbuf)
-    if mouse_x<0
-        return 0
-    elseif mouse_y<0
-        return 0
-    elseif mouse_x>=px_width
-        return 0
-    elseif mouse_y>=px_height
-        return 0
-    endelseif
-    sd mouse_x_max
-    set mouse_x_max mouse_x
-    add mouse_x_max pixel_value
-    if mouse_x_max>px_width
-        set mouse_x_max px_width
-    endif
-    sd mouse_y_max
-    set mouse_y_max mouse_y
-    add mouse_y_max pixel_value
-    if mouse_y_max>px_height
-        set mouse_y_max px_height
-    endif
-    #set the pixel
-    sd x_cursor
-    sd y_cursor
-    set y_cursor mouse_y
-    while y_cursor<mouse_y_max
-        set x_cursor mouse_x
-        while x_cursor<mouse_x_max
-            import "pixbuf_set_pixel" pixbuf_set_pixel
-            call pixbuf_set_pixel(pixbuf,color,x_cursor,y_cursor)
-            inc x_cursor
-        endwhile
-        inc y_cursor
-    endwhile
-    #redraw the new area
-    #get width and height size
-    sd width_size
-    set width_size mouse_x_max
-    sub width_size mouse_x
-    sd height_size
-    set height_size mouse_y_max
-    sub height_size mouse_y
-    #get rect
-    mult mouse_x zoom_count
-    mult mouse_y zoom_count
-    sd left
-    sd top
-    sd width
-    sd height
-    sd rect^left
-    #set rect
-    set left mouse_x
-    set top mouse_y
-    set width zoom_count
-    set height zoom_count
-    mult width width_size
-    mult height height_size
-    #redraw
-    importx "_gdk_window_invalidate_rect" gdk_window_invalidate_rect
-    sd window
-    setcall window gtk_widget_get_window(drawfield)
-    call gdk_window_invalidate_rect(window,rect,0)
-    #return
-    return (FALSE)
-endfunction
-
-#bool false to continue
-function stage_pencil_motion(sd *widget,sd EventMotion,sd *data)
-    sd state
-    sd p_state^state
-    importx "_gdk_event_get_state" gdk_event_get_state
-    call gdk_event_get_state(EventMotion,p_state)
-    and state (GDK_BUTTON1_MASK)
-    if state!=0
-        call stage_pencil_setpixel(0,EventMotion)
-    endif
-    return (FALSE)
-endfunction
-
-const expose_return=FALSE
-#bool false to propagate
-function stage_pencil_expose(sd drawwidget,sd ev_expose,sd *data)
-    #ev_expose
-    sd draw_left
-    sd draw_top
-
-    sd left
-    sd top
-    sd right
-    sd bottom
-    #GdkEventType type;
-    #GdkWindow *window;
-    #gint8 send_event;
-    #GdkRectangle area;
-    #GdkRegion *region;
-    #gint count;
-
-    #get rect: left top width height; and zoom multiplier
-    import "structure_get_int" structure_get_int
-    setcall draw_left structure_get_int(ev_expose,(ev_expose_left))
-    set left draw_left
-    setcall draw_top structure_get_int(ev_expose,(4*DWORD))
-    set top draw_top
-    sd width
-    sd height
-    setcall width structure_get_int(ev_expose,(ev_expose_width))
-    setcall height structure_get_int(ev_expose,(6*DWORD))
-    sd zoom_count
-    setcall zoom_count stage_pencil_zoomvalue((value_get))
-    #to normal size
-    div left zoom_count
-    div top zoom_count
-    div width zoom_count
-    div height zoom_count
-    #more at rect for unpainted spaces(left top take floor, +1; width height can also take floor, +1)
-    add width 2
-    add height 2
-    #pixbuf width and height
-    sd px_width
-    sd px_height
-    sd pixbuf
-    setcall pixbuf stage_pencil_pixbuf((stage_pencil_pixbuf_get))
-    setcall px_width gdk_pixbuf_get_width(pixbuf)
-    setcall px_height gdk_pixbuf_get_height(pixbuf)
-    #corrections
-    if left<0
-        set left 0
-    endif
-    if top<0
-        set top 0
-    endif
-    #rigth and bottom
-    set right left
-    add right width
-    set bottom top
-    add bottom height
-    #get real right,bottom, correct width,height
-    if right>px_width
-        set right px_width
-        set width px_width
-        sub width left
-    endif
-    if bottom>px_height
-        set bottom px_height
-        set height px_height
-        sub height top
-    endif
-    #input event sometimes has negative width,height
-    if width<0
-        return (expose_return)
-    endif
-    if height<0
-        return (expose_return)
-    endif
-    #get pixbuf to draw
-    import "pixbuf_new_subpixels" pixbuf_new_subpixels
-    sd sub_pixbuf
-    setcall sub_pixbuf pixbuf_new_subpixels(pixbuf,left,top,right,bottom)
-    if sub_pixbuf!=0
-        import "pixbuf_scale" pixbuf_scale
-        sd zoomed_pixbuf
-        mult left zoom_count
-        mult top zoom_count
-        mult width zoom_count
-        mult height zoom_count
-        setcall zoomed_pixbuf pixbuf_scale(sub_pixbuf,width,height)
-        if zoomed_pixbuf!=0
-            sd drawable
-            setcall drawable gtk_widget_get_window(drawwidget)
-            importx "_gdk_draw_pixbuf" gdk_draw_pixbuf
-            call gdk_draw_pixbuf(drawable,0,zoomed_pixbuf,0,0,left,top,width,height,(GDK_RGB_DITHER_NONE),0,0)
-            call g_object_unref(zoomed_pixbuf)
-        endif
-        call g_object_unref(sub_pixbuf)
-    endif
-    return (expose_return)
-endfunction
-
-
-##other fns
-
-function stage_pencil_drawsize()
-    sd zoom_count
-    setcall zoom_count stage_pencil_zoomvalue((value_get))
-
-    sd width
-    sd height
-    sd pixbuf
-    setcall pixbuf stage_pencil_pixbuf((stage_pencil_pixbuf_get))
-    setcall width gdk_pixbuf_get_width(pixbuf)
-    setcall height gdk_pixbuf_get_height(pixbuf)
-
-    mult width zoom_count
-    mult height zoom_count
-
-    sd drawwidg
-    setcall drawwidg stage_pencil_draw((value_get))
-
-    call gtk_widget_set_size_request(drawwidg,width,height)
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/frame/remove.oc
@@ -0,0 +1,233 @@
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+import "stage_get_sel" stage_get_sel
+import "stage_get_sel_pos" stage_get_sel_pos
+
+import "sound_pixbuf_redraw" sound_pixbuf_redraw
+
+function stage_remove()
+    #verify no frames
+    sd img
+    setcall img stage_get_sel()
+    if img=0
+        return 0
+    endif
+
+    #get current pos
+    sd pos
+    setcall pos stage_get_sel_pos()
+
+    call stage_remove_frame(pos)
+
+    call stage_remove_after(pos)
+
+    #redraw the visual sound pulse
+    call sound_pixbuf_redraw()
+endfunction
+
+import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
+
+function stage_remove_frame(sd pos)
+    #remove sound(using current total frames)
+    import "stage_sound_removeframe" stage_sound_removeframe
+    call stage_sound_removeframe(pos)
+
+    #index delete
+    import "stage_frame_time_numbers" stage_frame_time_numbers
+    call stage_frame_time_numbers((stage_frame_time_delete_frame),pos)
+
+    #verify if selection is deleted for clearing the value
+    import "stage_get_sel_position" stage_get_sel_position
+    sd selpos
+    sd p_selpos^selpos
+    sd err
+    setcall err stage_get_sel_position(p_selpos)
+    if err=(noerror)
+        if selpos=pos
+            import "stage_sel_prepare_img_space" stage_sel_prepare_img_space
+            call stage_sel_prepare_img_space()
+        endif
+    endif
+
+    #get container
+    sd ebox
+    setcall ebox stage_nthwidgetFromcontainer(pos)
+    #remove the pixbuf and destroy the frame(total frames changed)
+    import "unref_pixbuf_frame" unref_pixbuf_frame
+    call unref_pixbuf_frame(ebox)
+    importx "_gtk_widget_destroy" gtk_widget_destroy
+    call gtk_widget_destroy(ebox)
+endfunction
+
+function stage_remove_after(sd pos)
+    #return if there are no frames
+    import "stage_get_frames" stage_get_frames
+    sd total_pos
+    setcall total_pos stage_get_frames()
+    if total_pos=0
+        #clears the draw area
+        import "stage_redraw" stage_redraw
+        call stage_redraw()
+        return 0
+    endif
+
+    #return if the sel was not deleted
+    import "stage_sel" stage_sel
+    sd sel
+    setcall sel stage_sel()
+    if sel!=0
+        import "stage_get_sel_parent" stage_get_sel_parent
+        sd ebox
+        sd p_ebox^ebox
+        call stage_get_sel_parent(p_ebox)
+        import "stage_display_info" stage_display_info
+        call stage_display_info(ebox)
+        return 0
+    endif
+
+    #if last position was deleted, decrement position
+    if pos=total_pos
+        dec pos
+    endif
+
+    #arrange the frames bar
+    sd frame
+    setcall frame stage_nthwidgetFromcontainer(pos)
+    import "stage_sel_reparent" stage_sel_reparent
+    call stage_sel_reparent(frame)
+
+    #display the frame
+    import "stage_display_pixbuf" stage_display_pixbuf
+    call stage_display_pixbuf(frame)
+endfunction
+
+#mass remove
+function mass_remove_run(sd action,sd value)
+    data start_entry#1
+    if action=(value_set)
+        set start_entry value
+    else
+    #if action==(value_run)
+        sd end_entry
+        setcall end_entry link_mass_remove((value_get))
+        sd max_pos
+        setcall max_pos stage_get_frames()
+        dec max_pos
+
+        import "entry_to_int_min_N_max_M" entry_to_int_min_N_max_M
+        sd start
+        sd end
+        sd p_start^start
+        sd p_end^end
+        sd bool
+
+        setcall bool entry_to_int_min_N_max_M(start_entry,p_start,0,max_pos)
+        if bool!=1
+            return 0
+        endif
+        setcall bool entry_to_int_min_N_max_M(end_entry,p_end,0,max_pos)
+        if bool!=1
+            return 0
+        endif
+
+        if start>end
+            sd aux
+            set aux end
+            set end start
+            set start aux
+        endif
+
+        while start<=end
+            call stage_remove_frame(end)
+            dec end
+        endwhile
+        call stage_remove_after(start)
+    endelse
+endfunction
+
+function link_mass_remove(sd action,sd value)
+    data link#1
+    if action=(value_set)
+        set link value
+    elseif action=(value_write)
+        if link!=0
+            import "int_to_entry" int_to_entry
+            sd pos
+            setcall pos stage_get_sel_pos()
+            call int_to_entry(pos,link)
+        endif
+    else
+    #if action==(value_get)
+        return link
+    endelse
+endfunction
+
+function mass_remove()
+    #verify already started
+    sd dialog_initiated#1
+    setcall dialog_initiated link_mass_remove((value_get))
+    if dialog_initiated!=0
+        return 0
+    endif
+
+    #verify no frames
+    sd img
+    setcall img stage_get_sel()
+    if img=0
+        return 0
+    endif
+
+    #launch the dialog
+    import "dialogfield" dialogfield
+    str title="Frames remove"
+    data init^mass_remove_init
+    data do^mass_remove_set
+    call dialogfield(title,0,init,do)
+endfunction
+
+function mass_remove_init(sd vbox,sd *dialog)
+    str info="Remove video(and sound) from Start to End"
+    import "labelfield_l" labelfield_l
+    call labelfield_l(info,vbox)
+    str info_txt="Press on a frame to modify the End value"
+    call labelfield_l(info_txt,vbox)
+    sd start_txt
+    sd start_entry
+    sd end_txt
+    sd end_entry
+    ss cells^start_txt
+    ss s="Start"
+    ss e="End"
+
+    import "labelfield_left_prepare" labelfield_left_prepare
+    importx "_gtk_entry_new" gtk_entry_new
+    setcall start_txt labelfield_left_prepare(s)
+    setcall start_entry gtk_entry_new()
+    setcall end_txt labelfield_left_prepare(e)
+    setcall end_entry gtk_entry_new()
+
+    sd pos
+    setcall pos stage_get_sel_pos()
+    call int_to_entry(pos,start_entry)
+    call int_to_entry(pos,end_entry)
+
+    import "tablefield_cells" tablefield_cells
+    call tablefield_cells(vbox,2,2,cells)
+    call mass_remove_run((value_set),start_entry)
+    call link_mass_remove((value_set),end_entry)
+endfunction
+
+function mass_remove_set(sd response_id)
+    #start to remove if response is ok
+    if response_id=(GTK_RESPONSE_OK)
+        call mass_remove_run((value_run))
+    endif
+    call link_mass_remove((value_set),0)
+    #redraw the visual sound pulse
+    call sound_pixbuf_redraw()
+endfunction
+
--- ovideo-1.orig/src/_prepare/frame/remove.s
+++ /dev/null
@@ -1,233 +0,0 @@
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-import "stage_get_sel" stage_get_sel
-import "stage_get_sel_pos" stage_get_sel_pos
-
-import "sound_pixbuf_redraw" sound_pixbuf_redraw
-
-function stage_remove()
-    #verify no frames
-    sd img
-    setcall img stage_get_sel()
-    if img==0
-        return 0
-    endif
-
-    #get current pos
-    sd pos
-    setcall pos stage_get_sel_pos()
-
-    call stage_remove_frame(pos)
-
-    call stage_remove_after(pos)
-
-    #redraw the visual sound pulse
-    call sound_pixbuf_redraw()
-endfunction
-
-import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
-
-function stage_remove_frame(sd pos)
-    #remove sound(using current total frames)
-    import "stage_sound_removeframe" stage_sound_removeframe
-    call stage_sound_removeframe(pos)
-
-    #index delete
-    import "stage_frame_time_numbers" stage_frame_time_numbers
-    call stage_frame_time_numbers((stage_frame_time_delete_frame),pos)
-
-    #verify if selection is deleted for clearing the value
-    import "stage_get_sel_position" stage_get_sel_position
-    sd selpos
-    sd p_selpos^selpos
-    sd err
-    setcall err stage_get_sel_position(p_selpos)
-    if err==(noerror)
-        if selpos==pos
-            import "stage_sel_prepare_img_space" stage_sel_prepare_img_space
-            call stage_sel_prepare_img_space()
-        endif
-    endif
-
-    #get container
-    sd ebox
-    setcall ebox stage_nthwidgetFromcontainer(pos)
-    #remove the pixbuf and destroy the frame(total frames changed)
-    import "unref_pixbuf_frame" unref_pixbuf_frame
-    call unref_pixbuf_frame(ebox)
-    importx "_gtk_widget_destroy" gtk_widget_destroy
-    call gtk_widget_destroy(ebox)
-endfunction
-
-function stage_remove_after(sd pos)
-    #return if there are no frames
-    import "stage_get_frames" stage_get_frames
-    sd total_pos
-    setcall total_pos stage_get_frames()
-    if total_pos==0
-        #clears the draw area
-        import "stage_redraw" stage_redraw
-        call stage_redraw()
-        return 0
-    endif
-
-    #return if the sel was not deleted
-    import "stage_sel" stage_sel
-    sd sel
-    setcall sel stage_sel()
-    if sel!=0
-        import "stage_get_sel_parent" stage_get_sel_parent
-        sd ebox
-        sd p_ebox^ebox
-        call stage_get_sel_parent(p_ebox)
-        import "stage_display_info" stage_display_info
-        call stage_display_info(ebox)
-        return 0
-    endif
-
-    #if last position was deleted, decrement position
-    if pos==total_pos
-        dec pos
-    endif
-
-    #arrange the frames bar
-    sd frame
-    setcall frame stage_nthwidgetFromcontainer(pos)
-    import "stage_sel_reparent" stage_sel_reparent
-    call stage_sel_reparent(frame)
-
-    #display the frame
-    import "stage_display_pixbuf" stage_display_pixbuf
-    call stage_display_pixbuf(frame)
-endfunction
-
-#mass remove
-function mass_remove_run(sd action,sd value)
-    data start_entry#1
-    if action==(value_set)
-        set start_entry value
-    else
-    #if action==(value_run)
-        sd end_entry
-        setcall end_entry link_mass_remove((value_get))
-        sd max_pos
-        setcall max_pos stage_get_frames()
-        dec max_pos
-
-        import "entry_to_int_min_N_max_M" entry_to_int_min_N_max_M
-        sd start
-        sd end
-        sd p_start^start
-        sd p_end^end
-        sd bool
-
-        setcall bool entry_to_int_min_N_max_M(start_entry,p_start,0,max_pos)
-        if bool!=1
-            return 0
-        endif
-        setcall bool entry_to_int_min_N_max_M(end_entry,p_end,0,max_pos)
-        if bool!=1
-            return 0
-        endif
-
-        if start>end
-            sd aux
-            set aux end
-            set end start
-            set start aux
-        endif
-
-        while start<=end
-            call stage_remove_frame(end)
-            dec end
-        endwhile
-        call stage_remove_after(start)
-    endelse
-endfunction
-
-function link_mass_remove(sd action,sd value)
-    data link#1
-    if action==(value_set)
-        set link value
-    elseif action==(value_write)
-        if link!=0
-            import "int_to_entry" int_to_entry
-            sd pos
-            setcall pos stage_get_sel_pos()
-            call int_to_entry(pos,link)
-        endif
-    else
-    #if action==(value_get)
-        return link
-    endelse
-endfunction
-
-function mass_remove()
-    #verify already started
-    sd dialog_initiated#1
-    setcall dialog_initiated link_mass_remove((value_get))
-    if dialog_initiated!=0
-        return 0
-    endif
-
-    #verify no frames
-    sd img
-    setcall img stage_get_sel()
-    if img==0
-        return 0
-    endif
-
-    #launch the dialog
-    import "dialogfield" dialogfield
-    str title="Frames remove"
-    data init^mass_remove_init
-    data do^mass_remove_set
-    call dialogfield(title,0,init,do)
-endfunction
-
-function mass_remove_init(sd vbox,sd *dialog)
-    str info="Remove video(and sound) from Start to End"
-    import "labelfield_l" labelfield_l
-    call labelfield_l(info,vbox)
-    str info_txt="Press on a frame to modify the End value"
-    call labelfield_l(info_txt,vbox)
-    sd start_txt
-    sd start_entry
-    sd end_txt
-    sd end_entry
-    ss cells^start_txt
-    ss s="Start"
-    ss e="End"
-
-    import "labelfield_left_prepare" labelfield_left_prepare
-    importx "_gtk_entry_new" gtk_entry_new
-    setcall start_txt labelfield_left_prepare(s)
-    setcall start_entry gtk_entry_new()
-    setcall end_txt labelfield_left_prepare(e)
-    setcall end_entry gtk_entry_new()
-
-    sd pos
-    setcall pos stage_get_sel_pos()
-    call int_to_entry(pos,start_entry)
-    call int_to_entry(pos,end_entry)
-
-    import "tablefield_cells" tablefield_cells
-    call tablefield_cells(vbox,2,2,cells)
-    call mass_remove_run((value_set),start_entry)
-    call link_mass_remove((value_set),end_entry)
-endfunction
-
-function mass_remove_set(sd response_id)
-    #start to remove if response is ok
-    if response_id==(GTK_RESPONSE_OK)
-        call mass_remove_run((value_run))
-    endif
-    call link_mass_remove((value_set),0)
-    #redraw the visual sound pulse
-    call sound_pixbuf_redraw()
-endfunction
-
--- /dev/null
+++ ovideo-1/src/_prepare/frame/rotate.oc
@@ -0,0 +1,62 @@
+
+
+format elfobj
+
+
+function stage_rotate_left()
+    call stage_rotate(0,1,-1,1)
+endfunction
+
+function stage_rotate_right()
+    call stage_rotate(1,0,1,-1)
+endfunction
+
+function stage_rotate(sd x_at_start,sd y_at_start,sd on_y,sd on_x)
+    import "stage_get_selection_pixbuf" stage_get_selection_pixbuf
+    sd px
+    setcall px stage_get_selection_pixbuf()
+    if px=0
+        return 0
+    endif
+    sd w
+    sd h
+    sd p_w^w
+    import "pixbuf_get_wh" pixbuf_get_wh
+    call pixbuf_get_wh(px,p_w)
+    import "new_pixbuf" new_pixbuf
+    sd newpixbuf
+    setcall newpixbuf new_pixbuf(h,w)
+    if newpixbuf=0
+        return 0
+    endif
+
+    #rotate 90, the width will be height and viceversa
+    sd x
+    set x h
+    mult x x_at_start
+    sub x x_at_start
+
+    sd j=0
+    while j!=h
+        sd y
+        set y w
+        mult y y_at_start
+        sub y y_at_start
+
+        sd i=0
+        while i!=w
+            import "pixbuf_get_pixel" pixbuf_get_pixel
+            import "pixbuf_set_pixel" pixbuf_set_pixel
+            sd value
+            setcall value pixbuf_get_pixel(px,i,j)
+            call pixbuf_set_pixel(newpixbuf,value,x,y)
+            add y on_y
+            inc i
+        endwhile
+        add x on_x
+        inc j
+    endwhile
+
+    import "stage_sel_replace_pixbuf" stage_sel_replace_pixbuf
+    call stage_sel_replace_pixbuf(newpixbuf)
+endfunction
--- ovideo-1.orig/src/_prepare/frame/rotate.s
+++ /dev/null
@@ -1,62 +0,0 @@
-
-
-format elfobj
-
-
-function stage_rotate_left()
-    call stage_rotate(0,1,-1,1)
-endfunction
-
-function stage_rotate_right()
-    call stage_rotate(1,0,1,-1)
-endfunction
-
-function stage_rotate(sd x_at_start,sd y_at_start,sd on_y,sd on_x)
-    import "stage_get_selection_pixbuf" stage_get_selection_pixbuf
-    sd px
-    setcall px stage_get_selection_pixbuf()
-    if px==0
-        return 0
-    endif
-    sd w
-    sd h
-    sd p_w^w
-    import "pixbuf_get_wh" pixbuf_get_wh
-    call pixbuf_get_wh(px,p_w)
-    import "new_pixbuf" new_pixbuf
-    sd newpixbuf
-    setcall newpixbuf new_pixbuf(h,w)
-    if newpixbuf==0
-        return 0
-    endif
-
-    #rotate 90, the width will be height and viceversa
-    sd x
-    set x h
-    mult x x_at_start
-    sub x x_at_start
-
-    sd j=0
-    while j!=h
-        sd y
-        set y w
-        mult y y_at_start
-        sub y y_at_start
-
-        sd i=0
-        while i!=w
-            import "pixbuf_get_pixel" pixbuf_get_pixel
-            import "pixbuf_set_pixel" pixbuf_set_pixel
-            sd value
-            setcall value pixbuf_get_pixel(px,i,j)
-            call pixbuf_set_pixel(newpixbuf,value,x,y)
-            add y on_y
-            inc i
-        endwhile
-        add x on_x
-        inc j
-    endwhile
-
-    import "stage_sel_replace_pixbuf" stage_sel_replace_pixbuf
-    call stage_sel_replace_pixbuf(newpixbuf)
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/frame/scale.oc
@@ -0,0 +1,283 @@
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+function stage_scale_set()
+    data currentpixbuf#1
+    const ptr_currentpixbuf^currentpixbuf
+
+    data entryw#1
+    data entryh#1
+    const ptr_entryw^entryw
+    const ptr_entryh^entryh
+
+    importx "_gtk_entry_get_text" gtk_entry_get_text
+
+    import "strtoint" strtoint
+    sd bool
+    str valueserr="Number expected for scaling"
+    sd text
+
+    import "texter" texter
+
+    sd width
+    sd ptr_width^width
+    setcall text gtk_entry_get_text(entryw)
+    setcall bool strtoint(text,ptr_width)
+    if bool=0
+        call texter(valueserr)
+        return valueserr
+    endif
+    sd height
+    sd ptr_height^height
+    setcall text gtk_entry_get_text(entryh)
+    setcall bool strtoint(text,ptr_height)
+    if bool=0
+        call texter(valueserr)
+        return valueserr
+    endif
+
+    import "pixbuf_scale" pixbuf_scale
+
+    sd newpixbuf
+    setcall newpixbuf pixbuf_scale(currentpixbuf,width,height)
+    if newpixbuf=0
+        return -1
+    endif
+
+    import "stage_get_sel_parent" stage_get_sel_parent
+    sd eventbox
+    sd ptr_eventbox^eventbox
+    call stage_get_sel_parent(ptr_eventbox)
+
+    importx "_g_object_unref" g_object_unref
+    call g_object_unref(currentpixbuf)
+
+    import "object_set_dword_name" object_set_dword_name
+    call object_set_dword_name(eventbox,newpixbuf)
+
+    import "stage_redraw" stage_redraw
+    call stage_redraw()
+endfunction
+
+function stage_scale_init(sd vbox,sd *dialog)
+    sd textw
+    sd entryw
+    sd texth
+    sd entryh
+    sd cells^textw
+
+    data rows=2
+    data cols=2
+
+    importx "_gtk_label_new" gtk_label_new
+    importx "_gtk_entry_new" gtk_entry_new
+
+    import "connect_signal_data" connect_signal_data
+    str signal_set="changed"
+    data fn_set^scale_signal_changed
+
+    str w="Width"
+    setcall textw gtk_label_new(w)
+    setcall entryw gtk_entry_new()
+    call scale_width_entry((value_set),entryw)
+    data fn_wd^scale_width_changed
+
+    str h="Height"
+    setcall texth gtk_label_new(h)
+    setcall entryh gtk_entry_new()
+    call scale_height_entry((value_set),entryh)
+    data fn_hg^scale_height_changed
+
+    data ptr_pix%ptr_currentpixbuf
+    data pixbuf#1
+
+    set pixbuf ptr_pix#
+
+    importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+    sd width
+    sd height
+    setcall width gdk_pixbuf_get_width(pixbuf)
+    setcall height gdk_pixbuf_get_height(pixbuf)
+
+    char dest#sign_int_null
+    str strconv^dest
+
+    str format="%u"
+
+    importx "_sprintf" sprintf
+    importx "_gtk_entry_set_text" gtk_entry_set_text
+
+    call sprintf(strconv,format,width)
+    call gtk_entry_set_text(entryw,strconv)
+
+    call sprintf(strconv,format,height)
+    call gtk_entry_set_text(entryh,strconv)
+
+    sd p_w%ptr_entryw
+    sd p_h%ptr_entryh
+
+    set p_w# entryw
+    set p_h# entryh
+
+    import "tablefield_cells" tablefield_cells
+    call tablefield_cells(vbox,rows,cols,cells)
+
+    #toggle button
+    sd ch_button
+    importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
+    ss txt="Preserve aspect ratio"
+    setcall ch_button gtk_check_button_new_with_label(txt)
+    import "packstart_default" packstart_default
+    call scale_toggle_entry((value_set),ch_button)
+    call packstart_default(vbox,ch_button)
+
+    #set to preserve aspect ratio
+    importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
+    call gtk_toggle_button_set_active(ch_button,1)
+
+    #connect the on change signal to edit entries
+    call connect_signal_data(entryw,signal_set,fn_set,fn_wd)
+    call connect_signal_data(entryh,signal_set,fn_set,fn_hg)
+endfunction
+
+function stage_scale_img()
+    sd err
+    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
+    sd ptr_pixbuf%ptr_currentpixbuf
+    setcall err stage_get_sel_pixbuf(ptr_pixbuf)
+    if err!=(noerror)
+        return err
+    endif
+
+    import "stage_frame_dialog" stage_frame_dialog
+    ss title="Scale selection"
+    data init^stage_scale_init
+    data do^stage_scale_set
+    call stage_frame_dialog(init,do,title)
+endfunction
+
+
+
+
+
+
+function scale_width_entry(sd action,sd value)
+    data width_entry#1
+    if action=(value_set)
+        set width_entry value
+    else
+        return width_entry
+    endelse
+endfunction
+function scale_height_entry(sd action,sd value)
+    data height_entry#1
+    if action=(value_set)
+        set height_entry value
+    else
+        return height_entry
+    endelse
+endfunction
+function scale_toggle_entry(sd action,sd value)
+    data toggle_entry#1
+    if action=(value_set)
+        set toggle_entry value
+    else
+        return toggle_entry
+    endelse
+endfunction
+
+
+function scale_signal_changed(sd widget,sv data)
+    importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
+    sd ch_button
+    setcall ch_button scale_toggle_entry((value_get))
+    sd toggled
+    setcall toggled gtk_toggle_button_get_active(ch_button)
+    if toggled=(FALSE)
+        return 0
+    endif
+
+    #not count irrelevant cases
+    ss text
+    setcall text gtk_entry_get_text(widget)
+    import "slen" slen
+    sd len
+    setcall len slen(text)
+    if len=0
+        return 0
+    endif
+
+    sd wd_entry
+    setcall wd_entry scale_width_entry((value_get))
+    sd hg_entry
+    setcall hg_entry scale_height_entry((value_get))
+
+    #disconnect for not trigger in chain
+    data fn_set^scale_signal_changed
+    importx "_g_signal_handlers_disconnect_matched" g_signal_handlers_disconnect_matched
+    call g_signal_handlers_disconnect_matched(wd_entry,(G_SIGNAL_MATCH_FUNC),0,0,0,fn_set,0)
+    call g_signal_handlers_disconnect_matched(hg_entry,(G_SIGNAL_MATCH_FUNC),0,0,0,fn_set,0)
+
+    sd pixbuf
+    sd p_pixbuf^pixbuf
+    call stage_get_sel_pixbuf(p_pixbuf)
+
+    sd width
+    sd height
+    setcall width gdk_pixbuf_get_width(pixbuf)
+    setcall height gdk_pixbuf_get_height(pixbuf)
+
+    call data(width,height,wd_entry,hg_entry)
+
+    #connect back
+    data fn_wd^scale_width_changed
+    data fn_hg^scale_height_changed
+    str signal_set="changed"
+    call connect_signal_data(wd_entry,signal_set,fn_set,fn_wd)
+    call connect_signal_data(hg_entry,signal_set,fn_set,fn_hg)
+endfunction
+
+import "entry_to_int_min_N" entry_to_int_min_N
+import "int_to_entry" int_to_entry
+import "numbers_proportion" numbers_proportion
+
+function scale_width_changed(sd width,sd height,sd wd_entry,sd hg_entry)
+    sd newwidth
+    sd ptr_newwidth^newwidth
+
+    sd bool
+    setcall bool entry_to_int_min_N(wd_entry,ptr_newwidth,1)
+    if bool!=1
+        return 0
+    endif
+
+    sd newheight
+    setcall newheight numbers_proportion(newwidth,height,width)
+    if newheight=0
+        set newheight 1
+    endif
+
+    call int_to_entry(newheight,hg_entry)
+endfunction
+
+function scale_height_changed(sd width,sd height,sd wd_entry,sd hg_entry)
+    sd newheight
+    sd ptr_newheight^newheight
+    sd bool
+    setcall bool entry_to_int_min_N(hg_entry,ptr_newheight,1)
+    if bool!=1
+        return 0
+    endif
+
+    sd newwidth
+    setcall newwidth numbers_proportion(newheight,width,height)
+    if newwidth=0
+        set newwidth 1
+    endif
+
+    call int_to_entry(newwidth,wd_entry)
+endfunction
--- ovideo-1.orig/src/_prepare/frame/scale.s
+++ /dev/null
@@ -1,283 +0,0 @@
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-function stage_scale_set()
-    data currentpixbuf#1
-    const ptr_currentpixbuf^currentpixbuf
-
-    data entryw#1
-    data entryh#1
-    const ptr_entryw^entryw
-    const ptr_entryh^entryh
-
-    importx "_gtk_entry_get_text" gtk_entry_get_text
-
-    import "strtoint" strtoint
-    sd bool
-    str valueserr="Number expected for scaling"
-    sd text
-
-    import "texter" texter
-
-    sd width
-    sd ptr_width^width
-    setcall text gtk_entry_get_text(entryw)
-    setcall bool strtoint(text,ptr_width)
-    if bool==0
-        call texter(valueserr)
-        return valueserr
-    endif
-    sd height
-    sd ptr_height^height
-    setcall text gtk_entry_get_text(entryh)
-    setcall bool strtoint(text,ptr_height)
-    if bool==0
-        call texter(valueserr)
-        return valueserr
-    endif
-
-    import "pixbuf_scale" pixbuf_scale
-
-    sd newpixbuf
-    setcall newpixbuf pixbuf_scale(currentpixbuf,width,height)
-    if newpixbuf==0
-        return -1
-    endif
-
-    import "stage_get_sel_parent" stage_get_sel_parent
-    sd eventbox
-    sd ptr_eventbox^eventbox
-    call stage_get_sel_parent(ptr_eventbox)
-
-    importx "_g_object_unref" g_object_unref
-    call g_object_unref(currentpixbuf)
-
-    import "object_set_dword_name" object_set_dword_name
-    call object_set_dword_name(eventbox,newpixbuf)
-
-    import "stage_redraw" stage_redraw
-    call stage_redraw()
-endfunction
-
-function stage_scale_init(sd vbox,sd *dialog)
-    sd textw
-    sd entryw
-    sd texth
-    sd entryh
-    sd cells^textw
-
-    data rows=2
-    data cols=2
-
-    importx "_gtk_label_new" gtk_label_new
-    importx "_gtk_entry_new" gtk_entry_new
-
-    import "connect_signal_data" connect_signal_data
-    str signal_set="changed"
-    data fn_set^scale_signal_changed
-
-    str w="Width"
-    setcall textw gtk_label_new(w)
-    setcall entryw gtk_entry_new()
-    call scale_width_entry((value_set),entryw)
-    data fn_wd^scale_width_changed
-
-    str h="Height"
-    setcall texth gtk_label_new(h)
-    setcall entryh gtk_entry_new()
-    call scale_height_entry((value_set),entryh)
-    data fn_hg^scale_height_changed
-
-    data ptr_pix%ptr_currentpixbuf
-    data pixbuf#1
-
-    set pixbuf ptr_pix#
-
-    importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-    sd width
-    sd height
-    setcall width gdk_pixbuf_get_width(pixbuf)
-    setcall height gdk_pixbuf_get_height(pixbuf)
-
-    char dest#sign_int_null
-    str strconv^dest
-
-    str format="%u"
-
-    importx "_sprintf" sprintf
-    importx "_gtk_entry_set_text" gtk_entry_set_text
-
-    call sprintf(strconv,format,width)
-    call gtk_entry_set_text(entryw,strconv)
-
-    call sprintf(strconv,format,height)
-    call gtk_entry_set_text(entryh,strconv)
-
-    sd p_w%ptr_entryw
-    sd p_h%ptr_entryh
-
-    set p_w# entryw
-    set p_h# entryh
-
-    import "tablefield_cells" tablefield_cells
-    call tablefield_cells(vbox,rows,cols,cells)
-
-    #toggle button
-    sd ch_button
-    importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
-    ss txt="Preserve aspect ratio"
-    setcall ch_button gtk_check_button_new_with_label(txt)
-    import "packstart_default" packstart_default
-    call scale_toggle_entry((value_set),ch_button)
-    call packstart_default(vbox,ch_button)
-
-    #set to preserve aspect ratio
-    importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
-    call gtk_toggle_button_set_active(ch_button,1)
-
-    #connect the on change signal to edit entries
-    call connect_signal_data(entryw,signal_set,fn_set,fn_wd)
-    call connect_signal_data(entryh,signal_set,fn_set,fn_hg)
-endfunction
-
-function stage_scale_img()
-    sd err
-    import "stage_get_sel_pixbuf" stage_get_sel_pixbuf
-    sd ptr_pixbuf%ptr_currentpixbuf
-    setcall err stage_get_sel_pixbuf(ptr_pixbuf)
-    if err!=(noerror)
-        return err
-    endif
-
-    import "stage_frame_dialog" stage_frame_dialog
-    ss title="Scale selection"
-    data init^stage_scale_init
-    data do^stage_scale_set
-    call stage_frame_dialog(init,do,title)
-endfunction
-
-
-
-
-
-
-function scale_width_entry(sd action,sd value)
-    data width_entry#1
-    if action==(value_set)
-        set width_entry value
-    else
-        return width_entry
-    endelse
-endfunction
-function scale_height_entry(sd action,sd value)
-    data height_entry#1
-    if action==(value_set)
-        set height_entry value
-    else
-        return height_entry
-    endelse
-endfunction
-function scale_toggle_entry(sd action,sd value)
-    data toggle_entry#1
-    if action==(value_set)
-        set toggle_entry value
-    else
-        return toggle_entry
-    endelse
-endfunction
-
-
-function scale_signal_changed(sd widget,sd data)
-    importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
-    sd ch_button
-    setcall ch_button scale_toggle_entry((value_get))
-    sd toggled
-    setcall toggled gtk_toggle_button_get_active(ch_button)
-    if toggled==(FALSE)
-        return 0
-    endif
-
-    #not count irrelevant cases
-    ss text
-    setcall text gtk_entry_get_text(widget)
-    import "slen" slen
-    sd len
-    setcall len slen(text)
-    if len==0
-        return 0
-    endif
-
-    sd wd_entry
-    setcall wd_entry scale_width_entry((value_get))
-    sd hg_entry
-    setcall hg_entry scale_height_entry((value_get))
-
-    #disconnect for not trigger in chain
-    data fn_set^scale_signal_changed
-    importx "_g_signal_handlers_disconnect_matched" g_signal_handlers_disconnect_matched
-    call g_signal_handlers_disconnect_matched(wd_entry,(G_SIGNAL_MATCH_FUNC),0,0,0,fn_set,0)
-    call g_signal_handlers_disconnect_matched(hg_entry,(G_SIGNAL_MATCH_FUNC),0,0,0,fn_set,0)
-
-    sd pixbuf
-    sd p_pixbuf^pixbuf
-    call stage_get_sel_pixbuf(p_pixbuf)
-
-    sd width
-    sd height
-    setcall width gdk_pixbuf_get_width(pixbuf)
-    setcall height gdk_pixbuf_get_height(pixbuf)
-
-    call data(width,height,wd_entry,hg_entry)
-
-    #connect back
-    data fn_wd^scale_width_changed
-    data fn_hg^scale_height_changed
-    str signal_set="changed"
-    call connect_signal_data(wd_entry,signal_set,fn_set,fn_wd)
-    call connect_signal_data(hg_entry,signal_set,fn_set,fn_hg)
-endfunction
-
-import "entry_to_int_min_N" entry_to_int_min_N
-import "int_to_entry" int_to_entry
-import "numbers_proportion" numbers_proportion
-
-function scale_width_changed(sd width,sd height,sd wd_entry,sd hg_entry)
-    sd newwidth
-    sd ptr_newwidth^newwidth
-
-    sd bool
-    setcall bool entry_to_int_min_N(wd_entry,ptr_newwidth,1)
-    if bool!=1
-        return 0
-    endif
-
-    sd newheight
-    setcall newheight numbers_proportion(newwidth,height,width)
-    if newheight==0
-        set newheight 1
-    endif
-
-    call int_to_entry(newheight,hg_entry)
-endfunction
-
-function scale_height_changed(sd width,sd height,sd wd_entry,sd hg_entry)
-    sd newheight
-    sd ptr_newheight^newheight
-    sd bool
-    setcall bool entry_to_int_min_N(hg_entry,ptr_newheight,1)
-    if bool!=1
-        return 0
-    endif
-
-    sd newwidth
-    setcall newwidth numbers_proportion(newheight,width,height)
-    if newwidth==0
-        set newwidth 1
-    endif
-
-    call int_to_entry(newwidth,wd_entry)
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/frame/screenshot.oc
@@ -0,0 +1,41 @@
+
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+function stage_screenshot()
+    importx "_gdk_get_default_root_window" gdk_get_default_root_window
+    importx "_gdk_drawable_get_size" gdk_drawable_get_size
+    importx "_gdk_window_get_origin" gdk_window_get_origin
+    sd root
+    setcall root gdk_get_default_root_window()
+    sd width
+    sd height
+    sd x_orig
+    sd y_orig
+    sd p_width^width
+    sd p_height^height
+    sd p_x_orig^x_orig
+    sd p_y_orig^y_orig
+    call gdk_drawable_get_size(root,p_width,p_height)
+    call gdk_window_get_origin(root,p_x_orig,p_y_orig)
+
+    importx "_gdk_pixbuf_get_from_drawable" gdk_pixbuf_get_from_drawable
+    sd pixbuf
+    setcall pixbuf gdk_pixbuf_get_from_drawable((NULL),root,(NULL),x_orig,y_orig,0,0,width,height)
+    if pixbuf=0
+        import "texter" texter
+        str er="Pixbuf error"
+        call texter(er)
+        return 0
+    endif
+    import "stage_new_pix" stage_new_pix
+    str nrofframes="Total frames: "
+    call stage_new_pix(pixbuf,nrofframes)
+
+    import "stage_display_last" stage_display_last
+    call stage_display_last()
+endfunction
--- ovideo-1.orig/src/_prepare/frame/screenshot.s
+++ /dev/null
@@ -1,41 +0,0 @@
-
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-function stage_screenshot()
-    importx "_gdk_get_default_root_window" gdk_get_default_root_window
-    importx "_gdk_drawable_get_size" gdk_drawable_get_size
-    importx "_gdk_window_get_origin" gdk_window_get_origin
-    sd root
-    setcall root gdk_get_default_root_window()
-    sd width
-    sd height
-    sd x_orig
-    sd y_orig
-    sd p_width^width
-    sd p_height^height
-    sd p_x_orig^x_orig
-    sd p_y_orig^y_orig
-    call gdk_drawable_get_size(root,p_width,p_height)
-    call gdk_window_get_origin(root,p_x_orig,p_y_orig)
-
-    importx "_gdk_pixbuf_get_from_drawable" gdk_pixbuf_get_from_drawable
-    sd pixbuf
-    setcall pixbuf gdk_pixbuf_get_from_drawable((NULL),root,(NULL),x_orig,y_orig,0,0,width,height)
-    if pixbuf==0
-        import "texter" texter
-        str er="Pixbuf error"
-        call texter(er)
-        return 0
-    endif
-    import "stage_new_pix" stage_new_pix
-    str nrofframes="Total frames: "
-    call stage_new_pix(pixbuf,nrofframes)
-
-    import "stage_display_last" stage_display_last
-    call stage_display_last()
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/output/all.oc
@@ -0,0 +1,641 @@
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+importx "_sprintf" sprintf
+
+data dialog#1
+const stage_file_dialog^dialog
+
+function stage_progress_dialog(sd inits)
+    data modal=GTK_DIALOG_MODAL
+    import "dialogfield_size_button" dialogfield_size_button
+    ss title="Save stage"
+    data width=150
+    data height=100
+    str GTK_STOCK_CANCEL="gtk-cancel"
+    data responsecancel=GTK_RESPONSE_CANCEL
+    call dialogfield_size_button(title,modal,inits,0,width,height,GTK_STOCK_CANCEL,responsecancel)
+    #set the dialog to null
+    data ptr_dialog%stage_file_dialog
+    set ptr_dialog# 0
+endfunction
+function stage_progress_dialog_inc(sd frame)
+    ss value=100
+    mult value frame
+    import "stage_get_frames" stage_get_frames
+    divcall value stage_get_frames()
+	char s={_0,Period}
+	char a#1
+	char b#1
+	char *=0
+	set b value
+	remu b 10
+	add b (_0)
+	set a value
+	divu a 10
+	remu a 10
+	add a (_0)
+    sd doublelow
+    sd doublehigh
+    sd double^doublelow
+    str doubleformat="%lf"
+    importx "_sscanf" sscanf
+    call sscanf(#s,doubleformat,double)
+    importx "_gtk_progress_bar_set_fraction" gtk_progress_bar_set_fraction
+    data pbar#1
+    const progressbar^pbar
+    call gtk_progress_bar_set_fraction(pbar,doublelow,doublehigh)
+endfunction
+function stage_file_dialog_inits(sd vbox,sd dialog)
+    data ptr%stage_file_dialog
+    set ptr# dialog
+
+    #progress bar
+    import "progressfield" progressfield
+    sd widget
+    setcall widget progressfield(vbox)
+
+    importx "_gtk_progress_bar_set_text" gtk_progress_bar_set_text
+    str save="Save to file"
+    call gtk_progress_bar_set_text(widget,save)
+
+    data pbar%progressbar
+    set pbar# widget
+
+    #new texter
+    import "new_texter_modal" new_texter_modal
+    call new_texter_modal(vbox,dialog)
+endfunction
+function stage_file_close()
+    importx "_gtk_dialog_response" gtk_dialog_response
+    sd d%stage_file_dialog
+    data z=0
+    if d#!=z
+        data responsecancel=GTK_RESPONSE_CANCEL
+        call gtk_dialog_response(d#,responsecancel)
+        set d# z
+    endif
+endfunction
+
+
+
+
+function stage_file_error(sd *bus,sd message,sd *data)
+    import "def_error" def_error
+    call def_error(message)
+    call stage_file_close()
+endfunction
+function stage_file_eos(sd *bus,sd *message,sd *data)
+    call stage_file_close()
+endfunction
+
+function stage_get_src_name()
+    str s="source"
+    return s
+endfunction
+#eventbox/0
+function stage_nthwidgetFromcontainer(sd value)
+    import "nthwidgetFromcontainer" nthwidgetFromcontainer
+    import "stage_get_frames_container" stage_get_frames_container
+    sd container
+    setcall container stage_get_frames_container()
+    sd eventbox
+    setcall eventbox nthwidgetFromcontainer(container,value)
+    return eventbox
+endfunction
+
+import "object_get_dword_name" object_get_dword_name
+
+#pixbuf/0
+function stage_nthPixbufFromContainer(sd value)
+    sd container
+    setcall container stage_get_frames_container()
+    sd eventbox
+    setcall eventbox nthwidgetFromcontainer(container,value)
+    if eventbox=0
+        return 0
+    endif
+    sd pixbuf
+    setcall pixbuf object_get_dword_name(eventbox)
+    return pixbuf
+endfunction
+
+import "texter" texter
+
+function stage_prepare_pixbuf(sd pixbuf,sd mem,sd w,sd h)
+    sd px_pixels
+    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+    setcall px_pixels gdk_pixbuf_get_pixels(pixbuf)
+
+    sd px_bps
+    importx "_gdk_pixbuf_get_bits_per_sample" gdk_pixbuf_get_bits_per_sample
+    setcall px_bps gdk_pixbuf_get_bits_per_sample(pixbuf)
+
+    data minbps=pixbuf_minbps
+    if px_bps<minbps
+        str bpser="Bits-per-sample to few."
+        call texter(bpser)
+        return bpser
+    endif
+
+    sd px_nchan
+    importx "_gdk_pixbuf_get_n_channels" gdk_pixbuf_get_n_channels
+    setcall px_nchan gdk_pixbuf_get_n_channels(pixbuf)
+
+    data minnchan=pixbuf_minnchan
+    if px_nchan<minnchan
+        str nchaner="N-channels to few."
+        call texter(nchaner)
+        return nchaner
+    endif
+
+    sd px_rowstride
+    importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
+    setcall px_rowstride gdk_pixbuf_get_rowstride(pixbuf)
+
+    import "rgb_get_set" rgb_get_set
+    data rowstart=0
+    sd x
+    sd y=0
+    while y!=h
+        set x rowstart
+        while x!=w
+            call rgb_get_set(mem,px_pixels,x,y,px_bps,px_nchan,px_rowstride,(get_rgb))
+            data a=4
+            add mem a
+            inc x
+        endwhile
+        inc y
+    endwhile
+endfunction
+
+function stage_frame_size(sd w,sd h)
+    sd bpp=stage_bpp
+    sd size
+    set size w
+    mult size h
+    sd Bpp
+    set Bpp bpp
+    data bitsperbyte=8
+    div Bpp bitsperbyte
+    mult size Bpp
+    return size
+endfunction
+
+function stage_file_frame_main_set(sd ptr_pack,sd eventbox)
+    data a=4
+
+    sd pix
+    setcall pix object_get_dword_name(eventbox)
+    set ptr_pack# pix
+    add ptr_pack a
+
+    importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+    setcall ptr_pack# gdk_pixbuf_get_width(pix)
+    add ptr_pack a
+    setcall ptr_pack# gdk_pixbuf_get_height(pix)
+endfunction
+
+importx "_free" free
+
+#all returns of this timeout are false to not launch it again from here
+function stage_file_need_fn(sd appsrc)
+    data file_frames#1
+    const stage_file_frames^file_frames
+    data file_frames_portions#1
+         #implementation for frame with length, like at mkv
+    const stage_file_frames_portions^file_frames_portions
+    sd eventbox
+    setcall eventbox stage_nthwidgetFromcontainer(file_frames)
+    if eventbox!=0
+        sd d%stage_file_dialog
+        data false=0
+        if d#=false
+            return false
+        endif
+
+        import "stage_get_fr_length" stage_get_fr_length
+        if file_frames_portions=0
+            setcall file_frames_portions stage_get_fr_length(eventbox)
+            call stage_progress_dialog_inc(file_frames)
+        endif
+        dec file_frames_portions
+        if file_frames_portions=0
+            inc file_frames
+        endif
+
+        sd pixbuf
+        sd w
+        sd h
+
+        sd ptr_pack^pixbuf
+        call stage_file_frame_main_set(ptr_pack,eventbox)
+
+        sd framesize
+        setcall framesize stage_frame_size(w,h)
+
+        import "memoryalloc" memoryalloc
+        sd mem
+        sd mem_ptr^mem
+        sd err
+        sd noerr=noerror
+        setcall err memoryalloc(framesize,mem_ptr)
+        if err!=noerr
+            call stage_file_close()
+            return false
+        endif
+
+        call stage_prepare_pixbuf(pixbuf,mem,w,h)
+
+        importx "_gst_app_buffer_new" gst_app_buffer_new
+        data free_fn^free
+        sd buffer
+        setcall buffer gst_app_buffer_new(mem,framesize,free_fn,mem)
+
+        ss capsformat="video/x-raw-rgb,width=%u,height=%u,bpp=%u,endianness=4321,red_mask=0xFF000000,green_mask=0xFF0000,blue_mask=0xFF00,framerate=%u/1"
+        char capsdata#200
+        str gstcaps^capsdata
+        sd bpp=stage_bpp
+        sd fps
+        import "stage_file_options_fps" stage_file_options_fps
+        setcall fps stage_file_options_fps()
+        call sprintf(gstcaps,capsformat,w,h,bpp,fps)
+
+        importx "_gst_caps_from_string" gst_caps_from_string
+        sd caps
+        setcall caps gst_caps_from_string(gstcaps)
+
+        importx "_gst_buffer_set_caps" gst_buffer_set_caps
+        call gst_buffer_set_caps(buffer,caps)
+
+        importx "_gst_caps_unref" gst_caps_unref
+        call gst_caps_unref(caps)
+
+        sd flow
+        sd ptr_flow^flow
+        importx "_g_signal_emit_by_name" g_signal_emit_by_name
+        str push="push-buffer"
+        call g_signal_emit_by_name(appsrc,push,buffer,ptr_flow)
+        importx "_gst_mini_object_unref" gst_mini_object_unref
+        call gst_mini_object_unref(buffer)
+        data ok=GST_FLOW_OK
+        if flow<ok
+            str notok="The flow is not ok."
+            call texter(notok)
+            call stage_file_close()
+            return false
+        endif
+
+        setcall eventbox stage_nthwidgetFromcontainer(file_frames)
+        if eventbox=0
+            #state must be play or pause
+            importx "_gst_app_src_end_of_stream" gst_app_src_end_of_stream
+            call gst_app_src_end_of_stream(appsrc)
+
+            import "save_inform_saved" save_inform_saved
+            data location#1
+            const stage_file_path^location
+            call save_inform_saved(location)
+        endif
+    endif
+    #timeout stop
+    return false
+endfunction
+function stage_file_need(sd appsrc,sd *arg1,sd *data)
+    importx "_gdk_threads_add_timeout" gdk_threads_add_timeout
+    #set a timeout to allow the progress bar redrawing
+    data msec=0
+    data f^stage_file_need_fn
+    call gdk_threads_add_timeout(msec,f,appsrc)
+endfunction
+
+import "connect_signal" connect_signal
+
+function stage_file_connects(sd bus)
+    data er^stage_file_error
+    str ermsg="message::error"
+    call connect_signal(bus,ermsg,er)
+    data es^stage_file_eos
+    str esmsg="message::eos"
+    call connect_signal(bus,esmsg,es)
+endfunction
+
+function stage_file_command(ss command)
+    #creates the pipe
+    import "launch_pipe_start" launch_pipe_start
+    sd pipe
+    setcall pipe launch_pipe_start(command)
+    if pipe=0
+        return 0
+    endif
+
+    #connect pipe error messages
+    import "bus_signals" bus_signals
+    data connects^stage_file_connects
+    call bus_signals(pipe,connects)
+
+    #connect appsrc to add pixbufs
+    importx "_gst_bin_get_by_name" gst_bin_get_by_name
+    ss srcname
+    setcall srcname stage_get_src_name()
+    sd appsrc
+    setcall appsrc gst_bin_get_by_name(pipe,srcname)
+    ss need="need-data"
+    data start^stage_file_need
+    call connect_signal(appsrc,need,start)
+    #set frames queue size
+    #use the first frame to set the frames queue size
+    sd firstframe
+    setcall firstframe stage_nthwidgetFromcontainer(0)
+    sd pixbuf
+    sd w
+    sd h
+    sd ptr_pack^pixbuf
+    call stage_file_frame_main_set(ptr_pack,firstframe)
+    sd queue
+    setcall queue stage_frame_size(w,h)
+    data queueframes=1
+    mult queue queueframes
+    importx "_gst_app_src_set_max_bytes" gst_app_src_set_max_bytes
+    call gst_app_src_set_max_bytes(appsrc,queue)
+
+    #launch a modal progress bar
+    data inits^stage_file_dialog_inits
+    call stage_progress_dialog(inits)
+
+    #state null appsrc and unref
+    importx "_gst_object_unref" gst_object_unref
+    call gst_object_unref(appsrc)
+    #state null pipe, remove the watch and unref the pipe
+    import "default_unref" default_unref
+    call default_unref(pipe)
+endfunction
+
+function stage_save_all()
+    #verify for one frame and not mass remove
+    import "frame_jobs" frame_jobs
+    sd bool
+    setcall bool frame_jobs()
+    if bool!=1
+        return 0
+    endif
+
+    #file format
+    sd format
+    import "stage_file_get_format" stage_file_get_format
+    setcall format stage_file_get_format()
+    import "cmpmem" cmpmem
+
+    str mk="mkv"
+    sd cmp
+    setcall cmp cmpmem(format,mk,3)
+    if cmp=(equalCompare)
+        import "mkvfile" mkvfile
+        call mkvfile((capture_flag_off))
+        return 1
+    endif
+
+    import "is_local_avi" is_local_avi
+    setcall bool is_local_avi()
+    if bool=1
+        import "aviwrite" aviwrite
+        call aviwrite(0)
+        return 1
+    endif
+
+    import "slen" slen
+    str mp4="mp4"
+    setcall cmp cmpmem(format,mp4,3)
+    if cmp=(equalCompare)
+        import "mp4_write" mp4_write
+        call mp4_write()
+        return 1
+    endif
+
+    data file_frames%stage_file_frames
+    set file_frames# 0
+    data file_frames_portions%stage_file_frames_portions
+    set file_frames_portions 0
+
+    ss pipeformat="appsrc is-live=true name=%s ! ffmpegcolorspace ! %s ! filesink location=\"%s\""
+    ss srcname
+    ss outformat
+    ss location
+    sd *=0
+    sd strings^pipeformat
+
+    setcall srcname stage_get_src_name()
+    import "stage_file_get_format_name" stage_file_get_format_name
+    setcall outformat stage_file_get_format_name()
+
+    import "save_destination" save_destination
+    setcall location save_destination(format)
+    data copy%stage_file_path
+    set copy# location
+
+    import "allocsum_null" allocsum_null
+    sd mem
+    sd ptr_mem^mem
+    sd err
+    data noerr=noerror
+    setcall err allocsum_null(strings,ptr_mem)
+    if err!=noerr
+        return err
+    endif
+
+    call sprintf(mem,pipeformat,srcname,outformat,location)
+
+    call stage_file_command(mem)
+
+    call free(mem)
+endfunction
+
+
+#bool
+function stage_jpeg_write(sd file,sd pixbuf)
+    import "jpeg_quality" jpeg_quality
+    sd quality
+    setcall quality jpeg_quality((value_get))
+
+    #flip the value, so 1 is best 900 is lowest
+    import "rule3_two_offsets" rule3_two_offsets
+    setcall quality rule3_two_offsets((jpeg_min_quality),quality,(jpeg_max_quality),(jpeg_max_quality),(jpeg_min_quality))
+
+    import "write_jpeg" write_jpeg
+    sd bool
+    setcall bool write_jpeg(file,pixbuf,quality)
+    return bool
+endfunction
+
+
+
+
+
+
+function av_frames(sd action,sd value)
+    data image_nr#1
+    if action=(value_set)
+        set image_nr value
+    elseif action=(value_get)
+        return image_nr
+    else
+        #const get_buffer=value_extra
+    #0/pixbuf
+        #image_nr = frame index
+        sd eventbox
+        setcall eventbox stage_nthwidgetFromcontainer(image_nr)
+        if eventbox=0
+            return 0
+        endif
+
+        sd pix
+        setcall pix object_get_dword_name(eventbox)
+
+        return pix
+    endelse
+endfunction
+
+#return width*height
+function av_frames_mainpixbuf_sizes(sd wh)
+    import "pixbuf_get_wh" pixbuf_get_wh
+    sd w
+    sd h
+    sd _w_h_^w
+    sd pixbuf
+    setcall pixbuf av_frames((get_buffer))
+    call pixbuf_get_wh(pixbuf,_w_h_)
+    import "cpymem" cpymem
+    call cpymem(wh,_w_h_,(2*4))
+    sd imagesize
+    set imagesize w
+    #rgb=3 bytes
+    mult imagesize 3
+    mult imagesize h
+    return imagesize
+endfunction
+
+function av_good_fps(sd ptr_fps)
+    if ptr_fps#=0
+        set ptr_fps# 1
+        str fpsnotzero="Frames-per-second can not be 0"
+        call texter(fpsnotzero)
+    endif
+endfunction
+
+
+import "alloc_block" alloc_block
+
+function stage_read_values(sd action,sd append,sd append_size)
+    data mem#1
+    data size#1
+	if action=(value_set)
+    #bool
+        setcall mem alloc_block((value_set))
+        if mem=0
+            return 0
+        endif
+        set size 0
+        return 1
+	endif
+	if action=(value_unset)
+        call free(mem)
+	elseif action=(value_append)
+    #bool
+        sd appendresult
+        setcall appendresult alloc_block((value_append),mem,size,append,append_size)
+        if appendresult=0
+            return 0
+        endif
+        set mem appendresult
+        add size append_size
+        return 1
+	elseif action=(value_write)
+        sd cursor
+        set cursor mem
+        sd pixbuf
+        sd frames
+        while size!=0
+            set pixbuf cursor#
+            sub size 4
+            add cursor 4
+
+            set frames cursor#
+            sub size 4
+            add cursor 4
+
+            #add to stage
+            import "stage_new_frame_with_timelength" stage_new_frame_with_timelength
+            call stage_new_frame_with_timelength(pixbuf,frames)
+        endwhile
+	else
+    #if action==(value_custom)
+    #increment the last frame length
+    #bool
+        if size=0
+            return 0
+        endif
+        sd pointer
+        set pointer mem
+        add pointer size
+        sub pointer 4
+        inc pointer#
+        return 1
+	endelse
+endfunction
+
+
+
+
+function stage_files_read()
+    import "filechooserfield" filechooserfield
+    sd filename
+    setcall filename filechooserfield()
+    if filename=0
+        return 0
+    endif
+
+    import "path_extension" path_extension
+    ss extension
+    setcall extension path_extension(filename)
+    sd length
+    setcall length slen(extension)
+    sd format=format_raw
+    if length=3
+        sd compare
+        str avi="avi"
+        setcall compare cmpmem(avi,extension,3)
+        if compare=(equalCompare)
+            set format (format_avi)
+        else
+            str mkv="mkv"
+            setcall compare cmpmem(mkv,extension,3)
+            if compare=(equalCompare)
+                set format (format_mkv)
+            endif
+        endelse
+    endif
+
+    import "aviread" aviread
+    import "stage_mkv_read" stage_mkv_read
+    import "capture_raw_read" capture_raw_read
+    if format=(format_avi)
+        call aviread(filename)
+    elseif format=(format_mkv)
+        call stage_mkv_read(filename)
+    else
+        call capture_raw_read(filename)
+    endelse
+
+    #redraw the visual sound pulse
+    import "sound_pixbuf_redraw" sound_pixbuf_redraw
+    call sound_pixbuf_redraw()
+
+    call free(filename)
+endfunction
+
+
+
--- ovideo-1.orig/src/_prepare/output/all.s
+++ /dev/null
@@ -1,640 +0,0 @@
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-importx "_sprintf" sprintf
-
-data dialog#1
-const stage_file_dialog^dialog
-
-function stage_progress_dialog(sd inits)
-    data modal=GTK_DIALOG_MODAL
-    import "dialogfield_size_button" dialogfield_size_button
-    ss title="Save stage"
-    data width=150
-    data height=100
-    str GTK_STOCK_CANCEL="gtk-cancel"
-    data responsecancel=GTK_RESPONSE_CANCEL
-    call dialogfield_size_button(title,modal,inits,0,width,height,GTK_STOCK_CANCEL,responsecancel)
-    #set the dialog to null
-    data ptr_dialog%stage_file_dialog
-    set ptr_dialog# 0
-endfunction
-function stage_progress_dialog_inc(sd frame)
-    ss value=100
-    mult value frame
-    import "stage_get_frames" stage_get_frames
-    divcall value stage_get_frames()
-	char s={_0,Period}
-	char a#1
-	char b#1
-	char *=0
-	set b value
-	rem b 10
-	add b (_0)
-	set a value
-	div a 10
-	rem a 10
-	add a (_0)
-    sd doublelow
-    sd doublehigh
-    sd double^doublelow
-    str doubleformat="%lf"
-    importx "_sscanf" sscanf
-    call sscanf(#s,doubleformat,double)
-    importx "_gtk_progress_bar_set_fraction" gtk_progress_bar_set_fraction
-    data pbar#1
-    const progressbar^pbar
-    call gtk_progress_bar_set_fraction(pbar,doublelow,doublehigh)
-endfunction
-function stage_file_dialog_inits(sd vbox,sd dialog)
-    data ptr%stage_file_dialog
-    set ptr# dialog
-
-    #progress bar
-    import "progressfield" progressfield
-    sd widget
-    setcall widget progressfield(vbox)
-
-    importx "_gtk_progress_bar_set_text" gtk_progress_bar_set_text
-    str save="Save to file"
-    call gtk_progress_bar_set_text(widget,save)
-
-    data pbar%progressbar
-    set pbar# widget
-
-    #new texter
-    import "new_texter_modal" new_texter_modal
-    call new_texter_modal(vbox,dialog)
-endfunction
-function stage_file_close()
-    importx "_gtk_dialog_response" gtk_dialog_response
-    sd d%stage_file_dialog
-    data z=0
-    if d#!=z
-        data responsecancel=GTK_RESPONSE_CANCEL
-        call gtk_dialog_response(d#,responsecancel)
-        set d# z
-    endif
-endfunction
-
-
-
-
-function stage_file_error(sd *bus,sd message,sd *data)
-    import "def_error" def_error
-    call def_error(message)
-    call stage_file_close()
-endfunction
-function stage_file_eos(sd *bus,sd *message,sd *data)
-    call stage_file_close()
-endfunction
-
-function stage_get_src_name()
-    str s="source"
-    return s
-endfunction
-#eventbox/0
-function stage_nthwidgetFromcontainer(sd value)
-    import "nthwidgetFromcontainer" nthwidgetFromcontainer
-    import "stage_get_frames_container" stage_get_frames_container
-    sd container
-    setcall container stage_get_frames_container()
-    sd eventbox
-    setcall eventbox nthwidgetFromcontainer(container,value)
-    return eventbox
-endfunction
-
-import "object_get_dword_name" object_get_dword_name
-
-#pixbuf/0
-function stage_nthPixbufFromContainer(sd value)
-    sd container
-    setcall container stage_get_frames_container()
-    sd eventbox
-    setcall eventbox nthwidgetFromcontainer(container,value)
-    if eventbox==0
-        return 0
-    endif
-    sd pixbuf
-    setcall pixbuf object_get_dword_name(eventbox)
-    return pixbuf
-endfunction
-
-import "texter" texter
-
-function stage_prepare_pixbuf(sd pixbuf,sd mem,sd w,sd h)
-    sd px_pixels
-    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-    setcall px_pixels gdk_pixbuf_get_pixels(pixbuf)
-
-    sd px_bps
-    importx "_gdk_pixbuf_get_bits_per_sample" gdk_pixbuf_get_bits_per_sample
-    setcall px_bps gdk_pixbuf_get_bits_per_sample(pixbuf)
-
-    data minbps=pixbuf_minbps
-    if px_bps<minbps
-        str bpser="Bits-per-sample to few."
-        call texter(bpser)
-        return bpser
-    endif
-
-    sd px_nchan
-    importx "_gdk_pixbuf_get_n_channels" gdk_pixbuf_get_n_channels
-    setcall px_nchan gdk_pixbuf_get_n_channels(pixbuf)
-
-    data minnchan=pixbuf_minnchan
-    if px_nchan<minnchan
-        str nchaner="N-channels to few."
-        call texter(nchaner)
-        return nchaner
-    endif
-
-    sd px_rowstride
-    importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
-    setcall px_rowstride gdk_pixbuf_get_rowstride(pixbuf)
-
-    import "rgb_get_set" rgb_get_set
-    data rowstart=0
-    sd x
-    sd y=0
-    while y!=h
-        set x rowstart
-        while x!=w
-            call rgb_get_set(mem,px_pixels,x,y,px_bps,px_nchan,px_rowstride,(get_rgb))
-            data a=4
-            add mem a
-            inc x
-        endwhile
-        inc y
-    endwhile
-endfunction
-
-function stage_frame_size(sd w,sd h)
-    sd bpp=stage_bpp
-    sd size
-    set size w
-    mult size h
-    sd Bpp
-    set Bpp bpp
-    data bitsperbyte=8
-    div Bpp bitsperbyte
-    mult size Bpp
-    return size
-endfunction
-
-function stage_file_frame_main_set(sd ptr_pack,sd eventbox)
-    data a=4
-
-    sd pix
-    setcall pix object_get_dword_name(eventbox)
-    set ptr_pack# pix
-    add ptr_pack a
-
-    importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-    setcall ptr_pack# gdk_pixbuf_get_width(pix)
-    add ptr_pack a
-    setcall ptr_pack# gdk_pixbuf_get_height(pix)
-endfunction
-
-importx "_free" free
-
-#all returns of this timeout are false to not launch it again from here
-function stage_file_need_fn(sd appsrc)
-    data file_frames#1
-    const stage_file_frames^file_frames
-    data file_frames_portions#1
-         #implementation for frame with length, like at mkv
-    const stage_file_frames_portions^file_frames_portions
-    sd eventbox
-    setcall eventbox stage_nthwidgetFromcontainer(file_frames)
-    if eventbox!=0
-        sd d%stage_file_dialog
-        data false=0
-        if d#==false
-            return false
-        endif
-
-        import "stage_get_fr_length" stage_get_fr_length
-        if file_frames_portions==0
-            setcall file_frames_portions stage_get_fr_length(eventbox)
-            call stage_progress_dialog_inc(file_frames)
-        endif
-        dec file_frames_portions
-        if file_frames_portions==0
-            inc file_frames
-        endif
-
-        sd pixbuf
-        sd w
-        sd h
-
-        sd ptr_pack^pixbuf
-        call stage_file_frame_main_set(ptr_pack,eventbox)
-
-        sd framesize
-        setcall framesize stage_frame_size(w,h)
-
-        import "memoryalloc" memoryalloc
-        sd mem
-        sd mem_ptr^mem
-        sd err
-        sd noerr=noerror
-        setcall err memoryalloc(framesize,mem_ptr)
-        if err!=noerr
-            call stage_file_close()
-            return false
-        endif
-
-        call stage_prepare_pixbuf(pixbuf,mem,w,h)
-
-        importx "_gst_app_buffer_new" gst_app_buffer_new
-        data free_fn^free
-        sd buffer
-        setcall buffer gst_app_buffer_new(mem,framesize,free_fn,mem)
-
-        ss capsformat="video/x-raw-rgb,width=%u,height=%u,bpp=%u,endianness=4321,red_mask=0xFF000000,green_mask=0xFF0000,blue_mask=0xFF00,framerate=%u/1"
-        char capsdata#200
-        str gstcaps^capsdata
-        sd bpp=stage_bpp
-        sd fps
-        import "stage_file_options_fps" stage_file_options_fps
-        setcall fps stage_file_options_fps()
-        call sprintf(gstcaps,capsformat,w,h,bpp,fps)
-
-        importx "_gst_caps_from_string" gst_caps_from_string
-        sd caps
-        setcall caps gst_caps_from_string(gstcaps)
-
-        importx "_gst_buffer_set_caps" gst_buffer_set_caps
-        call gst_buffer_set_caps(buffer,caps)
-
-        importx "_gst_caps_unref" gst_caps_unref
-        call gst_caps_unref(caps)
-
-        sd flow
-        sd ptr_flow^flow
-        importx "_g_signal_emit_by_name" g_signal_emit_by_name
-        str push="push-buffer"
-        call g_signal_emit_by_name(appsrc,push,buffer,ptr_flow)
-        importx "_gst_mini_object_unref" gst_mini_object_unref
-        call gst_mini_object_unref(buffer)
-        data ok=GST_FLOW_OK
-        if flow<ok
-            str notok="The flow is not ok."
-            call texter(notok)
-            call stage_file_close()
-            return false
-        endif
-
-        setcall eventbox stage_nthwidgetFromcontainer(file_frames)
-        if eventbox==0
-            #state must be play or pause
-            importx "_gst_app_src_end_of_stream" gst_app_src_end_of_stream
-            call gst_app_src_end_of_stream(appsrc)
-
-            import "save_inform_saved" save_inform_saved
-            data location#1
-            const stage_file_path^location
-            call save_inform_saved(location)
-        endif
-    endif
-    #timeout stop
-    return false
-endfunction
-function stage_file_need(sd appsrc,sd *arg1,sd *data)
-    importx "_gdk_threads_add_timeout" gdk_threads_add_timeout
-    #set a timeout to allow the progress bar redrawing
-    data msec=0
-    data f^stage_file_need_fn
-    call gdk_threads_add_timeout(msec,f,appsrc)
-endfunction
-
-import "connect_signal" connect_signal
-
-function stage_file_connects(sd bus)
-    data er^stage_file_error
-    str ermsg="message::error"
-    call connect_signal(bus,ermsg,er)
-    data es^stage_file_eos
-    str esmsg="message::eos"
-    call connect_signal(bus,esmsg,es)
-endfunction
-
-function stage_file_command(ss command)
-    #creates the pipe
-    import "launch_pipe_start" launch_pipe_start
-    sd pipe
-    setcall pipe launch_pipe_start(command)
-    if pipe==0
-        return 0
-    endif
-
-    #connect pipe error messages
-    import "bus_signals" bus_signals
-    data connects^stage_file_connects
-    call bus_signals(pipe,connects)
-
-    #connect appsrc to add pixbufs
-    importx "_gst_bin_get_by_name" gst_bin_get_by_name
-    ss srcname
-    setcall srcname stage_get_src_name()
-    sd appsrc
-    setcall appsrc gst_bin_get_by_name(pipe,srcname)
-    ss need="need-data"
-    data start^stage_file_need
-    call connect_signal(appsrc,need,start)
-    #set frames queue size
-    #use the first frame to set the frames queue size
-    sd firstframe
-    setcall firstframe stage_nthwidgetFromcontainer(0)
-    sd pixbuf
-    sd w
-    sd h
-    sd ptr_pack^pixbuf
-    call stage_file_frame_main_set(ptr_pack,firstframe)
-    sd queue
-    setcall queue stage_frame_size(w,h)
-    data queueframes=1
-    mult queue queueframes
-    importx "_gst_app_src_set_max_bytes" gst_app_src_set_max_bytes
-    call gst_app_src_set_max_bytes(appsrc,queue)
-
-    #launch a modal progress bar
-    data inits^stage_file_dialog_inits
-    call stage_progress_dialog(inits)
-
-    #state null appsrc and unref
-    importx "_gst_object_unref" gst_object_unref
-    call gst_object_unref(appsrc)
-    #state null pipe, remove the watch and unref the pipe
-    import "default_unref" default_unref
-    call default_unref(pipe)
-endfunction
-
-function stage_save_all()
-    #verify for one frame and not mass remove
-    import "frame_jobs" frame_jobs
-    sd bool
-    setcall bool frame_jobs()
-    if bool!=1
-        return 0
-    endif
-
-    #file format
-    sd format
-    import "stage_file_get_format" stage_file_get_format
-    setcall format stage_file_get_format()
-    import "cmpmem" cmpmem
-
-    str mk="mkv"
-    sd cmp
-    setcall cmp cmpmem(format,mk,3)
-    if cmp==(equalCompare)
-        import "mkvfile" mkvfile
-        call mkvfile((capture_flag_off))
-        return 1
-    endif
-
-    import "is_local_avi" is_local_avi
-    setcall bool is_local_avi()
-    if bool==1
-        import "aviwrite" aviwrite
-        call aviwrite(0)
-        return 1
-    endif
-
-    import "slen" slen
-    str mp4="mp4"
-    setcall cmp cmpmem(format,mp4,3)
-    if cmp==(equalCompare)
-        import "mp4_write" mp4_write
-        call mp4_write()
-        return 1
-    endif
-
-    data file_frames%stage_file_frames
-    set file_frames# 0
-    data file_frames_portions%stage_file_frames_portions
-    set file_frames_portions 0
-
-    ss pipeformat="appsrc is-live=true name=%s ! ffmpegcolorspace ! %s ! filesink location=\"%s\""
-    ss srcname
-    ss outformat
-    ss location
-    sd *=0
-    sd strings^pipeformat
-
-    setcall srcname stage_get_src_name()
-    import "stage_file_get_format_name" stage_file_get_format_name
-    setcall outformat stage_file_get_format_name()
-
-    import "save_destination" save_destination
-    setcall location save_destination(format)
-    data copy%stage_file_path
-    set copy# location
-
-    import "allocsum_null" allocsum_null
-    sd mem
-    sd ptr_mem^mem
-    sd err
-    data noerr=noerror
-    setcall err allocsum_null(strings,ptr_mem)
-    if err!=noerr
-        return err
-    endif
-
-    call sprintf(mem,pipeformat,srcname,outformat,location)
-
-    call stage_file_command(mem)
-
-    call free(mem)
-endfunction
-
-
-#bool
-function stage_jpeg_write(sd file,sd pixbuf)
-    import "jpeg_quality" jpeg_quality
-    sd quality
-    setcall quality jpeg_quality((value_get))
-
-    #flip the value, so 1 is best 900 is lowest
-    import "rule3_two_offsets" rule3_two_offsets
-    setcall quality rule3_two_offsets((jpeg_min_quality),quality,(jpeg_max_quality),(jpeg_max_quality),(jpeg_min_quality))
-
-    import "write_jpeg" write_jpeg
-    sd bool
-    setcall bool write_jpeg(file,pixbuf,quality)
-    return bool
-endfunction
-
-
-
-
-
-
-function av_frames(sd action,sd value)
-    data image_nr#1
-    if action==(value_set)
-        set image_nr value
-    elseif action==(value_get)
-        return image_nr
-    else
-        #const get_buffer=value_extra
-    #0/pixbuf
-        #image_nr = frame index
-        sd eventbox
-        setcall eventbox stage_nthwidgetFromcontainer(image_nr)
-        if eventbox==0
-            return 0
-        endif
-
-        sd pix
-        setcall pix object_get_dword_name(eventbox)
-
-        return pix
-    endelse
-endfunction
-
-#return width*height
-function av_frames_mainpixbuf_sizes(sd wh)
-    import "pixbuf_get_wh" pixbuf_get_wh
-    sd w
-    sd h
-    sd _w_h_^w
-    sd pixbuf
-    setcall pixbuf av_frames((get_buffer))
-    call pixbuf_get_wh(pixbuf,_w_h_)
-    import "cpymem" cpymem
-    call cpymem(wh,_w_h_,(2*4))
-    sd imagesize
-    set imagesize w
-    #rgb=3 bytes
-    mult imagesize 3
-    mult imagesize h
-    return imagesize
-endfunction
-
-function av_good_fps(sd ptr_fps)
-    if ptr_fps#==0
-        set ptr_fps# 1
-        str fpsnotzero="Frames-per-second can not be 0"
-        call texter(fpsnotzero)
-    endif
-endfunction
-
-
-import "alloc_block" alloc_block
-
-function stage_read_values(sd action,sd append,sd append_size)
-    data mem#1
-    data size#1
-    if action==(value_set)
-    #bool
-        setcall mem alloc_block((value_set))
-        if mem==0
-            return 0
-        endif
-        set size 0
-        return 1
-    elseif action==(value_unset)
-        call free(mem)
-    elseif action==(value_append)
-    #bool
-        sd appendresult
-        setcall appendresult alloc_block((value_append),mem,size,append,append_size)
-        if appendresult==0
-            return 0
-        endif
-        set mem appendresult
-        add size append_size
-        return 1
-    elseif action==(value_write)
-        sd cursor
-        set cursor mem
-        sd pixbuf
-        sd frames
-        while size!=0
-            set pixbuf cursor#
-            sub size 4
-            add cursor 4
-
-            set frames cursor#
-            sub size 4
-            add cursor 4
-
-            #add to stage
-            import "stage_new_frame_with_timelength" stage_new_frame_with_timelength
-            call stage_new_frame_with_timelength(pixbuf,frames)
-        endwhile
-    else
-    #if action==(value_custom)
-    #increment the last frame length
-    #bool
-        if size==0
-            return 0
-        endif
-        sd pointer
-        set pointer mem
-        add pointer size
-        sub pointer 4
-        inc pointer#
-        return 1
-    endelse
-endfunction
-
-
-
-
-function stage_files_read()
-    import "filechooserfield" filechooserfield
-    sd filename
-    setcall filename filechooserfield()
-    if filename==0
-        return 0
-    endif
-
-    import "path_extension" path_extension
-    ss extension
-    setcall extension path_extension(filename)
-    sd length
-    setcall length slen(extension)
-    sd format=format_raw
-    if length==3
-        sd compare
-        str avi="avi"
-        setcall compare cmpmem(avi,extension,3)
-        if compare==(equalCompare)
-            set format (format_avi)
-        else
-            str mkv="mkv"
-            setcall compare cmpmem(mkv,extension,3)
-            if compare==(equalCompare)
-                set format (format_mkv)
-            endif
-        endelse
-    endif
-
-    import "aviread" aviread
-    import "stage_mkv_read" stage_mkv_read
-    import "capture_raw_read" capture_raw_read
-    if format==(format_avi)
-        call aviread(filename)
-    elseif format==(format_mkv)
-        call stage_mkv_read(filename)
-    else
-        call capture_raw_read(filename)
-    endelse
-
-    #redraw the visual sound pulse
-    import "sound_pixbuf_redraw" sound_pixbuf_redraw
-    call sound_pixbuf_redraw()
-
-    call free(filename)
-endfunction
-
-
-
--- /dev/null
+++ ovideo-1/src/_prepare/output/avi.oc
@@ -0,0 +1,1384 @@
+
+
+
+format elfobj
+include "../../_include/include.h"
+
+
+Const AVIF_HASINDEX=0x00000010
+#Const AVIF_MUSTUSEINDEX=0x00000020
+Const AVIF_ISINTERLEAVED=0x00000100
+
+Const AVIIF_KEYFRAME=0x00000010
+
+const WAVE_FORMAT_PCM=1
+
+import "av_dialog_run" av_dialog_run
+import "av_dialog_close" av_dialog_close
+import "av_dialog_stop" av_dialog_stop
+
+import "stage_sound_sizedone" stage_sound_sizedone
+import "stage_sound_alloc_getremainingsize" stage_sound_alloc_getremainingsize
+
+#w_r, writeseek; means a function used at write and at read, at read it seeks instead of writes
+
+import "av_readwrite_value" av_readwrite_value
+
+#write
+
+import "stage_file_get_avi_encoder" stage_file_get_avi_encoder
+
+import "cmpmem" cmpmem
+
+#bool
+function is_local_avi()
+    import "stage_file_get_format" stage_file_get_format
+    sd format
+    setcall format stage_file_get_format()
+    str avi="avi"
+    sd cmp
+    setcall cmp cmpmem(format,avi,3)
+    if cmp=(equalCompare)
+        sd encoder
+        setcall encoder stage_file_get_avi_encoder()
+        if encoder!=(format_avi_raw)
+            return 1
+        endif
+    endif
+    return 0
+endfunction
+importx "_free" free
+#location
+function aviwrite(sd combo_flag,sd data)
+    #get file path
+    import "combo_location" combo_location
+    sd location
+    setcall location combo_location(combo_flag,data)
+
+    call avi_write_fname(location,(avi_new))
+
+    return location
+endfunction
+
+function avi_write_fname(ss location,sd expand)
+    #new file or expand file
+    call avi_expandvalue((value_set),expand)
+    sd method
+    if expand=(avi_new)
+        str w="w+b"
+        set method w
+    else
+        str rw="r+b"
+        set method rw
+    endelse
+
+    #init readwrite value
+    call av_readwrite_value((value_set),(write_file))
+    #init frames
+    import "av_frames" av_frames
+    call av_frames((value_set),0)
+
+    #inits
+    sd bool
+    setcall bool avi_index_mem((value_set))
+    if bool=0
+        return 0
+    endif
+
+    #open file and continue at forward
+    import "file_forward" file_forward
+    sd forward^avidialog
+    sd err
+    setcall err file_forward(location,method,forward)
+
+    #frees
+    call avi_index_mem((value_unset))
+
+    #
+    if err=(noerror)
+        import "save_inform_saved" save_inform_saved
+        call save_inform_saved(location)
+    endif
+endfunction
+
+#read
+
+import "stage_read_values" stage_read_values
+
+function aviread(ss filepath)
+    #write_read flag
+    call av_readwrite_value((value_set),(read_file))
+
+    #values init
+    sd bool
+    setcall bool stage_read_values((value_set))
+    if bool!=1
+        return 0
+    endif
+
+    import "file_forward_read" file_forward_read
+    data f^avidialog
+    call file_forward_read(filepath,f)
+
+    #values write and free
+    call stage_read_values((value_write))
+    call stage_read_values((value_unset))
+endfunction
+
+#
+
+#expand
+
+function avi_expandvalue(sd action,sd value)
+    data expandvalue#1
+    if action=(value_set)
+        set expandvalue value
+    else
+        return expandvalue
+    endelse
+endfunction
+
+#
+
+import "riff_chunk_w_r" riff_chunk_w_r
+import "riff_w_r_name" riff_w_r_name
+
+##read/write start
+
+#er
+function avidialog(sd file)
+    #encoder inits
+    sd bool
+    data f^avicontent
+    setcall bool av_dialog_run(f,file)
+    if bool!=1
+        return (error)
+    endif
+    return (noerror)
+endfunction
+
+
+
+#bool
+function avicontent(sd file)
+    ss riff="RIFF"
+    data f^aviriff
+    sd bool
+    setcall bool riff_chunk_w_r(file,f,riff)
+    call av_dialog_close()
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function aviriff(sd file)
+    ss avi="AVI "
+    sd bool
+    setcall bool riff_w_r_name(file,avi)
+    if bool!=1
+        return 0
+    endif
+    #
+
+    #header list
+    ss list="LIST"
+    data f^avi_hdrl
+    setcall bool riff_chunk_w_r(file,f,list)
+    if bool!=1
+        return 0
+    endif
+
+    sd io
+    sd encoder
+    setcall io av_readwrite_value((value_get))
+    if io=(write_file)
+        setcall encoder stage_write_avi_encoder((value_get))
+        if encoder=(format_avi_xvid)
+            import "stage_mpeg_init" stage_mpeg_init
+            setcall bool stage_mpeg_init(file)
+            if bool!=1
+                return (error)
+            endif
+        endif
+    endif
+    setcall bool avi_movi_index(file)
+    if io=(write_file)
+        if encoder=(format_avi_xvid)
+            import "mpeg_release" mpeg_release
+            call mpeg_release()
+        endif
+    endif
+    return bool
+endfunction
+
+#bool
+function avi_movi_index(sd file)
+    sd bool
+
+    #movi list
+    ss list="LIST"
+    sd io
+    setcall io av_readwrite_value((value_get))
+    call avi_movi_flag((value_set),io)
+    if io=(write_file)
+        sd expand
+        setcall expand avi_expandvalue((value_get))
+        if expand=(avi_expand)
+            call av_readwrite_value((value_set),(read_file))
+        endif
+    endif
+    data m_f^avi_movi
+    setcall bool riff_chunk_w_r(file,m_f,list)
+    if bool!=1
+        return 0
+    endif
+
+    #index
+    ss index="idx1"
+    data ind_f^avi_index
+    setcall bool riff_chunk_w_r(file,ind_f,index)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+##
+#bool
+function avi_hdrl(sd file)
+    sd bool
+
+    ss hdrl="hdrl"
+    setcall bool riff_w_r_name(file,hdrl)
+    if bool=0
+        return 0
+    endif
+    #
+
+    #avi header
+    ss avih="avih"
+    data h_f^avi_avih
+    setcall bool riff_chunk_w_r(file,h_f,avih)
+    if bool=0
+        return 0
+    endif
+
+    #video stream
+    ss list="LIST"
+    data strl_f^avi_streamlist
+    setcall bool riff_chunk_w_r(file,strl_f,list)
+    if bool=0
+        return 0
+    endif
+
+    #audio stream
+    sd audio=0
+    sd is_from_read=1
+    sd w_r
+    setcall w_r av_readwrite_value((value_get))
+    if w_r=(write_file)
+        sd expand
+        setcall expand avi_expandvalue((value_get))
+        if expand=(avi_new)
+            sd sz
+            setcall sz stage_sound_alloc_getremainingsize()
+            if sz!=0
+                set audio 1
+            endif
+            set is_from_read 0
+        endif
+    endif
+    if is_from_read=1
+        sd streams
+        setcall streams avi_read_streams((value_get))
+        if streams=2
+            set audio 1
+        endif
+    endif
+    if audio=1
+        data f_audio^avi_strl_audio
+        setcall bool riff_chunk_w_r(file,f_audio,list)
+        if bool!=1
+            return 0
+        endif
+    endif
+
+    #odml header
+    data odml_f^avi_odml
+    setcall bool riff_chunk_w_r(file,odml_f,list)
+    if bool=0
+        return 0
+    endif
+
+    return 1
+endfunction
+
+import "av_frames_mainpixbuf_sizes" av_frames_mainpixbuf_sizes
+import "stage_file_options_fps" stage_file_options_fps
+import "stage_frame_time_numbers" stage_frame_time_numbers
+import "file_write" file_write
+import "file_read" file_read
+import "file_read_and_back_with_intervening_call" file_read_and_back_with_intervening_call
+
+#AVIMAINHEADER
+
+#bool
+function avi_avih(sd file)
+    data dwMicroSecPerFrame#1
+    #max(sum of file bytes/sec)
+    data dwMaxBytesPerSec#1
+    #entries pad=0
+    data dwPaddingGranularity#1
+    data dwFlags#1
+    data dwTotalFrames#1
+    #initial frames=0
+    data dwInitialFrames#1
+    data dwStreams#1
+    #playback buffer size
+    data dwSuggestedBufferSize#1
+    data dwWidth#1
+    data dwHeight#1
+    data *dwReserved#4
+
+    data AVIMAINHEADER^dwMicroSecPerFrame
+
+    const _AVIMAINHEADER^dwMicroSecPerFrame
+    const AVIMAINHEADER_^AVIMAINHEADER
+    data size=AVIMAINHEADER_-_AVIMAINHEADER
+
+    sd w_r
+    sd err
+    setcall w_r av_readwrite_value((value_get))
+
+    if w_r=(write_file)
+        #sound init
+        call stage_sound_sizedone((value_set),0)
+
+        sd expand
+        setcall expand avi_expandvalue((value_get))
+        if expand=(avi_new)
+            set dwPaddingGranularity 0
+            set dwInitialFrames 0
+
+            sd wh^dwWidth
+
+            set dwMicroSecPerFrame (1000*1000)
+            sd fps
+            setcall fps stage_file_options_fps()
+            div dwMicroSecPerFrame fps
+
+            setcall dwMaxBytesPerSec av_frames_mainpixbuf_sizes(wh)
+            mult dwMaxBytesPerSec 2
+            set dwSuggestedBufferSize dwMaxBytesPerSec
+
+            set dwFlags (AVIF_HASINDEX)
+
+            #dwTotalFrames: new 0+frames
+            set dwTotalFrames 0
+
+            set dwStreams 1
+            #sound write verification
+            #get the size
+            sd sound_size
+            setcall sound_size stage_sound_alloc_getremainingsize()
+            if sound_size!=0
+                inc dwStreams
+            endif
+        else
+            #avi_expand
+            setcall err file_read_and_back_with_intervening_call(AVIMAINHEADER,size,file)
+            if err!=(noerror)
+                return 0
+            endif
+            #flags
+            if dwStreams=2
+                or dwFlags (AVIF_ISINTERLEAVED)
+            endif
+            #set the number of streams
+            call avi_read_streams((value_set),dwStreams)
+        endelse
+        #add the frames
+        addcall dwTotalFrames stage_frame_time_numbers((stage_frame_time_total_sum))
+        #write to file
+        setcall err file_write(AVIMAINHEADER,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        setcall err file_read(AVIMAINHEADER,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+        call avi_read_width((value_set),dwWidth)
+        call avi_read_height((value_set),dwHeight)
+        call avi_read_streams((value_set),dwStreams)
+    endelse
+
+    return 1
+endfunction
+
+
+function avi_streamlist(sd file)
+    sd bool
+
+    ss strl="strl"
+    setcall bool riff_w_r_name(file,strl)
+    if bool=0
+        return 0
+    endif
+    #
+    ss strh="strh"
+    data strh_f^avi_streamheader
+    setcall bool riff_chunk_w_r(file,strh_f,strh)
+    if bool=0
+        return 0
+    endif
+
+    ss strf="strf"
+    data strf_f^avi_streamformat
+    setcall bool riff_chunk_w_r(file,strf_f,strf)
+    if bool=0
+        return 0
+    endif
+
+    return 1
+endfunction
+
+import "cpymem" cpymem
+
+#AVISTREAMHEADER
+
+#bool
+function avi_streamheader(sd file)
+    data fccType#1
+    data fccHandler#1
+    data dwFlags#1
+    data wPriority_wLanguage#1
+    data dwInitialFrames#1
+    data dwScale#1
+    #dwRate/dwScale=fps
+    data dwRate#1
+    data dwStart#1
+    data dwLength#1
+    data dwSuggestedBufferSize#1
+    data dwQuality#1
+    data dwSampleSize#1
+    data left_top#1
+    data right_bottom#1
+
+    data AVISTREAMHEADER^fccType
+
+    const _AVISTREAMHEADER^fccType
+    const AVISTREAMHEADER_^AVISTREAMHEADER
+    data size=AVISTREAMHEADER_-_AVISTREAMHEADER
+
+    str fcc^fccHandler
+
+    sd err
+    sd enc
+
+    sd w_r
+    setcall w_r av_readwrite_value((value_get))
+
+    if w_r=(write_file)
+        sd expand
+        setcall expand avi_expandvalue((value_get))
+        if expand=(avi_new)
+            str vds="vids"
+            call cpymem(AVISTREAMHEADER,vds,4)
+
+            set dwFlags 0
+            set wPriority_wLanguage 0
+            set dwInitialFrames 0
+            set dwScale 1
+            set dwStart 0
+            set dwQuality -1
+            set dwSampleSize 0
+            set left_top 0
+
+            setcall dwRate stage_file_options_fps()
+            set dwLength 0
+
+            sd w
+            sd h
+            sd wh^w
+
+            setcall dwSuggestedBufferSize av_frames_mainpixbuf_sizes(wh)
+            set right_bottom w
+            mult h 0x10000
+            or right_bottom h
+
+            setcall enc stage_file_get_avi_encoder()
+        else
+            setcall err file_read_and_back_with_intervening_call(AVISTREAMHEADER,size,file)
+            if err!=(noerror)
+                return 0
+            endif
+
+            setcall enc avi_video_fcc((value_get),fcc)
+        endelse
+        call stage_write_avi_encoder((value_set),enc)
+        if expand=(avi_new)
+            call avi_video_fcc((value_set),fcc)
+        endif
+
+        addcall dwLength stage_frame_time_numbers((stage_frame_time_total_sum))
+
+        setcall err file_write(AVISTREAMHEADER,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        setcall err file_read(AVISTREAMHEADER,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+
+        import "av_good_fps" av_good_fps
+        data p_dwRate^dwRate
+        call av_good_fps(p_dwRate)
+        call avi_read_fps((value_set),dwRate)
+
+        setcall enc avi_video_fcc((value_get),fcc)
+        call avi_read_encoder((value_set),enc)
+    endelse
+    return 1
+endfunction
+
+function avi_video_fcc(sd action,ss fcc)
+    if action=(value_set)
+        str i420="I420"
+        str jpg="MJPG"
+        str xvid="XVID"
+
+        sd encoder
+
+        setcall encoder stage_write_avi_encoder((value_get))
+        if encoder=(format_avi_i420)
+            call cpymem(fcc,i420,4)
+        elseif encoder=(format_avi_mjpg)
+            call cpymem(fcc,jpg,4)
+        else
+        #if encoder==(format_avi_xvid)
+            call cpymem(fcc,xvid,4)
+        endelse
+    else
+        sd compare
+
+        setcall compare cmpmem(fcc,i420,4)
+        if compare=(equalCompare)
+            return (format_avi_i420)
+        endif
+        setcall compare cmpmem(fcc,jpg,4)
+        if compare=(equalCompare)
+            return (format_avi_mjpg)
+        endif
+        return (format_avi_xvid)
+    endelse
+endfunction
+
+#bool
+function avi_streamformat(sd file)
+    data biSize=40
+    data biWidth#1
+    data biHeight#1
+    char *biPlanes={1,0}
+    char biBitCount={24,0}
+    char biCompression#4
+    data biSizeImage#1
+    data *biXPelsPerMeter=0
+    data *biYPelsPerMeter=0
+    data *biClrUsed=0
+    data *biClrImportant=0
+
+    data BITMAPINFOHEADER^biSize
+
+    const _BITMAPINFOHEADER^biSize
+    const BITMAPINFOHEADER_^BITMAPINFOHEADER
+    data size=BITMAPINFOHEADER_-_BITMAPINFOHEADER
+
+    sd w_r
+    setcall w_r av_readwrite_value((value_get))
+
+    if w_r=(write_file)
+        data fcc^biCompression
+        call avi_video_fcc((value_set),fcc)
+
+        sd wh^biWidth
+        setcall biSizeImage av_frames_mainpixbuf_sizes(wh)
+
+        sd encoder
+        setcall encoder stage_write_avi_encoder((value_get))
+        if encoder=(format_avi_i420)
+            set biBitCount 12
+            import "yuv_get_size" yuv_get_size
+            setcall biSizeImage yuv_get_size(biWidth,biHeight)
+        else
+            set biBitCount 24
+        endelse
+
+        sd err
+        setcall err file_write(BITMAPINFOHEADER,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function avi_strl_audio(sd file)
+    sd bool
+
+    ss strl="strl"
+    setcall bool riff_w_r_name(file,strl)
+    if bool!=1
+        return 0
+    endif
+    #
+    ss strh="strh"
+    data strh_f^avi_streamheader_audio
+    setcall bool riff_chunk_w_r(file,strh_f,strh)
+    if bool=0
+        return 0
+    endif
+
+    ss strf="strf"
+    data strf_f^avi_streamformat_audio
+    setcall bool riff_chunk_w_r(file,strf_f,strf)
+    if bool=0
+        return 0
+    endif
+
+    return 1
+endfunction
+
+#bool
+function avi_streamheader_audio(sd file)
+    char fccType={a,u,d,s}
+    data *fccHandler=0
+    data *dwFlags=0
+    char *wPriority={0,0}
+    char *wLanguage={0,0}
+    data *dwInitialFrames=0
+    #blockalign
+    data dwScale#1
+    #avgbytes_per_sec
+    data dwRate#1
+    data *dwStart=0
+    data dwLength#1
+    data dwSuggestedBufferSize#1
+    data *dwQuality=-1
+    data dwSampleSize#1
+    data *left_top=0
+    data *right_bottom=0
+
+    data AVISTREAMHEADER_audio^fccType
+    const _AVISTREAMHEADER_audio^fccType
+    const AVISTREAMHEADER__audio^AVISTREAMHEADER_audio
+    data size=AVISTREAMHEADER__audio-_AVISTREAMHEADER_audio
+
+    sd w_r
+    setcall w_r av_readwrite_value((value_get))
+
+    if w_r=(write_file)
+        import "stage_sound_blockalign" stage_sound_blockalign
+        setcall dwScale stage_sound_blockalign()
+        set dwSampleSize dwScale
+        import "stage_sound_avgbytespersec" stage_sound_avgbytespersec
+        setcall dwRate stage_sound_avgbytespersec()
+
+        sd err
+        #suggested size and length
+        sd suggestedsize
+        sd length
+        setcall suggestedsize stage_sound_alloc_getremainingsize()
+        set length suggestedsize
+        div length dwSampleSize
+        #add new expand bytes
+        sd expand
+        setcall expand avi_expandvalue((value_get))
+        if expand=(avi_expand)
+            setcall err file_read_and_back_with_intervening_call(AVISTREAMHEADER_audio,size,file)
+            if err!=(noerror)
+                return 0
+            endif
+            import "get_higher" get_higher
+            setcall suggestedsize get_higher(suggestedsize,dwSuggestedBufferSize)
+            add length dwLength
+        endif
+        #set
+        set dwSuggestedBufferSize suggestedsize
+        set dwLength length
+        #write all
+        setcall err file_write(AVISTREAMHEADER_audio,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+function avi_streamformat_audio(sd file)
+    #WAVEFORMATEX
+    char wFormatTag={WAVE_FORMAT_PCM,0}
+    char nChannels={1,0}
+    data nSamplesPerSec#1
+    data nAvgBytesPerSec#1
+    char nBlockAlign={2,0}
+    char wBitsPerSample={16,0}
+    #EX
+    #no extra data, simple PCM-format used
+    char *cbSize={0,0}
+
+    data WAVEFORMATEX^wFormatTag
+
+    const _WAVEFORMATEX^wFormatTag
+    const WAVEFORMATEX_^WAVEFORMATEX
+    data size=WAVEFORMATEX_-_WAVEFORMATEX
+
+    sd w_r
+    setcall w_r av_readwrite_value((value_get))
+
+    if w_r=(write_file)
+        import "stage_sound_channels" stage_sound_channels
+        import "stage_sound_rate" stage_sound_rate
+        import "stage_sound_bps" stage_sound_bps
+        setcall nChannels stage_sound_channels((value_get))
+        setcall nSamplesPerSec stage_sound_rate((value_get))
+        setcall wBitsPerSample stage_sound_bps((value_get))
+        setcall nBlockAlign stage_sound_blockalign()
+        setcall nAvgBytesPerSec stage_sound_avgbytespersec()
+
+        sd err
+        setcall err file_write(WAVEFORMATEX,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function avi_odml(sd file)
+    ss odml="odml"
+    sd bool
+    setcall bool riff_w_r_name(file,odml)
+    if bool!=1
+        return 0
+    endif
+
+    char dmlh={d,m,l,h}
+    data *size=4
+    data value#1
+
+    data DMLH^dmlh
+    data odml_sz=3*4
+
+    sd w_r
+    setcall w_r av_readwrite_value((value_get))
+    if w_r=(write_file)
+        sd err
+        set value 0
+        sd expand
+        setcall expand avi_expandvalue((value_get))
+        if expand=(avi_expand)
+            setcall err file_read_and_back_with_intervening_call(DMLH,odml_sz,file)
+            if err!=(noerror)
+                return 0
+            endif
+        endif
+        addcall value stage_frame_time_numbers((stage_frame_time_total_sum))
+        setcall err file_write(DMLH,odml_sz,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function avi_movi(sd file,sd offset,ss *name,sd size)
+    sd prev_io
+    setcall prev_io avi_movi_flag((value_get))
+    call av_readwrite_value((value_set),prev_io)
+
+    sd bool
+
+    sd expand=avi_new
+    sd w_r
+    setcall w_r av_readwrite_value((value_get))
+    if w_r=(write_file)
+        setcall expand avi_expandvalue((value_get))
+        #here, if it is expanding, jump over the current data, get the previous index, and continue
+        if expand=(avi_expand)
+            setcall bool avi_expanding(file,size,offset)
+            if bool!=1
+                return 0
+            endif
+        endif
+    endif
+    if expand=(avi_new)
+        ss mv="movi"
+        setcall bool riff_w_r_name(file,mv)
+        if bool!=1
+            return 0
+        endif
+    endif
+
+    if w_r=(write_file)
+        sd audio_sz
+        setcall audio_sz stage_sound_alloc_getremainingsize()
+        if audio_sz!=0
+            data forward_write_audio^avi_write_frame_audio
+            str audio_id="01wb"
+            setcall bool avi_index_mem((value_append),file,offset,0,audio_id,forward_write_audio,(AVIIF_KEYFRAME))
+            if bool!=1
+                return 0
+            endif
+        endif
+        sd encoder
+        setcall encoder stage_write_avi_encoder((value_get))
+    endif
+
+    sd loop=1
+    while loop=1
+        sd stop
+        setcall stop av_dialog_stop((value_get))
+        if stop=1
+            set loop 0
+        else
+            if w_r=(write_file)
+                #verify for last frame
+                sd pixbuf
+                setcall pixbuf av_frames((get_buffer))
+                if pixbuf=0
+                    return 1
+                endif
+                #get the frame length
+                sd framelength
+                sd currentframe
+                setcall currentframe av_frames((value_get))
+                setcall framelength stage_frame_time_numbers((stage_frame_time_get_at_index),currentframe)
+                #loop the frame length
+                sd i=0
+                while i!=framelength
+                    data forward_write_video^avi_write_frame
+                    str video_id_key="00db"
+                    str video_id_p="00dc"
+                    ss video_id
+                    sd flags
+                    if i=0
+                        set flags (AVIIF_KEYFRAME)
+                        if encoder=(format_avi_xvid)
+                            import "stage_mpeg_encode" stage_mpeg_encode
+                            data is_keyframe#1
+                            data p_is_keyframe^is_keyframe
+                            setcall bool stage_mpeg_encode(pixbuf,currentframe,p_is_keyframe)
+                            if bool!=1
+                                return 0
+                            endif
+                            if is_keyframe=(FALSE)
+                                set flags 0
+                            endif
+                        endif
+                    else
+                        set flags 0
+                    endelse
+                    if flags=(AVIIF_KEYFRAME)
+                        set video_id video_id_key
+                    else
+                        set video_id video_id_p
+                    endelse
+                    setcall loop avi_index_mem((value_append),file,offset,i,video_id,forward_write_video,flags)
+                    if loop=0
+                        return 0
+                    endif
+                    #increment iter
+                    inc i
+                endwhile
+                #increment current frame and print info
+                inc currentframe
+                call av_frames((value_set),currentframe)
+                import "av_display_progress" av_display_progress
+                call av_display_progress(currentframe,(capture_flag_off))
+            else
+                if size=0
+                    set loop 0
+                else
+                    data f_video^avi_read_entries
+                    setcall loop riff_chunk_w_r(file,f_video,0)
+                    if loop=1
+                        import "file_tell" file_tell
+
+                        sd off
+                        sd p_off^off
+                        sd err
+                        setcall err file_tell(file,p_off)
+                        if err!=(noerror)
+                            return 0
+                        endif
+                        sub off offset
+                        if off=size
+                            set loop 0
+                        endif
+                    endif
+                endelse
+            endelse
+        endelse
+    endwhile
+    return 1
+endfunction
+
+
+#bool
+function avi_index(sd file)
+    sd bool
+    setcall bool avi_index_mem((value_filewrite),file)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+import "alloc_block" alloc_block
+
+const value_expand=value_custom
+
+function avi_index_mem(sd action,sd file,sd offset,sd i,ss identifier,sd forward,sd flags)
+    data index_mem#1
+    data size#1
+
+    data p_size^size
+
+	if action=(value_set)
+    #bool
+        set size 0
+        setcall index_mem alloc_block((value_set))
+        if index_mem=0
+            return 0
+        endif
+        return 1
+	endif
+	if action=(value_unset)
+        call alloc_block((value_unset),index_mem)
+	elseif action=(value_append)
+    #bool
+        const avi_index_entry_size=0x10
+
+        data avi_oldindex_dwChunkId#1
+        data avi_oldindex_dwFlags#1
+        data avi_oldindex_dwOffset#1
+        data avi_oldindex_dwSize#1
+
+        data avi_oldindex^avi_oldindex_dwChunkId
+
+        data seek_off#1
+        data p_seek_off^seek_off
+
+        sd err
+        sd bool
+
+        #write identifier
+        call cpymem(avi_oldindex,identifier,4)
+
+        #get the file offset
+        setcall err file_tell(file,p_seek_off)
+        if err!=(noerror)
+            return 0
+        endif
+        set avi_oldindex_dwOffset seek_off
+        sub avi_oldindex_dwOffset offset
+
+        if i=0
+            #write the frame
+            setcall bool riff_chunk_w_r(file,forward,avi_oldindex)
+            if bool!=1
+                return 0
+            endif
+        else
+            #write empty frame
+            setcall err file_write(avi_oldindex,4,file)
+            if err!=(noerror)
+                return 0
+            endif
+            data null=0
+            data p_null^null
+            setcall err file_write(p_null,4,file)
+            if err!=(noerror)
+                return 0
+            endif
+        endelse
+
+        #get the frame size and write the value at index
+        #bool
+        import "file_seek_set" file_seek_set
+        add seek_off 4
+        setcall err file_seek_set(file,seek_off)
+        if err!=(noerror)
+            return 0
+        endif
+        import "file_get_dword" file_get_dword
+        sd p_sz^avi_oldindex_dwSize
+        setcall err file_get_dword(file,p_sz)
+        if err!=(noerror)
+            return 0
+        endif
+        import "file_seek_end" file_seek_end
+        call file_seek_end(file)
+
+        #avi index add
+        #write the index flags
+        set avi_oldindex_dwFlags flags
+        #add to mem
+        setcall index_mem alloc_block((value_append),index_mem,size,avi_oldindex,(avi_index_entry_size))
+        if index_mem=0
+            return 0
+        endif
+        add size (avi_index_entry_size)
+        return 1
+	elseif action=(value_expand)
+    #bool
+        import "file_seek_cursor" file_seek_cursor
+        setcall err file_seek_cursor(file,4)
+        if err!=(noerror)
+            return 0
+        endif
+
+        setcall err file_read(p_size,4,file)
+        if err!=(noerror)
+            return 0
+        endif
+
+        setcall index_mem alloc_block((value_append),index_mem,0,0,size)
+        if index_mem=0
+            return 0
+        endif
+
+        setcall err file_read(index_mem,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+        return 1
+	else
+    #bool
+        #value_filewrite
+        setcall err file_write(index_mem,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+        return 1
+	endelse
+endfunction
+
+function avi_write_frame(sd file)
+    #get the pixbuf
+    sd pixbuf
+    setcall pixbuf av_frames((get_buffer))
+    if pixbuf=0
+        return 0
+    endif
+
+    #info prepare
+    import "av_display_info" av_display_info
+    call av_display_info((value_get),file)
+
+    #encode the frame or only write
+    sd encoder
+    sd bool
+    setcall encoder stage_write_avi_encoder((value_get))
+    if encoder=(format_avi_i420)
+        importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+        import "pixbuf_get_wh" pixbuf_get_wh
+        sd width
+        sd height
+        sd width_height^width
+        sd pixels
+        call pixbuf_get_wh(pixbuf,width_height)
+        setcall pixels gdk_pixbuf_get_pixels(pixbuf)
+
+        import "rgb_to_yuvi420_write" rgb_to_yuvi420_write
+        sd err
+        setcall err rgb_to_yuvi420_write(pixels,width,height,file)
+        if err!=(noerror)
+            return 0
+        endif
+    elseif encoder=(format_avi_mjpg)
+        import "stage_jpeg_write" stage_jpeg_write
+        setcall bool stage_jpeg_write(file,pixbuf)
+        if bool!=1
+            return 0
+        endif
+    else
+    #if encoder==(format_avi_xvid)
+        import "mpeg_file_mem" mpeg_file_mem
+        setcall bool mpeg_file_mem((value_filewrite))
+        if bool!=1
+            return 0
+        endif
+    endelse
+
+    #info display
+    sd currentframe
+    setcall currentframe av_frames((value_get))
+    call av_display_info((value_write),file,currentframe)
+
+    return 1
+endfunction
+
+function avi_write_frame_audio(sd file)
+    sd audio_sz
+    setcall audio_sz stage_sound_alloc_getremainingsize()
+
+    import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
+    sd bytes
+    setcall bytes stage_sound_alloc_getbytes()
+    sd err
+    setcall err file_write(bytes,audio_sz,file)
+    if err!=(noerror)
+        return 0
+    endif
+
+    call stage_sound_sizedone((value_set),audio_sz)
+
+    return 1
+endfunction
+
+#
+
+function avi_read_fps(sd action,sd value)
+    data read_fps#1
+    if action=(value_set)
+        set read_fps value
+    else
+        return read_fps
+    endelse
+endfunction
+function avi_read_width(sd action,sd value)
+    data read_width#1
+    if action=(value_set)
+        set read_width value
+    else
+        return read_width
+    endelse
+endfunction
+function avi_read_height(sd action,sd value)
+    data read_height#1
+    if action=(value_set)
+        set read_height value
+    else
+        return read_height
+    endelse
+endfunction
+function avi_read_streams(sd action,sd value)
+    data read_streams#1
+    if action=(value_set)
+        set read_streams value
+    else
+        return read_streams
+    endelse
+endfunction
+function avi_read_buffer(sd action,sd value)
+    data read_buffer#1
+    if action=(value_set)
+        set read_buffer value
+    else
+        return read_buffer
+    endelse
+endfunction
+function avi_read_encoder(sd action,sd value)
+    data read_encoder#1
+    if action=(value_set)
+        set read_encoder value
+    else
+        return read_encoder
+    endelse
+endfunction
+
+#bool
+function avi_read_entries(sd file,sd *file_pos,ss chunk_id,sd chunk_size)
+    sd bool
+    sd is_video=0
+    ss video_iframe="00db"
+    sd compare
+    setcall compare cmpmem(chunk_id,video_iframe,4)
+    if compare=(equalCompare)
+        set is_video 1
+    endif
+    ss video_pframe="00dc"
+    setcall compare cmpmem(chunk_id,video_pframe,4)
+    if compare=(equalCompare)
+        set is_video 1
+    endif
+
+	if is_video=1
+        if chunk_size=0
+        #extend previous frame length
+            setcall bool stage_read_values((value_custom))
+            if bool!=1
+                return 0
+            endif
+            return 1
+        endif
+
+        #get width and height
+        import "memalloc" memalloc
+        import "rgb_get_size" rgb_get_size
+        sd width
+        sd height
+        setcall width avi_read_width((value_get))
+        setcall height avi_read_height((value_get))
+        #get image size
+        sd size
+        setcall size rgb_get_size(width,height)
+        #alloc buffer
+        sd rgbbuffer
+        setcall rgbbuffer memalloc(size)
+        if rgbbuffer=0
+            return 0
+        endif
+        call avi_read_buffer((value_set),rgbbuffer)
+        #read
+        sd encoder
+        setcall encoder avi_read_encoder((value_get))
+        if encoder=(format_avi_i420)
+            #read yuv
+            import "yuv_to_rgb_from_file" yuv_to_rgb_from_file
+            sd yuvbuffer
+            sd yuvsize
+            setcall yuvsize yuv_get_size(width,height)
+            setcall yuvbuffer memalloc(yuvsize)
+            if yuvbuffer=0
+                return 0
+            endif
+            setcall bool yuv_to_rgb_from_file(file,yuvbuffer,rgbbuffer,width,height)
+            call free(yuvbuffer)
+            if bool!=1
+                return 0
+            endif
+        else
+            #read jpeg
+            import "read_jpeg" read_jpeg
+            data f^avi_read_video
+            setcall bool read_jpeg(file,f)
+            if bool!=1
+                return 0
+            endif
+        endelse
+
+        #info display
+        call av_display_info((value_write),file,-1,chunk_size)
+
+        #make pixbuf
+        importx "_gdk_pixbuf_new_from_data" gdk_pixbuf_new_from_data
+        import "rgb_get_rowstride" rgb_get_rowstride
+        data free_pixbuf^free
+        sd rowstride
+        setcall rowstride rgb_get_rowstride(width)
+        sd pixbuf
+        sd *length=1
+        setcall pixbuf gdk_pixbuf_new_from_data(rgbbuffer,(GDK_COLORSPACE_RGB),(FALSE),8,width,height,rowstride,free_pixbuf,rgbbuffer)
+
+        #add to stage buffer
+        sd entry^pixbuf
+        setcall bool stage_read_values((value_append),entry,8)
+        if bool!=1
+            return 0
+        endif
+        return 1
+	endif
+    #is audio
+        #01wb
+        import "file_get_size_forward" file_get_size_forward
+        data f_audio^avi_read_sound
+        sd err
+        setcall err file_get_size_forward(file,chunk_size,f_audio)
+        if err!=(noerror)
+            return 0
+        endif
+        return 1
+endfunction
+
+#bool
+function avi_read_video(sd bytes,sd rowstride,sd rowindex)
+    sd width
+    sd height
+    setcall width avi_read_width((value_get))
+    setcall height avi_read_height((value_get))
+    sd buffer
+    setcall buffer avi_read_buffer((value_get))
+
+    import "av_read_row" av_read_row
+    sd bool
+    setcall bool av_read_row(width,height,buffer,bytes,rowstride,rowindex)
+    return bool
+endfunction
+
+function avi_read_sound(sd mem,sd size)
+    import "stage_sound_alloc_expand" stage_sound_alloc_expand
+    call stage_sound_alloc_expand(mem,size)
+endfunction
+
+
+
+##expanding
+
+function avi_movi_flag(sd action,sd value)
+    data movi_flag#1
+    if action=(value_set)
+        set movi_flag value
+    else
+        return movi_flag
+    endelse
+endfunction
+
+#bool
+function avi_expanding(sd file,sd size,sd offset)
+    sd err
+
+    #jump over the current data
+    setcall err file_seek_cursor(file,size)
+    if err!=(noerror)
+        return 0
+    endif
+
+    sd bool
+    setcall bool avi_index_mem((value_expand),file)
+
+    #seek back to add more frames
+    add offset size
+    setcall err file_seek_set(file,offset)
+    if err!=(noerror)
+        return 0
+    endif
+
+    return 1
+endfunction
+
+
+
+function stage_write_avi_encoder(sd action,sd value)
+    data enc#1
+    if action=(value_set)
+        set enc value
+    else
+        return enc
+    endelse
+endfunction
--- ovideo-1.orig/src/_prepare/output/avi.s
+++ /dev/null
@@ -1,1384 +0,0 @@
-
-
-
-format elfobj
-include "../../_include/include.h"
-
-
-Const AVIF_HASINDEX=0x00000010
-#Const AVIF_MUSTUSEINDEX=0x00000020
-Const AVIF_ISINTERLEAVED=0x00000100
-
-Const AVIIF_KEYFRAME=0x00000010
-
-const WAVE_FORMAT_PCM=1
-
-import "av_dialog_run" av_dialog_run
-import "av_dialog_close" av_dialog_close
-import "av_dialog_stop" av_dialog_stop
-
-import "stage_sound_sizedone" stage_sound_sizedone
-import "stage_sound_alloc_getremainingsize" stage_sound_alloc_getremainingsize
-
-#w_r, writeseek; means a function used at write and at read, at read it seeks instead of writes
-
-import "av_readwrite_value" av_readwrite_value
-
-#write
-
-import "stage_file_get_avi_encoder" stage_file_get_avi_encoder
-
-import "cmpmem" cmpmem
-
-#bool
-function is_local_avi()
-    import "stage_file_get_format" stage_file_get_format
-    sd format
-    setcall format stage_file_get_format()
-    str avi="avi"
-    sd cmp
-    setcall cmp cmpmem(format,avi,3)
-    if cmp==(equalCompare)
-        sd encoder
-        setcall encoder stage_file_get_avi_encoder()
-        if encoder!=(format_avi_raw)
-            return 1
-        endif
-    endif
-    return 0
-endfunction
-importx "_free" free
-#location
-function aviwrite(sd combo_flag,sd data)
-    #get file path
-    import "combo_location" combo_location
-    sd location
-    setcall location combo_location(combo_flag,data)
-
-    call avi_write_fname(location,(avi_new))
-
-    return location
-endfunction
-
-function avi_write_fname(ss location,sd expand)
-    #new file or expand file
-    call avi_expandvalue((value_set),expand)
-    sd method
-    if expand==(avi_new)
-        str w="w+b"
-        set method w
-    else
-        str rw="r+b"
-        set method rw
-    endelse
-
-    #init readwrite value
-    call av_readwrite_value((value_set),(write_file))
-    #init frames
-    import "av_frames" av_frames
-    call av_frames((value_set),0)
-
-    #inits
-    sd bool
-    setcall bool avi_index_mem((value_set))
-    if bool==0
-        return 0
-    endif
-
-    #open file and continue at forward
-    import "file_forward" file_forward
-    sd forward^avidialog
-    sd err
-    setcall err file_forward(location,method,forward)
-
-    #frees
-    call avi_index_mem((value_unset))
-
-    #
-    if err==(noerror)
-        import "save_inform_saved" save_inform_saved
-        call save_inform_saved(location)
-    endif
-endfunction
-
-#read
-
-import "stage_read_values" stage_read_values
-
-function aviread(ss filepath)
-    #write_read flag
-    call av_readwrite_value((value_set),(read_file))
-
-    #values init
-    sd bool
-    setcall bool stage_read_values((value_set))
-    if bool!=1
-        return 0
-    endif
-
-    import "file_forward_read" file_forward_read
-    data f^avidialog
-    call file_forward_read(filepath,f)
-
-    #values write and free
-    call stage_read_values((value_write))
-    call stage_read_values((value_unset))
-endfunction
-
-#
-
-#expand
-
-function avi_expandvalue(sd action,sd value)
-    data expandvalue#1
-    if action==(value_set)
-        set expandvalue value
-    else
-        return expandvalue
-    endelse
-endfunction
-
-#
-
-import "riff_chunk_w_r" riff_chunk_w_r
-import "riff_w_r_name" riff_w_r_name
-
-##read/write start
-
-#er
-function avidialog(sd file)
-    #encoder inits
-    sd bool
-    data f^avicontent
-    setcall bool av_dialog_run(f,file)
-    if bool!=1
-        return (error)
-    endif
-    return (noerror)
-endfunction
-
-
-
-#bool
-function avicontent(sd file)
-    ss riff="RIFF"
-    data f^aviriff
-    sd bool
-    setcall bool riff_chunk_w_r(file,f,riff)
-    call av_dialog_close()
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function aviriff(sd file)
-    ss avi="AVI "
-    sd bool
-    setcall bool riff_w_r_name(file,avi)
-    if bool!=1
-        return 0
-    endif
-    #
-
-    #header list
-    ss list="LIST"
-    data f^avi_hdrl
-    setcall bool riff_chunk_w_r(file,f,list)
-    if bool!=1
-        return 0
-    endif
-
-    sd io
-    sd encoder
-    setcall io av_readwrite_value((value_get))
-    if io==(write_file)
-        setcall encoder stage_write_avi_encoder((value_get))
-        if encoder==(format_avi_xvid)
-            import "stage_mpeg_init" stage_mpeg_init
-            setcall bool stage_mpeg_init(file)
-            if bool!=1
-                return (error)
-            endif
-        endif
-    endif
-    setcall bool avi_movi_index(file)
-    if io==(write_file)
-        if encoder==(format_avi_xvid)
-            import "mpeg_release" mpeg_release
-            call mpeg_release()
-        endif
-    endif
-    return bool
-endfunction
-
-#bool
-function avi_movi_index(sd file)
-    sd bool
-
-    #movi list
-    ss list="LIST"
-    sd io
-    setcall io av_readwrite_value((value_get))
-    call avi_movi_flag((value_set),io)
-    if io==(write_file)
-        sd expand
-        setcall expand avi_expandvalue((value_get))
-        if expand==(avi_expand)
-            call av_readwrite_value((value_set),(read_file))
-        endif
-    endif
-    data m_f^avi_movi
-    setcall bool riff_chunk_w_r(file,m_f,list)
-    if bool!=1
-        return 0
-    endif
-
-    #index
-    ss index="idx1"
-    data ind_f^avi_index
-    setcall bool riff_chunk_w_r(file,ind_f,index)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-##
-#bool
-function avi_hdrl(sd file)
-    sd bool
-
-    ss hdrl="hdrl"
-    setcall bool riff_w_r_name(file,hdrl)
-    if bool==0
-        return 0
-    endif
-    #
-
-    #avi header
-    ss avih="avih"
-    data h_f^avi_avih
-    setcall bool riff_chunk_w_r(file,h_f,avih)
-    if bool==0
-        return 0
-    endif
-
-    #video stream
-    ss list="LIST"
-    data strl_f^avi_streamlist
-    setcall bool riff_chunk_w_r(file,strl_f,list)
-    if bool==0
-        return 0
-    endif
-
-    #audio stream
-    sd audio=0
-    sd is_from_read=1
-    sd w_r
-    setcall w_r av_readwrite_value((value_get))
-    if w_r==(write_file)
-        sd expand
-        setcall expand avi_expandvalue((value_get))
-        if expand==(avi_new)
-            sd sz
-            setcall sz stage_sound_alloc_getremainingsize()
-            if sz!=0
-                set audio 1
-            endif
-            set is_from_read 0
-        endif
-    endif
-    if is_from_read==1
-        sd streams
-        setcall streams avi_read_streams((value_get))
-        if streams==2
-            set audio 1
-        endif
-    endif
-    if audio==1
-        data f_audio^avi_strl_audio
-        setcall bool riff_chunk_w_r(file,f_audio,list)
-        if bool!=1
-            return 0
-        endif
-    endif
-
-    #odml header
-    data odml_f^avi_odml
-    setcall bool riff_chunk_w_r(file,odml_f,list)
-    if bool==0
-        return 0
-    endif
-
-    return 1
-endfunction
-
-import "av_frames_mainpixbuf_sizes" av_frames_mainpixbuf_sizes
-import "stage_file_options_fps" stage_file_options_fps
-import "stage_frame_time_numbers" stage_frame_time_numbers
-import "file_write" file_write
-import "file_read" file_read
-import "file_read_and_back_with_intervening_call" file_read_and_back_with_intervening_call
-
-#AVIMAINHEADER
-
-#bool
-function avi_avih(sd file)
-    data dwMicroSecPerFrame#1
-    #max(sum of file bytes/sec)
-    data dwMaxBytesPerSec#1
-    #entries pad=0
-    data dwPaddingGranularity#1
-    data dwFlags#1
-    data dwTotalFrames#1
-    #initial frames=0
-    data dwInitialFrames#1
-    data dwStreams#1
-    #playback buffer size
-    data dwSuggestedBufferSize#1
-    data dwWidth#1
-    data dwHeight#1
-    data *dwReserved#4
-
-    data AVIMAINHEADER^dwMicroSecPerFrame
-
-    const _AVIMAINHEADER^dwMicroSecPerFrame
-    const AVIMAINHEADER_^AVIMAINHEADER
-    data size=AVIMAINHEADER_-_AVIMAINHEADER
-
-    sd w_r
-    sd err
-    setcall w_r av_readwrite_value((value_get))
-
-    if w_r==(write_file)
-        #sound init
-        call stage_sound_sizedone((value_set),0)
-
-        sd expand
-        setcall expand avi_expandvalue((value_get))
-        if expand==(avi_new)
-            set dwPaddingGranularity 0
-            set dwInitialFrames 0
-
-            sd wh^dwWidth
-
-            set dwMicroSecPerFrame (1000*1000)
-            sd fps
-            setcall fps stage_file_options_fps()
-            div dwMicroSecPerFrame fps
-
-            setcall dwMaxBytesPerSec av_frames_mainpixbuf_sizes(wh)
-            mult dwMaxBytesPerSec 2
-            set dwSuggestedBufferSize dwMaxBytesPerSec
-
-            set dwFlags (AVIF_HASINDEX)
-
-            #dwTotalFrames: new 0+frames
-            set dwTotalFrames 0
-
-            set dwStreams 1
-            #sound write verification
-            #get the size
-            sd sound_size
-            setcall sound_size stage_sound_alloc_getremainingsize()
-            if sound_size!=0
-                inc dwStreams
-            endif
-        else
-            #avi_expand
-            setcall err file_read_and_back_with_intervening_call(AVIMAINHEADER,size,file)
-            if err!=(noerror)
-                return 0
-            endif
-            #flags
-            if dwStreams==2
-                or dwFlags (AVIF_ISINTERLEAVED)
-            endif
-            #set the number of streams
-            call avi_read_streams((value_set),dwStreams)
-        endelse
-        #add the frames
-        addcall dwTotalFrames stage_frame_time_numbers((stage_frame_time_total_sum))
-        #write to file
-        setcall err file_write(AVIMAINHEADER,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        setcall err file_read(AVIMAINHEADER,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-        call avi_read_width((value_set),dwWidth)
-        call avi_read_height((value_set),dwHeight)
-        call avi_read_streams((value_set),dwStreams)
-    endelse
-
-    return 1
-endfunction
-
-
-function avi_streamlist(sd file)
-    sd bool
-
-    ss strl="strl"
-    setcall bool riff_w_r_name(file,strl)
-    if bool==0
-        return 0
-    endif
-    #
-    ss strh="strh"
-    data strh_f^avi_streamheader
-    setcall bool riff_chunk_w_r(file,strh_f,strh)
-    if bool==0
-        return 0
-    endif
-
-    ss strf="strf"
-    data strf_f^avi_streamformat
-    setcall bool riff_chunk_w_r(file,strf_f,strf)
-    if bool==0
-        return 0
-    endif
-
-    return 1
-endfunction
-
-import "cpymem" cpymem
-
-#AVISTREAMHEADER
-
-#bool
-function avi_streamheader(sd file)
-    data fccType#1
-    data fccHandler#1
-    data dwFlags#1
-    data wPriority_wLanguage#1
-    data dwInitialFrames#1
-    data dwScale#1
-    #dwRate/dwScale=fps
-    data dwRate#1
-    data dwStart#1
-    data dwLength#1
-    data dwSuggestedBufferSize#1
-    data dwQuality#1
-    data dwSampleSize#1
-    data left_top#1
-    data right_bottom#1
-
-    data AVISTREAMHEADER^fccType
-
-    const _AVISTREAMHEADER^fccType
-    const AVISTREAMHEADER_^AVISTREAMHEADER
-    data size=AVISTREAMHEADER_-_AVISTREAMHEADER
-
-    str fcc^fccHandler
-
-    sd err
-    sd enc
-
-    sd w_r
-    setcall w_r av_readwrite_value((value_get))
-
-    if w_r==(write_file)
-        sd expand
-        setcall expand avi_expandvalue((value_get))
-        if expand==(avi_new)
-            str vds="vids"
-            call cpymem(AVISTREAMHEADER,vds,4)
-
-            set dwFlags 0
-            set wPriority_wLanguage 0
-            set dwInitialFrames 0
-            set dwScale 1
-            set dwStart 0
-            set dwQuality -1
-            set dwSampleSize 0
-            set left_top 0
-
-            setcall dwRate stage_file_options_fps()
-            set dwLength 0
-
-            sd w
-            sd h
-            sd wh^w
-
-            setcall dwSuggestedBufferSize av_frames_mainpixbuf_sizes(wh)
-            set right_bottom w
-            mult h 0x10000
-            or right_bottom h
-
-            setcall enc stage_file_get_avi_encoder()
-        else
-            setcall err file_read_and_back_with_intervening_call(AVISTREAMHEADER,size,file)
-            if err!=(noerror)
-                return 0
-            endif
-
-            setcall enc avi_video_fcc((value_get),fcc)
-        endelse
-        call stage_write_avi_encoder((value_set),enc)
-        if expand==(avi_new)
-            call avi_video_fcc((value_set),fcc)
-        endif
-
-        addcall dwLength stage_frame_time_numbers((stage_frame_time_total_sum))
-
-        setcall err file_write(AVISTREAMHEADER,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        setcall err file_read(AVISTREAMHEADER,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-
-        import "av_good_fps" av_good_fps
-        data p_dwRate^dwRate
-        call av_good_fps(p_dwRate)
-        call avi_read_fps((value_set),dwRate)
-
-        setcall enc avi_video_fcc((value_get),fcc)
-        call avi_read_encoder((value_set),enc)
-    endelse
-    return 1
-endfunction
-
-function avi_video_fcc(sd action,ss fcc)
-    if action==(value_set)
-        str i420="I420"
-        str jpg="MJPG"
-        str xvid="XVID"
-
-        sd encoder
-
-        setcall encoder stage_write_avi_encoder((value_get))
-        if encoder==(format_avi_i420)
-            call cpymem(fcc,i420,4)
-        elseif encoder==(format_avi_mjpg)
-            call cpymem(fcc,jpg,4)
-        else
-        #if encoder==(format_avi_xvid)
-            call cpymem(fcc,xvid,4)
-        endelse
-    else
-        sd compare
-
-        setcall compare cmpmem(fcc,i420,4)
-        if compare==(equalCompare)
-            return (format_avi_i420)
-        endif
-        setcall compare cmpmem(fcc,jpg,4)
-        if compare==(equalCompare)
-            return (format_avi_mjpg)
-        endif
-        return (format_avi_xvid)
-    endelse
-endfunction
-
-#bool
-function avi_streamformat(sd file)
-    data biSize=40
-    data biWidth#1
-    data biHeight#1
-    char *biPlanes={1,0}
-    char biBitCount={24,0}
-    char biCompression#4
-    data biSizeImage#1
-    data *biXPelsPerMeter=0
-    data *biYPelsPerMeter=0
-    data *biClrUsed=0
-    data *biClrImportant=0
-
-    data BITMAPINFOHEADER^biSize
-
-    const _BITMAPINFOHEADER^biSize
-    const BITMAPINFOHEADER_^BITMAPINFOHEADER
-    data size=BITMAPINFOHEADER_-_BITMAPINFOHEADER
-
-    sd w_r
-    setcall w_r av_readwrite_value((value_get))
-
-    if w_r==(write_file)
-        data fcc^biCompression
-        call avi_video_fcc((value_set),fcc)
-
-        sd wh^biWidth
-        setcall biSizeImage av_frames_mainpixbuf_sizes(wh)
-
-        sd encoder
-        setcall encoder stage_write_avi_encoder((value_get))
-        if encoder==(format_avi_i420)
-            set biBitCount 12
-            import "yuv_get_size" yuv_get_size
-            setcall biSizeImage yuv_get_size(biWidth,biHeight)
-        else
-            set biBitCount 24
-        endelse
-
-        sd err
-        setcall err file_write(BITMAPINFOHEADER,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function avi_strl_audio(sd file)
-    sd bool
-
-    ss strl="strl"
-    setcall bool riff_w_r_name(file,strl)
-    if bool!=1
-        return 0
-    endif
-    #
-    ss strh="strh"
-    data strh_f^avi_streamheader_audio
-    setcall bool riff_chunk_w_r(file,strh_f,strh)
-    if bool==0
-        return 0
-    endif
-
-    ss strf="strf"
-    data strf_f^avi_streamformat_audio
-    setcall bool riff_chunk_w_r(file,strf_f,strf)
-    if bool==0
-        return 0
-    endif
-
-    return 1
-endfunction
-
-#bool
-function avi_streamheader_audio(sd file)
-    char fccType={a,u,d,s}
-    data *fccHandler=0
-    data *dwFlags=0
-    char *wPriority={0,0}
-    char *wLanguage={0,0}
-    data *dwInitialFrames=0
-    #blockalign
-    data dwScale#1
-    #avgbytes_per_sec
-    data dwRate#1
-    data *dwStart=0
-    data dwLength#1
-    data dwSuggestedBufferSize#1
-    data *dwQuality=-1
-    data dwSampleSize#1
-    data *left_top=0
-    data *right_bottom=0
-
-    data AVISTREAMHEADER_audio^fccType
-    const _AVISTREAMHEADER_audio^fccType
-    const AVISTREAMHEADER__audio^AVISTREAMHEADER_audio
-    data size=AVISTREAMHEADER__audio-_AVISTREAMHEADER_audio
-
-    sd w_r
-    setcall w_r av_readwrite_value((value_get))
-
-    if w_r==(write_file)
-        import "stage_sound_blockalign" stage_sound_blockalign
-        setcall dwScale stage_sound_blockalign()
-        set dwSampleSize dwScale
-        import "stage_sound_avgbytespersec" stage_sound_avgbytespersec
-        setcall dwRate stage_sound_avgbytespersec()
-
-        sd err
-        #suggested size and length
-        sd suggestedsize
-        sd length
-        setcall suggestedsize stage_sound_alloc_getremainingsize()
-        set length suggestedsize
-        div length dwSampleSize
-        #add new expand bytes
-        sd expand
-        setcall expand avi_expandvalue((value_get))
-        if expand==(avi_expand)
-            setcall err file_read_and_back_with_intervening_call(AVISTREAMHEADER_audio,size,file)
-            if err!=(noerror)
-                return 0
-            endif
-            import "get_higher" get_higher
-            setcall suggestedsize get_higher(suggestedsize,dwSuggestedBufferSize)
-            add length dwLength
-        endif
-        #set
-        set dwSuggestedBufferSize suggestedsize
-        set dwLength length
-        #write all
-        setcall err file_write(AVISTREAMHEADER_audio,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-function avi_streamformat_audio(sd file)
-    #WAVEFORMATEX
-    char wFormatTag={WAVE_FORMAT_PCM,0}
-    char nChannels={1,0}
-    data nSamplesPerSec#1
-    data nAvgBytesPerSec#1
-    char nBlockAlign={2,0}
-    char wBitsPerSample={16,0}
-    #EX
-    #no extra data, simple PCM-format used
-    char *cbSize={0,0}
-
-    data WAVEFORMATEX^wFormatTag
-
-    const _WAVEFORMATEX^wFormatTag
-    const WAVEFORMATEX_^WAVEFORMATEX
-    data size=WAVEFORMATEX_-_WAVEFORMATEX
-
-    sd w_r
-    setcall w_r av_readwrite_value((value_get))
-
-    if w_r==(write_file)
-        import "stage_sound_channels" stage_sound_channels
-        import "stage_sound_rate" stage_sound_rate
-        import "stage_sound_bps" stage_sound_bps
-        setcall nChannels stage_sound_channels((value_get))
-        setcall nSamplesPerSec stage_sound_rate((value_get))
-        setcall wBitsPerSample stage_sound_bps((value_get))
-        setcall nBlockAlign stage_sound_blockalign()
-        setcall nAvgBytesPerSec stage_sound_avgbytespersec()
-
-        sd err
-        setcall err file_write(WAVEFORMATEX,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function avi_odml(sd file)
-    ss odml="odml"
-    sd bool
-    setcall bool riff_w_r_name(file,odml)
-    if bool!=1
-        return 0
-    endif
-
-    char dmlh={d,m,l,h}
-    data *size=4
-    data value#1
-
-    data DMLH^dmlh
-    data odml_sz=3*4
-
-    sd w_r
-    setcall w_r av_readwrite_value((value_get))
-    if w_r==(write_file)
-        sd err
-        set value 0
-        sd expand
-        setcall expand avi_expandvalue((value_get))
-        if expand==(avi_expand)
-            setcall err file_read_and_back_with_intervening_call(DMLH,odml_sz,file)
-            if err!=(noerror)
-                return 0
-            endif
-        endif
-        addcall value stage_frame_time_numbers((stage_frame_time_total_sum))
-        setcall err file_write(DMLH,odml_sz,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function avi_movi(sd file,sd offset,ss *name,sd size)
-    sd prev_io
-    setcall prev_io avi_movi_flag((value_get))
-    call av_readwrite_value((value_set),prev_io)
-
-    sd bool
-
-    sd expand=avi_new
-    sd w_r
-    setcall w_r av_readwrite_value((value_get))
-    if w_r==(write_file)
-        setcall expand avi_expandvalue((value_get))
-        #here, if it is expanding, jump over the current data, get the previous index, and continue
-        if expand==(avi_expand)
-            setcall bool avi_expanding(file,size,offset)
-            if bool!=1
-                return 0
-            endif
-        endif
-    endif
-    if expand==(avi_new)
-        ss mv="movi"
-        setcall bool riff_w_r_name(file,mv)
-        if bool!=1
-            return 0
-        endif
-    endif
-
-    if w_r==(write_file)
-        sd audio_sz
-        setcall audio_sz stage_sound_alloc_getremainingsize()
-        if audio_sz!=0
-            data forward_write_audio^avi_write_frame_audio
-            str audio_id="01wb"
-            setcall bool avi_index_mem((value_append),file,offset,0,audio_id,forward_write_audio,(AVIIF_KEYFRAME))
-            if bool!=1
-                return 0
-            endif
-        endif
-        sd encoder
-        setcall encoder stage_write_avi_encoder((value_get))
-    endif
-
-    sd loop=1
-    while loop==1
-        sd stop
-        setcall stop av_dialog_stop((value_get))
-        if stop==1
-            set loop 0
-        else
-            if w_r==(write_file)
-                #verify for last frame
-                sd pixbuf
-                setcall pixbuf av_frames((get_buffer))
-                if pixbuf==0
-                    return 1
-                endif
-                #get the frame length
-                sd framelength
-                sd currentframe
-                setcall currentframe av_frames((value_get))
-                setcall framelength stage_frame_time_numbers((stage_frame_time_get_at_index),currentframe)
-                #loop the frame length
-                sd i=0
-                while i!=framelength
-                    data forward_write_video^avi_write_frame
-                    str video_id_key="00db"
-                    str video_id_p="00dc"
-                    ss video_id
-                    sd flags
-                    if i==0
-                        set flags (AVIIF_KEYFRAME)
-                        if encoder==(format_avi_xvid)
-                            import "stage_mpeg_encode" stage_mpeg_encode
-                            data is_keyframe#1
-                            data p_is_keyframe^is_keyframe
-                            setcall bool stage_mpeg_encode(pixbuf,currentframe,p_is_keyframe)
-                            if bool!=1
-                                return 0
-                            endif
-                            if is_keyframe==(FALSE)
-                                set flags 0
-                            endif
-                        endif
-                    else
-                        set flags 0
-                    endelse
-                    if flags==(AVIIF_KEYFRAME)
-                        set video_id video_id_key
-                    else
-                        set video_id video_id_p
-                    endelse
-                    setcall loop avi_index_mem((value_append),file,offset,i,video_id,forward_write_video,flags)
-                    if loop==0
-                        return 0
-                    endif
-                    #increment iter
-                    inc i
-                endwhile
-                #increment current frame and print info
-                inc currentframe
-                call av_frames((value_set),currentframe)
-                import "av_display_progress" av_display_progress
-                call av_display_progress(currentframe,(capture_flag_off))
-            else
-                if size==0
-                    set loop 0
-                else
-                    data f_video^avi_read_entries
-                    setcall loop riff_chunk_w_r(file,f_video,0)
-                    if loop==1
-                        import "file_tell" file_tell
-
-                        sd off
-                        sd p_off^off
-                        sd err
-                        setcall err file_tell(file,p_off)
-                        if err!=(noerror)
-                            return 0
-                        endif
-                        sub off offset
-                        if off==size
-                            set loop 0
-                        endif
-                    endif
-                endelse
-            endelse
-        endelse
-    endwhile
-    return 1
-endfunction
-
-
-#bool
-function avi_index(sd file)
-    sd bool
-    setcall bool avi_index_mem((value_filewrite),file)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-import "alloc_block" alloc_block
-
-const value_expand=value_custom
-
-function avi_index_mem(sd action,sd file,sd offset,sd i,ss identifier,sd forward,sd flags)
-    data index_mem#1
-    data size#1
-
-    data p_size^size
-
-    if action==(value_set)
-    #bool
-        set size 0
-        setcall index_mem alloc_block((value_set))
-        if index_mem==0
-            return 0
-        endif
-        return 1
-    elseif action==(value_unset)
-        call alloc_block((value_unset),index_mem)
-    elseif action==(value_append)
-    #bool
-        const avi_index_entry_size=0x10
-
-        data avi_oldindex_dwChunkId#1
-        data avi_oldindex_dwFlags#1
-        data avi_oldindex_dwOffset#1
-        data avi_oldindex_dwSize#1
-
-        data avi_oldindex^avi_oldindex_dwChunkId
-
-        data seek_off#1
-        data p_seek_off^seek_off
-
-        sd err
-        sd bool
-
-        #write identifier
-        call cpymem(avi_oldindex,identifier,4)
-
-        #get the file offset
-        setcall err file_tell(file,p_seek_off)
-        if err!=(noerror)
-            return 0
-        endif
-        set avi_oldindex_dwOffset seek_off
-        sub avi_oldindex_dwOffset offset
-
-        if i==0
-            #write the frame
-            setcall bool riff_chunk_w_r(file,forward,avi_oldindex)
-            if bool!=1
-                return 0
-            endif
-        else
-            #write empty frame
-            setcall err file_write(avi_oldindex,4,file)
-            if err!=(noerror)
-                return 0
-            endif
-            data null=0
-            data p_null^null
-            setcall err file_write(p_null,4,file)
-            if err!=(noerror)
-                return 0
-            endif
-        endelse
-
-        #get the frame size and write the value at index
-        #bool
-        import "file_seek_set" file_seek_set
-        add seek_off 4
-        setcall err file_seek_set(file,seek_off)
-        if err!=(noerror)
-            return 0
-        endif
-        import "file_get_dword" file_get_dword
-        sd p_sz^avi_oldindex_dwSize
-        setcall err file_get_dword(file,p_sz)
-        if err!=(noerror)
-            return 0
-        endif
-        import "file_seek_end" file_seek_end
-        call file_seek_end(file)
-
-        #avi index add
-        #write the index flags
-        set avi_oldindex_dwFlags flags
-        #add to mem
-        setcall index_mem alloc_block((value_append),index_mem,size,avi_oldindex,(avi_index_entry_size))
-        if index_mem==0
-            return 0
-        endif
-        add size (avi_index_entry_size)
-        return 1
-    elseif action==(value_expand)
-    #bool
-        import "file_seek_cursor" file_seek_cursor
-        setcall err file_seek_cursor(file,4)
-        if err!=(noerror)
-            return 0
-        endif
-
-        setcall err file_read(p_size,4,file)
-        if err!=(noerror)
-            return 0
-        endif
-
-        setcall index_mem alloc_block((value_append),index_mem,0,0,size)
-        if index_mem==0
-            return 0
-        endif
-
-        setcall err file_read(index_mem,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-        return 1
-    else
-    #bool
-        #value_filewrite
-        setcall err file_write(index_mem,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-        return 1
-    endelse
-endfunction
-
-function avi_write_frame(sd file)
-    #get the pixbuf
-    sd pixbuf
-    setcall pixbuf av_frames((get_buffer))
-    if pixbuf==0
-        return 0
-    endif
-
-    #info prepare
-    import "av_display_info" av_display_info
-    call av_display_info((value_get),file)
-
-    #encode the frame or only write
-    sd encoder
-    sd bool
-    setcall encoder stage_write_avi_encoder((value_get))
-    if encoder==(format_avi_i420)
-        importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-        import "pixbuf_get_wh" pixbuf_get_wh
-        sd width
-        sd height
-        sd width_height^width
-        sd pixels
-        call pixbuf_get_wh(pixbuf,width_height)
-        setcall pixels gdk_pixbuf_get_pixels(pixbuf)
-
-        import "rgb_to_yuvi420_write" rgb_to_yuvi420_write
-        sd err
-        setcall err rgb_to_yuvi420_write(pixels,width,height,file)
-        if err!=(noerror)
-            return 0
-        endif
-    elseif encoder==(format_avi_mjpg)
-        import "stage_jpeg_write" stage_jpeg_write
-        setcall bool stage_jpeg_write(file,pixbuf)
-        if bool!=1
-            return 0
-        endif
-    else
-    #if encoder==(format_avi_xvid)
-        import "mpeg_file_mem" mpeg_file_mem
-        setcall bool mpeg_file_mem((value_filewrite))
-        if bool!=1
-            return 0
-        endif
-    endelse
-
-    #info display
-    sd currentframe
-    setcall currentframe av_frames((value_get))
-    call av_display_info((value_write),file,currentframe)
-
-    return 1
-endfunction
-
-function avi_write_frame_audio(sd file)
-    sd audio_sz
-    setcall audio_sz stage_sound_alloc_getremainingsize()
-
-    import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
-    sd bytes
-    setcall bytes stage_sound_alloc_getbytes()
-    sd err
-    setcall err file_write(bytes,audio_sz,file)
-    if err!=(noerror)
-        return 0
-    endif
-
-    call stage_sound_sizedone((value_set),audio_sz)
-
-    return 1
-endfunction
-
-#
-
-function avi_read_fps(sd action,sd value)
-    data read_fps#1
-    if action==(value_set)
-        set read_fps value
-    else
-        return read_fps
-    endelse
-endfunction
-function avi_read_width(sd action,sd value)
-    data read_width#1
-    if action==(value_set)
-        set read_width value
-    else
-        return read_width
-    endelse
-endfunction
-function avi_read_height(sd action,sd value)
-    data read_height#1
-    if action==(value_set)
-        set read_height value
-    else
-        return read_height
-    endelse
-endfunction
-function avi_read_streams(sd action,sd value)
-    data read_streams#1
-    if action==(value_set)
-        set read_streams value
-    else
-        return read_streams
-    endelse
-endfunction
-function avi_read_buffer(sd action,sd value)
-    data read_buffer#1
-    if action==(value_set)
-        set read_buffer value
-    else
-        return read_buffer
-    endelse
-endfunction
-function avi_read_encoder(sd action,sd value)
-    data read_encoder#1
-    if action==(value_set)
-        set read_encoder value
-    else
-        return read_encoder
-    endelse
-endfunction
-
-#bool
-function avi_read_entries(sd file,sd *file_pos,ss chunk_id,sd chunk_size)
-    sd bool
-    sd is_video=0
-    ss video_iframe="00db"
-    sd compare
-    setcall compare cmpmem(chunk_id,video_iframe,4)
-    if compare==(equalCompare)
-        set is_video 1
-    endif
-    ss video_pframe="00dc"
-    setcall compare cmpmem(chunk_id,video_pframe,4)
-    if compare==(equalCompare)
-        set is_video 1
-    endif
-
-    if is_video==1
-        if chunk_size==0
-        #extend previous frame length
-            setcall bool stage_read_values((value_custom))
-            if bool!=1
-                return 0
-            endif
-            return 1
-        endif
-
-        #get width and height
-        import "memalloc" memalloc
-        import "rgb_get_size" rgb_get_size
-        sd width
-        sd height
-        setcall width avi_read_width((value_get))
-        setcall height avi_read_height((value_get))
-        #get image size
-        sd size
-        setcall size rgb_get_size(width,height)
-        #alloc buffer
-        sd rgbbuffer
-        setcall rgbbuffer memalloc(size)
-        if rgbbuffer==0
-            return 0
-        endif
-        call avi_read_buffer((value_set),rgbbuffer)
-        #read
-        sd encoder
-        setcall encoder avi_read_encoder((value_get))
-        if encoder==(format_avi_i420)
-            #read yuv
-            import "yuv_to_rgb_from_file" yuv_to_rgb_from_file
-            sd yuvbuffer
-            sd yuvsize
-            setcall yuvsize yuv_get_size(width,height)
-            setcall yuvbuffer memalloc(yuvsize)
-            if yuvbuffer==0
-                return 0
-            endif
-            setcall bool yuv_to_rgb_from_file(file,yuvbuffer,rgbbuffer,width,height)
-            call free(yuvbuffer)
-            if bool!=1
-                return 0
-            endif
-        else
-            #read jpeg
-            import "read_jpeg" read_jpeg
-            data f^avi_read_video
-            setcall bool read_jpeg(file,f)
-            if bool!=1
-                return 0
-            endif
-        endelse
-
-        #info display
-        call av_display_info((value_write),file,-1,chunk_size)
-
-        #make pixbuf
-        importx "_gdk_pixbuf_new_from_data" gdk_pixbuf_new_from_data
-        import "rgb_get_rowstride" rgb_get_rowstride
-        data free_pixbuf^free
-        sd rowstride
-        setcall rowstride rgb_get_rowstride(width)
-        sd pixbuf
-        sd *length=1
-        setcall pixbuf gdk_pixbuf_new_from_data(rgbbuffer,(GDK_COLORSPACE_RGB),(FALSE),8,width,height,rowstride,free_pixbuf,rgbbuffer)
-
-        #add to stage buffer
-        sd entry^pixbuf
-        setcall bool stage_read_values((value_append),entry,8)
-        if bool!=1
-            return 0
-        endif
-        return 1
-    else
-    #is audio
-        #01wb
-        import "file_get_size_forward" file_get_size_forward
-        data f_audio^avi_read_sound
-        sd err
-        setcall err file_get_size_forward(file,chunk_size,f_audio)
-        if err!=(noerror)
-            return 0
-        endif
-        return 1
-    endelse
-endfunction
-
-#bool
-function avi_read_video(sd bytes,sd rowstride,sd rowindex)
-    sd width
-    sd height
-    setcall width avi_read_width((value_get))
-    setcall height avi_read_height((value_get))
-    sd buffer
-    setcall buffer avi_read_buffer((value_get))
-
-    import "av_read_row" av_read_row
-    sd bool
-    setcall bool av_read_row(width,height,buffer,bytes,rowstride,rowindex)
-    return bool
-endfunction
-
-function avi_read_sound(sd mem,sd size)
-    import "stage_sound_alloc_expand" stage_sound_alloc_expand
-    call stage_sound_alloc_expand(mem,size)
-endfunction
-
-
-
-##expanding
-
-function avi_movi_flag(sd action,sd value)
-    data movi_flag#1
-    if action==(value_set)
-        set movi_flag value
-    else
-        return movi_flag
-    endelse
-endfunction
-
-#bool
-function avi_expanding(sd file,sd size,sd offset)
-    sd err
-
-    #jump over the current data
-    setcall err file_seek_cursor(file,size)
-    if err!=(noerror)
-        return 0
-    endif
-
-    sd bool
-    setcall bool avi_index_mem((value_expand),file)
-
-    #seek back to add more frames
-    add offset size
-    setcall err file_seek_set(file,offset)
-    if err!=(noerror)
-        return 0
-    endif
-
-    return 1
-endfunction
-
-
-
-function stage_write_avi_encoder(sd action,sd value)
-    data enc#1
-    if action==(value_set)
-        set enc value
-    else
-        return enc
-    endelse
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/output/mkv.oc
@@ -0,0 +1,1862 @@
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+import "dword_reverse" dword_reverse
+
+const mkv_write=0
+const mkv_read=1
+import "file_seek_cursor" file_seek_cursor
+import "file_get_dword_reverse" file_get_dword_reverse
+import "file_seek_cursor_get_dword_reverse" file_seek_cursor_get_dword_reverse
+import "memoryrealloc" memoryrealloc
+import "rgb_get_all_sizes" rgb_get_all_sizes
+
+import "pixbuf_from_pixbuf_reverse" pixbuf_from_pixbuf_reverse
+
+const mkv_yuv_init=0
+const mkv_yuv_p_bytes=1
+const mkv_yuv_set_size=2
+const mkv_yuv_get_size=3
+const mkv_yuv_get_bytes=4
+const mkv_yuv_free=5
+const mkv_rgb_get_p_bytes=6
+const mkv_rgb_set_size=7
+const mkv_rgb_get_size=8
+
+import "av_dialog_run" av_dialog_run
+import "av_dialog_close" av_dialog_close
+import "av_dialog_stop" av_dialog_stop
+
+import "stage_file_get_mkv_encoder" stage_file_get_mkv_encoder
+
+#write/capture node
+
+function mkvfile(sd capture_flag,sd file_number)
+    call mkv_capture((value_set),capture_flag)
+    data f^mkvfile_fn
+    call av_dialog_run(f,file_number)
+endfunction
+
+import "capture_obtain_screenshot" capture_obtain_screenshot
+
+function mkvfile_fn(sd data)
+    call mkv_write_read_set((mkv_write))
+
+    data location#1
+    const ptr_location^location
+    sd capture
+    setcall capture mkv_capture((value_get))
+
+    import "combo_location" combo_location
+    setcall location combo_location(capture,data)
+
+    import "file_write_forward" file_write_forward
+    data f^mkvfile_encoders
+    call file_write_forward(location,f)
+
+    call av_dialog_close()
+endfunction
+
+function mkvfile_encoders(sd file)
+    sd bool
+    sd encoder
+    setcall encoder stage_file_get_mkv_encoder()
+    if encoder=(format_mkv_xvid)
+        import "av_frames" av_frames
+        call av_frames((value_set),0)
+        import "stage_mpeg_init" stage_mpeg_init
+        setcall bool stage_mpeg_init(file)
+        if bool!=1
+            return 0
+        endif
+    endif
+
+    call mkvfile_headers(file)
+
+    if encoder=(format_mkv_xvid)
+        import "mpeg_release" mpeg_release
+        call mpeg_release()
+    endif
+endfunction
+
+function mkv_capture(sd action,sd value)
+    data capture#1
+    #bool value, true for capture, or false
+    if action=(value_set)
+        set capture value
+    else
+        return capture
+    endelse
+endfunction
+
+#
+
+##headers
+
+function mkvfile_headers(sd file)
+    #Extensible Binary Meta Language
+    #EBML Header, level 0
+    char EBML={0x1A,0x45,0xDF,0xA3}
+    char EBML_size#1
+    char EBMLVersion={0x42,0x86}
+    char *EBMLVersion_size=0x81
+    char *EBMLVersion_value=1
+    char *EBMLReadVersion={0x42,0xF7}
+    char *EBMLReadVersion_size=0x81
+    char *EBMLReadVersion_value=1
+    char *EBMLMaxIDLength={0x42,0xF2}
+    char *EBMLMaxIDLength_size=0x81
+    char *EBMLMaxIDLength_value=4
+    char *EBMLMaxSizeLength={0x42,0xF3}
+    char *EBMLMaxSizeLength_size=0x81
+    char *EBMLMaxSizeLength_value=8
+    char *DocType={0x42,0x82}
+    char *DocType_size=0x80|8
+    char *DocType_value={m,a,t,r,o,s,k,a}
+    char *DocTypeVersion={0x42,0x87}
+    char *DocTypeVersion_size=0x81
+    char *DocTypeVersion_value=2
+    char *DocTypeReadVersion={0x42,0x85}
+    char *DocTypeReadVersion_size=0x81
+    char DocTypeReadVersion_value=2
+
+    #segment, level 0
+    char *SegmentElement={0x18,0x53,0x80,0x67}
+
+    data f^mkv_segment
+
+    const _EBMLVersion^EBMLVersion
+    const DocTypeReadVersion_value_^DocTypeReadVersion_value
+    sd EBML_sz=DocTypeReadVersion_value_-_EBMLVersion+1|0x80
+    set EBML_size EBML_sz
+
+    data start^EBML
+    data end^f
+    call mkv_size_pass(file,f,start,end)
+endfunction
+
+import "file_set_dword" file_set_dword
+import "file_length" file_length
+import "file_write" file_write
+
+function mkv_segment(sd file,sd read_size,sd file_pos)
+    sd io
+    setcall io mkv_write_read_get()
+    #get the offset for seek head positions at write
+    if io=(mkv_write)
+        data segment_base#1
+        const ptr_segment_base^segment_base
+        data ptr_segment_base^segment_base
+        sd err
+        setcall err file_length(file,ptr_segment_base)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+
+    #seek head
+    #level 1
+    char SeekHead={0x11,0x4D,0x9B,0x74}
+
+    data f^mkv_seekhead
+
+    data start1^SeekHead
+    data end1^f
+
+    sd bool
+    setcall bool mkv_size_pass(file,f,start1,end1)
+    if bool=0
+        return 0
+    endif
+
+    if io=(mkv_write)
+        #info
+        #set the information at seek head for Info
+        setcall bool mkv_seekhead_fn(1,file)
+        if bool=0
+            return 0
+        endif
+    endif
+
+    #level 1
+    char Info={0x15,0x49,0xA9,0x66}
+
+    data fn^mkv_info
+
+    data start2^Info
+    data end2^fn
+    setcall bool mkv_size_pass(file,fn,start2,end2)
+    if bool=0
+        return 0
+    endif
+
+    #tracks
+    if io=(mkv_write)
+        #reset frames index; init here for calling at tracks, get width/height based on first frame
+        call mkv_frames(0)
+        #set the information at seek head for Tracks
+        setcall bool mkv_seekhead_fn(2,file)
+        if bool=0
+            return 0
+        endif
+    endif
+
+    #level 1
+    char Tracks={0x16,0x54,0xAE,0x6B}
+
+    data fnc^mkv_track
+
+    data start_data^Tracks
+    data end_data^fnc
+    setcall bool mkv_size_pass(file,fnc,start_data,end_data)
+    if bool=0
+        return 0
+    endif
+
+    #clusters
+    char Cluster={0x1F,0x43,0xB6,0x75}
+    data p_fn^mkv_cluster
+    data p_start^Cluster
+    data p_end^p_fn
+
+    call mkv_fr_set(0)
+
+    data no_more_frames#1
+    data p_nomoreframes^no_more_frames
+    const ptr_nomoreframes^no_more_frames
+    set no_more_frames 0
+
+    sd loop
+    set loop 1
+    while loop=1
+        setcall loop mkv_size_pass(file,p_fn,p_start,p_end)
+        #stop if error or no more frames
+        if loop=1
+            if io=(mkv_read)
+                setcall err mkv_read_cluster_verify_end(file,read_size,file_pos,p_nomoreframes)
+                if err!=(noerror)
+                    return 0
+                endif
+                if no_more_frames=1
+                    set loop 0
+                endif
+            endif
+        endif
+    endwhile
+    sd allframes
+    setcall allframes mkv_fr_get()
+
+    if io=(mkv_write)
+        sd fileduration
+        setcall fileduration mkv_timecodes(allframes)
+        call mkv_set_duration(file,fileduration)
+    else
+        sd newframes_read
+        sd p_newframes_read^newframes_read
+        sd duration
+        setcall duration mkv_read_get_duration()
+        call mkv_readentry(allframes,duration,p_newframes_read)
+    endelse
+endfunction
+
+#bool
+function mkv_seekhead_fn(sd action,sd file)
+	if action=0
+        #seek entry KaxInfo
+        data info#1
+        data ptr_info^info
+        char KaxInfo={0x15,0x49,0xA9,0x66}
+        sd todata^KaxInfo
+
+        sd bool
+        setcall bool seek_entry(todata#,file,ptr_info)
+        if bool=0
+            return 0
+        endif
+
+        #seek entry KaxTracks
+        data tracks#1
+        data ptr_tracks^tracks
+        char KaxTracks={0x16,0x54,0xAE,0x6B}
+        sd dodata^KaxTracks
+
+        setcall bool seek_entry(dodata#,file,ptr_tracks)
+        return bool
+	endif
+        sd seg_base%ptr_segment_base
+        sd position_value
+        sd ptr_position_value^position_value
+        sd err
+        setcall err file_length(file,ptr_position_value)
+        if err!=(noerror)
+            return 0
+        endif
+        sub position_value seg_base#
+        setcall position_value dword_reverse(position_value)
+        sd pos
+        if action=1
+            set pos info
+        else
+            set pos tracks
+        endelse
+        setcall err file_set_dword(file,pos,ptr_position_value)
+        if err!=(noerror)
+            return 0
+        endif
+        return 1
+endfunction
+
+#bool
+function mkv_seekhead(sd file)
+    sd bool
+    setcall bool mkv_seekhead_fn(0,file)
+    return bool
+endfunction
+
+#bool
+function seek_entry(sd value,sd file,sd ptr_pointer)
+    char Seek={0x4D,0xBB}
+    char *Seek_size=0x80+2+1+4+2+1+4
+    char *SeekID={0x53,0xAB}
+    char *SeekID_size=0x84
+    data SeekID_value#1
+    char *SeekPosition={0x53,0xAC}
+    char *SeekPosition_size=0x84
+    char SeekPosition_value#4
+
+    set SeekID_value value
+
+    const _Seek^Seek
+    const SeekPosition_value_^SeekPosition_value
+    data sz=SeekPosition_value_-_Seek+4
+    data wr^Seek
+
+    #write/pass the seek entry
+    sd bool
+    setcall bool mkv_write_seek(wr,sz,file)
+    if bool=0
+        return 0
+    endif
+
+    sd io
+    setcall io mkv_write_read_get()
+    #set the pointer entry if write
+    if io=(mkv_write)
+        sd err
+        setcall err file_length(file,ptr_pointer)
+        if err!=(noerror)
+            return 0
+        endif
+        sub ptr_pointer# 4
+    endif
+
+    return 1
+endfunction
+
+#bool
+function mkv_info(sd file)
+    sd io
+    setcall io mkv_write_read_get()
+
+    if io=(mkv_write)
+        sd err
+        #get the offset for Duration
+        data offset#1
+        data ptr_offset^offset
+        const ptr_offset^offset
+        setcall err file_length(file,ptr_offset)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+
+const _SegmentUID=\
+    char SegmentUID={0x73,0xA4}
+    char *SegmentUID_size=0x80|16
+    data SegmentUID_value#4
+    char *TimecodeScale={0x2A,0xD7,0xB1}
+    char *TimecodeScale_size=0x84
+    data TimecodeScale_value#1
+    char *Duration={0x44,0x89}
+    #unsigned integer
+    char *Duration_size=0x84
+const ptr_Duration=\
+    data Duration_value#1
+    char *DateUTC={0x44,0x61}
+    char *DateUTC_size=0x80|8
+    data DateUTC_value_high#1
+    data DateUTC_value_low#1
+    char *MuxingApp={0x4D,0x80}
+    char MuxingApp_size#1
+const _MuxingApp=\
+    char *MuxingApp_value={O,A,p,p,l,i,c,a,t,i,o,n,s}
+const App=\-_MuxingApp
+    char *WritingApp={0x57,0x41}
+    char WritingApp_size#1
+    char WritingApp_value={O,A,p,p,l,i,c,a,t,i,o,n,s}
+
+    const WritingApp_value_^WritingApp_value
+    data info_sz=WritingApp_value_-_SegmentUID+App
+    data ptr_seg^SegmentUID
+
+    #the muxer timecode
+    const Duration_offset=ptr_Duration-_SegmentUID
+    data Dur_offset=Duration_offset
+
+    if io=(mkv_write)
+        #1 000 000 nanoseconds=1 millisecond
+        setcall TimecodeScale_value dword_reverse((1000*1000))
+
+        #set app name size
+        data MuxingApp_sz=App|0x80
+        set MuxingApp_size MuxingApp_sz
+        set WritingApp_size MuxingApp_sz
+
+        #set unique ID
+        data p_SegmentUID_value^SegmentUID_value
+        sd pointer
+        set pointer p_SegmentUID_value
+        import "timeNode" time
+        sd currenttime
+        setcall currenttime time(0)
+        sd getAtime
+        set getAtime currenttime
+        mult getAtime (3*7)
+        set pointer# getAtime
+        add pointer 4
+        mult getAtime 11
+        set pointer# getAtime
+        add pointer 4
+        mult getAtime 13
+        set pointer# getAtime
+        add pointer 4
+        mult getAtime 17
+        set pointer# getAtime
+
+        #set the date
+        #the number is seconds sub: 1 jan 2001 - 1 jan 1970
+        sub currenttime 978307200
+        data ptr_DateUTC_value_high^DateUTC_value_high
+        import "mult64" mult64
+        setcall DateUTC_value_low mult64(currenttime,1000000000,ptr_DateUTC_value_high)
+        setcall DateUTC_value_high dword_reverse(DateUTC_value_high)
+        setcall DateUTC_value_low dword_reverse(DateUTC_value_low)
+
+        setcall err file_write(ptr_seg,info_sz,file)
+        if err!=(noerror)
+            return 0
+        endif
+
+        #add for duration write
+        add offset Dur_offset
+    else
+        #get the duration for the last frame
+        data ptr_Duration^Duration_value
+        setcall err file_seek_cursor_get_dword_reverse(file,Dur_offset,ptr_Duration)
+        if err!=(noerror)
+            return 0
+        endif
+        #seek to the end of info
+        sd sz
+        set sz info_sz
+        sub sz 4
+        sub sz Dur_offset
+        setcall err file_seek_cursor(file,sz)
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+    return 1
+endfunction
+
+#write duration to file
+function mkv_set_duration(sd file,sd duration)
+    data p_dr%ptr_Duration
+    data p_of%ptr_offset
+    setcall p_dr# dword_reverse(duration)
+    call file_set_dword(file,p_of#,p_dr)
+endfunction
+
+import "stage_sound_sizedone" stage_sound_sizedone
+import "stage_sound_alloc_getremainingsize" stage_sound_alloc_getremainingsize
+
+import "file_seek_offset_plus_size" file_seek_offset_plus_size
+import "file_sizeofseek_offset_plus_size" file_sizeofseek_offset_plus_size
+
+function mkv_track(sd file,sd size,sd filepos)
+    #level 2
+    char TrackEntry=0xAE
+
+    data f^mkv_track_entry
+    data start^TrackEntry
+    data end^f
+    sd bool
+    setcall bool mkv_size_pass(file,f,start,end)
+    if bool=0
+        return 0
+    endif
+
+    #verify for sound
+    sd io
+    setcall io mkv_write_read_get()
+    if io=(mkv_write)
+        #at write check the sound memory
+        #set remaining size to 0
+        call stage_sound_sizedone((value_set),0)
+        #get the size
+        sd sz
+        setcall sz stage_sound_alloc_getremainingsize()
+        if sz=0
+            return 1
+        endif
+    else
+        #at read check if space is available
+        #get size of seek
+        sd sizeofseek
+        sd p_sizeofseek^sizeofseek
+        sd err
+        setcall err file_sizeofseek_offset_plus_size(file,size,filepos,p_sizeofseek)
+        if err!=(noerror)
+            return 0
+        endif
+        if sizeofseek=0
+            return 1
+        endif
+    endelse
+
+    data sound_f^mkv_sound
+    setcall bool mkv_size_pass(file,sound_f,start,end)
+    return bool
+endfunction
+
+importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+
+import "stage_file_options_fps" stage_file_options_fps
+
+const TrackNumber_video=1
+const TrackNumber_audio=2
+
+const bitmapInfoHeader_size=40
+
+function mkv_track_entry(sd file,sd *size,sd *filepos)
+    char CodecID=0x86
+    data f^mkv_codecid
+
+    data start^CodecID
+    data end^f
+
+    sd bool
+
+    setcall bool mkv_size_pass(file,f,start,end)
+    if bool=0
+        return 0
+    endif
+
+##############
+    char TrackNumber=0xD7
+    char *TrackNumber_size=0x81
+    char *TrackNumber_value=TrackNumber_video
+    char *TrackUID={0x73,0xC5}
+    char *TrackUID_size=0x81
+    char *TrackUID_value=TrackNumber_video
+    char *TrackType=0x83
+    char *TrackType_size=0x81
+    char *TrackType_value=1
+    #video type=1
+    char *FlagLacing=0x9C
+    char *FlagLacing_size=0x81
+    char *FlagLacing_value=0
+    #no lacing used
+    char *Name={0x53,0x6E}
+    char *Name_size=0x85
+const track_last_=\
+    char *Name_value={V,i,d,e,o}
+
+    char *CodecPrivate={0x63,0xA2}
+    char *CodecPrivate_size=0x80+bitmapInfoHeader_size
+    data *biSize=bitmapInfoHeader_size
+    data biWidth#1
+    data biHeight#1
+    char *biPlanes={1,0}
+    char *biBitCount={24,0}
+    data *biCompression=BI_RGB
+    data biSizeImage#1
+    data *biXPelsPerMeter=0
+    data *biClrUsed=0
+    data *biClrImportant=0
+##############
+
+    const _track^TrackNumber
+    const track_=track_last_+5
+    data track_data^TrackNumber
+    data track_sz_init=track_-_track
+    data track_sz#1
+    sd rgb_privdata_size=2+1+bitmapInfoHeader_size
+
+    set track_sz track_sz_init
+
+    sd encoder
+    sd io
+    setcall io mkv_write_read_get()
+    if io=(mkv_write)
+        setcall encoder stage_file_get_mkv_encoder()
+        if encoder=(format_mkv_rgb24)
+            sd p_wh^biWidth
+            call mkv_get_video_width_height(p_wh)
+            #add here the bmp header
+            import "rgb_get_size" rgb_get_size
+            setcall biSizeImage rgb_get_size(biWidth,biHeight)
+            call mkv_rgb_yuv_functions((mkv_rgb_set_size),biSizeImage)
+        endif
+    else
+        setcall encoder mkv_read_encoder((value_get))
+    endelse
+    if encoder=(format_mkv_rgb24)
+        add track_sz rgb_privdata_size
+    endif
+
+    setcall bool mkv_write_seek(track_data,track_sz,file)
+    if bool!=1
+        return 0
+    endif
+
+    #add the video track
+    char Video=0xE0
+    data f_vd^mkv_track_video_entry
+    data start_vd^Video
+    data end_vd^f_vd
+    setcall bool mkv_size_pass(file,f_vd,start_vd,end_vd)
+    if bool=0
+        return 0
+    endif
+    return 1
+endfunction
+
+function mkv_track_video_entry(sd file,sd *size,sd *filepos)
+    #level 3
+    char PixelWidth=0xB0
+    char *PixelWidth_size=0x84
+    data PixelWidth_value#1
+    char PixelHeight=0xBA
+    char *PixelHeight_size=0x84
+    data PixelHeight_value#1
+    char DisplayWidth={0x54,0xB0}
+    char *DisplayWidth_size=0x84
+    data DisplayWidth_value#1
+    char *DisplayHeight={0x54,0xBA}
+    char *DisplayHeight_size=0x84
+    data DisplayHeight_value#1
+    char *FrameRate={0x23,0x83,0xE3}
+    char *FrameRate_size=0x84
+const video_track_last_=\
+    data FrameRate_value#1
+
+    char *ColourSpace={0x2E,0xB5,0x24}
+    char *ColourSpace_size=0x84
+    char *ColourSpace_value={I,_4,_2,_0}
+
+    sd err
+    sd io
+    setcall io mkv_write_read_get()
+    if io=(mkv_write)
+        const _video_track^PixelWidth
+        const video_track_=video_track_last_+4
+        data video_track^PixelWidth
+        data video_track_sz_init=video_track_-_video_track
+        data video_track_sz#1
+        set video_track_sz video_track_sz_init
+
+        sd encoder
+        setcall encoder stage_file_get_mkv_encoder()
+        if encoder=(format_mkv_i420)
+            const color_size=3+1+4
+            add video_track_sz (color_size)
+        endif
+
+        #set width, height
+        sd w
+        sd h
+        sd p_wh^w
+        call mkv_get_video_width_height(p_wh)
+        set PixelWidth_value w
+        set PixelHeight_value h
+
+        #to big endian and to display
+        setcall PixelWidth_value dword_reverse(PixelWidth_value)
+        setcall PixelHeight_value dword_reverse(PixelHeight_value)
+        set DisplayWidth_value PixelWidth_value
+        set DisplayHeight_value PixelHeight_value
+        #set frame rate
+        import "int_to_float" int_to_float
+        setcall FrameRate_value stage_file_options_fps()
+        setcall FrameRate_value int_to_float(FrameRate_value)
+        setcall FrameRate_value dword_reverse(FrameRate_value)
+
+        setcall err file_write(video_track,video_track_sz,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        #get the width
+        const ptr_PixelWidth_value^PixelWidth_value
+        data off_PixelWidth_value=ptr_PixelWidth_value-_video_track
+        data ptr_PixelWidth_value^PixelWidth_value
+        setcall err file_seek_cursor_get_dword_reverse(file,off_PixelWidth_value,ptr_PixelWidth_value)
+        if err!=(noerror)
+            return 0
+        endif
+        #get the height
+        const ptr_PixelHeight^PixelHeight
+        const ptr_PixelHeight_value^PixelHeight_value
+        data off_to_PixelHeight=ptr_PixelHeight_value-ptr_PixelHeight
+        data ptr_PixelHeight_value^PixelHeight_value
+        setcall err file_seek_cursor_get_dword_reverse(file,off_to_PixelHeight,ptr_PixelHeight_value)
+        if err!=(noerror)
+            return 0
+        endif
+        #get file fps
+        const ptr_DisplayWidth^DisplayWidth
+        const ptr_FrameRate_value^FrameRate_value
+        data off_to_FrameRate_value=ptr_FrameRate_value-ptr_DisplayWidth
+        data ptr_FrameRate_value^FrameRate_value
+        setcall err file_seek_cursor_get_dword_reverse(file,off_to_FrameRate_value,ptr_FrameRate_value)
+        if err!=(noerror)
+            return 0
+        endif
+        import "float_to_int" float_to_int
+        setcall FrameRate_value float_to_int(FrameRate_value)
+            #correct fps if it's 0
+        import "av_good_fps" av_good_fps
+        call av_good_fps(ptr_FrameRate_value)
+            #
+        call mkv_read_fps((value_set),FrameRate_value)
+
+        sd sz
+
+        #set the size and the bytes for yuv
+        import "yuv_get_size" yuv_get_size
+        setcall sz yuv_get_size(PixelWidth_value,PixelHeight_value)
+        sd p_yuv
+        setcall p_yuv mkv_rgb_yuv_functions((mkv_yuv_p_bytes))
+        setcall err memoryrealloc(p_yuv,sz)
+        if err!=(noerror)
+            return 0
+        endif
+        call mkv_rgb_yuv_functions((mkv_yuv_set_size),sz)
+        #set the bytes for rgb
+        setcall sz rgb_get_size(PixelWidth_value,PixelHeight_value)
+        call mkv_rgb_yuv_functions((mkv_rgb_set_size),sz)
+        sd p_rgb
+        setcall p_rgb mkv_rgb_yuv_functions((mkv_rgb_get_p_bytes))
+        setcall err memoryrealloc(p_rgb,sz)
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+    return 1
+endfunction
+
+import "file_get_size_forward" file_get_size_forward
+
+function mkv_codecid(sd file,sd size,sd *filepos)
+    sd err
+    sd bool
+    sd io
+    setcall io mkv_write_read_get()
+	if io=(mkv_write)
+        setcall bool mkv_codecid_data(io,file)
+        return bool
+	endif
+        data f^mkv_codecid_read
+        setcall err file_get_size_forward(file,size,f)
+        if err!=(noerror)
+            return 0
+        endif
+    return 1
+endfunction
+
+function mkv_cluster(sd file,sd read_size,sd file_pos)
+    char Timecode=0xE7
+    char *Timecode_size=0x84
+    data Timecode_value#1
+
+    #data p_nomoreframes%ptr_nomoreframes
+    data timecode_max#1
+    data p_timecodemax^timecode_max
+    const ptr_timecodemax^timecode_max
+
+    set timecode_max 0
+
+    sd io
+    sd bool
+    sd err
+    setcall io mkv_write_read_get()
+
+    #duration time
+    sd allframes
+    setcall allframes mkv_fr_get()
+
+    if io=(mkv_write)
+        setcall Timecode_value mkv_timecodes(allframes)
+        setcall Timecode_value dword_reverse(Timecode_value)
+
+        data ptr_tm^Timecode
+        setcall err file_write(ptr_tm,(1+1+4),file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        #get cluster timecode
+        data p_Timecode_value^Timecode_value
+        setcall err file_seek_cursor_get_dword_reverse(file,(1+1),p_Timecode_value)
+        if err!=(noerror)
+            return 0
+        endif
+        #finalize the previous frame
+        sd newframes_read
+        sd p_newframes_read^newframes_read
+        setcall bool mkv_readentry(allframes,Timecode_value,p_newframes_read)
+        if bool=0
+            return 0
+        endif
+        #set the elapsed frames
+        call mkv_fr_set(newframes_read)
+    endelse
+
+    call mkv_cluster_fr_set(0)
+    #
+
+    sd stop
+    sd loop
+    set loop 1
+    while loop=1
+        #aborted?
+        setcall stop av_dialog_stop((value_get))
+        if stop=1
+            #this is the point where user abort is checked
+            #direct capture required only: verify to not be the first frame to not let an empty cluster
+            sd s
+            setcall s mkv_cluster_fr_get()
+            if s!=0
+                set loop 0
+            endif
+        else
+            char SimpleBlock=0xA3
+            data f^mkv_simpleblock
+
+            data start^SimpleBlock
+            data end^f
+            setcall loop mkv_size_pass(file,f,start,end)
+
+            #stop if error or no more frames or cluster time exceeded
+            if io=(mkv_read)
+                if loop=1
+                    setcall err mkv_read_cluster_verify_end(file,read_size,file_pos,p_timecodemax)
+                    if err!=(noerror)
+                        return 0
+                    endif
+                    if timecode_max=1
+                        set loop 0
+                    endif
+                endif
+            endif
+        endelse
+    endwhile
+
+    #cluster time
+    sd newframes
+    setcall newframes mkv_cluster_fr_get()
+    addcall newframes mkv_fr_get()
+    call mkv_fr_set(newframes)
+    #
+
+	if timecode_max=1
+        return 1
+	endif
+        #p_nomoreframes#==1 or an error or abort
+        return 0
+endfunction
+
+#returns the timecode
+function mkv_timecodes(sd frames)
+    data returnduration#1
+    sd fps
+    setcall fps stage_file_options_fps()
+    sd value
+    #truncate frames
+    set value frames
+    div value fps
+    #truncation to milliseconds
+    set returnduration value
+    mult returnduration 1000
+
+    #look at the last milliseconds
+    mult value fps
+    sub frames value
+    #x      1000
+    #frames  fps
+    sd msec
+    set msec 1000
+    mult msec frames
+    div msec fps
+
+    add returnduration msec
+    return returnduration
+endfunction
+function mkv_fr_get()
+    data all_frames#1
+    const ptr_all_frames^all_frames
+    return all_frames
+endfunction
+function mkv_fr_set(sd value)
+    data p%ptr_all_frames
+    set p# value
+endfunction
+function mkv_cluster_fr_get()
+    data cluster_frames#1
+    const ptr_cluster_frames^cluster_frames
+    return cluster_frames
+endfunction
+function mkv_cluster_fr_set(sd value)
+    data p%ptr_cluster_frames
+    set p# value
+endfunction
+
+import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
+import "object_get_dword_name" object_get_dword_name
+
+const value_frame_nr=value_custom
+
+#bool, simpleblock is in loop
+function mkv_simpleblock(sd file,sd size,sd filepos)
+    sd err
+    sd io
+    setcall io mkv_write_read_get()
+
+    const SimpleBlock_Flags_Keyframe=0x80
+
+    char Track_Number#1
+    char Timecode_high#1
+    char Timecode_low#1
+    #cluster relative, signed int16
+    char Flags#1
+
+    #cluster time
+    sd frames
+    setcall frames mkv_cluster_fr_get()
+    sd bool
+
+    sd encoder
+    if io=(mkv_write)
+        setcall encoder stage_file_get_mkv_encoder()
+
+        set Track_Number 0x80
+
+        sd timecode
+        setcall timecode mkv_timecodes(frames)
+
+        set Timecode_low timecode
+        div timecode 0x100
+        set Timecode_high timecode
+
+        data ptr_smp^Track_Number
+        data smp_size=1+2+1
+
+        set Flags (SimpleBlock_Flags_Keyframe)
+
+        sd sz
+        setcall sz stage_sound_alloc_getremainingsize()
+        if sz!=0
+            #audio
+            or Track_Number (TrackNumber_audio)
+
+            setcall err file_write(ptr_smp,smp_size,file)
+            if err!=(noerror)
+                return 0
+            endif
+
+            import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
+            sd bytes
+            setcall bytes stage_sound_alloc_getbytes()
+            setcall err file_write(bytes,sz,file)
+            if err!=(noerror)
+                return 0
+            endif
+            call stage_sound_sizedone((value_set),sz)
+            return 1
+        endif
+
+        #video
+        sd currentframe
+        sd pixbuf
+        setcall currentframe mkv_frames((value_frame_nr))
+
+        or Track_Number (TrackNumber_video)
+
+        setcall pixbuf mkv_frames(1,1)
+
+        if encoder=(format_mkv_xvid)
+            import "stage_mpeg_encode" stage_mpeg_encode
+            data is_keyframe#1
+            data p_is_keyframe^is_keyframe
+            setcall bool stage_mpeg_encode(pixbuf,currentframe,p_is_keyframe)
+            if bool!=1
+                return 0
+            endif
+            if is_keyframe=(FALSE)
+                set Flags 0
+            endif
+        endif
+
+        setcall err file_write(ptr_smp,smp_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+
+		#import "rgb_test" rgb_test
+		#setcall bool rgb_test(pixbuf)
+		#if bool==0
+		#    return 0
+		#else
+		#info prepare
+		import "av_display_info" av_display_info
+		call av_display_info((value_get),file)
+		if encoder=(format_mkv_i420)
+		    sd pixels
+		    sd width
+		    sd height
+		    setcall pixels gdk_pixbuf_get_pixels(pixbuf)
+		    setcall width gdk_pixbuf_get_width(pixbuf)
+		    setcall height gdk_pixbuf_get_height(pixbuf)
+
+		    import "rgb_to_yuvi420_write" rgb_to_yuvi420_write
+		    setcall err rgb_to_yuvi420_write(pixels,width,height,file)
+		    if err!=(noerror)
+		        return 0
+		    endif
+		elseif encoder=(format_mkv_mjpg)
+		    import "stage_jpeg_write" stage_jpeg_write
+		    setcall bool stage_jpeg_write(file,pixbuf)
+		    if bool!=1
+		        return 0
+		    endif
+		elseif encoder=(format_mkv_xvid)
+		    import "mpeg_file_mem" mpeg_file_mem
+		    setcall bool mpeg_file_mem((value_filewrite))
+		    if bool!=1
+		        return 0
+		    endif
+		else
+		#if encoder==(format_avi_rgb24)
+		    import "pixbuf_get_wh" pixbuf_get_wh
+		    sd rgb_pixels
+		    sd rgb_sz
+		    setcall rgb_pixels gdk_pixbuf_get_pixels(pixbuf)
+		    sd rgb_width
+		    sd rgb_height
+		    sd rgb_dim^rgb_width
+		    call pixbuf_get_wh(pixbuf,rgb_dim)
+		    setcall rgb_sz rgb_get_size(rgb_width,rgb_height)
+
+		    sd capture_flag
+		    setcall capture_flag mkv_capture((value_get))
+		    if capture_flag=0
+		        sd reverse_pixbuf
+		        setcall reverse_pixbuf pixbuf_from_pixbuf_reverse(pixbuf)
+		        setcall rgb_pixels gdk_pixbuf_get_pixels(reverse_pixbuf)
+		    endif
+		    #
+		    setcall err file_write(rgb_pixels,rgb_sz,file)
+		    #
+		    if capture_flag=0
+		        importx "_g_object_unref" g_object_unref
+		        call g_object_unref(reverse_pixbuf)
+		    endif
+
+		    if err!=(noerror)
+		        return 0
+		    endif
+		endelse
+		#info display
+		call av_display_info((value_write),file,currentframe)
+		#endelse
+
+        setcall pixbuf mkv_frames(1,0,file)
+
+        if pixbuf=0
+        #no more frames
+            data p%ptr_nomoreframes
+            set p# 1
+            data fl%ptr_location
+            import "save_inform_saved" save_inform_saved
+            call save_inform_saved(fl#)
+            return 0
+        endif
+        data time_max%ptr_timecodemax
+        if time_max#=1
+        #cluster is full
+            return 0
+        endif
+    else
+        setcall encoder mkv_read_encoder((value_get))
+
+        import "file_get_dword" file_get_dword
+        sd harvest_blocktime#1
+        sd p_harvest_blocktime^harvest_blocktime
+        setcall err file_get_dword(file,p_harvest_blocktime)
+        if err!=(noerror)
+            return err
+        endif
+
+        set Track_Number harvest_blocktime
+        and Track_Number 0x7f
+        #add if it is audio to the prepared music
+        if Track_Number=(TrackNumber_audio)
+            sd audioframesize
+            sd p_audioframesize^audioframesize
+            setcall err file_sizeofseek_offset_plus_size(file,size,filepos,p_audioframesize)
+            if err!=(noerror)
+                return 0
+            endif
+
+            data f^mkv_read_sound
+            setcall err file_get_size_forward(file,audioframesize,f)
+            if err!=(noerror)
+                return 0
+            endif
+            return 1
+        endif
+
+        setcall harvest_blocktime dword_reverse(harvest_blocktime)
+
+        sd newframes_read
+        sd p_newframes_read^newframes_read
+
+        and harvest_blocktime 0xffFFff
+        div harvest_blocktime 0x100
+        setcall bool mkv_readentry(frames,harvest_blocktime,p_newframes_read)
+        if bool=0
+            return 0
+        endif
+        call mkv_cluster_fr_set(newframes_read)
+
+        if encoder=(format_mkv_i420)
+            sd yuv
+            setcall yuv mkv_rgb_yuv_functions((mkv_yuv_get_bytes))
+            sd sizeofyuv
+            setcall sizeofyuv mkv_rgb_yuv_functions((mkv_yuv_get_size))
+            import "file_read" file_read
+            setcall err file_read(yuv,sizeofyuv,file)
+            if err!=(noerror)
+                return 0
+            endif
+        elseif encoder=(format_mkv_mjpg)
+            import "read_jpeg" read_jpeg
+            data f_readjpeg^mkv_read_mjpeg
+
+            setcall bool read_jpeg(file,f_readjpeg)
+            if bool=0
+                return 0
+            endif
+            #the read function let the cursor somewhere after the frame size
+            setcall err file_seek_offset_plus_size(file,size,filepos)
+            if err!=(noerror)
+                return 0
+            endif
+        else
+            sd p_rgb
+            setcall p_rgb mkv_rgb_yuv_functions((mkv_rgb_get_p_bytes))
+            sd rgb_size
+            setcall rgb_size mkv_rgb_yuv_functions((mkv_rgb_get_size))
+            setcall err file_read(p_rgb#,rgb_size,file)
+            if err!=(noerror)
+                return 0
+            endif
+        endelse
+        #info display
+        call av_display_info((value_write),file,-1,size)
+    endelse
+    return 1
+endfunction
+
+function mkv_get_video_width_height(sd p_wh)
+    sd capture_flag
+    setcall capture_flag mkv_capture((value_get))
+    if capture_flag=0
+        sd pixbuf
+        setcall pixbuf mkv_frames(1,0)
+        setcall p_wh# gdk_pixbuf_get_width(pixbuf)
+        add p_wh 4
+        setcall p_wh# gdk_pixbuf_get_height(pixbuf)
+    else
+        import "capture_get_width_height" capture_get_width_height
+        call capture_get_width_height(p_wh)
+    endelse
+endfunction
+
+function mkv_frames(sd action,sd addatframes,sd file)
+    data image_nr#1
+    if action=0
+        #0
+        set image_nr 0
+    elseif action=1
+    #0 is no more frames or error
+        #1
+        sd capture
+        sd temp_flag
+        sd pix
+        setcall capture mkv_capture((value_get))
+        if capture=0
+            #save the stage
+            sd eventbox
+            setcall eventbox stage_nthwidgetFromcontainer(image_nr)
+            if eventbox=0
+                return 0
+            endif
+            setcall pix object_get_dword_name(eventbox)
+        else
+            #capture file
+            import "capture_temp_flag" capture_temp_flag
+            setcall temp_flag capture_temp_flag((value_get))
+            if addatframes=0
+                #test for end of frames/last frame
+                import "capture_split" capture_split
+                if temp_flag=0
+                    #test for split max size(end of frames)
+                    setcall pix capture_split((value_get),file)
+                else
+                    #test for end of frames/last frame
+                    import "capture_direct_frames" capture_direct_frames
+                    sd temp_frames
+                    setcall temp_frames capture_direct_frames((value_get))
+                    if temp_frames=image_nr
+                        #last frame
+                        set pix 0
+                    else
+                        #test for split max size(end of frames)
+                        setcall pix capture_split((value_get),file)
+                        if pix=0
+                        #substract for next file
+                            sub temp_frames image_nr
+                            call capture_direct_frames((value_set),temp_frames)
+                        endif
+                    endelse
+                endelse
+            else
+            #get a frame
+                setcall pix capture_obtain_screenshot()
+            endelse
+        endelse
+
+        if addatframes!=0
+            #increment image_nr
+            add image_nr addatframes
+
+            #display position
+            import "av_display_progress" av_display_progress
+            call av_display_progress(image_nr,capture)
+
+            #frames number is rising
+            sd frames_rise
+            #the frame length
+            if capture=0
+                import "stage_get_fr_length" stage_get_fr_length
+                setcall frames_rise stage_get_fr_length(eventbox)
+            else
+                if temp_flag=0
+                    import "capture_time" capture_time
+                    setcall frames_rise capture_time((value_get))
+                else
+                    import "capture_temp_file" capture_temp_file
+                    sd temp_file
+                    setcall temp_file capture_temp_file((value_get))
+                    sd p_frames_rise^frames_rise
+                    call file_read(p_frames_rise,4,temp_file)
+                endelse
+            endelse
+            #
+            addcall frames_rise mkv_cluster_fr_get()
+            call mkv_cluster_fr_set(frames_rise)
+
+            sd maxtimecheck
+            data stop%ptr_timecodemax
+            setcall maxtimecheck mkv_timecodes(frames_rise)
+            if maxtimecheck>0x7fFF
+                set stop# 1
+            endif
+        endif
+
+        return pix
+    else
+        #2
+        #value_frame_nr
+        return image_nr
+    endelse
+endfunction
+
+import "file_tell" file_tell
+
+#bool
+function mkv_size_pass(sd file,sv forward,sd start,sd end)
+    sd size
+    set size end
+    sub size start
+
+    sd bool
+    sd err
+    sd io
+    setcall io mkv_write_read_get()
+
+    #write the start/pass the start
+    setcall bool mkv_write_seek(start,size,file)
+    if bool=0
+        return 0
+    endif
+
+    if io=(mkv_write)
+        #write the size
+        sd ebmlsize_high
+        sd *ebmlsize_low
+        setcall ebmlsize_high dword_reverse(0x01000000)
+        sd ptr_ebmlsize_high^ebmlsize_high
+
+        setcall err file_write(ptr_ebmlsize_high,8,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        #get the size
+        setcall err file_seek_cursor(file,4)
+        if err!=(noerror)
+            return 0
+        endif
+        sd ebmlblocksize
+        sd p_ebmlblocksize^ebmlblocksize
+        setcall err file_get_dword_reverse(file,p_ebmlblocksize)
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+
+    #get the point for write/read calculations
+    sd file_pos
+    sd ptr_file_pos^file_pos
+    setcall err file_tell(file,ptr_file_pos)
+    if err!=(noerror)
+        return 0
+    endif
+    if io=(mkv_write)
+        sd writepoint
+        set writepoint file_pos
+        sub writepoint 4
+    endif
+
+    setcall bool forward(file,ebmlblocksize,file_pos)
+
+    #set the size at write
+    if io=(mkv_write)
+        sd seg_size_after
+        sd ptr_seg_size_after^seg_size_after
+        setcall err file_length(file,ptr_seg_size_after)
+        if err!=(noerror)
+            return 0
+        endif
+        sub seg_size_after file_pos
+
+        setcall seg_size_after dword_reverse(seg_size_after)
+
+        setcall err file_set_dword(file,writepoint,ptr_seg_size_after)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+    #seek remaining at read
+        import "file_seek" file_seek
+        sd seek_remaining
+        set seek_remaining file_pos
+        add seek_remaining ebmlblocksize
+        setcall err file_seek(file,seek_remaining,(SEEK_SET))
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+
+    return bool
+endfunction
+
+
+
+
+
+#mkv write/seek
+#bool
+function mkv_write_seek(sd mem,sd size,sd file)
+    sd err
+    sd io
+    setcall io mkv_write_read_get()
+    if io=(mkv_write)
+        setcall err file_write(mem,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        setcall err file_seek_cursor(file,size)
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+    return 1
+endfunction
+
+
+
+
+
+
+
+
+
+
+
+
+
+importx "_free" free
+
+#
+
+function stage_mkv_read(ss filename)
+    #color space init
+    sd err
+    setcall err mkv_rgb_yuv_functions((mkv_yuv_init))
+    if err!=(noerror)
+        return 0
+    endif
+
+    import "file_forward_read" file_forward_read
+    data f^stage_mkv_read_gotfile
+    call file_forward_read(filename,f)
+
+    #color space free
+    call mkv_rgb_yuv_functions((mkv_yuv_free))
+endfunction
+
+import "stage_read_values" stage_read_values
+
+function stage_mkv_read_gotfile(sd file)
+    #values init
+    sd bool
+    setcall bool stage_read_values((value_set))
+    if bool!=1
+        return 0
+    endif
+
+    data f^stage_mkv_read_fn
+    call av_dialog_run(f,file)
+
+    #values write and free
+    call stage_read_values((value_write))
+    call stage_read_values((value_unset))
+endfunction
+
+function stage_mkv_read_fn(sd file)
+    call mkv_write_read_set((mkv_read))
+
+    call mkvfile_headers(file)
+
+    call av_dialog_close()
+endfunction
+
+function mkv_rgb_yuv_functions(sd method,sd sz)
+    data yuv#1
+    data p_yuv^yuv
+    data size#1
+
+    data rgb#1
+    data rgb_size#1
+    data p_rgb^rgb
+
+	if method=(mkv_yuv_init)
+        set yuv 0
+        set rgb 0
+
+        sd err
+        setcall err memoryrealloc(p_yuv,0)
+        if err!=(noerror)
+            return err
+        endif
+
+        setcall err memoryrealloc(p_rgb,0)
+        if err!=(noerror)
+            call mkv_rgb_yuv_functions((mkv_yuv_free))
+            return err
+        endif
+
+        return (noerror)
+	endif
+	if method=(mkv_yuv_p_bytes)
+        return p_yuv
+	endif
+	if method=(mkv_yuv_set_size)
+        set size sz
+	elseif method=(mkv_yuv_get_size)
+        return size
+	elseif method=(mkv_yuv_get_bytes)
+        return yuv
+	elseif method=(mkv_yuv_free)
+        call free(yuv)
+        if rgb!=0
+            call free(rgb)
+        endif
+	elseif method=(mkv_rgb_get_p_bytes)
+        return p_rgb
+	elseif method=(mkv_rgb_set_size)
+        set rgb_size sz
+	else
+    #if method==(mkv_rgb_get_size)
+        return rgb_size
+	endelse
+    return 1
+endfunction
+
+function mkv_write_read_set(sd value)
+    data write_or_read#1
+    set write_or_read value
+    const p_write_or_read^write_or_read
+endfunction
+function mkv_write_read_get()
+    data p%p_write_or_read
+    return p#
+endfunction
+
+#err
+function mkv_read_cluster_verify_end(sd file,sd sz,sd pos,sd p_bool)
+    sd position
+    sd p_position^position
+    sd err
+    setcall err file_tell(file,p_position)
+    if err!=(noerror)
+        return err
+    endif
+    sub position pos
+    if position>sz
+        import "texter" texter
+        str er="Wrong mkv segment sizes."
+        call texter(er)
+        return er
+    endif
+    if position<sz
+        set p_bool# 0
+        return (noerror)
+    endif
+    #size end
+    set p_bool# 1
+    return (noerror)
+endfunction
+
+function mkv_read_get_duration()
+    data p%ptr_Duration
+    return p#
+endfunction
+
+#bool
+function mkv_readentry(sd frames,sd newtime,sd p_resultedframes)
+    sd px
+    sd nt_frames
+
+    sd fps
+    setcall fps mkv_read_fps((value_get))
+
+    #<fps
+    sd msec
+    #x fps
+    #msec 1000
+    import "rest" rest
+    setcall msec rest(newtime,1000)
+    #round msec, not working at 1000 fps
+    inc msec
+    import "rule3" rule3
+    setcall nt_frames rule3(msec,1000,fps)
+
+    #seconds*fps
+    div newtime 1000
+    mult newtime fps
+    add nt_frames newtime
+
+    set p_resultedframes# nt_frames
+    sub nt_frames frames
+	if nt_frames=0
+        return 1
+	endif
+	if nt_frames<0
+        str timeerr="Wrong timecodes."
+        call texter(timeerr)
+        return 0
+	endif
+
+    sd p_rgb
+    setcall p_rgb mkv_rgb_yuv_functions((mkv_rgb_get_p_bytes))
+    sd p_wd%ptr_PixelWidth_value
+    sd p_hg%ptr_PixelHeight_value
+    sd w
+    sd h
+    set w p_wd#
+    set h p_hg#
+
+    sd encoder
+    setcall encoder mkv_read_encoder((value_get))
+    if encoder=(format_mkv_i420)
+        #convert yuv to rgb
+        sd yuv
+        setcall yuv mkv_rgb_yuv_functions((mkv_yuv_get_bytes))
+        import "yuvi420_to_rgb" yuvi420_to_rgb
+        call yuvi420_to_rgb(yuv,p_rgb#,w,h)
+    endif
+
+    #add make pixbuf from data
+    importx "_gdk_pixbuf_new_from_data" gdk_pixbuf_new_from_data
+    sd rowstride
+    sd p_rowstride^rowstride
+    call rgb_get_all_sizes(w,h,p_rowstride)
+    sd pixbuf
+    setcall pixbuf gdk_pixbuf_new_from_data(p_rgb#,(GDK_COLORSPACE_RGB),(FALSE),8,w,h,rowstride,(NULL),0)
+
+    #keep the pixbuf
+    import "pixbuf_copy" pixbuf_copy
+    setcall px pixbuf_copy(pixbuf)
+    if px=0
+        return 0
+    endif
+    if encoder=(format_mkv_rgb24)
+        #bitmap is right to left from file
+        import "rgb_color_swap" rgb_color_swap
+        sd newbytes
+        setcall newbytes gdk_pixbuf_get_pixels(px)
+        call rgb_color_swap(newbytes,w,h)
+    endif
+    call g_object_unref(pixbuf)
+
+    #add to stage
+    sd bool
+    sd entry^px
+    setcall bool stage_read_values((value_append),entry,8)
+    return bool
+endfunction
+
+
+
+
+
+
+
+
+
+
+function mkv_codecid_data(sd io,sd arg,sd size)
+	if io=(mkv_write)
+        sd file
+        set file arg
+    #bool
+        sd codec_ptr
+        sd codec_sz
+
+        sd encoder
+        setcall encoder stage_file_get_mkv_encoder()
+        if encoder=(format_mkv_i420)
+                const codecid_i420_sz=1+1+1+1+1+1+1+1+1+1+1+1+1+1
+            char CodecID_i420_value={V,_,U,N,C,O,M,P,R,E,S,S,E,D}
+            data p_uncomp^CodecID_i420_value
+
+            set codec_ptr p_uncomp
+            set codec_sz (codecid_i420_sz)
+        elseif encoder=(format_mkv_mjpg)
+                const codecid_mjpg_sz=1+1+1+1+1+1+1
+            char CodecID_mjpg_value={V,_,M,J,P,E,G}
+            data p_mjpg^CodecID_mjpg_value
+
+            set codec_ptr p_mjpg
+            set codec_sz (codecid_mjpg_sz)
+        elseif encoder=(format_mkv_xvid)
+                const codecid_xvid_sz=1+1+1+1+1+1+ 1+1+    1+1+1+1+    1+1+1
+            char CodecID_xvid_value={V,_,M,P,E,G,_4,Slash,I,S,O,Slash,A,S,P}
+            data p_xvid^CodecID_xvid_value
+
+            set codec_ptr p_xvid
+            set codec_sz (codecid_xvid_sz)
+        else
+        #if encoder==(format_mkv_rgb24)
+                const codecid_rgb24_sz=1+1+1+1+1+    1+1+1+1+    1+1+1+1+1+1
+            char CodecID_rgb24_value={V,_,M,S,Slash,V,F,W,Slash,F,O,U,R,C,C}
+            data p_rgb24^CodecID_rgb24_value
+
+            set codec_ptr p_rgb24
+            set codec_sz (codecid_rgb24_sz)
+        endelse
+
+        sd err
+        setcall err file_write(codec_ptr,codec_sz,file)
+        if err!=(noerror)
+            return 0
+        endif
+        return 1
+	endif
+    #void
+        sd mem
+        set mem arg
+
+        import "cmpmem_s" cmpmem_s
+        sd compare
+
+        setcall compare cmpmem_s(mem,size,p_uncomp,(codecid_i420_sz))
+        if compare=(equalCompare)
+            call mkv_read_encoder(0,(format_mkv_i420))
+            return (void)
+        endif
+        setcall compare cmpmem_s(mem,size,p_mjpg,(codecid_mjpg_sz))
+        if compare=(equalCompare)
+            call mkv_read_encoder(0,(format_mkv_mjpg))
+            return (void)
+        endif
+        call mkv_read_encoder(0,(format_mkv_rgb24))
+endfunction
+
+
+#void
+function mkv_codecid_read(sd mem,sd size)
+    call mkv_codecid_data((mkv_read),mem,size)
+endfunction
+
+
+function mkv_read_encoder(sd action,sd value)
+    data encoder#1
+    if action=(value_set)
+    #void
+        set encoder value
+    else
+        return encoder
+    endelse
+endfunction
+
+function mkv_read_fps(sd action,sd value)
+    data fps#1
+    if action=(value_set)
+        set fps value
+    else
+        return fps
+    endelse
+endfunction
+
+#bool
+function mkv_read_mjpeg(sd bytes,sd filerowstride,sd j)
+    sd p_rgb
+    setcall p_rgb mkv_rgb_yuv_functions((mkv_rgb_get_p_bytes))
+    sd rgb
+    set rgb p_rgb#
+    sd p_wd%ptr_PixelWidth_value
+    sd p_hg%ptr_PixelHeight_value
+    sd w
+    sd h
+    set w p_wd#
+    set h p_hg#
+    import "rgb_get_rowstride" rgb_get_rowstride
+    sd rowstride
+    setcall rowstride rgb_get_rowstride(w)
+
+	if filerowstride>rowstride
+        ss rstr="Rowstride too large"
+        call texter(rstr)
+        return 0
+	endif
+	if j>=h
+        ss herr="Height too big"
+        call texter(herr)
+        return 0
+	endif
+
+    mult rowstride j
+    add rgb rowstride
+
+    import "cpymem" cpymem
+    call cpymem(rgb,bytes,filerowstride)
+
+    return 1
+endfunction
+
+
+#sound entry
+#bool
+function mkv_sound(sd file,sd *size,sd *filepos)
+const _audio=\
+    char CodecID=0x86
+ char *CodecID_size=0x80+1+1+1+1+1+1+    1+1+1+1+    1+1+1
+    char *CodecID_value={A,_,P,C,M,Slash,I,N,T,Slash,L,I,T}
+    char *TrackNumber=0xD7
+    char *TrackNumber_size=0x81
+    char *TrackNumber_value=TrackNumber_audio
+    char *TrackUID={0x73,0xC5}
+    char *TrackUID_size=0x81
+    char *TrackUID_value=TrackNumber_audio
+    char *TrackType=0x83
+    char *TrackType_size=0x81
+    char *TrackType_value=2
+    #audio type=2
+    char *FlagLacing=0x9C
+    char *FlagLacing_size=0x81
+    char *FlagLacing_value=0
+    #no lacing used
+    char *Name={0x53,0x6E}
+    char *Name_size=0x85
+    char *Name_value={A,u,d,i,o}
+
+    char *Audio={0xE1}
+    char Audio_size=0x80
+const _audiospec=\
+    char *SamplingFrequency=0xB5
+    char *SamplingFrequency_size=0x84
+    data SamplingFrequency_value#1
+    char *Channels=0x9F
+    char *Channels_size=0x84
+    data Channels_value#1
+    char *BitDepth={0x62,0x64}
+    char *BitDepth_size=0x84
+const audiospec_=\
+    data BitDepth_value#1
+
+    sd io
+    setcall io mkv_write_read_get()
+    if io=(mkv_write)
+        const audiospec_@=audiospec_+4
+        const audiospec_size=audiospec_@-_audiospec
+        or Audio_size (audiospec_size)
+
+        import "stage_sound_rate" stage_sound_rate
+        data freq#1
+        setcall freq stage_sound_rate((value_get))
+        setcall SamplingFrequency_value int_to_float(freq)
+        setcall SamplingFrequency_value dword_reverse(SamplingFrequency_value)
+
+        import "stage_sound_channels" stage_sound_channels
+        setcall Channels_value stage_sound_channels((value_get))
+        import "stage_sound_bps" stage_sound_bps
+        setcall BitDepth_value stage_sound_bps((value_get))
+        setcall Channels_value dword_reverse(Channels_value)
+        setcall BitDepth_value dword_reverse(BitDepth_value)
+    endif
+
+    const audio_size=audiospec_@-_audio
+    data audio^CodecID
+
+    sd bool
+    setcall bool mkv_write_seek(audio,(audio_size),file)
+    return bool
+endfunction
+
+function mkv_read_sound(sd mem,sd size)
+    import "stage_sound_alloc_expand" stage_sound_alloc_expand
+    call stage_sound_alloc_expand(mem,size)
+endfunction
--- ovideo-1.orig/src/_prepare/output/mkv.s
+++ /dev/null
@@ -1,1862 +0,0 @@
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-import "dword_reverse" dword_reverse
-
-const mkv_write=0
-const mkv_read=1
-import "file_seek_cursor" file_seek_cursor
-import "file_get_dword_reverse" file_get_dword_reverse
-import "file_seek_cursor_get_dword_reverse" file_seek_cursor_get_dword_reverse
-import "memoryrealloc" memoryrealloc
-import "rgb_get_all_sizes" rgb_get_all_sizes
-
-import "pixbuf_from_pixbuf_reverse" pixbuf_from_pixbuf_reverse
-
-const mkv_yuv_init=0
-const mkv_yuv_p_bytes=1
-const mkv_yuv_set_size=2
-const mkv_yuv_get_size=3
-const mkv_yuv_get_bytes=4
-const mkv_yuv_free=5
-const mkv_rgb_get_p_bytes=6
-const mkv_rgb_set_size=7
-const mkv_rgb_get_size=8
-
-import "av_dialog_run" av_dialog_run
-import "av_dialog_close" av_dialog_close
-import "av_dialog_stop" av_dialog_stop
-
-import "stage_file_get_mkv_encoder" stage_file_get_mkv_encoder
-
-#write/capture node
-
-function mkvfile(sd capture_flag,sd file_number)
-    call mkv_capture((value_set),capture_flag)
-    data f^mkvfile_fn
-    call av_dialog_run(f,file_number)
-endfunction
-
-import "capture_obtain_screenshot" capture_obtain_screenshot
-
-function mkvfile_fn(sd data)
-    call mkv_write_read_set((mkv_write))
-
-    data location#1
-    const ptr_location^location
-    sd capture
-    setcall capture mkv_capture((value_get))
-
-    import "combo_location" combo_location
-    setcall location combo_location(capture,data)
-
-    import "file_write_forward" file_write_forward
-    data f^mkvfile_encoders
-    call file_write_forward(location,f)
-
-    call av_dialog_close()
-endfunction
-
-function mkvfile_encoders(sd file)
-    sd bool
-    sd encoder
-    setcall encoder stage_file_get_mkv_encoder()
-    if encoder==(format_mkv_xvid)
-        import "av_frames" av_frames
-        call av_frames((value_set),0)
-        import "stage_mpeg_init" stage_mpeg_init
-        setcall bool stage_mpeg_init(file)
-        if bool!=1
-            return 0
-        endif
-    endif
-
-    call mkvfile_headers(file)
-
-    if encoder==(format_mkv_xvid)
-        import "mpeg_release" mpeg_release
-        call mpeg_release()
-    endif
-endfunction
-
-function mkv_capture(sd action,sd value)
-    data capture#1
-    #bool value, true for capture, or false
-    if action==(value_set)
-        set capture value
-    else
-        return capture
-    endelse
-endfunction
-
-#
-
-##headers
-
-function mkvfile_headers(sd file)
-    #Extensible Binary Meta Language
-    #EBML Header, level 0
-    char EBML={0x1A,0x45,0xDF,0xA3}
-    char EBML_size#1
-    char EBMLVersion={0x42,0x86}
-    char *EBMLVersion_size=0x81
-    char *EBMLVersion_value=1
-    char *EBMLReadVersion={0x42,0xF7}
-    char *EBMLReadVersion_size=0x81
-    char *EBMLReadVersion_value=1
-    char *EBMLMaxIDLength={0x42,0xF2}
-    char *EBMLMaxIDLength_size=0x81
-    char *EBMLMaxIDLength_value=4
-    char *EBMLMaxSizeLength={0x42,0xF3}
-    char *EBMLMaxSizeLength_size=0x81
-    char *EBMLMaxSizeLength_value=8
-    char *DocType={0x42,0x82}
-    char *DocType_size=0x80|8
-    char *DocType_value={m,a,t,r,o,s,k,a}
-    char *DocTypeVersion={0x42,0x87}
-    char *DocTypeVersion_size=0x81
-    char *DocTypeVersion_value=2
-    char *DocTypeReadVersion={0x42,0x85}
-    char *DocTypeReadVersion_size=0x81
-    char DocTypeReadVersion_value=2
-
-    #segment, level 0
-    char *SegmentElement={0x18,0x53,0x80,0x67}
-
-    data f^mkv_segment
-
-    const _EBMLVersion^EBMLVersion
-    const DocTypeReadVersion_value_^DocTypeReadVersion_value
-    sd EBML_sz=DocTypeReadVersion_value_-_EBMLVersion+1|0x80
-    set EBML_size EBML_sz
-
-    data start^EBML
-    data end^f
-    call mkv_size_pass(file,f,start,end)
-endfunction
-
-import "file_set_dword" file_set_dword
-import "file_length" file_length
-import "file_write" file_write
-
-function mkv_segment(sd file,sd read_size,sd file_pos)
-    sd io
-    setcall io mkv_write_read_get()
-    #get the offset for seek head positions at write
-    if io==(mkv_write)
-        data segment_base#1
-        const ptr_segment_base^segment_base
-        data ptr_segment_base^segment_base
-        sd err
-        setcall err file_length(file,ptr_segment_base)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-
-    #seek head
-    #level 1
-    char SeekHead={0x11,0x4D,0x9B,0x74}
-
-    data f^mkv_seekhead
-
-    data start1^SeekHead
-    data end1^f
-
-    sd bool
-    setcall bool mkv_size_pass(file,f,start1,end1)
-    if bool==0
-        return 0
-    endif
-
-    if io==(mkv_write)
-        #info
-        #set the information at seek head for Info
-        setcall bool mkv_seekhead_fn(1,file)
-        if bool==0
-            return 0
-        endif
-    endif
-
-    #level 1
-    char Info={0x15,0x49,0xA9,0x66}
-
-    data fn^mkv_info
-
-    data start2^Info
-    data end2^fn
-    setcall bool mkv_size_pass(file,fn,start2,end2)
-    if bool==0
-        return 0
-    endif
-
-    #tracks
-    if io==(mkv_write)
-        #reset frames index; init here for calling at tracks, get width/height based on first frame
-        call mkv_frames(0)
-        #set the information at seek head for Tracks
-        setcall bool mkv_seekhead_fn(2,file)
-        if bool==0
-            return 0
-        endif
-    endif
-
-    #level 1
-    char Tracks={0x16,0x54,0xAE,0x6B}
-
-    data fnc^mkv_track
-
-    data start_data^Tracks
-    data end_data^fnc
-    setcall bool mkv_size_pass(file,fnc,start_data,end_data)
-    if bool==0
-        return 0
-    endif
-
-    #clusters
-    char Cluster={0x1F,0x43,0xB6,0x75}
-    data p_fn^mkv_cluster
-    data p_start^Cluster
-    data p_end^p_fn
-
-    call mkv_fr_set(0)
-
-    data no_more_frames#1
-    data p_nomoreframes^no_more_frames
-    const ptr_nomoreframes^no_more_frames
-    set no_more_frames 0
-
-    sd loop
-    set loop 1
-    while loop==1
-        setcall loop mkv_size_pass(file,p_fn,p_start,p_end)
-        #stop if error or no more frames
-        if loop==1
-            if io==(mkv_read)
-                setcall err mkv_read_cluster_verify_end(file,read_size,file_pos,p_nomoreframes)
-                if err!=(noerror)
-                    return 0
-                endif
-                if no_more_frames==1
-                    set loop 0
-                endif
-            endif
-        endif
-    endwhile
-    sd allframes
-    setcall allframes mkv_fr_get()
-
-    if io==(mkv_write)
-        sd fileduration
-        setcall fileduration mkv_timecodes(allframes)
-        call mkv_set_duration(file,fileduration)
-    else
-        sd newframes_read
-        sd p_newframes_read^newframes_read
-        sd duration
-        setcall duration mkv_read_get_duration()
-        call mkv_readentry(allframes,duration,p_newframes_read)
-    endelse
-endfunction
-
-#bool
-function mkv_seekhead_fn(sd action,sd file)
-    if action==0
-        #seek entry KaxInfo
-        data info#1
-        data ptr_info^info
-        char KaxInfo={0x15,0x49,0xA9,0x66}
-        sd todata^KaxInfo
-
-        sd bool
-        setcall bool seek_entry(todata#,file,ptr_info)
-        if bool==0
-            return 0
-        endif
-
-        #seek entry KaxTracks
-        data tracks#1
-        data ptr_tracks^tracks
-        char KaxTracks={0x16,0x54,0xAE,0x6B}
-        sd dodata^KaxTracks
-
-        setcall bool seek_entry(dodata#,file,ptr_tracks)
-        return bool
-    else
-        sd seg_base%ptr_segment_base
-        sd position_value
-        sd ptr_position_value^position_value
-        sd err
-        setcall err file_length(file,ptr_position_value)
-        if err!=(noerror)
-            return 0
-        endif
-        sub position_value seg_base#
-        setcall position_value dword_reverse(position_value)
-        sd pos
-        if action==1
-            set pos info
-        else
-            set pos tracks
-        endelse
-        setcall err file_set_dword(file,pos,ptr_position_value)
-        if err!=(noerror)
-            return 0
-        endif
-        return 1
-    endelse
-endfunction
-
-#bool
-function mkv_seekhead(sd file)
-    sd bool
-    setcall bool mkv_seekhead_fn(0,file)
-    return bool
-endfunction
-
-#bool
-function seek_entry(sd value,sd file,sd ptr_pointer)
-    char Seek={0x4D,0xBB}
-    char *Seek_size=0x80+2+1+4+2+1+4
-    char *SeekID={0x53,0xAB}
-    char *SeekID_size=0x84
-    data SeekID_value#1
-    char *SeekPosition={0x53,0xAC}
-    char *SeekPosition_size=0x84
-    char SeekPosition_value#4
-
-    set SeekID_value value
-
-    const _Seek^Seek
-    const SeekPosition_value_^SeekPosition_value
-    data sz=SeekPosition_value_-_Seek+4
-    data wr^Seek
-
-    #write/pass the seek entry
-    sd bool
-    setcall bool mkv_write_seek(wr,sz,file)
-    if bool==0
-        return 0
-    endif
-
-    sd io
-    setcall io mkv_write_read_get()
-    #set the pointer entry if write
-    if io==(mkv_write)
-        sd err
-        setcall err file_length(file,ptr_pointer)
-        if err!=(noerror)
-            return 0
-        endif
-        sub ptr_pointer# 4
-    endif
-
-    return 1
-endfunction
-
-#bool
-function mkv_info(sd file)
-    sd io
-    setcall io mkv_write_read_get()
-
-    if io==(mkv_write)
-        sd err
-        #get the offset for Duration
-        data offset#1
-        data ptr_offset^offset
-        const ptr_offset^offset
-        setcall err file_length(file,ptr_offset)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-
-const _SegmentUID=!
-    char SegmentUID={0x73,0xA4}
-    char *SegmentUID_size=0x80|16
-    data SegmentUID_value#4
-    char *TimecodeScale={0x2A,0xD7,0xB1}
-    char *TimecodeScale_size=0x84
-    data TimecodeScale_value#1
-    char *Duration={0x44,0x89}
-    #unsigned integer
-    char *Duration_size=0x84
-const ptr_Duration=!
-    data Duration_value#1
-    char *DateUTC={0x44,0x61}
-    char *DateUTC_size=0x80|8
-    data DateUTC_value_high#1
-    data DateUTC_value_low#1
-    char *MuxingApp={0x4D,0x80}
-    char MuxingApp_size#1
-const _MuxingApp=!
-    char *MuxingApp_value={O,A,p,p,l,i,c,a,t,i,o,n,s}
-const App=!-_MuxingApp
-    char *WritingApp={0x57,0x41}
-    char WritingApp_size#1
-    char WritingApp_value={O,A,p,p,l,i,c,a,t,i,o,n,s}
-
-    const WritingApp_value_^WritingApp_value
-    data info_sz=WritingApp_value_-_SegmentUID+App
-    data ptr_seg^SegmentUID
-
-    #the muxer timecode
-    const Duration_offset=ptr_Duration-_SegmentUID
-    data Dur_offset=Duration_offset
-
-    if io==(mkv_write)
-        #1 000 000 nanoseconds=1 millisecond
-        setcall TimecodeScale_value dword_reverse((1000*1000))
-
-        #set app name size
-        data MuxingApp_sz=App|0x80
-        set MuxingApp_size MuxingApp_sz
-        set WritingApp_size MuxingApp_sz
-
-        #set unique ID
-        data p_SegmentUID_value^SegmentUID_value
-        sd pointer
-        set pointer p_SegmentUID_value
-        import "timeNode" time
-        sd currenttime
-        setcall currenttime time(0)
-        sd getAtime
-        set getAtime currenttime
-        mult getAtime (3*7)
-        set pointer# getAtime
-        add pointer 4
-        mult getAtime 11
-        set pointer# getAtime
-        add pointer 4
-        mult getAtime 13
-        set pointer# getAtime
-        add pointer 4
-        mult getAtime 17
-        set pointer# getAtime
-
-        #set the date
-        #the number is seconds sub: 1 jan 2001 - 1 jan 1970
-        sub currenttime 978307200
-        data ptr_DateUTC_value_high^DateUTC_value_high
-        import "mult64" mult64
-        setcall DateUTC_value_low mult64(currenttime,1000000000,ptr_DateUTC_value_high)
-        setcall DateUTC_value_high dword_reverse(DateUTC_value_high)
-        setcall DateUTC_value_low dword_reverse(DateUTC_value_low)
-
-        setcall err file_write(ptr_seg,info_sz,file)
-        if err!=(noerror)
-            return 0
-        endif
-
-        #add for duration write
-        add offset Dur_offset
-    else
-        #get the duration for the last frame
-        data ptr_Duration^Duration_value
-        setcall err file_seek_cursor_get_dword_reverse(file,Dur_offset,ptr_Duration)
-        if err!=(noerror)
-            return 0
-        endif
-        #seek to the end of info
-        sd sz
-        set sz info_sz
-        sub sz 4
-        sub sz Dur_offset
-        setcall err file_seek_cursor(file,sz)
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-    return 1
-endfunction
-
-#write duration to file
-function mkv_set_duration(sd file,sd duration)
-    data p_dr%ptr_Duration
-    data p_of%ptr_offset
-    setcall p_dr# dword_reverse(duration)
-    call file_set_dword(file,p_of#,p_dr)
-endfunction
-
-import "stage_sound_sizedone" stage_sound_sizedone
-import "stage_sound_alloc_getremainingsize" stage_sound_alloc_getremainingsize
-
-import "file_seek_offset_plus_size" file_seek_offset_plus_size
-import "file_sizeofseek_offset_plus_size" file_sizeofseek_offset_plus_size
-
-function mkv_track(sd file,sd size,sd filepos)
-    #level 2
-    char TrackEntry=0xAE
-
-    data f^mkv_track_entry
-    data start^TrackEntry
-    data end^f
-    sd bool
-    setcall bool mkv_size_pass(file,f,start,end)
-    if bool==0
-        return 0
-    endif
-
-    #verify for sound
-    sd io
-    setcall io mkv_write_read_get()
-    if io==(mkv_write)
-        #at write check the sound memory
-        #set remaining size to 0
-        call stage_sound_sizedone((value_set),0)
-        #get the size
-        sd sz
-        setcall sz stage_sound_alloc_getremainingsize()
-        if sz==0
-            return 1
-        endif
-    else
-        #at read check if space is available
-        #get size of seek
-        sd sizeofseek
-        sd p_sizeofseek^sizeofseek
-        sd err
-        setcall err file_sizeofseek_offset_plus_size(file,size,filepos,p_sizeofseek)
-        if err!=(noerror)
-            return 0
-        endif
-        if sizeofseek==0
-            return 1
-        endif
-    endelse
-
-    data sound_f^mkv_sound
-    setcall bool mkv_size_pass(file,sound_f,start,end)
-    return bool
-endfunction
-
-importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-
-import "stage_file_options_fps" stage_file_options_fps
-
-const TrackNumber_video=1
-const TrackNumber_audio=2
-
-const bitmapInfoHeader_size=40
-
-function mkv_track_entry(sd file,sd *size,sd *filepos)
-    char CodecID=0x86
-    data f^mkv_codecid
-
-    data start^CodecID
-    data end^f
-
-    sd bool
-
-    setcall bool mkv_size_pass(file,f,start,end)
-    if bool==0
-        return 0
-    endif
-
-##############
-    char TrackNumber=0xD7
-    char *TrackNumber_size=0x81
-    char *TrackNumber_value=TrackNumber_video
-    char *TrackUID={0x73,0xC5}
-    char *TrackUID_size=0x81
-    char *TrackUID_value=TrackNumber_video
-    char *TrackType=0x83
-    char *TrackType_size=0x81
-    char *TrackType_value=1
-    #video type=1
-    char *FlagLacing=0x9C
-    char *FlagLacing_size=0x81
-    char *FlagLacing_value=0
-    #no lacing used
-    char *Name={0x53,0x6E}
-    char *Name_size=0x85
-const track_last_=!
-    char *Name_value={V,i,d,e,o}
-
-    char *CodecPrivate={0x63,0xA2}
-    char *CodecPrivate_size=0x80+bitmapInfoHeader_size
-    data *biSize=bitmapInfoHeader_size
-    data biWidth#1
-    data biHeight#1
-    char *biPlanes={1,0}
-    char *biBitCount={24,0}
-    data *biCompression=BI_RGB
-    data biSizeImage#1
-    data *biXPelsPerMeter=0
-    data *biClrUsed=0
-    data *biClrImportant=0
-##############
-
-    const _track^TrackNumber
-    const track_=track_last_+5
-    data track_data^TrackNumber
-    data track_sz_init=track_-_track
-    data track_sz#1
-    sd rgb_privdata_size=2+1+bitmapInfoHeader_size
-
-    set track_sz track_sz_init
-
-    sd encoder
-    sd io
-    setcall io mkv_write_read_get()
-    if io==(mkv_write)
-        setcall encoder stage_file_get_mkv_encoder()
-        if encoder==(format_mkv_rgb24)
-            sd p_wh^biWidth
-            call mkv_get_video_width_height(p_wh)
-            #add here the bmp header
-            import "rgb_get_size" rgb_get_size
-            setcall biSizeImage rgb_get_size(biWidth,biHeight)
-            call mkv_rgb_yuv_functions((mkv_rgb_set_size),biSizeImage)
-        endif
-    else
-        setcall encoder mkv_read_encoder((value_get))
-    endelse
-    if encoder==(format_mkv_rgb24)
-        add track_sz rgb_privdata_size
-    endif
-
-    setcall bool mkv_write_seek(track_data,track_sz,file)
-    if bool!=1
-        return 0
-    endif
-
-    #add the video track
-    char Video=0xE0
-    data f_vd^mkv_track_video_entry
-    data start_vd^Video
-    data end_vd^f_vd
-    setcall bool mkv_size_pass(file,f_vd,start_vd,end_vd)
-    if bool==0
-        return 0
-    endif
-    return 1
-endfunction
-
-function mkv_track_video_entry(sd file,sd *size,sd *filepos)
-    #level 3
-    char PixelWidth=0xB0
-    char *PixelWidth_size=0x84
-    data PixelWidth_value#1
-    char PixelHeight=0xBA
-    char *PixelHeight_size=0x84
-    data PixelHeight_value#1
-    char DisplayWidth={0x54,0xB0}
-    char *DisplayWidth_size=0x84
-    data DisplayWidth_value#1
-    char *DisplayHeight={0x54,0xBA}
-    char *DisplayHeight_size=0x84
-    data DisplayHeight_value#1
-    char *FrameRate={0x23,0x83,0xE3}
-    char *FrameRate_size=0x84
-const video_track_last_=!
-    data FrameRate_value#1
-
-    char *ColourSpace={0x2E,0xB5,0x24}
-    char *ColourSpace_size=0x84
-    char *ColourSpace_value={I,_4,_2,_0}
-
-    sd err
-    sd io
-    setcall io mkv_write_read_get()
-    if io==(mkv_write)
-        const _video_track^PixelWidth
-        const video_track_=video_track_last_+4
-        data video_track^PixelWidth
-        data video_track_sz_init=video_track_-_video_track
-        data video_track_sz#1
-        set video_track_sz video_track_sz_init
-
-        sd encoder
-        setcall encoder stage_file_get_mkv_encoder()
-        if encoder==(format_mkv_i420)
-            const color_size=3+1+4
-            add video_track_sz (color_size)
-        endif
-
-        #set width, height
-        sd w
-        sd h
-        sd p_wh^w
-        call mkv_get_video_width_height(p_wh)
-        set PixelWidth_value w
-        set PixelHeight_value h
-
-        #to big endian and to display
-        setcall PixelWidth_value dword_reverse(PixelWidth_value)
-        setcall PixelHeight_value dword_reverse(PixelHeight_value)
-        set DisplayWidth_value PixelWidth_value
-        set DisplayHeight_value PixelHeight_value
-        #set frame rate
-        import "int_to_float" int_to_float
-        setcall FrameRate_value stage_file_options_fps()
-        setcall FrameRate_value int_to_float(FrameRate_value)
-        setcall FrameRate_value dword_reverse(FrameRate_value)
-
-        setcall err file_write(video_track,video_track_sz,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        #get the width
-        const ptr_PixelWidth_value^PixelWidth_value
-        data off_PixelWidth_value=ptr_PixelWidth_value-_video_track
-        data ptr_PixelWidth_value^PixelWidth_value
-        setcall err file_seek_cursor_get_dword_reverse(file,off_PixelWidth_value,ptr_PixelWidth_value)
-        if err!=(noerror)
-            return 0
-        endif
-        #get the height
-        const ptr_PixelHeight^PixelHeight
-        const ptr_PixelHeight_value^PixelHeight_value
-        data off_to_PixelHeight=ptr_PixelHeight_value-ptr_PixelHeight
-        data ptr_PixelHeight_value^PixelHeight_value
-        setcall err file_seek_cursor_get_dword_reverse(file,off_to_PixelHeight,ptr_PixelHeight_value)
-        if err!=(noerror)
-            return 0
-        endif
-        #get file fps
-        const ptr_DisplayWidth^DisplayWidth
-        const ptr_FrameRate_value^FrameRate_value
-        data off_to_FrameRate_value=ptr_FrameRate_value-ptr_DisplayWidth
-        data ptr_FrameRate_value^FrameRate_value
-        setcall err file_seek_cursor_get_dword_reverse(file,off_to_FrameRate_value,ptr_FrameRate_value)
-        if err!=(noerror)
-            return 0
-        endif
-        import "float_to_int" float_to_int
-        setcall FrameRate_value float_to_int(FrameRate_value)
-            #correct fps if it's 0
-        import "av_good_fps" av_good_fps
-        call av_good_fps(ptr_FrameRate_value)
-            #
-        call mkv_read_fps((value_set),FrameRate_value)
-
-        sd sz
-
-        #set the size and the bytes for yuv
-        import "yuv_get_size" yuv_get_size
-        setcall sz yuv_get_size(PixelWidth_value,PixelHeight_value)
-        sd p_yuv
-        setcall p_yuv mkv_rgb_yuv_functions((mkv_yuv_p_bytes))
-        setcall err memoryrealloc(p_yuv,sz)
-        if err!=(noerror)
-            return 0
-        endif
-        call mkv_rgb_yuv_functions((mkv_yuv_set_size),sz)
-        #set the bytes for rgb
-        setcall sz rgb_get_size(PixelWidth_value,PixelHeight_value)
-        call mkv_rgb_yuv_functions((mkv_rgb_set_size),sz)
-        sd p_rgb
-        setcall p_rgb mkv_rgb_yuv_functions((mkv_rgb_get_p_bytes))
-        setcall err memoryrealloc(p_rgb,sz)
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-    return 1
-endfunction
-
-import "file_get_size_forward" file_get_size_forward
-
-function mkv_codecid(sd file,sd size,sd *filepos)
-    sd err
-    sd bool
-    sd io
-    setcall io mkv_write_read_get()
-    if io==(mkv_write)
-        setcall bool mkv_codecid_data(io,file)
-        return bool
-    else
-        data f^mkv_codecid_read
-        setcall err file_get_size_forward(file,size,f)
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-    return 1
-endfunction
-
-function mkv_cluster(sd file,sd read_size,sd file_pos)
-    char Timecode=0xE7
-    char *Timecode_size=0x84
-    data Timecode_value#1
-
-    #data p_nomoreframes%ptr_nomoreframes
-    data timecode_max#1
-    data p_timecodemax^timecode_max
-    const ptr_timecodemax^timecode_max
-
-    set timecode_max 0
-
-    sd io
-    sd bool
-    sd err
-    setcall io mkv_write_read_get()
-
-    #duration time
-    sd allframes
-    setcall allframes mkv_fr_get()
-
-    if io==(mkv_write)
-        setcall Timecode_value mkv_timecodes(allframes)
-        setcall Timecode_value dword_reverse(Timecode_value)
-
-        data ptr_tm^Timecode
-        setcall err file_write(ptr_tm,(1+1+4),file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        #get cluster timecode
-        data p_Timecode_value^Timecode_value
-        setcall err file_seek_cursor_get_dword_reverse(file,(1+1),p_Timecode_value)
-        if err!=(noerror)
-            return 0
-        endif
-        #finalize the previous frame
-        sd newframes_read
-        sd p_newframes_read^newframes_read
-        setcall bool mkv_readentry(allframes,Timecode_value,p_newframes_read)
-        if bool==0
-            return 0
-        endif
-        #set the elapsed frames
-        call mkv_fr_set(newframes_read)
-    endelse
-
-    call mkv_cluster_fr_set(0)
-    #
-
-    sd stop
-    sd loop
-    set loop 1
-    while loop==1
-        #aborted?
-        setcall stop av_dialog_stop((value_get))
-        if stop==1
-            #this is the point where user abort is checked
-            #direct capture required only: verify to not be the first frame to not let an empty cluster
-            sd s
-            setcall s mkv_cluster_fr_get()
-            if s!=0
-                set loop 0
-            endif
-        else
-            char SimpleBlock=0xA3
-            data f^mkv_simpleblock
-
-            data start^SimpleBlock
-            data end^f
-            setcall loop mkv_size_pass(file,f,start,end)
-
-            #stop if error or no more frames or cluster time exceeded
-            if io==(mkv_read)
-                if loop==1
-                    setcall err mkv_read_cluster_verify_end(file,read_size,file_pos,p_timecodemax)
-                    if err!=(noerror)
-                        return 0
-                    endif
-                    if timecode_max==1
-                        set loop 0
-                    endif
-                endif
-            endif
-        endelse
-    endwhile
-
-    #cluster time
-    sd newframes
-    setcall newframes mkv_cluster_fr_get()
-    addcall newframes mkv_fr_get()
-    call mkv_fr_set(newframes)
-    #
-
-    if timecode_max==1
-        return 1
-    else
-        #p_nomoreframes#==1 or an error or abort
-        return 0
-    endelse
-endfunction
-
-#returns the timecode
-function mkv_timecodes(sd frames)
-    data returnduration#1
-    sd fps
-    setcall fps stage_file_options_fps()
-    sd value
-    #truncate frames
-    set value frames
-    div value fps
-    #truncation to milliseconds
-    set returnduration value
-    mult returnduration 1000
-
-    #look at the last milliseconds
-    mult value fps
-    sub frames value
-    #x      1000
-    #frames  fps
-    sd msec
-    set msec 1000
-    mult msec frames
-    div msec fps
-
-    add returnduration msec
-    return returnduration
-endfunction
-function mkv_fr_get()
-    data all_frames#1
-    const ptr_all_frames^all_frames
-    return all_frames
-endfunction
-function mkv_fr_set(sd value)
-    data p%ptr_all_frames
-    set p# value
-endfunction
-function mkv_cluster_fr_get()
-    data cluster_frames#1
-    const ptr_cluster_frames^cluster_frames
-    return cluster_frames
-endfunction
-function mkv_cluster_fr_set(sd value)
-    data p%ptr_cluster_frames
-    set p# value
-endfunction
-
-import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
-import "object_get_dword_name" object_get_dword_name
-
-const value_frame_nr=value_custom
-
-#bool, simpleblock is in loop
-function mkv_simpleblock(sd file,sd size,sd filepos)
-    sd err
-    sd io
-    setcall io mkv_write_read_get()
-
-    const SimpleBlock_Flags_Keyframe=0x80
-
-    char Track_Number#1
-    char Timecode_high#1
-    char Timecode_low#1
-    #cluster relative, signed int16
-    char Flags#1
-
-    #cluster time
-    sd frames
-    setcall frames mkv_cluster_fr_get()
-    sd bool
-
-    sd encoder
-    if io==(mkv_write)
-        setcall encoder stage_file_get_mkv_encoder()
-
-        set Track_Number 0x80
-
-        sd timecode
-        setcall timecode mkv_timecodes(frames)
-
-        set Timecode_low timecode
-        div timecode 0x100
-        set Timecode_high timecode
-
-        data ptr_smp^Track_Number
-        data smp_size=1+2+1
-
-        set Flags (SimpleBlock_Flags_Keyframe)
-
-        sd sz
-        setcall sz stage_sound_alloc_getremainingsize()
-        if sz!=0
-            #audio
-            or Track_Number (TrackNumber_audio)
-
-            setcall err file_write(ptr_smp,smp_size,file)
-            if err!=(noerror)
-                return 0
-            endif
-
-            import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
-            sd bytes
-            setcall bytes stage_sound_alloc_getbytes()
-            setcall err file_write(bytes,sz,file)
-            if err!=(noerror)
-                return 0
-            endif
-            call stage_sound_sizedone((value_set),sz)
-            return 1
-        endif
-
-        #video
-        sd currentframe
-        sd pixbuf
-        setcall currentframe mkv_frames((value_frame_nr))
-
-        or Track_Number (TrackNumber_video)
-
-        setcall pixbuf mkv_frames(1,1)
-
-        if encoder==(format_mkv_xvid)
-            import "stage_mpeg_encode" stage_mpeg_encode
-            data is_keyframe#1
-            data p_is_keyframe^is_keyframe
-            setcall bool stage_mpeg_encode(pixbuf,currentframe,p_is_keyframe)
-            if bool!=1
-                return 0
-            endif
-            if is_keyframe==(FALSE)
-                set Flags 0
-            endif
-        endif
-
-        setcall err file_write(ptr_smp,smp_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-
-		#import "rgb_test" rgb_test
-		#setcall bool rgb_test(pixbuf)
-		#if bool==0
-		#    return 0
-		#else
-		#info prepare
-		import "av_display_info" av_display_info
-		call av_display_info((value_get),file)
-		if encoder==(format_mkv_i420)
-		    sd pixels
-		    sd width
-		    sd height
-		    setcall pixels gdk_pixbuf_get_pixels(pixbuf)
-		    setcall width gdk_pixbuf_get_width(pixbuf)
-		    setcall height gdk_pixbuf_get_height(pixbuf)
-
-		    import "rgb_to_yuvi420_write" rgb_to_yuvi420_write
-		    setcall err rgb_to_yuvi420_write(pixels,width,height,file)
-		    if err!=(noerror)
-		        return 0
-		    endif
-		elseif encoder==(format_mkv_mjpg)
-		    import "stage_jpeg_write" stage_jpeg_write
-		    setcall bool stage_jpeg_write(file,pixbuf)
-		    if bool!=1
-		        return 0
-		    endif
-		elseif encoder==(format_mkv_xvid)
-		    import "mpeg_file_mem" mpeg_file_mem
-		    setcall bool mpeg_file_mem((value_filewrite))
-		    if bool!=1
-		        return 0
-		    endif
-		else
-		#if encoder==(format_avi_rgb24)
-		    import "pixbuf_get_wh" pixbuf_get_wh
-		    sd rgb_pixels
-		    sd rgb_sz
-		    setcall rgb_pixels gdk_pixbuf_get_pixels(pixbuf)
-		    sd rgb_width
-		    sd rgb_height
-		    sd rgb_dim^rgb_width
-		    call pixbuf_get_wh(pixbuf,rgb_dim)
-		    setcall rgb_sz rgb_get_size(rgb_width,rgb_height)
-
-		    sd capture_flag
-		    setcall capture_flag mkv_capture((value_get))
-		    if capture_flag==0
-		        sd reverse_pixbuf
-		        setcall reverse_pixbuf pixbuf_from_pixbuf_reverse(pixbuf)
-		        setcall rgb_pixels gdk_pixbuf_get_pixels(reverse_pixbuf)
-		    endif
-		    #
-		    setcall err file_write(rgb_pixels,rgb_sz,file)
-		    #
-		    if capture_flag==0
-		        importx "_g_object_unref" g_object_unref
-		        call g_object_unref(reverse_pixbuf)
-		    endif
-
-		    if err!=(noerror)
-		        return 0
-		    endif
-		endelse
-		#info display
-		call av_display_info((value_write),file,currentframe)
-		#endelse
-
-        setcall pixbuf mkv_frames(1,0,file)
-
-        if pixbuf==0
-        #no more frames
-            data p%ptr_nomoreframes
-            set p# 1
-            data fl%ptr_location
-            import "save_inform_saved" save_inform_saved
-            call save_inform_saved(fl#)
-            return 0
-        endif
-        data time_max%ptr_timecodemax
-        if time_max#==1
-        #cluster is full
-            return 0
-        endif
-    else
-        setcall encoder mkv_read_encoder((value_get))
-
-        import "file_get_dword" file_get_dword
-        sd harvest_blocktime#1
-        sd p_harvest_blocktime^harvest_blocktime
-        setcall err file_get_dword(file,p_harvest_blocktime)
-        if err!=(noerror)
-            return err
-        endif
-
-        set Track_Number harvest_blocktime
-        and Track_Number 0x7f
-        #add if it is audio to the prepared music
-        if Track_Number==(TrackNumber_audio)
-            sd audioframesize
-            sd p_audioframesize^audioframesize
-            setcall err file_sizeofseek_offset_plus_size(file,size,filepos,p_audioframesize)
-            if err!=(noerror)
-                return 0
-            endif
-
-            data f^mkv_read_sound
-            setcall err file_get_size_forward(file,audioframesize,f)
-            if err!=(noerror)
-                return 0
-            endif
-            return 1
-        endif
-
-        setcall harvest_blocktime dword_reverse(harvest_blocktime)
-
-        sd newframes_read
-        sd p_newframes_read^newframes_read
-
-        and harvest_blocktime 0xffFFff
-        div harvest_blocktime 0x100
-        setcall bool mkv_readentry(frames,harvest_blocktime,p_newframes_read)
-        if bool==0
-            return 0
-        endif
-        call mkv_cluster_fr_set(newframes_read)
-
-        if encoder==(format_mkv_i420)
-            sd yuv
-            setcall yuv mkv_rgb_yuv_functions((mkv_yuv_get_bytes))
-            sd sizeofyuv
-            setcall sizeofyuv mkv_rgb_yuv_functions((mkv_yuv_get_size))
-            import "file_read" file_read
-            setcall err file_read(yuv,sizeofyuv,file)
-            if err!=(noerror)
-                return 0
-            endif
-        elseif encoder==(format_mkv_mjpg)
-            import "read_jpeg" read_jpeg
-            data f_readjpeg^mkv_read_mjpeg
-
-            setcall bool read_jpeg(file,f_readjpeg)
-            if bool==0
-                return 0
-            endif
-            #the read function let the cursor somewhere after the frame size
-            setcall err file_seek_offset_plus_size(file,size,filepos)
-            if err!=(noerror)
-                return 0
-            endif
-        else
-            sd p_rgb
-            setcall p_rgb mkv_rgb_yuv_functions((mkv_rgb_get_p_bytes))
-            sd rgb_size
-            setcall rgb_size mkv_rgb_yuv_functions((mkv_rgb_get_size))
-            setcall err file_read(p_rgb#,rgb_size,file)
-            if err!=(noerror)
-                return 0
-            endif
-        endelse
-        #info display
-        call av_display_info((value_write),file,-1,size)
-    endelse
-    return 1
-endfunction
-
-function mkv_get_video_width_height(sd p_wh)
-    sd capture_flag
-    setcall capture_flag mkv_capture((value_get))
-    if capture_flag==0
-        sd pixbuf
-        setcall pixbuf mkv_frames(1,0)
-        setcall p_wh# gdk_pixbuf_get_width(pixbuf)
-        add p_wh 4
-        setcall p_wh# gdk_pixbuf_get_height(pixbuf)
-    else
-        import "capture_get_width_height" capture_get_width_height
-        call capture_get_width_height(p_wh)
-    endelse
-endfunction
-
-function mkv_frames(sd action,sd addatframes,sd file)
-    data image_nr#1
-    if action==0
-        #0
-        set image_nr 0
-    elseif action==1
-    #0 is no more frames or error
-        #1
-        sd capture
-        sd temp_flag
-        sd pix
-        setcall capture mkv_capture((value_get))
-        if capture==0
-            #save the stage
-            sd eventbox
-            setcall eventbox stage_nthwidgetFromcontainer(image_nr)
-            if eventbox==0
-                return 0
-            endif
-            setcall pix object_get_dword_name(eventbox)
-        else
-            #capture file
-            import "capture_temp_flag" capture_temp_flag
-            setcall temp_flag capture_temp_flag((value_get))
-            if addatframes==0
-                #test for end of frames/last frame
-                import "capture_split" capture_split
-                if temp_flag==0
-                    #test for split max size(end of frames)
-                    setcall pix capture_split((value_get),file)
-                else
-                    #test for end of frames/last frame
-                    import "capture_direct_frames" capture_direct_frames
-                    sd temp_frames
-                    setcall temp_frames capture_direct_frames((value_get))
-                    if temp_frames==image_nr
-                        #last frame
-                        set pix 0
-                    else
-                        #test for split max size(end of frames)
-                        setcall pix capture_split((value_get),file)
-                        if pix==0
-                        #substract for next file
-                            sub temp_frames image_nr
-                            call capture_direct_frames((value_set),temp_frames)
-                        endif
-                    endelse
-                endelse
-            else
-            #get a frame
-                setcall pix capture_obtain_screenshot()
-            endelse
-        endelse
-
-        if addatframes!=0
-            #increment image_nr
-            add image_nr addatframes
-
-            #display position
-            import "av_display_progress" av_display_progress
-            call av_display_progress(image_nr,capture)
-
-            #frames number is rising
-            sd frames_rise
-            #the frame length
-            if capture==0
-                import "stage_get_fr_length" stage_get_fr_length
-                setcall frames_rise stage_get_fr_length(eventbox)
-            else
-                if temp_flag==0
-                    import "capture_time" capture_time
-                    setcall frames_rise capture_time((value_get))
-                else
-                    import "capture_temp_file" capture_temp_file
-                    sd temp_file
-                    setcall temp_file capture_temp_file((value_get))
-                    sd p_frames_rise^frames_rise
-                    call file_read(p_frames_rise,4,temp_file)
-                endelse
-            endelse
-            #
-            addcall frames_rise mkv_cluster_fr_get()
-            call mkv_cluster_fr_set(frames_rise)
-
-            sd maxtimecheck
-            data stop%ptr_timecodemax
-            setcall maxtimecheck mkv_timecodes(frames_rise)
-            if maxtimecheck>0x7fFF
-                set stop# 1
-            endif
-        endif
-
-        return pix
-    else
-        #2
-        #value_frame_nr
-        return image_nr
-    endelse
-endfunction
-
-import "file_tell" file_tell
-
-#bool
-function mkv_size_pass(sd file,sd forward,sd start,sd end)
-    sd size
-    set size end
-    sub size start
-
-    sd bool
-    sd err
-    sd io
-    setcall io mkv_write_read_get()
-
-    #write the start/pass the start
-    setcall bool mkv_write_seek(start,size,file)
-    if bool==0
-        return 0
-    endif
-
-    if io==(mkv_write)
-        #write the size
-        sd ebmlsize_high
-        sd *ebmlsize_low
-        setcall ebmlsize_high dword_reverse(0x01000000)
-        sd ptr_ebmlsize_high^ebmlsize_high
-
-        setcall err file_write(ptr_ebmlsize_high,8,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        #get the size
-        setcall err file_seek_cursor(file,4)
-        if err!=(noerror)
-            return 0
-        endif
-        sd ebmlblocksize
-        sd p_ebmlblocksize^ebmlblocksize
-        setcall err file_get_dword_reverse(file,p_ebmlblocksize)
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-
-    #get the point for write/read calculations
-    sd file_pos
-    sd ptr_file_pos^file_pos
-    setcall err file_tell(file,ptr_file_pos)
-    if err!=(noerror)
-        return 0
-    endif
-    if io==(mkv_write)
-        sd writepoint
-        set writepoint file_pos
-        sub writepoint 4
-    endif
-
-    setcall bool forward(file,ebmlblocksize,file_pos)
-
-    #set the size at write
-    if io==(mkv_write)
-        sd seg_size_after
-        sd ptr_seg_size_after^seg_size_after
-        setcall err file_length(file,ptr_seg_size_after)
-        if err!=(noerror)
-            return 0
-        endif
-        sub seg_size_after file_pos
-
-        setcall seg_size_after dword_reverse(seg_size_after)
-
-        setcall err file_set_dword(file,writepoint,ptr_seg_size_after)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-    #seek remaining at read
-        import "file_seek" file_seek
-        sd seek_remaining
-        set seek_remaining file_pos
-        add seek_remaining ebmlblocksize
-        setcall err file_seek(file,seek_remaining,(SEEK_SET))
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-
-    return bool
-endfunction
-
-
-
-
-
-#mkv write/seek
-#bool
-function mkv_write_seek(sd mem,sd size,sd file)
-    sd err
-    sd io
-    setcall io mkv_write_read_get()
-    if io==(mkv_write)
-        setcall err file_write(mem,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        setcall err file_seek_cursor(file,size)
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-    return 1
-endfunction
-
-
-
-
-
-
-
-
-
-
-
-
-
-importx "_free" free
-
-#
-
-function stage_mkv_read(ss filename)
-    #color space init
-    sd err
-    setcall err mkv_rgb_yuv_functions((mkv_yuv_init))
-    if err!=(noerror)
-        return 0
-    endif
-
-    import "file_forward_read" file_forward_read
-    data f^stage_mkv_read_gotfile
-    call file_forward_read(filename,f)
-
-    #color space free
-    call mkv_rgb_yuv_functions((mkv_yuv_free))
-endfunction
-
-import "stage_read_values" stage_read_values
-
-function stage_mkv_read_gotfile(sd file)
-    #values init
-    sd bool
-    setcall bool stage_read_values((value_set))
-    if bool!=1
-        return 0
-    endif
-
-    data f^stage_mkv_read_fn
-    call av_dialog_run(f,file)
-
-    #values write and free
-    call stage_read_values((value_write))
-    call stage_read_values((value_unset))
-endfunction
-
-function stage_mkv_read_fn(sd file)
-    call mkv_write_read_set((mkv_read))
-
-    call mkvfile_headers(file)
-
-    call av_dialog_close()
-endfunction
-
-function mkv_rgb_yuv_functions(sd method,sd sz)
-    data yuv#1
-    data p_yuv^yuv
-    data size#1
-
-    data rgb#1
-    data rgb_size#1
-    data p_rgb^rgb
-
-    if method==(mkv_yuv_init)
-        set yuv 0
-        set rgb 0
-
-        sd err
-        setcall err memoryrealloc(p_yuv,0)
-        if err!=(noerror)
-            return err
-        endif
-
-        setcall err memoryrealloc(p_rgb,0)
-        if err!=(noerror)
-            call mkv_rgb_yuv_functions((mkv_yuv_free))
-            return err
-        endif
-
-        return (noerror)
-    elseif method==(mkv_yuv_p_bytes)
-        return p_yuv
-    elseif method==(mkv_yuv_set_size)
-        set size sz
-    elseif method==(mkv_yuv_get_size)
-        return size
-    elseif method==(mkv_yuv_get_bytes)
-        return yuv
-    elseif method==(mkv_yuv_free)
-        call free(yuv)
-        if rgb!=0
-            call free(rgb)
-        endif
-    elseif method==(mkv_rgb_get_p_bytes)
-        return p_rgb
-    elseif method==(mkv_rgb_set_size)
-        set rgb_size sz
-    else
-    #if method==(mkv_rgb_get_size)
-        return rgb_size
-    endelse
-    return 1
-endfunction
-
-function mkv_write_read_set(sd value)
-    data write_or_read#1
-    set write_or_read value
-    const p_write_or_read^write_or_read
-endfunction
-function mkv_write_read_get()
-    data p%p_write_or_read
-    return p#
-endfunction
-
-#err
-function mkv_read_cluster_verify_end(sd file,sd sz,sd pos,sd p_bool)
-    sd position
-    sd p_position^position
-    sd err
-    setcall err file_tell(file,p_position)
-    if err!=(noerror)
-        return err
-    endif
-    sub position pos
-    if position>sz
-        import "texter" texter
-        str er="Wrong mkv segment sizes."
-        call texter(er)
-        return er
-    endif
-    if position<sz
-        set p_bool# 0
-        return (noerror)
-    endif
-    #size end
-    set p_bool# 1
-    return (noerror)
-endfunction
-
-function mkv_read_get_duration()
-    data p%ptr_Duration
-    return p#
-endfunction
-
-#bool
-function mkv_readentry(sd frames,sd newtime,sd p_resultedframes)
-    sd px
-    sd nt_frames
-
-    sd fps
-    setcall fps mkv_read_fps((value_get))
-
-    #<fps
-    sd msec
-    #x fps
-    #msec 1000
-    import "rest" rest
-    setcall msec rest(newtime,1000)
-    #round msec, not working at 1000 fps
-    inc msec
-    import "rule3" rule3
-    setcall nt_frames rule3(msec,1000,fps)
-
-    #seconds*fps
-    div newtime 1000
-    mult newtime fps
-    add nt_frames newtime
-
-    set p_resultedframes# nt_frames
-    sub nt_frames frames
-    if nt_frames==0
-        return 1
-    elseif nt_frames<0
-        str timeerr="Wrong timecodes."
-        call texter(timeerr)
-        return 0
-    endelseif
-
-    sd p_rgb
-    setcall p_rgb mkv_rgb_yuv_functions((mkv_rgb_get_p_bytes))
-    sd p_wd%ptr_PixelWidth_value
-    sd p_hg%ptr_PixelHeight_value
-    sd w
-    sd h
-    set w p_wd#
-    set h p_hg#
-
-    sd encoder
-    setcall encoder mkv_read_encoder((value_get))
-    if encoder==(format_mkv_i420)
-        #convert yuv to rgb
-        sd yuv
-        setcall yuv mkv_rgb_yuv_functions((mkv_yuv_get_bytes))
-        import "yuvi420_to_rgb" yuvi420_to_rgb
-        call yuvi420_to_rgb(yuv,p_rgb#,w,h)
-    endif
-
-    #add make pixbuf from data
-    importx "_gdk_pixbuf_new_from_data" gdk_pixbuf_new_from_data
-    sd rowstride
-    sd p_rowstride^rowstride
-    call rgb_get_all_sizes(w,h,p_rowstride)
-    sd pixbuf
-    setcall pixbuf gdk_pixbuf_new_from_data(p_rgb#,(GDK_COLORSPACE_RGB),(FALSE),8,w,h,rowstride,(NULL),0)
-
-    #keep the pixbuf
-    import "pixbuf_copy" pixbuf_copy
-    setcall px pixbuf_copy(pixbuf)
-    if px==0
-        return 0
-    endif
-    if encoder==(format_mkv_rgb24)
-        #bitmap is right to left from file
-        import "rgb_color_swap" rgb_color_swap
-        sd newbytes
-        setcall newbytes gdk_pixbuf_get_pixels(px)
-        call rgb_color_swap(newbytes,w,h)
-    endif
-    call g_object_unref(pixbuf)
-
-    #add to stage
-    sd bool
-    sd entry^px
-    setcall bool stage_read_values((value_append),entry,8)
-    return bool
-endfunction
-
-
-
-
-
-
-
-
-
-
-function mkv_codecid_data(sd io,sd arg,sd size)
-    if io==(mkv_write)
-        sd file
-        set file arg
-    #bool
-        sd codec_ptr
-        sd codec_sz
-
-        sd encoder
-        setcall encoder stage_file_get_mkv_encoder()
-        if encoder==(format_mkv_i420)
-                const codecid_i420_sz=1+1+1+1+1+1+1+1+1+1+1+1+1+1
-            char CodecID_i420_value={V,_,U,N,C,O,M,P,R,E,S,S,E,D}
-            data p_uncomp^CodecID_i420_value
-
-            set codec_ptr p_uncomp
-            set codec_sz (codecid_i420_sz)
-        elseif encoder==(format_mkv_mjpg)
-                const codecid_mjpg_sz=1+1+1+1+1+1+1
-            char CodecID_mjpg_value={V,_,M,J,P,E,G}
-            data p_mjpg^CodecID_mjpg_value
-
-            set codec_ptr p_mjpg
-            set codec_sz (codecid_mjpg_sz)
-        elseif encoder==(format_mkv_xvid)
-                const codecid_xvid_sz=1+1+1+1+1+1+ 1+1+    1+1+1+1+    1+1+1
-            char CodecID_xvid_value={V,_,M,P,E,G,_4,Slash,I,S,O,Slash,A,S,P}
-            data p_xvid^CodecID_xvid_value
-
-            set codec_ptr p_xvid
-            set codec_sz (codecid_xvid_sz)
-        else
-        #if encoder==(format_mkv_rgb24)
-                const codecid_rgb24_sz=1+1+1+1+1+    1+1+1+1+    1+1+1+1+1+1
-            char CodecID_rgb24_value={V,_,M,S,Slash,V,F,W,Slash,F,O,U,R,C,C}
-            data p_rgb24^CodecID_rgb24_value
-
-            set codec_ptr p_rgb24
-            set codec_sz (codecid_rgb24_sz)
-        endelse
-
-        sd err
-        setcall err file_write(codec_ptr,codec_sz,file)
-        if err!=(noerror)
-            return 0
-        endif
-        return 1
-    else
-    #void
-        sd mem
-        set mem arg
-
-        import "cmpmem_s" cmpmem_s
-        sd compare
-
-        setcall compare cmpmem_s(mem,size,p_uncomp,(codecid_i420_sz))
-        if compare==(equalCompare)
-            call mkv_read_encoder(0,(format_mkv_i420))
-            return (void)
-        endif
-        setcall compare cmpmem_s(mem,size,p_mjpg,(codecid_mjpg_sz))
-        if compare==(equalCompare)
-            call mkv_read_encoder(0,(format_mkv_mjpg))
-            return (void)
-        endif
-        call mkv_read_encoder(0,(format_mkv_rgb24))
-    endelse
-endfunction
-
-
-#void
-function mkv_codecid_read(sd mem,sd size)
-    call mkv_codecid_data((mkv_read),mem,size)
-endfunction
-
-
-function mkv_read_encoder(sd action,sd value)
-    data encoder#1
-    if action==(value_set)
-    #void
-        set encoder value
-    else
-        return encoder
-    endelse
-endfunction
-
-function mkv_read_fps(sd action,sd value)
-    data fps#1
-    if action==(value_set)
-        set fps value
-    else
-        return fps
-    endelse
-endfunction
-
-#bool
-function mkv_read_mjpeg(sd bytes,sd filerowstride,sd j)
-    sd p_rgb
-    setcall p_rgb mkv_rgb_yuv_functions((mkv_rgb_get_p_bytes))
-    sd rgb
-    set rgb p_rgb#
-    sd p_wd%ptr_PixelWidth_value
-    sd p_hg%ptr_PixelHeight_value
-    sd w
-    sd h
-    set w p_wd#
-    set h p_hg#
-    import "rgb_get_rowstride" rgb_get_rowstride
-    sd rowstride
-    setcall rowstride rgb_get_rowstride(w)
-
-    if filerowstride>rowstride
-        ss rstr="Rowstride too large"
-        call texter(rstr)
-        return 0
-    elseif j>=h
-        ss herr="Height too big"
-        call texter(herr)
-        return 0
-    endelseif
-
-    mult rowstride j
-    add rgb rowstride
-
-    import "cpymem" cpymem
-    call cpymem(rgb,bytes,filerowstride)
-
-    return 1
-endfunction
-
-
-#sound entry
-#bool
-function mkv_sound(sd file,sd *size,sd *filepos)
-const _audio=!
-    char CodecID=0x86
- char *CodecID_size=0x80+1+1+1+1+1+1+    1+1+1+1+    1+1+1
-    char *CodecID_value={A,_,P,C,M,Slash,I,N,T,Slash,L,I,T}
-    char *TrackNumber=0xD7
-    char *TrackNumber_size=0x81
-    char *TrackNumber_value=TrackNumber_audio
-    char *TrackUID={0x73,0xC5}
-    char *TrackUID_size=0x81
-    char *TrackUID_value=TrackNumber_audio
-    char *TrackType=0x83
-    char *TrackType_size=0x81
-    char *TrackType_value=2
-    #audio type=2
-    char *FlagLacing=0x9C
-    char *FlagLacing_size=0x81
-    char *FlagLacing_value=0
-    #no lacing used
-    char *Name={0x53,0x6E}
-    char *Name_size=0x85
-    char *Name_value={A,u,d,i,o}
-
-    char *Audio={0xE1}
-    char Audio_size=0x80
-const _audiospec=!
-    char *SamplingFrequency=0xB5
-    char *SamplingFrequency_size=0x84
-    data SamplingFrequency_value#1
-    char *Channels=0x9F
-    char *Channels_size=0x84
-    data Channels_value#1
-    char *BitDepth={0x62,0x64}
-    char *BitDepth_size=0x84
-const audiospec_=!
-    data BitDepth_value#1
-
-    sd io
-    setcall io mkv_write_read_get()
-    if io==(mkv_write)
-        const audiospec_@=audiospec_+4
-        const audiospec_size=audiospec_@-_audiospec
-        or Audio_size (audiospec_size)
-
-        import "stage_sound_rate" stage_sound_rate
-        data freq#1
-        setcall freq stage_sound_rate((value_get))
-        setcall SamplingFrequency_value int_to_float(freq)
-        setcall SamplingFrequency_value dword_reverse(SamplingFrequency_value)
-
-        import "stage_sound_channels" stage_sound_channels
-        setcall Channels_value stage_sound_channels((value_get))
-        import "stage_sound_bps" stage_sound_bps
-        setcall BitDepth_value stage_sound_bps((value_get))
-        setcall Channels_value dword_reverse(Channels_value)
-        setcall BitDepth_value dword_reverse(BitDepth_value)
-    endif
-
-    const audio_size=audiospec_@-_audio
-    data audio^CodecID
-
-    sd bool
-    setcall bool mkv_write_seek(audio,(audio_size),file)
-    return bool
-endfunction
-
-function mkv_read_sound(sd mem,sd size)
-    import "stage_sound_alloc_expand" stage_sound_alloc_expand
-    call stage_sound_alloc_expand(mem,size)
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/output/sound.oc
@@ -0,0 +1,954 @@
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+const stage_sound_alloc_init=0
+const stage_sound_alloc_free=1
+const stage_sound_alloc_expand=2
+const stage_sound_alloc_getremainingsize=3
+const stage_sound_alloc_getbytes=4
+const stage_sound_alloc_printtexter_time=5
+const stage_sound_alloc_printdialog_time=6
+
+import "texter" texter
+
+##some variables
+
+function stage_sound_file_entry(sd action,sd value)
+    data file_entry#1
+    if action=(value_set)
+        set file_entry value
+    else
+        return file_entry
+    endelse
+endfunction
+function stage_sound_file_path(sd action,sd value)
+    data path#1
+    if action=(value_set)
+        set path value
+    else
+        return path
+    endelse
+endfunction
+function stage_sound_pipe(sd action,sd value)
+    data pipe#1
+    if action=(value_set)
+        set pipe value
+    else
+        return pipe
+    endelse
+endfunction
+function stage_sound_dialog(sd action,sd value)
+    data dialog#1
+    if action=(value_set)
+        set dialog value
+    else
+        return dialog
+    endelse
+endfunction
+
+
+
+
+##main func
+
+function stage_sound()
+    sd bool
+    import "sound_preview_bool" sound_preview_bool
+    sd sound_prev
+    setcall sound_prev sound_preview_bool()
+    if sound_prev#!=0
+        import "sound_preview_end_and_no_errors" sound_preview_end_and_no_errors
+
+        setcall bool sound_preview_end_and_no_errors()
+        if bool=(FALSE)
+            str er="The sound is on, stop the stage preview first"
+            call texter(er)
+            return (void)
+        endif
+    endif
+
+    call stage_sound_file_path((value_set),0)
+
+    #dialog
+    importx "_gtk_dialog_new_with_buttons" gtk_dialog_new_with_buttons
+    import "mainwidget" mainwidget
+    sd window
+    setcall window mainwidget()
+
+    str GTK_STOCK_OK="gtk-ok"
+    str GTK_STOCK_CLOSE="gtk-close"
+    ss title="Sound"
+
+    sd dialog
+    setcall dialog gtk_dialog_new_with_buttons(title,window,(GTK_DIALOG_DESTROY_WITH_PARENT|GTK_DIALOG_MODAL),GTK_STOCK_OK,(GTK_RESPONSE_OK),GTK_STOCK_CLOSE,(GTK_RESPONSE_CANCEL),0)
+
+    importx "_gtk_dialog_get_content_area" gtk_dialog_get_content_area
+    sd vbox
+    setcall vbox gtk_dialog_get_content_area(dialog)
+    call stage_sound_init(vbox)
+
+    importx "_gtk_window_set_default_size" gtk_window_set_default_size
+    call gtk_window_set_default_size(dialog,500,-1)
+
+    importx "_gtk_widget_show_all" gtk_widget_show_all
+    call gtk_widget_show_all(dialog)
+
+    #stop flag for imported sound, but is used at print threads environment
+    sd stop_flag
+    setcall stop_flag sound_stop_flag()
+    set stop_flag# 0
+
+    importx "_gtk_dialog_run" gtk_dialog_run
+    sd response
+    setcall response gtk_dialog_run(dialog)
+
+    importx "_gtk_widget_destroy" gtk_widget_destroy
+
+    if response=(GTK_RESPONSE_OK)
+        call stage_sound_set()
+        call gtk_widget_destroy(dialog)
+        sd filepath
+        setcall filepath stage_sound_file_path((value_get))
+        if filepath!=0
+                #for not messing the sound
+            import "mass_remove_job" mass_remove_job
+            setcall bool mass_remove_job()
+            if bool=1
+            #sound import
+                call stage_sound_init_appsink(filepath)
+            endif
+            importx "_g_free" g_free
+            call g_free(filepath)
+        endif
+    else
+        call gtk_widget_destroy(dialog)
+    endelse
+    #redraw the visual sound pulse
+    import "sound_pixbuf_redraw" sound_pixbuf_redraw
+    call sound_pixbuf_redraw()
+endfunction
+
+
+##the pipe mechanism
+
+function stage_sound_init_appsink(sd filepath)
+    #the command for gst-launch
+    ss launchformat="filesrc location=\"%s\" ! decodebin2 ! audioconvert ! audioresample ! audio/x-raw-int,channels=%u,rate=%u,signed=(boolean)true,width=%u,depth=%u,endianness=%u ! appsink emit-signals=TRUE sync=false"
+    sd flocation
+    sd *=0
+    str sound_format^launchformat
+
+    #location
+    #escape path
+    import "string_alloc_escaped" string_alloc_escaped
+    ss escapedpath
+    setcall escapedpath string_alloc_escaped(filepath)
+    if escapedpath=0
+        return 0
+    endif
+    #set
+    set flocation escapedpath
+
+    import "allocsum_numbers_null" allocsum_numbers_null
+    sd command
+    sd p_command^command
+
+    sd err
+    setcall err allocsum_numbers_null(sound_format,5,p_command)
+    if err!=(noerror)
+        return err
+    endif
+
+    #concatenate the command
+    importx "_sprintf" sprintf
+    sd channels
+    setcall channels stage_sound_channels((value_get))
+    sd rate
+    setcall rate stage_sound_rate((value_get))
+    sd bps
+    setcall bps stage_sound_bps((value_get))
+    call sprintf(command,launchformat,flocation,channels,rate,bps,bps,(sound_endian_def))
+    sd com
+    setcall com stage_sound_comm()
+    set com# command
+    call stage_sound_command()
+
+    #clean
+    importx "_free" free
+    call free(escapedpath)
+    call free(command)
+endfunction
+function stage_sound_command()
+    #sync mem
+    sd global_flag
+    setcall global_flag sound_global_flag()
+    set global_flag# 1
+    sd stop_flag
+    setcall stop_flag sound_stop_flag()
+
+    #launch the modal parser
+    import "dialogfield_modal_texter_sync" dialogfield_modal_texter_sync
+    ss title="Sound"
+    data f_init^stage_sound_command_init
+    ss button="Stop"
+    call dialogfield_modal_texter_sync(title,f_init,button,global_flag,stop_flag)
+
+    #stop and free the pipe
+    sd pipe
+    setcall pipe stage_sound_pipe((value_get))
+    import "default_unref" default_unref
+    call default_unref(pipe)
+endfunction
+
+function stage_sound_command_init(sd *vbox,sd dialog)
+    #keep the dialog for eos at appsink or error at pipe
+    call stage_sound_dialog((value_set),dialog)
+
+    #make the pipe
+    sd com
+    setcall com stage_sound_comm()
+    import "launch_pipe_start" launch_pipe_start
+    sd pipeline
+    setcall pipeline launch_pipe_start(com#)
+    if pipeline=0
+        return 0
+    endif
+
+    #put the pipeline to a static place
+    call stage_sound_pipe((value_set),pipeline)
+
+    #add error signal to pipe
+    #sd pipe
+    #setcall pipe stage_sound_pipe((value_get))
+    import "err_signal_modal" err_signal_modal
+    data f^stage_sound_closedialog
+    call err_signal_modal(pipeline,f)
+
+    import "iterate_firstsink" iterate_firstsink
+    #new-buffer signal to appsink, and eos
+    data f_newbuffer^stage_sound_connect_appsink
+    call iterate_firstsink(pipeline,f_newbuffer)
+endfunction
+
+function stage_sound_connect_appsink(sd appsink)
+    #new buffer signal
+    import "connect_signal" connect_signal
+    ss buffer="new-buffer"
+    data f_nb^stage_sound_expand
+    call connect_signal(appsink,buffer,f_nb)
+
+    #add eos at appsink(sometimes eos comes only here)
+    ss eos="eos"
+    data f_eos^stage_sound_closedialog
+    call connect_signal(appsink,eos,f_eos)
+endfunction
+#close the dialog when it is called
+function stage_sound_closedialog()
+	#not in main is here
+	importx "_g_idle_add" g_idle_add
+	call g_idle_add(stage_sound_realclosedialog,(void))
+endfunction
+#bool
+function stage_sound_realclosedialog()
+	sd dialog
+	setcall dialog stage_sound_dialog((value_get))
+	importx "_gtk_dialog_response" gtk_dialog_response
+	call gtk_dialog_response(dialog,(GTK_RESPONSE_OK))
+	call sound_global_flag_set(0)
+	return (FALSE) #to not call again
+endfunction
+
+
+
+
+##user init input
+
+function stage_sound_init(sd vbox)
+    #button to add a new sound
+    import "fchooserbuttonfield_open_label" fchooserbuttonfield_open_label
+    ss text="Open File "
+    sd file
+    setcall file fchooserbuttonfield_open_label(vbox,text)
+    call stage_sound_file_entry((value_set),file)
+
+    import "buttonfield_prepare_with_label" buttonfield_prepare_with_label
+    importx "_gtk_table_new" gtk_table_new
+    importx "_gtk_table_attach" gtk_table_attach
+    sd table
+    setcall table gtk_table_new(6,2,0)
+
+    #button to remove all sounds
+    ss rem="Remove prepared sound"
+    sd button
+    setcall button buttonfield_prepare_with_label(rem)
+    call gtk_table_attach(table,button,0,1,0,1,(GTK_FILL),0,0,0)
+    #add signal
+    import "connect_clicked" connect_clicked
+    data f^stage_sound_remove
+    call connect_clicked(button,f)
+
+    #button to view how much times is in the prepared sound memory
+    #add button
+    ss view="View prepared sound time"
+    sd time
+    setcall time buttonfield_prepare_with_label(view)
+    call gtk_table_attach(table,time,0,1,1,2,(GTK_FILL),0,0,0)
+    #add signal
+    data f_viewtime^stage_sound_viewtime
+    call connect_clicked(time,f_viewtime)
+
+    #button to cut extra sound time to be equal with the video time
+    ss cut="Cut extra sound"
+    sd cuttime
+    setcall cuttime buttonfield_prepare_with_label(cut)
+    call gtk_table_attach(table,cuttime,0,1,2,3,(GTK_FILL),0,0,0)
+    #add signal
+    data f_cuttime^stage_sound_cut
+    call connect_clicked(cuttime,f_cuttime)
+
+    #button to copy sound created with the program Sound Recorder from oapplications
+    ss cpy="Copy sound"
+    sd copy
+    setcall copy buttonfield_prepare_with_label(cpy)
+    importx "_gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
+    ss cpy_inf="Copy sound from a wav file with a RIFF,fmt ,data chunks (ex: created with the program Sound Recorder)"
+    call gtk_widget_set_tooltip_markup(copy,cpy_inf)
+    call gtk_table_attach(table,copy,0,1,3,4,(GTK_FILL),0,0,0)
+    #add signal
+    data f_copy^stage_sound_copy
+    call connect_clicked(copy,f_copy)
+
+    #button to fade out sound
+    ss fade="Fade out last two seconds"
+    sd fade_button
+    setcall fade_button buttonfield_prepare_with_label(fade)
+    call gtk_table_attach(table,fade_button,0,1,4,5,(GTK_FILL),0,0,0)
+    #add signal
+    data f_fade^stage_sound_fade
+    call connect_clicked(fade_button,f_fade)
+
+    #button to amplify the sound
+    ss amplify="Amplify all sound (%)"
+    sd amplify_button
+    setcall amplify_button buttonfield_prepare_with_label(amplify)
+    call gtk_table_attach(table,amplify_button,0,1,5,6,(GTK_FILL),0,0,0)
+    #number
+    importx "_gtk_entry_new" gtk_entry_new
+    sd entry
+    setcall entry gtk_entry_new()
+    call gtk_table_attach(table,entry,1,2,5,6,0,0,0,0)
+    #add signal
+    import "connect_clicked_data" connect_clicked_data
+    call connect_clicked_data(amplify_button,stage_amplify,entry)
+
+    #add the table
+    import "packstart_default" packstart_default
+    call packstart_default(vbox,table)
+endfunction
+import "rest" rest
+import "rule3" rule3
+import "multiple_of_nr" multiple_of_nr
+import "message_dialog" message_dialog
+function stage_sound_remove(sd *widget,sd *data)
+    call stage_sound_alloc_free()
+    call stage_sound_alloc_init()
+
+    ss done="Removed"
+    call message_dialog(done)
+endfunction
+function stage_sound_viewtime(sd *widget,sd *data)
+    call stage_sound_alloc((stage_sound_alloc_printdialog_time))
+endfunction
+function stage_sound_cut(sd *widget,sd *data)
+    import "stage_frame_time_numbers" stage_frame_time_numbers
+    sd t_length
+    setcall t_length stage_frame_time_numbers((stage_frame_time_total_sum))
+
+    import "stage_file_options_fps" stage_file_options_fps
+    sd fps
+    setcall fps stage_file_options_fps()
+
+    sd avgbytes_persec
+    sd blockalign
+    setcall avgbytes_persec stage_sound_avgbytespersec()
+    setcall blockalign stage_sound_blockalign()
+
+    #sound time
+    sd sound_time
+    setcall sound_time stage_sound_framelength_to_soundlength(t_length)
+
+    sd current_sound_size
+    setcall current_sound_size stage_sound_subsize((value_get))
+    if current_sound_size>sound_time
+         call stage_sound_subsize((value_set),sound_time)
+         ss ok="Extra sound removed. Sound time is now equal with video time."
+         call message_dialog(ok)
+    else
+        ss not_needed="There is not extra sound. Sound time is lower or equal with video time."
+        call message_dialog(not_needed)
+    endelse
+endfunction
+import "file_chooser_get_fname" file_chooser_get_fname
+function stage_sound_copy()
+    sd fileentry
+    setcall fileentry stage_sound_file_entry((value_get))
+
+    sd filename
+    setcall filename file_chooser_get_fname(fileentry)
+
+    if filename=0
+        return 0
+    endif
+
+    import "file_get_content_forward" file_get_content_forward
+    data f_copy_sound^stage_sound_copy_action
+    call file_get_content_forward(filename,f_copy_sound)
+
+    call g_free(filename)
+endfunction
+function stage_sound_set()
+    sd fileentry
+    setcall fileentry stage_sound_file_entry((value_get))
+
+    sd filename
+    setcall filename file_chooser_get_fname(fileentry)
+
+    if filename=0
+        str no_f="No file name selected"
+        call texter(no_f)
+        return 0
+    endif
+
+    call stage_sound_file_path((value_set),filename)
+endfunction
+
+import "cpymem" cpymem
+
+function stage_sound_fade()
+    sd fadebytes
+    setcall fadebytes stage_sound_avgbytespersec()
+    mult fadebytes 2
+    sd current_sound_size
+    setcall current_sound_size stage_sound_subsize((value_get))
+
+    sd cursor
+    if fadebytes>=current_sound_size
+        set cursor 0
+	set fadebytes current_sound_size
+    else
+        set cursor current_sound_size
+        sub cursor fadebytes
+    endelse
+
+    ss bytes
+    sd last
+    setcall bytes stage_sound_alloc((stage_sound_alloc_getbytes))
+    set last bytes
+    add bytes cursor
+    add last current_sound_size
+    sd blockalign
+    setcall blockalign stage_sound_blockalign()
+    sd BYps
+    setcall BYps stage_sound_bps((value_get))
+    div BYps 8
+    sd channels
+    sd rate=0
+    sd value
+    sd p_value^value
+    while bytes!=last
+        setcall channels stage_sound_channels((value_get))
+        while channels!=0
+            sd pos
+            if BYps=1
+                set value bytes#
+                sub value 0x80
+            else
+                import "short_get_to_int" short_get_to_int
+                setcall value short_get_to_int(bytes)
+            endelse
+	    #x            fadebytes-rate
+	    #value        fadebytes
+
+            set pos fadebytes
+            sub pos rate
+            data double_data#2
+            data double^double_data
+            import "fild_value" fild_value
+            import "fstp_quad" fstp_quad
+            import "fmul_quad" fmul_quad
+            import "fdiv_quad" fdiv_quad
+            import "fistp" fistp
+            call fild_value(pos)
+            call fstp_quad(double)
+            call fild_value(value)
+            call fmul_quad(double)
+            call fild_value(fadebytes)
+            call fstp_quad(double)
+            call fdiv_quad(double)
+            call fistp(p_value)
+
+            if BYps=1
+                add value 0x80
+                set bytes# value
+            else
+                import "int_into_short" int_into_short
+                call int_into_short(value,bytes)
+            endelse
+            add rate BYps
+            add bytes BYps
+            dec channels
+        endwhile
+    endwhile
+    str fade="End sound faded"
+    call message_dialog(fade)
+endfunction
+
+function stage_amplify(sd *widget,sd entry)
+    import "entry_to_int_min_N_max_M" entry_to_int_min_N_max_M
+    sd nr
+    sd bool
+    setcall bool entry_to_int_min_N_max_M(entry,#nr,1,1000)
+    if bool!=(TRUE)
+        return (FALSE)
+    endif
+
+    call fild_value(nr)
+    sd multp#2
+    sd procent=100
+    import "fidiv" fidiv
+    call fidiv(#procent)
+    import "fiadd" fiadd
+    sd addnr=1
+    call fiadd(#addnr)
+    call fstp_quad(#multp)
+
+    sd channels
+    sd bits_per_sample
+    setcall channels stage_sound_channels((value_get))
+    setcall bits_per_sample stage_sound_bps((value_get))
+
+    sd sound_size
+    setcall sound_size stage_sound_subsize((value_get))
+    ss buf
+    setcall buf stage_sound_alloc_getbytes()
+    sd value
+    sd item
+    sd all_samples
+    set all_samples sound_size
+    divcall all_samples stage_sound_blockalign()
+    sd pos=0
+    while pos<all_samples
+        sd chn=0
+        while chn<channels
+            if bits_per_sample=8
+                set item buf#
+                if item<0x80
+                    set value 0x80
+                    sub value item
+                else
+                    set value item
+                    sub value 0x80
+                endelse
+            elseif bits_per_sample=16
+                setcall value short_get_to_int(buf)
+            else
+                call texter("wrong bits-per-sample")
+                return (void)
+            endelse
+            call fild_value(value)
+            call fmul_quad(#multp)
+            call fistp(#value)
+            sd res_value
+            if bits_per_sample=8
+                if item<0x80
+                    set res_value 0x80
+                    sub res_value value
+                    if res_value<0
+                        set res_value 0
+                    endif
+                else
+                    set res_value 0x80
+                    add res_value value
+                    if res_value>0xff
+                        set res_value 0xff
+                    endif
+                endelse
+                set buf# res_value
+                inc buf
+            else
+            #if bits_per_sample==16
+                if value>0x7fFF
+                    set res_value 0x7fFF
+                elseif value<0xffFF8000
+                    set res_value 0xffFF8000
+                else
+                    set res_value value
+                endelse
+                call int_into_short(res_value,buf)
+                add buf 2
+            endelse
+            inc chn
+        endwhile
+        inc pos
+    endwhile
+    call message_dialog("Amplifyed")
+endfunction
+
+
+
+##expand and keep for output
+
+function stage_sound_alloc_init()
+    call stage_sound_alloc((stage_sound_alloc_init))
+endfunction
+function stage_sound_alloc_free()
+    call stage_sound_alloc((stage_sound_alloc_free))
+endfunction
+function stage_sound_alloc_expand(sd newblock,sd newblock_size)
+    call stage_sound_alloc((stage_sound_alloc_expand),newblock,newblock_size)
+endfunction
+#sz
+function stage_sound_alloc_getremainingsize()
+    sd sz
+    setcall sz stage_sound_alloc((stage_sound_alloc_getremainingsize))
+    return sz
+endfunction
+#bytes
+function stage_sound_alloc_getbytes()
+    sd bytes
+    setcall bytes stage_sound_alloc((stage_sound_alloc_getbytes))
+    return bytes
+endfunction
+
+function stage_sound_subsize(sd action,sd value)
+    data subsize#1
+    if action=(value_set)
+        set subsize value
+    else
+        return subsize
+    endelse
+endfunction
+function stage_sound_alloc(sd action,sd newblock,sd newblock_size)
+    import "memoryrealloc" memoryrealloc
+    data alloc#1
+    data p_alloc^alloc
+    data size#1
+
+	if action=(stage_sound_alloc_init)
+    #init the memory
+        set alloc 0
+        set size 0
+        call stage_sound_subsize((value_set),0)
+        call memoryrealloc(p_alloc,size)
+        return 0
+	endif
+	if action=(stage_sound_alloc_getremainingsize)
+    #get the remaining size
+        sd sz
+        setcall sz stage_sound_subsize((value_get))
+        subcall sz stage_sound_sizedone((value_get))
+        return sz
+	endif
+	if action=(stage_sound_alloc_getbytes)
+        return alloc
+	endif
+    if alloc=0
+        return 0
+    endif
+    if action=(stage_sound_alloc_free)
+        call free(alloc)
+    elseif action=(stage_sound_alloc_expand)
+        sd newsubsize
+        setcall newsubsize stage_sound_subsize((value_get))
+        add newsubsize newblock_size
+
+        sd newsize
+        setcall newsize multiple_of_nr(newsubsize,0x1000)
+
+        if newsize!=size
+            sd err
+            setcall err memoryrealloc(p_alloc,newsize)
+            if err!=(noerror)
+                return err
+            endif
+            set size newsize
+        endif
+
+        sd cursor
+        set cursor alloc
+        addcall cursor stage_sound_subsize((value_get))
+
+        call cpymem(cursor,newblock,newblock_size)
+
+        call stage_sound_subsize((value_set),newsubsize)
+    else
+    #stage_sound_alloc_printtexter_time
+    #stage_sound_alloc_printdialog_time
+        sd stop_flag
+        setcall stop_flag sound_stop_flag()
+        if stop_flag#=1
+            #safe close the main thread if stop pressed
+            call sound_global_flag_set(0)
+            return (void)
+        endif
+
+        sd bytespersec
+        setcall bytespersec stage_sound_avgbytespersec()
+
+        #seconds
+        sd subsize
+        setcall subsize stage_sound_subsize((value_get))
+        sd seconds
+        set seconds subsize
+        div seconds bytespersec
+
+        #decimal part
+        const numbers=4
+        sd bytesrest
+        setcall bytesrest rest(subsize,bytespersec)
+        sd sec_rest
+        setcall sec_rest rule3(bytesrest,bytespersec,(10$numbers-1))
+
+        #print
+        const sountformbufstart=\
+        char format="Prepared sound time: %u.%u"
+        char datastring#\-sountformbufstart-2-2+modal_texter_mark
+        vstr print^datastring
+        call sprintf(print,#format,seconds,sec_rest)
+        if action=(stage_sound_alloc_printtexter_time)
+            import "dialog_modal_texter_draw" dialog_modal_texter_draw
+            call dialog_modal_texter_draw(print)
+        else
+            #if action==(stage_sound_alloc_printdialog_time)
+            call message_dialog(print)
+        endelse
+    endelse
+endfunction
+
+function stage_sound_expand(sd gstappsink,sd *user_data)
+    importx "_g_signal_emit_by_name" g_signal_emit_by_name
+    ss method="pull-buffer"
+    sd buffer
+    sd p_buffer^buffer
+    call g_signal_emit_by_name(gstappsink,method,p_buffer)
+
+    import "structure_get_int" structure_get_int
+    sd data
+    sd size
+
+    #GstBuffer
+        #GstMiniObject
+            #GTypeInstance instance
+            #gint refcount
+            #guint flags
+        #guint8              *data
+        #guint               size
+
+    setcall data structure_get_int(buffer,0x10)
+    setcall size structure_get_int(buffer,0x14)
+
+    #append the new buffer at the sound memory
+    call stage_sound_alloc((stage_sound_alloc_expand),data,size)
+    #print time
+    call stage_sound_alloc((stage_sound_alloc_printtexter_time))
+
+    importx "_gst_mini_object_unref" gst_mini_object_unref
+    call gst_mini_object_unref(buffer)
+endfunction
+
+
+function stage_sound_sizedone(sd action,sd value)
+    data done#1
+    if action=(value_set)
+        set done value
+    else
+        return done
+    endelse
+endfunction
+
+function stage_sound_removeframe(sd frame_pos)
+    sd start_point
+    setcall start_point stage_frame_time_numbers((stage_frame_time_sum_at_index),frame_pos)
+    sd sound_sum_at_index
+    setcall sound_sum_at_index stage_sound_framelength_to_soundlength(start_point)
+
+    sd length_at_point
+    setcall length_at_point stage_frame_time_numbers((stage_frame_time_get_at_index),frame_pos)
+    sd sound_at_index
+    setcall sound_at_index stage_sound_framelength_to_soundlength(length_at_point)
+
+    sd bytes
+    setcall bytes stage_sound_alloc((stage_sound_alloc_getbytes))
+    sd soundsize
+    setcall soundsize stage_sound_subsize((value_get))
+    sd soundtotal
+    set soundtotal soundsize
+
+    if sound_sum_at_index>=soundsize
+        return 0
+    endif
+
+    add bytes sound_sum_at_index
+
+    sub soundsize sound_sum_at_index
+    if soundsize<sound_at_index
+        set sound_at_index soundsize
+    endif
+
+    sd cursor
+    set cursor bytes
+    add cursor sound_at_index
+
+    sub soundsize sound_at_index
+    call cpymem(bytes,cursor,soundsize)
+
+    sub soundtotal sound_at_index
+    call stage_sound_subsize((value_set),soundtotal)
+endfunction
+
+#soundlength
+function stage_sound_framelength_to_soundlength(sd framelength)
+    sd fps
+    setcall fps stage_file_options_fps()
+    sd rest_frame
+    setcall rest_frame rest(framelength,fps)
+    div framelength fps
+
+    sd bytes_per_sec
+    setcall bytes_per_sec stage_sound_avgbytespersec()
+
+    mult framelength bytes_per_sec
+    setcall rest_frame rule3(rest_frame,fps,bytes_per_sec)
+    #round to multiple of blockalign
+    sd blockalign
+    setcall blockalign stage_sound_blockalign()
+    setcall rest_frame multiple_of_nr(rest_frame,blockalign)
+
+    add framelength rest_frame
+    return framelength
+endfunction
+
+############################sound values
+
+function stage_sound_channels(sd action,sd value)
+    data channels=2
+    if action=(value_set)
+        set channels value
+    else
+        return channels
+    endelse
+endfunction
+function stage_sound_rate(sd action,sd value)
+    data rate=48000
+    if action=(value_set)
+        set rate value
+    else
+        return rate
+    endelse
+endfunction
+function stage_sound_bps(sd action,sd value)
+    data bps=16
+    if action=(value_set)
+        set bps value
+    else
+        return bps
+    endelse
+endfunction
+
+function stage_sound_blockalign()
+    sd value
+    setcall value stage_sound_channels((value_get))
+    multcall value stage_sound_bps((value_get))
+    div value 8
+    return value
+endfunction
+function stage_sound_avgbytespersec()
+    sd value
+    setcall value stage_sound_blockalign()
+    multcall value stage_sound_rate((value_get))
+    return value
+endfunction
+
+function sound_get_values(sd mem,sd *size)
+    sd mem_sz^mem
+
+    sd value
+    sd p_value^value
+    import "get_mem_int_advance" get_mem_int_advance
+    sd err
+
+    setcall err get_mem_int_advance(p_value,mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    call stage_sound_channels((value_set),value)
+
+    setcall err get_mem_int_advance(p_value,mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    call stage_sound_rate((value_set),value)
+
+    setcall err get_mem_int_advance(p_value,mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    call stage_sound_bps((value_set),value)
+endfunction
+
+function stage_sound_copy_action(sd mem,sd *size)
+    str r="RIFF"
+    str r_ex="WAVE"
+    str f="fmt "
+    str d="data"
+    sd bool
+    import "riff_head" riff_head
+    sd mem_sz^mem
+    sd chunk_size
+    sd p_chunk_size^chunk_size
+
+    setcall bool riff_head(mem_sz,r,p_chunk_size,r_ex)
+    if bool!=1
+        return 0
+    endif
+    setcall bool riff_head(mem_sz,f,p_chunk_size,0)
+    if bool!=1
+        return 0
+    endif
+    import "move_cursors" move_cursors
+    call move_cursors(mem_sz,chunk_size)
+    setcall bool riff_head(mem_sz,d,p_chunk_size,0)
+    if bool!=1
+        return 0
+    endif
+
+    call stage_sound_alloc_expand(mem,chunk_size)
+    call stage_sound_alloc((stage_sound_alloc_printdialog_time))
+endfunction
+
+
+function sound_global_flag()
+    data global_flag#1
+    data p^global_flag
+    return p
+endfunction
+function sound_global_flag_set(sd value)
+    sd global_flag
+    setcall global_flag sound_global_flag()
+    set global_flag# value
+endfunction
+
+function sound_stop_flag()
+    data stop_flag#1
+    data p^stop_flag
+    return p
+endfunction
+
+function stage_sound_comm()
+    data sound_command#1
+    data p^sound_command
+    return p
+endfunction
--- ovideo-1.orig/src/_prepare/output/sound.s
+++ /dev/null
@@ -1,952 +0,0 @@
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-const stage_sound_alloc_init=0
-const stage_sound_alloc_free=1
-const stage_sound_alloc_expand=2
-const stage_sound_alloc_getremainingsize=3
-const stage_sound_alloc_getbytes=4
-const stage_sound_alloc_printtexter_time=5
-const stage_sound_alloc_printdialog_time=6
-
-import "texter" texter
-
-##some variables
-
-function stage_sound_file_entry(sd action,sd value)
-    data file_entry#1
-    if action==(value_set)
-        set file_entry value
-    else
-        return file_entry
-    endelse
-endfunction
-function stage_sound_file_path(sd action,sd value)
-    data path#1
-    if action==(value_set)
-        set path value
-    else
-        return path
-    endelse
-endfunction
-function stage_sound_pipe(sd action,sd value)
-    data pipe#1
-    if action==(value_set)
-        set pipe value
-    else
-        return pipe
-    endelse
-endfunction
-function stage_sound_dialog(sd action,sd value)
-    data dialog#1
-    if action==(value_set)
-        set dialog value
-    else
-        return dialog
-    endelse
-endfunction
-
-
-
-
-##main func
-
-function stage_sound()
-    sd bool
-    import "sound_preview_bool" sound_preview_bool
-    sd sound_prev
-    setcall sound_prev sound_preview_bool()
-    if sound_prev#!=0
-        import "sound_preview_end_and_no_errors" sound_preview_end_and_no_errors
-
-        setcall bool sound_preview_end_and_no_errors()
-        if bool==(FALSE)
-            str er="The sound is on, stop the stage preview first"
-            call texter(er)
-            return (void)
-        endif
-    endif
-
-    call stage_sound_file_path((value_set),0)
-
-    #dialog
-    importx "_gtk_dialog_new_with_buttons" gtk_dialog_new_with_buttons
-    import "mainwidget" mainwidget
-    sd window
-    setcall window mainwidget()
-
-    str GTK_STOCK_OK="gtk-ok"
-    str GTK_STOCK_CLOSE="gtk-close"
-    ss title="Sound"
-
-    sd dialog
-    setcall dialog gtk_dialog_new_with_buttons(title,window,(GTK_DIALOG_DESTROY_WITH_PARENT|GTK_DIALOG_MODAL),GTK_STOCK_OK,(GTK_RESPONSE_OK),GTK_STOCK_CLOSE,(GTK_RESPONSE_CANCEL),0)
-
-    importx "_gtk_dialog_get_content_area" gtk_dialog_get_content_area
-    sd vbox
-    setcall vbox gtk_dialog_get_content_area(dialog)
-    call stage_sound_init(vbox)
-
-    importx "_gtk_window_set_default_size" gtk_window_set_default_size
-    call gtk_window_set_default_size(dialog,500,-1)
-
-    importx "_gtk_widget_show_all" gtk_widget_show_all
-    call gtk_widget_show_all(dialog)
-
-    #stop flag for imported sound, but is used at print threads environment
-    sd stop_flag
-    setcall stop_flag sound_stop_flag()
-    set stop_flag# 0
-
-    importx "_gtk_dialog_run" gtk_dialog_run
-    sd response
-    setcall response gtk_dialog_run(dialog)
-
-    importx "_gtk_widget_destroy" gtk_widget_destroy
-
-    if response==(GTK_RESPONSE_OK)
-        call stage_sound_set()
-        call gtk_widget_destroy(dialog)
-        sd filepath
-        setcall filepath stage_sound_file_path((value_get))
-        if filepath!=0
-                #for not messing the sound
-            import "mass_remove_job" mass_remove_job
-            setcall bool mass_remove_job()
-            if bool==1
-            #sound import
-                call stage_sound_init_appsink(filepath)
-            endif
-            importx "_g_free" g_free
-            call g_free(filepath)
-        endif
-    else
-        call gtk_widget_destroy(dialog)
-    endelse
-    #redraw the visual sound pulse
-    import "sound_pixbuf_redraw" sound_pixbuf_redraw
-    call sound_pixbuf_redraw()
-endfunction
-
-
-##the pipe mechanism
-
-function stage_sound_init_appsink(sd filepath)
-    #the command for gst-launch
-    ss launchformat="filesrc location=\"%s\" ! decodebin2 ! audioconvert ! audioresample ! audio/x-raw-int,channels=%u,rate=%u,signed=(boolean)true,width=%u,depth=%u,endianness=%u ! appsink emit-signals=TRUE sync=false"
-    sd flocation
-    sd *=0
-    str sound_format^launchformat
-
-    #location
-    #escape path
-    import "string_alloc_escaped" string_alloc_escaped
-    ss escapedpath
-    setcall escapedpath string_alloc_escaped(filepath)
-    if escapedpath==0
-        return 0
-    endif
-    #set
-    set flocation escapedpath
-
-    import "allocsum_numbers_null" allocsum_numbers_null
-    sd command
-    sd p_command^command
-
-    sd err
-    setcall err allocsum_numbers_null(sound_format,5,p_command)
-    if err!=(noerror)
-        return err
-    endif
-
-    #concatenate the command
-    importx "_sprintf" sprintf
-    sd channels
-    setcall channels stage_sound_channels((value_get))
-    sd rate
-    setcall rate stage_sound_rate((value_get))
-    sd bps
-    setcall bps stage_sound_bps((value_get))
-    call sprintf(command,launchformat,flocation,channels,rate,bps,bps,(sound_endian_def))
-    sd com
-    setcall com stage_sound_comm()
-    set com# command
-    call stage_sound_command()
-
-    #clean
-    importx "_free" free
-    call free(escapedpath)
-    call free(command)
-endfunction
-function stage_sound_command()
-    #sync mem
-    sd global_flag
-    setcall global_flag sound_global_flag()
-    set global_flag# 1
-    sd stop_flag
-    setcall stop_flag sound_stop_flag()
-
-    #launch the modal parser
-    import "dialogfield_modal_texter_sync" dialogfield_modal_texter_sync
-    ss title="Sound"
-    data f_init^stage_sound_command_init
-    ss button="Stop"
-    call dialogfield_modal_texter_sync(title,f_init,button,global_flag,stop_flag)
-
-    #stop and free the pipe
-    sd pipe
-    setcall pipe stage_sound_pipe((value_get))
-    import "default_unref" default_unref
-    call default_unref(pipe)
-endfunction
-
-function stage_sound_command_init(sd *vbox,sd dialog)
-    #keep the dialog for eos at appsink or error at pipe
-    call stage_sound_dialog((value_set),dialog)
-
-    #make the pipe
-    sd com
-    setcall com stage_sound_comm()
-    import "launch_pipe_start" launch_pipe_start
-    sd pipeline
-    setcall pipeline launch_pipe_start(com#)
-    if pipeline==0
-        return 0
-    endif
-
-    #put the pipeline to a static place
-    call stage_sound_pipe((value_set),pipeline)
-
-    #add error signal to pipe
-    #sd pipe
-    #setcall pipe stage_sound_pipe((value_get))
-    import "err_signal_modal" err_signal_modal
-    data f^stage_sound_closedialog
-    call err_signal_modal(pipeline,f)
-
-    import "iterate_firstsink" iterate_firstsink
-    #new-buffer signal to appsink, and eos
-    data f_newbuffer^stage_sound_connect_appsink
-    call iterate_firstsink(pipeline,f_newbuffer)
-endfunction
-
-function stage_sound_connect_appsink(sd appsink)
-    #new buffer signal
-    import "connect_signal" connect_signal
-    ss buffer="new-buffer"
-    data f_nb^stage_sound_expand
-    call connect_signal(appsink,buffer,f_nb)
-
-    #add eos at appsink(sometimes eos comes only here)
-    ss eos="eos"
-    data f_eos^stage_sound_closedialog
-    call connect_signal(appsink,eos,f_eos)
-endfunction
-#close the dialog when it is called
-function stage_sound_closedialog()
-	#not in main is here
-	importx "_g_idle_add" g_idle_add
-	call g_idle_add(stage_sound_realclosedialog,(void))
-endfunction
-#bool
-function stage_sound_realclosedialog()
-	sd dialog
-	setcall dialog stage_sound_dialog((value_get))
-	importx "_gtk_dialog_response" gtk_dialog_response
-	call gtk_dialog_response(dialog,(GTK_RESPONSE_OK))
-	call sound_global_flag_set(0)
-	return (FALSE) #to not call again
-endfunction
-
-
-
-
-##user init input
-
-function stage_sound_init(sd vbox)
-    #button to add a new sound
-    import "fchooserbuttonfield_open_label" fchooserbuttonfield_open_label
-    ss text="Open File "
-    sd file
-    setcall file fchooserbuttonfield_open_label(vbox,text)
-    call stage_sound_file_entry((value_set),file)
-
-    import "buttonfield_prepare_with_label" buttonfield_prepare_with_label
-    importx "_gtk_table_new" gtk_table_new
-    importx "_gtk_table_attach" gtk_table_attach
-    sd table
-    setcall table gtk_table_new(6,2,0)
-
-    #button to remove all sounds
-    ss rem="Remove prepared sound"
-    sd button
-    setcall button buttonfield_prepare_with_label(rem)
-    call gtk_table_attach(table,button,0,1,0,1,(GTK_FILL),0,0,0)
-    #add signal
-    import "connect_clicked" connect_clicked
-    data f^stage_sound_remove
-    call connect_clicked(button,f)
-
-    #button to view how much times is in the prepared sound memory
-    #add button
-    ss view="View prepared sound time"
-    sd time
-    setcall time buttonfield_prepare_with_label(view)
-    call gtk_table_attach(table,time,0,1,1,2,(GTK_FILL),0,0,0)
-    #add signal
-    data f_viewtime^stage_sound_viewtime
-    call connect_clicked(time,f_viewtime)
-
-    #button to cut extra sound time to be equal with the video time
-    ss cut="Cut extra sound"
-    sd cuttime
-    setcall cuttime buttonfield_prepare_with_label(cut)
-    call gtk_table_attach(table,cuttime,0,1,2,3,(GTK_FILL),0,0,0)
-    #add signal
-    data f_cuttime^stage_sound_cut
-    call connect_clicked(cuttime,f_cuttime)
-
-    #button to copy sound created with the program Sound Recorder from oapplications
-    ss cpy="Copy sound"
-    sd copy
-    setcall copy buttonfield_prepare_with_label(cpy)
-    importx "_gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
-    ss cpy_inf="Copy sound from a wav file with a RIFF,fmt ,data chunks (ex: created with the program Sound Recorder)"
-    call gtk_widget_set_tooltip_markup(copy,cpy_inf)
-    call gtk_table_attach(table,copy,0,1,3,4,(GTK_FILL),0,0,0)
-    #add signal
-    data f_copy^stage_sound_copy
-    call connect_clicked(copy,f_copy)
-
-    #button to fade out sound
-    ss fade="Fade out last two seconds"
-    sd fade_button
-    setcall fade_button buttonfield_prepare_with_label(fade)
-    call gtk_table_attach(table,fade_button,0,1,4,5,(GTK_FILL),0,0,0)
-    #add signal
-    data f_fade^stage_sound_fade
-    call connect_clicked(fade_button,f_fade)
-
-    #button to amplify the sound
-    ss amplify="Amplify all sound (%)"
-    sd amplify_button
-    setcall amplify_button buttonfield_prepare_with_label(amplify)
-    call gtk_table_attach(table,amplify_button,0,1,5,6,(GTK_FILL),0,0,0)
-    #number
-    importx "_gtk_entry_new" gtk_entry_new
-    sd entry
-    setcall entry gtk_entry_new()
-    call gtk_table_attach(table,entry,1,2,5,6,0,0,0,0)
-    #add signal
-    import "connect_clicked_data" connect_clicked_data
-    call connect_clicked_data(amplify_button,stage_amplify,entry)
-
-    #add the table
-    import "packstart_default" packstart_default
-    call packstart_default(vbox,table)
-endfunction
-import "rest" rest
-import "rule3" rule3
-import "multiple_of_nr" multiple_of_nr
-import "message_dialog" message_dialog
-function stage_sound_remove(sd *widget,sd *data)
-    call stage_sound_alloc_free()
-    call stage_sound_alloc_init()
-
-    ss done="Removed"
-    call message_dialog(done)
-endfunction
-function stage_sound_viewtime(sd *widget,sd *data)
-    call stage_sound_alloc((stage_sound_alloc_printdialog_time))
-endfunction
-function stage_sound_cut(sd *widget,sd *data)
-    import "stage_frame_time_numbers" stage_frame_time_numbers
-    sd t_length
-    setcall t_length stage_frame_time_numbers((stage_frame_time_total_sum))
-
-    import "stage_file_options_fps" stage_file_options_fps
-    sd fps
-    setcall fps stage_file_options_fps()
-
-    sd avgbytes_persec
-    sd blockalign
-    setcall avgbytes_persec stage_sound_avgbytespersec()
-    setcall blockalign stage_sound_blockalign()
-
-    #sound time
-    sd sound_time
-    setcall sound_time stage_sound_framelength_to_soundlength(t_length)
-
-    sd current_sound_size
-    setcall current_sound_size stage_sound_subsize((value_get))
-    if current_sound_size>sound_time
-         call stage_sound_subsize((value_set),sound_time)
-         ss ok="Extra sound removed. Sound time is now equal with video time."
-         call message_dialog(ok)
-    else
-        ss not_needed="There is not extra sound. Sound time is lower or equal with video time."
-        call message_dialog(not_needed)
-    endelse
-endfunction
-import "file_chooser_get_fname" file_chooser_get_fname
-function stage_sound_copy()
-    sd fileentry
-    setcall fileentry stage_sound_file_entry((value_get))
-
-    sd filename
-    setcall filename file_chooser_get_fname(fileentry)
-
-    if filename==0
-        return 0
-    endif
-
-    import "file_get_content_forward" file_get_content_forward
-    data f_copy_sound^stage_sound_copy_action
-    call file_get_content_forward(filename,f_copy_sound)
-
-    call g_free(filename)
-endfunction
-function stage_sound_set()
-    sd fileentry
-    setcall fileentry stage_sound_file_entry((value_get))
-
-    sd filename
-    setcall filename file_chooser_get_fname(fileentry)
-
-    if filename==0
-        str no_f="No file name selected"
-        call texter(no_f)
-        return 0
-    endif
-
-    call stage_sound_file_path((value_set),filename)
-endfunction
-
-import "cpymem" cpymem
-
-function stage_sound_fade()
-    sd fadebytes
-    setcall fadebytes stage_sound_avgbytespersec()
-    mult fadebytes 2
-    sd current_sound_size
-    setcall current_sound_size stage_sound_subsize((value_get))
-
-    sd cursor
-    if fadebytes>=current_sound_size
-        set cursor 0
-	set fadebytes current_sound_size
-    else
-        set cursor current_sound_size
-        sub cursor fadebytes
-    endelse
-
-    ss bytes
-    sd last
-    setcall bytes stage_sound_alloc((stage_sound_alloc_getbytes))
-    set last bytes
-    add bytes cursor
-    add last current_sound_size
-    sd blockalign
-    setcall blockalign stage_sound_blockalign()
-    sd BYps
-    setcall BYps stage_sound_bps((value_get))
-    div BYps 8
-    sd channels
-    sd rate=0
-    sd value
-    sd p_value^value
-    while bytes!=last
-        setcall channels stage_sound_channels((value_get))
-        while channels!=0
-            sd pos
-            if BYps==1
-                set value bytes#
-                sub value 0x80
-            else
-                import "short_get_to_int" short_get_to_int
-                setcall value short_get_to_int(bytes)
-            endelse
-	    #x            fadebytes-rate
-	    #value        fadebytes
-
-            set pos fadebytes
-            sub pos rate
-            data double_data#2
-            data double^double_data
-            import "fild_value" fild_value
-            import "fstp_quad" fstp_quad
-            import "fmul_quad" fmul_quad
-            import "fdiv_quad" fdiv_quad
-            import "fistp" fistp
-            call fild_value(pos)
-            call fstp_quad(double)
-            call fild_value(value)
-            call fmul_quad(double)
-            call fild_value(fadebytes)
-            call fstp_quad(double)
-            call fdiv_quad(double)
-            call fistp(p_value)
-
-            if BYps==1
-                add value 0x80
-                set bytes# value
-            else
-                import "int_into_short" int_into_short
-                call int_into_short(value,bytes)
-            endelse
-            add rate BYps
-            add bytes BYps
-            dec channels
-        endwhile
-    endwhile
-    str fade="End sound faded"
-    call message_dialog(fade)
-endfunction
-
-function stage_amplify(sd *widget,sd entry)
-    import "entry_to_int_min_N_max_M" entry_to_int_min_N_max_M
-    sd nr
-    sd bool
-    setcall bool entry_to_int_min_N_max_M(entry,#nr,1,1000)
-    if bool!=(TRUE)
-        return (FALSE)
-    endif
-
-    call fild_value(nr)
-    sd multp#2
-    sd procent=100
-    import "fidiv" fidiv
-    call fidiv(#procent)
-    import "fiadd" fiadd
-    sd addnr=1
-    call fiadd(#addnr)
-    call fstp_quad(#multp)
-
-    sd channels
-    sd bits_per_sample
-    setcall channels stage_sound_channels((value_get))
-    setcall bits_per_sample stage_sound_bps((value_get))
-
-    sd sound_size
-    setcall sound_size stage_sound_subsize((value_get))
-    ss buf
-    setcall buf stage_sound_alloc_getbytes()
-    sd value
-    sd item
-    sd all_samples
-    set all_samples sound_size
-    divcall all_samples stage_sound_blockalign()
-    sd pos=0
-    while pos<all_samples
-        sd chn=0
-        while chn<channels
-            if bits_per_sample==8
-                set item buf#
-                if item<0x80
-                    set value 0x80
-                    sub value item
-                else
-                    set value item
-                    sub value 0x80
-                endelse
-            elseif bits_per_sample==16
-                setcall value short_get_to_int(buf)
-            else
-                call texter("wrong bits-per-sample")
-                return (void)
-            endelse
-            call fild_value(value)
-            call fmul_quad(#multp)
-            call fistp(#value)
-            sd res_value
-            if bits_per_sample==8
-                if item<0x80
-                    set res_value 0x80
-                    sub res_value value
-                    if res_value<0
-                        set res_value 0
-                    endif
-                else
-                    set res_value 0x80
-                    add res_value value
-                    if res_value>0xff
-                        set res_value 0xff
-                    endif
-                endelse
-                set buf# res_value
-                inc buf
-            else
-            #if bits_per_sample==16
-                if value>0x7fFF
-                    set res_value 0x7fFF
-                elseif value<0xffFF8000
-                    set res_value 0xffFF8000
-                else
-                    set res_value value
-                endelse
-                call int_into_short(res_value,buf)
-                add buf 2
-            endelse
-            inc chn
-        endwhile
-        inc pos
-    endwhile
-    call message_dialog("Amplifyed")
-endfunction
-
-
-
-##expand and keep for output
-
-function stage_sound_alloc_init()
-    call stage_sound_alloc((stage_sound_alloc_init))
-endfunction
-function stage_sound_alloc_free()
-    call stage_sound_alloc((stage_sound_alloc_free))
-endfunction
-function stage_sound_alloc_expand(sd newblock,sd newblock_size)
-    call stage_sound_alloc((stage_sound_alloc_expand),newblock,newblock_size)
-endfunction
-#sz
-function stage_sound_alloc_getremainingsize()
-    sd sz
-    setcall sz stage_sound_alloc((stage_sound_alloc_getremainingsize))
-    return sz
-endfunction
-#bytes
-function stage_sound_alloc_getbytes()
-    sd bytes
-    setcall bytes stage_sound_alloc((stage_sound_alloc_getbytes))
-    return bytes
-endfunction
-
-function stage_sound_subsize(sd action,sd value)
-    data subsize#1
-    if action==(value_set)
-        set subsize value
-    else
-        return subsize
-    endelse
-endfunction
-function stage_sound_alloc(sd action,sd newblock,sd newblock_size)
-    import "memoryrealloc" memoryrealloc
-    data alloc#1
-    data p_alloc^alloc
-    data size#1
-
-    if action==(stage_sound_alloc_init)
-    #init the memory
-        set alloc 0
-        set size 0
-        call stage_sound_subsize((value_set),0)
-        call memoryrealloc(p_alloc,size)
-        return 0
-    elseif action==(stage_sound_alloc_getremainingsize)
-    #get the remaining size
-        sd sz
-        setcall sz stage_sound_subsize((value_get))
-        subcall sz stage_sound_sizedone((value_get))
-        return sz
-    elseif action==(stage_sound_alloc_getbytes)
-        return alloc
-    endelseif
-    if alloc==0
-        return 0
-    endif
-    if action==(stage_sound_alloc_free)
-        call free(alloc)
-    elseif action==(stage_sound_alloc_expand)
-        sd newsubsize
-        setcall newsubsize stage_sound_subsize((value_get))
-        add newsubsize newblock_size
-
-        sd newsize
-        setcall newsize multiple_of_nr(newsubsize,0x1000)
-
-        if newsize!=size
-            sd err
-            setcall err memoryrealloc(p_alloc,newsize)
-            if err!=(noerror)
-                return err
-            endif
-            set size newsize
-        endif
-
-        sd cursor
-        set cursor alloc
-        addcall cursor stage_sound_subsize((value_get))
-
-        call cpymem(cursor,newblock,newblock_size)
-
-        call stage_sound_subsize((value_set),newsubsize)
-    else
-    #stage_sound_alloc_printtexter_time
-    #stage_sound_alloc_printdialog_time
-        sd stop_flag
-        setcall stop_flag sound_stop_flag()
-        if stop_flag#==1
-            #safe close the main thread if stop pressed
-            call sound_global_flag_set(0)
-            return (void)
-        endif
-
-        sd bytespersec
-        setcall bytespersec stage_sound_avgbytespersec()
-
-        #seconds
-        sd subsize
-        setcall subsize stage_sound_subsize((value_get))
-        sd seconds
-        set seconds subsize
-        div seconds bytespersec
-
-        #decimal part
-        const numbers=4
-        sd bytesrest
-        setcall bytesrest rest(subsize,bytespersec)
-        sd sec_rest
-        setcall sec_rest rule3(bytesrest,bytespersec,(10$numbers-1))
-
-        #print
-        const sountformbufstart=!
-        char format="Prepared sound time: %u.%u"
-        char datastring#!-sountformbufstart-2-2+modal_texter_mark
-        vstr print^datastring
-        call sprintf(print,#format,seconds,sec_rest)
-        if action==(stage_sound_alloc_printtexter_time)
-            import "dialog_modal_texter_draw" dialog_modal_texter_draw
-            call dialog_modal_texter_draw(print)
-        else
-            #if action==(stage_sound_alloc_printdialog_time)
-            call message_dialog(print)
-        endelse
-    endelse
-endfunction
-
-function stage_sound_expand(sd gstappsink,sd *user_data)
-    importx "_g_signal_emit_by_name" g_signal_emit_by_name
-    ss method="pull-buffer"
-    sd buffer
-    sd p_buffer^buffer
-    call g_signal_emit_by_name(gstappsink,method,p_buffer)
-
-    import "structure_get_int" structure_get_int
-    sd data
-    sd size
-
-    #GstBuffer
-        #GstMiniObject
-            #GTypeInstance instance
-            #gint refcount
-            #guint flags
-        #guint8              *data
-        #guint               size
-
-    setcall data structure_get_int(buffer,0x10)
-    setcall size structure_get_int(buffer,0x14)
-
-    #append the new buffer at the sound memory
-    call stage_sound_alloc((stage_sound_alloc_expand),data,size)
-    #print time
-    call stage_sound_alloc((stage_sound_alloc_printtexter_time))
-
-    importx "_gst_mini_object_unref" gst_mini_object_unref
-    call gst_mini_object_unref(buffer)
-endfunction
-
-
-function stage_sound_sizedone(sd action,sd value)
-    data done#1
-    if action==(value_set)
-        set done value
-    else
-        return done
-    endelse
-endfunction
-
-function stage_sound_removeframe(sd frame_pos)
-    sd start_point
-    setcall start_point stage_frame_time_numbers((stage_frame_time_sum_at_index),frame_pos)
-    sd sound_sum_at_index
-    setcall sound_sum_at_index stage_sound_framelength_to_soundlength(start_point)
-
-    sd length_at_point
-    setcall length_at_point stage_frame_time_numbers((stage_frame_time_get_at_index),frame_pos)
-    sd sound_at_index
-    setcall sound_at_index stage_sound_framelength_to_soundlength(length_at_point)
-
-    sd bytes
-    setcall bytes stage_sound_alloc((stage_sound_alloc_getbytes))
-    sd soundsize
-    setcall soundsize stage_sound_subsize((value_get))
-    sd soundtotal
-    set soundtotal soundsize
-
-    if sound_sum_at_index>=soundsize
-        return 0
-    endif
-
-    add bytes sound_sum_at_index
-
-    sub soundsize sound_sum_at_index
-    if soundsize<sound_at_index
-        set sound_at_index soundsize
-    endif
-
-    sd cursor
-    set cursor bytes
-    add cursor sound_at_index
-
-    sub soundsize sound_at_index
-    call cpymem(bytes,cursor,soundsize)
-
-    sub soundtotal sound_at_index
-    call stage_sound_subsize((value_set),soundtotal)
-endfunction
-
-#soundlength
-function stage_sound_framelength_to_soundlength(sd framelength)
-    sd fps
-    setcall fps stage_file_options_fps()
-    sd rest_frame
-    setcall rest_frame rest(framelength,fps)
-    div framelength fps
-
-    sd bytes_per_sec
-    setcall bytes_per_sec stage_sound_avgbytespersec()
-
-    mult framelength bytes_per_sec
-    setcall rest_frame rule3(rest_frame,fps,bytes_per_sec)
-    #round to multiple of blockalign
-    sd blockalign
-    setcall blockalign stage_sound_blockalign()
-    setcall rest_frame multiple_of_nr(rest_frame,blockalign)
-
-    add framelength rest_frame
-    return framelength
-endfunction
-
-############################sound values
-
-function stage_sound_channels(sd action,sd value)
-    data channels=2
-    if action==(value_set)
-        set channels value
-    else
-        return channels
-    endelse
-endfunction
-function stage_sound_rate(sd action,sd value)
-    data rate=48000
-    if action==(value_set)
-        set rate value
-    else
-        return rate
-    endelse
-endfunction
-function stage_sound_bps(sd action,sd value)
-    data bps=16
-    if action==(value_set)
-        set bps value
-    else
-        return bps
-    endelse
-endfunction
-
-function stage_sound_blockalign()
-    sd value
-    setcall value stage_sound_channels((value_get))
-    multcall value stage_sound_bps((value_get))
-    div value 8
-    return value
-endfunction
-function stage_sound_avgbytespersec()
-    sd value
-    setcall value stage_sound_blockalign()
-    multcall value stage_sound_rate((value_get))
-    return value
-endfunction
-
-function sound_get_values(sd mem,sd *size)
-    sd mem_sz^mem
-
-    sd value
-    sd p_value^value
-    import "get_mem_int_advance" get_mem_int_advance
-    sd err
-
-    setcall err get_mem_int_advance(p_value,mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    call stage_sound_channels((value_set),value)
-
-    setcall err get_mem_int_advance(p_value,mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    call stage_sound_rate((value_set),value)
-
-    setcall err get_mem_int_advance(p_value,mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    call stage_sound_bps((value_set),value)
-endfunction
-
-function stage_sound_copy_action(sd mem,sd *size)
-    str r="RIFF"
-    str r_ex="WAVE"
-    str f="fmt "
-    str d="data"
-    sd bool
-    import "riff_head" riff_head
-    sd mem_sz^mem
-    sd chunk_size
-    sd p_chunk_size^chunk_size
-
-    setcall bool riff_head(mem_sz,r,p_chunk_size,r_ex)
-    if bool!=1
-        return 0
-    endif
-    setcall bool riff_head(mem_sz,f,p_chunk_size,0)
-    if bool!=1
-        return 0
-    endif
-    import "move_cursors" move_cursors
-    call move_cursors(mem_sz,chunk_size)
-    setcall bool riff_head(mem_sz,d,p_chunk_size,0)
-    if bool!=1
-        return 0
-    endif
-
-    call stage_sound_alloc_expand(mem,chunk_size)
-    call stage_sound_alloc((stage_sound_alloc_printdialog_time))
-endfunction
-
-
-function sound_global_flag()
-    data global_flag#1
-    data p^global_flag
-    return p
-endfunction
-function sound_global_flag_set(sd value)
-    sd global_flag
-    setcall global_flag sound_global_flag()
-    set global_flag# value
-endfunction
-
-function sound_stop_flag()
-    data stop_flag#1
-    data p^stop_flag
-    return p
-endfunction
-
-function stage_sound_comm()
-    data sound_command#1
-    data p^sound_command
-    return p
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/output/stagefileoptions.oc
@@ -0,0 +1,608 @@
+
+
+
+format elfobj
+
+include "../../_include/include.h"
+
+function stage_file_options_got_file(sd mem,sd *size)
+    #values and initial default set
+    data fps#1
+    data ptr_fps^fps
+    const ptr_fps^fps
+    set fps 2
+
+    data output#1
+    data ptr_output^output
+    const ptr_output^output
+    set output 0
+
+    #set from the option file
+    sd err
+    data noerr=noerror
+    import "get_mem_int_advance" get_mem_int_advance
+    sd mem_sz^mem
+
+    setcall err get_mem_int_advance(ptr_fps,mem_sz)
+    if err!=noerr
+        return err
+    endif
+
+    import "av_good_fps" av_good_fps
+    call av_good_fps(ptr_fps)
+
+    setcall err get_mem_int_advance(ptr_output,mem_sz)
+    if err!=noerr
+        return err
+    endif
+
+    sd value
+    sd p_value^value
+    setcall err get_mem_int_advance(p_value,mem_sz)
+    if err!=noerr
+        return err
+    endif
+    call stage_file_options_info_message((value_set),value)
+endfunction
+
+function stage_file_options_fname()
+    str stagedata="stage.data"
+    return stagedata
+endfunction
+
+function stage_file_options_init()
+    #stage data
+    ss stagedata
+    setcall stagedata stage_file_options_fname()
+
+    import "file_get_content_forward" file_get_content_forward
+    data f^stage_file_options_got_file
+    call file_get_content_forward(stagedata,f)
+
+    #jpeg specific
+    import "jpeg_get_quality" jpeg_get_quality
+    data j_f^jpeg_get_quality
+    ss jpeg_data
+    setcall jpeg_data jpeg_file()
+    call file_get_content_forward(jpeg_data,j_f)
+
+    #mpeg specific
+    import "mpeg_options" mpeg_options
+    data mpeg_f^mpeg_options
+    sd mpeg_data
+    setcall mpeg_data mpeg_file()
+    call file_get_content_forward(mpeg_data,mpeg_f)
+
+    #sound data
+    import "sound_get_values" sound_get_values
+    data s_f^sound_get_values
+    sd sdata
+    setcall sdata sound_file()
+    call file_get_content_forward(sdata,s_f)
+
+    #capture data
+    import "capture_get_data" capture_get_data
+    data c_f^capture_get_data
+    sd cdata
+    setcall cdata capture_file()
+    call file_get_content_forward(cdata,c_f)
+endfunction
+function jpeg_file()
+    str jpeg_data="jpeg.data"
+    return jpeg_data
+endfunction
+function mpeg_file()
+    str mpeg_data="mpeg.data"
+    return mpeg_data
+endfunction
+function sound_file()
+    str sdata="sound.data"
+    return sdata
+endfunction
+function capture_file()
+    str cdata="capture.data"
+    return cdata
+endfunction
+
+function stage_file_options_fps_pointer()
+    data ptr_fps%ptr_fps
+    return ptr_fps
+endfunction
+function stage_file_options_fps()
+    sd p_fps
+    setcall p_fps stage_file_options_fps_pointer()
+    return p_fps#
+endfunction
+
+function stage_file_options_output_pointer()
+    data ptr_output%ptr_output
+    return ptr_output
+endfunction
+function stage_file_options_output()
+    data ptr_output#1
+    setcall ptr_output stage_file_options_output_pointer()
+    return ptr_output#
+endfunction
+function stage_file_options_info_message(sd action,sd value)
+    data flag#1
+    if action=(value_set)
+        set flag value
+    else
+        return flag
+    endelse
+endfunction
+
+import "jpeg_dialog" jpeg_dialog
+import "update_set" update_set
+import "update_mem" update_mem
+#case start:arg1 is vbox
+#case notstart:arg1 fileout
+function stage_file_options_structure(sd start,sd arg1)
+    data true=1
+    data rows=4
+    data cols=2
+
+    #also it is required to look at values above and at strings below
+    #and at constants (format_avi, format_mkv, ...)
+
+    data fps_label#1
+    data fps_edit#1
+    data outformat_label#1
+    data outformat_list#1
+    data *space=0
+    data options#1
+    data img_jpeg#1
+    data *space=0
+    data v_cells^fps_label
+
+    data ch_txt#1
+    data ch_opt#1
+    data rate_txt#1
+    data rate_opt#1
+    data bps_txt#1
+    data bps_opt#1
+    data a_cells^ch_txt
+
+    data results_toggle#1
+    data update_toggle#1
+
+    import "stage_sound_channels" stage_sound_channels
+    import "stage_sound_rate" stage_sound_rate
+    import "stage_sound_bps" stage_sound_bps
+    sd channels
+    sd rate
+    sd bps
+    sd p_channels^channels
+    sd p_rate^rate
+    sd p_bps^bps
+
+    sd ptr_out
+    setcall ptr_out stage_file_options_output_pointer()
+    if start=true
+        sd vbox
+        set vbox arg1
+        importx "_gtk_frame_new" gtk_frame_new
+        import "packstart" packstart
+        import "tablefield_cells" tablefield_cells
+#video
+        str video="Video"
+        sd v_frame
+        setcall v_frame gtk_frame_new(video)
+        call packstart(vbox,v_frame,(TRUE))
+
+        #fps
+        importx "_gtk_label_new" gtk_label_new
+        str fps_label_text="Frames-per-second"
+        setcall fps_label gtk_label_new(fps_label_text)
+        import "editfield_with_int" editfield_with_int
+        sd fps
+        setcall fps stage_file_options_fps()
+        setcall fps_edit editfield_with_int(fps)
+
+        #output format
+        str outformat_label_text="Output format"
+        setcall outformat_label gtk_label_new(outformat_label_text)
+        importx "_gtk_combo_box_text_new" gtk_combo_box_text_new
+        setcall outformat_list gtk_combo_box_text_new()
+
+        #connect changed signal for storing the index
+        import "connect_signal_data" connect_signal_data
+        str change="changed"
+        data ch_fn^stage_oformat_changed
+        call connect_signal_data(outformat_list,change,ch_fn,ptr_out)
+
+        importx "_gtk_combo_box_text_append_text" gtk_combo_box_text_append_text
+
+        str entry1="AVI yuv"
+        call gtk_combo_box_text_append_text(outformat_list,entry1)
+        str entry1_i420="AVI/I420\\PCM"
+        call gtk_combo_box_text_append_text(outformat_list,entry1_i420)
+        str entry1_jpg="AVI/MJPEG\\PCM"
+        call gtk_combo_box_text_append_text(outformat_list,entry1_jpg)
+        str entry1_xvid="AVI/MPG4-ASP\\PCM"
+        call gtk_combo_box_text_append_text(outformat_list,entry1_xvid)
+
+        str entry2="MXF"
+        call gtk_combo_box_text_append_text(outformat_list,entry2)
+
+        str entry3_1="MKV/I420\\PCM"
+        call gtk_combo_box_text_append_text(outformat_list,entry3_1)
+        str entry3_2="MKV/MJEPG\\PCM"
+        call gtk_combo_box_text_append_text(outformat_list,entry3_2)
+        str entry3_3="MKV/MPG4-ASP\\PCM"
+        call gtk_combo_box_text_append_text(outformat_list,entry3_3)
+        str entry3_4="MKV/RGB24\\PCM"
+        call gtk_combo_box_text_append_text(outformat_list,entry3_4)
+
+        str entry4_1="MP4/MPG4-AVC\\MP3"
+        call gtk_combo_box_text_append_text(outformat_list,entry4_1)
+
+        importx "_gtk_combo_box_set_active" gtk_combo_box_set_active
+        call gtk_combo_box_set_active(outformat_list,ptr_out#)
+
+        #configurations
+        import "buttonfield_prepare_with_label" buttonfield_prepare_with_label
+        str conf="Format configure"
+        setcall options buttonfield_prepare_with_label(conf)
+        import "connect_clicked" connect_clicked
+        data f^stage_properties_enc
+        call connect_clicked(options,f)
+
+        #image
+        ss jpg="Image - JPEG"
+        setcall img_jpeg buttonfield_prepare_with_label(jpg)
+        data f_jpg_img^jpeg_dialog
+        call connect_clicked(img_jpeg,f_jpg_img)
+
+        call tablefield_cells(v_frame,rows,cols,v_cells)
+#audio
+        str audio="Audio"
+        sd a_frame
+        setcall a_frame gtk_frame_new(audio)
+        call packstart(vbox,a_frame,(TRUE))
+
+        str ch_info="Channels"
+        setcall ch_txt gtk_label_new(ch_info)
+        setcall channels stage_sound_channels((value_get))
+        setcall ch_opt editfield_with_int(channels)
+        #
+        str rate_info="Samples-per-sec"
+        setcall rate_txt gtk_label_new(rate_info)
+        setcall rate stage_sound_rate((value_get))
+        setcall rate_opt editfield_with_int(rate)
+        #
+        str bps_info="Bits-per-sample"
+        setcall bps_txt gtk_label_new(bps_info)
+        setcall bps stage_sound_bps((value_get))
+        setcall bps_opt editfield_with_int(bps)
+        #
+        call tablefield_cells(a_frame,3,2,a_cells)
+#
+        importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
+        importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
+        import "packstart_default" packstart_default
+        #results message
+        ss txt="Show results message(if available)"
+        setcall results_toggle gtk_check_button_new_with_label(txt)
+        sd toggle
+        setcall toggle stage_file_options_info_message((value_get))
+        if toggle!=0
+            call gtk_toggle_button_set_active(results_toggle,1)
+        endif
+        call packstart_default(vbox,results_toggle)
+        #updates
+        ss up_txt="Check for updates"
+        setcall update_toggle gtk_check_button_new_with_label(up_txt)
+        sd update
+        setcall update update_mem()
+        if update#=(TRUE)
+            call gtk_toggle_button_set_active(update_toggle,1)
+        endif
+        call packstart_default(vbox,update_toggle)
+    else
+        import "file_write" file_write
+        importx "_gtk_entry_get_text" gtk_entry_get_text
+#
+        ss currentframestext
+        setcall currentframestext gtk_entry_get_text(fps_edit)
+
+        sd err
+        data noerr=noerror
+
+        import "strtoint" strtoint
+        sd fpspointer%ptr_fps
+        call strtoint(currentframestext,fpspointer)
+        call av_good_fps(fpspointer)
+        setcall err file_write(fpspointer,4,arg1)
+        if err!=noerr
+            return err
+        endif
+
+        setcall err file_write(ptr_out,4,arg1)
+        if err!=noerr
+            return err
+        endif
+#
+        ss file_sound
+        setcall file_sound sound_file()
+        sd audio_file
+        sd p_audio_file^audio_file
+        str s_fmode="wb"
+        import "openfile" openfile
+        setcall err openfile(p_audio_file,file_sound,s_fmode)
+        if err!=noerr
+            return err
+        endif
+        import "entry_to_nr_minValue" entry_to_nr_minValue
+
+        call entry_to_nr_minValue(ch_opt,p_channels,1)
+        call entry_to_nr_minValue(rate_opt,p_rate,1)
+        call entry_to_nr_minValue(bps_opt,p_bps,8)
+
+        call stage_sound_channels((value_set),channels)
+        call stage_sound_rate((value_set),rate)
+        call stage_sound_bps((value_set),bps)
+
+        call write_sound_options(audio_file,p_channels,p_rate,p_bps)
+
+        importx "_fclose" fclose
+        call fclose(audio_file)
+#
+        importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
+        #
+        sd toggle_flag
+        sd p_toggle_flag^toggle_flag
+        setcall toggle_flag gtk_toggle_button_get_active(results_toggle)
+        call stage_file_options_info_message((value_set),toggle_flag)
+        setcall err file_write(p_toggle_flag,4,arg1)
+        if err!=noerr
+            return err
+        endif
+        #
+        sd up_flag
+        setcall up_flag gtk_toggle_button_get_active(update_toggle)
+        call update_set(up_flag)
+        #
+    endelse
+endfunction
+function stage_oformat_changed(sd combo,sd p_loc)
+    importx "_gtk_combo_box_get_active" gtk_combo_box_get_active
+    setcall p_loc# gtk_combo_box_get_active(combo)
+endfunction
+
+import "get_string_at_index" get_string_at_index
+#type/extension
+function stage_file_get_format()
+    sd ptr_index%ptr_output
+#these formats are related to format_max
+    #Audio Video Interleaved
+    char entry1="avi"
+    #Audio Video Interleaved / I420
+    char *="avi"
+    #Audio Video Interleaved / MJPEG
+    char *="avi"
+    #Audio Video Interleaved / MPG4-ASP
+    char *="avi"
+    #Material eXchange Format
+    char *="mxf"
+    #Matroska / I420
+    char *="mkv"
+    #Matroska / MJPEG
+    char *="mkv"
+    #Matroska / MPG4-ASP
+    char *="mkv"
+    #Matroska / RGB24
+    char *="mkv"
+    #Mp4 / MPEG4-AVC
+    char *="mp4"
+
+    sd index
+    set index ptr_index#
+    ss iter^entry1
+    setcall iter get_string_at_index(iter,index)
+    return iter
+endfunction
+#get the name string of the output format for gstreamer options
+function stage_file_get_format_name()
+    ss format
+    setcall format stage_file_get_format()
+    char dest_data#format_max+1
+    data dest^dest_data
+    import "strcpy" strcpy
+    import "slen" slen
+    call strcpy(dest,format)
+    sd len
+    setcall len slen(dest)
+    sd cursor
+    set cursor dest
+    add cursor len
+    ss mux="mux"
+    call strcpy(cursor,mux)
+    return dest
+endfunction
+#get the encoder for mkv,avi files
+function stage_file_get_mkv_encoder()
+    sd ptr_index%ptr_output
+    sd index
+    set index ptr_index#
+    sub index (format_mkv)
+    return index
+endfunction
+function stage_file_get_avi_encoder()
+    sd ptr_index%ptr_output
+    sd index
+    set index ptr_index#
+    sub index (format_avi)
+    return index
+endfunction
+
+
+#init
+function stage_file_options_dialog_init(sd vbox,sd *dialog)
+    call stage_file_options_structure((TRUE),vbox)
+endfunction
+
+import "move_to_home_v" move_to_home_v
+
+#write if ok
+function stage_file_options_dialog_got_file(sd file)
+    data notstart=0
+    call stage_file_options_structure(notstart,file)
+endfunction
+function stage_file_options_dialog_sysenter()
+    import "file_write_forward" file_write_forward
+    ss stagedata
+    setcall stagedata stage_file_options_fname()
+    data f^stage_file_options_dialog_got_file
+    call file_write_forward(stagedata,f)
+endfunction
+function stage_file_options_dialog_continuation()
+	call move_to_home_v()
+	data f^stage_file_options_dialog_sysenter
+	import "sys_folder_enterleave" sys_folder_enterleave
+	call sys_folder_enterleave(f)
+	#redraw the visual sound pulse
+	import "sound_pixbuf_redraw" sound_pixbuf_redraw
+	call sound_pixbuf_redraw()
+endfunction
+
+function file_write_forward_sys_folder_enter_leave(ss filename,sd forward)
+	call move_to_home_v()
+	call forward_in_sys_folder((value_set),filename,forward)
+	data sys_forward^forward_file_sys_folder
+	call sys_folder_enterleave(sys_forward)
+endfunction
+function forward_file_sys_folder()
+    sd values
+    setcall values forward_in_sys_folder((value_get))
+    sd filename
+    sd forward
+    set filename values#
+    add values 4
+    set forward values#
+    call file_write_forward(filename,forward)
+endfunction
+function forward_in_sys_folder(sd action,sd fname,sd frw)
+    data filename#1
+    data forward#1
+    if action=(value_set)
+        set filename fname
+        set forward frw
+    else
+        data set^filename
+        return set
+    endelse
+endfunction
+
+#get container file
+function stage_get_output_container()
+    sd format
+    setcall format stage_file_get_format()
+    import "save_destination" save_destination
+
+    sd output_container
+    setcall output_container save_destination(format)
+
+    return output_container
+endfunction
+
+
+
+
+
+
+
+#clicked
+
+function stage_file_options()
+    str stageoptions="Stage Options"
+    data modal=GTK_DIALOG_MODAL
+    data set^stage_file_options_dialog_init
+    data continuation^stage_file_options_dialog_continuation
+
+    import "dialogfield" dialogfield
+    call dialogfield(stageoptions,modal,set,continuation)
+endfunction
+
+const options_na=0
+const options_jpg=1
+const options_mpg=2
+
+#clicked,void
+function stage_properties_enc(sd *button,sd *data)
+    sd options
+    str sets="Settings"
+
+    setcall options stage_properties_enc_get_options_format()
+
+    import "dialogfield_size" dialogfield_size
+	if options=(options_jpg)
+        call jpeg_dialog()
+        return 1
+	endif
+	if options=(options_mpg)
+        import "mpeg_settings_init" mpeg_settings_init
+        import "mpeg_settings_set" mpeg_settings_set
+        data mpeg_i_f^mpeg_settings_init
+        data mpeg_s_f^mpeg_settings_set
+        call dialogfield_size(sets,(GTK_DIALOG_MODAL),mpeg_i_f,mpeg_s_f,300,-1)
+        return 1
+	endif
+
+    import "message_dialog" message_dialog
+    str no="The encoder doesn't have specific options"
+    call message_dialog(no)
+endfunction
+
+import "cmpmem" cmpmem
+
+function stage_properties_enc_get_options_format()
+    sd encoder
+    sd cmp
+    sd format
+    setcall format stage_file_get_format()
+    str mk="mkv"
+    setcall cmp cmpmem(format,mk,3)
+    if cmp=(equalCompare)
+        setcall encoder stage_file_get_mkv_encoder()
+	if encoder=(format_mkv_mjpg)
+            return (options_jpg)
+	endif
+	if encoder=(format_mkv_xvid)
+            return (options_mpg)
+	endif
+    endif
+    str avi="avi"
+    setcall cmp cmpmem(format,avi,3)
+    if cmp=(equalCompare)
+        setcall encoder stage_file_get_avi_encoder()
+	if encoder=(format_avi_mjpg)
+            return (options_jpg)
+	endif
+	if encoder=(format_avi_xvid)
+            return (options_mpg)
+	endif
+    endif
+    str mp4="mp4"
+    setcall cmp cmpmem(format,mp4,3)
+    if cmp=(equalCompare)
+        return (options_mpg)
+    endif
+    return (options_na)
+endfunction
+
+function write_sound_options(sd file,sd p_channels,sd p_rate,sd p_bps)
+    sd err
+    setcall err file_write(p_channels,4,file)
+    if err!=(noerror)
+        return err
+    endif
+    setcall err file_write(p_rate,4,file)
+    if err!=(noerror)
+        return err
+    endif
+    setcall err file_write(p_bps,4,file)
+    if err!=(noerror)
+        return err
+    endif
+endfunction
--- ovideo-1.orig/src/_prepare/output/stagefileoptions.s
+++ /dev/null
@@ -1,605 +0,0 @@
-
-
-
-format elfobj
-
-include "../../_include/include.h"
-
-function stage_file_options_got_file(sd mem,sd *size)
-    #values and initial default set
-    data fps#1
-    data ptr_fps^fps
-    const ptr_fps^fps
-    set fps 2
-
-    data output#1
-    data ptr_output^output
-    const ptr_output^output
-    set output 0
-
-    #set from the option file
-    sd err
-    data noerr=noerror
-    import "get_mem_int_advance" get_mem_int_advance
-    sd mem_sz^mem
-
-    setcall err get_mem_int_advance(ptr_fps,mem_sz)
-    if err!=noerr
-        return err
-    endif
-
-    import "av_good_fps" av_good_fps
-    call av_good_fps(ptr_fps)
-
-    setcall err get_mem_int_advance(ptr_output,mem_sz)
-    if err!=noerr
-        return err
-    endif
-
-    sd value
-    sd p_value^value
-    setcall err get_mem_int_advance(p_value,mem_sz)
-    if err!=noerr
-        return err
-    endif
-    call stage_file_options_info_message((value_set),value)
-endfunction
-
-function stage_file_options_fname()
-    str stagedata="stage.data"
-    return stagedata
-endfunction
-
-function stage_file_options_init()
-    #stage data
-    ss stagedata
-    setcall stagedata stage_file_options_fname()
-
-    import "file_get_content_forward" file_get_content_forward
-    data f^stage_file_options_got_file
-    call file_get_content_forward(stagedata,f)
-
-    #jpeg specific
-    import "jpeg_get_quality" jpeg_get_quality
-    data j_f^jpeg_get_quality
-    ss jpeg_data
-    setcall jpeg_data jpeg_file()
-    call file_get_content_forward(jpeg_data,j_f)
-
-    #mpeg specific
-    import "mpeg_options" mpeg_options
-    data mpeg_f^mpeg_options
-    sd mpeg_data
-    setcall mpeg_data mpeg_file()
-    call file_get_content_forward(mpeg_data,mpeg_f)
-
-    #sound data
-    import "sound_get_values" sound_get_values
-    data s_f^sound_get_values
-    sd sdata
-    setcall sdata sound_file()
-    call file_get_content_forward(sdata,s_f)
-
-    #capture data
-    import "capture_get_data" capture_get_data
-    data c_f^capture_get_data
-    sd cdata
-    setcall cdata capture_file()
-    call file_get_content_forward(cdata,c_f)
-endfunction
-function jpeg_file()
-    str jpeg_data="jpeg.data"
-    return jpeg_data
-endfunction
-function mpeg_file()
-    str mpeg_data="mpeg.data"
-    return mpeg_data
-endfunction
-function sound_file()
-    str sdata="sound.data"
-    return sdata
-endfunction
-function capture_file()
-    str cdata="capture.data"
-    return cdata
-endfunction
-
-function stage_file_options_fps_pointer()
-    data ptr_fps%ptr_fps
-    return ptr_fps
-endfunction
-function stage_file_options_fps()
-    sd p_fps
-    setcall p_fps stage_file_options_fps_pointer()
-    return p_fps#
-endfunction
-
-function stage_file_options_output_pointer()
-    data ptr_output%ptr_output
-    return ptr_output
-endfunction
-function stage_file_options_output()
-    data ptr_output#1
-    setcall ptr_output stage_file_options_output_pointer()
-    return ptr_output#
-endfunction
-function stage_file_options_info_message(sd action,sd value)
-    data flag#1
-    if action==(value_set)
-        set flag value
-    else
-        return flag
-    endelse
-endfunction
-
-import "jpeg_dialog" jpeg_dialog
-import "update_set" update_set
-import "update_mem" update_mem
-#case start:arg1 is vbox
-#case notstart:arg1 fileout
-function stage_file_options_structure(sd start,sd arg1)
-    data true=1
-    data rows=4
-    data cols=2
-
-    #also it is required to look at values above and at strings below
-    #and at constants (format_avi, format_mkv, ...)
-
-    data fps_label#1
-    data fps_edit#1
-    data outformat_label#1
-    data outformat_list#1
-    data *space=0
-    data options#1
-    data img_jpeg#1
-    data *space=0
-    data v_cells^fps_label
-
-    data ch_txt#1
-    data ch_opt#1
-    data rate_txt#1
-    data rate_opt#1
-    data bps_txt#1
-    data bps_opt#1
-    data a_cells^ch_txt
-
-    data results_toggle#1
-    data update_toggle#1
-
-    import "stage_sound_channels" stage_sound_channels
-    import "stage_sound_rate" stage_sound_rate
-    import "stage_sound_bps" stage_sound_bps
-    sd channels
-    sd rate
-    sd bps
-    sd p_channels^channels
-    sd p_rate^rate
-    sd p_bps^bps
-
-    sd ptr_out
-    setcall ptr_out stage_file_options_output_pointer()
-    if start==true
-        sd vbox
-        set vbox arg1
-        importx "_gtk_frame_new" gtk_frame_new
-        import "packstart" packstart
-        import "tablefield_cells" tablefield_cells
-#video
-        str video="Video"
-        sd v_frame
-        setcall v_frame gtk_frame_new(video)
-        call packstart(vbox,v_frame,(TRUE))
-
-        #fps
-        importx "_gtk_label_new" gtk_label_new
-        str fps_label_text="Frames-per-second"
-        setcall fps_label gtk_label_new(fps_label_text)
-        import "editfield_with_int" editfield_with_int
-        sd fps
-        setcall fps stage_file_options_fps()
-        setcall fps_edit editfield_with_int(fps)
-
-        #output format
-        str outformat_label_text="Output format"
-        setcall outformat_label gtk_label_new(outformat_label_text)
-        importx "_gtk_combo_box_text_new" gtk_combo_box_text_new
-        setcall outformat_list gtk_combo_box_text_new()
-
-        #connect changed signal for storing the index
-        import "connect_signal_data" connect_signal_data
-        str change="changed"
-        data ch_fn^stage_oformat_changed
-        call connect_signal_data(outformat_list,change,ch_fn,ptr_out)
-
-        importx "_gtk_combo_box_text_append_text" gtk_combo_box_text_append_text
-
-        str entry1="AVI yuv"
-        call gtk_combo_box_text_append_text(outformat_list,entry1)
-        str entry1_i420="AVI/I420\\PCM"
-        call gtk_combo_box_text_append_text(outformat_list,entry1_i420)
-        str entry1_jpg="AVI/MJPEG\\PCM"
-        call gtk_combo_box_text_append_text(outformat_list,entry1_jpg)
-        str entry1_xvid="AVI/MPG4-ASP\\PCM"
-        call gtk_combo_box_text_append_text(outformat_list,entry1_xvid)
-
-        str entry2="MXF"
-        call gtk_combo_box_text_append_text(outformat_list,entry2)
-
-        str entry3_1="MKV/I420\\PCM"
-        call gtk_combo_box_text_append_text(outformat_list,entry3_1)
-        str entry3_2="MKV/MJEPG\\PCM"
-        call gtk_combo_box_text_append_text(outformat_list,entry3_2)
-        str entry3_3="MKV/MPG4-ASP\\PCM"
-        call gtk_combo_box_text_append_text(outformat_list,entry3_3)
-        str entry3_4="MKV/RGB24\\PCM"
-        call gtk_combo_box_text_append_text(outformat_list,entry3_4)
-
-        str entry4_1="MP4/MPG4-AVC\\MP3"
-        call gtk_combo_box_text_append_text(outformat_list,entry4_1)
-
-        importx "_gtk_combo_box_set_active" gtk_combo_box_set_active
-        call gtk_combo_box_set_active(outformat_list,ptr_out#)
-
-        #configurations
-        import "buttonfield_prepare_with_label" buttonfield_prepare_with_label
-        str conf="Format configure"
-        setcall options buttonfield_prepare_with_label(conf)
-        import "connect_clicked" connect_clicked
-        data f^stage_properties_enc
-        call connect_clicked(options,f)
-
-        #image
-        ss jpg="Image - JPEG"
-        setcall img_jpeg buttonfield_prepare_with_label(jpg)
-        data f_jpg_img^jpeg_dialog
-        call connect_clicked(img_jpeg,f_jpg_img)
-
-        call tablefield_cells(v_frame,rows,cols,v_cells)
-#audio
-        str audio="Audio"
-        sd a_frame
-        setcall a_frame gtk_frame_new(audio)
-        call packstart(vbox,a_frame,(TRUE))
-
-        str ch_info="Channels"
-        setcall ch_txt gtk_label_new(ch_info)
-        setcall channels stage_sound_channels((value_get))
-        setcall ch_opt editfield_with_int(channels)
-        #
-        str rate_info="Samples-per-sec"
-        setcall rate_txt gtk_label_new(rate_info)
-        setcall rate stage_sound_rate((value_get))
-        setcall rate_opt editfield_with_int(rate)
-        #
-        str bps_info="Bits-per-sample"
-        setcall bps_txt gtk_label_new(bps_info)
-        setcall bps stage_sound_bps((value_get))
-        setcall bps_opt editfield_with_int(bps)
-        #
-        call tablefield_cells(a_frame,3,2,a_cells)
-#
-        importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
-        importx "_gtk_toggle_button_set_active" gtk_toggle_button_set_active
-        import "packstart_default" packstart_default
-        #results message
-        ss txt="Show results message(if available)"
-        setcall results_toggle gtk_check_button_new_with_label(txt)
-        sd toggle
-        setcall toggle stage_file_options_info_message((value_get))
-        if toggle!=0
-            call gtk_toggle_button_set_active(results_toggle,1)
-        endif
-        call packstart_default(vbox,results_toggle)
-        #updates
-        ss up_txt="Check for updates"
-        setcall update_toggle gtk_check_button_new_with_label(up_txt)
-        sd update
-        setcall update update_mem()
-        if update#==(TRUE)
-            call gtk_toggle_button_set_active(update_toggle,1)
-        endif
-        call packstart_default(vbox,update_toggle)
-    else
-        import "file_write" file_write
-        importx "_gtk_entry_get_text" gtk_entry_get_text
-#
-        ss currentframestext
-        setcall currentframestext gtk_entry_get_text(fps_edit)
-
-        sd err
-        data noerr=noerror
-
-        import "strtoint" strtoint
-        sd fpspointer%ptr_fps
-        call strtoint(currentframestext,fpspointer)
-        call av_good_fps(fpspointer)
-        setcall err file_write(fpspointer,4,arg1)
-        if err!=noerr
-            return err
-        endif
-
-        setcall err file_write(ptr_out,4,arg1)
-        if err!=noerr
-            return err
-        endif
-#
-        ss file_sound
-        setcall file_sound sound_file()
-        sd audio_file
-        sd p_audio_file^audio_file
-        str s_fmode="wb"
-        import "openfile" openfile
-        setcall err openfile(p_audio_file,file_sound,s_fmode)
-        if err!=noerr
-            return err
-        endif
-        import "entry_to_nr_minValue" entry_to_nr_minValue
-
-        call entry_to_nr_minValue(ch_opt,p_channels,1)
-        call entry_to_nr_minValue(rate_opt,p_rate,1)
-        call entry_to_nr_minValue(bps_opt,p_bps,8)
-
-        call stage_sound_channels((value_set),channels)
-        call stage_sound_rate((value_set),rate)
-        call stage_sound_bps((value_set),bps)
-
-        call write_sound_options(audio_file,p_channels,p_rate,p_bps)
-
-        importx "_fclose" fclose
-        call fclose(audio_file)
-#
-        importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
-        #
-        sd toggle_flag
-        sd p_toggle_flag^toggle_flag
-        setcall toggle_flag gtk_toggle_button_get_active(results_toggle)
-        call stage_file_options_info_message((value_set),toggle_flag)
-        setcall err file_write(p_toggle_flag,4,arg1)
-        if err!=noerr
-            return err
-        endif
-        #
-        sd up_flag
-        setcall up_flag gtk_toggle_button_get_active(update_toggle)
-        call update_set(up_flag)
-        #
-    endelse
-endfunction
-function stage_oformat_changed(sd combo,sd p_loc)
-    importx "_gtk_combo_box_get_active" gtk_combo_box_get_active
-    setcall p_loc# gtk_combo_box_get_active(combo)
-endfunction
-
-import "get_string_at_index" get_string_at_index
-#type/extension
-function stage_file_get_format()
-    sd ptr_index%ptr_output
-#these formats are related to format_max
-    #Audio Video Interleaved
-    char entry1="avi"
-    #Audio Video Interleaved / I420
-    char *="avi"
-    #Audio Video Interleaved / MJPEG
-    char *="avi"
-    #Audio Video Interleaved / MPG4-ASP
-    char *="avi"
-    #Material eXchange Format
-    char *="mxf"
-    #Matroska / I420
-    char *="mkv"
-    #Matroska / MJPEG
-    char *="mkv"
-    #Matroska / MPG4-ASP
-    char *="mkv"
-    #Matroska / RGB24
-    char *="mkv"
-    #Mp4 / MPEG4-AVC
-    char *="mp4"
-
-    sd index
-    set index ptr_index#
-    ss iter^entry1
-    setcall iter get_string_at_index(iter,index)
-    return iter
-endfunction
-#get the name string of the output format for gstreamer options
-function stage_file_get_format_name()
-    ss format
-    setcall format stage_file_get_format()
-    char dest_data#format_max+1
-    data dest^dest_data
-    import "strcpy" strcpy
-    import "slen" slen
-    call strcpy(dest,format)
-    sd len
-    setcall len slen(dest)
-    sd cursor
-    set cursor dest
-    add cursor len
-    ss mux="mux"
-    call strcpy(cursor,mux)
-    return dest
-endfunction
-#get the encoder for mkv,avi files
-function stage_file_get_mkv_encoder()
-    sd ptr_index%ptr_output
-    sd index
-    set index ptr_index#
-    sub index (format_mkv)
-    return index
-endfunction
-function stage_file_get_avi_encoder()
-    sd ptr_index%ptr_output
-    sd index
-    set index ptr_index#
-    sub index (format_avi)
-    return index
-endfunction
-
-
-#init
-function stage_file_options_dialog_init(sd vbox,sd *dialog)
-    call stage_file_options_structure((TRUE),vbox)
-endfunction
-
-import "move_to_home_v" move_to_home_v
-
-#write if ok
-function stage_file_options_dialog_got_file(sd file)
-    data notstart=0
-    call stage_file_options_structure(notstart,file)
-endfunction
-function stage_file_options_dialog_sysenter()
-    import "file_write_forward" file_write_forward
-    ss stagedata
-    setcall stagedata stage_file_options_fname()
-    data f^stage_file_options_dialog_got_file
-    call file_write_forward(stagedata,f)
-endfunction
-function stage_file_options_dialog_continuation()
-	call move_to_home_v()
-	data f^stage_file_options_dialog_sysenter
-	import "sys_folder_enterleave" sys_folder_enterleave
-	call sys_folder_enterleave(f)
-	#redraw the visual sound pulse
-	import "sound_pixbuf_redraw" sound_pixbuf_redraw
-	call sound_pixbuf_redraw()
-endfunction
-
-function file_write_forward_sys_folder_enter_leave(ss filename,sd forward)
-	call move_to_home_v()
-	call forward_in_sys_folder((value_set),filename,forward)
-	data sys_forward^forward_file_sys_folder
-	call sys_folder_enterleave(sys_forward)
-endfunction
-function forward_file_sys_folder()
-    sd values
-    setcall values forward_in_sys_folder((value_get))
-    sd filename
-    sd forward
-    set filename values#
-    add values 4
-    set forward values#
-    call file_write_forward(filename,forward)
-endfunction
-function forward_in_sys_folder(sd action,sd fname,sd frw)
-    data filename#1
-    data forward#1
-    if action==(value_set)
-        set filename fname
-        set forward frw
-    else
-        data set^filename
-        return set
-    endelse
-endfunction
-
-#get container file
-function stage_get_output_container()
-    sd format
-    setcall format stage_file_get_format()
-    import "save_destination" save_destination
-
-    sd output_container
-    setcall output_container save_destination(format)
-
-    return output_container
-endfunction
-
-
-
-
-
-
-
-#clicked
-
-function stage_file_options()
-    str stageoptions="Stage Options"
-    data modal=GTK_DIALOG_MODAL
-    data set^stage_file_options_dialog_init
-    data continuation^stage_file_options_dialog_continuation
-
-    import "dialogfield" dialogfield
-    call dialogfield(stageoptions,modal,set,continuation)
-endfunction
-
-const options_na=0
-const options_jpg=1
-const options_mpg=2
-
-#clicked,void
-function stage_properties_enc(sd *button,sd *data)
-    sd options
-    str sets="Settings"
-
-    setcall options stage_properties_enc_get_options_format()
-
-    import "dialogfield_size" dialogfield_size
-    if options==(options_jpg)
-        call jpeg_dialog()
-        return 1
-    elseif options==(options_mpg)
-        import "mpeg_settings_init" mpeg_settings_init
-        import "mpeg_settings_set" mpeg_settings_set
-        data mpeg_i_f^mpeg_settings_init
-        data mpeg_s_f^mpeg_settings_set
-        call dialogfield_size(sets,(GTK_DIALOG_MODAL),mpeg_i_f,mpeg_s_f,300,-1)
-        return 1
-    endelseif
-
-    import "message_dialog" message_dialog
-    str no="The encoder doesn't have specific options"
-    call message_dialog(no)
-endfunction
-
-import "cmpmem" cmpmem
-
-function stage_properties_enc_get_options_format()
-    sd encoder
-    sd cmp
-    sd format
-    setcall format stage_file_get_format()
-    str mk="mkv"
-    setcall cmp cmpmem(format,mk,3)
-    if cmp==(equalCompare)
-        setcall encoder stage_file_get_mkv_encoder()
-        if encoder==(format_mkv_mjpg)
-            return (options_jpg)
-        elseif encoder==(format_mkv_xvid)
-            return (options_mpg)
-        endelseif
-    endif
-    str avi="avi"
-    setcall cmp cmpmem(format,avi,3)
-    if cmp==(equalCompare)
-        setcall encoder stage_file_get_avi_encoder()
-        if encoder==(format_avi_mjpg)
-            return (options_jpg)
-        elseif encoder==(format_avi_xvid)
-            return (options_mpg)
-        endelseif
-    endif
-    str mp4="mp4"
-    setcall cmp cmpmem(format,mp4,3)
-    if cmp==(equalCompare)
-        return (options_mpg)
-    endif
-    return (options_na)
-endfunction
-
-function write_sound_options(sd file,sd p_channels,sd p_rate,sd p_bps)
-    sd err
-    setcall err file_write(p_channels,4,file)
-    if err!=(noerror)
-        return err
-    endif
-    setcall err file_write(p_rate,4,file)
-    if err!=(noerror)
-        return err
-    endif
-    setcall err file_write(p_bps,4,file)
-    if err!=(noerror)
-        return err
-    endif
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/paint.oc
@@ -0,0 +1,37 @@
+
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+function stage_redraw()
+    import "drawwidget" drawwidget
+    sd draw
+    setcall draw drawwidget()
+    import "widget_redraw" widget_redraw
+    call widget_redraw(draw)
+endfunction
+
+#TRUE to stop other handlers from being invoked for the event. FALSE to propagate the event further.
+function stage_paint_event(sd widget,sd *event,sd *data)
+    import "get_playbool" get_playbool
+    sd bool
+    setcall bool get_playbool()
+    #on gst play don't combine with stage
+    if bool=(TRUE)
+        return (FALSE)
+    endif
+
+    import "stage_get_sel_pixbuf_nowarning" stage_get_sel_pixbuf_nowarning
+    sd px
+    sd p_px^px
+    sd err
+    setcall err stage_get_sel_pixbuf_nowarning(p_px)
+    if err=(noerror)
+        import "widget_draw_pixbuf" widget_draw_pixbuf
+        call widget_draw_pixbuf(widget,px)
+    endif
+    return (FALSE)
+endfunction
--- ovideo-1.orig/src/_prepare/paint.s
+++ /dev/null
@@ -1,37 +0,0 @@
-
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-function stage_redraw()
-    import "drawwidget" drawwidget
-    sd draw
-    setcall draw drawwidget()
-    import "widget_redraw" widget_redraw
-    call widget_redraw(draw)
-endfunction
-
-#TRUE to stop other handlers from being invoked for the event. FALSE to propagate the event further.
-function stage_paint_event(sd widget,sd *event,sd *data)
-    import "get_playbool" get_playbool
-    sd bool
-    setcall bool get_playbool()
-    #on gst play don't combine with stage
-    if bool==(TRUE)
-        return (FALSE)
-    endif
-
-    import "stage_get_sel_pixbuf_nowarning" stage_get_sel_pixbuf_nowarning
-    sd px
-    sd p_px^px
-    sd err
-    setcall err stage_get_sel_pixbuf_nowarning(p_px)
-    if err==(noerror)
-        import "widget_draw_pixbuf" widget_draw_pixbuf
-        call widget_draw_pixbuf(widget,px)
-    endif
-    return (FALSE)
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/pipe.oc
@@ -0,0 +1,361 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+importx "_sprintf" sprintf
+
+import "stage_get_frames_container" stage_get_frames_container
+
+#get the number of frames
+function stage_get_frames()
+    #write the number of frames
+    sd box
+    setcall box stage_get_frames_container()
+
+    import "widget_get_children_number" widget_get_children_number
+    sd elements
+    setcall elements widget_get_children_number(box)
+    return elements
+endfunction
+
+#display the index of frames and the string
+function stage_display_index(ss string,sd add)
+    sd elements
+    setcall elements stage_get_frames()
+
+    dec elements
+    add elements add
+
+    import "strdworddisp" strdworddisp
+
+    call strdworddisp(string,elements)
+endfunction
+
+import "texter" texter
+
+#frame position in stage
+function stage_frame_index(sd frame)
+    import "widget_position_in_container" widget_position_in_container
+    sd box
+    setcall box stage_get_frames_container()
+    sd pos
+    setcall pos widget_position_in_container(frame,box)
+    return pos
+endfunction
+
+#frame clicked function
+function stage_frame_clicked(sd widget,sd event,sd *data)
+    #info
+    call stage_display_pixbuf(widget)
+    #select
+    import "stage_frame_unit_select" stage_frame_unit_select
+    call stage_frame_unit_select(widget,event)
+    #link to mass remove
+    import "link_mass_remove" link_mass_remove
+    call link_mass_remove((value_write))
+endfunction
+
+import "stage_frame_time_numbers" stage_frame_time_numbers
+
+function stage_display_info(sd widget)
+    #display the frame position and time informations
+    str format="Frame: %u/%u; Time: %u:%02u from %u:%02u; Position: %u from %u"
+    char data#200
+    str string^data
+    sd length_at_index
+    sd length_total
+
+    sd position
+    setcall position stage_frame_index(widget)
+    #
+    sd position_total
+    setcall position_total stage_get_frames()
+    dec position_total
+    #
+    import "stage_file_options_fps" stage_file_options_fps
+    import "rest" rest
+    sd fps
+    setcall fps stage_file_options_fps()
+
+    sd seconds_pos
+    setcall length_at_index stage_frame_time_numbers((stage_frame_time_sum_at_index),position)
+    set seconds_pos length_at_index
+    div seconds_pos fps
+    sd minutes_pos
+    set minutes_pos seconds_pos
+    setcall seconds_pos rest(seconds_pos,60)
+    div minutes_pos 60
+    #
+    sd seconds_total
+    setcall length_total stage_frame_time_numbers((stage_frame_time_total_sum))
+    set seconds_total length_total
+    import "multiple_of_nr" multiple_of_nr
+    setcall seconds_total multiple_of_nr(seconds_total,fps)
+    div seconds_total fps
+    sd minutes_total
+    set minutes_total seconds_total
+    setcall seconds_total rest(seconds_total,60)
+    div minutes_total 60
+    #
+    call sprintf(string,format,position,position_total,minutes_pos,seconds_pos,minutes_total,seconds_total,length_at_index,length_total)
+    call texter(string)
+endfunction
+
+function stage_display_pixbuf(sd widget)
+    #info
+    call stage_display_info(widget)
+
+    #select the frame
+    import "stage_sel_reparent" stage_sel_reparent
+    call stage_sel_reparent(widget)
+
+    #draw the selection
+    import "stage_redraw" stage_redraw
+    call stage_redraw()
+endfunction
+
+function img_folder()
+const img_folder_start=\
+	char img="img"
+const img_folder_size=\-img_folder_start-1
+	return #img
+endfunction
+function edit_folder()
+const edit_folder_start=\
+	char edit="edit"
+const edit_folder_size=\-edit_folder_start-1
+	return #edit
+endfunction
+function unselectedframe()
+const unselected_bmp_start=\
+    vstr frame="frame.bmp"
+const unselected_bmp_size=\-unselected_bmp_start-1
+    ss file
+    setcall file stage_get_image(frame)
+    return file
+endfunction
+function selectedframe()
+    vstr frame="sel.bmp"
+    ss file
+    setcall file stage_get_image(frame)
+    return file
+endfunction
+
+import "move_to_share_core" move_to_share_core
+#name of the img/edit+(image)
+function stage_get_image(ss image)
+	ss i
+	ss e
+	setcall i img_folder()
+	setcall e edit_folder()
+	char bytes#img_folder_size+1+edit_folder_size+1+unselected_bmp_size+1
+	ss file^bytes
+	str form="%s/%s/%s"
+	call sprintf(file,form,i,e,image)
+	call move_to_share_core(#file)
+	return file
+endfunction
+
+#eventbox
+function stage_new_click_area()
+    #get frames container
+    sd box
+    setcall box stage_get_frames_container()
+    #eventbox
+    import "eventboxfield" eventboxfield
+    sd eventbox
+    setcall eventbox eventboxfield(box)
+    return eventbox
+endfunction
+
+import "connect_signal" connect_signal
+
+#add a pixbuf to eventbox
+function stage_pixbuf_to_container(sd pixbuf,sd eventbox)
+    #set the name of the image to the pixbuf handle for remember at select,scale,free...(more actions can be)
+    import "object_set_dword_name" object_set_dword_name
+    call object_set_dword_name(eventbox,pixbuf)
+
+    #add one more frame,selection(blue) or normal(white)
+    import "stage_sel_img_listen" stage_sel_img_listen
+    sd img
+    setcall img stage_sel_img_listen(eventbox)
+    data null=0
+    if img!=null
+        call stage_redraw()
+    else
+        import "stage_unselected_frame" stage_unselected_frame
+        setcall img stage_unselected_frame(eventbox)
+    endelse
+
+    #add mouse detection to display pixbuf when clicked
+    str pressed="button-press-event"
+    data f^stage_frame_clicked
+    call connect_signal(eventbox,pressed,f)
+    importx "_gtk_widget_add_events" gtk_widget_add_events
+    sd events=GDK_BUTTON_PRESS_MASK
+    call gtk_widget_add_events(eventbox,events)
+
+    #display the widget
+    importx "_gtk_widget_show_all" gtk_widget_show_all
+    call gtk_widget_show_all(eventbox)
+endfunction
+
+#add a new frame to the stage
+#err
+function stage_new_frame_with_timelength(sd pixbuf,sd length)
+    #add the frame length at the end
+    call stage_frame_time_numbers((stage_frame_time_append),length)
+
+    #add eventbox for mouse detection
+    sd eventbox
+    setcall eventbox stage_new_click_area()
+
+    #pixbuf to eventbox
+    call stage_pixbuf_to_container(pixbuf,eventbox)
+endfunction
+#add a frame,length=1
+function stage_new_pix(sd pixbuf,ss text_ok)
+    call stage_new_frame_with_timelength(pixbuf,1)
+
+    #show the message and the received number of frames
+    data one=1
+    call stage_display_index(text_ok,one)
+endfunction
+import "default_unref_ptr" default_unref_ptr
+#incoming frame arrange
+function stage_element(sd *bus,sd message,sd ptrpipeline)
+    #get the pixbuf for future usage
+    import "msgelement_pixbuf" msgelement_pixbuf
+    sd pixbuf
+    setcall pixbuf msgelement_pixbuf(message)
+    #can be an error
+    if pixbuf!=0
+        sd skip=0
+        #verify with the limits
+        import "stage_prepare_uri_pos" stage_prepare_uri_pos
+        import "stage_prepare_uri_first" stage_prepare_uri_first
+        import "stage_prepare_uri_last" stage_prepare_uri_last
+        sd pos
+        setcall pos stage_prepare_uri_pos()
+        sd first
+        sd last
+        setcall first stage_prepare_uri_first()
+        setcall last stage_prepare_uri_last()
+        #
+        if first#!=-1
+            if pos#<first#
+                set skip 1
+            endif
+        endif
+        #
+        if last#!=-1
+            if pos#>last#
+                set skip 2
+                call default_unref_ptr(ptrpipeline)
+            endif
+        endif
+        #
+		if skip=0
+			import "rgb_test" rgb_test
+			setcall pixbuf rgb_test(pixbuf)
+			if pixbuf!=(NULL)
+				vstr text="Received frames: "
+				call stage_new_pix(pixbuf,text)
+			else
+				set skip 1
+			endelse
+		endif
+		if skip!=0
+			importx "_g_object_unref" g_object_unref
+			call g_object_unref(pixbuf)
+			if skip=1
+				call strdworddisp("Skipped frame: ",pos#)
+			else
+				call stage_display_index("Total frames: ",1)
+			endelse
+		endif
+		#
+		inc pos#
+	endif
+endfunction
+
+
+function stage_eos(sd *bus,sd *message,sd ptrpipeline)
+    #display the total number of frames
+    str text="Total frames at end of stream: "
+    data one=1
+    call stage_display_index(text,one)
+    call default_unref_ptr(ptrpipeline)
+endfunction
+
+function stage_connect_signals(sd bus,sd ptrpipe)
+    import "connect_signal_data" connect_signal_data
+    #element
+    str px="message::element"
+    data fn^stage_element
+    call connect_signal_data(bus,px,fn,ptrpipe)
+
+    #error
+    import "default_error_ptr" default_error_ptr
+    data er^default_error_ptr
+    str error="message::error"
+    call connect_signal_data(bus,error,er,ptrpipe)
+
+    #eos
+    data eos^stage_eos
+    str eosmsg="message::eos"
+    call connect_signal_data(bus,eosmsg,eos,ptrpipe)
+endfunction
+
+function stage_start_pipe(ss uri)
+#gdkpixbufsink plugins-good
+    ss launcher="uridecodebin uri=\"%s\" ! ffmpegcolorspace ! gdkpixbufsink"
+    ss str
+    sd *=0
+    sd strs^launcher
+
+    set str uri
+
+    sd err
+
+    sd mem
+    sd ptr_mem^mem
+
+    import "allocsum_null" allocsum_null
+    setcall err allocsum_null(strs,ptr_mem)
+    if err!=(noerror)
+        return err
+    endif
+
+    call sprintf(mem,launcher,uri)
+
+    import "launch_pipe_start" launch_pipe_start
+    data pipe#1
+    sd ptrpipe^pipe
+    const stage_pipeline^pipe
+
+    setcall pipe launch_pipe_start(mem)
+
+    importx "_free" free
+    call free(mem)
+    if pipe=0
+        return (void)
+    endif
+
+    import "bus_signals_data" bus_signals_data
+    data fn^stage_connect_signals
+    call bus_signals_data(pipe,fn,ptrpipe)
+endfunction
+
+function stage_get_pipeline()
+    data s%stage_pipeline
+    return s#
+endfunction
+function stage_set_pipeline(sd value)
+    data s%stage_pipeline
+    set s# value
+endfunction
--- ovideo-1.orig/src/_prepare/pipe.s
+++ /dev/null
@@ -1,361 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-importx "_sprintf" sprintf
-
-import "stage_get_frames_container" stage_get_frames_container
-
-#get the number of frames
-function stage_get_frames()
-    #write the number of frames
-    sd box
-    setcall box stage_get_frames_container()
-
-    import "widget_get_children_number" widget_get_children_number
-    sd elements
-    setcall elements widget_get_children_number(box)
-    return elements
-endfunction
-
-#display the index of frames and the string
-function stage_display_index(ss string,sd add)
-    sd elements
-    setcall elements stage_get_frames()
-
-    dec elements
-    add elements add
-
-    import "strdworddisp" strdworddisp
-
-    call strdworddisp(string,elements)
-endfunction
-
-import "texter" texter
-
-#frame position in stage
-function stage_frame_index(sd frame)
-    import "widget_position_in_container" widget_position_in_container
-    sd box
-    setcall box stage_get_frames_container()
-    sd pos
-    setcall pos widget_position_in_container(frame,box)
-    return pos
-endfunction
-
-#frame clicked function
-function stage_frame_clicked(sd widget,sd event,sd *data)
-    #info
-    call stage_display_pixbuf(widget)
-    #select
-    import "stage_frame_unit_select" stage_frame_unit_select
-    call stage_frame_unit_select(widget,event)
-    #link to mass remove
-    import "link_mass_remove" link_mass_remove
-    call link_mass_remove((value_write))
-endfunction
-
-import "stage_frame_time_numbers" stage_frame_time_numbers
-
-function stage_display_info(sd widget)
-    #display the frame position and time informations
-    str format="Frame: %u/%u; Time: %u:%02u from %u:%02u; Position: %u from %u"
-    char data#200
-    str string^data
-    sd length_at_index
-    sd length_total
-
-    sd position
-    setcall position stage_frame_index(widget)
-    #
-    sd position_total
-    setcall position_total stage_get_frames()
-    dec position_total
-    #
-    import "stage_file_options_fps" stage_file_options_fps
-    import "rest" rest
-    sd fps
-    setcall fps stage_file_options_fps()
-
-    sd seconds_pos
-    setcall length_at_index stage_frame_time_numbers((stage_frame_time_sum_at_index),position)
-    set seconds_pos length_at_index
-    div seconds_pos fps
-    sd minutes_pos
-    set minutes_pos seconds_pos
-    setcall seconds_pos rest(seconds_pos,60)
-    div minutes_pos 60
-    #
-    sd seconds_total
-    setcall length_total stage_frame_time_numbers((stage_frame_time_total_sum))
-    set seconds_total length_total
-    import "multiple_of_nr" multiple_of_nr
-    setcall seconds_total multiple_of_nr(seconds_total,fps)
-    div seconds_total fps
-    sd minutes_total
-    set minutes_total seconds_total
-    setcall seconds_total rest(seconds_total,60)
-    div minutes_total 60
-    #
-    call sprintf(string,format,position,position_total,minutes_pos,seconds_pos,minutes_total,seconds_total,length_at_index,length_total)
-    call texter(string)
-endfunction
-
-function stage_display_pixbuf(sd widget)
-    #info
-    call stage_display_info(widget)
-
-    #select the frame
-    import "stage_sel_reparent" stage_sel_reparent
-    call stage_sel_reparent(widget)
-
-    #draw the selection
-    import "stage_redraw" stage_redraw
-    call stage_redraw()
-endfunction
-
-function img_folder()
-const img_folder_start=!
-	char img="img"
-const img_folder_size=!-img_folder_start-1
-	return #img
-endfunction
-function edit_folder()
-const edit_folder_start=!
-	char edit="edit"
-const edit_folder_size=!-edit_folder_start-1
-	return #edit
-endfunction
-function unselectedframe()
-const unselected_bmp_start=!
-    vstr frame="frame.bmp"
-const unselected_bmp_size=!-unselected_bmp_start-1
-    ss file
-    setcall file stage_get_image(frame)
-    return file
-endfunction
-function selectedframe()
-    vstr frame="sel.bmp"
-    ss file
-    setcall file stage_get_image(frame)
-    return file
-endfunction
-
-import "move_to_share_core" move_to_share_core
-#name of the img/edit+(image)
-function stage_get_image(ss image)
-	ss i
-	ss e
-	setcall i img_folder()
-	setcall e edit_folder()
-	char bytes#img_folder_size+1+edit_folder_size+1+unselected_bmp_size+1
-	ss file^bytes
-	str form="%s/%s/%s"
-	call sprintf(file,form,i,e,image)
-	call move_to_share_core(#file)
-	return file
-endfunction
-
-#eventbox
-function stage_new_click_area()
-    #get frames container
-    sd box
-    setcall box stage_get_frames_container()
-    #eventbox
-    import "eventboxfield" eventboxfield
-    sd eventbox
-    setcall eventbox eventboxfield(box)
-    return eventbox
-endfunction
-
-import "connect_signal" connect_signal
-
-#add a pixbuf to eventbox
-function stage_pixbuf_to_container(sd pixbuf,sd eventbox)
-    #set the name of the image to the pixbuf handle for remember at select,scale,free...(more actions can be)
-    import "object_set_dword_name" object_set_dword_name
-    call object_set_dword_name(eventbox,pixbuf)
-
-    #add one more frame,selection(blue) or normal(white)
-    import "stage_sel_img_listen" stage_sel_img_listen
-    sd img
-    setcall img stage_sel_img_listen(eventbox)
-    data null=0
-    if img!=null
-        call stage_redraw()
-    else
-        import "stage_unselected_frame" stage_unselected_frame
-        setcall img stage_unselected_frame(eventbox)
-    endelse
-
-    #add mouse detection to display pixbuf when clicked
-    str pressed="button-press-event"
-    data f^stage_frame_clicked
-    call connect_signal(eventbox,pressed,f)
-    importx "_gtk_widget_add_events" gtk_widget_add_events
-    sd events=GDK_BUTTON_PRESS_MASK
-    call gtk_widget_add_events(eventbox,events)
-
-    #display the widget
-    importx "_gtk_widget_show_all" gtk_widget_show_all
-    call gtk_widget_show_all(eventbox)
-endfunction
-
-#add a new frame to the stage
-#err
-function stage_new_frame_with_timelength(sd pixbuf,sd length)
-    #add the frame length at the end
-    call stage_frame_time_numbers((stage_frame_time_append),length)
-
-    #add eventbox for mouse detection
-    sd eventbox
-    setcall eventbox stage_new_click_area()
-
-    #pixbuf to eventbox
-    call stage_pixbuf_to_container(pixbuf,eventbox)
-endfunction
-#add a frame,length=1
-function stage_new_pix(sd pixbuf,ss text_ok)
-    call stage_new_frame_with_timelength(pixbuf,1)
-
-    #show the message and the received number of frames
-    data one=1
-    call stage_display_index(text_ok,one)
-endfunction
-import "default_unref_ptr" default_unref_ptr
-#incoming frame arrange
-function stage_element(sd *bus,sd message,sd ptrpipeline)
-    #get the pixbuf for future usage
-    import "msgelement_pixbuf" msgelement_pixbuf
-    sd pixbuf
-    setcall pixbuf msgelement_pixbuf(message)
-    #can be an error
-    if pixbuf!=0
-        sd skip=0
-        #verify with the limits
-        import "stage_prepare_uri_pos" stage_prepare_uri_pos
-        import "stage_prepare_uri_first" stage_prepare_uri_first
-        import "stage_prepare_uri_last" stage_prepare_uri_last
-        sd pos
-        setcall pos stage_prepare_uri_pos()
-        sd first
-        sd last
-        setcall first stage_prepare_uri_first()
-        setcall last stage_prepare_uri_last()
-        #
-        if first#!=-1
-            if pos#<first#
-                set skip 1
-            endif
-        endif
-        #
-        if last#!=-1
-            if pos#>last#
-                set skip 2
-                call default_unref_ptr(ptrpipeline)
-            endif
-        endif
-        #
-		if skip==0
-			import "rgb_test" rgb_test
-			setcall pixbuf rgb_test(pixbuf)
-			if pixbuf!=(NULL)
-				vstr text="Received frames: "
-				call stage_new_pix(pixbuf,text)
-			else
-				set skip 1
-			endelse
-		endif
-		if skip!=0
-			importx "_g_object_unref" g_object_unref
-			call g_object_unref(pixbuf)
-			if skip==1
-				call strdworddisp("Skipped frame: ",pos#)
-			else
-				call stage_display_index("Total frames: ",1)
-			endelse
-		endif
-		#
-		inc pos#
-	endif
-endfunction
-
-
-function stage_eos(sd *bus,sd *message,sd ptrpipeline)
-    #display the total number of frames
-    str text="Total frames at end of stream: "
-    data one=1
-    call stage_display_index(text,one)
-    call default_unref_ptr(ptrpipeline)
-endfunction
-
-function stage_connect_signals(sd bus,sd ptrpipe)
-    import "connect_signal_data" connect_signal_data
-    #element
-    str px="message::element"
-    data fn^stage_element
-    call connect_signal_data(bus,px,fn,ptrpipe)
-
-    #error
-    import "default_error_ptr" default_error_ptr
-    data er^default_error_ptr
-    str error="message::error"
-    call connect_signal_data(bus,error,er,ptrpipe)
-
-    #eos
-    data eos^stage_eos
-    str eosmsg="message::eos"
-    call connect_signal_data(bus,eosmsg,eos,ptrpipe)
-endfunction
-
-function stage_start_pipe(ss uri)
-#gdkpixbufsink plugins-good
-    ss launcher="uridecodebin uri=\"%s\" ! ffmpegcolorspace ! gdkpixbufsink"
-    ss str
-    sd *=0
-    sd strs^launcher
-
-    set str uri
-
-    sd err
-
-    sd mem
-    sd ptr_mem^mem
-
-    import "allocsum_null" allocsum_null
-    setcall err allocsum_null(strs,ptr_mem)
-    if err!=(noerror)
-        return err
-    endif
-
-    call sprintf(mem,launcher,uri)
-
-    import "launch_pipe_start" launch_pipe_start
-    data pipe#1
-    sd ptrpipe^pipe
-    const stage_pipeline^pipe
-
-    setcall pipe launch_pipe_start(mem)
-
-    importx "_free" free
-    call free(mem)
-    if pipe==0
-        return (void)
-    endif
-
-    import "bus_signals_data" bus_signals_data
-    data fn^stage_connect_signals
-    call bus_signals_data(pipe,fn,ptrpipe)
-endfunction
-
-function stage_get_pipeline()
-    data s%stage_pipeline
-    return s#
-endfunction
-function stage_set_pipeline(sd value)
-    data s%stage_pipeline
-    set s# value
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/prevw.oc
@@ -0,0 +1,337 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+function stage_preview()
+    import "stage_get_sel" stage_get_sel
+    sd img
+    setcall img stage_get_sel()
+    if img=0
+        return 0
+    endif
+
+    #used for allowing only one timeout for preview
+    sd key
+    setcall key sound_random_key()
+    inc key#
+
+    data letplay#1
+    const ptr_letplay^letplay
+    set letplay 1
+
+    call stage_preview_next(key#)
+endfunction
+
+function stage_pause()
+    data p%ptr_letplay
+    set p# 0
+    call sound_pause()
+endfunction
+
+import "stage_get_sel_pos" stage_get_sel_pos
+import "stage_get_frames" stage_get_frames
+
+function stage_preview_next(sd random_key)
+    #get sel position
+    sd pos
+    setcall pos stage_get_sel_pos()
+    #total positions
+    sd total_pos
+    setcall total_pos stage_get_frames()
+
+    #get the frame length
+    import "stage_frame_time_numbers" stage_frame_time_numbers
+    sd length
+    setcall length stage_frame_time_numbers((stage_f_length_get),pos)
+
+    #sound
+    call sound_send_buffer(pos,random_key)
+
+    #test next pos with the final one
+    inc pos
+    if pos=total_pos
+        #stop if last pos
+        return 0
+    endif
+
+    #set the timeout duration
+    import "stage_file_options_fps" stage_file_options_fps
+    sd fps
+    setcall fps stage_file_options_fps()
+    import "rule3" rule3
+    sd timeoutduration
+    setcall timeoutduration rule3(length,fps,1000)
+
+    importx "_gdk_threads_add_timeout" gdk_threads_add_timeout
+    data f^stage_preview_timeout
+    call gdk_threads_add_timeout(timeoutduration,f,random_key)
+endfunction
+
+function sound_random_key()
+    data key#1
+    return #key
+endfunction
+
+#timeout function
+function stage_preview_timeout(sd key)
+    #pause or close
+    sd pause%ptr_letplay
+    if pause#=0
+        return 0
+    endif
+
+    sd k
+    setcall k sound_random_key()
+    if k#!=key
+        #there is another timeout launched
+        return 0
+    endif
+
+    #get sel position
+    sd pos
+    setcall pos stage_get_sel_pos()
+    #get next pos
+    inc pos
+    #total positions
+    sd total_pos
+    setcall total_pos stage_get_frames()
+    if pos!=total_pos
+        #display the selection
+        import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
+        sd ebox
+        setcall ebox stage_nthwidgetFromcontainer(pos)
+        import "stage_display_pixbuf" stage_display_pixbuf
+        call stage_display_pixbuf(ebox)
+        #sync with the scroll
+        sd x
+        sd y
+        sd wind
+        importx "_gtk_widget_get_window" gtk_widget_get_window
+        setcall wind gtk_widget_get_window(ebox)
+        importx "_gdk_window_get_position" gdk_window_get_position
+        call gdk_window_get_position(wind,#x,#y)
+        import "stage_scroll" stage_scroll
+        sd scrl
+        setcall scrl stage_scroll()
+        importx "_gtk_scrolled_window_get_hadjustment" gtk_scrolled_window_get_hadjustment
+        sd adj
+        setcall adj gtk_scrolled_window_get_hadjustment(scrl#)
+        sd value#2
+        sd upper#2
+        sd page_size#2
+        importx "_g_object_get" g_object_get
+        call g_object_get(adj,"value",#value,"upper",#upper,"page-size",#page_size,0)
+        import "double_to_int" double_to_int
+        setcall value double_to_int(#value)
+        setcall upper double_to_int(#upper)
+        setcall page_size double_to_int(#page_size)
+        #use [lower,upper-page_size]
+        sd max
+        set max upper
+        sub max page_size
+        if value<max
+            sd next
+            set next value
+            add next page_size
+            if x>=next
+                if x>max
+                    set x max
+                endif
+                import "int_to_double" int_to_double
+                sd double_low
+                sd double_high
+                call int_to_double(x,#double_low)
+                importx "_gtk_adjustment_set_value" gtk_adjustment_set_value
+                call gtk_adjustment_set_value(adj,double_low,double_high)
+            endif
+        endif
+    endif
+
+    call stage_preview_next(key)
+
+    return 0
+endfunction
+
+
+#sound preview
+import "sound_preview_init" sound_preview_init
+import "sound_preview_free" sound_preview_free
+import "sound_preview_write_buffer" sound_preview_write_buffer
+
+function sound_preview_bool()
+    data bool#1
+    return #bool
+endfunction
+
+function sound_ready(sd frame_pos,sd random_key)
+    data logical_frame_pos#1
+    sd ptrbool
+    setcall ptrbool sound_preview_bool()
+    #condition to unset the previous player: if was created and has a different format, or another frame pressed
+    if ptrbool#=1
+        sd bool
+        setcall bool sound_format((value_get))
+        if bool=1
+            inc logical_frame_pos
+            if frame_pos!=logical_frame_pos
+                set bool 0
+            endif
+        endif
+        if bool=0
+            #unset the previous player
+            call sound_preview_free()
+            set ptrbool# 0
+        endif
+    endif
+    #condition to set the player: if isn't created
+    if ptrbool#=0
+        setcall ptrbool# sound_preview_init()
+        if ptrbool#=1
+            call sound_format((value_set))
+            set logical_frame_pos frame_pos
+            sd i=0
+            sd cursor
+            set cursor frame_pos
+            sd max
+            setcall max sound_preview_buffers()
+            while i<max
+                call sound_prev_pos(cursor,random_key)
+                inc cursor
+                inc i
+            endwhile
+        endif
+    endif
+endfunction
+
+function sound_pause()
+    sd prev
+    setcall prev sound_preview_bool()
+    if prev#=1
+        call sound_preview_free()
+        set prev# 0
+    endif
+endfunction
+
+import "stage_sound_rate" stage_sound_rate
+import "stage_sound_channels" stage_sound_channels
+import "stage_sound_bps" stage_sound_bps
+import "stage_sound_blockalign" stage_sound_blockalign
+
+function sound_send_buffer(sd frame_pos,sd random_key)
+    call sound_ready(frame_pos,random_key)
+    addcall frame_pos sound_preview_buffers()
+    call sound_prev_pos(frame_pos,random_key)
+endfunction
+
+function sound_preview_buffers()
+    sd buffers
+    setcall buffers stage_file_options_fps()
+    mult buffers 2
+    return buffers
+endfunction
+
+import "stage_sound_framelength_to_soundlength" stage_sound_framelength_to_soundlength
+
+function sound_prev_pos(sd frame_pos,sd random_key)
+    #get logical sound position
+    sd sum_at_point
+    setcall sum_at_point stage_frame_time_numbers((stage_frame_time_sum_at_index),frame_pos)
+    if sum_at_point=0
+        if frame_pos!=0
+            #after the last frame, once
+            return (void)
+        endif
+    endif
+    sd pos_sound_size
+    setcall pos_sound_size stage_sound_framelength_to_soundlength(sum_at_point)
+    import "stage_sound_subsize" stage_sound_subsize
+    sd current_sound_size
+    setcall current_sound_size stage_sound_subsize((value_get))
+    if current_sound_size<=pos_sound_size
+        #no sound buffer to add
+        return (void)
+    endif
+
+    sd test_minimum_sz
+    set test_minimum_sz current_sound_size
+    sub test_minimum_sz pos_sound_size
+    sd minimum_sz
+	sd blockalign
+	setcall blockalign stage_sound_blockalign()
+    set minimum_sz blockalign
+    if test_minimum_sz<=minimum_sz
+        #insignificant sound detected
+        return (void)
+    endif
+
+    #get next logical size
+    sd next_size
+    set next_size pos_sound_size
+    sd length_at_point
+    setcall length_at_point stage_frame_time_numbers((stage_frame_time_get_at_index),frame_pos)
+    addcall next_size stage_sound_framelength_to_soundlength(length_at_point)
+
+    #next size can be smaller
+    if current_sound_size<next_size
+        set next_size current_sound_size
+    else
+	#if it's last, forward all remaining sound
+        sd all_frames
+        setcall all_frames stage_get_frames()
+        sd next_frame
+        set next_frame frame_pos
+        inc next_frame
+        if next_frame=all_frames
+            set next_size current_sound_size
+        endif
+    endelse
+
+    #output the sound
+    import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
+    sd buf_size
+    sd buf
+    set buf_size next_size
+    sub buf_size pos_sound_size
+    setcall buf stage_sound_alloc_getbytes()
+    add buf pos_sound_size
+    call sound_preview_write_buffer(buf,buf_size,random_key)
+endfunction
+
+function sound_format(sd procedure)
+    data sample_rate#1
+    data channels#1
+    data bits_per_sample#1
+    sd current_sample_rate
+    sd current_channels
+    sd current_bits_per_sample
+    setcall current_sample_rate stage_sound_rate((value_get))
+    setcall current_channels stage_sound_channels((value_get))
+    setcall current_bits_per_sample stage_sound_bps((value_get))
+    if procedure=(value_set)
+        set sample_rate current_sample_rate
+        set channels current_channels
+        set bits_per_sample current_bits_per_sample
+    else
+    #bool
+        sd changed=0
+        if sample_rate!=current_sample_rate
+            set changed 1
+        endif
+        if channels!=current_channels
+            set changed 1
+        endif
+        if bits_per_sample!=current_bits_per_sample
+            set changed 1
+        endif
+        if changed=1
+            set sample_rate current_sample_rate
+            set channels current_channels
+            set bits_per_sample current_bits_per_sample
+            return 0
+        endif
+        return 1
+    endelse
+endfunction
--- ovideo-1.orig/src/_prepare/prevw.s
+++ /dev/null
@@ -1,337 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-function stage_preview()
-    import "stage_get_sel" stage_get_sel
-    sd img
-    setcall img stage_get_sel()
-    if img==0
-        return 0
-    endif
-
-    #used for allowing only one timeout for preview
-    sd key
-    setcall key sound_random_key()
-    inc key#
-
-    data letplay#1
-    const ptr_letplay^letplay
-    set letplay 1
-
-    call stage_preview_next(key#)
-endfunction
-
-function stage_pause()
-    data p%ptr_letplay
-    set p# 0
-    call sound_pause()
-endfunction
-
-import "stage_get_sel_pos" stage_get_sel_pos
-import "stage_get_frames" stage_get_frames
-
-function stage_preview_next(sd random_key)
-    #get sel position
-    sd pos
-    setcall pos stage_get_sel_pos()
-    #total positions
-    sd total_pos
-    setcall total_pos stage_get_frames()
-
-    #get the frame length
-    import "stage_frame_time_numbers" stage_frame_time_numbers
-    sd length
-    setcall length stage_frame_time_numbers((stage_f_length_get),pos)
-
-    #sound
-    call sound_send_buffer(pos,random_key)
-
-    #test next pos with the final one
-    inc pos
-    if pos==total_pos
-        #stop if last pos
-        return 0
-    endif
-
-    #set the timeout duration
-    import "stage_file_options_fps" stage_file_options_fps
-    sd fps
-    setcall fps stage_file_options_fps()
-    import "rule3" rule3
-    sd timeoutduration
-    setcall timeoutduration rule3(length,fps,1000)
-
-    importx "_gdk_threads_add_timeout" gdk_threads_add_timeout
-    data f^stage_preview_timeout
-    call gdk_threads_add_timeout(timeoutduration,f,random_key)
-endfunction
-
-function sound_random_key()
-    data key#1
-    return #key
-endfunction
-
-#timeout function
-function stage_preview_timeout(sd key)
-    #pause or close
-    sd pause%ptr_letplay
-    if pause#==0
-        return 0
-    endif
-
-    sd k
-    setcall k sound_random_key()
-    if k#!=key
-        #there is another timeout launched
-        return 0
-    endif
-
-    #get sel position
-    sd pos
-    setcall pos stage_get_sel_pos()
-    #get next pos
-    inc pos
-    #total positions
-    sd total_pos
-    setcall total_pos stage_get_frames()
-    if pos!=total_pos
-        #display the selection
-        import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
-        sd ebox
-        setcall ebox stage_nthwidgetFromcontainer(pos)
-        import "stage_display_pixbuf" stage_display_pixbuf
-        call stage_display_pixbuf(ebox)
-        #sync with the scroll
-        sd x
-        sd y
-        sd wind
-        importx "_gtk_widget_get_window" gtk_widget_get_window
-        setcall wind gtk_widget_get_window(ebox)
-        importx "_gdk_window_get_position" gdk_window_get_position
-        call gdk_window_get_position(wind,#x,#y)
-        import "stage_scroll" stage_scroll
-        sd scrl
-        setcall scrl stage_scroll()
-        importx "_gtk_scrolled_window_get_hadjustment" gtk_scrolled_window_get_hadjustment
-        sd adj
-        setcall adj gtk_scrolled_window_get_hadjustment(scrl#)
-        sd value#2
-        sd upper#2
-        sd page_size#2
-        importx "_g_object_get" g_object_get
-        call g_object_get(adj,"value",#value,"upper",#upper,"page-size",#page_size,0)
-        import "double_to_int" double_to_int
-        setcall value double_to_int(#value)
-        setcall upper double_to_int(#upper)
-        setcall page_size double_to_int(#page_size)
-        #use [lower,upper-page_size]
-        sd max
-        set max upper
-        sub max page_size
-        if value<max
-            sd next
-            set next value
-            add next page_size
-            if x>=next
-                if x>max
-                    set x max
-                endif
-                import "int_to_double" int_to_double
-                sd double_low
-                sd double_high
-                call int_to_double(x,#double_low)
-                importx "_gtk_adjustment_set_value" gtk_adjustment_set_value
-                call gtk_adjustment_set_value(adj,double_low,double_high)
-            endif
-        endif
-    endif
-
-    call stage_preview_next(key)
-
-    return 0
-endfunction
-
-
-#sound preview
-import "sound_preview_init" sound_preview_init
-import "sound_preview_free" sound_preview_free
-import "sound_preview_write_buffer" sound_preview_write_buffer
-
-function sound_preview_bool()
-    data bool#1
-    return #bool
-endfunction
-
-function sound_ready(sd frame_pos,sd random_key)
-    data logical_frame_pos#1
-    sd ptrbool
-    setcall ptrbool sound_preview_bool()
-    #condition to unset the previous player: if was created and has a different format, or another frame pressed
-    if ptrbool#==1
-        sd bool
-        setcall bool sound_format((value_get))
-        if bool==1
-            inc logical_frame_pos
-            if frame_pos!=logical_frame_pos
-                set bool 0
-            endif
-        endif
-        if bool==0
-            #unset the previous player
-            call sound_preview_free()
-            set ptrbool# 0
-        endif
-    endif
-    #condition to set the player: if isn't created
-    if ptrbool#==0
-        setcall ptrbool# sound_preview_init()
-        if ptrbool#==1
-            call sound_format((value_set))
-            set logical_frame_pos frame_pos
-            sd i=0
-            sd cursor
-            set cursor frame_pos
-            sd max
-            setcall max sound_preview_buffers()
-            while i<max
-                call sound_prev_pos(cursor,random_key)
-                inc cursor
-                inc i
-            endwhile
-        endif
-    endif
-endfunction
-
-function sound_pause()
-    sd prev
-    setcall prev sound_preview_bool()
-    if prev#==1
-        call sound_preview_free()
-        set prev# 0
-    endif
-endfunction
-
-import "stage_sound_rate" stage_sound_rate
-import "stage_sound_channels" stage_sound_channels
-import "stage_sound_bps" stage_sound_bps
-import "stage_sound_blockalign" stage_sound_blockalign
-
-function sound_send_buffer(sd frame_pos,sd random_key)
-    call sound_ready(frame_pos,random_key)
-    addcall frame_pos sound_preview_buffers()
-    call sound_prev_pos(frame_pos,random_key)
-endfunction
-
-function sound_preview_buffers()
-    sd buffers
-    setcall buffers stage_file_options_fps()
-    mult buffers 2
-    return buffers
-endfunction
-
-import "stage_sound_framelength_to_soundlength" stage_sound_framelength_to_soundlength
-
-function sound_prev_pos(sd frame_pos,sd random_key)
-    #get logical sound position
-    sd sum_at_point
-    setcall sum_at_point stage_frame_time_numbers((stage_frame_time_sum_at_index),frame_pos)
-    if sum_at_point==0
-        if frame_pos!=0
-            #after the last frame, once
-            return (void)
-        endif
-    endif
-    sd pos_sound_size
-    setcall pos_sound_size stage_sound_framelength_to_soundlength(sum_at_point)
-    import "stage_sound_subsize" stage_sound_subsize
-    sd current_sound_size
-    setcall current_sound_size stage_sound_subsize((value_get))
-    if current_sound_size<=pos_sound_size
-        #no sound buffer to add
-        return (void)
-    endif
-
-    sd test_minimum_sz
-    set test_minimum_sz current_sound_size
-    sub test_minimum_sz pos_sound_size
-    sd minimum_sz
-	sd blockalign
-	setcall blockalign stage_sound_blockalign()
-    set minimum_sz blockalign
-    if test_minimum_sz<=minimum_sz
-        #insignificant sound detected
-        return (void)
-    endif
-
-    #get next logical size
-    sd next_size
-    set next_size pos_sound_size
-    sd length_at_point
-    setcall length_at_point stage_frame_time_numbers((stage_frame_time_get_at_index),frame_pos)
-    addcall next_size stage_sound_framelength_to_soundlength(length_at_point)
-
-    #next size can be smaller
-    if current_sound_size<next_size
-        set next_size current_sound_size
-    else
-	#if it's last, forward all remaining sound
-        sd all_frames
-        setcall all_frames stage_get_frames()
-        sd next_frame
-        set next_frame frame_pos
-        inc next_frame
-        if next_frame==all_frames
-            set next_size current_sound_size
-        endif
-    endelse
-
-    #output the sound
-    import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
-    sd buf_size
-    sd buf
-    set buf_size next_size
-    sub buf_size pos_sound_size
-    setcall buf stage_sound_alloc_getbytes()
-    add buf pos_sound_size
-    call sound_preview_write_buffer(buf,buf_size,random_key)
-endfunction
-
-function sound_format(sd procedure)
-    data sample_rate#1
-    data channels#1
-    data bits_per_sample#1
-    sd current_sample_rate
-    sd current_channels
-    sd current_bits_per_sample
-    setcall current_sample_rate stage_sound_rate((value_get))
-    setcall current_channels stage_sound_channels((value_get))
-    setcall current_bits_per_sample stage_sound_bps((value_get))
-    if procedure==(value_set)
-        set sample_rate current_sample_rate
-        set channels current_channels
-        set bits_per_sample current_bits_per_sample
-    else
-    #bool
-        sd changed=0
-        if sample_rate!=current_sample_rate
-            set changed 1
-        endif
-        if channels!=current_channels
-            set changed 1
-        endif
-        if bits_per_sample!=current_bits_per_sample
-            set changed 1
-        endif
-        if changed==1
-            set sample_rate current_sample_rate
-            set channels current_channels
-            set bits_per_sample current_bits_per_sample
-            return 0
-        endif
-        return 1
-    endelse
-endfunction
--- /dev/null
+++ ovideo-1/src/_prepare/sel.oc
@@ -0,0 +1,386 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+#unselected frame
+#image
+function stage_unselected_frame(sd parent)
+    ss normalframe
+    import "unselectedframe" unselectedframe
+    setcall normalframe unselectedframe()
+    sd img
+    setcall img stage_img_with_length(normalframe,parent)
+    return img
+endfunction
+
+#selected frame
+#creates selection image with pixbuf
+#img returned
+function stage_sel_img(sd parent)
+    import "selectedframe" selectedframe
+    ss file
+    setcall file selectedframe()
+    data img#1
+    const ptr_img^img
+    setcall img stage_img_with_length(file,parent)
+    return img
+endfunction
+#put the selection at the eventbox position(newparent)
+#img return
+function stage_sel_img_set(sd newparent)
+    sd img
+    setcall img stage_sel_img(newparent)
+    importx "_gtk_widget_show" gtk_widget_show
+    call gtk_widget_show(img)
+    return img
+endfunction
+
+importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+
+#returns the new img with the length set and added to the parent
+function stage_img_with_length(ss file,sd parent)
+    sd img
+    importx "_gtk_image_new" gtk_image_new
+    setcall img gtk_image_new()
+
+    import "pixbuf_from_file" pixbuf_from_file
+    sd pixbuf
+    setcall pixbuf pixbuf_from_file(file)
+    if pixbuf=0
+        return img
+    endif
+
+    import "stage_get_fr_length" stage_get_fr_length
+    sd length
+    setcall length stage_get_fr_length(parent)
+
+    sd w
+    setcall w gdk_pixbuf_get_width(pixbuf)
+    mult w length
+    sd h
+    setcall h gdk_pixbuf_get_height(pixbuf)
+    import "pixbuf_scale_forward_data" pixbuf_scale_forward_data
+    data f^stage_img_with_length_fn
+    call pixbuf_scale_forward_data(pixbuf,w,h,f,img)
+
+    importx "_g_object_unref" g_object_unref
+    call g_object_unref(pixbuf)
+
+    import "container_child" container_child
+    call container_child(parent,img)
+    return img
+endfunction
+function stage_img_with_length_fn(sd pixb,sd img)
+    #draw a border around the pixbuf
+    sd w
+    setcall w gdk_pixbuf_get_width(pixb)
+    sd h
+    setcall h gdk_pixbuf_get_height(pixb)
+    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+    sd pixels
+    setcall pixels gdk_pixbuf_get_pixels(pixb)
+    importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
+
+    sd rowsub
+    set rowsub w
+    mult rowsub 3
+    sd rowdif
+    setcall rowdif gdk_pixbuf_get_rowstride(pixb)
+    sub rowdif rowsub
+
+    sd prelast_h
+    set prelast_h h
+    dec prelast_h
+
+    sd prelast_w
+    set prelast_w w
+    dec prelast_w
+
+    sd j=0
+    while j!=h
+        sd i=0
+        while i!=w
+            sd border=0
+            if j=0
+                set border 1
+            elseif j=prelast_h
+                set border 1
+            elseif i=0
+                set border 1
+            elseif i=prelast_w
+                set border 1
+            endelseif
+            if border=1
+                ss px
+                set px pixels
+                set px# 0
+                inc px
+                set px# 0
+                inc px
+                set px# 0
+            endif
+            add pixels 3
+            inc i
+        endwhile
+        add pixels rowdif
+        inc j
+    endwhile
+
+    importx "_gtk_image_set_from_pixbuf" gtk_image_set_from_pixbuf
+    call gtk_image_set_from_pixbuf(img,pixb)
+endfunction
+
+#initialize/set the img to zero
+function stage_sel_prepare_img_space()
+    sd pi%ptr_img
+    data z=0
+    set pi# z
+endfunction
+
+#listen for the first frame to select it
+#img or null
+function stage_sel_img_listen(sd newparent)
+    sd pi%ptr_img
+    sd img=0
+    data z=0
+    if pi#=z
+        setcall img stage_sel_img_set(newparent)
+    endif
+    return img
+endfunction
+
+importx "_gtk_widget_get_parent" gtk_widget_get_parent
+
+#deletes the old selection frame and creates the new
+function stage_sel_reparent(sd newparent)
+    sd pi%ptr_img
+    data z=0
+    sd img
+    set img pi#
+    if img!=z
+        sd parent
+        setcall parent gtk_widget_get_parent(img)
+        call stage_unselected_frame(parent)
+        importx "_gtk_widget_show_all" gtk_widget_show_all
+        call gtk_widget_show_all(parent)
+    endif
+    call stage_sel_img_set(newparent)
+endfunction
+
+#e
+function stage_save_nothing()
+    str noframe="There is no frame on the stage."
+    import "texter" texter
+    call texter(noframe)
+    return noframe
+endfunction
+
+#0/pixbuf
+#get the sel frame bar pixbuf
+function stage_sel_framebar_pixbuf()
+    sd img
+    setcall img stage_get_sel()
+    if img=0
+        return 0
+    endif
+    importx "_gtk_image_get_pixbuf" gtk_image_get_pixbuf
+    sd pixbuf
+    setcall pixbuf gtk_image_get_pixbuf(img)
+    return pixbuf
+endfunction
+
+function stage_sel_pointer()
+    sd pi%ptr_img
+    return pi
+endfunction
+
+function stage_sel()
+    sd pi
+    setcall pi stage_sel_pointer()
+    return pi#
+endfunction
+
+#NULL/img
+function stage_get_sel()
+    sd pi%ptr_img
+    sd img
+    set img pi#
+    if img=0
+        call stage_save_nothing()
+        return 0
+    endif
+    return img
+endfunction
+
+#e
+function stage_get_sel_parent(sd ptr_eventbox)
+    sd img
+    setcall img stage_get_sel()
+    if img=0
+        return (error)
+    endif
+    setcall ptr_eventbox# gtk_widget_get_parent(img)
+    return (noerror)
+endfunction
+
+#e
+function stage_get_sel_pixbuf(sd ptr)
+    sd eventbox
+    sd ptr_eventbox^eventbox
+    sd err
+    setcall err stage_get_sel_parent(ptr_eventbox)
+    if err!=(noerror)
+        return err
+    endif
+    sd pixbuf
+    import "object_get_dword_name" object_get_dword_name
+    setcall pixbuf object_get_dword_name(eventbox)
+    set ptr# pixbuf
+    data noerr=noerror
+    return noerr
+endfunction
+#e
+function stage_get_sel_pixbuf_nowarning(sd ptr)
+    sd pi%ptr_img
+    if pi#=0
+        return (error)
+    endif
+    call stage_get_sel_pixbuf(ptr)
+endfunction
+#0/pixbuf
+function stage_get_selection_pixbuf()
+    sd px
+    sd p_px^px
+    sd err
+    setcall err stage_get_sel_pixbuf(p_px)
+    if err!=(noerror)
+        return 0
+    endif
+    return px
+endfunction
+
+#save the selection to a file
+function stage_save_img()
+    sd pixbuf
+    sd ptr_pixbuf^pixbuf
+    sd err
+    data noerr=noerror
+    setcall err stage_get_sel_pixbuf(ptr_pixbuf)
+    if err!=noerr
+        return err
+    endif
+
+    ss location
+    str format="jpeg"
+    import "save_destination" save_destination
+    setcall location save_destination(format)
+
+    sd file
+    sd p_file^file
+    import "openfile" openfile
+    importx "_fclose" fclose
+    sd er
+    ss mode="wb"
+    setcall er openfile(p_file,location,mode)
+    if er!=(noerror)
+        return 0
+    endif
+    import "stage_jpeg_write" stage_jpeg_write
+    call stage_jpeg_write(file,pixbuf)
+    call fclose(file)
+
+    import "save_inform_saved" save_inform_saved
+    call save_inform_saved(location)
+endfunction
+
+
+#verify a frame exists and mass remove is close
+#bool
+function frame_jobs()
+    sd img
+    setcall img stage_get_sel()
+    if img=0
+        return 0
+    endif
+    sd bool
+    setcall bool mass_remove_job()
+    return bool
+endfunction
+
+#bool
+function mass_remove_job()
+    import "link_mass_remove" link_mass_remove
+    sd massremove
+    setcall massremove link_mass_remove((value_get))
+    if massremove!=0
+        str er="Close the interval remove dialog first"
+        call texter(er)
+        return 0
+    endif
+    return 1
+endfunction
+
+#a dialog checking if there is at least one frame and mass remove is off
+function stage_frame_dialog(sd init,sd on_ok,sd title)
+    sd bool
+    setcall bool frame_jobs()
+    if bool!=(TRUE)
+        return (void)
+    endif
+    import "dialogfield" dialogfield
+    call dialogfield(title,(GTK_DIALOG_MODAL),init,on_ok)
+endfunction
+#dialog, checking if mass remove is off
+function stage_frame_dialog_solo(sd init,sd on_ok,sd title)
+    sd bool
+    setcall bool mass_remove_job()
+    if bool!=(TRUE)
+        return (void)
+    endif
+    call dialogfield(title,(GTK_DIALOG_MODAL),init,on_ok)
+endfunction
+
+import "stage_frame_index" stage_frame_index
+
+#the sel pos
+function stage_get_sel_pos()
+    sd selparent
+    sd p_selparent^selparent
+    call stage_get_sel_parent(p_selparent)
+    sd pos
+    setcall pos stage_frame_index(selparent)
+    return pos
+endfunction
+#e
+function stage_get_sel_position(sd p_pos)
+    #no texter
+    sd pi%ptr_img
+    sd img
+    set img pi#
+    if img=0
+        return (error)
+    endif
+    sd selparent
+    setcall selparent gtk_widget_get_parent(img)
+    setcall p_pos# stage_frame_index(selparent)
+    return (noerror)
+endfunction
+
+function stage_sel_replace_pixbuf(sd newpixbuf)
+    sd ebox
+    sd p_ebox^ebox
+    call stage_get_sel_parent(p_ebox)
+
+    import "unref_pixbuf_frame" unref_pixbuf_frame
+    call unref_pixbuf_frame(ebox)
+
+    import "object_set_dword_name" object_set_dword_name
+    call object_set_dword_name(ebox,newpixbuf)
+    import "stage_redraw" stage_redraw
+    call stage_redraw()
+endfunction
+
+
--- ovideo-1.orig/src/_prepare/sel.s
+++ /dev/null
@@ -1,386 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-#unselected frame
-#image
-function stage_unselected_frame(sd parent)
-    ss normalframe
-    import "unselectedframe" unselectedframe
-    setcall normalframe unselectedframe()
-    sd img
-    setcall img stage_img_with_length(normalframe,parent)
-    return img
-endfunction
-
-#selected frame
-#creates selection image with pixbuf
-#img returned
-function stage_sel_img(sd parent)
-    import "selectedframe" selectedframe
-    ss file
-    setcall file selectedframe()
-    data img#1
-    const ptr_img^img
-    setcall img stage_img_with_length(file,parent)
-    return img
-endfunction
-#put the selection at the eventbox position(newparent)
-#img return
-function stage_sel_img_set(sd newparent)
-    sd img
-    setcall img stage_sel_img(newparent)
-    importx "_gtk_widget_show" gtk_widget_show
-    call gtk_widget_show(img)
-    return img
-endfunction
-
-importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-
-#returns the new img with the length set and added to the parent
-function stage_img_with_length(ss file,sd parent)
-    sd img
-    importx "_gtk_image_new" gtk_image_new
-    setcall img gtk_image_new()
-
-    import "pixbuf_from_file" pixbuf_from_file
-    sd pixbuf
-    setcall pixbuf pixbuf_from_file(file)
-    if pixbuf==0
-        return img
-    endif
-
-    import "stage_get_fr_length" stage_get_fr_length
-    sd length
-    setcall length stage_get_fr_length(parent)
-
-    sd w
-    setcall w gdk_pixbuf_get_width(pixbuf)
-    mult w length
-    sd h
-    setcall h gdk_pixbuf_get_height(pixbuf)
-    import "pixbuf_scale_forward_data" pixbuf_scale_forward_data
-    data f^stage_img_with_length_fn
-    call pixbuf_scale_forward_data(pixbuf,w,h,f,img)
-
-    importx "_g_object_unref" g_object_unref
-    call g_object_unref(pixbuf)
-
-    import "container_child" container_child
-    call container_child(parent,img)
-    return img
-endfunction
-function stage_img_with_length_fn(sd pixb,sd img)
-    #draw a border around the pixbuf
-    sd w
-    setcall w gdk_pixbuf_get_width(pixb)
-    sd h
-    setcall h gdk_pixbuf_get_height(pixb)
-    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-    sd pixels
-    setcall pixels gdk_pixbuf_get_pixels(pixb)
-    importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
-
-    sd rowsub
-    set rowsub w
-    mult rowsub 3
-    sd rowdif
-    setcall rowdif gdk_pixbuf_get_rowstride(pixb)
-    sub rowdif rowsub
-
-    sd prelast_h
-    set prelast_h h
-    dec prelast_h
-
-    sd prelast_w
-    set prelast_w w
-    dec prelast_w
-
-    sd j=0
-    while j!=h
-        sd i=0
-        while i!=w
-            sd border=0
-            if j==0
-                set border 1
-            elseif j==prelast_h
-                set border 1
-            elseif i==0
-                set border 1
-            elseif i==prelast_w
-                set border 1
-            endelseif
-            if border==1
-                ss px
-                set px pixels
-                set px# 0
-                inc px
-                set px# 0
-                inc px
-                set px# 0
-            endif
-            add pixels 3
-            inc i
-        endwhile
-        add pixels rowdif
-        inc j
-    endwhile
-
-    importx "_gtk_image_set_from_pixbuf" gtk_image_set_from_pixbuf
-    call gtk_image_set_from_pixbuf(img,pixb)
-endfunction
-
-#initialize/set the img to zero
-function stage_sel_prepare_img_space()
-    sd pi%ptr_img
-    data z=0
-    set pi# z
-endfunction
-
-#listen for the first frame to select it
-#img or null
-function stage_sel_img_listen(sd newparent)
-    sd pi%ptr_img
-    sd img=0
-    data z=0
-    if pi#==z
-        setcall img stage_sel_img_set(newparent)
-    endif
-    return img
-endfunction
-
-importx "_gtk_widget_get_parent" gtk_widget_get_parent
-
-#deletes the old selection frame and creates the new
-function stage_sel_reparent(sd newparent)
-    sd pi%ptr_img
-    data z=0
-    sd img
-    set img pi#
-    if img!=z
-        sd parent
-        setcall parent gtk_widget_get_parent(img)
-        call stage_unselected_frame(parent)
-        importx "_gtk_widget_show_all" gtk_widget_show_all
-        call gtk_widget_show_all(parent)
-    endif
-    call stage_sel_img_set(newparent)
-endfunction
-
-#e
-function stage_save_nothing()
-    str noframe="There is no frame on the stage."
-    import "texter" texter
-    call texter(noframe)
-    return noframe
-endfunction
-
-#0/pixbuf
-#get the sel frame bar pixbuf
-function stage_sel_framebar_pixbuf()
-    sd img
-    setcall img stage_get_sel()
-    if img==0
-        return 0
-    endif
-    importx "_gtk_image_get_pixbuf" gtk_image_get_pixbuf
-    sd pixbuf
-    setcall pixbuf gtk_image_get_pixbuf(img)
-    return pixbuf
-endfunction
-
-function stage_sel_pointer()
-    sd pi%ptr_img
-    return pi
-endfunction
-
-function stage_sel()
-    sd pi
-    setcall pi stage_sel_pointer()
-    return pi#
-endfunction
-
-#NULL/img
-function stage_get_sel()
-    sd pi%ptr_img
-    sd img
-    set img pi#
-    if img==0
-        call stage_save_nothing()
-        return 0
-    endif
-    return img
-endfunction
-
-#e
-function stage_get_sel_parent(sd ptr_eventbox)
-    sd img
-    setcall img stage_get_sel()
-    if img==0
-        return (error)
-    endif
-    setcall ptr_eventbox# gtk_widget_get_parent(img)
-    return (noerror)
-endfunction
-
-#e
-function stage_get_sel_pixbuf(sd ptr)
-    sd eventbox
-    sd ptr_eventbox^eventbox
-    sd err
-    setcall err stage_get_sel_parent(ptr_eventbox)
-    if err!=(noerror)
-        return err
-    endif
-    sd pixbuf
-    import "object_get_dword_name" object_get_dword_name
-    setcall pixbuf object_get_dword_name(eventbox)
-    set ptr# pixbuf
-    data noerr=noerror
-    return noerr
-endfunction
-#e
-function stage_get_sel_pixbuf_nowarning(sd ptr)
-    sd pi%ptr_img
-    if pi#==0
-        return (error)
-    endif
-    call stage_get_sel_pixbuf(ptr)
-endfunction
-#0/pixbuf
-function stage_get_selection_pixbuf()
-    sd px
-    sd p_px^px
-    sd err
-    setcall err stage_get_sel_pixbuf(p_px)
-    if err!=(noerror)
-        return 0
-    endif
-    return px
-endfunction
-
-#save the selection to a file
-function stage_save_img()
-    sd pixbuf
-    sd ptr_pixbuf^pixbuf
-    sd err
-    data noerr=noerror
-    setcall err stage_get_sel_pixbuf(ptr_pixbuf)
-    if err!=noerr
-        return err
-    endif
-
-    ss location
-    str format="jpeg"
-    import "save_destination" save_destination
-    setcall location save_destination(format)
-
-    sd file
-    sd p_file^file
-    import "openfile" openfile
-    importx "_fclose" fclose
-    sd er
-    ss mode="wb"
-    setcall er openfile(p_file,location,mode)
-    if er!=(noerror)
-        return 0
-    endif
-    import "stage_jpeg_write" stage_jpeg_write
-    call stage_jpeg_write(file,pixbuf)
-    call fclose(file)
-
-    import "save_inform_saved" save_inform_saved
-    call save_inform_saved(location)
-endfunction
-
-
-#verify a frame exists and mass remove is close
-#bool
-function frame_jobs()
-    sd img
-    setcall img stage_get_sel()
-    if img==0
-        return 0
-    endif
-    sd bool
-    setcall bool mass_remove_job()
-    return bool
-endfunction
-
-#bool
-function mass_remove_job()
-    import "link_mass_remove" link_mass_remove
-    sd massremove
-    setcall massremove link_mass_remove((value_get))
-    if massremove!=0
-        str er="Close the interval remove dialog first"
-        call texter(er)
-        return 0
-    endif
-    return 1
-endfunction
-
-#a dialog checking if there is at least one frame and mass remove is off
-function stage_frame_dialog(sd init,sd on_ok,sd title)
-    sd bool
-    setcall bool frame_jobs()
-    if bool!=(TRUE)
-        return (void)
-    endif
-    import "dialogfield" dialogfield
-    call dialogfield(title,(GTK_DIALOG_MODAL),init,on_ok)
-endfunction
-#dialog, checking if mass remove is off
-function stage_frame_dialog_solo(sd init,sd on_ok,sd title)
-    sd bool
-    setcall bool mass_remove_job()
-    if bool!=(TRUE)
-        return (void)
-    endif
-    call dialogfield(title,(GTK_DIALOG_MODAL),init,on_ok)
-endfunction
-
-import "stage_frame_index" stage_frame_index
-
-#the sel pos
-function stage_get_sel_pos()
-    sd selparent
-    sd p_selparent^selparent
-    call stage_get_sel_parent(p_selparent)
-    sd pos
-    setcall pos stage_frame_index(selparent)
-    return pos
-endfunction
-#e
-function stage_get_sel_position(sd p_pos)
-    #no texter
-    sd pi%ptr_img
-    sd img
-    set img pi#
-    if img==0
-        return (error)
-    endif
-    sd selparent
-    setcall selparent gtk_widget_get_parent(img)
-    setcall p_pos# stage_frame_index(selparent)
-    return (noerror)
-endfunction
-
-function stage_sel_replace_pixbuf(sd newpixbuf)
-    sd ebox
-    sd p_ebox^ebox
-    call stage_get_sel_parent(p_ebox)
-
-    import "unref_pixbuf_frame" unref_pixbuf_frame
-    call unref_pixbuf_frame(ebox)
-
-    import "object_set_dword_name" object_set_dword_name
-    call object_set_dword_name(ebox,newpixbuf)
-    import "stage_redraw" stage_redraw
-    call stage_redraw()
-endfunction
-
-
--- /dev/null
+++ ovideo-1/src/_prepare/stagempeg.oc
@@ -0,0 +1,39 @@
+
+##mpeg for stage
+
+format elfobj
+
+include "../_include/include.h"
+
+##encode
+
+#bool
+function stage_mpeg_init(sd file)
+    import "av_frames" av_frames
+    sd pixbuf
+    setcall pixbuf av_frames((get_buffer))
+
+    import "stage_get_frames" stage_get_frames
+    sd totalframes
+    setcall totalframes stage_get_frames()
+
+    import "mpeg_init" mpeg_init
+    sd bool
+    setcall bool mpeg_init(file,pixbuf,totalframes)
+    return bool
+endfunction
+
+#bool
+function stage_mpeg_encode(sd pixbuf,sd currentframe,sd p_is_keyframe)
+    import "stage_frame_time_numbers" stage_frame_time_numbers
+    sd position
+    setcall position stage_frame_time_numbers((stage_frame_time_sum_at_index),currentframe)
+
+    import "mpeg_encode" mpeg_encode
+    sd bool
+    setcall bool mpeg_encode(pixbuf,position,p_is_keyframe)
+    return bool
+endfunction
+
+
+##decode
--- ovideo-1.orig/src/_prepare/stagempeg.s
+++ /dev/null
@@ -1,39 +0,0 @@
-
-##mpeg for stage
-
-format elfobj
-
-include "../_include/include.h"
-
-##encode
-
-#bool
-function stage_mpeg_init(sd file)
-    import "av_frames" av_frames
-    sd pixbuf
-    setcall pixbuf av_frames((get_buffer))
-
-    import "stage_get_frames" stage_get_frames
-    sd totalframes
-    setcall totalframes stage_get_frames()
-
-    import "mpeg_init" mpeg_init
-    sd bool
-    setcall bool mpeg_init(file,pixbuf,totalframes)
-    return bool
-endfunction
-
-#bool
-function stage_mpeg_encode(sd pixbuf,sd currentframe,sd p_is_keyframe)
-    import "stage_frame_time_numbers" stage_frame_time_numbers
-    sd position
-    setcall position stage_frame_time_numbers((stage_frame_time_sum_at_index),currentframe)
-
-    import "mpeg_encode" mpeg_encode
-    sd bool
-    setcall bool mpeg_encode(pixbuf,position,p_is_keyframe)
-    return bool
-endfunction
-
-
-##decode
--- /dev/null
+++ ovideo-1/src/_prepare/view.oc
@@ -0,0 +1,1030 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+#inits
+
+function stage_buttons_enter(sd container)
+        #newuri
+    char button="new.bmp"
+    char *="Creates a blank new media"
+    data *^stage_prepare_blank
+        #
+    char *="newuri.bmp"
+    char *="Open the media from the uri bar"
+    data *^stage_prepare_uri_start
+        #
+    import "stage_preview" stage_preview
+    char *="preview.bmp"
+    char *="Preview the stage"
+    data *^stage_preview
+        #
+    import "stage_pause" stage_pause
+    char *="pause.bmp"
+    char *="Pause the preview"
+    data *^stage_pause
+        #
+    char *="close.bmp"
+    char *="Close the stage bar"
+    data *^stage_buttons_close
+        #
+    data *=0
+        #
+    import "stage_save_all" stage_save_all
+    char *="file.bmp"
+    char *="Save the stage to a file"
+    data *^stage_save_all
+        #
+    import "av_expand" av_expand
+    char *="expand.bmp"
+    char *="Expand a mp4 or avi(i420,mjpeg,mpg4-asp) file"
+    data *^av_expand
+        #
+    import "stage_file_options" stage_file_options
+    char *="fileoptions.bmp"
+    char *="Set the stage file options"
+    data *^stage_file_options
+        #
+    data *=0
+        #
+    import "stage_files_read" stage_files_read
+    char *="open.bmp"
+    char *="Append a file created with mkv(i420,mjpeg,rgb24), avi(i420,mjpeg), raw capture output format"
+    data *^stage_files_read
+        #
+    import "stage_sound" stage_sound
+    char *="sound.bmp"
+    char *="Add sound to be used at mkv, avi(i420,mjpeg,mpg4-asp) or mp4 files"
+    data *^stage_sound
+        #
+    data *=0
+        #
+    import "capture" capture
+    char *="capture.bmp"
+    char *="Screen capture"
+    data *^capture
+        #
+    data *=0
+        #
+    import "stage_new_frame_form" stage_new_frame_form
+    char *="add.bmp"
+    char *="Add a new frame selecting width,height and color"
+    data *^stage_new_frame_form
+        #
+    import "stage_new_frame" stage_new_frame
+    char *="addfromfile.bmp"
+    char *="Add a new frame from a file"
+    data *^stage_new_frame
+        #
+    import "stage_remove" stage_remove
+    char *="remove.bmp"
+    char *="Remove the selected frame"
+    data *^stage_remove
+        #
+    import "mass_remove" mass_remove
+    char *="removeframes.bmp"
+    char *="Remove a frames interval"
+    data *^mass_remove
+        #
+    import "stage_frame_time" stage_frame_time
+    char *="ftime.bmp"
+    char *="Modify the frame time"
+    data *^stage_frame_time
+        #
+    import "stage_split_frame" stage_split_frame
+    char *="split.bmp"
+    char *="Split the selection into two parts"
+    data *^stage_split_frame
+        #
+    import "stage_frame_equalize" stage_frame_equalize
+    char *="equalize.bmp"
+    char *="Equalize the frames lengths starting with selection; last interval frame can be truncated"
+    data *^stage_frame_equalize
+        #
+    data *=0
+        #
+    import "stage_frame_panel_open" stage_frame_panel_open
+    char *="framepanel.bmp"
+    char *="Open the frame panel"
+    data *^stage_frame_panel_open
+        #
+    data *=0
+        #
+    import "stage_fade" stage_fade
+    char *="fade.bmp"
+    char *="Fade In/Fade Out effects"
+    data *^stage_fade
+        #
+    import "stage_move" stage_move
+    char *="move.bmp"
+    char *="Move In/Move Out effects"
+    data *^stage_move
+        #
+    import "stage_cover_panel_open" stage_cover_panel_open
+    char *="cover_effects.bmp"
+    char *="Uncover/Cover effects"
+    data *^stage_cover_panel_open
+        #
+    import "stage_effect_scale" stage_effect_scale
+    char *="scale_effect.bmp"
+    char *="Scale In/Scale Out effects"
+    data *^stage_effect_scale
+        #
+    data *=0
+        #
+    data *=0
+
+    sd ptr^button
+    import "buttons_lots" buttons_lots
+    call buttons_lots(ptr,container)
+endfunction
+
+
+
+
+
+
+
+
+import "stagewidget" stagewidget
+
+importx "_gtk_widget_destroy" gtk_widget_destroy
+
+#free pixbufs
+function unref_pixbuf_frame(sd widget,sd *data)
+    import "object_get_dword_name" object_get_dword_name
+    sd pixbuf
+    setcall pixbuf object_get_dword_name(widget)
+    importx "_g_object_unref" g_object_unref
+    call g_object_unref(pixbuf)
+endfunction
+
+
+#free pipe and pbufs
+function stage_container_destroy(sd object,sd *data)
+    data null=0
+    import "stage_get_pipeline" stage_get_pipeline
+    sd pipe
+    setcall pipe stage_get_pipeline()
+    if pipe!=null
+        import "default_unref" default_unref
+        call default_unref(pipe)
+    endif
+
+    importx "_gtk_container_foreach" gtk_container_foreach
+    data f^unref_pixbuf_frame
+    data n=0
+    call gtk_container_foreach(object,f,n)
+endfunction
+
+
+importx "_gtk_widget_set_sensitive" gtk_widget_set_sensitive
+
+import "stage_frame_time_numbers" stage_frame_time_numbers
+
+import "stage_sel_prepare_img_space" stage_sel_prepare_img_space
+
+function stage_scroll()
+    data scroll#1
+    return #scroll
+endfunction
+
+#clean the stage
+function stage_clean()
+    #delete the container and trigger the destroy signal for closing the pipeline and freeing the pixbufs
+    sd scroll
+    setcall scroll stage_scroll()
+    import "firstwidgetFromcontainer" firstwidgetFromcontainer
+    sd widget
+    setcall widget firstwidgetFromcontainer(scroll#)
+
+    #if exists only
+    if widget!=0
+##########################
+        #set selection to 0 to stop the redrawings
+        call stage_sel_prepare_img_space()
+        #destroy the frame container
+        call gtk_widget_destroy(widget)
+        #free frame lengths
+        call stage_frame_time_numbers((stage_frame_time_free))
+        #stop the preview
+        call stage_pause()
+        #free the sound
+        import "stage_sound_alloc_free" stage_sound_alloc_free
+        call stage_sound_alloc_free()
+############################
+    endif
+endfunction
+
+import "hboxfield_cnt" hboxfield_cnt
+import "vboxfield_pack" vboxfield_pack
+importx "_gtk_widget_show_all" gtk_widget_show_all
+import "hseparatorfield" hseparatorfield
+importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
+
+#prepare the stage
+function stage_prepare()
+    #clean previous if exists
+    call stage_clean()
+
+####################
+    #init the frame lengths
+    call stage_frame_time_numbers((stage_frame_time_init))
+
+    #init the sound container
+    import "stage_sound_alloc_init" stage_sound_alloc_init
+    call stage_sound_alloc_init()
+
+    #these two: the pipeline and the frames container, are initialized here and closed when the stage is closed
+    import "stage_set_pipeline" stage_set_pipeline
+    call stage_set_pipeline(0)
+
+    #visual for frames and sound
+    sd min_size
+    setcall min_size stage_trace_min_size_get()
+    importx "_gtk_vbox_new" gtk_vbox_new
+    import "container_add" container_add
+    sd ptr_scroll
+    setcall ptr_scroll stage_scroll()
+    sd scroll
+    set scroll ptr_scroll#
+    sd scroll_height
+    set scroll_height min_size
+    mult scroll_height 2
+    add scroll_height (10+10+10)
+    call gtk_widget_set_size_request(scroll,-1,scroll_height)
+    sd vbox
+    setcall vbox gtk_vbox_new(0,0)
+    call container_add(scroll,vbox)
+    #frames container
+    import "hseparatorfield_nopad" hseparatorfield_nopad
+    sd container
+    setcall container stage_get_frames_container_pointer()
+    import "hboxfield_prepare" hboxfield_prepare
+    import "packstart_default" packstart_default
+    setcall container# hboxfield_prepare()
+    call packstart_default(vbox,container#)
+    call gtk_widget_set_size_request(container#,-1,min_size)
+    import "connect_signal" connect_signal
+    str destroy="destroy"
+    data f^stage_container_destroy
+    call connect_signal(container#,destroy,f)
+    #separator
+    call hseparatorfield_nopad(vbox)
+    #sound pulse
+    import "eventboxfield" eventboxfield
+    sd ebox
+    sd pulseWidget
+    setcall pulseWidget sound_widget()
+    setcall pulseWidget# eventboxfield(vbox)
+    set ebox pulseWidget#
+    call gtk_widget_set_size_request(ebox,-1,min_size)
+    importx "_gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
+    str move_info="Hold the left mouse button and drag up to increase the size of the sound pulse or drag down to decrease the size"
+    call gtk_widget_set_tooltip_markup(ebox,move_info)
+        #on click is the pencil color point
+    str press="button-press-event"
+    data clickfunction^sound_widget_onclick
+    call connect_signal(ebox,press,clickfunction)
+        #on mouse moving
+    str motion="motion-notify-event"
+    data motionfunction^sound_widget_motion
+    call connect_signal(ebox,motion,motionfunction)
+        #
+    import "drawfield_cnt" drawfield_cnt
+    sd sound_pixbuf_draw_widget
+    setcall sound_pixbuf_draw_widget drawfield_cnt(ebox)
+    sd draw_area
+    setcall draw_area sound_pixbuf_draw_area()
+    set draw_area# sound_pixbuf_draw_widget
+    #separator
+    call hseparatorfield_nopad(vbox)
+    #show all for realize for get size at sound_pixbuf_paint, else: here showall vbox but for some rules showall scroll
+    import "mainwidget" mainwidget
+    sd mainwd
+    setcall mainwd mainwidget()
+    call gtk_widget_show_all(mainwd)
+        #continue at sound
+        #add the pulse pixbuf
+    sd pixbuf_location
+    setcall pixbuf_location sound_pixbuf()
+    set pixbuf_location# 0
+    call sound_pixbuf_paint()
+        #remove pixbuf at end
+    data sound_draw_dest^sound_widget_destroy
+    call connect_signal(sound_pixbuf_draw_widget,destroy,sound_draw_dest)
+        #expose the pixbuf
+    str expose="expose-event"
+    data exp^sound_widget_expose
+    call connect_signal(sound_pixbuf_draw_widget,expose,exp)
+
+    #set the sel frame to uninit, 0
+    call stage_sel_prepare_img_space()
+#######################
+endfunction
+function stage_get_frames_container_pointer()
+    data c#1
+    return #c
+endfunction
+function stage_get_frames_container()
+    sd c
+    setcall c stage_get_frames_container_pointer()
+    return c#
+endfunction
+
+#prepare a blank stage
+function stage_prepare_blank()
+    str new="Ready"
+    import "texter" texter
+    call texter(new)
+    call stage_prepare()
+endfunction
+
+#prepare the stage and start from the uri
+function stage_prepare_uri_start()
+    import "stage_frame_dialog_solo" stage_frame_dialog_solo
+    call stage_frame_dialog_solo(stage_prepare_uri_init,stage_prepare_uri_set,"Media from uri")
+endfunction
+function stage_prepare_uri_init(sd vbox)
+    importx "_gtk_table_new" gtk_table_new
+    importx "_gtk_table_attach" gtk_table_attach
+    sd table
+    setcall table gtk_table_new(2,2,(FALSE))
+
+    import "labelfield_left_prepare" labelfield_left_prepare
+    importx "_gtk_entry_new" gtk_entry_new
+    sd entry
+    sd store
+
+    setcall entry labelfield_left_prepare("Start frame")
+    call gtk_table_attach(table,entry,0,1,0,1,0,0,0,0)
+    setcall entry gtk_entry_new()
+    call gtk_table_attach(table,entry,1,2,0,1,(GTK_FILL),0,0,0)
+    setcall store stage_prepare_uri_first_entry()
+    set store# entry
+
+    setcall entry labelfield_left_prepare("Last frame")
+    call gtk_table_attach(table,entry,0,1,1,2,0,0,0,0)
+    setcall entry gtk_entry_new()
+    call gtk_table_attach(table,entry,1,2,1,2,(GTK_FILL),0,0,0)
+    setcall store stage_prepare_uri_last_entry()
+    set store# entry
+
+    importx "_gtk_container_add" gtk_container_add
+    call gtk_container_add(vbox,table)
+
+    import "labelfield_l" labelfield_l
+    call labelfield_l("Leave blank for no limit",vbox)
+endfunction
+function stage_prepare_uri_set()
+    sd f_entry
+    sd l_entry
+    setcall f_entry stage_prepare_uri_first_entry()
+    setcall l_entry stage_prepare_uri_last_entry()
+    ss text
+    sd len
+    sd first
+    sd last
+    setcall first stage_prepare_uri_first()
+    setcall last stage_prepare_uri_last()
+
+    importx "_gtk_entry_get_text" gtk_entry_get_text
+    import "strtoint_positive" strtoint_positive
+    import "slen" slen
+    sd bool
+    setcall text gtk_entry_get_text(f_entry#)
+    setcall len slen(text)
+    if len=0
+        set first# -1
+    else
+        setcall bool strtoint_positive(text,first)
+        if bool!=(TRUE)
+            return (void)
+        endif
+    endelse
+    setcall text gtk_entry_get_text(l_entry#)
+    setcall len slen(text)
+    if len=0
+        set last# -1
+    else
+        setcall bool strtoint_positive(text,last)
+        if bool!=(TRUE)
+            return (void)
+        endif
+    endelse
+    sd pos
+    setcall pos stage_prepare_uri_pos()
+    set pos# 0
+
+    call stage_prepare()
+    import "editWidgetBufferForward" editWidgetBufferForward
+    import "stage_start_pipe" stage_start_pipe
+    data nextFn^stage_start_pipe
+    call editWidgetBufferForward(nextFn)
+endfunction
+function stage_prepare_uri_first_entry()
+    data first#1
+    return #first
+endfunction
+function stage_prepare_uri_last_entry()
+    data last#1
+    return #last
+endfunction
+function stage_prepare_uri_first()
+    data first#1
+    return #first
+endfunction
+function stage_prepare_uri_last()
+    data last#1
+    return #last
+endfunction
+function stage_prepare_uri_pos()
+    data pos#1
+    return #pos
+endfunction
+
+#clicks
+#stage click
+function stage_start(data widget)
+const stage_button_const^widget
+    data null=0
+
+    #set the prepare button to disable state, can be reenabled if the prepare it's closed
+    call gtk_widget_set_sensitive(widget,null)
+
+    call stage_prepare_blank()
+
+    sd vbox
+    setcall vbox stagewidget()
+    call gtk_widget_show_all(vbox)
+endfunction
+
+
+#close click
+function stage_buttons_close(sd *button)
+    call stage_clean()
+
+    sd vbox
+    setcall vbox stagewidget()
+    importx "_gtk_widget_hide_all" gtk_widget_hide_all
+    call gtk_widget_hide_all(vbox)
+
+    data b%stage_button_const
+    data true=1
+    call gtk_widget_set_sensitive(b#,true)
+endfunction
+
+
+
+import "img_folder_enterleave_data" img_folder_enterleave_data
+import "folder_enterleave_data" folder_enterleave_data
+import "edit_folder" edit_folder
+
+import "move_to_share_v" move_to_share_v
+function img_edit_folder_enterleave_data(sd forward,sd data)
+	call move_to_share_v()
+	sd df
+	sd df2
+	set df forward
+	set df2 data
+	call img_folder_enterleave_data(edit_folder_enterleave_data_forward,#df)
+endfunction
+function edit_folder_enterleave_data_forward(sv data)
+	sd forward
+	set forward data#
+	add data :
+	call edit_folder_enterleave_data(forward,data#)
+endfunction
+
+#inits
+
+#at runtime
+#creates stage buttons
+function stage_buttons()
+    data stage_buttons_container#1
+    const stage_buttons_container_linker^stage_buttons_container
+
+    data f^stage_buttons_enter
+    call edit_folder_enterleave_data(f,stage_buttons_container)
+endfunction
+
+function edit_folder_enterleave_data(sd forward,sd data)
+    ss e
+    setcall e edit_folder()
+    call folder_enterleave_data(e,forward,data)
+endfunction
+
+#return: edit vbox
+function stage_init()
+    #add a vbox to the main window
+    import "boxwidget" boxwidget
+    sd mainbox
+    setcall mainbox boxwidget()
+    sd vbox
+    setcall vbox vboxfield_pack(mainbox)
+
+    #a separator
+    call hseparatorfield(vbox)
+
+    #scroll for frames/sound
+    import "scrollfield" scrollfield
+    sd scroll
+    setcall scroll stage_scroll()
+    setcall scroll# scrollfield(vbox)
+    importx "_gtk_scrolled_window_set_policy" gtk_scrolled_window_set_policy
+    data always=GTK_POLICY_ALWAYS
+    data auto=GTK_POLICY_AUTOMATIC
+
+    call gtk_scrolled_window_set_policy(scroll#,always,auto)
+
+    #alignment for buttons
+    import "alignmentfield" alignmentfield
+    data alignment#1
+    setcall alignment alignmentfield(vbox)
+    sd hbox%stage_buttons_container_linker
+    setcall hbox# hboxfield_cnt(alignment)
+
+    call stage_vbox(0,vbox)
+
+    return vbox
+endfunction
+
+function stage_vbox(sd part,sd value)
+    data vbox#1
+    if part=0
+        set vbox value
+    else
+        return vbox
+    endelse
+endfunction
+
+#new panel returned
+function stage_new_panel(sd lots,sd trigbutton,sd callbackfunc,sd callbackdata,sd closefunc)
+    sd vbox
+    setcall vbox stage_vbox(1)
+
+    import "linked_instance" linked_instance
+    sd newpanel
+    setcall newpanel linked_instance(vbox,lots,trigbutton,callbackfunc,callbackdata,closefunc)
+
+    import "widget_get_ancestor" widget_get_ancestor
+    sd ancestor
+    setcall ancestor widget_get_ancestor(trigbutton,vbox)
+
+    import "widget_position_in_container" widget_position_in_container
+    sd pos
+    setcall pos widget_position_in_container(ancestor,vbox)
+
+    importx "_gtk_box_reorder_child" gtk_box_reorder_child
+    call gtk_box_reorder_child(vbox,newpanel,pos)
+
+    return newpanel
+endfunction
+
+
+
+function stage_display_last()
+    import "stage_get_frames" stage_get_frames
+    sd pos
+    setcall pos stage_get_frames()
+
+    #display the selection
+    dec pos
+    import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
+    sd ebox
+    setcall ebox stage_nthwidgetFromcontainer(pos)
+    import "stage_display_pixbuf" stage_display_pixbuf
+    call stage_display_pixbuf(ebox)
+endfunction
+
+
+
+
+#######sound view
+
+function sound_widget()
+    data widget#1
+    return #widget
+endfunction
+
+importx "_gdk_window_get_height" gdk_window_get_height
+
+#min size ptr
+function stage_trace_min_size()
+    data min_size#1
+    return #min_size
+endfunction
+#min size
+function stage_trace_min_size_get()
+    sd sz
+    setcall sz stage_trace_min_size()
+    return sz#
+endfunction
+function stage_trace_min_size_set()
+    sd sz
+    setcall sz stage_trace_min_size()
+    setcall sz# stage_init_frame_sizes()
+endfunction
+#min size
+function stage_init_frame_sizes()
+    ss normalframe
+    import "unselectedframe" unselectedframe
+    setcall normalframe unselectedframe()
+    import "pixbuf_from_file" pixbuf_from_file
+    sd frame_width
+    setcall frame_width stage_frame_width()
+    #
+    sd pixbuf
+    setcall pixbuf pixbuf_from_file(normalframe)
+    if pixbuf=0
+        set frame_width# 10
+        return 25
+    endif
+    importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+    setcall frame_width# gdk_pixbuf_get_width(pixbuf)
+    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+    sd height
+    setcall height gdk_pixbuf_get_height(pixbuf)
+    add height 5
+    call g_object_unref(pixbuf)
+    return height
+endfunction
+#free size
+function sound_widget_free_size()
+    import "drawwidget" drawwidget
+    importx "_gtk_widget_get_window" gtk_widget_get_window
+    sd drawW
+    setcall drawW drawwidget()
+    #get size
+    sd drawWindow
+    setcall drawWindow gtk_widget_get_window(drawW)
+    sd height
+    setcall height gdk_window_get_height(drawWindow)
+    sub height 35
+    return height
+endfunction
+
+function sound_widget_last_point()
+    data last_point#1
+    return #last_point
+endfunction
+function sound_widget_last_point_set(sd value)
+    sd p
+    setcall p sound_widget_last_point()
+    set p# value
+endfunction
+function sound_widget_last_point_get()
+    sd p
+    setcall p sound_widget_last_point()
+    return p#
+endfunction
+
+import "eventbutton_get_coords" eventbutton_get_coords
+
+#bool false, continue events
+function sound_widget_onclick(sd *ebox,sd event,sd *data)
+    #set last point for resizing if mouse move
+    sd lp
+    setcall lp sound_widget_last_point()
+    call eventbutton_get_coords(event,lp)
+    return (TRUE)
+endfunction
+
+importx "_gtk_widget_size_request" gtk_widget_size_request
+#bool false to continue
+function sound_widget_motion(sd *widget,sd EventMotion,sd *data)
+    sd state
+    sd p_state^state
+    importx "_gdk_event_get_state" gdk_event_get_state
+    call gdk_event_get_state(EventMotion,p_state)
+    and state (GDK_BUTTON1_MASK)
+    if state!=0
+        #left is pressed, verify next step for resizing
+        sd current_point
+        call eventbutton_get_coords(EventMotion,#current_point)
+        sd last_point
+        setcall last_point sound_widget_last_point_get()
+        #new size will be dif+old size, dif can also be negative
+        sd dif
+        set dif current_point
+        sub dif last_point
+        #up is bigger down is smaller
+        mult dif -1
+        #
+        sd sd_wid
+        setcall sd_wid sound_widget()
+        sd width
+        sd height
+        sd requisition^width
+        call gtk_widget_size_request(sd_wid#,requisition)
+        #
+        add height dif
+        #verify with the limits
+        sd min_size
+        setcall min_size stage_trace_min_size_get()
+        if height<min_size
+            return (TRUE)
+        endif
+        sd free_space
+        setcall free_space sound_widget_free_size()
+        if dif>free_space
+            return (TRUE)
+        endif
+        #ok to resize
+        #resize the sound box
+        call sound_widget_last_point_set(current_point)
+        call gtk_widget_set_size_request(sd_wid#,-1,height)
+        #resize the scroll ancestor
+        sd scroll
+        setcall scroll stage_scroll()
+        sd wd
+        sd hg
+        sd req^wd
+        call gtk_widget_size_request(scroll#,req)
+        add hg dif
+        call gtk_widget_set_size_request(scroll#,wd,hg)
+        #paint the pixbuf
+        call sound_pixbuf_paint()
+    endif
+    return (TRUE)
+endfunction
+
+function sound_widget_destroy()
+    sd pixbuf_location
+    setcall pixbuf_location sound_pixbuf()
+    if pixbuf_location#!=0
+        call g_object_unref(pixbuf_location#)
+    endif
+endfunction
+
+import "fild" fild
+#true to not propagate
+function sound_widget_expose(sd drawWd,sd ev_expose,sd *data)
+    sd pixbuf_location
+    setcall pixbuf_location sound_pixbuf()
+    sd pixbuf
+    set pixbuf pixbuf_location#
+    if pixbuf!=0
+        importx "_gdk_cairo_create" gdk_cairo_create
+        importx "_gdk_cairo_set_source_pixbuf" gdk_cairo_set_source_pixbuf
+        importx "_cairo_paint" cairo_paint
+        importx "_cairo_destroy" cairo_destroy
+        import "structure_get_int" structure_get_int
+
+        sd left
+        setcall left structure_get_int(ev_expose,(ev_expose_left))
+        sd width
+        setcall width structure_get_int(ev_expose,(ev_expose_width))
+        sd px_width
+        setcall px_width gdk_pixbuf_get_width(pixbuf)
+        sd px_height
+        setcall px_height gdk_pixbuf_get_height(pixbuf)
+
+        sd right
+        set right left
+        add right width
+        if right>px_width
+            set width px_width
+            sub width left
+        endif
+
+        #width can come wrong
+        if width<=0
+            return (TRUE)
+        endif
+        importx "_gdk_pixbuf_new_subpixbuf" gdk_pixbuf_new_subpixbuf
+        sd expose_pixbuf
+        setcall expose_pixbuf gdk_pixbuf_new_subpixbuf(pixbuf,left,0,width,px_height)
+        if expose_pixbuf!=0
+            import "fstp_quad" fstp_quad
+            sd double_x_low
+            sd double_x_high
+            call fild(#left)
+            call fstp_quad(#double_x_low)
+
+            sd window
+            setcall window gtk_widget_get_window(drawWd)
+            sd cairo
+            setcall cairo gdk_cairo_create(window)
+                                             #cr    px    double x                   double y
+            call gdk_cairo_set_source_pixbuf(cairo,expose_pixbuf,double_x_low,double_x_high,0,0)
+            call cairo_paint(cairo)
+            call cairo_destroy(cairo)
+
+            call g_object_unref(expose_pixbuf)
+        endif
+    endif
+    return (FALSE)
+endfunction
+
+
+#painting the pulse pixbuf
+
+function sound_pixbuf()
+    data pixbuf#1
+    return #pixbuf
+endfunction
+
+function stage_frame_width()
+    data frame_size#1
+    return #frame_size
+endfunction
+
+function sound_pixbuf_draw_area()
+    data draw_area#1
+    return #draw_area
+endfunction
+
+function sound_pixbuf_redraw()
+    call sound_pixbuf_paint()
+    sd px
+    setcall px sound_pixbuf()
+    if px#!=0
+        import "widget_redraw" widget_redraw
+        sd draw
+        setcall draw sound_pixbuf_draw_area()
+        sd px_width
+        setcall px_width gdk_pixbuf_get_width(px#)
+        call gtk_widget_set_size_request(draw#,px_width,-1)
+        call widget_redraw(draw#)
+    endif
+endfunction
+
+function sound_pixbuf_paint()
+    sd width
+    sd height
+    sd soundWd
+    setcall soundWd sound_widget()
+    sd requisition^width
+    call gtk_widget_size_request(soundWd#,requisition)
+    #
+    import "stage_sound_subsize" stage_sound_subsize
+    import "stage_file_options_fps" stage_file_options_fps
+    sd fps
+    sd sound_size
+    setcall fps stage_file_options_fps()
+    setcall sound_size stage_sound_subsize((value_get))
+    #
+    import "stage_sound_blockalign" stage_sound_blockalign
+    import "stage_sound_rate" stage_sound_rate
+    sd all_samples
+    set all_samples sound_size
+    divcall all_samples stage_sound_blockalign()
+    #
+    import "stage_sound_channels" stage_sound_channels
+    import "stage_sound_bps" stage_sound_bps
+    sd nr_of_channels
+    setcall nr_of_channels stage_sound_channels((value_get))
+    sd sample_rate
+    setcall sample_rate stage_sound_rate((value_get))
+    sd bps
+    setcall bps stage_sound_bps((value_get))
+    if bps!=8
+        if bps!=16
+            return (void)
+        endif
+    endif
+    #
+    sd frame_width
+    setcall frame_width stage_frame_width()
+    sd a_second_video_width
+    set a_second_video_width frame_width#
+    mult a_second_video_width fps
+    #width=all_samples x a_second_video_width
+    #      sample_rate
+    import "fimul" fimul
+    import "fidiv" fidiv
+    import "fst_quad" fst_quad
+    import "fistp" fistp
+    import "fmul_quad" fmul_quad
+    #store the fraction for fast use
+    sd fraction#2
+    call fild(#a_second_video_width)
+    call fidiv(#sample_rate)
+    call fst_quad(#fraction)
+    #
+    call fimul(#all_samples)
+    call fistp(#width)
+    #rounding AND to see the area at 0
+    add width 10
+    #
+    import "new_pixbuf" new_pixbuf
+    sd pixbuf
+    setcall pixbuf new_pixbuf(width,height)
+    if pixbuf!=0
+        importx "_gdk_pixbuf_fill" gdk_pixbuf_fill
+        call gdk_pixbuf_fill(pixbuf,0xffFFffFF)
+        #sound pulse
+        #draw all samples
+        import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
+
+        ss sound_bytes_cursor
+        setcall sound_bytes_cursor stage_sound_alloc_getbytes()
+
+        sd bytespersample
+        set bytespersample bps
+        div bytespersample 8
+        #
+        importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+        import "rgb_get_rowstride" rgb_get_rowstride
+        sd half
+        set half height
+        div half 2
+        sd pixels
+        setcall pixels gdk_pixbuf_get_pixels(pixbuf)
+        sd stride
+        setcall stride rgb_get_rowstride(width)
+        sd x
+        sd y
+        sd value
+        sd value_max
+        sd y_sens
+        #
+        sd i=0
+        while i!=all_samples
+            call fild(#i)
+            call fmul_quad(#fraction)
+            call fistp(#x)
+            sd channels=0
+            while channels!=nr_of_channels
+                if bps=8
+                    set value_max 0x7f
+                    set value sound_bytes_cursor#
+                    if value>=0x80
+                        sub value 0x80
+                        set y_sens -1
+                    else
+                        #flip the value
+                        mult value -1
+                        add value 0x7f
+                        set y_sens 1
+                    endelse
+                    inc sound_bytes_cursor
+                else
+                #if bps==16
+                    import "short_get_to_int" short_get_to_int
+                    set value_max 0x7fFF
+                    setcall value short_get_to_int(sound_bytes_cursor)
+                    if value>=0
+                        set y_sens -1
+                    else
+                        mult value -1
+                        dec value
+                        set y_sens 1
+                    endelse
+                    add sound_bytes_cursor 2
+                endelse
+                #a     value
+                #half  value_max
+                sd number
+                set number value
+                mult number half
+                div number value_max
+                mult number y_sens
+
+                sd y_last
+                set y_last half
+                add y_last number
+
+                set y half
+                if y=y_last
+                    #do at least a dot
+                    add y_last y_sens
+                endif
+
+                while y!=y_last
+                    #
+                    ss pixels_cursor
+                    set pixels_cursor pixels
+                    sd rows
+                    set rows y
+                    mult rows stride
+                    add pixels_cursor rows
+                    sd lines
+                    set lines x
+                    mult lines 3
+                    add pixels_cursor lines
+                    set pixels_cursor# 0
+                    inc pixels_cursor
+                    set pixels_cursor# 0
+                    inc pixels_cursor
+                    set pixels_cursor# 0
+                    #
+                    add y y_sens
+               endwhile
+               inc channels
+           endwhile
+           inc i
+        endwhile
+        #set for expose
+        sd pixbuf_location
+        setcall pixbuf_location sound_pixbuf()
+        if pixbuf_location#!=0
+            call g_object_unref(pixbuf_location#)
+        endif
+        set pixbuf_location# pixbuf
+    endif
+endfunction
--- ovideo-1.orig/src/_prepare/view.s
+++ /dev/null
@@ -1,1030 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-#inits
-
-function stage_buttons_enter(sd container)
-        #newuri
-    char button="new.bmp"
-    char *="Creates a blank new media"
-    data *^stage_prepare_blank
-        #
-    char *="newuri.bmp"
-    char *="Open the media from the uri bar"
-    data *^stage_prepare_uri_start
-        #
-    import "stage_preview" stage_preview
-    char *="preview.bmp"
-    char *="Preview the stage"
-    data *^stage_preview
-        #
-    import "stage_pause" stage_pause
-    char *="pause.bmp"
-    char *="Pause the preview"
-    data *^stage_pause
-        #
-    char *="close.bmp"
-    char *="Close the stage bar"
-    data *^stage_buttons_close
-        #
-    data *=0
-        #
-    import "stage_save_all" stage_save_all
-    char *="file.bmp"
-    char *="Save the stage to a file"
-    data *^stage_save_all
-        #
-    import "av_expand" av_expand
-    char *="expand.bmp"
-    char *="Expand a mp4 or avi(i420,mjpeg,mpg4-asp) file"
-    data *^av_expand
-        #
-    import "stage_file_options" stage_file_options
-    char *="fileoptions.bmp"
-    char *="Set the stage file options"
-    data *^stage_file_options
-        #
-    data *=0
-        #
-    import "stage_files_read" stage_files_read
-    char *="open.bmp"
-    char *="Append a file created with mkv(i420,mjpeg,rgb24), avi(i420,mjpeg), raw capture output format"
-    data *^stage_files_read
-        #
-    import "stage_sound" stage_sound
-    char *="sound.bmp"
-    char *="Add sound to be used at mkv, avi(i420,mjpeg,mpg4-asp) or mp4 files"
-    data *^stage_sound
-        #
-    data *=0
-        #
-    import "capture" capture
-    char *="capture.bmp"
-    char *="Screen capture"
-    data *^capture
-        #
-    data *=0
-        #
-    import "stage_new_frame_form" stage_new_frame_form
-    char *="add.bmp"
-    char *="Add a new frame selecting width,height and color"
-    data *^stage_new_frame_form
-        #
-    import "stage_new_frame" stage_new_frame
-    char *="addfromfile.bmp"
-    char *="Add a new frame from a file"
-    data *^stage_new_frame
-        #
-    import "stage_remove" stage_remove
-    char *="remove.bmp"
-    char *="Remove the selected frame"
-    data *^stage_remove
-        #
-    import "mass_remove" mass_remove
-    char *="removeframes.bmp"
-    char *="Remove a frames interval"
-    data *^mass_remove
-        #
-    import "stage_frame_time" stage_frame_time
-    char *="ftime.bmp"
-    char *="Modify the frame time"
-    data *^stage_frame_time
-        #
-    import "stage_split_frame" stage_split_frame
-    char *="split.bmp"
-    char *="Split the selection into two parts"
-    data *^stage_split_frame
-        #
-    import "stage_frame_equalize" stage_frame_equalize
-    char *="equalize.bmp"
-    char *="Equalize the frames lengths starting with selection; last interval frame can be truncated"
-    data *^stage_frame_equalize
-        #
-    data *=0
-        #
-    import "stage_frame_panel_open" stage_frame_panel_open
-    char *="framepanel.bmp"
-    char *="Open the frame panel"
-    data *^stage_frame_panel_open
-        #
-    data *=0
-        #
-    import "stage_fade" stage_fade
-    char *="fade.bmp"
-    char *="Fade In/Fade Out effects"
-    data *^stage_fade
-        #
-    import "stage_move" stage_move
-    char *="move.bmp"
-    char *="Move In/Move Out effects"
-    data *^stage_move
-        #
-    import "stage_cover_panel_open" stage_cover_panel_open
-    char *="cover_effects.bmp"
-    char *="Uncover/Cover effects"
-    data *^stage_cover_panel_open
-        #
-    import "stage_effect_scale" stage_effect_scale
-    char *="scale_effect.bmp"
-    char *="Scale In/Scale Out effects"
-    data *^stage_effect_scale
-        #
-    data *=0
-        #
-    data *=0
-
-    sd ptr^button
-    import "buttons_lots" buttons_lots
-    call buttons_lots(ptr,container)
-endfunction
-
-
-
-
-
-
-
-
-import "stagewidget" stagewidget
-
-importx "_gtk_widget_destroy" gtk_widget_destroy
-
-#free pixbufs
-function unref_pixbuf_frame(sd widget,sd *data)
-    import "object_get_dword_name" object_get_dword_name
-    sd pixbuf
-    setcall pixbuf object_get_dword_name(widget)
-    importx "_g_object_unref" g_object_unref
-    call g_object_unref(pixbuf)
-endfunction
-
-
-#free pipe and pbufs
-function stage_container_destroy(sd object,sd *data)
-    data null=0
-    import "stage_get_pipeline" stage_get_pipeline
-    sd pipe
-    setcall pipe stage_get_pipeline()
-    if pipe!=null
-        import "default_unref" default_unref
-        call default_unref(pipe)
-    endif
-
-    importx "_gtk_container_foreach" gtk_container_foreach
-    data f^unref_pixbuf_frame
-    data n=0
-    call gtk_container_foreach(object,f,n)
-endfunction
-
-
-importx "_gtk_widget_set_sensitive" gtk_widget_set_sensitive
-
-import "stage_frame_time_numbers" stage_frame_time_numbers
-
-import "stage_sel_prepare_img_space" stage_sel_prepare_img_space
-
-function stage_scroll()
-    data scroll#1
-    return #scroll
-endfunction
-
-#clean the stage
-function stage_clean()
-    #delete the container and trigger the destroy signal for closing the pipeline and freeing the pixbufs
-    sd scroll
-    setcall scroll stage_scroll()
-    import "firstwidgetFromcontainer" firstwidgetFromcontainer
-    sd widget
-    setcall widget firstwidgetFromcontainer(scroll#)
-
-    #if exists only
-    if widget!=0
-##########################
-        #set selection to 0 to stop the redrawings
-        call stage_sel_prepare_img_space()
-        #destroy the frame container
-        call gtk_widget_destroy(widget)
-        #free frame lengths
-        call stage_frame_time_numbers((stage_frame_time_free))
-        #stop the preview
-        call stage_pause()
-        #free the sound
-        import "stage_sound_alloc_free" stage_sound_alloc_free
-        call stage_sound_alloc_free()
-############################
-    endif
-endfunction
-
-import "hboxfield_cnt" hboxfield_cnt
-import "vboxfield_pack" vboxfield_pack
-importx "_gtk_widget_show_all" gtk_widget_show_all
-import "hseparatorfield" hseparatorfield
-importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
-
-#prepare the stage
-function stage_prepare()
-    #clean previous if exists
-    call stage_clean()
-
-####################
-    #init the frame lengths
-    call stage_frame_time_numbers((stage_frame_time_init))
-
-    #init the sound container
-    import "stage_sound_alloc_init" stage_sound_alloc_init
-    call stage_sound_alloc_init()
-
-    #these two: the pipeline and the frames container, are initialized here and closed when the stage is closed
-    import "stage_set_pipeline" stage_set_pipeline
-    call stage_set_pipeline(0)
-
-    #visual for frames and sound
-    sd min_size
-    setcall min_size stage_trace_min_size_get()
-    importx "_gtk_vbox_new" gtk_vbox_new
-    import "container_add" container_add
-    sd ptr_scroll
-    setcall ptr_scroll stage_scroll()
-    sd scroll
-    set scroll ptr_scroll#
-    sd scroll_height
-    set scroll_height min_size
-    mult scroll_height 2
-    add scroll_height (10+10+10)
-    call gtk_widget_set_size_request(scroll,-1,scroll_height)
-    sd vbox
-    setcall vbox gtk_vbox_new(0,0)
-    call container_add(scroll,vbox)
-    #frames container
-    import "hseparatorfield_nopad" hseparatorfield_nopad
-    sd container
-    setcall container stage_get_frames_container_pointer()
-    import "hboxfield_prepare" hboxfield_prepare
-    import "packstart_default" packstart_default
-    setcall container# hboxfield_prepare()
-    call packstart_default(vbox,container#)
-    call gtk_widget_set_size_request(container#,-1,min_size)
-    import "connect_signal" connect_signal
-    str destroy="destroy"
-    data f^stage_container_destroy
-    call connect_signal(container#,destroy,f)
-    #separator
-    call hseparatorfield_nopad(vbox)
-    #sound pulse
-    import "eventboxfield" eventboxfield
-    sd ebox
-    sd pulseWidget
-    setcall pulseWidget sound_widget()
-    setcall pulseWidget# eventboxfield(vbox)
-    set ebox pulseWidget#
-    call gtk_widget_set_size_request(ebox,-1,min_size)
-    importx "_gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
-    str move_info="Hold the left mouse button and drag up to increase the size of the sound pulse or drag down to decrease the size"
-    call gtk_widget_set_tooltip_markup(ebox,move_info)
-        #on click is the pencil color point
-    str press="button-press-event"
-    data clickfunction^sound_widget_onclick
-    call connect_signal(ebox,press,clickfunction)
-        #on mouse moving
-    str motion="motion-notify-event"
-    data motionfunction^sound_widget_motion
-    call connect_signal(ebox,motion,motionfunction)
-        #
-    import "drawfield_cnt" drawfield_cnt
-    sd sound_pixbuf_draw_widget
-    setcall sound_pixbuf_draw_widget drawfield_cnt(ebox)
-    sd draw_area
-    setcall draw_area sound_pixbuf_draw_area()
-    set draw_area# sound_pixbuf_draw_widget
-    #separator
-    call hseparatorfield_nopad(vbox)
-    #show all for realize for get size at sound_pixbuf_paint, else: here showall vbox but for some rules showall scroll
-    import "mainwidget" mainwidget
-    sd mainwd
-    setcall mainwd mainwidget()
-    call gtk_widget_show_all(mainwd)
-        #continue at sound
-        #add the pulse pixbuf
-    sd pixbuf_location
-    setcall pixbuf_location sound_pixbuf()
-    set pixbuf_location# 0
-    call sound_pixbuf_paint()
-        #remove pixbuf at end
-    data sound_draw_dest^sound_widget_destroy
-    call connect_signal(sound_pixbuf_draw_widget,destroy,sound_draw_dest)
-        #expose the pixbuf
-    str expose="expose-event"
-    data exp^sound_widget_expose
-    call connect_signal(sound_pixbuf_draw_widget,expose,exp)
-
-    #set the sel frame to uninit, 0
-    call stage_sel_prepare_img_space()
-#######################
-endfunction
-function stage_get_frames_container_pointer()
-    data c#1
-    return #c
-endfunction
-function stage_get_frames_container()
-    sd c
-    setcall c stage_get_frames_container_pointer()
-    return c#
-endfunction
-
-#prepare a blank stage
-function stage_prepare_blank()
-    str new="Ready"
-    import "texter" texter
-    call texter(new)
-    call stage_prepare()
-endfunction
-
-#prepare the stage and start from the uri
-function stage_prepare_uri_start()
-    import "stage_frame_dialog_solo" stage_frame_dialog_solo
-    call stage_frame_dialog_solo(stage_prepare_uri_init,stage_prepare_uri_set,"Media from uri")
-endfunction
-function stage_prepare_uri_init(sd vbox)
-    importx "_gtk_table_new" gtk_table_new
-    importx "_gtk_table_attach" gtk_table_attach
-    sd table
-    setcall table gtk_table_new(2,2,(FALSE))
-
-    import "labelfield_left_prepare" labelfield_left_prepare
-    importx "_gtk_entry_new" gtk_entry_new
-    sd entry
-    sd store
-
-    setcall entry labelfield_left_prepare("Start frame")
-    call gtk_table_attach(table,entry,0,1,0,1,0,0,0,0)
-    setcall entry gtk_entry_new()
-    call gtk_table_attach(table,entry,1,2,0,1,(GTK_FILL),0,0,0)
-    setcall store stage_prepare_uri_first_entry()
-    set store# entry
-
-    setcall entry labelfield_left_prepare("Last frame")
-    call gtk_table_attach(table,entry,0,1,1,2,0,0,0,0)
-    setcall entry gtk_entry_new()
-    call gtk_table_attach(table,entry,1,2,1,2,(GTK_FILL),0,0,0)
-    setcall store stage_prepare_uri_last_entry()
-    set store# entry
-
-    importx "_gtk_container_add" gtk_container_add
-    call gtk_container_add(vbox,table)
-
-    import "labelfield_l" labelfield_l
-    call labelfield_l("Leave blank for no limit",vbox)
-endfunction
-function stage_prepare_uri_set()
-    sd f_entry
-    sd l_entry
-    setcall f_entry stage_prepare_uri_first_entry()
-    setcall l_entry stage_prepare_uri_last_entry()
-    ss text
-    sd len
-    sd first
-    sd last
-    setcall first stage_prepare_uri_first()
-    setcall last stage_prepare_uri_last()
-
-    importx "_gtk_entry_get_text" gtk_entry_get_text
-    import "strtoint_positive" strtoint_positive
-    import "slen" slen
-    sd bool
-    setcall text gtk_entry_get_text(f_entry#)
-    setcall len slen(text)
-    if len==0
-        set first# -1
-    else
-        setcall bool strtoint_positive(text,first)
-        if bool!=(TRUE)
-            return (void)
-        endif
-    endelse
-    setcall text gtk_entry_get_text(l_entry#)
-    setcall len slen(text)
-    if len==0
-        set last# -1
-    else
-        setcall bool strtoint_positive(text,last)
-        if bool!=(TRUE)
-            return (void)
-        endif
-    endelse
-    sd pos
-    setcall pos stage_prepare_uri_pos()
-    set pos# 0
-
-    call stage_prepare()
-    import "editWidgetBufferForward" editWidgetBufferForward
-    import "stage_start_pipe" stage_start_pipe
-    data nextFn^stage_start_pipe
-    call editWidgetBufferForward(nextFn)
-endfunction
-function stage_prepare_uri_first_entry()
-    data first#1
-    return #first
-endfunction
-function stage_prepare_uri_last_entry()
-    data last#1
-    return #last
-endfunction
-function stage_prepare_uri_first()
-    data first#1
-    return #first
-endfunction
-function stage_prepare_uri_last()
-    data last#1
-    return #last
-endfunction
-function stage_prepare_uri_pos()
-    data pos#1
-    return #pos
-endfunction
-
-#clicks
-#stage click
-function stage_start(data widget)
-const stage_button_const^widget
-    data null=0
-
-    #set the prepare button to disable state, can be reenabled if the prepare it's closed
-    call gtk_widget_set_sensitive(widget,null)
-
-    call stage_prepare_blank()
-
-    sd vbox
-    setcall vbox stagewidget()
-    call gtk_widget_show_all(vbox)
-endfunction
-
-
-#close click
-function stage_buttons_close(sd *button)
-    call stage_clean()
-
-    sd vbox
-    setcall vbox stagewidget()
-    importx "_gtk_widget_hide_all" gtk_widget_hide_all
-    call gtk_widget_hide_all(vbox)
-
-    data b%stage_button_const
-    data true=1
-    call gtk_widget_set_sensitive(b#,true)
-endfunction
-
-
-
-import "img_folder_enterleave_data" img_folder_enterleave_data
-import "folder_enterleave_data" folder_enterleave_data
-import "edit_folder" edit_folder
-
-import "move_to_share_v" move_to_share_v
-function img_edit_folder_enterleave_data(sd forward,sd data)
-	call move_to_share_v()
-	sd df
-	sd df2
-	set df forward
-	set df2 data
-	call img_folder_enterleave_data(edit_folder_enterleave_data_forward,#df)
-endfunction
-function edit_folder_enterleave_data_forward(sv data)
-	sd forward
-	set forward data#
-	add data :
-	call edit_folder_enterleave_data(forward,data#)
-endfunction
-
-#inits
-
-#at runtime
-#creates stage buttons
-function stage_buttons()
-    data stage_buttons_container#1
-    const stage_buttons_container_linker^stage_buttons_container
-
-    data f^stage_buttons_enter
-    call edit_folder_enterleave_data(f,stage_buttons_container)
-endfunction
-
-function edit_folder_enterleave_data(sd forward,sd data)
-    ss e
-    setcall e edit_folder()
-    call folder_enterleave_data(e,forward,data)
-endfunction
-
-#return: edit vbox
-function stage_init()
-    #add a vbox to the main window
-    import "boxwidget" boxwidget
-    sd mainbox
-    setcall mainbox boxwidget()
-    sd vbox
-    setcall vbox vboxfield_pack(mainbox)
-
-    #a separator
-    call hseparatorfield(vbox)
-
-    #scroll for frames/sound
-    import "scrollfield" scrollfield
-    sd scroll
-    setcall scroll stage_scroll()
-    setcall scroll# scrollfield(vbox)
-    importx "_gtk_scrolled_window_set_policy" gtk_scrolled_window_set_policy
-    data always=GTK_POLICY_ALWAYS
-    data auto=GTK_POLICY_AUTOMATIC
-
-    call gtk_scrolled_window_set_policy(scroll#,always,auto)
-
-    #alignment for buttons
-    import "alignmentfield" alignmentfield
-    data alignment#1
-    setcall alignment alignmentfield(vbox)
-    sd hbox%stage_buttons_container_linker
-    setcall hbox# hboxfield_cnt(alignment)
-
-    call stage_vbox(0,vbox)
-
-    return vbox
-endfunction
-
-function stage_vbox(sd part,sd value)
-    data vbox#1
-    if part==0
-        set vbox value
-    else
-        return vbox
-    endelse
-endfunction
-
-#new panel returned
-function stage_new_panel(sd lots,sd trigbutton,sd callbackfunc,sd callbackdata,sd closefunc)
-    sd vbox
-    setcall vbox stage_vbox(1)
-
-    import "linked_instance" linked_instance
-    sd newpanel
-    setcall newpanel linked_instance(vbox,lots,trigbutton,callbackfunc,callbackdata,closefunc)
-
-    import "widget_get_ancestor" widget_get_ancestor
-    sd ancestor
-    setcall ancestor widget_get_ancestor(trigbutton,vbox)
-
-    import "widget_position_in_container" widget_position_in_container
-    sd pos
-    setcall pos widget_position_in_container(ancestor,vbox)
-
-    importx "_gtk_box_reorder_child" gtk_box_reorder_child
-    call gtk_box_reorder_child(vbox,newpanel,pos)
-
-    return newpanel
-endfunction
-
-
-
-function stage_display_last()
-    import "stage_get_frames" stage_get_frames
-    sd pos
-    setcall pos stage_get_frames()
-
-    #display the selection
-    dec pos
-    import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
-    sd ebox
-    setcall ebox stage_nthwidgetFromcontainer(pos)
-    import "stage_display_pixbuf" stage_display_pixbuf
-    call stage_display_pixbuf(ebox)
-endfunction
-
-
-
-
-#######sound view
-
-function sound_widget()
-    data widget#1
-    return #widget
-endfunction
-
-importx "_gdk_window_get_height" gdk_window_get_height
-
-#min size ptr
-function stage_trace_min_size()
-    data min_size#1
-    return #min_size
-endfunction
-#min size
-function stage_trace_min_size_get()
-    sd sz
-    setcall sz stage_trace_min_size()
-    return sz#
-endfunction
-function stage_trace_min_size_set()
-    sd sz
-    setcall sz stage_trace_min_size()
-    setcall sz# stage_init_frame_sizes()
-endfunction
-#min size
-function stage_init_frame_sizes()
-    ss normalframe
-    import "unselectedframe" unselectedframe
-    setcall normalframe unselectedframe()
-    import "pixbuf_from_file" pixbuf_from_file
-    sd frame_width
-    setcall frame_width stage_frame_width()
-    #
-    sd pixbuf
-    setcall pixbuf pixbuf_from_file(normalframe)
-    if pixbuf==0
-        set frame_width# 10
-        return 25
-    endif
-    importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-    setcall frame_width# gdk_pixbuf_get_width(pixbuf)
-    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-    sd height
-    setcall height gdk_pixbuf_get_height(pixbuf)
-    add height 5
-    call g_object_unref(pixbuf)
-    return height
-endfunction
-#free size
-function sound_widget_free_size()
-    import "drawwidget" drawwidget
-    importx "_gtk_widget_get_window" gtk_widget_get_window
-    sd drawW
-    setcall drawW drawwidget()
-    #get size
-    sd drawWindow
-    setcall drawWindow gtk_widget_get_window(drawW)
-    sd height
-    setcall height gdk_window_get_height(drawWindow)
-    sub height 35
-    return height
-endfunction
-
-function sound_widget_last_point()
-    data last_point#1
-    return #last_point
-endfunction
-function sound_widget_last_point_set(sd value)
-    sd p
-    setcall p sound_widget_last_point()
-    set p# value
-endfunction
-function sound_widget_last_point_get()
-    sd p
-    setcall p sound_widget_last_point()
-    return p#
-endfunction
-
-import "eventbutton_get_coords" eventbutton_get_coords
-
-#bool false, continue events
-function sound_widget_onclick(sd *ebox,sd event,sd *data)
-    #set last point for resizing if mouse move
-    sd lp
-    setcall lp sound_widget_last_point()
-    call eventbutton_get_coords(event,lp)
-    return (TRUE)
-endfunction
-
-importx "_gtk_widget_size_request" gtk_widget_size_request
-#bool false to continue
-function sound_widget_motion(sd *widget,sd EventMotion,sd *data)
-    sd state
-    sd p_state^state
-    importx "_gdk_event_get_state" gdk_event_get_state
-    call gdk_event_get_state(EventMotion,p_state)
-    and state (GDK_BUTTON1_MASK)
-    if state!=0
-        #left is pressed, verify next step for resizing
-        sd current_point
-        call eventbutton_get_coords(EventMotion,#current_point)
-        sd last_point
-        setcall last_point sound_widget_last_point_get()
-        #new size will be dif+old size, dif can also be negative
-        sd dif
-        set dif current_point
-        sub dif last_point
-        #up is bigger down is smaller
-        mult dif -1
-        #
-        sd sd_wid
-        setcall sd_wid sound_widget()
-        sd width
-        sd height
-        sd requisition^width
-        call gtk_widget_size_request(sd_wid#,requisition)
-        #
-        add height dif
-        #verify with the limits
-        sd min_size
-        setcall min_size stage_trace_min_size_get()
-        if height<min_size
-            return (TRUE)
-        endif
-        sd free_space
-        setcall free_space sound_widget_free_size()
-        if dif>free_space
-            return (TRUE)
-        endif
-        #ok to resize
-        #resize the sound box
-        call sound_widget_last_point_set(current_point)
-        call gtk_widget_set_size_request(sd_wid#,-1,height)
-        #resize the scroll ancestor
-        sd scroll
-        setcall scroll stage_scroll()
-        sd wd
-        sd hg
-        sd req^wd
-        call gtk_widget_size_request(scroll#,req)
-        add hg dif
-        call gtk_widget_set_size_request(scroll#,wd,hg)
-        #paint the pixbuf
-        call sound_pixbuf_paint()
-    endif
-    return (TRUE)
-endfunction
-
-function sound_widget_destroy()
-    sd pixbuf_location
-    setcall pixbuf_location sound_pixbuf()
-    if pixbuf_location#!=0
-        call g_object_unref(pixbuf_location#)
-    endif
-endfunction
-
-import "fild" fild
-#true to not propagate
-function sound_widget_expose(sd drawWd,sd ev_expose,sd *data)
-    sd pixbuf_location
-    setcall pixbuf_location sound_pixbuf()
-    sd pixbuf
-    set pixbuf pixbuf_location#
-    if pixbuf!=0
-        importx "_gdk_cairo_create" gdk_cairo_create
-        importx "_gdk_cairo_set_source_pixbuf" gdk_cairo_set_source_pixbuf
-        importx "_cairo_paint" cairo_paint
-        importx "_cairo_destroy" cairo_destroy
-        import "structure_get_int" structure_get_int
-
-        sd left
-        setcall left structure_get_int(ev_expose,(ev_expose_left))
-        sd width
-        setcall width structure_get_int(ev_expose,(ev_expose_width))
-        sd px_width
-        setcall px_width gdk_pixbuf_get_width(pixbuf)
-        sd px_height
-        setcall px_height gdk_pixbuf_get_height(pixbuf)
-
-        sd right
-        set right left
-        add right width
-        if right>px_width
-            set width px_width
-            sub width left
-        endif
-
-        #width can come wrong
-        if width<=0
-            return (TRUE)
-        endif
-        importx "_gdk_pixbuf_new_subpixbuf" gdk_pixbuf_new_subpixbuf
-        sd expose_pixbuf
-        setcall expose_pixbuf gdk_pixbuf_new_subpixbuf(pixbuf,left,0,width,px_height)
-        if expose_pixbuf!=0
-            import "fstp_quad" fstp_quad
-            sd double_x_low
-            sd double_x_high
-            call fild(#left)
-            call fstp_quad(#double_x_low)
-
-            sd window
-            setcall window gtk_widget_get_window(drawWd)
-            sd cairo
-            setcall cairo gdk_cairo_create(window)
-                                             #cr    px    double x                   double y
-            call gdk_cairo_set_source_pixbuf(cairo,expose_pixbuf,double_x_low,double_x_high,0,0)
-            call cairo_paint(cairo)
-            call cairo_destroy(cairo)
-
-            call g_object_unref(expose_pixbuf)
-        endif
-    endif
-    return (FALSE)
-endfunction
-
-
-#painting the pulse pixbuf
-
-function sound_pixbuf()
-    data pixbuf#1
-    return #pixbuf
-endfunction
-
-function stage_frame_width()
-    data frame_size#1
-    return #frame_size
-endfunction
-
-function sound_pixbuf_draw_area()
-    data draw_area#1
-    return #draw_area
-endfunction
-
-function sound_pixbuf_redraw()
-    call sound_pixbuf_paint()
-    sd px
-    setcall px sound_pixbuf()
-    if px#!=0
-        import "widget_redraw" widget_redraw
-        sd draw
-        setcall draw sound_pixbuf_draw_area()
-        sd px_width
-        setcall px_width gdk_pixbuf_get_width(px#)
-        call gtk_widget_set_size_request(draw#,px_width,-1)
-        call widget_redraw(draw#)
-    endif
-endfunction
-
-function sound_pixbuf_paint()
-    sd width
-    sd height
-    sd soundWd
-    setcall soundWd sound_widget()
-    sd requisition^width
-    call gtk_widget_size_request(soundWd#,requisition)
-    #
-    import "stage_sound_subsize" stage_sound_subsize
-    import "stage_file_options_fps" stage_file_options_fps
-    sd fps
-    sd sound_size
-    setcall fps stage_file_options_fps()
-    setcall sound_size stage_sound_subsize((value_get))
-    #
-    import "stage_sound_blockalign" stage_sound_blockalign
-    import "stage_sound_rate" stage_sound_rate
-    sd all_samples
-    set all_samples sound_size
-    divcall all_samples stage_sound_blockalign()
-    #
-    import "stage_sound_channels" stage_sound_channels
-    import "stage_sound_bps" stage_sound_bps
-    sd nr_of_channels
-    setcall nr_of_channels stage_sound_channels((value_get))
-    sd sample_rate
-    setcall sample_rate stage_sound_rate((value_get))
-    sd bps
-    setcall bps stage_sound_bps((value_get))
-    if bps!=8
-        if bps!=16
-            return (void)
-        endif
-    endif
-    #
-    sd frame_width
-    setcall frame_width stage_frame_width()
-    sd a_second_video_width
-    set a_second_video_width frame_width#
-    mult a_second_video_width fps
-    #width=all_samples x a_second_video_width
-    #      sample_rate
-    import "fimul" fimul
-    import "fidiv" fidiv
-    import "fst_quad" fst_quad
-    import "fistp" fistp
-    import "fmul_quad" fmul_quad
-    #store the fraction for fast use
-    sd fraction#2
-    call fild(#a_second_video_width)
-    call fidiv(#sample_rate)
-    call fst_quad(#fraction)
-    #
-    call fimul(#all_samples)
-    call fistp(#width)
-    #rounding AND to see the area at 0
-    add width 10
-    #
-    import "new_pixbuf" new_pixbuf
-    sd pixbuf
-    setcall pixbuf new_pixbuf(width,height)
-    if pixbuf!=0
-        importx "_gdk_pixbuf_fill" gdk_pixbuf_fill
-        call gdk_pixbuf_fill(pixbuf,0xffFFffFF)
-        #sound pulse
-        #draw all samples
-        import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
-
-        ss sound_bytes_cursor
-        setcall sound_bytes_cursor stage_sound_alloc_getbytes()
-
-        sd bytespersample
-        set bytespersample bps
-        div bytespersample 8
-        #
-        importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-        import "rgb_get_rowstride" rgb_get_rowstride
-        sd half
-        set half height
-        div half 2
-        sd pixels
-        setcall pixels gdk_pixbuf_get_pixels(pixbuf)
-        sd stride
-        setcall stride rgb_get_rowstride(width)
-        sd x
-        sd y
-        sd value
-        sd value_max
-        sd y_sens
-        #
-        sd i=0
-        while i!=all_samples
-            call fild(#i)
-            call fmul_quad(#fraction)
-            call fistp(#x)
-            sd channels=0
-            while channels!=nr_of_channels
-                if bps==8
-                    set value_max 0x7f
-                    set value sound_bytes_cursor#
-                    if value>=0x80
-                        sub value 0x80
-                        set y_sens -1
-                    else
-                        #flip the value
-                        mult value -1
-                        add value 0x7f
-                        set y_sens 1
-                    endelse
-                    inc sound_bytes_cursor
-                else
-                #if bps==16
-                    import "short_get_to_int" short_get_to_int
-                    set value_max 0x7fFF
-                    setcall value short_get_to_int(sound_bytes_cursor)
-                    if value>=0
-                        set y_sens -1
-                    else
-                        mult value -1
-                        dec value
-                        set y_sens 1
-                    endelse
-                    add sound_bytes_cursor 2
-                endelse
-                #a     value
-                #half  value_max
-                sd number
-                set number value
-                mult number half
-                div number value_max
-                mult number y_sens
-
-                sd y_last
-                set y_last half
-                add y_last number
-
-                set y half
-                if y==y_last
-                    #do at least a dot
-                    add y_last y_sens
-                endif
-
-                while y!=y_last
-                    #
-                    ss pixels_cursor
-                    set pixels_cursor pixels
-                    sd rows
-                    set rows y
-                    mult rows stride
-                    add pixels_cursor rows
-                    sd lines
-                    set lines x
-                    mult lines 3
-                    add pixels_cursor lines
-                    set pixels_cursor# 0
-                    inc pixels_cursor
-                    set pixels_cursor# 0
-                    inc pixels_cursor
-                    set pixels_cursor# 0
-                    #
-                    add y y_sens
-               endwhile
-               inc channels
-           endwhile
-           inc i
-        endwhile
-        #set for expose
-        sd pixbuf_location
-        setcall pixbuf_location sound_pixbuf()
-        if pixbuf_location#!=0
-            call g_object_unref(pixbuf_location#)
-        endif
-        set pixbuf_location# pixbuf
-    endif
-endfunction
--- /dev/null
+++ ovideo-1/src/_search/dialog.oc
@@ -0,0 +1,124 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+function show_preferences_set_windows(sd vbox)
+    import "packstart" packstart
+
+    data true=1
+
+    importx "_gtk_frame_new" gtk_frame_new
+    str body="Body"
+    sd frame#1
+    setcall frame gtk_frame_new(body)
+    call packstart(vbox,frame,true)
+
+    import "tablefield_row" tablefield_row
+
+    importx "_gtk_entry_new" gtk_entry_new
+    importx "_gtk_label_new" gtk_label_new
+
+    import "labelfield_left_prepare" labelfield_left_prepare
+    import "edit_info_prepare_blue" edit_info_prepare_blue
+    #Get
+    #info label
+    data cols=5
+
+    sd getinfo
+
+    str getinfotext="Get the URIs between the Start and the End:"
+    setcall getinfo labelfield_left_prepare(getinfotext)
+
+    sd table
+    setcall table tablefield_row(frame,cols,getinfo)
+
+    import "search_get_fields" search_get_fields
+    sd fields
+    setcall fields search_get_fields()
+    data dw=4
+    sd widgets
+
+    set widgets fields
+
+
+    #rowGetEntries_label1
+    str startlabel_text="Start->"
+    setcall fields# gtk_label_new(startlabel_text)
+    add fields dw
+
+    #rowGetEntries_entry1
+    setcall fields# gtk_entry_new()
+    add fields dw
+
+    #rowGetEntries_text
+    str get_uri_text="URI"
+    setcall fields# edit_info_prepare_blue(get_uri_text)
+    add fields dw
+
+    #rowGetEntries_entry2
+    setcall fields# gtk_entry_new()
+    add fields dw
+
+    #rowGetEntries_label2
+    str endlabel_text="<-End"
+    setcall fields# gtk_label_new(endlabel_text)
+    add fields dw
+
+    #add the group1
+    import "table_add_cells" table_add_cells
+    data onerow=1
+    setcall widgets table_add_cells(table,onerow,widgets)
+
+
+    import "hseparatorfield_table" hseparatorfield_table
+    call hseparatorfield_table(table)
+
+
+    #the wrap widgets follow
+    import "labelfield_left_table" labelfield_left_table
+
+    str wraptext="Wrap the URI between the following fields to create the final URI or leave blank:"
+    call labelfield_left_table(wraptext,table)
+
+    str wrap_text="+"
+
+    setcall fields# gtk_entry_new()
+    add fields dw
+    setcall fields# gtk_label_new(wrap_text)
+    add fields dw
+    setcall fields# edit_info_prepare_blue(get_uri_text)
+    add fields dw
+    setcall fields# gtk_label_new(wrap_text)
+    add fields dw
+    setcall fields# gtk_entry_new()
+
+    #add the group2
+    call table_add_cells(table,onerow,widgets)
+
+    #set vars to display
+    import "set_field_pack" set_field_pack
+    call set_field_pack()
+endfunction
+
+import "move_to_home_v" move_to_home_v
+function show_preferences_continuation()
+	call move_to_home_v()
+	import "sys_folder_enterleave" sys_folder_enterleave
+	import "write_free_read" write_free_read
+	data fn^write_free_read
+	call sys_folder_enterleave(fn)
+endfunction
+
+#v
+function show_preferences()
+    str searchpreferences="Search Preferences"
+    data modal=GTK_DIALOG_MODAL
+    data set^show_preferences_set_windows
+    data continuation^show_preferences_continuation
+
+    import "dialogfield" dialogfield
+    call dialogfield(searchpreferences,modal,set,continuation)
+endfunction
--- ovideo-1.orig/src/_search/dialog.s
+++ /dev/null
@@ -1,124 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-function show_preferences_set_windows(sd vbox)
-    import "packstart" packstart
-
-    data true=1
-
-    importx "_gtk_frame_new" gtk_frame_new
-    str body="Body"
-    sd frame#1
-    setcall frame gtk_frame_new(body)
-    call packstart(vbox,frame,true)
-
-    import "tablefield_row" tablefield_row
-
-    importx "_gtk_entry_new" gtk_entry_new
-    importx "_gtk_label_new" gtk_label_new
-
-    import "labelfield_left_prepare" labelfield_left_prepare
-    import "edit_info_prepare_blue" edit_info_prepare_blue
-    #Get
-    #info label
-    data cols=5
-
-    sd getinfo
-
-    str getinfotext="Get the URIs between the Start and the End:"
-    setcall getinfo labelfield_left_prepare(getinfotext)
-
-    sd table
-    setcall table tablefield_row(frame,cols,getinfo)
-
-    import "search_get_fields" search_get_fields
-    sd fields
-    setcall fields search_get_fields()
-    data dw=4
-    sd widgets
-
-    set widgets fields
-
-
-    #rowGetEntries_label1
-    str startlabel_text="Start->"
-    setcall fields# gtk_label_new(startlabel_text)
-    add fields dw
-
-    #rowGetEntries_entry1
-    setcall fields# gtk_entry_new()
-    add fields dw
-
-    #rowGetEntries_text
-    str get_uri_text="URI"
-    setcall fields# edit_info_prepare_blue(get_uri_text)
-    add fields dw
-
-    #rowGetEntries_entry2
-    setcall fields# gtk_entry_new()
-    add fields dw
-
-    #rowGetEntries_label2
-    str endlabel_text="<-End"
-    setcall fields# gtk_label_new(endlabel_text)
-    add fields dw
-
-    #add the group1
-    import "table_add_cells" table_add_cells
-    data onerow=1
-    setcall widgets table_add_cells(table,onerow,widgets)
-
-
-    import "hseparatorfield_table" hseparatorfield_table
-    call hseparatorfield_table(table)
-
-
-    #the wrap widgets follow
-    import "labelfield_left_table" labelfield_left_table
-
-    str wraptext="Wrap the URI between the following fields to create the final URI or leave blank:"
-    call labelfield_left_table(wraptext,table)
-
-    str wrap_text="+"
-
-    setcall fields# gtk_entry_new()
-    add fields dw
-    setcall fields# gtk_label_new(wrap_text)
-    add fields dw
-    setcall fields# edit_info_prepare_blue(get_uri_text)
-    add fields dw
-    setcall fields# gtk_label_new(wrap_text)
-    add fields dw
-    setcall fields# gtk_entry_new()
-
-    #add the group2
-    call table_add_cells(table,onerow,widgets)
-
-    #set vars to display
-    import "set_field_pack" set_field_pack
-    call set_field_pack()
-endfunction
-
-import "move_to_home_v" move_to_home_v
-function show_preferences_continuation()
-	call move_to_home_v()
-	import "sys_folder_enterleave" sys_folder_enterleave
-	import "write_free_read" write_free_read
-	data fn^write_free_read
-	call sys_folder_enterleave(fn)
-endfunction
-
-#v
-function show_preferences()
-    str searchpreferences="Search Preferences"
-    data modal=GTK_DIALOG_MODAL
-    data set^show_preferences_set_windows
-    data continuation^show_preferences_continuation
-
-    import "dialogfield" dialogfield
-    call dialogfield(searchpreferences,modal,set,continuation)
-endfunction
--- /dev/null
+++ ovideo-1/src/_search/dialog_fns.oc
@@ -0,0 +1,304 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+import "foreach_dword" foreach_dword
+
+import "content_size" content_size
+
+
+function search_preferences_set_init()
+    DATA search_preferences_mem#1
+    const search_preferences_mem^search_preferences_mem
+
+
+    #FIELDS
+    #group1
+const search_structures=\
+    DATA *startlabel#1
+    #
+const search_start_entry=\
+    DATA *startentry#1
+    #
+    const search_start=search_start_entry-search_structures
+    #
+    DATA *get_uri#1
+const search_end_entry=\
+    DATA *endentry#1
+    #
+    const search_end=search_end_entry-search_structures
+    #
+    DATA *endlabel#1
+    #group2
+const search_group2=\
+    DATA *search_wrap_begin#1
+    const search_start_wrap=0
+    const search_fields_struct_size=search_group2-search_structures
+    DATA *#3
+const search_end_wrap_entry=\
+    DATA *search_wrap_end#1
+    const search_end_wrap=search_end_wrap_entry-search_group2
+    #
+
+    #VARS
+    #group1
+const search_first_var_offset=\
+    DATA *search_preferences_uri_start#1
+    #
+    DATA *search_preferences_uri_end#1
+    #group2
+const search_group2_vars=\
+    DATA *search_preferences_wrap_start#1
+    const search_vars_struct_size=search_group2_vars-search_first_var_offset
+    #
+const search_last_var_offset=\
+    DATA *search_preferences_wrap_end#1
+    const search_after_last_var_offset=search_last_var_offset+DWORD
+    const search_vars_size=search_after_last_var_offset-search_first_var_offset
+    #
+
+    data z=0
+    set search_preferences_mem z
+endfunction
+
+function search_get_mem()
+    data search_preferences_mem%search_preferences_mem
+    return search_preferences_mem
+endfunction
+
+function search_get_fields()
+    data uri%search_structures
+    return uri
+endfunction
+function search_get_vars()
+    data offset%search_first_var_offset
+    return offset
+endfunction
+function search_get_vars_based_on_index(sd index)
+    sd vars
+    setcall vars search_get_vars()
+    sd off=search_vars_struct_size
+    mult off index
+    add vars off
+    return vars
+endfunction
+function search_get_fields_based_on_var(sd number)
+    data vars_size=search_vars_struct_size
+    sd vars
+    setcall vars search_get_vars()
+    sub number vars
+    div number vars_size
+    data fields_size=search_fields_struct_size
+    mult number fields_size
+    sd fields
+    setcall fields search_get_fields()
+    add fields number
+    return fields
+endfunction
+
+function search_clear_memory()
+    sd mem
+    setcall mem search_get_mem()
+    set mem mem#
+    data null=0
+    if mem!=null
+        importx "_free" free
+        call free(mem)
+    endif
+endfunction
+
+function search_foreach(sd forward,sd data)
+    data nr=search_vars_size
+    sd vars
+    setcall vars search_get_vars()
+    call foreach_dword(nr,vars,forward,data)
+endfunction
+
+#e
+function getvar(sd var,sd str_sz)
+    data mem#1
+    data size#1
+
+    sd ptrdata^mem
+    call content_size(str_sz,ptrdata)
+
+    import "slen_s" slen_s
+    sd sz
+    sd ptrsz^sz
+    sd err
+    sd noerr=noerror
+
+    setcall err slen_s(mem,size,ptrsz)
+    if err!=noerr
+        return err
+    endif
+    set var# mem
+    import "move_cursors" move_cursors
+    inc sz
+    call move_cursors(str_sz,sz)
+
+    return noerr
+endfunction
+
+function search_filename()
+    str path="search.data"
+    return path
+endfunction
+
+import "file_get_content" file_get_content
+function search_preferences_read_set()
+    sd err
+    data noerr=noerror
+    ss path
+    setcall path search_filename()
+
+    data mem#1
+    data sz#1
+
+    sd ptrsz^sz
+
+    sd str_sz^mem
+
+    sd ptr_search_mem
+
+    #mem
+    setcall ptr_search_mem search_get_mem()
+
+    setcall err file_get_content(path,ptrsz,ptr_search_mem)
+    if err!=noerr
+        return err
+    endif
+    set mem ptr_search_mem#
+
+    #packs
+    data fn^getvar
+    call search_foreach(fn,str_sz)
+endfunction
+
+function search_preferences_init_vars(sd var,sd *data)
+    str nullstr=""
+    set var# nullstr
+    data noError=noerror
+    return noError
+endfunction
+
+function search_preferences_init()
+    call search_preferences_set_init()
+    data f^search_preferences_init_vars
+    data null=0
+    call search_foreach(f,null)
+    call search_preferences_read_set()
+endfunction
+
+
+
+#read to display or write to file
+
+function setdisplay_setfile_search(sd method,sd argument,sd text)
+#method calls
+#           selection 0, field,text
+#           selection 1, field
+#method init
+#           selection 0
+#           selection 1, file
+
+    const search_setdisplay=0
+    const search_setfile=1
+    const search_calls=2
+    data setdisplay=2
+    data setfile=3
+    data selection#1
+
+    if method<setdisplay
+        add method setdisplay
+        set selection method
+        if method=setfile
+            data file#1
+            set file argument
+        endif
+    else
+        if selection=setdisplay
+            importx "_gtk_entry_set_text" gtk_entry_set_text
+            call gtk_entry_set_text(argument,text)
+        else
+            importx "_gtk_entry_get_text" gtk_entry_get_text
+            import "slen" slen
+            ss buffer
+            setcall buffer gtk_entry_get_text(argument)
+            sd size
+            setcall size slen(buffer)
+            inc size
+            sd e
+            import "file_write" file_write
+            setcall e file_write(buffer,size,file)
+            return e
+        endelse
+    endelse
+    data noe=noerror
+    return noe
+endfunction
+
+
+function set_field_loop(sd var,sd ptroff)
+    sd fields
+    setcall fields search_get_fields_based_on_var(var)
+    sd off
+    set off ptroff#
+    add fields off#
+
+    data calls=search_calls
+    sd e
+    data noe=noerror
+    setcall e setdisplay_setfile_search(calls,fields#,var#)
+    if e!=noe
+        return e
+    endif
+
+    data dw=4
+    add ptroff# dw
+    return noe
+endfunction
+
+function search_set_field_or_file()
+    data startoffset=search_start
+    data *endoffset=search_end
+    data *wrapstartoffset=search_start_wrap
+    data *wrapendoffset=search_end_wrap
+    sd off^startoffset
+    sd ptroff^off
+
+    data fn^set_field_loop
+    call search_foreach(fn,ptroff)
+endfunction
+
+
+#read
+function set_field_pack()
+    data search_setdisplay=search_setdisplay
+    call setdisplay_setfile_search(search_setdisplay)
+    call search_set_field_or_file()
+endfunction
+
+
+#settings ok button pressed
+
+function search_file_write(sd file)
+    data search_setfile=search_setfile
+    call setdisplay_setfile_search(search_setfile,file)
+    call search_set_field_or_file()
+endfunction
+
+function write_free_read()
+    import "file_write_forward" file_write_forward
+    data f^search_file_write
+    ss path
+    setcall path search_filename()
+    call file_write_forward(path,f)
+
+    call search_clear_memory()
+
+    call search_preferences_init()
+endfunction
--- ovideo-1.orig/src/_search/dialog_fns.s
+++ /dev/null
@@ -1,304 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-import "foreach_dword" foreach_dword
-
-import "content_size" content_size
-
-
-function search_preferences_set_init()
-    DATA search_preferences_mem#1
-    const search_preferences_mem^search_preferences_mem
-
-
-    #FIELDS
-    #group1
-const search_structures=!
-    DATA *startlabel#1
-    #
-const search_start_entry=!
-    DATA *startentry#1
-    #
-    const search_start=search_start_entry-search_structures
-    #
-    DATA *get_uri#1
-const search_end_entry=!
-    DATA *endentry#1
-    #
-    const search_end=search_end_entry-search_structures
-    #
-    DATA *endlabel#1
-    #group2
-const search_group2=!
-    DATA *search_wrap_begin#1
-    const search_start_wrap=0
-    const search_fields_struct_size=search_group2-search_structures
-    DATA *#3
-const search_end_wrap_entry=!
-    DATA *search_wrap_end#1
-    const search_end_wrap=search_end_wrap_entry-search_group2
-    #
-
-    #VARS
-    #group1
-const search_first_var_offset=!
-    DATA *search_preferences_uri_start#1
-    #
-    DATA *search_preferences_uri_end#1
-    #group2
-const search_group2_vars=!
-    DATA *search_preferences_wrap_start#1
-    const search_vars_struct_size=search_group2_vars-search_first_var_offset
-    #
-const search_last_var_offset=!
-    DATA *search_preferences_wrap_end#1
-    const search_after_last_var_offset=search_last_var_offset+DWORD
-    const search_vars_size=search_after_last_var_offset-search_first_var_offset
-    #
-
-    data z=0
-    set search_preferences_mem z
-endfunction
-
-function search_get_mem()
-    data search_preferences_mem%search_preferences_mem
-    return search_preferences_mem
-endfunction
-
-function search_get_fields()
-    data uri%search_structures
-    return uri
-endfunction
-function search_get_vars()
-    data offset%search_first_var_offset
-    return offset
-endfunction
-function search_get_vars_based_on_index(sd index)
-    sd vars
-    setcall vars search_get_vars()
-    sd off=search_vars_struct_size
-    mult off index
-    add vars off
-    return vars
-endfunction
-function search_get_fields_based_on_var(sd number)
-    data vars_size=search_vars_struct_size
-    sd vars
-    setcall vars search_get_vars()
-    sub number vars
-    div number vars_size
-    data fields_size=search_fields_struct_size
-    mult number fields_size
-    sd fields
-    setcall fields search_get_fields()
-    add fields number
-    return fields
-endfunction
-
-function search_clear_memory()
-    sd mem
-    setcall mem search_get_mem()
-    set mem mem#
-    data null=0
-    if mem!=null
-        importx "_free" free
-        call free(mem)
-    endif
-endfunction
-
-function search_foreach(sd forward,sd data)
-    data nr=search_vars_size
-    sd vars
-    setcall vars search_get_vars()
-    call foreach_dword(nr,vars,forward,data)
-endfunction
-
-#e
-function getvar(sd var,sd str_sz)
-    data mem#1
-    data size#1
-
-    sd ptrdata^mem
-    call content_size(str_sz,ptrdata)
-
-    import "slen_s" slen_s
-    sd sz
-    sd ptrsz^sz
-    sd err
-    sd noerr=noerror
-
-    setcall err slen_s(mem,size,ptrsz)
-    if err!=noerr
-        return err
-    endif
-    set var# mem
-    import "move_cursors" move_cursors
-    inc sz
-    call move_cursors(str_sz,sz)
-
-    return noerr
-endfunction
-
-function search_filename()
-    str path="search.data"
-    return path
-endfunction
-
-import "file_get_content" file_get_content
-function search_preferences_read_set()
-    sd err
-    data noerr=noerror
-    ss path
-    setcall path search_filename()
-
-    data mem#1
-    data sz#1
-
-    sd ptrsz^sz
-
-    sd str_sz^mem
-
-    sd ptr_search_mem
-
-    #mem
-    setcall ptr_search_mem search_get_mem()
-
-    setcall err file_get_content(path,ptrsz,ptr_search_mem)
-    if err!=noerr
-        return err
-    endif
-    set mem ptr_search_mem#
-
-    #packs
-    data fn^getvar
-    call search_foreach(fn,str_sz)
-endfunction
-
-function search_preferences_init_vars(sd var,sd *data)
-    str nullstr=""
-    set var# nullstr
-    data noError=noerror
-    return noError
-endfunction
-
-function search_preferences_init()
-    call search_preferences_set_init()
-    data f^search_preferences_init_vars
-    data null=0
-    call search_foreach(f,null)
-    call search_preferences_read_set()
-endfunction
-
-
-
-#read to display or write to file
-
-function setdisplay_setfile_search(sd method,sd argument,sd text)
-#method calls
-#           selection 0, field,text
-#           selection 1, field
-#method init
-#           selection 0
-#           selection 1, file
-
-    const search_setdisplay=0
-    const search_setfile=1
-    const search_calls=2
-    data setdisplay=2
-    data setfile=3
-    data selection#1
-
-    if method<setdisplay
-        add method setdisplay
-        set selection method
-        if method==setfile
-            data file#1
-            set file argument
-        endif
-    else
-        if selection==setdisplay
-            importx "_gtk_entry_set_text" gtk_entry_set_text
-            call gtk_entry_set_text(argument,text)
-        else
-            importx "_gtk_entry_get_text" gtk_entry_get_text
-            import "slen" slen
-            ss buffer
-            setcall buffer gtk_entry_get_text(argument)
-            sd size
-            setcall size slen(buffer)
-            inc size
-            sd e
-            import "file_write" file_write
-            setcall e file_write(buffer,size,file)
-            return e
-        endelse
-    endelse
-    data noe=noerror
-    return noe
-endfunction
-
-
-function set_field_loop(sd var,sd ptroff)
-    sd fields
-    setcall fields search_get_fields_based_on_var(var)
-    sd off
-    set off ptroff#
-    add fields off#
-
-    data calls=search_calls
-    sd e
-    data noe=noerror
-    setcall e setdisplay_setfile_search(calls,fields#,var#)
-    if e!=noe
-        return e
-    endif
-
-    data dw=4
-    add ptroff# dw
-    return noe
-endfunction
-
-function search_set_field_or_file()
-    data startoffset=search_start
-    data *endoffset=search_end
-    data *wrapstartoffset=search_start_wrap
-    data *wrapendoffset=search_end_wrap
-    sd off^startoffset
-    sd ptroff^off
-
-    data fn^set_field_loop
-    call search_foreach(fn,ptroff)
-endfunction
-
-
-#read
-function set_field_pack()
-    data search_setdisplay=search_setdisplay
-    call setdisplay_setfile_search(search_setdisplay)
-    call search_set_field_or_file()
-endfunction
-
-
-#settings ok button pressed
-
-function search_file_write(sd file)
-    data search_setfile=search_setfile
-    call setdisplay_setfile_search(search_setfile,file)
-    call search_set_field_or_file()
-endfunction
-
-function write_free_read()
-    import "file_write_forward" file_write_forward
-    data f^search_file_write
-    ss path
-    setcall path search_filename()
-    call file_write_forward(path,f)
-
-    call search_clear_memory()
-
-    call search_preferences_init()
-endfunction
--- /dev/null
+++ ovideo-1/src/_search/parse.oc
@@ -0,0 +1,178 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+function search_parse_URIs_launch(ss str,sd table)
+    import "table_add_row" table_add_row
+
+    importx "_gtk_hseparator_new" gtk_hseparator_new
+    sd hseparator
+    setcall hseparator gtk_hseparator_new()
+    data w=-1
+    data h=20
+    importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
+    call gtk_widget_set_size_request(hseparator,w,h)
+    call table_add_row(table,hseparator)
+
+    sd newedit
+	import "edit_info_prepare_green" edit_info_prepare_green
+    setcall newedit edit_info_prepare_green(str)
+    call table_add_row(table,newedit)
+
+    importx "_gtk_image_new" gtk_image_new
+    sd img
+    setcall img gtk_image_new()
+    call table_add_row(table,img)
+
+    import "search_get_image" search_get_image
+    call search_get_image(str,img)
+endfunction
+
+importx "_sprintf" sprintf
+
+function search_parse_URIs(ss str,sd table)
+    data ind=search_preferences_wrap_index
+    sd vars
+    import "search_get_vars_based_on_index" search_get_vars_based_on_index
+    setcall vars search_get_vars_based_on_index(ind)
+    sd s1
+    sd s2
+    sd s3
+    sd *=0
+    sd strings^s1
+
+    set s1 vars#
+    set s2 str
+    data dw=4
+    add vars dw
+    set s3 vars#
+
+    import "allocsum_null" allocsum_null
+    sd mem
+    sd ptr_mem^mem
+    sd err
+    data noerr=noerror
+    setcall err allocsum_null(strings,ptr_mem)
+    if err!=noerr
+        return err
+    endif
+    str form="%s%s%s"
+    call sprintf(mem,form,s1,s2,s3)
+    call search_parse_URIs_launch(mem,table)
+    importx "_free" free
+    call free(mem)
+endfunction
+
+function count_the_findings(ss *str,sd data)
+    inc data#
+endfunction
+
+import "search_get_vars" search_get_vars
+import "find_start_end_forward_center_data" find_start_end_forward_center_data
+function search_parse_got_body(ss body,sd size,sd data)
+    sd vars
+    setcall vars search_get_vars()
+    sd start
+    set start vars#
+    data dw=4
+    add vars dw
+    sd end
+    set end vars#
+
+    sd table
+    set table data#
+    add data dw
+
+    sd totalentries=0
+    sd ptr_totalentries^totalentries
+    sd counter^count_the_findings
+    call find_start_end_forward_center_data(body,size,start,end,counter,ptr_totalentries)
+    char number#dword_null
+    ss nr^number
+    str dw_str="%u"
+    call sprintf(nr,dw_str,totalentries)
+    importx "_gtk_entry_set_text" gtk_entry_set_text
+    call gtk_entry_set_text(data#,nr)
+
+    sd entries^search_parse_URIs
+    call find_start_end_forward_center_data(body,size,start,end,entries,table)
+endfunction
+
+
+
+import "uri_get_content_forward_data" uri_get_content_forward_data
+function search_parse_got_uri(ss uri,sd vbox)
+    sd urilabel
+    sd uritext
+
+    sd itemslabel
+    sd itemstext
+
+    sd rows=2
+    sd cols=2
+    sd widgets^urilabel
+
+    #row1
+    importx "_gtk_label_new" gtk_label_new
+    str uristr="URI:"
+
+    setcall urilabel gtk_label_new(uristr)
+
+    setcall uritext edit_info_prepare_green(uri)
+
+    #row2
+    str itemsstr="Items:"
+
+    setcall itemslabel gtk_label_new(itemsstr)
+
+    sd table
+    sd extradata
+
+	import "edit_info_prepare_texter_green" edit_info_prepare_texter_green
+    setcall itemstext edit_info_prepare_texter_green("",#extradata)
+
+    #scroll panel
+    import "scrollfield" scrollfield
+    sd scroll
+    setcall scroll scrollfield(vbox)
+    importx "_gtk_scrolled_window_set_policy" gtk_scrolled_window_set_policy
+    data always=GTK_POLICY_ALWAYS
+    data auto=GTK_POLICY_AUTOMATIC
+    call gtk_scrolled_window_set_policy(scroll,auto,always)
+
+    import "tablefield_cells" tablefield_cells
+    ##begin the table
+    setcall table tablefield_cells(scroll,rows,cols,widgets)
+
+    #entries
+    data nextFn^search_parse_got_body
+    sd pass^table
+    call uri_get_content_forward_data(uri,nextFn,pass)
+
+    #lastrow
+    str endoflist="End of List"
+    sd last
+    setcall last gtk_label_new(endoflist)
+    call table_add_row(table,last)
+endfunction
+
+
+
+function search_parse_set_windows(sd vbox)
+    import "editWidgetBufferForwardData" editWidgetBufferForwardData
+    data nextFn^search_parse_got_uri
+    call editWidgetBufferForwardData(nextFn,vbox)
+endfunction
+
+import "dialogfield_size" dialogfield_size
+function search_parse()
+    ss searchlist="Search List"
+    sd null=0
+    data fn^search_parse_set_windows
+    data w=300
+    data h=512
+    call dialogfield_size(searchlist,null,fn,null,w,h)
+endfunction
--- ovideo-1.orig/src/_search/parse.s
+++ /dev/null
@@ -1,178 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-function search_parse_URIs_launch(ss str,sd table)
-    import "table_add_row" table_add_row
-
-    importx "_gtk_hseparator_new" gtk_hseparator_new
-    sd hseparator
-    setcall hseparator gtk_hseparator_new()
-    data w=-1
-    data h=20
-    importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
-    call gtk_widget_set_size_request(hseparator,w,h)
-    call table_add_row(table,hseparator)
-
-    sd newedit
-	import "edit_info_prepare_green" edit_info_prepare_green
-    setcall newedit edit_info_prepare_green(str)
-    call table_add_row(table,newedit)
-
-    importx "_gtk_image_new" gtk_image_new
-    sd img
-    setcall img gtk_image_new()
-    call table_add_row(table,img)
-
-    import "search_get_image" search_get_image
-    call search_get_image(str,img)
-endfunction
-
-importx "_sprintf" sprintf
-
-function search_parse_URIs(ss str,sd table)
-    data ind=search_preferences_wrap_index
-    sd vars
-    import "search_get_vars_based_on_index" search_get_vars_based_on_index
-    setcall vars search_get_vars_based_on_index(ind)
-    sd s1
-    sd s2
-    sd s3
-    sd *=0
-    sd strings^s1
-
-    set s1 vars#
-    set s2 str
-    data dw=4
-    add vars dw
-    set s3 vars#
-
-    import "allocsum_null" allocsum_null
-    sd mem
-    sd ptr_mem^mem
-    sd err
-    data noerr=noerror
-    setcall err allocsum_null(strings,ptr_mem)
-    if err!=noerr
-        return err
-    endif
-    str form="%s%s%s"
-    call sprintf(mem,form,s1,s2,s3)
-    call search_parse_URIs_launch(mem,table)
-    importx "_free" free
-    call free(mem)
-endfunction
-
-function count_the_findings(ss *str,sd data)
-    inc data#
-endfunction
-
-import "search_get_vars" search_get_vars
-import "find_start_end_forward_center_data" find_start_end_forward_center_data
-function search_parse_got_body(ss body,sd size,sd data)
-    sd vars
-    setcall vars search_get_vars()
-    sd start
-    set start vars#
-    data dw=4
-    add vars dw
-    sd end
-    set end vars#
-
-    sd table
-    set table data#
-    add data dw
-
-    sd totalentries=0
-    sd ptr_totalentries^totalentries
-    sd counter^count_the_findings
-    call find_start_end_forward_center_data(body,size,start,end,counter,ptr_totalentries)
-    char number#dword_null
-    ss nr^number
-    str dw_str="%u"
-    call sprintf(nr,dw_str,totalentries)
-    importx "_gtk_entry_set_text" gtk_entry_set_text
-    call gtk_entry_set_text(data#,nr)
-
-    sd entries^search_parse_URIs
-    call find_start_end_forward_center_data(body,size,start,end,entries,table)
-endfunction
-
-
-
-import "uri_get_content_forward_data" uri_get_content_forward_data
-function search_parse_got_uri(ss uri,sd vbox)
-    sd urilabel
-    sd uritext
-
-    sd itemslabel
-    sd itemstext
-
-    sd rows=2
-    sd cols=2
-    sd widgets^urilabel
-
-    #row1
-    importx "_gtk_label_new" gtk_label_new
-    str uristr="URI:"
-
-    setcall urilabel gtk_label_new(uristr)
-
-    setcall uritext edit_info_prepare_green(uri)
-
-    #row2
-    str itemsstr="Items:"
-
-    setcall itemslabel gtk_label_new(itemsstr)
-
-    sd table
-    sd extradata
-
-	import "edit_info_prepare_texter_green" edit_info_prepare_texter_green
-    setcall itemstext edit_info_prepare_texter_green("",#extradata)
-
-    #scroll panel
-    import "scrollfield" scrollfield
-    sd scroll
-    setcall scroll scrollfield(vbox)
-    importx "_gtk_scrolled_window_set_policy" gtk_scrolled_window_set_policy
-    data always=GTK_POLICY_ALWAYS
-    data auto=GTK_POLICY_AUTOMATIC
-    call gtk_scrolled_window_set_policy(scroll,auto,always)
-
-    import "tablefield_cells" tablefield_cells
-    ##begin the table
-    setcall table tablefield_cells(scroll,rows,cols,widgets)
-
-    #entries
-    data nextFn^search_parse_got_body
-    sd pass^table
-    call uri_get_content_forward_data(uri,nextFn,pass)
-
-    #lastrow
-    str endoflist="End of List"
-    sd last
-    setcall last gtk_label_new(endoflist)
-    call table_add_row(table,last)
-endfunction
-
-
-
-function search_parse_set_windows(sd vbox)
-    import "editWidgetBufferForwardData" editWidgetBufferForwardData
-    data nextFn^search_parse_got_uri
-    call editWidgetBufferForwardData(nextFn,vbox)
-endfunction
-
-import "dialogfield_size" dialogfield_size
-function search_parse()
-    ss searchlist="Search List"
-    sd null=0
-    data fn^search_parse_set_windows
-    data w=300
-    data h=512
-    call dialogfield_size(searchlist,null,fn,null,w,h)
-endfunction
--- /dev/null
+++ ovideo-1/src/_search/previews.oc
@@ -0,0 +1,134 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+function getsubject()
+    str nm="name"
+    return nm
+endfunction
+
+function search_photo_set_scaled(sd pixbuf,sd img)
+    importx "_gtk_image_set_from_pixbuf" gtk_image_set_from_pixbuf
+    call gtk_image_set_from_pixbuf(img,pixbuf)
+endfunction
+
+#ve
+function search_photo_set(sd pixbuf,sd img)
+    importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+
+    sd w
+    sd h
+    setcall w gdk_pixbuf_get_width(pixbuf)
+    setcall h gdk_pixbuf_get_height(pixbuf)
+
+    sd scale_w=200
+    sd scale_h
+
+    #w..h
+    #sw..sh
+    #sh=h*sw/w
+    mult h scale_w
+    div h w
+    set scale_h h
+
+    data fn^search_photo_set_scaled
+    import "pixbuf_scale_forward_data" pixbuf_scale_forward_data
+    call pixbuf_scale_forward_data(pixbuf,scale_w,scale_h,fn,img)
+endfunction
+
+function search_photo_prepare(sd elem,sd msg)
+    import "object_get_dword_name" object_get_dword_name
+    sd img
+    setcall img object_get_dword_name(elem)
+
+    data fn^search_photo_set
+    import "msgelement_pixbuf_forward_data" msgelement_pixbuf_forward_data
+    call msgelement_pixbuf_forward_data(msg,fn,img)
+endfunction
+
+
+function search_photo_get(sd iter,sd msg)
+    import "iterate_next_forward_data_free" iterate_next_forward_data_free
+    data f^search_photo_prepare
+    call iterate_next_forward_data_free(iter,f,msg)
+endfunction
+
+
+function search_photo_received(sd *bus,sd msg,sd pipe)
+    import "set_pipe_null" set_pipe_null
+    call set_pipe_null(pipe)
+
+    import "iterate_sinks_data" iterate_sinks_data
+    data f^search_photo_get
+
+    call iterate_sinks_data(pipe,f,msg)
+
+    import "unset_pipe_and_watch" unset_pipe_and_watch
+    call unset_pipe_and_watch(pipe)
+endfunction
+
+
+
+function search_connect_pixbuf(sd bus,sd pipe)
+    str px="message::element"
+    import "connect_signal_data" connect_signal_data
+    data fn^search_photo_received
+    call connect_signal_data(bus,px,fn,pipe)
+endfunction
+
+importx "_sprintf" sprintf
+
+function search_get_image(ss uri,sd handle)
+    ss launcher="uridecodebin uri=\"%s\" ! ffmpegcolorspace ! gdkpixbufsink %s=%u"
+    ss src
+    ss nm
+    sd *term=0
+
+    set src uri
+    setcall nm getsubject()
+
+    sd strs^launcher
+    sd nrs=1
+
+    sd mem
+    sd ptrmem^mem
+
+    import "allocsum_numbers_null" allocsum_numbers_null
+    sd err
+    data noerr=noerror
+
+    setcall err allocsum_numbers_null(strs,nrs,ptrmem)
+    if err!=noerr
+        return err
+    endif
+    call sprintf(mem,launcher,uri,nm,handle)
+
+    import "launch_pipe" launch_pipe
+    sd pipeline
+    data n=0
+
+    setcall pipeline launch_pipe(mem)
+
+    importx "_free" free
+    call free(mem)
+    if pipeline=n
+        return n
+    endif
+
+    import "start_pipe" start_pipe
+    setcall err start_pipe(pipeline)
+    if err!=noerr
+        return err
+    endif
+
+    import "bus_default_signals" bus_default_signals
+    call bus_default_signals(pipeline)
+
+    import "bus_signals_bin" bus_signals_bin
+    data fn^search_connect_pixbuf
+    call bus_signals_bin(pipeline,fn)
+endfunction
--- ovideo-1.orig/src/_search/previews.s
+++ /dev/null
@@ -1,134 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-function getsubject()
-    str nm="name"
-    return nm
-endfunction
-
-function search_photo_set_scaled(sd pixbuf,sd img)
-    importx "_gtk_image_set_from_pixbuf" gtk_image_set_from_pixbuf
-    call gtk_image_set_from_pixbuf(img,pixbuf)
-endfunction
-
-#ve
-function search_photo_set(sd pixbuf,sd img)
-    importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-    importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-
-    sd w
-    sd h
-    setcall w gdk_pixbuf_get_width(pixbuf)
-    setcall h gdk_pixbuf_get_height(pixbuf)
-
-    sd scale_w=200
-    sd scale_h
-
-    #w..h
-    #sw..sh
-    #sh=h*sw/w
-    mult h scale_w
-    div h w
-    set scale_h h
-
-    data fn^search_photo_set_scaled
-    import "pixbuf_scale_forward_data" pixbuf_scale_forward_data
-    call pixbuf_scale_forward_data(pixbuf,scale_w,scale_h,fn,img)
-endfunction
-
-function search_photo_prepare(sd elem,sd msg)
-    import "object_get_dword_name" object_get_dword_name
-    sd img
-    setcall img object_get_dword_name(elem)
-
-    data fn^search_photo_set
-    import "msgelement_pixbuf_forward_data" msgelement_pixbuf_forward_data
-    call msgelement_pixbuf_forward_data(msg,fn,img)
-endfunction
-
-
-function search_photo_get(sd iter,sd msg)
-    import "iterate_next_forward_data_free" iterate_next_forward_data_free
-    data f^search_photo_prepare
-    call iterate_next_forward_data_free(iter,f,msg)
-endfunction
-
-
-function search_photo_received(sd *bus,sd msg,sd pipe)
-    import "set_pipe_null" set_pipe_null
-    call set_pipe_null(pipe)
-
-    import "iterate_sinks_data" iterate_sinks_data
-    data f^search_photo_get
-
-    call iterate_sinks_data(pipe,f,msg)
-
-    import "unset_pipe_and_watch" unset_pipe_and_watch
-    call unset_pipe_and_watch(pipe)
-endfunction
-
-
-
-function search_connect_pixbuf(sd bus,sd pipe)
-    str px="message::element"
-    import "connect_signal_data" connect_signal_data
-    data fn^search_photo_received
-    call connect_signal_data(bus,px,fn,pipe)
-endfunction
-
-importx "_sprintf" sprintf
-
-function search_get_image(ss uri,sd handle)
-    ss launcher="uridecodebin uri=\"%s\" ! ffmpegcolorspace ! gdkpixbufsink %s=%u"
-    ss src
-    ss nm
-    sd *term=0
-
-    set src uri
-    setcall nm getsubject()
-
-    sd strs^launcher
-    sd nrs=1
-
-    sd mem
-    sd ptrmem^mem
-
-    import "allocsum_numbers_null" allocsum_numbers_null
-    sd err
-    data noerr=noerror
-
-    setcall err allocsum_numbers_null(strs,nrs,ptrmem)
-    if err!=noerr
-        return err
-    endif
-    call sprintf(mem,launcher,uri,nm,handle)
-
-    import "launch_pipe" launch_pipe
-    sd pipeline
-    data n=0
-
-    setcall pipeline launch_pipe(mem)
-
-    importx "_free" free
-    call free(mem)
-    if pipeline==n
-        return n
-    endif
-
-    import "start_pipe" start_pipe
-    setcall err start_pipe(pipeline)
-    if err!=noerr
-        return err
-    endif
-
-    import "bus_default_signals" bus_default_signals
-    call bus_default_signals(pipeline)
-
-    import "bus_signals_bin" bus_signals_bin
-    data fn^search_connect_pixbuf
-    call bus_signals_bin(pipeline,fn)
-endfunction
--- /dev/null
+++ ovideo-1/src/err/err.oc
@@ -0,0 +1,54 @@
+
+format elfobj
+
+importx "_g_error_free" g_error_free
+
+import "texter" texter
+import "geterrno" geterrno
+
+include "../_include/include.h"
+
+#get pointer
+function getptrgerr()
+    data gerror#1
+    data ptrgerror^gerror
+    data null=0
+    set gerror null
+    return ptrgerror
+endfunction
+
+#view gerror
+function view_gerror_message(data gerror)
+    #typedef guint32 GQuark;
+    #GQuark       domain
+    #gint         code
+    #gchar       *message
+
+    data pointer#1
+    set pointer gerror
+    data qword=QWORD
+    add pointer qword
+
+    call texter(pointer#)
+endfunction
+
+#view and clean
+function gerrtoerr(data ptrgerror)
+    call view_gerror_message(ptrgerror#)
+    call g_error_free(ptrgerror#)
+endfunction
+
+import "strvaluedisp" strvaluedisp
+
+#void
+#errno
+function strerrno(str text)
+        data err#1
+        setcall err geterrno()
+        data si=stringinteger
+        call strvaluedisp(text,err,si)
+endfunction
+
+
+
+
--- ovideo-1.orig/src/err/err.s
+++ /dev/null
@@ -1,54 +0,0 @@
-
-format elfobj
-
-importx "_g_error_free" g_error_free
-
-import "texter" texter
-import "geterrno" geterrno
-
-include "../_include/include.h"
-
-#get pointer
-function getptrgerr()
-    data gerror#1
-    data ptrgerror^gerror
-    data null=0
-    set gerror null
-    return ptrgerror
-endfunction
-
-#view gerror
-function view_gerror_message(data gerror)
-    #typedef guint32 GQuark;
-    #GQuark       domain
-    #gint         code
-    #gchar       *message
-
-    data pointer#1
-    set pointer gerror
-    data qword=QWORD
-    add pointer qword
-
-    call texter(pointer#)
-endfunction
-
-#view and clean
-function gerrtoerr(data ptrgerror)
-    call view_gerror_message(ptrgerror#)
-    call g_error_free(ptrgerror#)
-endfunction
-
-import "strvaluedisp" strvaluedisp
-
-#void
-#errno
-function strerrno(str text)
-        data err#1
-        setcall err geterrno()
-        data si=stringinteger
-        call strvaluedisp(text,err,si)
-endfunction
-
-
-
-
--- /dev/null
+++ ovideo-1/src/event/event.oc
@@ -0,0 +1,89 @@
+
+
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+#key-press-event , false invoke rest of actions
+function recoverEnter(data *GtkWidget,data GdkEventKey,data gpointer)
+    Const keyvaloff=5*DWORD
+    data keyvaloff=keyvaloff
+
+    add GdkEventKey keyvaloff
+    data pressedkey#1
+    set pressedkey GdkEventKey#
+
+    data enterkey#1
+    data true=TRUE
+    data false=FALSE
+    set enterkey false
+
+    data GDK_Return=0xff0d
+    data GDK_KP_Enter=0xff8d
+
+    if pressedkey=GDK_Return
+            set enterkey true
+    elseif pressedkey=GDK_KP_Enter
+            set enterkey true
+    endelseif
+
+    if enterkey=true
+        import "editWidgetBufferForward" editWidgetBufferForward
+        call editWidgetBufferForward(gpointer)
+    endif
+    return false
+endfunction
+
+#GdkEventType type;
+#GdkWindow *window;
+#gint8 send_event;
+#guint32 time;
+#guint state;
+#guint keyval;
+#gint length;
+#gchar *string;
+#guint16 hardware_keycode;
+#guint8 group;
+#guint is_modifier : 1;
+
+importx "_g_signal_connect_data" g_signal_connect_data
+
+#v
+function connect_signal_data(data instance,str event,data callback,data passdata)
+    data null=0
+    call g_signal_connect_data(instance,event,callback,passdata,null,null)
+endfunction
+
+#v
+function connect_signal(data instance,str event,data callback)
+    data null=0
+    call connect_signal_data(instance,event,callback,null)
+endfunction
+
+function connect_clicked(sd instance,sd callback)
+    call connect_clicked_data(instance,callback,0)
+endfunction
+function connect_clicked_data(sd instance,sd callback,sd data)
+    call connect_signal_data(instance,"clicked",callback,data)
+endfunction
+
+import "double_to_int" double_to_int
+
+#x
+function eventbutton_get_coords(sd event,sd p_y)
+    importx "_gdk_event_get_coords" gdk_event_get_coords
+    sd _x#2
+    sd _y#2
+    sd _p_x^_x
+    sd _p_y^_y
+    call gdk_event_get_coords(event,_p_x,_p_y)
+    if p_y!=0
+        setcall p_y# double_to_int(_p_y)
+    endif
+    sd x
+    setcall x double_to_int(_p_x)
+    return x
+endfunction
--- ovideo-1.orig/src/event/event.s
+++ /dev/null
@@ -1,89 +0,0 @@
-
-
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-#key-press-event , false invoke rest of actions
-function recoverEnter(data *GtkWidget,data GdkEventKey,data gpointer)
-    Const keyvaloff=5*DWORD
-    data keyvaloff=keyvaloff
-
-    add GdkEventKey keyvaloff
-    data pressedkey#1
-    set pressedkey GdkEventKey#
-
-    data enterkey#1
-    data true=TRUE
-    data false=FALSE
-    set enterkey false
-
-    data GDK_Return=0xff0d
-    data GDK_KP_Enter=0xff8d
-
-    if pressedkey==GDK_Return
-            set enterkey true
-    elseif pressedkey==GDK_KP_Enter
-            set enterkey true
-    endelseif
-
-    if enterkey==true
-        import "editWidgetBufferForward" editWidgetBufferForward
-        call editWidgetBufferForward(gpointer)
-    endif
-    return false
-endfunction
-
-#GdkEventType type;
-#GdkWindow *window;
-#gint8 send_event;
-#guint32 time;
-#guint state;
-#guint keyval;
-#gint length;
-#gchar *string;
-#guint16 hardware_keycode;
-#guint8 group;
-#guint is_modifier : 1;
-
-importx "_g_signal_connect_data" g_signal_connect_data
-
-#v
-function connect_signal_data(data instance,str event,data callback,data passdata)
-    data null=0
-    call g_signal_connect_data(instance,event,callback,passdata,null,null)
-endfunction
-
-#v
-function connect_signal(data instance,str event,data callback)
-    data null=0
-    call connect_signal_data(instance,event,callback,null)
-endfunction
-
-function connect_clicked(sd instance,sd callback)
-    call connect_clicked_data(instance,callback,0)
-endfunction
-function connect_clicked_data(sd instance,sd callback,sd data)
-    call connect_signal_data(instance,"clicked",callback,data)
-endfunction
-
-import "double_to_int" double_to_int
-
-#x
-function eventbutton_get_coords(sd event,sd p_y)
-    importx "_gdk_event_get_coords" gdk_event_get_coords
-    sd _x#2
-    sd _y#2
-    sd _p_x^_x
-    sd _p_y^_y
-    call gdk_event_get_coords(event,_p_x,_p_y)
-    if p_y!=0
-        setcall p_y# double_to_int(_p_y)
-    endif
-    sd x
-    setcall x double_to_int(_p_x)
-    return x
-endfunction
--- /dev/null
+++ ovideo-1/src/file-folder/file-base.oc
@@ -0,0 +1,445 @@
+
+
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+importx "_fopen" fopen
+importx "_fclose" fclose
+importx "_fseek" fseek
+importx "_ftell" ftell
+importx "_fread" fread
+
+import "memoryalloc" memoryalloc
+import "strerrno" strerrno
+
+
+##file base
+#err
+Function openfile(data pfile,str path,str fmode)
+        data null=0
+        SetCall pfile# fopen(path,fmode)
+        If pfile#=null
+            str err="Cannot open a file. Error: "
+            call strerrno(err)
+            return err
+        EndIf
+        Data noerr=noerror
+        Return noerr
+EndFunction
+
+function getreadmode()
+    str read="rb"
+    return read
+endfunction
+
+function getwritemode()
+    str write="wb"
+    return write
+endfunction
+
+#e
+function seek_err(sd seekint)
+    If seekint!=0
+        str seekerr="File seek error: "
+        call strerrno(seekerr)
+        return seekerr
+    endif
+    return (noerror)
+endfunction
+
+#e
+function file_seek(sd file,sd off,sd method)
+    data seekint#1
+    SetCall seekint fseek(file,off,method)
+    sd err
+    setcall err seek_err(seekint)
+endfunction
+
+#e
+function file_seek_set(sd file,sd off)
+    sd err
+    setcall err file_seek(file,off,(SEEK_SET))
+    return err
+endfunction
+
+#e
+function file_seek_end(sd file)
+    sd err
+    setcall err file_seek(file,0,(SEEK_END))
+    return err
+endfunction
+#e
+function file_seek_cursor(sd file,sd off)
+    sd err
+    setcall err file_seek(file,off,(SEEK_CUR))
+    return err
+endfunction
+
+#e
+function file_tell(sd file,sd p_sz)
+    setcall p_sz# ftell(file)
+    if p_sz#=-1
+        str ftellerr="File tell error: "
+        call strerrno(ftellerr)
+        return ftellerr
+    endif
+    return (noerror)
+endfunction
+
+#err
+function file_length(sd file,sd ptr_size)
+    sd err
+    setcall err file_seek_end(file)
+    if err!=(noerror)
+        return err
+    endif
+
+    setcall err file_tell(file,ptr_size)
+    return err
+endfunction
+
+#e
+function file_sizeofseek_offset_plus_size(sd file,sd size,sd filepos,sd p_sizeofseek)
+    sd file_offset
+    sd ptr_file_offset^file_offset
+    sd err
+    setcall err file_tell(file,ptr_file_offset)
+    if err!=(noerror)
+        return err
+    endif
+    add filepos size
+    sub filepos file_offset
+    set p_sizeofseek# filepos
+    return (noerror)
+endfunction
+
+#e
+function file_seek_offset_plus_size(sd file,sd size,sd filepos)
+    #get size of seek
+    sd sizeofseek
+    sd p_sizeofseek^sizeofseek
+    sd err
+    setcall err file_sizeofseek_offset_plus_size(file,size,filepos,p_sizeofseek)
+    if err!=(noerror)
+        return err
+    endif
+
+    #seek
+    setcall err file_seek_cursor(file,sizeofseek)
+    if err!=(noerror)
+        return err
+    endif
+    return (noerror)
+endfunction
+
+#rename return
+function change_name(ss oldpath,ss newpath)
+    importx "_rename" rename
+    import "texter" texter
+    sd ret
+    setcall ret rename(oldpath,newpath)
+    if ret!=0
+        call texter("rename error")
+    endif
+    return ret
+endfunction
+
+##forward simple
+
+#err/returns what forward returns
+function file_forward(ss path,sd method,sv forward)
+    sd returnvalue
+    data noerr=noerror
+    sd file
+    sd ptrfile^file
+    SetCall returnvalue openfile(ptrfile,path,method)
+    If returnvalue!=noerr
+            Return returnvalue
+    EndIf
+    setcall returnvalue forward(file,path)
+    call fclose(file)
+    return returnvalue
+EndFunction
+
+##read
+
+#err
+function readtomem(data file,data ptrsize,data ptrmem,data offset,data trail)
+    sd size
+    sd ptr_size^size
+    sd err
+    setcall err file_length(file,ptr_size)
+    if err!=(noerror)
+        return err
+    endif
+
+    #seek back for reading
+    Call fseek(file,0,(SEEK_SET))
+
+    Set ptrsize# size
+
+    add size offset
+    add size trail
+
+    data noerr=noerror
+    SetCall err memoryalloc(size,ptrmem)
+    If err!=noerr
+        return err
+    endif
+
+    Data mem#1
+    Set mem ptrmem#
+
+    add mem offset
+
+    data byte=1
+    Call fread(mem,byte,ptrsize#,file)
+
+    return noerr
+endfunction
+
+#err
+#get: offset+size+trail
+Function file_get_content_offset_trail(str path,data ptrsize,data ptrmem,data offset,data trail)
+        Data err#1
+        Data noerr=noerror
+
+        Data file#1
+        Data ptrfile^file
+
+        str readfile#1
+        setcall readfile getreadmode()
+        SetCall err openfile(ptrfile,path,readfile)
+        If err!=noerr
+                Return err
+        EndIf
+
+        setcall err readtomem(file,ptrsize,ptrmem,offset,trail)
+        Call fclose(file)
+        Return err
+EndFunction
+
+#err
+function file_get_content(str path,data ptrsize,data ptrmem)
+    data err#1
+    data null=0
+    setcall err file_get_content_offset_trail(path,ptrsize,ptrmem,null,null)
+    return err
+EndFunction
+
+function file_get_content_forward(ss filename,sv forward)
+    sd err
+    sd noerr=noerror
+
+    sd size
+    sd ptr_size^size
+    sd mem
+    sd ptr_mem^mem
+    setcall err file_get_content(filename,ptr_size,ptr_mem)
+    if err!=noerr
+        return err
+    endif
+    call forward(mem,size)
+    importx "_free" free
+    call free(mem)
+endfunction
+
+#e
+function file_forward_read(ss path,sd forward)
+    sd method
+    setcall method getreadmode()
+    sd returnvalue
+    setcall returnvalue file_forward(path,method,forward)
+    return returnvalue
+endfunction
+#e
+function file_read(sd mem,sd size,sd file)
+    sd readed
+    setcall readed fread(mem,1,size,file)
+    if readed!=size
+        str er="Read error: "
+        call strerrno(er)
+        return er
+    endif
+    return (noerror)
+endfunction
+#e
+function file_get_size_forward(sd file,sd size,sv forward)
+    sd mem
+    sd p_mem^mem
+    sd err
+    SetCall err memoryalloc(size,p_mem)
+    If err!=(noerror)
+        return err
+    endif
+    SetCall err file_read(mem,size,file)
+    If err!=(noerror)
+        return err
+    endif
+    call forward(mem,size)
+    call free(mem)
+    return (noerror)
+endfunction
+#e
+function file_get_dword(sd file,sd p_dw)
+    sd err
+    setcall err file_read(p_dw,4,file)
+    return err
+endfunction
+#e
+function file_get_dword_reverse(sd file,sd p_dw)
+    sd err
+    setcall err file_get_dword(file,p_dw)
+    if err!=(noerror)
+        return err
+    endif
+    import "dword_reverse" dword_reverse
+    setcall p_dw# dword_reverse(p_dw#)
+    return (noerror)
+endfunction
+#err
+#function file_seek_cursor_get_dword(sd file,sd offset,sd p_dw)
+#    sd err
+#    setcall err file_seek_cursor(file,offset)
+#    if err!=(noerror)
+#        return err
+#    endif
+#    setcall err file_get_dword(file,p_dw)
+#    if err!=(noerror)
+#        return err
+#    endif
+#    return (noerror)
+#endfunction
+#err
+function file_seek_cursor_get_dword_reverse(sd file,sd offset,sd p_dw)
+    sd err
+    setcall err file_seek_cursor(file,offset)
+    if err!=(noerror)
+        return err
+    endif
+    setcall err file_get_dword_reverse(file,p_dw)
+    if err!=(noerror)
+        return err
+    endif
+    return (noerror)
+endfunction
+
+#err
+function file_read_and_back_with_intervening_call(sd mem,sd size,sd file)
+    sd err
+    #the intervening call is used when a read(write) call follows a write(read) call
+    setcall err file_seek_cursor(file,0)
+    if err!=(noerror)
+        return err
+    endif
+    #
+    setcall err file_read(mem,size,file)
+    if err!=(noerror)
+        return err
+    endif
+    sd pos
+    sd p_pos^pos
+    setcall err file_tell(file,p_pos)
+    if err!=(noerror)
+        return err
+    endif
+    sub pos size
+    setcall err file_seek_set(file,pos)
+    if err!=(noerror)
+        return err
+    endif
+    return (noerror)
+endfunction
+
+##write
+
+function file_write_forward(ss filename,sd forward)
+    sd method
+    setcall method getwritemode()
+    call file_forward(filename,method,forward)
+endfunction
+
+#e
+function file_write(sd buffer,sd size,sd file)
+    data z=0
+    data noe=noerror
+    if size=z
+        return noe
+    endif
+    data byte=1
+    sd sizewrote
+    importx "_fwrite" fwrite
+    setcall sizewrote fwrite(buffer,byte,size,file)
+    if sizewrote!=z
+        return noe
+    endif
+    str er="File write error number: "
+    call strerrno(er)
+    return er
+endfunction
+#bool
+function file_write_string(sd string,sd file)
+    import "slen" slen
+    sd len
+    setcall len slen(string)
+    inc len
+    sd err
+    setcall err file_write(string,len,file)
+    if err!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function file_seekSet_setDwRev_goEnd(sd file,sd offset,sd dw)
+    sd err
+    setcall err file_seek_set(file,offset)
+    if err!=(noerror)
+        return 0
+    endif
+    sd p_dw^dw
+    setcall dw dword_reverse(dw)
+    setcall err file_write(p_dw,4,file)
+    if err!=(noerror)
+        return 0
+    endif
+    setcall err file_seek_end(file)
+    if err!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+#e
+function file_set_dword(sd file,sd position,sd ptr_value)
+    sd err
+
+    sd pos
+    sd p_pos^pos
+    setcall err file_tell(file,p_pos)
+    if err!=(noerror)
+        return err
+    endif
+
+    setcall err file_seek(file,position,(SEEK_SET))
+    if err!=(noerror)
+        return err
+    endif
+
+    setcall err file_write(ptr_value,4,file)
+    if err!=(noerror)
+        return err
+    endif
+
+    setcall err file_seek_set(file,pos)
+    if err!=(noerror)
+        return err
+    endif
+
+    return (noerror)
+endfunction
--- ovideo-1.orig/src/file-folder/file-base.s
+++ /dev/null
@@ -1,445 +0,0 @@
-
-
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-importx "_fopen" fopen
-importx "_fclose" fclose
-importx "_fseek" fseek
-importx "_ftell" ftell
-importx "_fread" fread
-
-import "memoryalloc" memoryalloc
-import "strerrno" strerrno
-
-
-##file base
-#err
-Function openfile(data pfile,str path,str fmode)
-        data null=0
-        SetCall pfile# fopen(path,fmode)
-        If pfile#==null
-            str err="Cannot open a file. Error: "
-            call strerrno(err)
-            return err
-        EndIf
-        Data noerr=noerror
-        Return noerr
-EndFunction
-
-function getreadmode()
-    str read="rb"
-    return read
-endfunction
-
-function getwritemode()
-    str write="wb"
-    return write
-endfunction
-
-#e
-function seek_err(sd seekint)
-    If seekint!=0
-        str seekerr="File seek error: "
-        call strerrno(seekerr)
-        return seekerr
-    endif
-    return (noerror)
-endfunction
-
-#e
-function file_seek(sd file,sd off,sd method)
-    data seekint#1
-    SetCall seekint fseek(file,off,method)
-    sd err
-    setcall err seek_err(seekint)
-endfunction
-
-#e
-function file_seek_set(sd file,sd off)
-    sd err
-    setcall err file_seek(file,off,(SEEK_SET))
-    return err
-endfunction
-
-#e
-function file_seek_end(sd file)
-    sd err
-    setcall err file_seek(file,0,(SEEK_END))
-    return err
-endfunction
-#e
-function file_seek_cursor(sd file,sd off)
-    sd err
-    setcall err file_seek(file,off,(SEEK_CUR))
-    return err
-endfunction
-
-#e
-function file_tell(sd file,sd p_sz)
-    setcall p_sz# ftell(file)
-    if p_sz#==-1
-        str ftellerr="File tell error: "
-        call strerrno(ftellerr)
-        return ftellerr
-    endif
-    return (noerror)
-endfunction
-
-#err
-function file_length(sd file,sd ptr_size)
-    sd err
-    setcall err file_seek_end(file)
-    if err!=(noerror)
-        return err
-    endif
-
-    setcall err file_tell(file,ptr_size)
-    return err
-endfunction
-
-#e
-function file_sizeofseek_offset_plus_size(sd file,sd size,sd filepos,sd p_sizeofseek)
-    sd file_offset
-    sd ptr_file_offset^file_offset
-    sd err
-    setcall err file_tell(file,ptr_file_offset)
-    if err!=(noerror)
-        return err
-    endif
-    add filepos size
-    sub filepos file_offset
-    set p_sizeofseek# filepos
-    return (noerror)
-endfunction
-
-#e
-function file_seek_offset_plus_size(sd file,sd size,sd filepos)
-    #get size of seek
-    sd sizeofseek
-    sd p_sizeofseek^sizeofseek
-    sd err
-    setcall err file_sizeofseek_offset_plus_size(file,size,filepos,p_sizeofseek)
-    if err!=(noerror)
-        return err
-    endif
-
-    #seek
-    setcall err file_seek_cursor(file,sizeofseek)
-    if err!=(noerror)
-        return err
-    endif
-    return (noerror)
-endfunction
-
-#rename return
-function change_name(ss oldpath,ss newpath)
-    importx "_rename" rename
-    import "texter" texter
-    sd ret
-    setcall ret rename(oldpath,newpath)
-    if ret!=0
-        call texter("rename error")
-    endif
-    return ret
-endfunction
-
-##forward simple
-
-#err/returns what forward returns
-function file_forward(ss path,sd method,sd forward)
-    sd returnvalue
-    data noerr=noerror
-    sd file
-    sd ptrfile^file
-    SetCall returnvalue openfile(ptrfile,path,method)
-    If returnvalue!=noerr
-            Return returnvalue
-    EndIf
-    setcall returnvalue forward(file,path)
-    call fclose(file)
-    return returnvalue
-EndFunction
-
-##read
-
-#err
-function readtomem(data file,data ptrsize,data ptrmem,data offset,data trail)
-    sd size
-    sd ptr_size^size
-    sd err
-    setcall err file_length(file,ptr_size)
-    if err!=(noerror)
-        return err
-    endif
-
-    #seek back for reading
-    Call fseek(file,0,(SEEK_SET))
-
-    Set ptrsize# size
-
-    add size offset
-    add size trail
-
-    data noerr=noerror
-    SetCall err memoryalloc(size,ptrmem)
-    If err!=noerr
-        return err
-    endif
-
-    Data mem#1
-    Set mem ptrmem#
-
-    add mem offset
-
-    data byte=1
-    Call fread(mem,byte,ptrsize#,file)
-
-    return noerr
-endfunction
-
-#err
-#get: offset+size+trail
-Function file_get_content_offset_trail(str path,data ptrsize,data ptrmem,data offset,data trail)
-        Data err#1
-        Data noerr=noerror
-
-        Data file#1
-        Data ptrfile^file
-
-        str readfile#1
-        setcall readfile getreadmode()
-        SetCall err openfile(ptrfile,path,readfile)
-        If err!=noerr
-                Return err
-        EndIf
-
-        setcall err readtomem(file,ptrsize,ptrmem,offset,trail)
-        Call fclose(file)
-        Return err
-EndFunction
-
-#err
-function file_get_content(str path,data ptrsize,data ptrmem)
-    data err#1
-    data null=0
-    setcall err file_get_content_offset_trail(path,ptrsize,ptrmem,null,null)
-    return err
-EndFunction
-
-function file_get_content_forward(ss filename,sd forward)
-    sd err
-    sd noerr=noerror
-
-    sd size
-    sd ptr_size^size
-    sd mem
-    sd ptr_mem^mem
-    setcall err file_get_content(filename,ptr_size,ptr_mem)
-    if err!=noerr
-        return err
-    endif
-    call forward(mem,size)
-    importx "_free" free
-    call free(mem)
-endfunction
-
-#e
-function file_forward_read(ss path,sd forward)
-    sd method
-    setcall method getreadmode()
-    sd returnvalue
-    setcall returnvalue file_forward(path,method,forward)
-    return returnvalue
-endfunction
-#e
-function file_read(sd mem,sd size,sd file)
-    sd readed
-    setcall readed fread(mem,1,size,file)
-    if readed!=size
-        str er="Read error: "
-        call strerrno(er)
-        return er
-    endif
-    return (noerror)
-endfunction
-#e
-function file_get_size_forward(sd file,sd size,sd forward)
-    sd mem
-    sd p_mem^mem
-    sd err
-    SetCall err memoryalloc(size,p_mem)
-    If err!=(noerror)
-        return err
-    endif
-    SetCall err file_read(mem,size,file)
-    If err!=(noerror)
-        return err
-    endif
-    call forward(mem,size)
-    call free(mem)
-    return (noerror)
-endfunction
-#e
-function file_get_dword(sd file,sd p_dw)
-    sd err
-    setcall err file_read(p_dw,4,file)
-    return err
-endfunction
-#e
-function file_get_dword_reverse(sd file,sd p_dw)
-    sd err
-    setcall err file_get_dword(file,p_dw)
-    if err!=(noerror)
-        return err
-    endif
-    import "dword_reverse" dword_reverse
-    setcall p_dw# dword_reverse(p_dw#)
-    return (noerror)
-endfunction
-#err
-#function file_seek_cursor_get_dword(sd file,sd offset,sd p_dw)
-#    sd err
-#    setcall err file_seek_cursor(file,offset)
-#    if err!=(noerror)
-#        return err
-#    endif
-#    setcall err file_get_dword(file,p_dw)
-#    if err!=(noerror)
-#        return err
-#    endif
-#    return (noerror)
-#endfunction
-#err
-function file_seek_cursor_get_dword_reverse(sd file,sd offset,sd p_dw)
-    sd err
-    setcall err file_seek_cursor(file,offset)
-    if err!=(noerror)
-        return err
-    endif
-    setcall err file_get_dword_reverse(file,p_dw)
-    if err!=(noerror)
-        return err
-    endif
-    return (noerror)
-endfunction
-
-#err
-function file_read_and_back_with_intervening_call(sd mem,sd size,sd file)
-    sd err
-    #the intervening call is used when a read(write) call follows a write(read) call
-    setcall err file_seek_cursor(file,0)
-    if err!=(noerror)
-        return err
-    endif
-    #
-    setcall err file_read(mem,size,file)
-    if err!=(noerror)
-        return err
-    endif
-    sd pos
-    sd p_pos^pos
-    setcall err file_tell(file,p_pos)
-    if err!=(noerror)
-        return err
-    endif
-    sub pos size
-    setcall err file_seek_set(file,pos)
-    if err!=(noerror)
-        return err
-    endif
-    return (noerror)
-endfunction
-
-##write
-
-function file_write_forward(ss filename,sd forward)
-    sd method
-    setcall method getwritemode()
-    call file_forward(filename,method,forward)
-endfunction
-
-#e
-function file_write(sd buffer,sd size,sd file)
-    data z=0
-    data noe=noerror
-    if size==z
-        return noe
-    endif
-    data byte=1
-    sd sizewrote
-    importx "_fwrite" fwrite
-    setcall sizewrote fwrite(buffer,byte,size,file)
-    if sizewrote!=z
-        return noe
-    endif
-    str er="File write error number: "
-    call strerrno(er)
-    return er
-endfunction
-#bool
-function file_write_string(sd string,sd file)
-    import "slen" slen
-    sd len
-    setcall len slen(string)
-    inc len
-    sd err
-    setcall err file_write(string,len,file)
-    if err!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function file_seekSet_setDwRev_goEnd(sd file,sd offset,sd dw)
-    sd err
-    setcall err file_seek_set(file,offset)
-    if err!=(noerror)
-        return 0
-    endif
-    sd p_dw^dw
-    setcall dw dword_reverse(dw)
-    setcall err file_write(p_dw,4,file)
-    if err!=(noerror)
-        return 0
-    endif
-    setcall err file_seek_end(file)
-    if err!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-#e
-function file_set_dword(sd file,sd position,sd ptr_value)
-    sd err
-
-    sd pos
-    sd p_pos^pos
-    setcall err file_tell(file,p_pos)
-    if err!=(noerror)
-        return err
-    endif
-
-    setcall err file_seek(file,position,(SEEK_SET))
-    if err!=(noerror)
-        return err
-    endif
-
-    setcall err file_write(ptr_value,4,file)
-    if err!=(noerror)
-        return err
-    endif
-
-    setcall err file_seek_set(file,pos)
-    if err!=(noerror)
-        return err
-    endif
-
-    return (noerror)
-endfunction
--- /dev/null
+++ ovideo-1/src/file-folder/folder-base.oc
@@ -0,0 +1,40 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+#e
+import "chdr" chdir
+function dirch(str value)
+    data change#1
+    data zero=0
+    setcall change chdir(value)
+    if change!=zero
+        str chdirerr="Change dir err: "
+        import "strerrno" strerrno
+        call strerrno(chdirerr)
+        return chdirerr
+    endif
+    data noerr=noerror
+    return noerr
+endfunction
+
+#e
+function folder_enterleave_data(ss folder,sv forward,sd data)
+    sd err
+    data noerr=noerror
+    setcall err dirch(folder)
+    if err!=noerr
+        return err
+    endif
+    call forward(data)
+    setcall err dirch("../")
+    return err
+endfunction
+
+function folder_enterleave(ss folder,data forward)
+    data n=0
+    call folder_enterleave_data(folder,forward,n)
+endfunction
--- ovideo-1.orig/src/file-folder/folder-base.s
+++ /dev/null
@@ -1,40 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-#e
-import "chdr" chdir
-function dirch(str value)
-    data change#1
-    data zero=0
-    setcall change chdir(value)
-    if change!=zero
-        str chdirerr="Change dir err: "
-        import "strerrno" strerrno
-        call strerrno(chdirerr)
-        return chdirerr
-    endif
-    data noerr=noerror
-    return noerr
-endfunction
-
-#e
-function folder_enterleave_data(ss folder,sd forward,sd data)
-    sd err
-    data noerr=noerror
-    setcall err dirch(folder)
-    if err!=noerr
-        return err
-    endif
-    call forward(data)
-    setcall err dirch("../")
-    return err
-endfunction
-
-function folder_enterleave(ss folder,data forward)
-    data n=0
-    call folder_enterleave_data(folder,forward,n)
-endfunction
--- /dev/null
+++ ovideo-1/src/gnu/gst.oc
@@ -0,0 +1,252 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+import "getptrgerr" getptrgerr
+import "gerrtoerr" gerrtoerr
+
+function add_bus_signal_watch_got_bus(sd bus)
+    importx "_gst_bus_add_signal_watch" gst_bus_add_signal_watch
+    call gst_bus_add_signal_watch(bus)
+endfunction
+function add_bus_signal_watch(sd pipe)
+    data f^add_bus_signal_watch_got_bus
+    call bus_signals(pipe,f)
+endfunction
+function remove_bus_signal_watch_got_bus(sd bus)
+    importx "_gst_bus_remove_signal_watch" gst_bus_remove_signal_watch
+    call gst_bus_remove_signal_watch(bus)
+endfunction
+function remove_bus_signal_watch(sd pipe)
+    data f^remove_bus_signal_watch_got_bus
+    call bus_signals(pipe,f)
+endfunction
+
+importx "_gst_object_unref" gst_object_unref
+function unset_pipe_and_watch(sd pipe)
+    call remove_bus_signal_watch(pipe)
+    call gst_object_unref(pipe)
+endfunction
+
+#return gst_parse_launch
+function launch_pipe(ss mem)
+    sd ptrgerr
+    setcall ptrgerr getptrgerr()
+
+    importx "_gst_parse_launch" gst_parse_launch
+    sd pipe
+    setcall pipe gst_parse_launch(mem,ptrgerr)
+
+    data n=0
+    if pipe=n
+        call gerrtoerr(ptrgerr)
+    endif
+    call add_bus_signal_watch(pipe)
+    return pipe
+endfunction
+
+
+importx "_gst_element_set_state" gst_element_set_state
+#e
+function start_pipe(sd pipe)
+    data play=GST_STATE_PLAYING
+    data error=GST_STATE_CHANGE_FAILURE
+    data noe=noerror
+    sd ret
+    setcall ret gst_element_set_state(pipe,play)
+    if ret!=error
+        return noe
+    endif
+
+    str er="Unable to set the pipeline to the playing state."
+    import "texter" texter
+    call texter(er)
+    call unset_pipe_and_watch(pipe)
+    return er
+endfunction
+
+#null or pipeline
+function launch_pipe_start(ss command)
+    sd pipeline
+    data n=0
+
+    setcall pipeline launch_pipe(command)
+    if pipeline=n
+        return n
+    endif
+
+    sd err
+    data noerr=noerror
+    setcall err start_pipe(pipeline)
+    if err!=noerr
+        return n
+    endif
+    return pipeline
+endfunction
+
+
+import "set_pipe_null" set_pipe_null
+#
+function default_unref(sd pipe)
+    call set_pipe_null(pipe)
+    call unset_pipe_and_watch(pipe)
+endfunction
+
+function default_unref_ptr(sd ptr_pipe)
+    sd pipe
+    set pipe ptr_pipe#
+    call default_unref(pipe)
+    data z=0
+    set ptr_pipe# z
+endfunction
+#
+
+#
+importx "_gst_message_parse_error" gst_message_parse_error
+function def_error(sd message)
+    sd ptrgerr#1
+    setcall ptrgerr getptrgerr()
+    data null=NULL
+    call gst_message_parse_error(message,ptrgerr,null)
+    call gerrtoerr(ptrgerr)
+endfunction
+function default_error(sd *bus,sd message,sd pipeline)
+    call def_error(message)
+    call default_unref(pipeline)
+endfunction
+function default_error_ptr(sd *bus,sd message,sd ptrpipeline)
+    call def_error(message)
+    call default_unref_ptr(ptrpipeline)
+endfunction
+
+function default_eos(sd *bus,sd *message,sd pipeline)
+    str eos="End Of Stream"
+    call texter(eos)
+    call default_unref(pipeline)
+endfunction
+#
+
+import "connect_signal_data" connect_signal_data
+
+#
+function pipe_default_error(sd bus,sd pipe)
+    data er^default_error
+    str ermsg="message::error"
+    call connect_signal_data(bus,ermsg,er,pipe)
+endfunction
+
+function pipe_default_signals(sd bus,sd pipe)
+    call pipe_default_error(bus,pipe)
+
+    data eos^default_eos
+    str eosmsg="message::eos"
+    call connect_signal_data(bus,eosmsg,eos,pipe)
+endfunction
+#
+
+#
+function bus_signals_data(sd element,sv forwardToSignals,sd forwardToSignalsData)
+    sd bus#1
+    importx "_gst_element_get_bus" gst_element_get_bus
+    setcall bus gst_element_get_bus(element)
+
+    call forwardToSignals(bus,forwardToSignalsData)
+
+    call gst_object_unref(bus)
+endfunction
+
+function bus_signals(sd element,sd forwardToSignals)
+    data n=0
+    call bus_signals_data(element,forwardToSignals,n)
+endfunction
+#
+
+#pipe as data callback
+function bus_signals_bin(sd pipe,sd forward)
+    call bus_signals_data(pipe,forward,pipe)
+endfunction
+#
+#def
+function bus_default_signals(sd pipe)
+    data next^pipe_default_signals
+    call bus_signals_bin(pipe,next)
+endfunction
+#
+
+#default err and eos pipe and modal
+importx "_gtk_dialog_response" gtk_dialog_response
+function default_err_modal(sd *bus,sd message,sd dialog)
+    call def_error(message)
+    call gtk_dialog_response(dialog,(GTK_RESPONSE_CANCEL))
+endfunction
+function default_eos_modal(sd *bus,sd *message,sd dialog)
+    call gtk_dialog_response(dialog,(GTK_RESPONSE_OK))
+endfunction
+#err and eos
+function default_signals_for_modal_set(sd bus,sd dialog)
+    data er^default_err_modal
+    str ermsg="message::error"
+    call connect_signal_data(bus,ermsg,er,dialog)
+
+    data eos^default_eos_modal
+    str eosmsg="message::eos"
+    call connect_signal_data(bus,eosmsg,eos,dialog)
+endfunction
+function default_signals_for_modal(sd pipe,sd dialog)
+    data f^default_signals_for_modal_set
+    call bus_signals_data(pipe,f,dialog)
+endfunction
+#err at modal when dialog is not known, but function to close dialog
+function err_modal(sd *bus,sd message,sv closemodalForward)
+    call def_error(message)
+    call closemodalForward()
+    #sound flag if required
+    import "sound_global_flag_set" sound_global_flag_set
+    call sound_global_flag_set(0)
+endfunction
+function err_signal_modal_set(sd bus,sd closemodalForward)
+    data er^err_modal
+    str ermsg="message::error"
+    call connect_signal_data(bus,ermsg,er,closemodalForward)
+endfunction
+function err_signal_modal(sd pipe,sd closemodalForward)
+    data f^err_signal_modal_set
+    call bus_signals_data(pipe,f,closemodalForward)
+endfunction
+
+importx "_gst_bin_iterate_sinks" gst_bin_iterate_sinks
+importx "_gst_iterator_free" gst_iterator_free
+function iterate_sinks_data(sd pipe,sv forward,sd data)
+    sd iter
+    setcall iter gst_bin_iterate_sinks(pipe)
+    call forward(iter,data)
+    call gst_iterator_free(iter)
+endfunction
+
+function iterate_firstsink(sd pipe,sd forward)
+    sd iter
+    setcall iter gst_bin_iterate_sinks(pipe)
+
+    call iterate_next_forward_data_free(iter,forward,0)
+
+    call gst_iterator_free(iter)
+endfunction
+
+importx "_gst_iterator_next" gst_iterator_next
+function iterate_next_forward_data_free(sd iter,sv forward,sd data)
+    sd elem
+    sd ptr_elem^elem
+    sd ret
+    setcall ret gst_iterator_next(iter,ptr_elem)
+    data er=GST_ITERATOR_ERROR
+    if ret=er
+        str e="Iterator error"
+        call texter(e)
+        return e
+    endif
+    call forward(elem,data)
+    call gst_object_unref(elem)
+endfunction
--- ovideo-1.orig/src/gnu/gst.s
+++ /dev/null
@@ -1,252 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-import "getptrgerr" getptrgerr
-import "gerrtoerr" gerrtoerr
-
-function add_bus_signal_watch_got_bus(sd bus)
-    importx "_gst_bus_add_signal_watch" gst_bus_add_signal_watch
-    call gst_bus_add_signal_watch(bus)
-endfunction
-function add_bus_signal_watch(sd pipe)
-    data f^add_bus_signal_watch_got_bus
-    call bus_signals(pipe,f)
-endfunction
-function remove_bus_signal_watch_got_bus(sd bus)
-    importx "_gst_bus_remove_signal_watch" gst_bus_remove_signal_watch
-    call gst_bus_remove_signal_watch(bus)
-endfunction
-function remove_bus_signal_watch(sd pipe)
-    data f^remove_bus_signal_watch_got_bus
-    call bus_signals(pipe,f)
-endfunction
-
-importx "_gst_object_unref" gst_object_unref
-function unset_pipe_and_watch(sd pipe)
-    call remove_bus_signal_watch(pipe)
-    call gst_object_unref(pipe)
-endfunction
-
-#return gst_parse_launch
-function launch_pipe(ss mem)
-    sd ptrgerr
-    setcall ptrgerr getptrgerr()
-
-    importx "_gst_parse_launch" gst_parse_launch
-    sd pipe
-    setcall pipe gst_parse_launch(mem,ptrgerr)
-
-    data n=0
-    if pipe==n
-        call gerrtoerr(ptrgerr)
-    endif
-    call add_bus_signal_watch(pipe)
-    return pipe
-endfunction
-
-
-importx "_gst_element_set_state" gst_element_set_state
-#e
-function start_pipe(sd pipe)
-    data play=GST_STATE_PLAYING
-    data error=GST_STATE_CHANGE_FAILURE
-    data noe=noerror
-    sd ret
-    setcall ret gst_element_set_state(pipe,play)
-    if ret!=error
-        return noe
-    endif
-
-    str er="Unable to set the pipeline to the playing state."
-    import "texter" texter
-    call texter(er)
-    call unset_pipe_and_watch(pipe)
-    return er
-endfunction
-
-#null or pipeline
-function launch_pipe_start(ss command)
-    sd pipeline
-    data n=0
-
-    setcall pipeline launch_pipe(command)
-    if pipeline==n
-        return n
-    endif
-
-    sd err
-    data noerr=noerror
-    setcall err start_pipe(pipeline)
-    if err!=noerr
-        return n
-    endif
-    return pipeline
-endfunction
-
-
-import "set_pipe_null" set_pipe_null
-#
-function default_unref(sd pipe)
-    call set_pipe_null(pipe)
-    call unset_pipe_and_watch(pipe)
-endfunction
-
-function default_unref_ptr(sd ptr_pipe)
-    sd pipe
-    set pipe ptr_pipe#
-    call default_unref(pipe)
-    data z=0
-    set ptr_pipe# z
-endfunction
-#
-
-#
-importx "_gst_message_parse_error" gst_message_parse_error
-function def_error(sd message)
-    sd ptrgerr#1
-    setcall ptrgerr getptrgerr()
-    data null=NULL
-    call gst_message_parse_error(message,ptrgerr,null)
-    call gerrtoerr(ptrgerr)
-endfunction
-function default_error(sd *bus,sd message,sd pipeline)
-    call def_error(message)
-    call default_unref(pipeline)
-endfunction
-function default_error_ptr(sd *bus,sd message,sd ptrpipeline)
-    call def_error(message)
-    call default_unref_ptr(ptrpipeline)
-endfunction
-
-function default_eos(sd *bus,sd *message,sd pipeline)
-    str eos="End Of Stream"
-    call texter(eos)
-    call default_unref(pipeline)
-endfunction
-#
-
-import "connect_signal_data" connect_signal_data
-
-#
-function pipe_default_error(sd bus,sd pipe)
-    data er^default_error
-    str ermsg="message::error"
-    call connect_signal_data(bus,ermsg,er,pipe)
-endfunction
-
-function pipe_default_signals(sd bus,sd pipe)
-    call pipe_default_error(bus,pipe)
-
-    data eos^default_eos
-    str eosmsg="message::eos"
-    call connect_signal_data(bus,eosmsg,eos,pipe)
-endfunction
-#
-
-#
-function bus_signals_data(sd element,sd forwardToSignals,sd forwardToSignalsData)
-    sd bus#1
-    importx "_gst_element_get_bus" gst_element_get_bus
-    setcall bus gst_element_get_bus(element)
-
-    call forwardToSignals(bus,forwardToSignalsData)
-
-    call gst_object_unref(bus)
-endfunction
-
-function bus_signals(sd element,sd forwardToSignals)
-    data n=0
-    call bus_signals_data(element,forwardToSignals,n)
-endfunction
-#
-
-#pipe as data callback
-function bus_signals_bin(sd pipe,sd forward)
-    call bus_signals_data(pipe,forward,pipe)
-endfunction
-#
-#def
-function bus_default_signals(sd pipe)
-    data next^pipe_default_signals
-    call bus_signals_bin(pipe,next)
-endfunction
-#
-
-#default err and eos pipe and modal
-importx "_gtk_dialog_response" gtk_dialog_response
-function default_err_modal(sd *bus,sd message,sd dialog)
-    call def_error(message)
-    call gtk_dialog_response(dialog,(GTK_RESPONSE_CANCEL))
-endfunction
-function default_eos_modal(sd *bus,sd *message,sd dialog)
-    call gtk_dialog_response(dialog,(GTK_RESPONSE_OK))
-endfunction
-#err and eos
-function default_signals_for_modal_set(sd bus,sd dialog)
-    data er^default_err_modal
-    str ermsg="message::error"
-    call connect_signal_data(bus,ermsg,er,dialog)
-
-    data eos^default_eos_modal
-    str eosmsg="message::eos"
-    call connect_signal_data(bus,eosmsg,eos,dialog)
-endfunction
-function default_signals_for_modal(sd pipe,sd dialog)
-    data f^default_signals_for_modal_set
-    call bus_signals_data(pipe,f,dialog)
-endfunction
-#err at modal when dialog is not known, but function to close dialog
-function err_modal(sd *bus,sd message,sd closemodalForward)
-    call def_error(message)
-    call closemodalForward()
-    #sound flag if required
-    import "sound_global_flag_set" sound_global_flag_set
-    call sound_global_flag_set(0)
-endfunction
-function err_signal_modal_set(sd bus,sd closemodalForward)
-    data er^err_modal
-    str ermsg="message::error"
-    call connect_signal_data(bus,ermsg,er,closemodalForward)
-endfunction
-function err_signal_modal(sd pipe,sd closemodalForward)
-    data f^err_signal_modal_set
-    call bus_signals_data(pipe,f,closemodalForward)
-endfunction
-
-importx "_gst_bin_iterate_sinks" gst_bin_iterate_sinks
-importx "_gst_iterator_free" gst_iterator_free
-function iterate_sinks_data(sd pipe,sd forward,sd data)
-    sd iter
-    setcall iter gst_bin_iterate_sinks(pipe)
-    call forward(iter,data)
-    call gst_iterator_free(iter)
-endfunction
-
-function iterate_firstsink(sd pipe,sd forward)
-    sd iter
-    setcall iter gst_bin_iterate_sinks(pipe)
-
-    call iterate_next_forward_data_free(iter,forward,0)
-
-    call gst_iterator_free(iter)
-endfunction
-
-importx "_gst_iterator_next" gst_iterator_next
-function iterate_next_forward_data_free(sd iter,sd forward,sd data)
-    sd elem
-    sd ptr_elem^elem
-    sd ret
-    setcall ret gst_iterator_next(iter,ptr_elem)
-    data er=GST_ITERATOR_ERROR
-    if ret==er
-        str e="Iterator error"
-        call texter(e)
-        return e
-    endif
-    call forward(elem,data)
-    call gst_object_unref(elem)
-endfunction
--- /dev/null
+++ ovideo-1/src/interface/buttons.oc
@@ -0,0 +1,100 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+#hbox
+function buttons_interface(sd destcontainer,sd lots,sd p_alignment)
+    #alignment for buttons
+    import "alignmentfield" alignmentfield
+    setcall p_alignment# alignmentfield(destcontainer)
+
+    import "hboxfield_cnt" hboxfield_cnt
+    sd hbox
+    setcall hbox hboxfield_cnt(p_alignment#)
+
+    call buttons_lots(lots,hbox)
+    return hbox
+endfunction
+
+function buttons_lots(sd ptr,sd buttons)
+    call buttons_lots_ex(ptr,buttons,0,0)
+endfunction
+function buttons_lots_ex(sd ptr,sd buttons,sd match,sd forward)
+    data z=0
+    while ptr#!=z
+        setcall ptr buttons_group_ex(ptr,buttons,match,forward)
+    endwhile
+endfunction
+
+function buttons_group(sd ptr,sd container)
+    call buttons_group_ex(ptr,container,0,0)
+endfunction
+
+#return: optional: ptr for next
+function buttons_group_ex(sd ptr,sd container,sd match,sv forward)
+    import "slen" slen
+    data z=0
+    data padgroups=5
+    sd hbox
+    import "hboxfield_pack_pad" hboxfield_pack_pad
+    import "buttonfield" buttonfield
+    importx "_gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
+    setcall hbox hboxfield_pack_pad(container,padgroups)
+    while ptr#!=z
+        sd button
+        setcall button buttonfield(hbox)
+
+        import "buttonfield_setimage" buttonfield_setimage
+        call buttonfield_setimage(ptr,button)
+        addcall ptr slen(ptr)
+        inc ptr
+
+        call gtk_widget_set_tooltip_markup(button,ptr)
+        addcall ptr slen(ptr)
+        inc ptr
+
+        str clicked="clicked"
+        import "connect_signal" connect_signal
+        call connect_signal(button,clicked,ptr#)
+
+        if match=ptr#
+            call forward(button,match)
+        endif
+
+        data dword=4
+        add ptr dword
+    endwhile
+    add ptr dword
+    return ptr
+endfunction
+
+
+#alignment
+function linked_instance(sd destcontainer,sd lots,sd trigbutton,sd callbackfunc,sd callbackdata,sd closefunc)
+    importx "_g_signal_handlers_disconnect_matched" g_signal_handlers_disconnect_matched
+    call g_signal_handlers_disconnect_matched(trigbutton,(G_SIGNAL_MATCH_FUNC|G_SIGNAL_MATCH_DATA),0,0,0,callbackfunc,callbackdata)
+
+    sd buttonscontainer
+    sd alignment
+    sd p_alignment^alignment
+    setcall buttonscontainer buttons_interface(destcontainer,lots,p_alignment)
+
+    char connect="close.bmp"
+    char *="Close the panel"
+    data backfunc#1
+    data *=0
+
+    set backfunc closefunc
+
+    data close_connect^connect
+    call buttons_group(close_connect,buttonscontainer)
+
+    importx "_gtk_widget_show_all" gtk_widget_show_all
+    call gtk_widget_show_all(alignment)
+
+    return alignment
+endfunction
+
+
--- ovideo-1.orig/src/interface/buttons.s
+++ /dev/null
@@ -1,100 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-#hbox
-function buttons_interface(sd destcontainer,sd lots,sd p_alignment)
-    #alignment for buttons
-    import "alignmentfield" alignmentfield
-    setcall p_alignment# alignmentfield(destcontainer)
-
-    import "hboxfield_cnt" hboxfield_cnt
-    sd hbox
-    setcall hbox hboxfield_cnt(p_alignment#)
-
-    call buttons_lots(lots,hbox)
-    return hbox
-endfunction
-
-function buttons_lots(sd ptr,sd buttons)
-    call buttons_lots_ex(ptr,buttons,0,0)
-endfunction
-function buttons_lots_ex(sd ptr,sd buttons,sd match,sd forward)
-    data z=0
-    while ptr#!=z
-        setcall ptr buttons_group_ex(ptr,buttons,match,forward)
-    endwhile
-endfunction
-
-function buttons_group(sd ptr,sd container)
-    call buttons_group_ex(ptr,container,0,0)
-endfunction
-
-#return: optional: ptr for next
-function buttons_group_ex(sd ptr,sd container,sd match,sd forward)
-    import "slen" slen
-    data z=0
-    data padgroups=5
-    sd hbox
-    import "hboxfield_pack_pad" hboxfield_pack_pad
-    import "buttonfield" buttonfield
-    importx "_gtk_widget_set_tooltip_markup" gtk_widget_set_tooltip_markup
-    setcall hbox hboxfield_pack_pad(container,padgroups)
-    while ptr#!=z
-        sd button
-        setcall button buttonfield(hbox)
-
-        import "buttonfield_setimage" buttonfield_setimage
-        call buttonfield_setimage(ptr,button)
-        addcall ptr slen(ptr)
-        inc ptr
-
-        call gtk_widget_set_tooltip_markup(button,ptr)
-        addcall ptr slen(ptr)
-        inc ptr
-
-        str clicked="clicked"
-        import "connect_signal" connect_signal
-        call connect_signal(button,clicked,ptr#)
-
-        if match==ptr#
-            call forward(button,match)
-        endif
-
-        data dword=4
-        add ptr dword
-    endwhile
-    add ptr dword
-    return ptr
-endfunction
-
-
-#alignment
-function linked_instance(sd destcontainer,sd lots,sd trigbutton,sd callbackfunc,sd callbackdata,sd closefunc)
-    importx "_g_signal_handlers_disconnect_matched" g_signal_handlers_disconnect_matched
-    call g_signal_handlers_disconnect_matched(trigbutton,(G_SIGNAL_MATCH_FUNC|G_SIGNAL_MATCH_DATA),0,0,0,callbackfunc,callbackdata)
-
-    sd buttonscontainer
-    sd alignment
-    sd p_alignment^alignment
-    setcall buttonscontainer buttons_interface(destcontainer,lots,p_alignment)
-
-    char connect="close.bmp"
-    char *="Close the panel"
-    data backfunc#1
-    data *=0
-
-    set backfunc closefunc
-
-    data close_connect^connect
-    call buttons_group(close_connect,buttonscontainer)
-
-    importx "_gtk_widget_show_all" gtk_widget_show_all
-    call gtk_widget_show_all(alignment)
-
-    return alignment
-endfunction
-
-
--- /dev/null
+++ ovideo-1/src/media/audiovideo.oc
@@ -0,0 +1,597 @@
+
+format elfobj
+include "../_include/include.h"
+
+#audio video read or write
+
+function av_readwrite_value(sd action,sd value)
+    data readwrite_value#1
+    if action=(value_set)
+        set readwrite_value value
+    else
+        return readwrite_value
+    endelse
+endfunction
+
+#container read or write, little endian
+#bool
+function av_chunk_readwrite(sd file,sv forward,ss riff)
+    sd bool
+    sd err
+    sd io
+    setcall io av_readwrite_value((value_get))
+
+    import "file_write" file_write
+
+    sd chunk_id
+    sd chunk_size
+    sd p_chunk^chunk_id
+
+    if io=(write_file)
+        import "cpymem" cpymem
+        call cpymem(p_chunk,riff,4)
+
+        #write id-size, 8 bytes
+        setcall err file_write(p_chunk,8,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        #get id-size
+        import "file_read" file_read
+        setcall err file_read(p_chunk,8,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+
+    import "file_tell" file_tell
+
+    #get the point for write/read calculations
+    sd file_pos
+    sd ptr_file_pos^file_pos
+    setcall err file_tell(file,ptr_file_pos)
+    if err!=(noerror)
+        return 0
+    endif
+
+    #write only, but can be used if io is changed inside
+    sd writepoint
+    set writepoint file_pos
+    sub writepoint 4
+
+    #                         write+read(segment offset)
+    setcall bool forward(file,file_pos,p_chunk,chunk_size)
+    #                                  read(iterate chunks)
+
+    import "file_set_dword" file_set_dword
+    import "file_seek" file_seek
+    #io again if changed inside the riff
+    setcall io av_readwrite_value((value_get))
+
+    if io=(write_file)
+    #set the size at write
+        sd seg_size_after
+        sd ptr_seg_size_after^seg_size_after
+        setcall err file_tell(file,ptr_seg_size_after)
+        if err!=(noerror)
+            return 0
+        endif
+        sub seg_size_after file_pos
+
+        setcall err file_set_dword(file,writepoint,ptr_seg_size_after)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+    #at read, advance remaining/all size cursor
+        add file_pos chunk_size
+        setcall err file_seek(file,file_pos,(SEEK_SET))
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+
+    return bool
+endfunction
+
+#bool
+function av_writeseek(sd mem,sd size,sd file)
+    sd err
+    sd io
+    setcall io av_readwrite_value((value_get))
+    if io=(write_file)
+        setcall err file_write(mem,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        import "file_seek_cursor" file_seek_cursor
+        setcall err file_seek_cursor(file,size)
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+    return 1
+endfunction
+
+#riff chunks
+#bool
+function riff_chunk_w_r(sd file,sd forward,ss riff)
+    sd err
+
+    sd startpos
+    sd p_startpos^startpos
+
+    setcall err file_tell(file,p_startpos)
+    if err!=(noerror)
+        return 0
+    endif
+
+    sd bool
+    setcall bool av_chunk_readwrite(file,forward,riff)
+    if bool!=1
+        return 0
+    endif
+
+    sd endpos
+    sd p_endpos^endpos
+    setcall err file_tell(file,p_endpos)
+    if err!=(noerror)
+        return 0
+    endif
+
+    sub endpos startpos
+    and endpos 1
+    if endpos!=0
+        sd pad=0
+        sd p_pad^pad
+        setcall bool av_writeseek(p_pad,1,file)
+        if bool!=1
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+function riff_w_r_name(sd file,ss name)
+    sd bool
+    setcall bool av_writeseek(name,4,file)
+    return bool
+endfunction
+
+
+
+
+
+
+#dialog for read/write waiting
+
+import "dialog_modal_texter_draw" dialog_modal_texter_draw
+
+function av_dialog_run_simple(sd forward)
+    call av_dialog_run(forward,0)
+endfunction
+
+#bool
+function av_dialog_run(sd forward,sd data)
+    data dialog#1
+
+    #init for linux terminal capture
+    import "dialog_modal_texter_drawwidget" dialog_modal_texter_drawwidget
+    call dialog_modal_texter_drawwidget((value_set),0)
+    call av_dialog_multiline_info((value_set),0)
+    set dialog 0
+
+    import "capture_terminal" capture_terminal
+    sd term
+    setcall term capture_terminal((value_get))
+    if term=0
+        #initiate the dialog
+        import "dialogfield_modal_texter_core" dialogfield_modal_texter_core
+        ss title="Audio Video Dialog"
+        ss button="Close"
+        data init_forward^av_dialog_init
+        setcall dialog dialogfield_modal_texter_core(title,init_forward,button)
+    endif
+
+    #flag to stop the read/write on another thread
+    call av_dialog_stop((value_set),0)
+
+    sd bool=0
+
+    #create the thread
+    import "getptrgerr" getptrgerr
+    sd ptrgerr
+    setcall ptrgerr getptrgerr()
+    importx "_g_thread_create" g_thread_create
+    sd thread
+    setcall thread g_thread_create(forward,data,1,ptrgerr)
+    if thread=0
+        import "gerrtoerr" gerrtoerr
+        call gerrtoerr(ptrgerr)
+    else
+        if term=0
+            #dialog run
+            importx "_gtk_dialog_run" gtk_dialog_run
+            sd response=GTK_RESPONSE_OK+1
+            sd stop_click=0
+            while response!=(GTK_RESPONSE_OK)
+                setcall response gtk_dialog_run(dialog)
+                if response!=(GTK_RESPONSE_OK)
+                    call av_dialog_stop((value_set),1)
+                    set stop_click 1
+                endif
+            endwhile
+            if stop_click=0
+                #keep the dialog for viewing informations
+                sd toggle
+                setcall toggle av_results((value_get))
+                if toggle!=0
+                    call gtk_dialog_run(dialog)
+                    import "stage_file_options_info_message" stage_file_options_info_message
+                    sd toggle_button
+                    setcall toggle_button av_results_toggle_button((value_get))
+                    importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
+                    setcall toggle gtk_toggle_button_get_active(toggle_button)
+                    if toggle=1
+                        call stage_file_options_info_message((value_set),0)
+                    endif
+                endif
+            endif
+        else
+            import "capture_alt_ev_wait" capture_alt_ev_wait
+            call capture_alt_ev_wait()
+        endelse
+        #close the other thread and get return(optional)
+        importx "_g_thread_join" g_thread_join
+        setcall bool g_thread_join(thread)
+    endelse
+
+    if dialog!=0
+        #for text draw callbacks
+        call dialog_modal_texter_drawwidget((value_set),0)
+        #free dialog
+        importx "_gtk_widget_destroy" gtk_widget_destroy
+        call gtk_widget_destroy(dialog) #here is not saying critical at windows, but also on linux the dialog needs to be destroyed
+    endif
+
+    return bool
+
+    const av_dialog^dialog
+endfunction
+function av_dialog_handle()
+    sd p%av_dialog
+    return p#
+endfunction
+function av_dialog_close()
+    sd dialog
+    setcall dialog av_dialog_handle()
+    if dialog!=0
+    #close the dialog
+        importx "_gtk_dialog_response" gtk_dialog_response
+        call gtk_dialog_response(dialog,(GTK_RESPONSE_OK))
+    else
+    #signal the terminal
+        import "capture_alt_ev_set" capture_alt_ev_set
+        call capture_alt_ev_set()
+    endelse
+endfunction
+function av_dialog_stop(sd action,sd value)
+    data x#1
+    if action=(value_set)
+        set x value
+    else
+        return x
+    endelse
+endfunction
+
+import "slen" slen
+
+#text iter at get
+function av_dialog_multiline_info(sd action,sd arg)
+    data view#1
+    sd buffer
+    if action=(value_set)
+        set view arg
+    else
+    #if action==(value_insert)
+        if view=0
+            return 0
+        endif
+        importx "_gtk_text_view_get_buffer" gtk_text_view_get_buffer
+        sd text
+        set text arg
+        setcall buffer gtk_text_view_get_buffer(view)
+        sd len
+        setcall len slen(text)
+        importx "_gtk_text_buffer_insert_at_cursor" gtk_text_buffer_insert_at_cursor
+        call gtk_text_buffer_insert_at_cursor(buffer,text,len)
+    endelse
+endfunction
+
+function av_dialog_init(sd vbox,sd *dialog)
+    #init for read
+    call av_display_info((value_set))
+    #info widgets
+    importx "_gtk_scrolled_window_new" gtk_scrolled_window_new
+    sd scroll
+    setcall scroll gtk_scrolled_window_new(0,0)
+    call av_results((value_set),scroll,vbox)
+    importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
+    call gtk_widget_set_size_request(scroll,-1,200)
+    importx "_gtk_text_view_new" gtk_text_view_new
+    sd view
+    setcall view gtk_text_view_new()
+    import "container_add" container_add
+    call container_add(scroll,view)
+    call av_dialog_multiline_info((value_set),view)
+    importx "_gtk_text_view_set_editable" gtk_text_view_set_editable
+    call gtk_text_view_set_editable(view,(FALSE))
+endfunction
+
+function av_results(sd action,sd scroll,sd vbox)
+    data scroll_entry#1
+    data vbox_entry#1
+    if action=(value_set)
+        set scroll_entry scroll
+        set vbox_entry vbox
+    else
+    #returns toggle flag status (1/0)
+        importx "_gtk_container_add" gtk_container_add
+        call gtk_container_add(vbox_entry,scroll_entry)
+        importx "_gtk_widget_show_all" gtk_widget_show_all
+        call gtk_widget_show_all(scroll_entry)
+
+        #info message flag
+        sd toggle
+        setcall toggle stage_file_options_info_message((value_get))
+        if toggle=0
+            return 0
+        endif
+        importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
+        ss txt="Disable results message(set from Stage Options to disable permanently)"
+        sd results_toggle
+        setcall results_toggle gtk_check_button_new_with_label(txt)
+        import "packstart_default" packstart_default
+        call packstart_default(vbox_entry,results_toggle)
+        call av_results_toggle_button((value_set),results_toggle)
+        importx "_gtk_widget_show" gtk_widget_show
+        call gtk_widget_show(results_toggle)
+        return 1
+    endelse
+endfunction
+
+function av_results_toggle_button(sd action,sd value)
+    data toggle#1
+    if action=(value_set)
+        set toggle value
+    else
+        return toggle
+    endelse
+endfunction
+
+const av_info_all=0
+const av_info_simple=1
+
+#at write
+function av_display_progress(sd image_nr,sd flag_simple)
+    #capture_flag and read info both goes in flag_simple
+	const procimgstrstart=\
+	char format_stage="Processed images: %u/%u"
+	char data#\-procimgstrstart-2-2+dword_max+dword_max
+	vstr string^data
+	char format_capture="Processed images: %u"
+    importx "_sprintf" sprintf
+    if flag_simple=(av_info_all)
+        import "stage_get_frames" stage_get_frames
+        sd totalframes
+        setcall totalframes stage_get_frames()
+        call sprintf(string,#format_stage,image_nr,totalframes)
+    else
+    #on
+        call sprintf(string,#format_capture,image_nr)
+    endelse
+    call dialog_modal_texter_draw(string)
+endfunction
+
+function av_display_info_progress(sd file,sd current_frame)
+    sd image_nr
+    set image_nr current_frame
+    inc image_nr
+    call av_display_progress(image_nr,(av_info_all))
+    call av_display_info((value_write),file,current_frame)
+endfunction
+
+function av_display_info(sd action,sd file,sd nr,sd frame_size)
+    data start#1
+    data end#1
+    data p_start^start
+    data p_end^end
+    data read_counter#1
+    if action=(value_set)
+        #set read counter
+        set read_counter 0
+    elseif action=(value_get)
+        call file_tell(file,p_start)
+        #get start pointer
+    else
+        #if action==(value_write)
+        #get/display
+        char bf#100
+        str text^bf
+        str format="Frame: %u, Size: %u bytes"
+        sd size
+
+        if nr!=-1
+            #write
+            call file_tell(file,p_end)
+            set size end
+            sub size start
+        else
+            #read
+            set nr read_counter
+            inc read_counter
+            set size frame_size
+            #add visual info
+            sd imgs
+            set imgs nr
+            inc imgs
+            call av_display_progress(imgs,(av_info_simple))
+        endelse
+
+        call sprintf(text,format,nr,size)
+        sd len
+        setcall len slen(text)
+        ss cursor
+        set cursor text
+        add cursor len
+        set cursor# (LineFeed)
+        inc cursor
+        set cursor# 0
+        call av_dialog_multiline_info((value_insert),text)
+    endelse
+endfunction
+
+#bool
+function av_read_row(sd width,sd height,sd buffer,sd bytes,sd filerowstride,sd rowindex)
+    import "rgb_get_rowstride" rgb_get_rowstride
+    sd bufferrowstride
+    setcall bufferrowstride rgb_get_rowstride(width)
+
+    import "texter" texter
+	if filerowstride>bufferrowstride
+        ss rstr="Rowstride too large"
+        call texter(rstr)
+        return 0
+	endif
+	if rowindex>=height
+        ss herr="Height too big"
+        call texter(herr)
+        return 0
+	endif
+
+    mult bufferrowstride rowindex
+    add buffer bufferrowstride
+
+    call cpymem(buffer,bytes,filerowstride)
+
+    return 1
+endfunction
+
+#bool
+function riff_head(sd mem_sz,ss chunk,sd p_chunk_size,ss riff_ex)
+    sd mem
+    sd size
+    sd block^mem
+    call cpymem(block,mem_sz,8)
+    if size<8
+        str er="More size expected"
+        call texter(er)
+        return 0
+    endif
+    import "cmpmem" cmpmem
+    sd cmp
+    setcall cmp cmpmem(chunk,mem,4)
+    if cmp!=(equalCompare)
+        str cmp_er="Unrecognized chunk"
+        call texter(cmp_er)
+        return 0
+    endif
+    import "move_cursors" move_cursors
+    call move_cursors(block,4)
+    set p_chunk_size# mem#
+    call move_cursors(block,4)
+    if p_chunk_size#>size
+        str sz_er="Too much size"
+        call texter(sz_er)
+        return 0
+    endif
+    if riff_ex!=0
+        #ex: RIFF,size,WAVE
+        if size<4
+            call texter(er)
+            return 0
+        endif
+        setcall cmp cmpmem(riff_ex,mem,4)
+        if cmp!=(equalCompare)
+            call texter(cmp_er)
+            return 0
+        endif
+        call move_cursors(block,4)
+        sub p_chunk_size# 4
+    endif
+    call cpymem(mem_sz,block,8)
+    return 1
+endfunction
+
+
+function combo_location(sd bool,sd data)
+    import "stage_get_output_container" stage_get_output_container
+    sd location
+    if bool=0
+        setcall location stage_get_output_container()
+    else
+        import "capture_path" capture_path
+        import "stage_file_get_format" stage_file_get_format
+        ss format
+        setcall format stage_file_get_format()
+        setcall location capture_path(format,1,data)
+    endelse
+    return location
+endfunction
+
+
+function av_expand()
+    import "frame_jobs" frame_jobs
+    sd bool
+    setcall bool frame_jobs()
+    if bool!=1
+        return 0
+    endif
+
+    import "filechooserfield" filechooserfield
+    sd filename
+    setcall filename filechooserfield()
+    if filename=0
+        return 0
+    endif
+
+    call av_expand_go(filename)
+
+    importx "_free" free
+    call free(filename)
+endfunction
+import "cmpmem_s" cmpmem_s
+function av_expand_go(ss filename)
+    import "path_extension" path_extension
+    ss extension
+    setcall extension path_extension(filename)
+    sd length
+    setcall length slen(extension)
+    inc length
+    str a="avi"
+    str m="mp4"
+    sd frm_len
+    sd compare
+
+    import "avi_write_fname" avi_write_fname
+    setcall frm_len slen(a)
+    inc frm_len
+    setcall compare cmpmem_s(extension,length,a,frm_len)
+    if compare=(equalCompare)
+        call avi_write_fname(filename,(avi_expand))
+        return (void)
+    endif
+
+    setcall frm_len slen(m)
+    inc frm_len
+    setcall compare cmpmem_s(extension,length,m,frm_len)
+    if compare=(equalCompare)
+        import "mp4_extend" mp4_extend
+        call mp4_extend(filename)
+        return (void)
+    endif
+
+    call texter("Unrecognized format")
+endfunction
--- ovideo-1.orig/src/media/audiovideo.s
+++ /dev/null
@@ -1,596 +0,0 @@
-
-format elfobj
-include "../_include/include.h"
-
-#audio video read or write
-
-function av_readwrite_value(sd action,sd value)
-    data readwrite_value#1
-    if action==(value_set)
-        set readwrite_value value
-    else
-        return readwrite_value
-    endelse
-endfunction
-
-#container read or write, little endian
-#bool
-function av_chunk_readwrite(sd file,sd forward,ss riff)
-    sd bool
-    sd err
-    sd io
-    setcall io av_readwrite_value((value_get))
-
-    import "file_write" file_write
-
-    sd chunk_id
-    sd chunk_size
-    sd p_chunk^chunk_id
-
-    if io==(write_file)
-        import "cpymem" cpymem
-        call cpymem(p_chunk,riff,4)
-
-        #write id-size, 8 bytes
-        setcall err file_write(p_chunk,8,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        #get id-size
-        import "file_read" file_read
-        setcall err file_read(p_chunk,8,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-
-    import "file_tell" file_tell
-
-    #get the point for write/read calculations
-    sd file_pos
-    sd ptr_file_pos^file_pos
-    setcall err file_tell(file,ptr_file_pos)
-    if err!=(noerror)
-        return 0
-    endif
-
-    #write only, but can be used if io is changed inside
-    sd writepoint
-    set writepoint file_pos
-    sub writepoint 4
-
-    #                         write+read(segment offset)
-    setcall bool forward(file,file_pos,p_chunk,chunk_size)
-    #                                  read(iterate chunks)
-
-    import "file_set_dword" file_set_dword
-    import "file_seek" file_seek
-    #io again if changed inside the riff
-    setcall io av_readwrite_value((value_get))
-
-    if io==(write_file)
-    #set the size at write
-        sd seg_size_after
-        sd ptr_seg_size_after^seg_size_after
-        setcall err file_tell(file,ptr_seg_size_after)
-        if err!=(noerror)
-            return 0
-        endif
-        sub seg_size_after file_pos
-
-        setcall err file_set_dword(file,writepoint,ptr_seg_size_after)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-    #at read, advance remaining/all size cursor
-        add file_pos chunk_size
-        setcall err file_seek(file,file_pos,(SEEK_SET))
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-
-    return bool
-endfunction
-
-#bool
-function av_writeseek(sd mem,sd size,sd file)
-    sd err
-    sd io
-    setcall io av_readwrite_value((value_get))
-    if io==(write_file)
-        setcall err file_write(mem,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        import "file_seek_cursor" file_seek_cursor
-        setcall err file_seek_cursor(file,size)
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-    return 1
-endfunction
-
-#riff chunks
-#bool
-function riff_chunk_w_r(sd file,sd forward,ss riff)
-    sd err
-
-    sd startpos
-    sd p_startpos^startpos
-
-    setcall err file_tell(file,p_startpos)
-    if err!=(noerror)
-        return 0
-    endif
-
-    sd bool
-    setcall bool av_chunk_readwrite(file,forward,riff)
-    if bool!=1
-        return 0
-    endif
-
-    sd endpos
-    sd p_endpos^endpos
-    setcall err file_tell(file,p_endpos)
-    if err!=(noerror)
-        return 0
-    endif
-
-    sub endpos startpos
-    and endpos 1
-    if endpos!=0
-        sd pad=0
-        sd p_pad^pad
-        setcall bool av_writeseek(p_pad,1,file)
-        if bool!=1
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-function riff_w_r_name(sd file,ss name)
-    sd bool
-    setcall bool av_writeseek(name,4,file)
-    return bool
-endfunction
-
-
-
-
-
-
-#dialog for read/write waiting
-
-import "dialog_modal_texter_draw" dialog_modal_texter_draw
-
-function av_dialog_run_simple(sd forward)
-    call av_dialog_run(forward,0)
-endfunction
-
-#bool
-function av_dialog_run(sd forward,sd data)
-    data dialog#1
-
-    #init for linux terminal capture
-    import "dialog_modal_texter_drawwidget" dialog_modal_texter_drawwidget
-    call dialog_modal_texter_drawwidget((value_set),0)
-    call av_dialog_multiline_info((value_set),0)
-    set dialog 0
-
-    import "capture_terminal" capture_terminal
-    sd term
-    setcall term capture_terminal((value_get))
-    if term==0
-        #initiate the dialog
-        import "dialogfield_modal_texter_core" dialogfield_modal_texter_core
-        ss title="Audio Video Dialog"
-        ss button="Close"
-        data init_forward^av_dialog_init
-        setcall dialog dialogfield_modal_texter_core(title,init_forward,button)
-    endif
-
-    #flag to stop the read/write on another thread
-    call av_dialog_stop((value_set),0)
-
-    sd bool=0
-
-    #create the thread
-    import "getptrgerr" getptrgerr
-    sd ptrgerr
-    setcall ptrgerr getptrgerr()
-    importx "_g_thread_create" g_thread_create
-    sd thread
-    setcall thread g_thread_create(forward,data,1,ptrgerr)
-    if thread==0
-        import "gerrtoerr" gerrtoerr
-        call gerrtoerr(ptrgerr)
-    else
-        if term==0
-            #dialog run
-            importx "_gtk_dialog_run" gtk_dialog_run
-            sd response=GTK_RESPONSE_OK+1
-            sd stop_click=0
-            while response!=(GTK_RESPONSE_OK)
-                setcall response gtk_dialog_run(dialog)
-                if response!=(GTK_RESPONSE_OK)
-                    call av_dialog_stop((value_set),1)
-                    set stop_click 1
-                endif
-            endwhile
-            if stop_click==0
-                #keep the dialog for viewing informations
-                sd toggle
-                setcall toggle av_results((value_get))
-                if toggle!=0
-                    call gtk_dialog_run(dialog)
-                    import "stage_file_options_info_message" stage_file_options_info_message
-                    sd toggle_button
-                    setcall toggle_button av_results_toggle_button((value_get))
-                    importx "_gtk_toggle_button_get_active" gtk_toggle_button_get_active
-                    setcall toggle gtk_toggle_button_get_active(toggle_button)
-                    if toggle==1
-                        call stage_file_options_info_message((value_set),0)
-                    endif
-                endif
-            endif
-        else
-            import "capture_alt_ev_wait" capture_alt_ev_wait
-            call capture_alt_ev_wait()
-        endelse
-        #close the other thread and get return(optional)
-        importx "_g_thread_join" g_thread_join
-        setcall bool g_thread_join(thread)
-    endelse
-
-    if dialog!=0
-        #for text draw callbacks
-        call dialog_modal_texter_drawwidget((value_set),0)
-        #free dialog
-        importx "_gtk_widget_destroy" gtk_widget_destroy
-        call gtk_widget_destroy(dialog) #here is not saying critical at windows, but also on linux the dialog needs to be destroyed
-    endif
-
-    return bool
-
-    const av_dialog^dialog
-endfunction
-function av_dialog_handle()
-    sd p%av_dialog
-    return p#
-endfunction
-function av_dialog_close()
-    sd dialog
-    setcall dialog av_dialog_handle()
-    if dialog!=0
-    #close the dialog
-        importx "_gtk_dialog_response" gtk_dialog_response
-        call gtk_dialog_response(dialog,(GTK_RESPONSE_OK))
-    else
-    #signal the terminal
-        import "capture_alt_ev_set" capture_alt_ev_set
-        call capture_alt_ev_set()
-    endelse
-endfunction
-function av_dialog_stop(sd action,sd value)
-    data x#1
-    if action==(value_set)
-        set x value
-    else
-        return x
-    endelse
-endfunction
-
-import "slen" slen
-
-#text iter at get
-function av_dialog_multiline_info(sd action,sd arg)
-    data view#1
-    sd buffer
-    if action==(value_set)
-        set view arg
-    else
-    #if action==(value_insert)
-        if view==0
-            return 0
-        endif
-        importx "_gtk_text_view_get_buffer" gtk_text_view_get_buffer
-        sd text
-        set text arg
-        setcall buffer gtk_text_view_get_buffer(view)
-        sd len
-        setcall len slen(text)
-        importx "_gtk_text_buffer_insert_at_cursor" gtk_text_buffer_insert_at_cursor
-        call gtk_text_buffer_insert_at_cursor(buffer,text,len)
-    endelse
-endfunction
-
-function av_dialog_init(sd vbox,sd *dialog)
-    #init for read
-    call av_display_info((value_set))
-    #info widgets
-    importx "_gtk_scrolled_window_new" gtk_scrolled_window_new
-    sd scroll
-    setcall scroll gtk_scrolled_window_new(0,0)
-    call av_results((value_set),scroll,vbox)
-    importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
-    call gtk_widget_set_size_request(scroll,-1,200)
-    importx "_gtk_text_view_new" gtk_text_view_new
-    sd view
-    setcall view gtk_text_view_new()
-    import "container_add" container_add
-    call container_add(scroll,view)
-    call av_dialog_multiline_info((value_set),view)
-    importx "_gtk_text_view_set_editable" gtk_text_view_set_editable
-    call gtk_text_view_set_editable(view,(FALSE))
-endfunction
-
-function av_results(sd action,sd scroll,sd vbox)
-    data scroll_entry#1
-    data vbox_entry#1
-    if action==(value_set)
-        set scroll_entry scroll
-        set vbox_entry vbox
-    else
-    #returns toggle flag status (1/0)
-        importx "_gtk_container_add" gtk_container_add
-        call gtk_container_add(vbox_entry,scroll_entry)
-        importx "_gtk_widget_show_all" gtk_widget_show_all
-        call gtk_widget_show_all(scroll_entry)
-
-        #info message flag
-        sd toggle
-        setcall toggle stage_file_options_info_message((value_get))
-        if toggle==0
-            return 0
-        endif
-        importx "_gtk_check_button_new_with_label" gtk_check_button_new_with_label
-        ss txt="Disable results message(set from Stage Options to disable permanently)"
-        sd results_toggle
-        setcall results_toggle gtk_check_button_new_with_label(txt)
-        import "packstart_default" packstart_default
-        call packstart_default(vbox_entry,results_toggle)
-        call av_results_toggle_button((value_set),results_toggle)
-        importx "_gtk_widget_show" gtk_widget_show
-        call gtk_widget_show(results_toggle)
-        return 1
-    endelse
-endfunction
-
-function av_results_toggle_button(sd action,sd value)
-    data toggle#1
-    if action==(value_set)
-        set toggle value
-    else
-        return toggle
-    endelse
-endfunction
-
-const av_info_all=0
-const av_info_simple=1
-
-#at write
-function av_display_progress(sd image_nr,sd flag_simple)
-    #capture_flag and read info both goes in flag_simple
-	const procimgstrstart=!
-	char format_stage="Processed images: %u/%u"
-	char data#!-procimgstrstart-2-2+dword_max+dword_max
-	vstr string^data
-	char format_capture="Processed images: %u"
-    importx "_sprintf" sprintf
-    if flag_simple==(av_info_all)
-        import "stage_get_frames" stage_get_frames
-        sd totalframes
-        setcall totalframes stage_get_frames()
-        call sprintf(string,#format_stage,image_nr,totalframes)
-    else
-    #on
-        call sprintf(string,#format_capture,image_nr)
-    endelse
-    call dialog_modal_texter_draw(string)
-endfunction
-
-function av_display_info_progress(sd file,sd current_frame)
-    sd image_nr
-    set image_nr current_frame
-    inc image_nr
-    call av_display_progress(image_nr,(av_info_all))
-    call av_display_info((value_write),file,current_frame)
-endfunction
-
-function av_display_info(sd action,sd file,sd nr,sd frame_size)
-    data start#1
-    data end#1
-    data p_start^start
-    data p_end^end
-    data read_counter#1
-    if action==(value_set)
-        #set read counter
-        set read_counter 0
-    elseif action==(value_get)
-        call file_tell(file,p_start)
-        #get start pointer
-    else
-        #if action==(value_write)
-        #get/display
-        char bf#100
-        str text^bf
-        str format="Frame: %u, Size: %u bytes"
-        sd size
-
-        if nr!=-1
-            #write
-            call file_tell(file,p_end)
-            set size end
-            sub size start
-        else
-            #read
-            set nr read_counter
-            inc read_counter
-            set size frame_size
-            #add visual info
-            sd imgs
-            set imgs nr
-            inc imgs
-            call av_display_progress(imgs,(av_info_simple))
-        endelse
-
-        call sprintf(text,format,nr,size)
-        sd len
-        setcall len slen(text)
-        ss cursor
-        set cursor text
-        add cursor len
-        set cursor# (LineFeed)
-        inc cursor
-        set cursor# 0
-        call av_dialog_multiline_info((value_insert),text)
-    endelse
-endfunction
-
-#bool
-function av_read_row(sd width,sd height,sd buffer,sd bytes,sd filerowstride,sd rowindex)
-    import "rgb_get_rowstride" rgb_get_rowstride
-    sd bufferrowstride
-    setcall bufferrowstride rgb_get_rowstride(width)
-
-    import "texter" texter
-    if filerowstride>bufferrowstride
-        ss rstr="Rowstride too large"
-        call texter(rstr)
-        return 0
-    elseif rowindex>=height
-        ss herr="Height too big"
-        call texter(herr)
-        return 0
-    endelseif
-
-    mult bufferrowstride rowindex
-    add buffer bufferrowstride
-
-    call cpymem(buffer,bytes,filerowstride)
-
-    return 1
-endfunction
-
-#bool
-function riff_head(sd mem_sz,ss chunk,sd p_chunk_size,ss riff_ex)
-    sd mem
-    sd size
-    sd block^mem
-    call cpymem(block,mem_sz,8)
-    if size<8
-        str er="More size expected"
-        call texter(er)
-        return 0
-    endif
-    import "cmpmem" cmpmem
-    sd cmp
-    setcall cmp cmpmem(chunk,mem,4)
-    if cmp!=(equalCompare)
-        str cmp_er="Unrecognized chunk"
-        call texter(cmp_er)
-        return 0
-    endif
-    import "move_cursors" move_cursors
-    call move_cursors(block,4)
-    set p_chunk_size# mem#
-    call move_cursors(block,4)
-    if p_chunk_size#>size
-        str sz_er="Too much size"
-        call texter(sz_er)
-        return 0
-    endif
-    if riff_ex!=0
-        #ex: RIFF,size,WAVE
-        if size<4
-            call texter(er)
-            return 0
-        endif
-        setcall cmp cmpmem(riff_ex,mem,4)
-        if cmp!=(equalCompare)
-            call texter(cmp_er)
-            return 0
-        endif
-        call move_cursors(block,4)
-        sub p_chunk_size# 4
-    endif
-    call cpymem(mem_sz,block,8)
-    return 1
-endfunction
-
-
-function combo_location(sd bool,sd data)
-    import "stage_get_output_container" stage_get_output_container
-    sd location
-    if bool==0
-        setcall location stage_get_output_container()
-    else
-        import "capture_path" capture_path
-        import "stage_file_get_format" stage_file_get_format
-        ss format
-        setcall format stage_file_get_format()
-        setcall location capture_path(format,1,data)
-    endelse
-    return location
-endfunction
-
-
-function av_expand()
-    import "frame_jobs" frame_jobs
-    sd bool
-    setcall bool frame_jobs()
-    if bool!=1
-        return 0
-    endif
-
-    import "filechooserfield" filechooserfield
-    sd filename
-    setcall filename filechooserfield()
-    if filename==0
-        return 0
-    endif
-
-    call av_expand_go(filename)
-
-    importx "_free" free
-    call free(filename)
-endfunction
-import "cmpmem_s" cmpmem_s
-function av_expand_go(ss filename)
-    import "path_extension" path_extension
-    ss extension
-    setcall extension path_extension(filename)
-    sd length
-    setcall length slen(extension)
-    inc length
-    str a="avi"
-    str m="mp4"
-    sd frm_len
-    sd compare
-
-    import "avi_write_fname" avi_write_fname
-    setcall frm_len slen(a)
-    inc frm_len
-    setcall compare cmpmem_s(extension,length,a,frm_len)
-    if compare==(equalCompare)
-        call avi_write_fname(filename,(avi_expand))
-        return (void)
-    endif
-
-    setcall frm_len slen(m)
-    inc frm_len
-    setcall compare cmpmem_s(extension,length,m,frm_len)
-    if compare==(equalCompare)
-        import "mp4_extend" mp4_extend
-        call mp4_extend(filename)
-        return (void)
-    endif
-
-    call texter("Unrecognized format")
-endfunction
--- /dev/null
+++ ovideo-1/src/media/jpeg.oc
@@ -0,0 +1,192 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+const JPEG_LIB_VERSION=80
+#const JCS_RGB=2
+
+import "texter" texter
+
+
+
+char jerrstruct#jerr_size
+const p_jerrstruct^jerrstruct
+function get_jerr()
+    data p%p_jerrstruct
+    return p
+endfunction
+
+function init_jerr(sd jstruct)
+    sd jerr
+    setcall jerr get_jerr()
+
+    importx "_jpeg_std_error" jpeg_std_error
+    #jstruct.err
+    setcall jstruct# jpeg_std_error(jerr)
+
+    #jerr.error_exit
+    data f^jpeg_errorhandle
+    set jerr# f
+
+    #execution allowed
+    call jpeg_continue((value_set),1)
+endfunction
+
+#void
+function jpeg_errorhandle(sd *j_common_ptr cinfo)
+    #execution blocked
+    call jpeg_continue((value_set),0)
+    ss jerrtext="Jpeg error"
+    call texter(jerrtext)
+endfunction
+function jpeg_continue(sd action,sd value)
+    data continue#1
+    if action=(value_set)
+        set continue value
+    else
+        return continue
+    endelse
+endfunction
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+char deinfo#jdestruct_size
+const p_deinfo^deinfo
+function get_jdestruct()
+    data p%p_deinfo
+    return p
+endfunction
+
+#bool continuation
+function read_jpeg(sd file,sd forward)
+    sd jdestruct
+    setcall jdestruct get_jdestruct()
+
+    #set error handle
+    call init_jerr(jdestruct)
+
+    sd continue
+
+    #get memory
+    import "jpeg_get_jdestruct_size" jpeg_get_jdestruct_size
+    sd jdestruct_size
+    setcall jdestruct_size jpeg_get_jdestruct_size()
+    importx "_jpeg_CreateDecompress" jpeg_CreateDecompress
+    call jpeg_CreateDecompress(jdestruct,(JPEG_LIB_VERSION),jdestruct_size)
+    setcall continue jpeg_continue((value_get))
+    if continue=0
+        return continue
+    endif
+
+    call read_jpeg_prepare(file,forward)
+
+    #free memory
+    importx "_jpeg_destroy_decompress" jpeg_destroy_decompress
+    call jpeg_destroy_decompress(jdestruct)
+
+    setcall continue jpeg_continue((value_get))
+    return continue
+endfunction
+
+function read_jpeg_prepare(sd file,sd forward)
+    sd jdestruct
+    setcall jdestruct get_jdestruct()
+
+    sd continue
+
+    #associate decompress file
+    importx "_jpeg_stdio_src" jpeg_stdio_src
+    call jpeg_stdio_src(jdestruct,file)
+    setcall continue jpeg_continue((value_get))
+    if continue=0
+        return continue
+    endif
+
+    #read headers
+    importx "_jpeg_read_header" jpeg_read_header
+    #2nd arg=TRUE to reject a tables-only JPEG file as an error
+    call jpeg_read_header(jdestruct,(TRUE))
+    setcall continue jpeg_continue((value_get))
+    if continue=0
+        return continue
+    endif
+
+    importx "_jpeg_start_decompress" jpeg_start_decompress
+    call jpeg_start_decompress(jdestruct)
+    setcall continue jpeg_continue((value_get))
+    if continue=0
+        return continue
+    endif
+
+    call read_jpeg_scanlines(forward)
+
+    importx "_jpeg_finish_decompress" jpeg_finish_decompress
+    call jpeg_finish_decompress(jdestruct)
+endfunction
+
+function read_jpeg_scanlines(sv forward)
+    sd jdestruct
+    setcall jdestruct get_jdestruct()
+
+    sd continue
+
+    import "structure_get_int" structure_get_int
+    #get file rowstride
+    sd filerowstride
+    import "jpeg_get_jdestruct_output_width" jpeg_get_jdestruct_output_width
+    sd output_width
+    setcall output_width jpeg_get_jdestruct_output_width()
+    setcall output_width structure_get_int(jdestruct,output_width)
+
+    import "jpeg_get_jdestruct_output_components" jpeg_get_jdestruct_output_components
+    sd output_components
+    setcall output_components jpeg_get_jdestruct_output_components()
+    setcall output_components structure_get_int(jdestruct,output_components)
+
+    set filerowstride output_width
+    mult filerowstride output_components
+
+    #alloc for reading
+    sv alloc_sarray
+    setcall alloc_sarray structure_get_int(jdestruct,4)
+    setcall alloc_sarray structure_get_int(alloc_sarray,8)
+
+    #Make a one-row-high sample array that will go away when done with image
+    sd buffer
+    setcall buffer alloc_sarray(jdestruct,(JPOOL_IMAGE),filerowstride,1)
+
+    #read and forward the scanlines
+    import "jpeg_get_jdestruct_output_height" jpeg_get_jdestruct_output_height
+    sd output_height
+    setcall output_height jpeg_get_jdestruct_output_height()
+    setcall output_height structure_get_int(jdestruct,output_height)
+
+    importx "_jpeg_read_scanlines" jpeg_read_scanlines
+    sd j=0
+    while j!=output_height
+        call jpeg_read_scanlines(jdestruct,buffer,1)
+        setcall continue jpeg_continue((value_get))
+        if continue=0
+            return continue
+        endif
+        setcall continue forward(buffer#,filerowstride,j)
+        if continue=0
+            call jpeg_continue((value_set),0)
+            return continue
+        endif
+        inc j
+    endwhile
+endfunction
--- ovideo-1.orig/src/media/jpeg.s
+++ /dev/null
@@ -1,192 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-const JPEG_LIB_VERSION=80
-#const JCS_RGB=2
-
-import "texter" texter
-
-
-
-char jerrstruct#jerr_size
-const p_jerrstruct^jerrstruct
-function get_jerr()
-    data p%p_jerrstruct
-    return p
-endfunction
-
-function init_jerr(sd jstruct)
-    sd jerr
-    setcall jerr get_jerr()
-
-    importx "_jpeg_std_error" jpeg_std_error
-    #jstruct.err
-    setcall jstruct# jpeg_std_error(jerr)
-
-    #jerr.error_exit
-    data f^jpeg_errorhandle
-    set jerr# f
-
-    #execution allowed
-    call jpeg_continue((value_set),1)
-endfunction
-
-#void
-function jpeg_errorhandle(sd *j_common_ptr cinfo)
-    #execution blocked
-    call jpeg_continue((value_set),0)
-    ss jerrtext="Jpeg error"
-    call texter(jerrtext)
-endfunction
-function jpeg_continue(sd action,sd value)
-    data continue#1
-    if action==(value_set)
-        set continue value
-    else
-        return continue
-    endelse
-endfunction
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-char deinfo#jdestruct_size
-const p_deinfo^deinfo
-function get_jdestruct()
-    data p%p_deinfo
-    return p
-endfunction
-
-#bool continuation
-function read_jpeg(sd file,sd forward)
-    sd jdestruct
-    setcall jdestruct get_jdestruct()
-
-    #set error handle
-    call init_jerr(jdestruct)
-
-    sd continue
-
-    #get memory
-    import "jpeg_get_jdestruct_size" jpeg_get_jdestruct_size
-    sd jdestruct_size
-    setcall jdestruct_size jpeg_get_jdestruct_size()
-    importx "_jpeg_CreateDecompress" jpeg_CreateDecompress
-    call jpeg_CreateDecompress(jdestruct,(JPEG_LIB_VERSION),jdestruct_size)
-    setcall continue jpeg_continue((value_get))
-    if continue==0
-        return continue
-    endif
-
-    call read_jpeg_prepare(file,forward)
-
-    #free memory
-    importx "_jpeg_destroy_decompress" jpeg_destroy_decompress
-    call jpeg_destroy_decompress(jdestruct)
-
-    setcall continue jpeg_continue((value_get))
-    return continue
-endfunction
-
-function read_jpeg_prepare(sd file,sd forward)
-    sd jdestruct
-    setcall jdestruct get_jdestruct()
-
-    sd continue
-
-    #associate decompress file
-    importx "_jpeg_stdio_src" jpeg_stdio_src
-    call jpeg_stdio_src(jdestruct,file)
-    setcall continue jpeg_continue((value_get))
-    if continue==0
-        return continue
-    endif
-
-    #read headers
-    importx "_jpeg_read_header" jpeg_read_header
-    #2nd arg=TRUE to reject a tables-only JPEG file as an error
-    call jpeg_read_header(jdestruct,(TRUE))
-    setcall continue jpeg_continue((value_get))
-    if continue==0
-        return continue
-    endif
-
-    importx "_jpeg_start_decompress" jpeg_start_decompress
-    call jpeg_start_decompress(jdestruct)
-    setcall continue jpeg_continue((value_get))
-    if continue==0
-        return continue
-    endif
-
-    call read_jpeg_scanlines(forward)
-
-    importx "_jpeg_finish_decompress" jpeg_finish_decompress
-    call jpeg_finish_decompress(jdestruct)
-endfunction
-
-function read_jpeg_scanlines(sd forward)
-    sd jdestruct
-    setcall jdestruct get_jdestruct()
-
-    sd continue
-
-    import "structure_get_int" structure_get_int
-    #get file rowstride
-    sd filerowstride
-    import "jpeg_get_jdestruct_output_width" jpeg_get_jdestruct_output_width
-    sd output_width
-    setcall output_width jpeg_get_jdestruct_output_width()
-    setcall output_width structure_get_int(jdestruct,output_width)
-
-    import "jpeg_get_jdestruct_output_components" jpeg_get_jdestruct_output_components
-    sd output_components
-    setcall output_components jpeg_get_jdestruct_output_components()
-    setcall output_components structure_get_int(jdestruct,output_components)
-
-    set filerowstride output_width
-    mult filerowstride output_components
-
-    #alloc for reading
-    sd alloc_sarray
-    setcall alloc_sarray structure_get_int(jdestruct,4)
-    setcall alloc_sarray structure_get_int(alloc_sarray,8)
-
-    #Make a one-row-high sample array that will go away when done with image
-    sd buffer
-    setcall buffer alloc_sarray(jdestruct,(JPOOL_IMAGE),filerowstride,1)
-
-    #read and forward the scanlines
-    import "jpeg_get_jdestruct_output_height" jpeg_get_jdestruct_output_height
-    sd output_height
-    setcall output_height jpeg_get_jdestruct_output_height()
-    setcall output_height structure_get_int(jdestruct,output_height)
-
-    importx "_jpeg_read_scanlines" jpeg_read_scanlines
-    sd j=0
-    while j!=output_height
-        call jpeg_read_scanlines(jdestruct,buffer,1)
-        setcall continue jpeg_continue((value_get))
-        if continue==0
-            return continue
-        endif
-        setcall continue forward(buffer#,filerowstride,j)
-        if continue==0
-            call jpeg_continue((value_set),0)
-            return continue
-        endif
-        inc j
-    endwhile
-endfunction
--- /dev/null
+++ ovideo-1/src/media/jpeg_enc.oc
@@ -0,0 +1,1872 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+import "file_write" file_write
+import "pixbuf_get_wh" pixbuf_get_wh
+import "alloc_block" alloc_block
+import "memoryalloc" memoryalloc
+importx "_free" free
+
+#bool
+function write_jpeg(sd file,sd pixbuf,sd quality)
+    sd bool
+    setcall bool jpeg_file_mem((value_set))
+    if bool=0
+        return 0
+    endif
+    setcall bool write_jpeg_file(pixbuf,quality)
+    if bool=0
+        return 0
+    endif
+
+    setcall bool jpeg_file_mem((value_filewrite),file)
+    if bool=0
+        return 0
+    endif
+
+    call jpeg_file_mem((value_unset))
+
+    return 1
+endfunction
+
+#bool
+function write_jpeg_file(sd pixbuf,sd quality)
+    sd bool
+    setcall bool write_jpeg_headers(pixbuf,quality)
+    if bool=0
+        return 0
+    endif
+
+    setcall bool jpeg_encode_main(pixbuf)
+    return bool
+endfunction
+
+
+#bool
+function write_jpeg_headers(sd pixbuf,sd quality)
+    sd bool
+    setcall bool write_jpeg_headers_appinfo()
+    if bool=0
+        return 0
+    endif
+    setcall bool write_jpeg_quantizationTables(quality)
+    if bool=0
+        return 0
+    endif
+    setcall bool write_jpeg_sof(pixbuf)
+    if bool=0
+        return 0
+    endif
+    setcall bool write_jpeg_Huffman()
+    if bool=0
+        return 0
+    endif
+    setcall bool write_jpeg_sos()
+    if bool=0
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function jpeg_encode_main(sd pixbuf)
+    sd bool
+    setcall bool jpeg_category((value_set))
+    if bool=0
+        return 0
+    endif
+    setcall bool jpeg_length((value_set))
+    if bool=0
+        call jpeg_category((value_unset))
+        return 0
+    endif
+    setcall bool jpeg_value((value_set))
+    if bool=0
+        call jpeg_category((value_unset))
+        call jpeg_length((value_unset))
+        return 0
+    endif
+
+    setcall bool write_jpeg_blocks(pixbuf)
+
+    call jpeg_category((value_unset))
+    call jpeg_length((value_unset))
+    call jpeg_value((value_unset))
+
+    return bool
+endfunction
+
+const lum=0
+const crom=1
+
+#bool
+function write_jpeg_blocks(sd pixbuf)
+    sd w
+    sd h
+    sd wh^w
+    call pixbuf_get_wh(pixbuf,wh)
+
+    #need when get 8x8
+    ##1
+    call jpeg_YCbCr_256color((value_set))
+
+    #need at quantization
+    ##2
+    call jpeg_FDCT_Quantization_Tables((value_set))
+    sd FDCT_Y
+    sd FDCT_CbCr
+    sd p_FDCT_CbCr^FDCT_CbCr
+    setcall FDCT_Y jpeg_FDCT_Quantization_Tables((value_get),p_FDCT_CbCr)
+
+    ##3
+    call jpeg_FDCT_Quantization_And_ZigZag((value_set))
+
+    ##4
+    call jpeg_encode_Huffman((value_set))
+    data prev_DC_Y#1
+    data prev_DC_Cb#1
+    data prev_DC_Cr#1
+    set prev_DC_Y 0
+    set prev_DC_Cb 0
+    set prev_DC_Cr 0
+    data p_prev_DC_Y^prev_DC_Y
+    data p_prev_DC_Cb^prev_DC_Cb
+    data p_prev_DC_Cr^prev_DC_Cr
+
+    #write blocks from top to bottom 8x8 pieces
+    sd j=0
+    while j<h
+        sd i=0
+        while i<w
+            #get a 8x8 block
+            char Y_data#8*8
+            char Cb_data#8*8
+            char Cr_data#8*8
+            str Y^Y_data
+            str Cb^Cb_data
+            str Cr^Cr_data
+            ##1
+            call jpeg_blocks_8x8(Y,Cb,Cr,pixbuf,i,j,w,h)
+
+            sd bool
+
+            #apply fast DCT and zigzag
+            #int16
+            char DCT_Quant_Y_data#64*2
+            str DCT_Quant_Y^DCT_Quant_Y_data
+            ##3,4
+            call jpeg_FDCT_Quantization_And_ZigZag((value_run),Y,DCT_Quant_Y,FDCT_Y)
+            #                                1 is for encode
+            setcall bool jpeg_encode_Huffman(1,DCT_Quant_Y,(lum),p_prev_DC_Y)
+            if bool!=1
+                return 0
+            endif
+            #
+            char DCT_Quant_Cb_data#64*2
+            str DCT_Quant_Cb^DCT_Quant_Cb_data
+            call jpeg_FDCT_Quantization_And_ZigZag((value_run),Cb,DCT_Quant_Cb,FDCT_CbCr)
+            setcall bool jpeg_encode_Huffman(1,DCT_Quant_Cb,(crom),p_prev_DC_Cb)
+            if bool!=1
+                return 0
+            endif
+            #
+            char DCT_Quant_Cr_data#64*2
+            str DCT_Quant_Cr^DCT_Quant_Cr_data
+            call jpeg_FDCT_Quantization_And_ZigZag((value_run),Cr,DCT_Quant_Cr,FDCT_CbCr)
+            setcall bool jpeg_encode_Huffman(1,DCT_Quant_Cr,(crom),p_prev_DC_Cr)
+            if bool!=1
+                return 0
+            endif
+            add i 8
+        endwhile
+        add j 8
+    endwhile
+
+    #Write End of Image Marker
+    char EOI_data={0xFF,0xD9}
+    str EOI^EOI_data
+    setcall bool jpeg_file_mem_add(EOI,2)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+
+
+
+function jpeg_file_mem(sd action,sd arg,sd append_size)
+    data mem#1
+    data size#1
+	if action=(value_set)
+    #bool
+        setcall mem alloc_block((value_set))
+        if mem=0
+            return 0
+        endif
+        set size 0
+        return 1
+	endif
+	if action=(value_unset)
+        call free(mem)
+	elseif action=(value_append)
+    #bool
+        sd append
+        set append arg
+        sd appendresult
+        setcall appendresult alloc_block((value_append),mem,size,append,append_size)
+        if appendresult=0
+            return 0
+        endif
+        set mem appendresult
+        add size append_size
+        return 1
+	else
+    #if action==(value_filewrite)
+    #bool
+        sd file
+        set file arg
+        sd err
+        setcall err file_write(mem,size,file)
+        if err!=(noerror)
+            return 0
+        endif
+        return 1
+	endelse
+endfunction
+
+function jpeg_file_mem_add(sd append,sd append_size)
+    sd bool
+    setcall bool jpeg_file_mem((value_append),append,append_size)
+    return bool
+endfunction
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+##
+
+#bool
+function write_jpeg_headers_appinfo()
+    #JPEG INIT
+    char JPEG_INIT={0xff,0xD8}
+    #marker
+    char *={0xff,0xE0}
+    #length = 16 for usual JPEG, no thumbnail
+    char *={0,16}
+    #signature
+    char *="JFIF"
+    #high version,low version
+    char *={1,1}
+    #xyunits = 0 = no units, normal density
+    char *=0
+    #x density = 1
+    char *={0,1}
+    #y density = 1
+    char *={0,1}
+    #thumb n width, thumb n height
+    char *={0,0}
+
+    data size#1
+
+    const _appinfo^JPEG_INIT
+    const appinfo_^size
+    set size (appinfo_-_appinfo)
+
+    sd buffer^JPEG_INIT
+
+    sd bool
+    setcall bool jpeg_file_mem_add(buffer,size)
+    if bool!=1
+        return 0
+    endif
+
+    return 1
+endfunction
+
+
+#Quantization Tables
+#bool
+function write_jpeg_quantizationTables(sd quality)
+    char marker={0xFF,0xDB}
+    #length = 132
+    char *={0,132}
+    #QTYinfo
+    #bit 0..3: number of QT = 0 (table for Y)
+    #bit 4..7: precision of QT, 0 = 8 bit
+    char *=0
+    #Y Table, luminance table
+    char Y_Table#64
+    #QTCbinfo
+    #quantization table for Cb,Cr
+    char *=1
+    #CbCr Table, chromiance table
+    char CbCr_Table#64
+
+    data size#1
+    const _quantizationTables^marker
+    const quantizationTables_^size
+    set size (quantizationTables_-_quantizationTables)
+
+    char luminance_r1={16, 11, 10, 16,24, 40, 51, 61}
+    char *         r2={12, 12, 14, 19,26, 58, 60, 55}
+    char *         r3={14, 13, 16, 24,40, 57, 69, 56}
+    char *         r4={14, 17, 22, 29,51, 87, 80, 62}
+    char *         r5={18, 22, 37, 56,68, 109,103,77}
+    char *         r6={24, 35, 55, 64,81, 104,113,92}
+    char *         r7={49, 64, 78, 87,103,121,120,101}
+    char *         r8={72, 92, 95, 98,112,100,103,99}
+
+    str luminance^luminance_r1
+    str Y_Tab^Y_Table
+    call jpeg_Scale_And_ZigZag_Quantization_Table(luminance,Y_Tab,quality)
+
+    char chromiance_r1={17,  18,  24,  47,  99,  99,  99,  99}
+    char *          r2={18,  21,  26,  66,  99,  99,  99,  99}
+    char *          r3={24,  26,  56,  99,  99,  99,  99,  99}
+    char *          r4={47,  66,  99,  99,  99,  99,  99,  99}
+    char *          r5={99,  99,  99,  99,  99,  99,  99,  99}
+    char *          r6={99,  99,  99,  99,  99,  99,  99,  99}
+    char *          r7={99,  99,  99,  99,  99,  99,  99,  99}
+    char *          r8={99,  99,  99,  99,  99,  99,  99,  99}
+
+    str chromiance^chromiance_r1
+    str CbCr_Tab^CbCr_Table
+    call jpeg_Scale_And_ZigZag_Quantization_Table(chromiance,CbCr_Tab,quality)
+
+    sd buffer^marker
+    sd bool
+    setcall bool jpeg_file_mem_add(buffer,size)
+    if bool!=1
+        return 0
+    endif
+    return 1
+
+    const Y_Tab^Y_Table
+    const CbCr_Tab^CbCr_Table
+endfunction
+
+function jpeg_Y_Table()
+    sd p%Y_Tab
+    return p
+endfunction
+function jpeg_CbCr_Table()
+    sd p%CbCr_Tab
+    return p
+endfunction
+
+
+function jpeg_Scale_And_ZigZag_Quantization_Table(ss srctable,ss desttable,sd quality)
+    sd i=0
+    while i!=64
+        #quality_scale=1(best) (x*quality_scale+50)/100
+        sd temp
+        set temp srctable#
+        #quality
+        mult temp quality
+        #
+        add temp 50
+        div temp 100
+        if temp<=0
+            set temp 1
+        elseif temp>0xff
+            set temp 0xff
+        endelseif
+
+        call jpeg_ZigZag((value_set),desttable,i,temp)
+
+        inc srctable
+        inc i
+    endwhile
+endfunction
+
+function jpeg_ZigZag_get(sd i)
+    char zigzag_r1={0, 1, 5, 6, 14,15,27,28}
+    char *      r2={2, 4, 7, 13,16,26,29,42}
+    char *      r3={3, 8, 12,17,25,30,41,43}
+    char *      r4={9, 11,18,24,31,40,44,53}
+    char *      r5={10,19,23,32,39,45,52,54}
+    char *      r6={20,22,33,38,46,51,55,60}
+    char *      r7={21,34,37,47,50,56,59,61}
+    char *      r8={35,36,48,49,57,58,62,63}
+
+    str zigzag^zigzag_r1
+    ss ztab
+    set ztab zigzag
+    add ztab i
+
+    return ztab#
+endfunction
+
+function jpeg_ZigZag(sd action,ss table,sd i,sd value)
+    sd jump
+    setcall jump jpeg_ZigZag_get(i)
+    add table jump
+
+    if action=(value_set)
+        set table# value
+    else
+        return table#
+    endelse
+endfunction
+
+##
+
+#bool
+function write_jpeg_sof(sd pixbuf)
+    char marker={0xFF,0xC0}
+    #length = 17 for a truecolor YCbCr JPG
+    char *={0,17}
+    #precision, Should be 8: 8 bits/sample
+    char *=8
+    #height
+    char height#2
+    #width
+    char width#2
+    #nrofcomponents, Should be 3: We encode a truecolor JPG
+    char *=3
+    #IdY
+    char *=1
+    #HVY, sampling factors for Y (bit 0-3 vert., 4-7 hor.)
+    char *=0x11
+    #QTY, Quantization Table number for Y = 0
+    char *=0
+    #IdCb
+    char *=2
+    #HVCb
+    char *=0x11
+    #QTCb
+    char *=1
+    #IdCr
+    char *=3
+    #HVCr
+    char *=0x11
+    #QTCr, Normally equal to QTCb = 1
+    char *=1
+
+    data size#1
+    const _sof^marker
+    const sof_^size
+    set size (sof_-_sof)
+
+    import "word_reverse" word_reverse
+    sd w
+    sd h
+    sd wh^w
+    call pixbuf_get_wh(pixbuf,wh)
+    str wd^width
+    str ht^height
+    call word_reverse(h,ht)
+    call word_reverse(w,wd)
+
+    sd buffer^marker
+    sd bool
+    setcall bool jpeg_file_mem_add(buffer,size)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+##
+
+const Huffman_init=0
+const Huffman_get=1
+
+#bool
+function write_jpeg_Huffman()
+    char marker={0xFF,0xC4}
+    #length
+    char *={0x01,0xA2}
+
+    data size#1
+    const _Huffman^marker
+    const Huffman_^size
+    set size (Huffman_-_Huffman)
+
+    sd buffer^marker
+    sd bool
+    setcall bool jpeg_file_mem_add(buffer,size)
+    if bool!=1
+        return 0
+    endif
+
+    setcall bool Huffman_DC_Luminance((Huffman_init))
+    if bool=0
+        return 0
+    endif
+
+    setcall bool Huffman_AC_Luminance((Huffman_init))
+    if bool=0
+        return 0
+    endif
+
+    setcall bool Huffman_DC_Chromiance((Huffman_init))
+    if bool=0
+        return 0
+    endif
+
+    setcall bool Huffman_AC_Chromiance((Huffman_init))
+    if bool=0
+        return 0
+    endif
+
+    return 1
+endfunction
+
+#HT info,   bit 0..3: number of HT (0..3), for Y =0, Cb=1
+#           bit 4  :type of HT, 0 = DC table,1 = AC table
+#           bit 5..7: not used, must be 0
+
+const Y_table=0
+const Cb_table=1
+
+const DC_table=0
+const AC_table=0x10
+
+function Huffman_DC_Luminance(sd action,sd ptr_values)
+    char HT=Y_table|DC_table
+    char NRCodes={0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0}
+    char Values={ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
+
+    data Values_size#1
+
+    const YDC_NRCodes^NRCodes
+    const YDC_Values^Values
+    const YDC_Values_^Values_size
+
+    sd p_NRCodes^NRCodes
+    sd p_Values^Values
+
+    if action=(Huffman_init)
+    #bool
+        inc p_NRCodes
+        sd NRCodes_size=YDC_Values-YDC_NRCodes
+        dec NRCodes_size
+
+        set Values_size (YDC_Values_-YDC_Values)
+
+        sd bool
+        setcall bool Huffman_init_write(HT,p_NRCodes,NRCodes_size,p_Values,Values_size)
+        return bool
+    endif
+
+    set ptr_values# p_Values
+    return p_NRCodes
+endfunction
+
+function Huffman_AC_Luminance(sd action,sd ptr_values)
+    char HT=Y_table|AC_table
+    char NRCodes={0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d}
+    char Values={0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12}
+    char     *2={0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07}
+    char     *3={0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08}
+    char     *4={0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0}
+    char     *5={0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16}
+    char     *6={0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28}
+    char     *7={0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39}
+    char     *8={0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49}
+    char     *9={0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59}
+    char    *10={0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69}
+    char    *11={0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79}
+    char    *12={0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89}
+    char    *13={0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98}
+    char    *14={0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7}
+    char    *15={0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6}
+    char    *16={0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5}
+    char    *17={0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4}
+    char    *18={0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2}
+    char    *19={0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea}
+    char    *20={0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8}
+    char    *21={0xf9, 0xfa}
+
+    data Values_size#1
+
+    const YAC_NRCodes^NRCodes
+    const YAC_Values^Values
+    const YAC_Values_^Values_size
+
+    sd p_NRCodes^NRCodes
+    sd p_Values^Values
+
+    if action=(Huffman_init)
+    #bool
+        inc p_NRCodes
+        sd NRCodes_size=YAC_Values-YAC_NRCodes
+        dec NRCodes_size
+
+        set Values_size (YAC_Values_-YAC_Values)
+
+        sd bool
+        setcall bool Huffman_init_write(HT,p_NRCodes,NRCodes_size,p_Values,Values_size)
+        return bool
+    endif
+    set ptr_values# p_Values
+    return p_NRCodes
+endfunction
+
+function Huffman_DC_Chromiance(sd action,sd ptr_values)
+    char HT=Cb_table|DC_table
+    char NRCodes={0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
+    char Values={0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
+
+    data Values_size#1
+
+    const CbDC_NRCodes^NRCodes
+    const CbDC_Values^Values
+    const CbDC_Values_^Values_size
+
+    sd p_NRCodes^NRCodes
+    sd p_Values^Values
+
+    if action=(Huffman_init)
+    #bool
+        inc p_NRCodes
+        sd NRCodes_size=CbDC_Values-CbDC_NRCodes
+        dec NRCodes_size
+
+        set Values_size (CbDC_Values_-CbDC_Values)
+
+        sd bool
+        setcall bool Huffman_init_write(HT,p_NRCodes,NRCodes_size,p_Values,Values_size)
+        return bool
+    endif
+    set ptr_values# p_Values
+    return p_NRCodes
+endfunction
+
+function Huffman_AC_Chromiance(sd action,sd ptr_values)
+    char HT=Cb_table|AC_table
+    char NRCodes={0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77}
+    char Values={0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21}
+    char     *2={0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71}
+    char     *3={0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91}
+    char     *4={0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0}
+    char     *5={0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34}
+    char     *6={0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26}
+    char     *7={0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38}
+    char     *8={0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48}
+    char     *9={0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58}
+    char    *10={0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68}
+    char    *11={0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78}
+    char    *12={0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87}
+    char    *13={0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96}
+    char    *14={0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5}
+    char    *15={0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4}
+    char    *16={0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3}
+    char    *17={0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2}
+    char    *18={0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda}
+    char    *19={0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9}
+    char    *20={0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8}
+    char    *21={0xf9, 0xfa}
+
+    data Values_size#1
+
+    const CbAC_NRCodes^NRCodes
+    const CbAC_Values^Values
+    const CbAC_Values_^Values_size
+
+    sd p_NRCodes^NRCodes
+    sd p_Values^Values
+
+    if action=(Huffman_init)
+    #bool
+        inc p_NRCodes
+        sd NRCodes_size=CbAC_Values-CbAC_NRCodes
+        dec NRCodes_size
+
+        set Values_size (CbAC_Values_-CbAC_Values)
+
+        sd bool
+        setcall bool Huffman_init_write(HT,p_NRCodes,NRCodes_size,p_Values,Values_size)
+        return bool
+    endif
+    set ptr_values# p_Values
+    return p_NRCodes
+endfunction
+
+#bool
+function Huffman_init_write(sd HTbyte,sd NRCodes,sd NRCodes_size,sd Values,sd Values_size)
+    sd p_HTbyte^HTbyte
+    sd bool
+    setcall bool jpeg_file_mem_add(p_HTbyte,1)
+    if bool!=1
+        return 0
+    endif
+    setcall bool jpeg_file_mem_add(NRCodes,NRCodes_size)
+    if bool!=1
+        return 0
+    endif
+    setcall bool jpeg_file_mem_add(Values,Values_size)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+##
+
+#bool
+function write_jpeg_sos()
+    char marker={0xFF,0xDA}
+    char *length={0,12}
+    #nrofcomponents Should be 3: truecolor JPG
+    char *=3
+
+    char *IdY=1
+    #HT, bits 0..3: AC table (0..3)
+    #    bits 4..7: DC table (0..3)
+    char *HTY=0
+    char *IdCb=2
+    char *HTCb=0x11
+    char *IdCr=3
+    char *HTCr=0x11
+    char *Ss=0
+    char *Se=0x3F
+    char *Bf=0
+
+    data size#1
+    const _sos^marker
+    const sos_^size
+    set size (sos_-_sos)
+
+    sd buffer^marker
+    sd bool
+    setcall bool jpeg_file_mem_add(buffer,size)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+##
+
+###
+
+function jpeg_YCbCr_256color(sd action,sd red,sd green,sd blue,sd p_Y,sd p_Cb,sd p_Cr,sd x,sd y)
+    data Y_Red_Table_data#256
+    data Cb_Red_Table_data#256
+    data Cr_Red_Table_data#256
+    data Y_Green_Table_data#256
+    data Cb_Green_Table_data#256
+    data Cr_Green_Table_data#256
+    data Y_Blue_Table_data#256
+    data Cb_Blue_Table_data#256
+    data Cr_Blue_Table_data#256
+
+    sd Y_Red_Table^Y_Red_Table_data
+    sd Cb_Red_Table^Cb_Red_Table_data
+    sd Cr_Red_Table^Cr_Red_Table_data
+    sd Y_Green_Table^Y_Green_Table_data
+    sd Cb_Green_Table^Cb_Green_Table_data
+    sd Cr_Green_Table^Cr_Green_Table_data
+    sd Y_Blue_Table^Y_Blue_Table_data
+    sd Cb_Blue_Table^Cb_Blue_Table_data
+    sd Cr_Blue_Table^Cr_Blue_Table_data
+
+    sd variable
+    if action=(value_set)
+        sd color
+        set color 0
+        while color!=256
+            str Y_Red_coef="0.299"
+            setcall Y_Red_Table# jpeg_YCbCr_256color_equation(Y_Red_coef,color)
+            add Y_Red_Table 4
+
+            str Cb_Red_coef="-0.16874"
+            setcall Cb_Red_Table# jpeg_YCbCr_256color_equation(Cb_Red_coef,color)
+            add Cb_Red_Table 4
+
+            set variable color
+            mult variable 32768
+            set Cr_Red_Table# variable
+            add Cr_Red_Table 4
+
+            inc color
+        endwhile
+
+        set color 0
+        while color!=256
+            str Y_Green_coef="0.587"
+            setcall Y_Green_Table# jpeg_YCbCr_256color_equation(Y_Green_coef,color)
+            add Y_Green_Table 4
+
+            str Cb_Green_coef="-0.33126"
+            setcall Cb_Green_Table# jpeg_YCbCr_256color_equation(Cb_Green_coef,color)
+            add Cb_Green_Table 4
+
+            str Cr_Green_coef="-0.41869"
+            setcall Cr_Green_Table# jpeg_YCbCr_256color_equation(Cr_Green_coef,color)
+            add Cr_Green_Table 4
+
+            inc color
+        endwhile
+        set color 0
+        while color!=256
+            str Y_Blue_coef="0.114"
+            setcall Y_Blue_Table# jpeg_YCbCr_256color_equation(Y_Blue_coef,color)
+            add Y_Blue_Table 4
+
+            set variable color
+            mult variable 32768
+            set Cb_Blue_Table# variable
+            add Cb_Blue_Table 4
+
+            str Cr_Blue_coef="-0.08131"
+            setcall Cr_Blue_Table# jpeg_YCbCr_256color_equation(Cr_Blue_coef,color)
+            add Cr_Blue_Table 4
+
+            inc color
+        endwhile
+        return (void)
+    endif
+
+    import "array_byte_setAtXY" array_byte_setAtXY
+    sd Y
+    setcall Y jpeg_YCbCr_256color_get3(red,green,blue,Y_Red_Table,Y_Green_Table,Y_Blue_Table)
+    sub Y 128
+    call array_byte_setAtXY(p_Y,Y,x,y,8)
+
+    sd Cb
+    setcall Cb jpeg_YCbCr_256color_get3(red,green,blue,Cb_Red_Table,Cb_Green_Table,Cb_Blue_Table)
+    call array_byte_setAtXY(p_Cb,Cb,x,y,8)
+
+    sd Cr
+    setcall Cr jpeg_YCbCr_256color_get3(red,green,blue,Cr_Red_Table,Cr_Green_Table,Cr_Blue_Table)
+    call array_byte_setAtXY(p_Cr,Cr,x,y,8)
+endfunction
+
+import "str_to_double" str_to_double
+import "int_to_double" int_to_double
+import "double_mult" double_mult
+import "double_add" double_add
+import "double_to_int" double_to_int
+#res
+function jpeg_YCbCr_256color_equation(sd value,sd color)
+    #int((65536 * value + 0.5) * color)
+    #65536
+    str predef_double_str="65536"
+    sd predef_double#2
+    sd p_predef_double^predef_double
+    call str_to_double(predef_double_str,p_predef_double)
+    #value
+    sd double#2
+    sd p_double^double
+    call str_to_double(value,p_double)
+    #0.5
+    str pre_double_str="0.5"
+    sd pre_double#2
+    sd p_pre_double^pre_double
+    call str_to_double(pre_double_str,p_pre_double)
+    #color
+    sd color_double#2
+    sd p_color_double^color_double
+    call int_to_double(color,p_color_double)
+
+    call double_mult(p_double,p_predef_double)
+    call double_add(p_double,p_pre_double)
+    call double_mult(p_double,p_color_double)
+
+    sd res
+    setcall res double_to_int(p_double)
+    return res
+endfunction
+
+function bytemult4_getfromstruct(sd index,sd block)
+    mult index 4
+    import "structure_get_int" structure_get_int
+    sd value
+    setcall value structure_get_int(block,index)
+    return value
+endfunction
+function jpeg_YCbCr_256color_get3(sd red,sd green,sd blue,sd red_tab,sd green_tab,sd blue_tab)
+    sd value
+    setcall value bytemult4_getfromstruct(red,red_tab)
+    addcall value bytemult4_getfromstruct(green,green_tab)
+    addcall value bytemult4_getfromstruct(blue,blue_tab)
+    import "sar32" sar32
+    setcall value sar32(value,16)
+    return value
+endfunction
+
+function jpeg_blocks_8x8(ss Y_tab,ss Cb_tab,ss Cr_tab,sd pixbuf,sd i,sd j,sd max_i,sd max_j)
+    sd x
+    sd max_x
+    set x i
+    set max_x x
+    add max_x 8
+    sd min_y
+    sd max_y
+    set min_y j
+    set max_y min_y
+    add max_y 8
+
+    sd red
+    sd green
+    sd blue
+    sd colors^red
+
+    while x!=max_x
+        sd send_x
+        set send_x x
+        sub send_x i
+
+        sd y
+        set y min_y
+        while y!=max_y
+            sd send_y
+            set send_y y
+            sub send_y j
+
+            set red 0
+            set green 0
+            set blue 0
+            if x<max_i
+                if y<max_j
+                    import "pixbuf_get_pixel" pixbuf_get_pixel
+                    sd value
+                    setcall value pixbuf_get_pixel(pixbuf,x,y)
+                    import "rgb_uint_to_colors" rgb_uint_to_colors
+                    call rgb_uint_to_colors(value,colors)
+                endif
+            endif
+
+            call jpeg_YCbCr_256color((value_get),red,green,blue,Y_tab,Cb_tab,Cr_tab,send_x,send_y)
+
+            inc y
+        endwhile
+        inc x
+    endwhile
+endfunction
+
+###
+
+function jpeg_FDCT_Quantization_Tables(sd action,sd p_CbCr)
+    data FDCT_Y_Quantization#64
+    sd FDCT_Y^FDCT_Y_Quantization
+    data FDCT_CbCr_Quantization#64
+    sd FDCT_CbCr^FDCT_CbCr_Quantization
+    if action=(value_set)
+        data CosineScaleFactor_data#8*2
+        sd CosineScaleFactor^CosineScaleFactor_data
+
+        char CosineScaleFactor_coef1="1.0"
+        char *CosineScaleFactor_coef2="1.387039845"
+        char *CosineScaleFactor_coef3="1.306562965"
+        char *CosineScaleFactor_coef4="1.175875602"
+        char *CosineScaleFactor_coef5="1.0"
+        char *CosineScaleFactor_coef6="0.785694958"
+        char *CosineScaleFactor_coef7="0.541196100"
+        char *CosineScaleFactor_coef8="0.275899379"
+        char *=0
+
+        ss CosineScaleFactor_coef^CosineScaleFactor_coef1
+
+#1.0 / (X_Table[Tables.ZigZag[i]]*CSF[row]*CSF[col]*8.0)
+        #8.0 to double
+        sd const_denom#2
+        sd p_const_denom^const_denom
+        str c_denom="1.0"
+        call str_to_double(c_denom,p_const_denom)
+
+        #8.0 to double
+        sd const_double#2
+        sd p_const_double^const_double
+        str c_double="8.0"
+        call str_to_double(c_double,p_const_double)
+
+        #cosines to double
+
+        while CosineScaleFactor_coef#!=0
+            call str_to_double(CosineScaleFactor_coef,CosineScaleFactor)
+
+            add CosineScaleFactor 8
+            import "slen" slen
+            addcall CosineScaleFactor_coef slen(CosineScaleFactor_coef)
+            inc CosineScaleFactor_coef
+        endwhile
+
+        #for cpy 1.0 here
+        sd res_value#2
+        sd p_res_value^res_value
+
+        sd tabs=0
+        while tabs!=2
+            sd Table
+            sd dest_table
+            if tabs=0
+                setcall Table jpeg_Y_Table()
+                set dest_table FDCT_Y
+            else
+                setcall Table jpeg_CbCr_Table()
+                set dest_table FDCT_CbCr
+            endelse
+
+            sd i=0
+            sd row=0
+            sd CosineScaleFactor_row^CosineScaleFactor_data
+            while row!=8
+                sd col=0
+                sd CosineScaleFactor_col^CosineScaleFactor_data
+                while col!=8
+                    import "cpymem" cpymem
+                    import "double_div" double_div
+                    import "double_to_float" double_to_float
+
+                    #get
+                    sd value
+                    setcall value jpeg_ZigZag((value_get),Table,i)
+                    sd double_value#2
+                    sd p_double_value^double_value
+                    call int_to_double(value,p_double_value)
+
+                    call double_mult(p_double_value,CosineScaleFactor_row)
+                    call double_mult(p_double_value,CosineScaleFactor_col)
+                    call double_mult(p_double_value,p_const_double)
+
+                    call cpymem(p_res_value,p_const_denom,8)
+                    call double_div(p_res_value,p_double_value)
+
+                    setcall dest_table# double_to_float(p_res_value)
+
+                    add dest_table 4
+                    add CosineScaleFactor_col 8
+                    inc i
+                    inc col
+                endwhile
+                add CosineScaleFactor_row 8
+                inc row
+            endwhile
+            inc tabs
+        endwhile
+        return (void)
+    endif
+    #get
+    set p_CbCr# FDCT_CbCr
+    return FDCT_Y
+endfunction
+
+###
+
+import "float_add" float_add
+import "array_set_word_off" array_set_word_off
+
+#                                                    char        int16            float
+function jpeg_FDCT_Quantization_And_ZigZag(sd action,ss data8x8,sd out_DCT_Quant,sd FDCT_table)
+    if action=(value_set)
+        import "str_to_float" str_to_float
+
+        str fstr="0.707106781"
+        data float_0#1
+        setcall float_0 str_to_float(fstr)
+        str fstr_1="0.382683433"
+        data float_1#1
+        setcall float_1 str_to_float(fstr_1)
+        str fstr_2="0.541196100"
+        data float_2#1
+        setcall float_2 str_to_float(fstr_2)
+        str fstr_3="1.306562965"
+        data float_3#1
+        setcall float_3 str_to_float(fstr_3)
+        str fstr_4="0.707106781"
+        data float_4#1
+        setcall float_4 str_to_float(fstr_4)
+        return 1
+    endif
+    sd tmp0
+    sd tmp1
+    sd tmp2
+    sd tmp3
+    sd tmp4
+    sd tmp5
+    sd tmp6
+    sd tmp7
+    #
+    sd tmp10
+    sd tmp11
+    sd tmp12
+    sd tmp13
+    #
+    sd zA
+    sd zB
+    sd zC
+    sd zD
+    sd zE
+    sd zF
+    sd zG
+
+    sd cursor
+    sd value
+    #convert the sbyte table to float
+    char temp_data#64*4
+    sd temp^temp_data
+    sd i=0
+    set cursor temp
+    while i!=64
+        import "int_to_float" int_to_float
+        import "char_to_int" char_to_int
+        setcall value char_to_int(data8x8#)
+        setcall cursor# int_to_float(value)
+        add cursor 4
+        inc data8x8
+        inc i
+    endwhile
+
+    import "array_set_4value_offsets" array_set_4value_offsets
+    import "float_mult" float_mult
+    import "float_sub" float_sub
+
+    #Pass 1: process rows.
+    sd k=0
+    while k!=64
+    #0=add; 1=sub
+        setcall tmp0 gettwofloats_offs_and_op(temp,0,7,k,0)
+        setcall tmp7 gettwofloats_offs_and_op(temp,0,7,k,1)
+        setcall tmp1 gettwofloats_offs_and_op(temp,1,6,k,0)
+        setcall tmp6 gettwofloats_offs_and_op(temp,1,6,k,1)
+        setcall tmp2 gettwofloats_offs_and_op(temp,2,5,k,0)
+        setcall tmp5 gettwofloats_offs_and_op(temp,2,5,k,1)
+        setcall tmp3 gettwofloats_offs_and_op(temp,3,4,k,0)
+        setcall tmp4 gettwofloats_offs_and_op(temp,3,4,k,1)
+
+        #Even part
+        setcall tmp10 float_add(tmp0,tmp3)
+        setcall tmp13 float_sub(tmp0,tmp3)
+        setcall tmp11 float_add(tmp1,tmp2)
+        setcall tmp12 float_sub(tmp1,tmp2)
+
+        #
+        setcall value float_add(tmp10,tmp11)
+        call array_set_4value_offsets(temp,value,0,k)
+        setcall value float_sub(tmp10,tmp11)
+        call array_set_4value_offsets(temp,value,4,k)
+
+        #
+        setcall zA float_add(tmp12,tmp13)
+        setcall zA float_mult(zA,float_0)
+
+        #
+        setcall value float_add(tmp13,zA)
+        call array_set_4value_offsets(temp,value,2,k)
+        setcall value float_sub(tmp13,zA)
+        call array_set_4value_offsets(temp,value,6,k)
+
+        #Odd part
+        setcall tmp10 float_add(tmp4,tmp5)
+        setcall tmp11 float_add(tmp5,tmp6)
+        setcall tmp12 float_add(tmp6,tmp7)
+
+        #The rotator is modified to avoid extra negations.
+        setcall zE float_sub(tmp10,tmp12)
+        setcall zE float_mult(zE,float_1)
+
+        set zB float_2
+        setcall zB float_mult(zB,tmp10)
+        setcall zB float_add(zB,zE)
+
+        set zD float_3
+        setcall zD float_mult(zD,tmp12)
+        setcall zD float_add(zD,zE)
+
+        set zC float_4
+        setcall zC float_mult(zC,tmp11)
+
+        #
+        setcall zF float_add(tmp7,zC)
+        setcall zG float_sub(tmp7,zC)
+        #
+
+        setcall value float_add(zG,zB)
+        call array_set_4value_offsets(temp,value,5,k)
+
+        setcall value float_sub(zG,zB)
+        call array_set_4value_offsets(temp,value,3,k)
+
+        setcall value float_add(zF,zD)
+        call array_set_4value_offsets(temp,value,1,k)
+
+        setcall value float_sub(zF,zD)
+        call array_set_4value_offsets(temp,value,7,k)
+
+        #go to next row
+        add k 8
+    endwhile
+
+    #Pass 2: process columns.
+    set k 0
+    while k!=8
+        setcall tmp0 gettwofloats_offs_and_op(temp,0,56,k,0)
+        setcall tmp7 gettwofloats_offs_and_op(temp,0,56,k,1)
+        setcall tmp1 gettwofloats_offs_and_op(temp,8,48,k,0)
+        setcall tmp6 gettwofloats_offs_and_op(temp,8,48,k,1)
+        setcall tmp2 gettwofloats_offs_and_op(temp,16,40,k,0)
+        setcall tmp5 gettwofloats_offs_and_op(temp,16,40,k,1)
+        setcall tmp3 gettwofloats_offs_and_op(temp,24,32,k,0)
+        setcall tmp4 gettwofloats_offs_and_op(temp,24,32,k,1)
+
+        #
+        setcall tmp10 float_add(tmp0,tmp3)
+        setcall tmp13 float_sub(tmp0,tmp3)
+        setcall tmp11 float_add(tmp1,tmp2)
+        setcall tmp12 float_sub(tmp1,tmp2)
+        #
+        setcall value float_add(tmp10,tmp11)
+        call array_set_4value_offsets(temp,value,0,k)
+        setcall value float_sub(tmp10,tmp11)
+        call array_set_4value_offsets(temp,value,32,k)
+
+        #
+        setcall zA float_add(tmp12,tmp13)
+        setcall value str_to_float(fstr)
+        setcall zA float_mult(zA,value)
+        #
+        setcall value float_add(tmp13,zA)
+        call array_set_4value_offsets(temp,value,16,k)
+        setcall value float_sub(tmp13,zA)
+        call array_set_4value_offsets(temp,value,48,k)
+
+        #Odd part
+        setcall tmp10 float_add(tmp4,tmp5)
+        setcall tmp11 float_add(tmp5,tmp6)
+        setcall tmp12 float_add(tmp6,tmp7)
+
+        #The rotator is modified to avoid extra negations.
+        setcall zE float_sub(tmp10,tmp12)
+        setcall value str_to_float(fstr_1)
+        setcall zE float_mult(zE,value)
+
+        setcall zB str_to_float(fstr_2)
+        setcall zB float_mult(zB,tmp10)
+        setcall zB float_add(zB,zE)
+
+        setcall zD str_to_float(fstr_3)
+        setcall zD float_mult(zD,tmp12)
+        setcall zD float_add(zD,zE)
+
+        setcall zC str_to_float(fstr_4)
+        setcall zC float_mult(zC,tmp11)
+
+        #
+        setcall zF float_add(tmp7,zC)
+        setcall zG float_sub(tmp7,zC)
+        #
+
+        setcall value float_add(zG,zB)
+        call array_set_4value_offsets(temp,value,40,k)
+
+        setcall value float_sub(zG,zB)
+        call array_set_4value_offsets(temp,value,24,k)
+
+        setcall value float_add(zF,zD)
+        call array_set_4value_offsets(temp,value,8,k)
+
+        setcall value float_sub(zF,zD)
+        call array_set_4value_offsets(temp,value,56,k)
+
+        inc k
+    endwhile
+
+    #Do Quantization, ZigZag and proper roundoff.
+    set i 0
+    str temp_str="16384.5"
+    sd temp_value
+    setcall temp_value str_to_float(temp_str)
+    sd t_double#2
+    sd p_t_double^t_double
+    while i!=64
+        #temp[i] * FDCT_table[i];
+        setcall value float_mult(temp#,FDCT_table#)
+        add temp 4
+        add FDCT_table 4
+        #
+        #((Data)(temp + 16384.5) - 16384)
+        setcall value float_add(value,temp_value)
+        #
+        import "float_to_double" float_to_double
+        call float_to_double(value,p_t_double)
+        #
+        setcall value double_to_int(p_t_double)
+        #
+        sub value 16384
+        #outdata[Tables.ZigZag[i]]=value
+        sd pos
+        setcall pos jpeg_ZigZag_get(i)
+        #
+        call array_set_word_off(out_DCT_Quant,value,pos)
+        #
+        inc i
+    endwhile
+endfunction
+
+#float
+function gettwofloats_offs_and_op(sd floats,sd offA,sd offB,sd offset,sd operation)
+    sd k
+
+    sd f1
+    set f1 floats
+    mult offA 4
+    add f1 offA
+    set k offset
+    mult k 4
+    add f1 k
+    set f1 f1#
+
+    sd f2
+    set f2 floats
+    mult offB 4
+    add f2 offB
+    mult offset 4
+    add f2 offset
+
+    sd value
+    #0=add,1=sub
+    if operation=0
+        setcall value float_add(f1,f2#)
+    else
+        setcall value float_sub(f1,f2#)
+    endelse
+    return value
+endfunction
+
+###
+#bool
+function jpeg_category(sd action)
+    data category#1
+	if action=(value_set)
+        sd p_category^category
+        sd err
+        setcall err memoryalloc(65535,p_category)
+        if err!=(noerror)
+            return 0
+        endif
+        return 1
+	endif
+	if action=(value_get)
+        return category
+	endif
+        call free(category)
+endfunction
+#bool
+function jpeg_length(sd action)
+    data length#1
+	if action=(value_set)
+        sd p_length^length
+        sd err
+        setcall err memoryalloc(65535,p_length)
+        if err!=(noerror)
+            return 0
+        endif
+        return 1
+	endif
+	if action=(value_get)
+        return length
+	endif
+        call free(length)
+endfunction
+#bool
+function jpeg_value(sd action)
+    data value#1
+	if action=(value_set)
+        sd p_value^value
+        sd err
+        setcall err memoryalloc((2*65535),p_value)
+        if err!=(noerror)
+            return 0
+        endif
+        return 1
+	endif
+	if action=(value_get)
+        return value
+	endif
+        call free(value)
+endfunction
+
+import "array_get_byte" array_get_byte
+import "array_set_byte_off" array_set_byte_off
+
+function jpeg_encode_init_Huffman(sd standard_nr,sd standard_val,sd p_nr,sd p_val)
+    sd code_value=0
+    sd pos_in_table=0
+    sd k=1
+    while k<=16
+        sd j=1
+        sd max_j
+        setcall max_j array_get_byte(standard_nr,k)
+        while j<=max_j
+            sd pos
+            setcall pos array_get_byte(standard_val,pos_in_table)
+
+            call array_set_byte_off(p_nr,k,pos)
+            call array_set_word_off(p_val,code_value,pos)
+
+            inc pos_in_table
+            inc code_value
+            inc j
+        endwhile
+
+        mult code_value 2
+
+        inc k
+    endwhile
+endfunction
+
+const bytenew_start=0
+const bytepos_start=7
+
+function jpeg_encode_Huffman(sd action,sd DCT_tab,sd lum_or_crom,sd prev_DC)
+    sd category
+    sd bits_length
+    sd bits_value
+
+    setcall category jpeg_category((value_get))
+    setcall bits_length jpeg_length((value_get))
+    setcall bits_value jpeg_value((value_get))
+    if action=(value_set)
+        #init category and bitcodes
+        import "array_set_byte_offsets" array_set_byte_offsets
+        import "array_set_word_offsets" array_set_word_offsets
+
+        sd nr
+        sd nr_lower=1
+        sd nr_upper=2
+        sd categ=1
+        while categ<=15
+            #Positive numbers
+            set nr nr_lower
+            while nr<nr_upper
+                call array_set_byte_offsets(category,categ,32767,nr)
+                call array_set_byte_offsets(bits_length,categ,32767,nr)
+                call array_set_word_offsets(bits_value,nr,32767,nr)
+
+                inc nr
+            endwhile
+
+            #Negative numbers
+            import "neg" neg
+
+            setcall nr neg(nr_upper)
+            inc nr
+
+            sd neg_nr_lower
+            setcall neg_nr_lower neg(nr_lower)
+
+            while nr<=neg_nr_lower
+                call array_set_byte_offsets(category,categ,32767,nr)
+                call array_set_byte_offsets(bits_length,categ,32767,nr)
+
+                sd bts_val
+                set bts_val nr_upper
+                dec bts_val
+                add bts_val nr
+                call array_set_word_offsets(bits_value,bts_val,32767,nr)
+
+                inc nr
+            endwhile
+
+            mult nr_lower 2
+            mult nr_upper 2
+
+            inc categ
+        endwhile
+
+        #init encoding tables
+        sd Standard_DC_Luminance_Nr
+        sd Standard_DC_Luminance_Val
+        sd p_Standard_DC_Luminance_Val^Standard_DC_Luminance_Val
+        setcall Standard_DC_Luminance_Nr Huffman_DC_Luminance((Huffman_get),p_Standard_DC_Luminance_Val)
+
+        sd Standard_AC_Luminance_Nr
+        sd Standard_AC_Luminance_Val
+        sd p_Standard_AC_Luminance_Val^Standard_AC_Luminance_Val
+        setcall Standard_AC_Luminance_Nr Huffman_AC_Luminance((Huffman_get),p_Standard_AC_Luminance_Val)
+
+        sd Standard_DC_Chromiance_Nr
+        sd Standard_DC_Chromiance_Val
+        sd p_Standard_DC_Chromiance_Val^Standard_DC_Chromiance_Val
+        setcall Standard_DC_Chromiance_Nr Huffman_DC_Chromiance((Huffman_get),p_Standard_DC_Chromiance_Val)
+
+        sd Standard_AC_Chromiance_Nr
+        sd Standard_AC_Chromiance_Val
+        sd p_Standard_AC_Chromiance_Val^Standard_AC_Chromiance_Val
+        setcall Standard_AC_Chromiance_Nr Huffman_AC_Chromiance((Huffman_get),p_Standard_AC_Chromiance_Val)
+
+        char Y_DC_Huffman_Table_nr#12
+        char Y_DC_Huffman_Table_value#12*2
+        char Y_AC_Huffman_Table_nr#256
+        char Y_AC_Huffman_Table_value#256*2
+
+        char CbCr_DC_Huffman_Table_nr#12
+        char CbCr_DC_Huffman_Table_value#12*2
+        char CbCr_AC_Huffman_Table_nr#256
+        char CbCr_AC_Huffman_Table_value#256*2
+
+        data p_Lum_DC_nr^Y_DC_Huffman_Table_nr
+        data p_Lum_DC_val^Y_DC_Huffman_Table_value
+        call jpeg_encode_init_Huffman(Standard_DC_Luminance_Nr,Standard_DC_Luminance_Val,p_Lum_DC_nr,p_Lum_DC_val)
+        data p_Lum_AC_nr^Y_AC_Huffman_Table_nr
+        data p_Lum_AC_val^Y_AC_Huffman_Table_value
+        call jpeg_encode_init_Huffman(Standard_AC_Luminance_Nr,Standard_AC_Luminance_Val,p_Lum_AC_nr,p_Lum_AC_val)
+
+        data p_Crom_DC_nr^CbCr_DC_Huffman_Table_nr
+        data p_Crom_DC_val^CbCr_DC_Huffman_Table_value
+        call jpeg_encode_init_Huffman(Standard_DC_Chromiance_Nr,Standard_DC_Chromiance_Val,p_Crom_DC_nr,p_Crom_DC_val)
+        data p_Crom_AC_nr^CbCr_AC_Huffman_Table_nr
+        data p_Crom_AC_val^CbCr_AC_Huffman_Table_value
+        call jpeg_encode_init_Huffman(Standard_AC_Chromiance_Nr,Standard_AC_Chromiance_Val,p_Crom_AC_nr,p_Crom_AC_val)
+
+        call jpeg_bytenew((value_set),(bytenew_start))
+        call jpeg_bytepos((value_set),(bytepos_start))
+
+        return (void)
+    endif
+    #bool
+    import "array_get_word" array_get_word
+    sd len
+    sd value
+    sd HTDC_nr
+    sd HTDC_val
+    sd HTAC_nr
+    sd HTAC_val
+    if lum_or_crom=(lum)
+        set HTDC_nr p_Lum_DC_nr
+        set HTDC_val p_Lum_DC_val
+        set HTAC_nr p_Lum_AC_nr
+        set HTAC_val p_Lum_AC_val
+    else
+        set HTDC_nr p_Crom_DC_nr
+        set HTDC_val p_Crom_DC_val
+        set HTAC_nr p_Crom_AC_nr
+        set HTAC_val p_Crom_AC_val
+    endelse
+    #encode DC
+    #(sd action,sd DCT_tab,sd lum_or_crom,sd prev_DC)
+    import "short_to_int" short_to_int
+    sd DCT_tab_0
+    setcall DCT_tab_0 array_get_word(DCT_tab,0)
+    setcall DCT_tab_0 short_to_int(DCT_tab_0)
+
+    sd Diff
+    set Diff DCT_tab_0
+    sub Diff prev_DC#
+    set prev_DC# DCT_tab_0
+
+    if Diff=0
+        setcall len array_get_byte(HTDC_nr,0)
+        setcall value array_get_word(HTDC_val,0)
+        sd bool
+        setcall bool jpeg_write_data(len,value)
+        if bool=0
+            return 0
+        endif
+    else
+        sd pos
+        set pos Diff
+        add pos 32767
+
+        sd cat_value
+        setcall cat_value array_get_byte(category,pos)
+        setcall len array_get_byte(HTDC_nr,cat_value)
+        setcall value array_get_word(HTDC_val,cat_value)
+        setcall bool jpeg_write_data(len,value)
+        if bool=0
+            return 0
+        endif
+
+        setcall len array_get_byte(bits_length,pos)
+        setcall value array_get_word(bits_value,pos)
+        setcall bool jpeg_write_data(len,value)
+        if bool=0
+            return 0
+        endif
+    endelse
+    #encode AC
+    #get first element !=0 in reverse order
+    sd DCT_val
+    sd startpos
+    sd endpos
+    set endpos 63
+    sd loop=1
+    while loop=1
+        if endpos=0
+            set loop 0
+        else
+            setcall DCT_val array_get_word(DCT_tab,endpos)
+            if DCT_val!=0
+                set loop 0
+            else
+                dec endpos
+            endelse
+        endelse
+    endwhile
+    sd i=1
+    while i<=endpos
+        set startpos i
+        #advance i to first non zero
+        set loop 1
+        while loop=1
+            if i>endpos
+                set loop 0
+            else
+                setcall DCT_val array_get_word(DCT_tab,i)
+                if DCT_val!=0
+                    set loop 0
+                else
+                   inc i
+                endelse
+            endelse
+        endwhile
+        #total zeroes
+        sd nr_zeroes
+        set nr_zeroes i
+        sub nr_zeroes startpos
+        #
+        if nr_zeroes>=16
+            const HTAC_zeroes=0xF0
+            setcall len array_get_byte(HTAC_nr,(HTAC_zeroes))
+            setcall value array_get_word(HTAC_val,(HTAC_zeroes))
+
+            sd nr_marker_max
+            set nr_marker_max nr_zeroes
+            div nr_marker_max 16
+
+            sd nr_marker
+            set nr_marker 1
+            while nr_marker<=nr_marker_max
+                setcall bool jpeg_write_data(len,value)
+                if bool=0
+                    return 0
+                endif
+                inc nr_marker
+            endwhile
+
+            import "rest" rest
+            setcall nr_zeroes rest(nr_zeroes,16)
+        endif
+        #
+        sd index
+        setcall index array_get_word(DCT_tab,i)
+        setcall index short_to_int(index)
+        add index 32767
+        #
+        sd coef
+        set coef nr_zeroes
+        mult coef 16
+        addcall coef array_get_byte(category,index)
+
+        setcall len array_get_byte(HTAC_nr,coef)
+        setcall value array_get_word(HTAC_val,coef)
+        setcall bool jpeg_write_data(len,value)
+        if bool=0
+            return 0
+        endif
+        #
+        setcall len array_get_byte(bits_length,index)
+        setcall value array_get_word(bits_value,index)
+        setcall bool jpeg_write_data(len,value)
+        if bool=0
+            return 0
+        endif
+        #
+        inc i
+    endwhile
+    if endpos!=63
+        const EOB=0x00
+        setcall len array_get_byte(HTAC_nr,(EOB))
+        setcall value array_get_word(HTAC_val,(EOB))
+        setcall bool jpeg_write_data(len,value)
+        if bool=0
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+function jpeg_bytenew(sd action,sd value)
+    data bytenew#1
+    if action=(value_set)
+        set bytenew value
+    else
+        return bytenew
+    endelse
+endfunction
+function jpeg_bytepos(sd action,sd value)
+    data bytepos#1
+    if action=(value_set)
+        set bytepos value
+    else
+        return bytepos
+    endelse
+endfunction
+
+function jpeg_write_data(sd pos,sd data)
+    #words style from char
+    char m_data={1,   0,         2,   0,         4,    0,          8,    0}
+    char      *={16,  0,         32,  0,         64,   0,          128,  0}
+    char      *={256, 256/0x100, 512, 512/0x100, 1024, 1024/0x100, 2048, 2048/0x100}
+    char      *={4096,4096/0x100,8192,8192/0x100,16384,16384/0x100,32768,32768/0x100}
+    str mask^m_data
+
+    dec pos
+
+    sd bytenew
+    sd bytepos
+    sd pbyte^bytenew
+    setcall bytenew jpeg_bytenew((value_get))
+    setcall bytepos jpeg_bytepos((value_get))
+
+    while pos>=0
+        sd mask_value
+        setcall mask_value array_get_word(mask,pos)
+        and mask_value data
+        if mask_value!=0
+            orcall bytenew array_get_word(mask,bytepos)
+        endif
+        dec pos
+        dec bytepos
+        #write file data
+        if bytepos<0
+            sd bool
+            setcall bool jpeg_file_mem_add(pbyte,1)
+            if bool!=1
+                return 0
+            endif
+            if bytenew=0xff
+                str null=""
+                setcall bool jpeg_file_mem_add(null,1)
+                if bool!=1
+                    return 0
+                endif
+            endif
+
+            set bytenew (bytenew_start)
+            set bytepos (bytepos_start)
+        endif
+    endwhile
+    #store the bytenew and bytepos for next round
+    call jpeg_bytenew((value_set),bytenew)
+    call jpeg_bytepos((value_set),bytepos)
+
+    return 1
+endfunction
+
+
+
+
+
+
+
+
+
+
+
+
+#settings
+
+function jpeg_dialog()
+    ss j_sets="JPEG - Settings"
+    import "dialogfield_size" dialogfield_size
+    data jpeg_i_f^jpeg_settings_init
+    data jpeg_s_f^jpeg_settings_set
+    call dialogfield_size(j_sets,(GTK_DIALOG_MODAL),jpeg_i_f,jpeg_s_f,300,-1)
+endfunction
+
+function jpeg_settings_init(sd vbox,sd *dialog)
+    str q="Quality: "
+    import "hboxfield_cnt" hboxfield_cnt
+    sd hbox
+    setcall hbox hboxfield_cnt(vbox)
+    import "labelfield_left_default" labelfield_left_default
+    call labelfield_left_default(q,hbox)
+    #
+    importx "_gtk_hscale_new_with_range" gtk_hscale_new_with_range
+    sd min_d_low
+    sd min_d_high
+    sd max_d_low
+    sd max_d_high
+    sd step_d_low
+    sd step_d_high
+    sd p_min_d^min_d_low
+    sd p_max_d^max_d_low
+    sd p_step_d^step_d_low
+    call int_to_double(1,p_min_d)
+    call int_to_double(900,p_max_d)
+    call int_to_double(100,p_step_d)
+
+    data hscale#1
+    setcall hscale gtk_hscale_new_with_range(min_d_low,min_d_high,max_d_low,max_d_high,step_d_low,step_d_high)
+
+    importx "_gtk_range_set_value" gtk_range_set_value
+    sd currentpos
+    setcall currentpos jpeg_quality((value_get))
+    sd doublepos_low
+    sd doublepos_high
+    sd p_doublepos^doublepos_low
+    call int_to_double(currentpos,p_doublepos)
+    call gtk_range_set_value(hscale,doublepos_low,doublepos_high)
+
+    import "packstart" packstart
+    call packstart(hbox,hscale,(TRUE))
+    #
+    str max="Best"
+    call labelfield_left_default(max,hbox)
+
+    const p_hscale^hscale
+endfunction
+
+function jpeg_settings_set()
+    import "file_write_forward_sys_folder_enter_leave" file_write_forward_sys_folder_enter_leave
+    data forw_jpeg^jpeg_settings_set_write
+    import "jpeg_file" jpeg_file
+    ss jpeg_fl_str
+    setcall jpeg_fl_str jpeg_file()
+    call file_write_forward_sys_folder_enter_leave(jpeg_fl_str,forw_jpeg)
+endfunction
+function jpeg_settings_set_write(sd jpeg_fl)
+    import "hscale_get" hscale_get
+    sd p_hscale%p_hscale
+    sd value
+    setcall value hscale_get(p_hscale#)
+    call jpeg_quality((value_set),value)
+
+    sd p_value^value
+    call file_write(p_value,4,jpeg_fl)
+endfunction
+
+
+#quality
+function jpeg_quality(sd action,sd value)
+    data quality#1
+    if action=(value_set)
+        set quality value
+    else
+        return quality
+    endelse
+endfunction
+
+function jpeg_get_quality(sd mem,sd *size)
+    sd quality
+    sd p_quality^quality
+
+    import "get_mem_int_advance" get_mem_int_advance
+    sd mem_sz^mem
+    sd err
+    setcall err get_mem_int_advance(p_quality,mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    call jpeg_quality((value_set),quality)
+endfunction
--- ovideo-1.orig/src/media/jpeg_enc.s
+++ /dev/null
@@ -1,1871 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-import "file_write" file_write
-import "pixbuf_get_wh" pixbuf_get_wh
-import "alloc_block" alloc_block
-import "memoryalloc" memoryalloc
-importx "_free" free
-
-#bool
-function write_jpeg(sd file,sd pixbuf,sd quality)
-    sd bool
-    setcall bool jpeg_file_mem((value_set))
-    if bool==0
-        return 0
-    endif
-    setcall bool write_jpeg_file(pixbuf,quality)
-    if bool==0
-        return 0
-    endif
-
-    setcall bool jpeg_file_mem((value_filewrite),file)
-    if bool==0
-        return 0
-    endif
-
-    call jpeg_file_mem((value_unset))
-
-    return 1
-endfunction
-
-#bool
-function write_jpeg_file(sd pixbuf,sd quality)
-    sd bool
-    setcall bool write_jpeg_headers(pixbuf,quality)
-    if bool==0
-        return 0
-    endif
-
-    setcall bool jpeg_encode_main(pixbuf)
-    return bool
-endfunction
-
-
-#bool
-function write_jpeg_headers(sd pixbuf,sd quality)
-    sd bool
-    setcall bool write_jpeg_headers_appinfo()
-    if bool==0
-        return 0
-    endif
-    setcall bool write_jpeg_quantizationTables(quality)
-    if bool==0
-        return 0
-    endif
-    setcall bool write_jpeg_sof(pixbuf)
-    if bool==0
-        return 0
-    endif
-    setcall bool write_jpeg_Huffman()
-    if bool==0
-        return 0
-    endif
-    setcall bool write_jpeg_sos()
-    if bool==0
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function jpeg_encode_main(sd pixbuf)
-    sd bool
-    setcall bool jpeg_category((value_set))
-    if bool==0
-        return 0
-    endif
-    setcall bool jpeg_length((value_set))
-    if bool==0
-        call jpeg_category((value_unset))
-        return 0
-    endif
-    setcall bool jpeg_value((value_set))
-    if bool==0
-        call jpeg_category((value_unset))
-        call jpeg_length((value_unset))
-        return 0
-    endif
-
-    setcall bool write_jpeg_blocks(pixbuf)
-
-    call jpeg_category((value_unset))
-    call jpeg_length((value_unset))
-    call jpeg_value((value_unset))
-
-    return bool
-endfunction
-
-const lum=0
-const crom=1
-
-#bool
-function write_jpeg_blocks(sd pixbuf)
-    sd w
-    sd h
-    sd wh^w
-    call pixbuf_get_wh(pixbuf,wh)
-
-    #need when get 8x8
-    ##1
-    call jpeg_YCbCr_256color((value_set))
-
-    #need at quantization
-    ##2
-    call jpeg_FDCT_Quantization_Tables((value_set))
-    sd FDCT_Y
-    sd FDCT_CbCr
-    sd p_FDCT_CbCr^FDCT_CbCr
-    setcall FDCT_Y jpeg_FDCT_Quantization_Tables((value_get),p_FDCT_CbCr)
-
-    ##3
-    call jpeg_FDCT_Quantization_And_ZigZag((value_set))
-
-    ##4
-    call jpeg_encode_Huffman((value_set))
-    data prev_DC_Y#1
-    data prev_DC_Cb#1
-    data prev_DC_Cr#1
-    set prev_DC_Y 0
-    set prev_DC_Cb 0
-    set prev_DC_Cr 0
-    data p_prev_DC_Y^prev_DC_Y
-    data p_prev_DC_Cb^prev_DC_Cb
-    data p_prev_DC_Cr^prev_DC_Cr
-
-    #write blocks from top to bottom 8x8 pieces
-    sd j=0
-    while j<h
-        sd i=0
-        while i<w
-            #get a 8x8 block
-            char Y_data#8*8
-            char Cb_data#8*8
-            char Cr_data#8*8
-            str Y^Y_data
-            str Cb^Cb_data
-            str Cr^Cr_data
-            ##1
-            call jpeg_blocks_8x8(Y,Cb,Cr,pixbuf,i,j,w,h)
-
-            sd bool
-
-            #apply fast DCT and zigzag
-            #int16
-            char DCT_Quant_Y_data#64*2
-            str DCT_Quant_Y^DCT_Quant_Y_data
-            ##3,4
-            call jpeg_FDCT_Quantization_And_ZigZag((value_run),Y,DCT_Quant_Y,FDCT_Y)
-            #                                1 is for encode
-            setcall bool jpeg_encode_Huffman(1,DCT_Quant_Y,(lum),p_prev_DC_Y)
-            if bool!=1
-                return 0
-            endif
-            #
-            char DCT_Quant_Cb_data#64*2
-            str DCT_Quant_Cb^DCT_Quant_Cb_data
-            call jpeg_FDCT_Quantization_And_ZigZag((value_run),Cb,DCT_Quant_Cb,FDCT_CbCr)
-            setcall bool jpeg_encode_Huffman(1,DCT_Quant_Cb,(crom),p_prev_DC_Cb)
-            if bool!=1
-                return 0
-            endif
-            #
-            char DCT_Quant_Cr_data#64*2
-            str DCT_Quant_Cr^DCT_Quant_Cr_data
-            call jpeg_FDCT_Quantization_And_ZigZag((value_run),Cr,DCT_Quant_Cr,FDCT_CbCr)
-            setcall bool jpeg_encode_Huffman(1,DCT_Quant_Cr,(crom),p_prev_DC_Cr)
-            if bool!=1
-                return 0
-            endif
-            add i 8
-        endwhile
-        add j 8
-    endwhile
-
-    #Write End of Image Marker
-    char EOI_data={0xFF,0xD9}
-    str EOI^EOI_data
-    setcall bool jpeg_file_mem_add(EOI,2)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-
-
-
-function jpeg_file_mem(sd action,sd arg,sd append_size)
-    data mem#1
-    data size#1
-    if action==(value_set)
-    #bool
-        setcall mem alloc_block((value_set))
-        if mem==0
-            return 0
-        endif
-        set size 0
-        return 1
-    elseif action==(value_unset)
-        call free(mem)
-    elseif action==(value_append)
-    #bool
-        sd append
-        set append arg
-        sd appendresult
-        setcall appendresult alloc_block((value_append),mem,size,append,append_size)
-        if appendresult==0
-            return 0
-        endif
-        set mem appendresult
-        add size append_size
-        return 1
-    else
-    #if action==(value_filewrite)
-    #bool
-        sd file
-        set file arg
-        sd err
-        setcall err file_write(mem,size,file)
-        if err!=(noerror)
-            return 0
-        endif
-        return 1
-    endelse
-endfunction
-
-function jpeg_file_mem_add(sd append,sd append_size)
-    sd bool
-    setcall bool jpeg_file_mem((value_append),append,append_size)
-    return bool
-endfunction
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-##
-
-#bool
-function write_jpeg_headers_appinfo()
-    #JPEG INIT
-    char JPEG_INIT={0xff,0xD8}
-    #marker
-    char *={0xff,0xE0}
-    #length = 16 for usual JPEG, no thumbnail
-    char *={0,16}
-    #signature
-    char *="JFIF"
-    #high version,low version
-    char *={1,1}
-    #xyunits = 0 = no units, normal density
-    char *=0
-    #x density = 1
-    char *={0,1}
-    #y density = 1
-    char *={0,1}
-    #thumb n width, thumb n height
-    char *={0,0}
-
-    data size#1
-
-    const _appinfo^JPEG_INIT
-    const appinfo_^size
-    set size (appinfo_-_appinfo)
-
-    sd buffer^JPEG_INIT
-
-    sd bool
-    setcall bool jpeg_file_mem_add(buffer,size)
-    if bool!=1
-        return 0
-    endif
-
-    return 1
-endfunction
-
-
-#Quantization Tables
-#bool
-function write_jpeg_quantizationTables(sd quality)
-    char marker={0xFF,0xDB}
-    #length = 132
-    char *={0,132}
-    #QTYinfo
-    #bit 0..3: number of QT = 0 (table for Y)
-    #bit 4..7: precision of QT, 0 = 8 bit
-    char *=0
-    #Y Table, luminance table
-    char Y_Table#64
-    #QTCbinfo
-    #quantization table for Cb,Cr
-    char *=1
-    #CbCr Table, chromiance table
-    char CbCr_Table#64
-
-    data size#1
-    const _quantizationTables^marker
-    const quantizationTables_^size
-    set size (quantizationTables_-_quantizationTables)
-
-    char luminance_r1={16, 11, 10, 16,24, 40, 51, 61}
-    char *         r2={12, 12, 14, 19,26, 58, 60, 55}
-    char *         r3={14, 13, 16, 24,40, 57, 69, 56}
-    char *         r4={14, 17, 22, 29,51, 87, 80, 62}
-    char *         r5={18, 22, 37, 56,68, 109,103,77}
-    char *         r6={24, 35, 55, 64,81, 104,113,92}
-    char *         r7={49, 64, 78, 87,103,121,120,101}
-    char *         r8={72, 92, 95, 98,112,100,103,99}
-
-    str luminance^luminance_r1
-    str Y_Tab^Y_Table
-    call jpeg_Scale_And_ZigZag_Quantization_Table(luminance,Y_Tab,quality)
-
-    char chromiance_r1={17,  18,  24,  47,  99,  99,  99,  99}
-    char *          r2={18,  21,  26,  66,  99,  99,  99,  99}
-    char *          r3={24,  26,  56,  99,  99,  99,  99,  99}
-    char *          r4={47,  66,  99,  99,  99,  99,  99,  99}
-    char *          r5={99,  99,  99,  99,  99,  99,  99,  99}
-    char *          r6={99,  99,  99,  99,  99,  99,  99,  99}
-    char *          r7={99,  99,  99,  99,  99,  99,  99,  99}
-    char *          r8={99,  99,  99,  99,  99,  99,  99,  99}
-
-    str chromiance^chromiance_r1
-    str CbCr_Tab^CbCr_Table
-    call jpeg_Scale_And_ZigZag_Quantization_Table(chromiance,CbCr_Tab,quality)
-
-    sd buffer^marker
-    sd bool
-    setcall bool jpeg_file_mem_add(buffer,size)
-    if bool!=1
-        return 0
-    endif
-    return 1
-
-    const Y_Tab^Y_Table
-    const CbCr_Tab^CbCr_Table
-endfunction
-
-function jpeg_Y_Table()
-    sd p%Y_Tab
-    return p
-endfunction
-function jpeg_CbCr_Table()
-    sd p%CbCr_Tab
-    return p
-endfunction
-
-
-function jpeg_Scale_And_ZigZag_Quantization_Table(ss srctable,ss desttable,sd quality)
-    sd i=0
-    while i!=64
-        #quality_scale=1(best) (x*quality_scale+50)/100
-        sd temp
-        set temp srctable#
-        #quality
-        mult temp quality
-        #
-        add temp 50
-        div temp 100
-        if temp<=0
-            set temp 1
-        elseif temp>0xff
-            set temp 0xff
-        endelseif
-
-        call jpeg_ZigZag((value_set),desttable,i,temp)
-
-        inc srctable
-        inc i
-    endwhile
-endfunction
-
-function jpeg_ZigZag_get(sd i)
-    char zigzag_r1={0, 1, 5, 6, 14,15,27,28}
-    char *      r2={2, 4, 7, 13,16,26,29,42}
-    char *      r3={3, 8, 12,17,25,30,41,43}
-    char *      r4={9, 11,18,24,31,40,44,53}
-    char *      r5={10,19,23,32,39,45,52,54}
-    char *      r6={20,22,33,38,46,51,55,60}
-    char *      r7={21,34,37,47,50,56,59,61}
-    char *      r8={35,36,48,49,57,58,62,63}
-
-    str zigzag^zigzag_r1
-    ss ztab
-    set ztab zigzag
-    add ztab i
-
-    return ztab#
-endfunction
-
-function jpeg_ZigZag(sd action,ss table,sd i,sd value)
-    sd jump
-    setcall jump jpeg_ZigZag_get(i)
-    add table jump
-
-    if action==(value_set)
-        set table# value
-    else
-        return table#
-    endelse
-endfunction
-
-##
-
-#bool
-function write_jpeg_sof(sd pixbuf)
-    char marker={0xFF,0xC0}
-    #length = 17 for a truecolor YCbCr JPG
-    char *={0,17}
-    #precision, Should be 8: 8 bits/sample
-    char *=8
-    #height
-    char height#2
-    #width
-    char width#2
-    #nrofcomponents, Should be 3: We encode a truecolor JPG
-    char *=3
-    #IdY
-    char *=1
-    #HVY, sampling factors for Y (bit 0-3 vert., 4-7 hor.)
-    char *=0x11
-    #QTY, Quantization Table number for Y = 0
-    char *=0
-    #IdCb
-    char *=2
-    #HVCb
-    char *=0x11
-    #QTCb
-    char *=1
-    #IdCr
-    char *=3
-    #HVCr
-    char *=0x11
-    #QTCr, Normally equal to QTCb = 1
-    char *=1
-
-    data size#1
-    const _sof^marker
-    const sof_^size
-    set size (sof_-_sof)
-
-    import "word_reverse" word_reverse
-    sd w
-    sd h
-    sd wh^w
-    call pixbuf_get_wh(pixbuf,wh)
-    str wd^width
-    str ht^height
-    call word_reverse(h,ht)
-    call word_reverse(w,wd)
-
-    sd buffer^marker
-    sd bool
-    setcall bool jpeg_file_mem_add(buffer,size)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-##
-
-const Huffman_init=0
-const Huffman_get=1
-
-#bool
-function write_jpeg_Huffman()
-    char marker={0xFF,0xC4}
-    #length
-    char *={0x01,0xA2}
-
-    data size#1
-    const _Huffman^marker
-    const Huffman_^size
-    set size (Huffman_-_Huffman)
-
-    sd buffer^marker
-    sd bool
-    setcall bool jpeg_file_mem_add(buffer,size)
-    if bool!=1
-        return 0
-    endif
-
-    setcall bool Huffman_DC_Luminance((Huffman_init))
-    if bool==0
-        return 0
-    endif
-
-    setcall bool Huffman_AC_Luminance((Huffman_init))
-    if bool==0
-        return 0
-    endif
-
-    setcall bool Huffman_DC_Chromiance((Huffman_init))
-    if bool==0
-        return 0
-    endif
-
-    setcall bool Huffman_AC_Chromiance((Huffman_init))
-    if bool==0
-        return 0
-    endif
-
-    return 1
-endfunction
-
-#HT info,   bit 0..3: number of HT (0..3), for Y =0, Cb=1
-#           bit 4  :type of HT, 0 = DC table,1 = AC table
-#           bit 5..7: not used, must be 0
-
-const Y_table=0
-const Cb_table=1
-
-const DC_table=0
-const AC_table=0x10
-
-function Huffman_DC_Luminance(sd action,sd ptr_values)
-    char HT=Y_table|DC_table
-    char NRCodes={0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0}
-    char Values={ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
-
-    data Values_size#1
-
-    const YDC_NRCodes^NRCodes
-    const YDC_Values^Values
-    const YDC_Values_^Values_size
-
-    sd p_NRCodes^NRCodes
-    sd p_Values^Values
-
-    if action==(Huffman_init)
-    #bool
-        inc p_NRCodes
-        sd NRCodes_size=YDC_Values-YDC_NRCodes
-        dec NRCodes_size
-
-        set Values_size (YDC_Values_-YDC_Values)
-
-        sd bool
-        setcall bool Huffman_init_write(HT,p_NRCodes,NRCodes_size,p_Values,Values_size)
-        return bool
-    endif
-
-    set ptr_values# p_Values
-    return p_NRCodes
-endfunction
-
-function Huffman_AC_Luminance(sd action,sd ptr_values)
-    char HT=Y_table|AC_table
-    char NRCodes={0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d}
-    char Values={0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12}
-    char     *2={0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07}
-    char     *3={0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08}
-    char     *4={0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0}
-    char     *5={0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16}
-    char     *6={0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28}
-    char     *7={0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39}
-    char     *8={0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49}
-    char     *9={0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59}
-    char    *10={0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69}
-    char    *11={0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79}
-    char    *12={0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89}
-    char    *13={0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98}
-    char    *14={0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7}
-    char    *15={0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6}
-    char    *16={0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5}
-    char    *17={0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4}
-    char    *18={0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2}
-    char    *19={0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea}
-    char    *20={0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8}
-    char    *21={0xf9, 0xfa}
-
-    data Values_size#1
-
-    const YAC_NRCodes^NRCodes
-    const YAC_Values^Values
-    const YAC_Values_^Values_size
-
-    sd p_NRCodes^NRCodes
-    sd p_Values^Values
-
-    if action==(Huffman_init)
-    #bool
-        inc p_NRCodes
-        sd NRCodes_size=YAC_Values-YAC_NRCodes
-        dec NRCodes_size
-
-        set Values_size (YAC_Values_-YAC_Values)
-
-        sd bool
-        setcall bool Huffman_init_write(HT,p_NRCodes,NRCodes_size,p_Values,Values_size)
-        return bool
-    endif
-    set ptr_values# p_Values
-    return p_NRCodes
-endfunction
-
-function Huffman_DC_Chromiance(sd action,sd ptr_values)
-    char HT=Cb_table|DC_table
-    char NRCodes={0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
-    char Values={0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
-
-    data Values_size#1
-
-    const CbDC_NRCodes^NRCodes
-    const CbDC_Values^Values
-    const CbDC_Values_^Values_size
-
-    sd p_NRCodes^NRCodes
-    sd p_Values^Values
-
-    if action==(Huffman_init)
-    #bool
-        inc p_NRCodes
-        sd NRCodes_size=CbDC_Values-CbDC_NRCodes
-        dec NRCodes_size
-
-        set Values_size (CbDC_Values_-CbDC_Values)
-
-        sd bool
-        setcall bool Huffman_init_write(HT,p_NRCodes,NRCodes_size,p_Values,Values_size)
-        return bool
-    endif
-    set ptr_values# p_Values
-    return p_NRCodes
-endfunction
-
-function Huffman_AC_Chromiance(sd action,sd ptr_values)
-    char HT=Cb_table|AC_table
-    char NRCodes={0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77}
-    char Values={0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21}
-    char     *2={0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71}
-    char     *3={0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91}
-    char     *4={0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0}
-    char     *5={0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34}
-    char     *6={0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26}
-    char     *7={0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38}
-    char     *8={0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48}
-    char     *9={0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58}
-    char    *10={0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68}
-    char    *11={0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78}
-    char    *12={0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87}
-    char    *13={0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96}
-    char    *14={0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5}
-    char    *15={0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4}
-    char    *16={0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3}
-    char    *17={0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2}
-    char    *18={0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda}
-    char    *19={0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9}
-    char    *20={0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8}
-    char    *21={0xf9, 0xfa}
-
-    data Values_size#1
-
-    const CbAC_NRCodes^NRCodes
-    const CbAC_Values^Values
-    const CbAC_Values_^Values_size
-
-    sd p_NRCodes^NRCodes
-    sd p_Values^Values
-
-    if action==(Huffman_init)
-    #bool
-        inc p_NRCodes
-        sd NRCodes_size=CbAC_Values-CbAC_NRCodes
-        dec NRCodes_size
-
-        set Values_size (CbAC_Values_-CbAC_Values)
-
-        sd bool
-        setcall bool Huffman_init_write(HT,p_NRCodes,NRCodes_size,p_Values,Values_size)
-        return bool
-    endif
-    set ptr_values# p_Values
-    return p_NRCodes
-endfunction
-
-#bool
-function Huffman_init_write(sd HTbyte,sd NRCodes,sd NRCodes_size,sd Values,sd Values_size)
-    sd p_HTbyte^HTbyte
-    sd bool
-    setcall bool jpeg_file_mem_add(p_HTbyte,1)
-    if bool!=1
-        return 0
-    endif
-    setcall bool jpeg_file_mem_add(NRCodes,NRCodes_size)
-    if bool!=1
-        return 0
-    endif
-    setcall bool jpeg_file_mem_add(Values,Values_size)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-##
-
-#bool
-function write_jpeg_sos()
-    char marker={0xFF,0xDA}
-    char *length={0,12}
-    #nrofcomponents Should be 3: truecolor JPG
-    char *=3
-
-    char *IdY=1
-    #HT, bits 0..3: AC table (0..3)
-    #    bits 4..7: DC table (0..3)
-    char *HTY=0
-    char *IdCb=2
-    char *HTCb=0x11
-    char *IdCr=3
-    char *HTCr=0x11
-    char *Ss=0
-    char *Se=0x3F
-    char *Bf=0
-
-    data size#1
-    const _sos^marker
-    const sos_^size
-    set size (sos_-_sos)
-
-    sd buffer^marker
-    sd bool
-    setcall bool jpeg_file_mem_add(buffer,size)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-##
-
-###
-
-function jpeg_YCbCr_256color(sd action,sd red,sd green,sd blue,sd p_Y,sd p_Cb,sd p_Cr,sd x,sd y)
-    data Y_Red_Table_data#256
-    data Cb_Red_Table_data#256
-    data Cr_Red_Table_data#256
-    data Y_Green_Table_data#256
-    data Cb_Green_Table_data#256
-    data Cr_Green_Table_data#256
-    data Y_Blue_Table_data#256
-    data Cb_Blue_Table_data#256
-    data Cr_Blue_Table_data#256
-
-    sd Y_Red_Table^Y_Red_Table_data
-    sd Cb_Red_Table^Cb_Red_Table_data
-    sd Cr_Red_Table^Cr_Red_Table_data
-    sd Y_Green_Table^Y_Green_Table_data
-    sd Cb_Green_Table^Cb_Green_Table_data
-    sd Cr_Green_Table^Cr_Green_Table_data
-    sd Y_Blue_Table^Y_Blue_Table_data
-    sd Cb_Blue_Table^Cb_Blue_Table_data
-    sd Cr_Blue_Table^Cr_Blue_Table_data
-
-    sd variable
-    if action==(value_set)
-        sd color
-        set color 0
-        while color!=256
-            str Y_Red_coef="0.299"
-            setcall Y_Red_Table# jpeg_YCbCr_256color_equation(Y_Red_coef,color)
-            add Y_Red_Table 4
-
-            str Cb_Red_coef="-0.16874"
-            setcall Cb_Red_Table# jpeg_YCbCr_256color_equation(Cb_Red_coef,color)
-            add Cb_Red_Table 4
-
-            set variable color
-            mult variable 32768
-            set Cr_Red_Table# variable
-            add Cr_Red_Table 4
-
-            inc color
-        endwhile
-
-        set color 0
-        while color!=256
-            str Y_Green_coef="0.587"
-            setcall Y_Green_Table# jpeg_YCbCr_256color_equation(Y_Green_coef,color)
-            add Y_Green_Table 4
-
-            str Cb_Green_coef="-0.33126"
-            setcall Cb_Green_Table# jpeg_YCbCr_256color_equation(Cb_Green_coef,color)
-            add Cb_Green_Table 4
-
-            str Cr_Green_coef="-0.41869"
-            setcall Cr_Green_Table# jpeg_YCbCr_256color_equation(Cr_Green_coef,color)
-            add Cr_Green_Table 4
-
-            inc color
-        endwhile
-        set color 0
-        while color!=256
-            str Y_Blue_coef="0.114"
-            setcall Y_Blue_Table# jpeg_YCbCr_256color_equation(Y_Blue_coef,color)
-            add Y_Blue_Table 4
-
-            set variable color
-            mult variable 32768
-            set Cb_Blue_Table# variable
-            add Cb_Blue_Table 4
-
-            str Cr_Blue_coef="-0.08131"
-            setcall Cr_Blue_Table# jpeg_YCbCr_256color_equation(Cr_Blue_coef,color)
-            add Cr_Blue_Table 4
-
-            inc color
-        endwhile
-        return (void)
-    endif
-
-    import "array_byte_setAtXY" array_byte_setAtXY
-    sd Y
-    setcall Y jpeg_YCbCr_256color_get3(red,green,blue,Y_Red_Table,Y_Green_Table,Y_Blue_Table)
-    sub Y 128
-    call array_byte_setAtXY(p_Y,Y,x,y,8)
-
-    sd Cb
-    setcall Cb jpeg_YCbCr_256color_get3(red,green,blue,Cb_Red_Table,Cb_Green_Table,Cb_Blue_Table)
-    call array_byte_setAtXY(p_Cb,Cb,x,y,8)
-
-    sd Cr
-    setcall Cr jpeg_YCbCr_256color_get3(red,green,blue,Cr_Red_Table,Cr_Green_Table,Cr_Blue_Table)
-    call array_byte_setAtXY(p_Cr,Cr,x,y,8)
-endfunction
-
-import "str_to_double" str_to_double
-import "int_to_double" int_to_double
-import "double_mult" double_mult
-import "double_add" double_add
-import "double_to_int" double_to_int
-#res
-function jpeg_YCbCr_256color_equation(sd value,sd color)
-    #int((65536 * value + 0.5) * color)
-    #65536
-    str predef_double_str="65536"
-    sd predef_double#2
-    sd p_predef_double^predef_double
-    call str_to_double(predef_double_str,p_predef_double)
-    #value
-    sd double#2
-    sd p_double^double
-    call str_to_double(value,p_double)
-    #0.5
-    str pre_double_str="0.5"
-    sd pre_double#2
-    sd p_pre_double^pre_double
-    call str_to_double(pre_double_str,p_pre_double)
-    #color
-    sd color_double#2
-    sd p_color_double^color_double
-    call int_to_double(color,p_color_double)
-
-    call double_mult(p_double,p_predef_double)
-    call double_add(p_double,p_pre_double)
-    call double_mult(p_double,p_color_double)
-
-    sd res
-    setcall res double_to_int(p_double)
-    return res
-endfunction
-
-function bytemult4_getfromstruct(sd index,sd block)
-    mult index 4
-    import "structure_get_int" structure_get_int
-    sd value
-    setcall value structure_get_int(block,index)
-    return value
-endfunction
-function jpeg_YCbCr_256color_get3(sd red,sd green,sd blue,sd red_tab,sd green_tab,sd blue_tab)
-    sd value
-    setcall value bytemult4_getfromstruct(red,red_tab)
-    addcall value bytemult4_getfromstruct(green,green_tab)
-    addcall value bytemult4_getfromstruct(blue,blue_tab)
-    import "sar32" sar32
-    setcall value sar32(value,16)
-    return value
-endfunction
-
-function jpeg_blocks_8x8(ss Y_tab,ss Cb_tab,ss Cr_tab,sd pixbuf,sd i,sd j,sd max_i,sd max_j)
-    sd x
-    sd max_x
-    set x i
-    set max_x x
-    add max_x 8
-    sd min_y
-    sd max_y
-    set min_y j
-    set max_y min_y
-    add max_y 8
-
-    sd red
-    sd green
-    sd blue
-    sd colors^red
-
-    while x!=max_x
-        sd send_x
-        set send_x x
-        sub send_x i
-
-        sd y
-        set y min_y
-        while y!=max_y
-            sd send_y
-            set send_y y
-            sub send_y j
-
-            set red 0
-            set green 0
-            set blue 0
-            if x<max_i
-                if y<max_j
-                    import "pixbuf_get_pixel" pixbuf_get_pixel
-                    sd value
-                    setcall value pixbuf_get_pixel(pixbuf,x,y)
-                    import "rgb_uint_to_colors" rgb_uint_to_colors
-                    call rgb_uint_to_colors(value,colors)
-                endif
-            endif
-
-            call jpeg_YCbCr_256color((value_get),red,green,blue,Y_tab,Cb_tab,Cr_tab,send_x,send_y)
-
-            inc y
-        endwhile
-        inc x
-    endwhile
-endfunction
-
-###
-
-function jpeg_FDCT_Quantization_Tables(sd action,sd p_CbCr)
-    data FDCT_Y_Quantization#64
-    sd FDCT_Y^FDCT_Y_Quantization
-    data FDCT_CbCr_Quantization#64
-    sd FDCT_CbCr^FDCT_CbCr_Quantization
-    if action==(value_set)
-        data CosineScaleFactor_data#8*2
-        sd CosineScaleFactor^CosineScaleFactor_data
-
-        char CosineScaleFactor_coef1="1.0"
-        char *CosineScaleFactor_coef2="1.387039845"
-        char *CosineScaleFactor_coef3="1.306562965"
-        char *CosineScaleFactor_coef4="1.175875602"
-        char *CosineScaleFactor_coef5="1.0"
-        char *CosineScaleFactor_coef6="0.785694958"
-        char *CosineScaleFactor_coef7="0.541196100"
-        char *CosineScaleFactor_coef8="0.275899379"
-        char *=0
-
-        ss CosineScaleFactor_coef^CosineScaleFactor_coef1
-
-#1.0 / (X_Table[Tables.ZigZag[i]]*CSF[row]*CSF[col]*8.0)
-        #8.0 to double
-        sd const_denom#2
-        sd p_const_denom^const_denom
-        str c_denom="1.0"
-        call str_to_double(c_denom,p_const_denom)
-
-        #8.0 to double
-        sd const_double#2
-        sd p_const_double^const_double
-        str c_double="8.0"
-        call str_to_double(c_double,p_const_double)
-
-        #cosines to double
-
-        while CosineScaleFactor_coef#!=0
-            call str_to_double(CosineScaleFactor_coef,CosineScaleFactor)
-
-            add CosineScaleFactor 8
-            import "slen" slen
-            addcall CosineScaleFactor_coef slen(CosineScaleFactor_coef)
-            inc CosineScaleFactor_coef
-        endwhile
-
-        #for cpy 1.0 here
-        sd res_value#2
-        sd p_res_value^res_value
-
-        sd tabs=0
-        while tabs!=2
-            sd Table
-            sd dest_table
-            if tabs==0
-                setcall Table jpeg_Y_Table()
-                set dest_table FDCT_Y
-            else
-                setcall Table jpeg_CbCr_Table()
-                set dest_table FDCT_CbCr
-            endelse
-
-            sd i=0
-            sd row=0
-            sd CosineScaleFactor_row^CosineScaleFactor_data
-            while row!=8
-                sd col=0
-                sd CosineScaleFactor_col^CosineScaleFactor_data
-                while col!=8
-                    import "cpymem" cpymem
-                    import "double_div" double_div
-                    import "double_to_float" double_to_float
-
-                    #get
-                    sd value
-                    setcall value jpeg_ZigZag((value_get),Table,i)
-                    sd double_value#2
-                    sd p_double_value^double_value
-                    call int_to_double(value,p_double_value)
-
-                    call double_mult(p_double_value,CosineScaleFactor_row)
-                    call double_mult(p_double_value,CosineScaleFactor_col)
-                    call double_mult(p_double_value,p_const_double)
-
-                    call cpymem(p_res_value,p_const_denom,8)
-                    call double_div(p_res_value,p_double_value)
-
-                    setcall dest_table# double_to_float(p_res_value)
-
-                    add dest_table 4
-                    add CosineScaleFactor_col 8
-                    inc i
-                    inc col
-                endwhile
-                add CosineScaleFactor_row 8
-                inc row
-            endwhile
-            inc tabs
-        endwhile
-        return (void)
-    endif
-    #get
-    set p_CbCr# FDCT_CbCr
-    return FDCT_Y
-endfunction
-
-###
-
-import "float_add" float_add
-import "array_set_word_off" array_set_word_off
-
-#                                                    char        int16            float
-function jpeg_FDCT_Quantization_And_ZigZag(sd action,ss data8x8,sd out_DCT_Quant,sd FDCT_table)
-    if action==(value_set)
-        import "str_to_float" str_to_float
-
-        str fstr="0.707106781"
-        data float_0#1
-        setcall float_0 str_to_float(fstr)
-        str fstr_1="0.382683433"
-        data float_1#1
-        setcall float_1 str_to_float(fstr_1)
-        str fstr_2="0.541196100"
-        data float_2#1
-        setcall float_2 str_to_float(fstr_2)
-        str fstr_3="1.306562965"
-        data float_3#1
-        setcall float_3 str_to_float(fstr_3)
-        str fstr_4="0.707106781"
-        data float_4#1
-        setcall float_4 str_to_float(fstr_4)
-        return 1
-    endif
-    sd tmp0
-    sd tmp1
-    sd tmp2
-    sd tmp3
-    sd tmp4
-    sd tmp5
-    sd tmp6
-    sd tmp7
-    #
-    sd tmp10
-    sd tmp11
-    sd tmp12
-    sd tmp13
-    #
-    sd zA
-    sd zB
-    sd zC
-    sd zD
-    sd zE
-    sd zF
-    sd zG
-
-    sd cursor
-    sd value
-    #convert the sbyte table to float
-    char temp_data#64*4
-    sd temp^temp_data
-    sd i=0
-    set cursor temp
-    while i!=64
-        import "int_to_float" int_to_float
-        import "char_to_int" char_to_int
-        setcall value char_to_int(data8x8#)
-        setcall cursor# int_to_float(value)
-        add cursor 4
-        inc data8x8
-        inc i
-    endwhile
-
-    import "array_set_4value_offsets" array_set_4value_offsets
-    import "float_mult" float_mult
-    import "float_sub" float_sub
-
-    #Pass 1: process rows.
-    sd k=0
-    while k!=64
-    #0=add; 1=sub
-        setcall tmp0 gettwofloats_offs_and_op(temp,0,7,k,0)
-        setcall tmp7 gettwofloats_offs_and_op(temp,0,7,k,1)
-        setcall tmp1 gettwofloats_offs_and_op(temp,1,6,k,0)
-        setcall tmp6 gettwofloats_offs_and_op(temp,1,6,k,1)
-        setcall tmp2 gettwofloats_offs_and_op(temp,2,5,k,0)
-        setcall tmp5 gettwofloats_offs_and_op(temp,2,5,k,1)
-        setcall tmp3 gettwofloats_offs_and_op(temp,3,4,k,0)
-        setcall tmp4 gettwofloats_offs_and_op(temp,3,4,k,1)
-
-        #Even part
-        setcall tmp10 float_add(tmp0,tmp3)
-        setcall tmp13 float_sub(tmp0,tmp3)
-        setcall tmp11 float_add(tmp1,tmp2)
-        setcall tmp12 float_sub(tmp1,tmp2)
-
-        #
-        setcall value float_add(tmp10,tmp11)
-        call array_set_4value_offsets(temp,value,0,k)
-        setcall value float_sub(tmp10,tmp11)
-        call array_set_4value_offsets(temp,value,4,k)
-
-        #
-        setcall zA float_add(tmp12,tmp13)
-        setcall zA float_mult(zA,float_0)
-
-        #
-        setcall value float_add(tmp13,zA)
-        call array_set_4value_offsets(temp,value,2,k)
-        setcall value float_sub(tmp13,zA)
-        call array_set_4value_offsets(temp,value,6,k)
-
-        #Odd part
-        setcall tmp10 float_add(tmp4,tmp5)
-        setcall tmp11 float_add(tmp5,tmp6)
-        setcall tmp12 float_add(tmp6,tmp7)
-
-        #The rotator is modified to avoid extra negations.
-        setcall zE float_sub(tmp10,tmp12)
-        setcall zE float_mult(zE,float_1)
-
-        set zB float_2
-        setcall zB float_mult(zB,tmp10)
-        setcall zB float_add(zB,zE)
-
-        set zD float_3
-        setcall zD float_mult(zD,tmp12)
-        setcall zD float_add(zD,zE)
-
-        set zC float_4
-        setcall zC float_mult(zC,tmp11)
-
-        #
-        setcall zF float_add(tmp7,zC)
-        setcall zG float_sub(tmp7,zC)
-        #
-
-        setcall value float_add(zG,zB)
-        call array_set_4value_offsets(temp,value,5,k)
-
-        setcall value float_sub(zG,zB)
-        call array_set_4value_offsets(temp,value,3,k)
-
-        setcall value float_add(zF,zD)
-        call array_set_4value_offsets(temp,value,1,k)
-
-        setcall value float_sub(zF,zD)
-        call array_set_4value_offsets(temp,value,7,k)
-
-        #go to next row
-        add k 8
-    endwhile
-
-    #Pass 2: process columns.
-    set k 0
-    while k!=8
-        setcall tmp0 gettwofloats_offs_and_op(temp,0,56,k,0)
-        setcall tmp7 gettwofloats_offs_and_op(temp,0,56,k,1)
-        setcall tmp1 gettwofloats_offs_and_op(temp,8,48,k,0)
-        setcall tmp6 gettwofloats_offs_and_op(temp,8,48,k,1)
-        setcall tmp2 gettwofloats_offs_and_op(temp,16,40,k,0)
-        setcall tmp5 gettwofloats_offs_and_op(temp,16,40,k,1)
-        setcall tmp3 gettwofloats_offs_and_op(temp,24,32,k,0)
-        setcall tmp4 gettwofloats_offs_and_op(temp,24,32,k,1)
-
-        #
-        setcall tmp10 float_add(tmp0,tmp3)
-        setcall tmp13 float_sub(tmp0,tmp3)
-        setcall tmp11 float_add(tmp1,tmp2)
-        setcall tmp12 float_sub(tmp1,tmp2)
-        #
-        setcall value float_add(tmp10,tmp11)
-        call array_set_4value_offsets(temp,value,0,k)
-        setcall value float_sub(tmp10,tmp11)
-        call array_set_4value_offsets(temp,value,32,k)
-
-        #
-        setcall zA float_add(tmp12,tmp13)
-        setcall value str_to_float(fstr)
-        setcall zA float_mult(zA,value)
-        #
-        setcall value float_add(tmp13,zA)
-        call array_set_4value_offsets(temp,value,16,k)
-        setcall value float_sub(tmp13,zA)
-        call array_set_4value_offsets(temp,value,48,k)
-
-        #Odd part
-        setcall tmp10 float_add(tmp4,tmp5)
-        setcall tmp11 float_add(tmp5,tmp6)
-        setcall tmp12 float_add(tmp6,tmp7)
-
-        #The rotator is modified to avoid extra negations.
-        setcall zE float_sub(tmp10,tmp12)
-        setcall value str_to_float(fstr_1)
-        setcall zE float_mult(zE,value)
-
-        setcall zB str_to_float(fstr_2)
-        setcall zB float_mult(zB,tmp10)
-        setcall zB float_add(zB,zE)
-
-        setcall zD str_to_float(fstr_3)
-        setcall zD float_mult(zD,tmp12)
-        setcall zD float_add(zD,zE)
-
-        setcall zC str_to_float(fstr_4)
-        setcall zC float_mult(zC,tmp11)
-
-        #
-        setcall zF float_add(tmp7,zC)
-        setcall zG float_sub(tmp7,zC)
-        #
-
-        setcall value float_add(zG,zB)
-        call array_set_4value_offsets(temp,value,40,k)
-
-        setcall value float_sub(zG,zB)
-        call array_set_4value_offsets(temp,value,24,k)
-
-        setcall value float_add(zF,zD)
-        call array_set_4value_offsets(temp,value,8,k)
-
-        setcall value float_sub(zF,zD)
-        call array_set_4value_offsets(temp,value,56,k)
-
-        inc k
-    endwhile
-
-    #Do Quantization, ZigZag and proper roundoff.
-    set i 0
-    str temp_str="16384.5"
-    sd temp_value
-    setcall temp_value str_to_float(temp_str)
-    sd t_double#2
-    sd p_t_double^t_double
-    while i!=64
-        #temp[i] * FDCT_table[i];
-        setcall value float_mult(temp#,FDCT_table#)
-        add temp 4
-        add FDCT_table 4
-        #
-        #((Data)(temp + 16384.5) - 16384)
-        setcall value float_add(value,temp_value)
-        #
-        import "float_to_double" float_to_double
-        call float_to_double(value,p_t_double)
-        #
-        setcall value double_to_int(p_t_double)
-        #
-        sub value 16384
-        #outdata[Tables.ZigZag[i]]=value
-        sd pos
-        setcall pos jpeg_ZigZag_get(i)
-        #
-        call array_set_word_off(out_DCT_Quant,value,pos)
-        #
-        inc i
-    endwhile
-endfunction
-
-#float
-function gettwofloats_offs_and_op(sd floats,sd offA,sd offB,sd offset,sd operation)
-    sd k
-
-    sd f1
-    set f1 floats
-    mult offA 4
-    add f1 offA
-    set k offset
-    mult k 4
-    add f1 k
-    set f1 f1#
-
-    sd f2
-    set f2 floats
-    mult offB 4
-    add f2 offB
-    mult offset 4
-    add f2 offset
-
-    sd value
-    #0=add,1=sub
-    if operation==0
-        setcall value float_add(f1,f2#)
-    else
-        setcall value float_sub(f1,f2#)
-    endelse
-    return value
-endfunction
-
-###
-#bool
-function jpeg_category(sd action)
-    data category#1
-    if action==(value_set)
-        sd p_category^category
-        sd err
-        setcall err memoryalloc(65535,p_category)
-        if err!=(noerror)
-            return 0
-        endif
-        return 1
-    elseif action==(value_get)
-        return category
-    else
-        call free(category)
-    endelse
-endfunction
-#bool
-function jpeg_length(sd action)
-    data length#1
-    if action==(value_set)
-        sd p_length^length
-        sd err
-        setcall err memoryalloc(65535,p_length)
-        if err!=(noerror)
-            return 0
-        endif
-        return 1
-    elseif action==(value_get)
-        return length
-    else
-        call free(length)
-    endelse
-endfunction
-#bool
-function jpeg_value(sd action)
-    data value#1
-    if action==(value_set)
-        sd p_value^value
-        sd err
-        setcall err memoryalloc((2*65535),p_value)
-        if err!=(noerror)
-            return 0
-        endif
-        return 1
-    elseif action==(value_get)
-        return value
-    else
-        call free(value)
-    endelse
-endfunction
-
-import "array_get_byte" array_get_byte
-import "array_set_byte_off" array_set_byte_off
-
-function jpeg_encode_init_Huffman(sd standard_nr,sd standard_val,sd p_nr,sd p_val)
-    sd code_value=0
-    sd pos_in_table=0
-    sd k=1
-    while k<=16
-        sd j=1
-        sd max_j
-        setcall max_j array_get_byte(standard_nr,k)
-        while j<=max_j
-            sd pos
-            setcall pos array_get_byte(standard_val,pos_in_table)
-
-            call array_set_byte_off(p_nr,k,pos)
-            call array_set_word_off(p_val,code_value,pos)
-
-            inc pos_in_table
-            inc code_value
-            inc j
-        endwhile
-
-        mult code_value 2
-
-        inc k
-    endwhile
-endfunction
-
-const bytenew_start=0
-const bytepos_start=7
-
-function jpeg_encode_Huffman(sd action,sd DCT_tab,sd lum_or_crom,sd prev_DC)
-    sd category
-    sd bits_length
-    sd bits_value
-
-    setcall category jpeg_category((value_get))
-    setcall bits_length jpeg_length((value_get))
-    setcall bits_value jpeg_value((value_get))
-    if action==(value_set)
-        #init category and bitcodes
-        import "array_set_byte_offsets" array_set_byte_offsets
-        import "array_set_word_offsets" array_set_word_offsets
-
-        sd nr
-        sd nr_lower=1
-        sd nr_upper=2
-        sd categ=1
-        while categ<=15
-            #Positive numbers
-            set nr nr_lower
-            while nr<nr_upper
-                call array_set_byte_offsets(category,categ,32767,nr)
-                call array_set_byte_offsets(bits_length,categ,32767,nr)
-                call array_set_word_offsets(bits_value,nr,32767,nr)
-
-                inc nr
-            endwhile
-
-            #Negative numbers
-            import "neg" neg
-
-            setcall nr neg(nr_upper)
-            inc nr
-
-            sd neg_nr_lower
-            setcall neg_nr_lower neg(nr_lower)
-
-            while nr<=neg_nr_lower
-                call array_set_byte_offsets(category,categ,32767,nr)
-                call array_set_byte_offsets(bits_length,categ,32767,nr)
-
-                sd bts_val
-                set bts_val nr_upper
-                dec bts_val
-                add bts_val nr
-                call array_set_word_offsets(bits_value,bts_val,32767,nr)
-
-                inc nr
-            endwhile
-
-            mult nr_lower 2
-            mult nr_upper 2
-
-            inc categ
-        endwhile
-
-        #init encoding tables
-        sd Standard_DC_Luminance_Nr
-        sd Standard_DC_Luminance_Val
-        sd p_Standard_DC_Luminance_Val^Standard_DC_Luminance_Val
-        setcall Standard_DC_Luminance_Nr Huffman_DC_Luminance((Huffman_get),p_Standard_DC_Luminance_Val)
-
-        sd Standard_AC_Luminance_Nr
-        sd Standard_AC_Luminance_Val
-        sd p_Standard_AC_Luminance_Val^Standard_AC_Luminance_Val
-        setcall Standard_AC_Luminance_Nr Huffman_AC_Luminance((Huffman_get),p_Standard_AC_Luminance_Val)
-
-        sd Standard_DC_Chromiance_Nr
-        sd Standard_DC_Chromiance_Val
-        sd p_Standard_DC_Chromiance_Val^Standard_DC_Chromiance_Val
-        setcall Standard_DC_Chromiance_Nr Huffman_DC_Chromiance((Huffman_get),p_Standard_DC_Chromiance_Val)
-
-        sd Standard_AC_Chromiance_Nr
-        sd Standard_AC_Chromiance_Val
-        sd p_Standard_AC_Chromiance_Val^Standard_AC_Chromiance_Val
-        setcall Standard_AC_Chromiance_Nr Huffman_AC_Chromiance((Huffman_get),p_Standard_AC_Chromiance_Val)
-
-        char Y_DC_Huffman_Table_nr#12
-        char Y_DC_Huffman_Table_value#12*2
-        char Y_AC_Huffman_Table_nr#256
-        char Y_AC_Huffman_Table_value#256*2
-
-        char CbCr_DC_Huffman_Table_nr#12
-        char CbCr_DC_Huffman_Table_value#12*2
-        char CbCr_AC_Huffman_Table_nr#256
-        char CbCr_AC_Huffman_Table_value#256*2
-
-        data p_Lum_DC_nr^Y_DC_Huffman_Table_nr
-        data p_Lum_DC_val^Y_DC_Huffman_Table_value
-        call jpeg_encode_init_Huffman(Standard_DC_Luminance_Nr,Standard_DC_Luminance_Val,p_Lum_DC_nr,p_Lum_DC_val)
-        data p_Lum_AC_nr^Y_AC_Huffman_Table_nr
-        data p_Lum_AC_val^Y_AC_Huffman_Table_value
-        call jpeg_encode_init_Huffman(Standard_AC_Luminance_Nr,Standard_AC_Luminance_Val,p_Lum_AC_nr,p_Lum_AC_val)
-
-        data p_Crom_DC_nr^CbCr_DC_Huffman_Table_nr
-        data p_Crom_DC_val^CbCr_DC_Huffman_Table_value
-        call jpeg_encode_init_Huffman(Standard_DC_Chromiance_Nr,Standard_DC_Chromiance_Val,p_Crom_DC_nr,p_Crom_DC_val)
-        data p_Crom_AC_nr^CbCr_AC_Huffman_Table_nr
-        data p_Crom_AC_val^CbCr_AC_Huffman_Table_value
-        call jpeg_encode_init_Huffman(Standard_AC_Chromiance_Nr,Standard_AC_Chromiance_Val,p_Crom_AC_nr,p_Crom_AC_val)
-
-        call jpeg_bytenew((value_set),(bytenew_start))
-        call jpeg_bytepos((value_set),(bytepos_start))
-
-        return (void)
-    endif
-    #bool
-    import "array_get_word" array_get_word
-    sd len
-    sd value
-    sd HTDC_nr
-    sd HTDC_val
-    sd HTAC_nr
-    sd HTAC_val
-    if lum_or_crom==(lum)
-        set HTDC_nr p_Lum_DC_nr
-        set HTDC_val p_Lum_DC_val
-        set HTAC_nr p_Lum_AC_nr
-        set HTAC_val p_Lum_AC_val
-    else
-        set HTDC_nr p_Crom_DC_nr
-        set HTDC_val p_Crom_DC_val
-        set HTAC_nr p_Crom_AC_nr
-        set HTAC_val p_Crom_AC_val
-    endelse
-    #encode DC
-    #(sd action,sd DCT_tab,sd lum_or_crom,sd prev_DC)
-    import "short_to_int" short_to_int
-    sd DCT_tab_0
-    setcall DCT_tab_0 array_get_word(DCT_tab,0)
-    setcall DCT_tab_0 short_to_int(DCT_tab_0)
-
-    sd Diff
-    set Diff DCT_tab_0
-    sub Diff prev_DC#
-    set prev_DC# DCT_tab_0
-
-    if Diff==0
-        setcall len array_get_byte(HTDC_nr,0)
-        setcall value array_get_word(HTDC_val,0)
-        sd bool
-        setcall bool jpeg_write_data(len,value)
-        if bool==0
-            return 0
-        endif
-    else
-        sd pos
-        set pos Diff
-        add pos 32767
-
-        sd cat_value
-        setcall cat_value array_get_byte(category,pos)
-        setcall len array_get_byte(HTDC_nr,cat_value)
-        setcall value array_get_word(HTDC_val,cat_value)
-        setcall bool jpeg_write_data(len,value)
-        if bool==0
-            return 0
-        endif
-
-        setcall len array_get_byte(bits_length,pos)
-        setcall value array_get_word(bits_value,pos)
-        setcall bool jpeg_write_data(len,value)
-        if bool==0
-            return 0
-        endif
-    endelse
-    #encode AC
-    #get first element !=0 in reverse order
-    sd DCT_val
-    sd startpos
-    sd endpos
-    set endpos 63
-    sd loop=1
-    while loop==1
-        if endpos==0
-            set loop 0
-        else
-            setcall DCT_val array_get_word(DCT_tab,endpos)
-            if DCT_val!=0
-                set loop 0
-            else
-                dec endpos
-            endelse
-        endelse
-    endwhile
-    sd i=1
-    while i<=endpos
-        set startpos i
-        #advance i to first non zero
-        set loop 1
-        while loop==1
-            if i>endpos
-                set loop 0
-            else
-                setcall DCT_val array_get_word(DCT_tab,i)
-                if DCT_val!=0
-                    set loop 0
-                else
-                   inc i
-                endelse
-            endelse
-        endwhile
-        #total zeroes
-        sd nr_zeroes
-        set nr_zeroes i
-        sub nr_zeroes startpos
-        #
-        if nr_zeroes>=16
-            const HTAC_zeroes=0xF0
-            setcall len array_get_byte(HTAC_nr,(HTAC_zeroes))
-            setcall value array_get_word(HTAC_val,(HTAC_zeroes))
-
-            sd nr_marker_max
-            set nr_marker_max nr_zeroes
-            div nr_marker_max 16
-
-            sd nr_marker
-            set nr_marker 1
-            while nr_marker<=nr_marker_max
-                setcall bool jpeg_write_data(len,value)
-                if bool==0
-                    return 0
-                endif
-                inc nr_marker
-            endwhile
-
-            import "rest" rest
-            setcall nr_zeroes rest(nr_zeroes,16)
-        endif
-        #
-        sd index
-        setcall index array_get_word(DCT_tab,i)
-        setcall index short_to_int(index)
-        add index 32767
-        #
-        sd coef
-        set coef nr_zeroes
-        mult coef 16
-        addcall coef array_get_byte(category,index)
-
-        setcall len array_get_byte(HTAC_nr,coef)
-        setcall value array_get_word(HTAC_val,coef)
-        setcall bool jpeg_write_data(len,value)
-        if bool==0
-            return 0
-        endif
-        #
-        setcall len array_get_byte(bits_length,index)
-        setcall value array_get_word(bits_value,index)
-        setcall bool jpeg_write_data(len,value)
-        if bool==0
-            return 0
-        endif
-        #
-        inc i
-    endwhile
-    if endpos!=63
-        const EOB=0x00
-        setcall len array_get_byte(HTAC_nr,(EOB))
-        setcall value array_get_word(HTAC_val,(EOB))
-        setcall bool jpeg_write_data(len,value)
-        if bool==0
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-function jpeg_bytenew(sd action,sd value)
-    data bytenew#1
-    if action==(value_set)
-        set bytenew value
-    else
-        return bytenew
-    endelse
-endfunction
-function jpeg_bytepos(sd action,sd value)
-    data bytepos#1
-    if action==(value_set)
-        set bytepos value
-    else
-        return bytepos
-    endelse
-endfunction
-
-function jpeg_write_data(sd pos,sd data)
-    #words style from char
-    char m_data={1,   0,         2,   0,         4,    0,          8,    0}
-    char      *={16,  0,         32,  0,         64,   0,          128,  0}
-    char      *={256, 256/0x100, 512, 512/0x100, 1024, 1024/0x100, 2048, 2048/0x100}
-    char      *={4096,4096/0x100,8192,8192/0x100,16384,16384/0x100,32768,32768/0x100}
-    str mask^m_data
-
-    dec pos
-
-    sd bytenew
-    sd bytepos
-    sd pbyte^bytenew
-    setcall bytenew jpeg_bytenew((value_get))
-    setcall bytepos jpeg_bytepos((value_get))
-
-    while pos>=0
-        sd mask_value
-        setcall mask_value array_get_word(mask,pos)
-        and mask_value data
-        if mask_value!=0
-            orcall bytenew array_get_word(mask,bytepos)
-        endif
-        dec pos
-        dec bytepos
-        #write file data
-        if bytepos<0
-            sd bool
-            setcall bool jpeg_file_mem_add(pbyte,1)
-            if bool!=1
-                return 0
-            endif
-            if bytenew==0xff
-                str null=""
-                setcall bool jpeg_file_mem_add(null,1)
-                if bool!=1
-                    return 0
-                endif
-            endif
-
-            set bytenew (bytenew_start)
-            set bytepos (bytepos_start)
-        endif
-    endwhile
-    #store the bytenew and bytepos for next round
-    call jpeg_bytenew((value_set),bytenew)
-    call jpeg_bytepos((value_set),bytepos)
-
-    return 1
-endfunction
-
-
-
-
-
-
-
-
-
-
-
-
-#settings
-
-function jpeg_dialog()
-    ss j_sets="JPEG - Settings"
-    import "dialogfield_size" dialogfield_size
-    data jpeg_i_f^jpeg_settings_init
-    data jpeg_s_f^jpeg_settings_set
-    call dialogfield_size(j_sets,(GTK_DIALOG_MODAL),jpeg_i_f,jpeg_s_f,300,-1)
-endfunction
-
-function jpeg_settings_init(sd vbox,sd *dialog)
-    str q="Quality: "
-    import "hboxfield_cnt" hboxfield_cnt
-    sd hbox
-    setcall hbox hboxfield_cnt(vbox)
-    import "labelfield_left_default" labelfield_left_default
-    call labelfield_left_default(q,hbox)
-    #
-    importx "_gtk_hscale_new_with_range" gtk_hscale_new_with_range
-    sd min_d_low
-    sd min_d_high
-    sd max_d_low
-    sd max_d_high
-    sd step_d_low
-    sd step_d_high
-    sd p_min_d^min_d_low
-    sd p_max_d^max_d_low
-    sd p_step_d^step_d_low
-    call int_to_double(1,p_min_d)
-    call int_to_double(900,p_max_d)
-    call int_to_double(100,p_step_d)
-
-    data hscale#1
-    setcall hscale gtk_hscale_new_with_range(min_d_low,min_d_high,max_d_low,max_d_high,step_d_low,step_d_high)
-
-    importx "_gtk_range_set_value" gtk_range_set_value
-    sd currentpos
-    setcall currentpos jpeg_quality((value_get))
-    sd doublepos_low
-    sd doublepos_high
-    sd p_doublepos^doublepos_low
-    call int_to_double(currentpos,p_doublepos)
-    call gtk_range_set_value(hscale,doublepos_low,doublepos_high)
-
-    import "packstart" packstart
-    call packstart(hbox,hscale,(TRUE))
-    #
-    str max="Best"
-    call labelfield_left_default(max,hbox)
-
-    const p_hscale^hscale
-endfunction
-
-function jpeg_settings_set()
-    import "file_write_forward_sys_folder_enter_leave" file_write_forward_sys_folder_enter_leave
-    data forw_jpeg^jpeg_settings_set_write
-    import "jpeg_file" jpeg_file
-    ss jpeg_fl_str
-    setcall jpeg_fl_str jpeg_file()
-    call file_write_forward_sys_folder_enter_leave(jpeg_fl_str,forw_jpeg)
-endfunction
-function jpeg_settings_set_write(sd jpeg_fl)
-    import "hscale_get" hscale_get
-    sd p_hscale%p_hscale
-    sd value
-    setcall value hscale_get(p_hscale#)
-    call jpeg_quality((value_set),value)
-
-    sd p_value^value
-    call file_write(p_value,4,jpeg_fl)
-endfunction
-
-
-#quality
-function jpeg_quality(sd action,sd value)
-    data quality#1
-    if action==(value_set)
-        set quality value
-    else
-        return quality
-    endelse
-endfunction
-
-function jpeg_get_quality(sd mem,sd *size)
-    sd quality
-    sd p_quality^quality
-
-    import "get_mem_int_advance" get_mem_int_advance
-    sd mem_sz^mem
-    sd err
-    setcall err get_mem_int_advance(p_quality,mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    call jpeg_quality((value_set),quality)
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mp4.oc
@@ -0,0 +1,2507 @@
+
+format elfobj
+
+include "../_include/include.h"
+
+import "mp4_sizes" mp4_sizes
+import "mp4_times" mp4_times
+import "mp4_tscale" mp4_tscale
+import "mp4_duration" mp4_duration
+import "mp4_timescale" mp4_timescale
+import "mp4_duration_1000" mp4_duration_1000
+import "mp4_SampleCount" mp4_SampleCount
+
+import "avc_init" avc_init
+import "avc_free" avc_free
+import "avc_ProfileIndication" avc_ProfileIndication
+import "avc_profile_compatibility" avc_profile_compatibility
+import "avc_LevelIndication" avc_LevelIndication
+import "avc_encode" avc_encode
+
+import "mp4_write_expand_set" mp4_write_expand_set
+import "mp4_write_expand_get" mp4_write_expand_get
+#0 is write
+const mp4_write=0
+#1 is expand
+const mp4_expand=1
+import "mp4_sound_presence" mp4_sound_presence
+import "mp4_sound_presence_get" mp4_sound_presence_get
+import "mp4_audio_samples_set" mp4_audio_samples_set
+import "mp4_audio_samples_get" mp4_audio_samples_get
+import "mp4_info_set" mp4_info_set
+import "mp4_info_get" mp4_info_get
+
+import "dialog_modal_texter_draw" dialog_modal_texter_draw
+const videoId=1
+const soundId=2
+const emptyId=3
+
+const enable_flag=1
+const sample_delta=1000
+
+import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
+import "file_write" file_write
+
+import "av_dialog_run" av_dialog_run
+import "av_dialog_close" av_dialog_close
+import "av_dialog_stop" av_dialog_stop
+
+
+
+#importx "_fread" fread
+#importx "_fwrite" fwrite
+#function extragere(ss location)
+#	data extragere_off1#1
+#	const extr_1^extragere_off1
+#	data extragere_off2#1
+#	const extr_2^extragere_off2
+#	sd file
+#	call openfile(#file,location,"rb")
+#	sd mp3_file
+#	call openfile(#mp3_file,"captures/file.mp3","wb")
+#	sd mp3_sz;set mp3_sz extragere_off2;sub mp3_sz extragere_off1
+#	call file_seek_set(file,extragere_off1)
+#	sd mp3Mem;setcall mp3Mem memalloc(mp3_sz)
+#	Call fread(mp3Mem,1,mp3_sz,file)
+#	Call fwrite(mp3Mem,1,mp3_sz,mp3_file)
+#	call fclose(mp3_file)
+#	call fclose(file)
+#endfunction
+
+
+
+
+function mp4_write()
+    call mp4_write_expand_set((mp4_write))
+    ss location
+    import "stage_get_output_container" stage_get_output_container
+    setcall location stage_get_output_container()
+    call av_dialog_run(mp4_dialog,location)
+
+#call extragere(location)
+
+endfunction
+#
+function mp4_filewrite(sd file)
+    sd ebox
+    setcall ebox stage_nthwidgetFromcontainer(0)
+    import "object_get_dword_name" object_get_dword_name
+    sd pixbuf
+    setcall pixbuf object_get_dword_name(ebox)
+    call mp4_container(file,pixbuf)
+endfunction
+
+import "mp3_init" mp3_init
+import "mp3_free" mp3_free
+
+function mp4_container(sd file,sd pixbuf)
+    sd bool
+    setcall bool avc_init(pixbuf)
+    if bool!=1
+        return 0
+    endif
+    setcall bool mp3_init()
+    if bool=1
+        call mp4_file(file,pixbuf)
+        call mp3_free()
+    endif
+    call avc_free()
+endfunction
+
+import "mp4_longest_duration" mp4_longest_duration
+import "mp4_next_track" mp4_next_track
+import "mp4_next_track_set" mp4_next_track_set
+import "mp4_audio_profile" mp4_audio_profile
+import "mp4_audio_profile_set" mp4_audio_profile_set
+
+import "stage_sound_alloc_getremainingsize" stage_sound_alloc_getremainingsize
+import "mp4_all_samples" mp4_all_samples
+import "mp4_sound_duration" mp4_sound_duration
+import "mp4_sample_count" mp4_sample_count
+import "mp4_entrysize_offset" mp4_entrysize_offset
+import "mp4_chunkoff" mp4_chunkoff
+
+function mp4_file(sd file,sd pixbuf)
+    call mp4_SampleCount((value_set))
+    call mp4_sizes((value_set),pixbuf)
+    call mp4_timescale((value_set))
+    call mp4_duration((value_set))
+    call mp4_duration_1000((value_set))
+    sd duration
+    setcall duration mp4_duration((value_get))
+    sd l_duration
+    setcall l_duration mp4_longest_duration()
+    set l_duration# duration
+    call mp4_next_track_set((soundId))
+        #No audio capability required
+    call mp4_audio_profile_set(0xff)
+    sd bool
+    #sound
+    import "stage_sound_sizedone" stage_sound_sizedone
+    call stage_sound_sizedone((value_set),0)
+    sd is_sound_or_is_not
+    setcall is_sound_or_is_not mp4_sound_presence_get()
+    if is_sound_or_is_not=0
+        setcall is_sound_or_is_not stage_sound_alloc_getremainingsize()
+    endif
+    if is_sound_or_is_not!=0
+        sd sz
+        setcall sz stage_sound_alloc_getremainingsize()
+        addcall sz mp4_audio_samples_get()
+        setcall bool mp4_sound_init(sz)
+        if bool!=1
+            return (void)
+        endif
+    endif
+    #
+    setcall bool mp4_start(file)
+    if bool=(TRUE)
+        call mp4_info_set(1)
+    endif
+endfunction
+#bool
+function mp4_start(sd file)
+    sd bool
+    str type="ftyp"
+    data type_fwd^mp4_ftyp
+    setcall bool mp4_piece(file,type,type_fwd)
+    if bool!=1
+        return (FALSE)
+    endif
+    str mov="moov"
+    data mov_fwd^mp4_moov
+    setcall bool mp4_piece(file,mov,mov_fwd)
+    if bool!=1
+        return (FALSE)
+    endif
+    #
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_expand)
+        #at read for expand stop here
+        return (TRUE)
+    endif
+    #
+    str md="mdat"
+    data md_fwd^mp4_mdat
+    setcall bool mp4_piece(file,md,md_fwd)
+    if bool!=1
+        return (FALSE)
+    endif
+    return (TRUE)
+endfunction
+
+#bool
+function mp4_piece(sd file,sd name,sd forward)
+    sd bool
+    setcall bool mp4_content(file,name,forward,0,4,0)
+    return bool
+endfunction
+
+#bool
+function mp4_content(sd file,sd name,sd forward,sd f_data,sd sizefield_bytes,sd substract)
+    sd bool
+    setcall bool mp4_wrap(file,name,forward,f_data,sizefield_bytes,substract,0)
+    return bool
+endfunction
+import "file_read" file_read
+#bool
+function mp4_wrap(sd file,sd name,sv forward,sd f_data,sd sizefield_bytes,sd substract,sd p_SizeOfSample)
+    import "file_tell" file_tell
+    sd err
+    #get the point for calculations
+    sd file_pos_in
+    sd ptr_file_pos_in^file_pos_in
+    setcall err file_tell(file,ptr_file_pos_in)
+    if err!=(noerror)
+        return 0
+    endif
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        sd dummy_size
+        sd dummy^dummy_size
+        setcall err file_write(dummy,sizefield_bytes,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        sd read_size
+        setcall err file_read(#read_size,sizefield_bytes,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+    sd bool
+    if name!=0
+        setcall bool mp4_write_seek(name,4,file)
+        if bool!=(TRUE)
+            return (FALSE)
+        endif
+    endif
+
+    setcall bool forward(file,f_data)
+    if bool!=1
+        return 0
+    endif
+
+    sd arrange_size=1
+    sd count
+    set count sizefield_bytes
+    while count!=4
+        mult arrange_size 0x100
+        inc count
+    endwhile
+
+    if procedure=(mp4_write)
+        sd file_pos_out
+        sd ptr_file_pos_out^file_pos_out
+        setcall err file_tell(file,ptr_file_pos_out)
+        if err!=(noerror)
+            return 0
+        endif
+        import "file_seek_set" file_seek_set
+        import "dword_reverse" dword_reverse
+        sd size
+        sd p_size^size
+        set size file_pos_out
+
+        sub size file_pos_in
+        sub size substract
+        mult size arrange_size
+
+        if p_SizeOfSample!=0
+            set p_SizeOfSample# size
+        endif
+        setcall size dword_reverse(size)
+        setcall err file_seek_set(file,file_pos_in)
+        if err!=(noerror)
+            return 0
+        endif
+        setcall err file_write(p_size,sizefield_bytes,file)
+        if err!=(noerror)
+            return 0
+        endif
+        setcall err file_seek_set(file,file_pos_out)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        setcall read_size dword_reverse(read_size)
+        div read_size arrange_size
+        add read_size substract
+        add read_size file_pos_in
+        setcall err file_seek_set(file,read_size)
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+
+    return 1
+endfunction
+
+#bool
+function mp4_ftyp(sd file)
+const ftyp_start=\
+    char GF_ISOM_BRAND_ISOM={i,s,o,m}
+    char *minorVersion={0,0,0,1}
+    char *brand={i,s,o,m}
+    char *brand_1={a,v,c,_1}
+const ftyp_size=\-ftyp_start
+    data ftyp^GF_ISOM_BRAND_ISOM
+    data ftyp_size=ftyp_size
+
+    sd err
+    setcall err mp4_write_or_no(ftyp,ftyp_size,file)
+    if err!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_moov(sd file)
+    call mp4_times((value_set))
+
+    str hd="mvhd"
+    data hd_fwd^mp4_mvhd
+    sd bool
+    setcall bool mp4_piece(file,hd,hd_fwd)
+    if bool!=1
+        return 0
+    endif
+    str iod="iods"
+    data iod_fwd^mp4_iods
+    setcall bool mp4_piece(file,iod,iod_fwd)
+    if bool!=1
+        return 0
+    endif
+    str trk="trak"
+    data trk_fwd^mp4_trak
+    setcall bool mp4_piece(file,trk,trk_fwd)
+    if bool!=1
+        return 0
+    endif
+
+    #sound
+    sd is_sound_or_is_not
+    setcall is_sound_or_is_not mp4_sound_presence_get()
+    if is_sound_or_is_not!=0
+        str soundtrk="trak"
+        data soundtrk_fwd^mp4_soundtrak
+        setcall bool mp4_piece(file,soundtrk,soundtrk_fwd)
+        if bool!=1
+            return 0
+        endif
+    endif
+    #
+
+    return 1
+endfunction
+
+import "file_seek_cursor" file_seek_cursor
+import "word_reverse" word_reverse
+import "file_get_dword" file_get_dword
+
+#bool
+function mp4_mvhd(sd file)
+const mvhd_start=\
+    #movie header
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    data creationTime#1
+    data *modificationTime#1
+    data timeScale#1
+    data duration#1
+    data preferredRate#1
+    char preferredVolume#2
+    char *reserved={0,0,0,0,0,0,0,0,0,0}
+    data matrixA#1
+    data *matrixB=0
+    data *matrixU=0
+    data *matrixC=0
+    data matrixD#1
+    data *matrixV=0
+    data *matrixX=0
+    data *matrixY=0
+    data matrixW#1
+    data *previewTime=0
+    data *previewDuration=0
+    data *posterTime=0
+    data *selectionTime=0
+    data *selectionDuration=0
+    data *currentTime=0
+const off_to_nexttrack=\-mvhd_start
+    data nextTrackID#1
+const mvhd_size=\-mvhd_start
+    data mvhd^version_u8
+    data mvhd_size=mvhd_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        data times^creationTime
+        call mp4_times((value_get),times)
+        setcall timeScale mp4_tscale((value_get))
+        setcall timeScale dword_reverse(timeScale)
+        #
+        setcall duration mp4_longest_duration()
+        setcall duration dword_reverse(duration#)
+        #
+        setcall preferredRate dword_reverse((2$16))
+        ss vol^preferredVolume
+        call word_reverse((2$8),vol)
+        setcall matrixA dword_reverse((2$16))
+        setcall matrixD dword_reverse((2$16))
+        setcall matrixW dword_reverse((2$30))
+        #
+        sd nexttrack
+        setcall nexttrack mp4_next_track()
+        setcall nextTrackID dword_reverse(nexttrack#)
+
+        sd err
+        setcall err file_write(mvhd,mvhd_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        setcall err file_seek_cursor(file,(off_to_nexttrack))
+        if err!=(noerror)
+            return 0
+        endif
+        setcall err file_get_dword(file,#nextTrackID)
+        if err!=(noerror)
+            return 0
+        endif
+    endelse
+    #back to little endian
+    setcall nextTrackID dword_reverse(nextTrackID)
+    if nextTrackID>(soundId)
+        #incrementation because one or two calls means sound and zero means no sound
+        sd presence
+        setcall presence mp4_sound_presence()
+        inc presence#
+    endif
+
+    return 1
+endfunction
+
+#bool
+function mp4_iods(sd file)
+    #InitialObjectDescriptor
+    const GF_ODF_ISOM_IOD_TAG=0x10
+    const iod_objectDescriptorId=1
+    const iod_URLFlag=0
+    const iod_inlineProfileFlag=0
+    const iod_reserved=0xf
+
+    char version=0
+    char *flags={0,0,0}
+
+    char *tag=GF_ODF_ISOM_IOD_TAG
+    char *tag_size=7
+    char iod_attr_data#2
+    char *OD_profileAndLevel=0xff
+    char *scene_profileAndLevel=0xff
+    char audio_profileAndLevel#1
+    #AVC/H264 Profile
+    char *visual_profileAndLevel=0x15
+    char *graphics_profileAndLevel=0xff
+
+    data iod^version
+    data _iod^iod
+    data iod_size#1
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        set iod_size _iod
+        sub iod_size iod
+
+        sd data=iod_reserved
+        sd mover=0x10
+        sd concat
+
+        set concat (iod_inlineProfileFlag)
+        mult concat mover
+        or data concat
+        mult mover 2
+
+        set concat (iod_URLFlag)
+        mult concat mover
+        or data concat
+        mult mover 2
+
+        set concat (iod_objectDescriptorId)
+        mult concat mover
+        or data concat
+
+        str iod_attr^iod_attr_data
+        call word_reverse(data,iod_attr)
+
+        ss profile
+        setcall profile mp4_audio_profile()
+        set audio_profileAndLevel profile#
+
+        sd err
+        setcall err file_write(iod,iod_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+
+    return 1
+endfunction
+
+#bool
+function mp4_trak(sd file)
+    sd bool
+
+    str tkh="tkhd"
+    data tkh_fwd^mp4_tkhd
+    setcall bool mp4_piece(file,tkh,tkh_fwd)
+    if bool!=1
+        return 0
+    endif
+    str md="mdia"
+    data md_fwd^mp4_mdia
+    setcall bool mp4_piece(file,md,md_fwd)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_tkhd(sd file)
+    char version_u8={0}
+    char *flags_u24={0,0,enable_flag}
+    data creationTime#1
+    data *modificationTime#1
+    char *trackID={0,0,0,videoId}
+    data *reserved1=0
+    data duration#1
+    data *reserved2={0,0}
+    char *layer={0,0}
+    char *alternate_group={0,0}
+    char *volume={0,0}
+    char *reserved3={0,0}
+    char *matrix0={0,1,0,0}
+    data *matrix1=0
+    data *matrix2=0
+    data *matrix3=0
+    char *matrix4={0,1,0,0}
+    data *matrix5=0
+    data *matrix6=0
+    data *matrix7=0
+    char *matrix8={0x40,0,0,0}
+    data width#1
+    data height#1
+
+    data tkhd^version_u8
+    data _tkhd^tkhd
+    data tkhd_size#1
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        set tkhd_size _tkhd
+        sub tkhd_size tkhd
+
+        data tm^creationTime
+        call mp4_times((value_get),tm)
+        setcall duration mp4_duration((value_get))
+        setcall duration dword_reverse(duration)
+        sd wh^width
+        call mp4_sizes((value_get),wh)
+        mult width 0x10000
+        mult height 0x10000
+        setcall width dword_reverse(width)
+        setcall height dword_reverse(height)
+
+        sd err
+        setcall err file_write(tkhd,tkhd_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_mdia(sd file)
+    sd bool
+
+    str mhd="mdhd"
+    data mhd_fwd^mp4_mdhd
+    setcall bool mp4_piece(file,mhd,mhd_fwd)
+    if bool!=1
+        return 0
+    endif
+    str hdl="hdlr"
+    data hdl_fwd^mp4_hdlr
+    setcall bool mp4_piece(file,hdl,hdl_fwd)
+    if bool!=1
+        return 0
+    endif
+    str mi="minf"
+    data mi_fwd^mp4_minf
+    setcall bool mp4_piece(file,mi,mi_fwd)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_mdhd(sd file)
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    data creationTime#1
+    data *modificationTime#1
+    data timeScale#1
+    data duration#1
+    char language#2
+    char *reserved={0,0}
+
+    data mdhd^version_u8
+    data _mdhd^mdhd
+    data mdhd_size#1
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        set mdhd_size _mdhd
+        sub mdhd_size mdhd
+
+        sd times^creationTime
+        call mp4_times((value_get),times)
+
+        setcall timeScale mp4_timescale((value_get))
+        setcall timeScale dword_reverse(timeScale)
+        setcall duration mp4_duration_1000((value_get))
+        setcall duration dword_reverse(duration)
+
+        data lang_str^language
+        call mp4_set_language(lang_str)
+
+        sd err
+        setcall err file_write(mdhd,mdhd_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+function mp4_set_language(sd pword)
+    sd word=0
+    sd aux
+    ss lang="und"
+    sd mover=0x8000
+    #SPECS: BIT(1) of padding
+
+    set aux lang#
+    sub aux 0x60
+    div mover (2$5)
+    mult aux mover
+    or word aux
+
+    inc lang
+    set aux lang#
+    sub aux 0x60
+    div mover (2$5)
+    mult aux mover
+    or word aux
+
+    inc lang
+    set aux lang#
+    sub aux 0x60
+    div mover (2$5)
+    mult aux mover
+    or word aux
+
+    call word_reverse(word,pword)
+endfunction
+
+#bool
+function mp4_hdlr(sd file)
+const hdlr_start=\
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    data *reserved1=0
+    char *handlerType={v,i,d,e}
+    char *reserved2={0,0,0,0,0,0,0,0,0,0,0,0}
+    #is null terminated
+    #char *nameUTF8="GPAC ISO Video Handler"
+    char *nameUTF8="OApplications Video"
+const hdlr_size=\-hdlr_start
+    data hdlr^version_u8
+    data hdlr_size=hdlr_size
+
+    sd err
+    setcall err mp4_write_or_no(hdlr,hdlr_size,file)
+    if err!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_minf(sd file)
+    sd bool
+
+    str vhd="vmhd"
+    data vhd_fwd^mp4_vmhd
+    setcall bool mp4_piece(file,vhd,vhd_fwd)
+    if bool!=1
+        return 0
+    endif
+    #data info
+    str di="dinf"
+    data di_fwd^mp4_dinf
+    setcall bool mp4_piece(file,di,di_fwd)
+    if bool!=1
+        return 0
+    endif
+    #sample table
+    str stb="stbl"
+    data stb_fwd^mp4_stbl
+    setcall bool mp4_piece(file,stb,stb_fwd)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_vmhd(sd file)
+    char version_u8={0}
+    char *flags_u24={0,0,enable_flag}
+    char *reserved={0,0,0,0,0,0,0,0}
+
+    data vmhd^version_u8
+    data _vmhd^vmhd
+    data vmhd_size#1
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        set vmhd_size _vmhd
+        sub vmhd_size vmhd
+
+        sd err
+        setcall err file_write(vmhd,vmhd_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_dinf(sd file)
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        sd bool
+        str drf="dref"
+        data drf_fwd^mp4_dref
+        setcall bool mp4_piece(file,drf,drf_fwd)
+        if bool!=1
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_dref(sd file)
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    char *count={0,0,0,1}
+
+    data dref^version_u8
+    data _dref^dref
+    data dref_size#1
+    set dref_size _dref
+    sub dref_size dref
+
+    sd err
+    setcall err file_write(dref,dref_size,file)
+    if err!=(noerror)
+        return 0
+    endif
+
+    sd bool
+    str url="url "
+    data url_fwd^mp4_url
+    setcall bool mp4_piece(file,url,url_fwd)
+    if bool!=1
+        return 0
+    endif
+
+    return 1
+endfunction
+
+#bool
+function mp4_url(sd file)
+    char version_u8={0}
+    char *flags_u24={0,0,enable_flag}
+
+    data url^version_u8
+    data _url^url
+    data url_size#1
+    set url_size _url
+    sub url_size url
+
+    sd err
+    setcall err file_write(url,url_size,file)
+    if err!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_stbl(sd file)
+    sd bool
+    #sample description
+    str sd="stsd"
+    data sd_fwd^mp4_stsd
+    setcall bool mp4_piece(file,sd,sd_fwd)
+    if bool!=1
+        return 0
+    endif
+    #time scale
+    str ts="stts"
+    data ts_fwd^mp4_stts
+    setcall bool mp4_piece(file,ts,ts_fwd)
+    if bool!=1
+        return 0
+    endif
+    #sync sample
+    str ss="stss"
+    data ss_fwd^mp4_stss
+    setcall bool mp4_piece(file,ss,ss_fwd)
+    if bool!=1
+        return 0
+    endif
+    #sample to chunk
+    str sc="stsc"
+    data sc_fwd^mp4_stsc
+    setcall bool mp4_piece(file,sc,sc_fwd)
+    if bool!=1
+        return 0
+    endif
+    #sample size
+    str sz="stsz"
+    data sz_fwd^mp4_stsz
+    setcall bool mp4_piece(file,sz,sz_fwd)
+    if bool!=1
+        return 0
+    endif
+    #chunk offset
+    str co="stco"
+    data co_fwd^mp4_stco
+    setcall bool mp4_piece(file,co,co_fwd)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_stsd(sd file)
+const stsd_start=\
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    char *entryCount={0,0,0,1}
+const stsd_size=\-stsd_start
+    data stsd^version_u8
+    data stsd_size=stsd_size
+
+    sd bool
+    setcall bool mp4_write_seek(stsd,stsd_size,file)
+    if bool!=1
+        return 0
+    endif
+
+    str avc="avc1"
+    data avc_fwd^mp4_avc1
+    setcall bool mp4_piece(file,avc,avc_fwd)
+    if bool!=1
+        return 0
+    endif
+
+    return 1
+endfunction
+
+#bool
+function mp4_avc1(sd file)
+const avc1_start=\
+    char reserved={0,0,0,0,0,0}
+    char *dataReferenceIndex={0,videoId}
+    char *version={0,0}
+    char *revision={0,0}
+    data *vendor=0
+    data *temporal_quality=0
+    data *spacial_quality=0
+    char Width#2
+    char Height#2
+    char *horiz_res={0,0x48,0,0}
+    char *vert_res={0,0x48,0,0}
+    data *entry_data_size=0
+    char *frames_per_sample={0,1}
+    char *compressor_name={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
+    char *bit_depth={0,0x18}
+    char color_table_index#2
+const avc1_size=\-avc1_start
+    data avc1^reserved
+    data avc1_size=avc1_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        sd w
+        sd h
+        sd wh^w
+        call mp4_sizes((value_get),wh)
+        sd W^Width
+        sd H^Height
+        call word_reverse(w,W)
+        call word_reverse(h,H)
+        sd cti^color_table_index
+        call word_reverse(-1,cti)
+    endif
+
+    sd bool
+    setcall bool mp4_write_seek(avc1,avc1_size,file)
+    if bool!=1
+        return 0
+    endif
+
+    #avc_config
+    str avC="avcC"
+    data avC_fwd^mp4_avcC
+    setcall bool mp4_piece(file,avC,avC_fwd)
+    if bool!=1
+        return 0
+    endif
+    #bitrate
+    str br="btrt"
+    data br_fwd^mp4_btrt
+    setcall bool mp4_piece(file,br,br_fwd)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_avcC(sd file)
+const avcC_start=\
+    char configurationVersion=1
+    char AVCProfileIndication#1
+    char profile_compatibility#1
+    char AVCLevelIndication#1
+    char cfg_data#2
+const avcC_size=\-avcC_start
+    data avcfg_main^configurationVersion
+    data avcfg_main_size=avcC_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        setcall AVCProfileIndication avc_ProfileIndication((value_get))
+        setcall profile_compatibility avc_profile_compatibility((value_get))
+        setcall AVCLevelIndication avc_LevelIndication((value_get))
+
+        sd word=0
+        sd aux
+        sd mover=0x10000
+
+        set aux 0x3f
+        div mover (2$6)
+        mult aux mover
+        or word aux
+
+        sd nal_unit_size=4
+        sub nal_unit_size 1
+        div mover (2$2)
+        mult nal_unit_size mover
+        or word nal_unit_size
+
+        set aux 0x7
+        div mover (2$3)
+        mult aux mover
+        or word aux
+
+        sd list_count=1
+        or word list_count
+
+        sd cfg_d^cfg_data
+        call word_reverse(word,cfg_d)
+
+        sd err
+        sd bool
+        #
+        setcall err file_write(avcfg_main,avcfg_main_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+        #
+        data avc_fn^avc_encode
+        setcall bool mp4_content(file,0,avc_fn,(avc_sequence_param),2,2)
+        if bool!=1
+            return 0
+        endif
+        #
+        char count=1
+        sd p_count^count
+        setcall err file_write(p_count,1,file)
+        if err!=(noerror)
+            return 0
+        endif
+        #
+        setcall bool mp4_content(file,0,avc_fn,(avc_picture_param),2,2)
+        if bool!=1
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+import "mp4_bufferSzOffset" mp4_bufferSzOffset
+import "mp4_avgbitrateOffset" mp4_avgbitrateOffset
+
+import "mp4_video_bufferSz_set" mp4_video_bufferSz_set
+import "mp4_video_bufferSz_get" mp4_video_bufferSz_get
+
+#bool
+function mp4_btrt(sd file)
+const btrt_start=\
+    data bufferSizeDB#1
+    data *maxBitrate=0
+    data *avgBitrate#1
+const btrt_size=\-btrt_start
+    data btrt^bufferSizeDB
+    data btrt_size=btrt_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        sd file_pos
+        sd ptr_file_pos^file_pos
+        sd err
+        setcall err file_tell(file,ptr_file_pos)
+        if err!=(noerror)
+            return 0
+        endif
+        call mp4_bufferSzOffset((value_set),file_pos)
+        add file_pos 8
+        call mp4_avgbitrateOffset((value_set),file_pos)
+
+        setcall err file_write(btrt,btrt_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        setcall err file_get_dword(file,#bufferSizeDB)
+        if err!=(noerror)
+            return 0
+        endif
+        setcall bufferSizeDB dword_reverse(bufferSizeDB)
+        call mp4_video_bufferSz_set(bufferSizeDB)
+    endelse
+    return 1
+endfunction
+
+import "mp4_video_samples_set" mp4_video_samples_set
+import "mp4_video_samples_get" mp4_video_samples_get
+import "file_seek_cursor_get_dword_reverse" file_seek_cursor_get_dword_reverse
+
+#bool
+function mp4_stts(sd file)
+const mp4_stts_start=\
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    char *list_count={0,0,0,1}
+const mp4_stts_sampleCount_offset=\-mp4_stts_start
+    data sampleCount#1
+    data sampleDelta#1
+const mp4_stts_size=\-mp4_stts_start
+
+    data stts^version_u8
+    data stts_size=mp4_stts_size
+
+    sd err
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        setcall sampleCount mp4_SampleCount((value_get))
+        setcall sampleCount dword_reverse(sampleCount)
+        setcall sampleDelta dword_reverse((sample_delta))
+
+        setcall err file_write(stts,stts_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        setcall err file_seek_cursor_get_dword_reverse(file,(mp4_stts_sampleCount_offset),#sampleCount)
+        if err!=(noerror)
+            return 0
+        endif
+        call mp4_video_samples_set(sampleCount)
+    endelse
+
+    return 1
+endfunction
+
+#bool
+function mp4_stss(sd file)
+const stss_start=\
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    char *entryCount={0,0,0,1}
+    char *sampleNumber={0,0,0,1}
+const stss_size=\-stss_start
+    data stss^version_u8
+    data stss_size=stss_size
+
+    sd err
+    setcall err mp4_write_or_no(stss,stss_size,file)
+    if err!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_stsc(sd file)
+const stsc_start=\
+    char version={0}
+    char *flags={0,0,0}
+    char *list_count={0,0,0,1}
+    char *firstChunk={0,0,0,1}
+    data samplesPerChunk#1
+    char *sampleDescriptionIndex={0,0,0,1}
+const stsc_size=\-stsc_start
+    data stsc^version
+    data stsc_size=stsc_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        setcall samplesPerChunk mp4_SampleCount((value_get))
+        setcall samplesPerChunk dword_reverse(samplesPerChunk)
+
+        sd err
+        setcall err file_write(stsc,stsc_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_stsz(sd file)
+const stsz_start=\
+    char version={0}
+    char *flags={0,0,0}
+    data *sampleSize=0
+    data sampleCount#1
+const stsz_size=\-stsz_start
+    data stsz^version
+    data stsz_size=stsz_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        sd NrOfSamples
+        setcall NrOfSamples mp4_SampleCount((value_write))
+        setcall sampleCount dword_reverse(NrOfSamples)
+
+        sd err
+        setcall err file_write(stsz,stsz_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+
+        import "mp4_samplesOffset" mp4_samplesOffset
+        sd file_pos
+        sd ptr_file_pos^file_pos
+        setcall err file_tell(file,ptr_file_pos)
+        if err!=(noerror)
+            return 0
+        endif
+        call mp4_samplesOffset((value_set),file_pos)
+        sd dummy_data
+        sd dummy^dummy_data
+        while NrOfSamples!=0
+            setcall err file_write(dummy,4,file)
+            if err!=(noerror)
+                return 0
+            endif
+            dec NrOfSamples
+        endwhile
+    endif
+    return 1
+endfunction
+import "mp4_video_offset_set" mp4_video_offset_set
+import "mp4_video_offset_get" mp4_video_offset_get
+#bool
+function mp4_stco(sd file)
+const stco_start=\
+    char version={0}
+    char *flags={0,0,0}
+    char *entries={0,0,0,1}
+const stco_offset_pos=\-stco_start
+    data offset#1
+const stco_size=\-stco_start
+    data stco^version
+    data stco_size=stco_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        import "mp4_chunksOffset" mp4_chunksOffset
+        sd file_pos
+        sd ptr_file_pos^file_pos
+        sd err
+        setcall err file_tell(file,ptr_file_pos)
+        if err!=(noerror)
+            return 0
+        endif
+        add file_pos 8
+        call mp4_chunksOffset((value_set),file_pos)
+
+        setcall err file_write(stco,stco_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        setcall err file_seek_cursor_get_dword_reverse(file,(stco_offset_pos),#offset)
+        if err!=(noerror)
+            return 0
+        endif
+        call mp4_video_offset_set(offset)
+    endelse
+    return 1
+endfunction
+
+import "memalloc" memalloc
+importx "_free" free
+import "texter" texter
+
+import "mp4_expand_startfile_set" mp4_expand_startfile_set
+import "mp4_expand_startfile_get" mp4_expand_startfile_get
+
+import "file_seekSet_setDwRev_goEnd" file_seekSet_setDwRev_goEnd
+
+#bool
+function mp4_mdat(sd file)
+
+#data off1%extr_1
+#call file_tell(file,off1)
+
+    sd bool
+    setcall bool mp4_mdat_sound(file)
+    if bool!=1
+        return 0
+    endif
+
+    #get chunk offset
+    sd ch_off
+    setcall ch_off mp4_chunksOffset((value_get))
+    sd file_pos
+    sd ptr_file_pos^file_pos
+    sd err
+    setcall err file_tell(file,ptr_file_pos)
+    if err!=(noerror)
+        return 0
+    endif
+    setcall bool file_seekSet_setDwRev_goEnd(file,ch_off,file_pos)
+    if bool!=(TRUE)
+        return (FALSE)
+    endif
+
+#data off2%extr_2
+#set off2# file_pos
+
+    #
+    sd all_size_of_sample
+    sd p_all_size_of_sample^all_size_of_sample
+    #
+    sd sz_off
+    setcall sz_off mp4_samplesOffset((value_get))
+    #
+    sd size_of_sample
+    sd p_size_of_sample^size_of_sample
+    #
+    sd max_size
+    setcall max_size mp4_video_bufferSz_get()
+    #
+    sd all_size=0
+
+    const chunk_size_sz=4
+
+    data avc_fn^avc_encode
+    setcall bool mp4_wrap(file,0,avc_fn,(avc_frame0_headers),(chunk_size_sz),(chunk_size_sz),p_all_size_of_sample)
+    if bool!=1
+        return 0
+    endif
+    add all_size_of_sample (chunk_size_sz)
+
+    sd force_start_encode=30
+
+    #can be expand
+    sd off_v
+    setcall off_v mp4_video_offset_get()
+    if off_v!=0
+        sd ex_file
+        setcall ex_file mp4_expand_startfile_get()
+        setcall err file_seek_set(ex_file,off_v)
+        if err!=(noerror)
+            return 0
+        endif
+        #skip header
+        import "file_get_dword_reverse" file_get_dword_reverse
+        setcall err file_get_dword_reverse(ex_file,p_size_of_sample)
+        if err!=(noerror)
+            return 0
+        endif
+        setcall err file_seek_cursor(ex_file,size_of_sample)
+        if err!=(noerror)
+            return 0
+        endif
+        #
+        sd mem
+        setcall mem memalloc(max_size)
+        if mem=0
+            return 0
+        endif
+        sd ex_samples
+        setcall ex_samples mp4_video_samples_get()
+        while ex_samples!=0
+            #
+            setcall err file_get_dword_reverse(ex_file,p_size_of_sample)
+            if err!=(noerror)
+                call free(mem)
+                return 0
+            endif
+            sd sz
+            setcall sz dword_reverse(size_of_sample)
+            setcall err file_write(#sz,(chunk_size_sz),file)
+            if err!=(noerror)
+                call free(mem)
+                return 0
+            endif
+            if max_size<size_of_sample
+                call texter("error at expand video")
+                call free(mem)
+                return 0
+            endif
+            setcall err file_read(mem,size_of_sample,ex_file)
+            if err!=(noerror)
+                call free(mem)
+                return 0
+            endif
+            setcall err file_write(mem,size_of_sample,file)
+            if err!=(noerror)
+                call free(mem)
+                return 0
+            endif
+            #
+            add size_of_sample (chunk_size_sz)
+            setcall bool mp4_avc_loop_sizes(file,size_of_sample,p_all_size_of_sample,#sz_off,#max_size,#all_size)
+            if bool!=1
+                call free(mem)
+                return 0
+            endif
+            dec ex_samples
+        endwhile
+        call free(mem)
+        set force_start_encode 0
+    endif
+
+    #
+    import "stage_get_frames" stage_get_frames
+    sd current_frame=0
+    sd f_size=-1
+    sd number_of_slices
+    setcall number_of_slices stage_get_frames()
+    sd current_slice=0
+    while current_slice!=number_of_slices
+        sd encode_slice
+        if f_size<0
+            set encode_slice current_slice
+        elseif current_frame>force_start_encode
+            set encode_slice -1
+        else
+        #at fixed frame rate we use zero length frames at this version
+        #some players may skip the start frame (frames?), encode at the beginning as p_skip
+            set encode_slice current_slice
+        endelse
+        data fn^mp4_avc
+        setcall bool mp4_wrap(file,0,fn,encode_slice,(chunk_size_sz),(chunk_size_sz),p_size_of_sample)
+        if bool!=1
+            return 0
+        endif
+        add size_of_sample (chunk_size_sz)
+        setcall bool mp4_avc_loop_sizes(file,size_of_sample,p_all_size_of_sample,#sz_off,#max_size,#all_size)
+        if bool!=1
+            return 0
+        endif
+        if f_size<0
+            import "stage_frame_time_numbers" stage_frame_time_numbers
+            setcall f_size stage_frame_time_numbers((stage_frame_time_get_at_index),encode_slice)
+        endif
+        dec f_size
+        if f_size=0
+            set f_size -1
+            inc current_slice
+        endif
+        inc current_frame
+    endwhile
+
+    #max buffer
+    sd bf_offset
+    setcall bf_offset mp4_bufferSzOffset((value_get))
+    setcall bool file_seekSet_setDwRev_goEnd(file,bf_offset,max_size)
+    if bool=0
+        return 0
+    endif
+    #average bit rate
+    import "int_to_double" int_to_double
+    import "double_div" double_div
+    import "double_to_int" double_to_int
+    sd avgBitrate
+    set avgBitrate all_size
+    sd br_double#2
+    sd br^br_double
+    sd tscale_double#2
+    sd tscale^tscale_double
+    sd avgb_double#2
+    sd avgb^avgb_double
+    sd value
+    setcall value mp4_timescale((value_get))
+    sd len
+    setcall len mp4_SampleCount((value_get))
+    mult len (sample_delta)
+    call int_to_double(len,br)
+    call int_to_double(value,tscale)
+    call double_div(br,tscale)
+    call int_to_double(avgBitrate,avgb)
+    call double_div(avgb,br)
+    setcall avgBitrate double_to_int(avgb)
+    mult avgBitrate 8
+    sd avg_off
+    setcall avg_off mp4_avgbitrateOffset((value_get))
+    setcall bool file_seekSet_setDwRev_goEnd(file,avg_off,avgBitrate)
+    if bool!=1
+        return 0
+    endif
+    #avgBitrate = (u32) ((Double) (s64)avg_rate / br)
+    #avgBitrate *= 8
+    return 1
+endfunction
+
+#bool
+function mp4_avc_loop_sizes(sd file,sd size_of_sample,sd p_all_size_of_sample,sd p_sz_off,sd p_max_size,sd p_all_size)
+    #all_size_of_sample is needed at start when we have the header included in the first frame
+    add p_all_size_of_sample# size_of_sample
+    if p_all_size_of_sample#>p_max_size#
+        #about max buffer size
+        set p_max_size# p_all_size_of_sample#
+    endif
+    #about average bit rate
+    add p_all_size# p_all_size_of_sample#
+    #add at stsz
+    sd bool
+    setcall bool file_seekSet_setDwRev_goEnd(file,p_sz_off#,p_all_size_of_sample#)
+    if bool!=(TRUE)
+        return (FALSE)
+    endif
+    #next offset at stsz
+    add p_sz_off# 4
+    #
+    set p_all_size_of_sample# 0
+    return (TRUE)
+endfunction
+
+#bool
+function mp4_avc(sd file,sd current_slice)
+    sd stop
+    setcall stop av_dialog_stop((value_get))
+    if stop=1
+        return 0
+    endif
+    if current_slice<0
+        return 1
+    endif
+    #
+    import "av_display_info" av_display_info
+    call av_display_info((value_get),file)
+    #
+    sd bool
+    sd eventbox
+    setcall eventbox stage_nthwidgetFromcontainer(current_slice)
+    sd pixbuf
+    setcall pixbuf object_get_dword_name(eventbox)
+    setcall bool avc_encode(file,(avc_frame),pixbuf)
+    if bool!=1
+        return 0
+    endif
+    #info display
+    import "av_display_info_progress" av_display_info_progress
+    call av_display_info_progress(file,current_slice)
+    #
+    return 1
+endfunction
+
+#sound
+import "mp4_audio_offset_set" mp4_audio_offset_set
+import "mp4_audio_offset_get" mp4_audio_offset_get
+import "mp4_audio_bufferSz_set" mp4_audio_bufferSz_set
+import "mp4_audio_bufferSz_get" mp4_audio_bufferSz_get
+import "mp4_audio_maxBitrate_set" mp4_audio_maxBitrate_set
+import "mp4_audio_maxBitrate_get" mp4_audio_maxBitrate_get
+
+#bool
+function mp4_mdat_sound(sd file)
+    sd bool
+    sd err
+    sd file_pos
+    sd ptr_file_pos^file_pos
+
+    #sound
+    import "mp3_encode" mp3_encode
+    sd is_sound_or_is_not
+    setcall is_sound_or_is_not mp4_sound_presence_get()
+    if is_sound_or_is_not!=0
+        sd off
+        #sound offset
+        setcall off mp4_chunkoff()
+        setcall err file_tell(file,ptr_file_pos)
+        if err!=(noerror)
+            return 0
+        endif
+        #
+        setcall bool file_seekSet_setDwRev_goEnd(file,off#,file_pos)
+        if bool!=1
+            return 0
+        endif
+        #
+        sd sound_size=0
+        sd p_sound_size^sound_size
+        #can be expand
+        sd off_a
+        setcall off_a mp4_audio_offset_get()
+        if off_a!=0
+            sd off_v
+            setcall off_v mp4_video_offset_get()
+            if off_v!=0
+                set sound_size off_v
+                sub sound_size off_a
+                sd ex_file
+                setcall ex_file mp4_expand_startfile_get()
+                setcall err file_seek_set(ex_file,off_a)
+                if err!=(noerror)
+                    return 0
+                endif
+                sd mem
+                setcall mem memalloc(sound_size)
+                if mem=0
+                    call free(mem)
+                    return 0
+                endif
+                setcall err file_read(mem,sound_size,ex_file)
+                if err!=(noerror)
+                    call free(mem)
+                    return 0
+                endif
+                setcall err file_write(mem,sound_size,file)
+                if err!=(noerror)
+                    call free(mem)
+                    return 0
+                endif
+                call free(mem)
+            endif
+        endif
+        #
+        sd max_sound_size
+        setcall max_sound_size mp4_audio_bufferSz_get()
+        #
+        sd all_sound_size
+        set all_sound_size sound_size
+        #
+        #sd count=0
+        sd rate=0
+        #
+        sd max_rate
+        setcall max_rate mp4_audio_maxBitrate_get()
+        #
+        sd timescale=mp3_samplerate
+        sd samples=0
+        sd loop=1
+        while loop=1
+            sd stop_question
+            setcall stop_question av_dialog_stop((value_get))
+            if stop_question=1
+                return 0
+            endif
+            setcall err file_tell(file,ptr_file_pos)
+            if err!=(noerror)
+                return 0
+            endif
+            setcall bool mp3_encode(file)
+            if bool!=1
+                return 0
+            endif
+            setcall err file_tell(file,p_sound_size)
+            if err!=(noerror)
+                return 0
+            endif
+            sub sound_size file_pos
+            if max_sound_size<sound_size
+                set max_sound_size sound_size
+            endif
+            #inc count
+            add rate sound_size
+            add samples (samp_per_frame)
+            add all_sound_size sound_size
+            if samples>=timescale
+                if max_rate<rate
+                    set max_rate rate
+                endif
+                set samples 0
+                set rate 0
+            endif
+            #
+            importx "_sprintf" sprintf
+            sd bytesleft
+            setcall bytesleft stage_sound_alloc_getremainingsize()
+            const soundbufstart=\
+            char format="Sound Bytes Left: %u"
+            char buffer#\-soundbufstart-2+dword_max
+            vstr buf^buffer
+            call sprintf(buf,#format,bytesleft)
+            call dialog_modal_texter_draw(buf)
+            #
+            import "mp3_encode_test" mp3_encode_test
+            setcall loop mp3_encode_test()
+        endwhile
+        #at stsz
+        setcall off mp4_entrysize_offset()
+        setcall bool file_seekSet_setDwRev_goEnd(file,off#,max_sound_size)
+        if bool!=1
+            return 0
+        endif
+        #move to esds
+        sd esds_offsets
+        setcall esds_offsets mp4_sound_esds_items_offset()
+        setcall err file_seek_set(file,esds_offsets#)
+        if err!=(noerror)
+            return 0
+        endif
+        #bufferSizeDB
+        mult max_sound_size 0x100
+        setcall max_sound_size dword_reverse(max_sound_size)
+        sd p_max^max_sound_size
+        setcall err file_write(p_max,3,file)
+        if err!=(noerror)
+            return 0
+        endif
+        #maxBitrate
+        sd maxBitrate
+        sd p_maxBitrate^maxBitrate
+        set maxBitrate max_rate
+        mult maxBitrate 8
+        setcall maxBitrate dword_reverse(maxBitrate)
+        setcall err file_write(p_maxBitrate,4,file)
+        if err!=(noerror)
+            return 0
+        endif
+        #avgBitrate
+        import "fild_value" fild_value
+        import "fstp_quad" fstp_quad
+        import "fdiv_quad" fdiv_quad
+        import "fistp" fistp
+        call fild_value(all_sound_size)
+        sd all_samples
+        setcall all_samples mp4_all_samples()
+        call fild_value(all_samples#)
+        data double_data#2
+        data double^double_data
+        call fild_value(timescale)
+        call fstp_quad(double)
+        call fdiv_quad(double)
+        call fstp_quad(double)
+        call fdiv_quad(double)
+        data sound_avgBitrate#1
+        data p_sound_avgBitrate^sound_avgBitrate
+        call fistp(p_sound_avgBitrate)
+        mult sound_avgBitrate 8
+        setcall sound_avgBitrate dword_reverse(sound_avgBitrate)
+        setcall err file_write(p_sound_avgBitrate,4,file)
+        if err!=(noerror)
+            return 0
+        endif
+        #
+        import "file_seek_end" file_seek_end
+        setcall err file_seek_end(file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+
+    return 1
+endfunction
+
+#bool
+function mp4_soundtrak(sd file)
+    sd bool
+    str tkh="tkhd"
+    data tkh_fwd^mp4_soundtkhd
+    setcall bool mp4_piece(file,tkh,tkh_fwd)
+    if bool!=1
+        return 0
+    endif
+    str md="mdia"
+    data md_fwd^mp4_soundmdia
+    setcall bool mp4_piece(file,md,md_fwd)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_soundtkhd(sd file)
+const soundtkhd_start=\
+    char version_u8={0}
+    char *flags_u24={0,0,enable_flag}
+    data creationTime#1
+    data *modificationTime#1
+    char *trackID={0,0,0,soundId}
+    data *reserved1=0
+    data duration#1
+    data *reserved2={0,0}
+    char *layer={0,0}
+    char *alternate_group={0,0}
+    char *volume={1,0}
+    char *reserved3={0,0}
+    char *matrix0={0,1,0,0}
+    data *matrix1=0
+    data *matrix2=0
+    data *matrix3=0
+    char *matrix4={0,1,0,0}
+    data *matrix5=0
+    data *matrix6=0
+    data *matrix7=0
+    char *matrix8={0x40,0,0,0}
+    data *width=0
+    data *height=0
+const soundtkhd_size=\-soundtkhd_start
+    data tkhd^version_u8
+    data tkhd_size=soundtkhd_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        data tm^creationTime
+        call mp4_times((value_get),tm)
+        setcall duration mp4_sound_duration()
+        set duration duration#
+
+        sd err
+        setcall err file_write(tkhd,tkhd_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_soundmdia(sd file)
+    sd bool
+
+    str mhd="mdhd"
+    data mhd_fwd^mp4_soundmdhd
+    setcall bool mp4_piece(file,mhd,mhd_fwd)
+    if bool!=1
+        return 0
+    endif
+    str hdl="hdlr"
+    data hdl_fwd^mp4_soundhdlr
+    setcall bool mp4_piece(file,hdl,hdl_fwd)
+    if bool!=1
+        return 0
+    endif
+    str mi="minf"
+    data mi_fwd^mp4_soundminf
+    setcall bool mp4_piece(file,mi,mi_fwd)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_soundmdhd(sd file)
+const soundmdhd_start=\
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    data creationTime#1
+    data *modificationTime#1
+    data timeScale#1
+const soundmdhd_duration=\-soundmdhd_start
+    data duration#1
+    char language#2
+    char *reserved={0,0}
+const soundmdhd_size=\-soundmdhd_start
+    data mdhd^version_u8
+    data mdhd_size=soundmdhd_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        sd times^creationTime
+        call mp4_times((value_get),times)
+        set timeScale (mp3_samplerate)
+        setcall timeScale dword_reverse(timeScale)
+        setcall duration mp4_all_samples()
+        setcall duration dword_reverse(duration#)
+        data lang_str^language
+        call mp4_set_language(lang_str)
+        sd err
+        setcall err file_write(mdhd,mdhd_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        setcall err file_seek_cursor_get_dword_reverse(file,(soundmdhd_duration),#duration)
+        if err!=(noerror)
+            return 0
+        endif
+        mult duration (mp3_blockalign)
+        call mp4_audio_samples_set(duration)
+    endelse
+    return 1
+endfunction
+
+#bool
+function mp4_soundhdlr(sd file)
+const soundhdlr_start=\
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    data *reserved1=0
+    char *handlerType={s,o,u,n}
+    char *reserved2={0,0,0,0,0,0,0,0,0,0,0,0}
+    #is null terminated
+    #char *nameUTF8="GPAC ISO Audio Handler"
+    char *nameUTF8="OApplications Audio"
+const soundhdlr_size=\-soundhdlr_start
+    data hdlr^version_u8
+    data hdlr_size=soundhdlr_size
+
+    sd err
+    setcall err mp4_write_or_no(hdlr,hdlr_size,file)
+    if err!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_soundminf(sd file)
+    sd bool
+    str shd="smhd"
+    data shd_fwd^mp4_smhd
+    setcall bool mp4_piece(file,shd,shd_fwd)
+    if bool!=1
+        return 0
+    endif
+    #data info
+    str di="dinf"
+    data di_fwd^mp4_dinf
+    setcall bool mp4_piece(file,di,di_fwd)
+    if bool!=1
+        return 0
+    endif
+    #sample table
+    str stb="stbl"
+    data stb_fwd^mp4_soundstbl
+    setcall bool mp4_piece(file,stb,stb_fwd)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_smhd(sd file)
+const sound_smhd_start=\
+    char version=0
+    char *flags={0,0,0}
+    data *reserved=0
+const sound_smhd_size=\-sound_smhd_start
+    data smhd^version
+    data smhd_size=sound_smhd_size
+
+    sd err
+    setcall err mp4_write_or_no(smhd,smhd_size,file)
+    if err!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_soundstbl(sd file)
+    sd bool
+    #sample description
+    str sd="stsd"
+    data sd_fwd^mp4_soundstsd
+    setcall bool mp4_piece(file,sd,sd_fwd)
+    if bool!=1
+        return 0
+    endif
+    #time scale
+    str ts="stts"
+    data ts_fwd^mp4_soundstts
+    setcall bool mp4_piece(file,ts,ts_fwd)
+    if bool!=1
+        return 0
+    endif
+    #sample to chunk
+    str sc="stsc"
+    data sc_fwd^mp4_soundstsc
+    setcall bool mp4_piece(file,sc,sc_fwd)
+    if bool!=1
+        return 0
+    endif
+    #sample size
+    str sz="stsz"
+    data sz_fwd^mp4_soundstsz
+    setcall bool mp4_piece(file,sz,sz_fwd)
+    if bool!=1
+        return 0
+    endif
+    #chunk offset
+    str co="stco"
+    data co_fwd^mp4_soundstco
+    setcall bool mp4_piece(file,co,co_fwd)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_soundstsd(sd file)
+const soundstsd_start=\
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    char *entryCount={0,0,0,1}
+const soundstsd_size=\-soundstsd_start
+    data stsd^version_u8
+    data stsd_size=soundstsd_size
+
+    sd bool
+    setcall bool mp4_write_seek(stsd,stsd_size,file)
+    if bool!=1
+        return 0
+    endif
+
+    str avc="mp4a"
+    data avc_fwd^mp4_mp4a
+    setcall bool mp4_piece(file,avc,avc_fwd)
+    if bool!=1
+        return 0
+    endif
+
+    return 1
+endfunction
+
+#bool
+function mp4_mp4a(sd file)
+const mp4a_start=\
+    char reserved={0,0,0,0,0,0}
+    char *dataReferenceIndex={0,videoId}
+    char *version={0,0}
+    char *revision={0,0}
+    data *vendor=0
+    char *channel_count={0,mp3_channels}
+    char *bitspersample={0,mp3_bitspersample}
+    char *compression_id={0,0}
+    char *packet_size={0,0}
+    char samplerate_hi#2
+    char *samplerate_lo={0,0}
+const mp4a_size=\-mp4a_start
+    data mp4a^reserved
+    data mp4a_size=mp4a_size
+    #
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        import "int_into_short" int_into_short
+        sd sr
+        setcall sr dword_reverse((mp3_samplerate))
+        div sr (0x100*0x100)
+        sd p^samplerate_hi
+        call int_into_short(sr,p)
+    endif
+
+    sd bool
+    setcall bool mp4_write_seek(mp4a,mp4a_size,file)
+    if bool!=(TRUE)
+        return (FALSE)
+    endif
+
+
+    str esds="esds"
+    data esds_fwd^mp4_esds
+    setcall bool mp4_piece(file,esds,esds_fwd)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
+
+
+#bool
+function mp4_esds(sd file)
+const esds_start=\
+    char version=0
+    char *flags={0,0,0}
+    char *GF_ODF_ESD_TAG=3
+    char esd_size#1
+
+    char ESID={0,0}
+    #lengths: dependsOnESID 1,URLString 1,OCRESID 1,streamPriority 5
+    char *info=0
+
+    char *GF_ODF_DCD_TAG=4
+    char dcd_size#1
+        const objectTypeIndication_MPEG1Audio=0x6b
+    char objectTypeIndication=objectTypeIndication_MPEG1Audio
+        const GF_STREAM_AUDIO=5
+    const streamType_value=GF_STREAM_AUDIO
+    const upstream_value=0
+    const upstream_shift=2$1
+    const reserved_value=1
+        const reserved_shift=2$1
+        const upstream_pack=upstream_value*reserved_shift
+        const streamType_shift_pack=reserved_shift*upstream_shift
+        const streamType_pack=streamType_value*streamType_shift_pack
+    char *info=streamType_pack|upstream_pack|reserved_value
+const sound_bufferSizeDB_offset=\-esds_start
+    char bufferSizeDB#3
+    data maxBitrate#1
+    data *avgBitrate#1
+
+    char GF_ODF_SLC_TAG=6
+    char slc_size#1
+        const SLPredef_MP4=2
+    char predefined=SLPredef_MP4
+const esds_size=\-esds_start
+    data esds^version
+    data esds_size=esds_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        const _esds^ESID
+        const esds_^esds
+        set esd_size (esds_-_esds)
+
+        const _dcd^objectTypeIndication
+        const dcd_^GF_ODF_SLC_TAG
+        set dcd_size (dcd_-_dcd)
+
+        const _slc^predefined
+        const slc_^esds
+        set slc_size (slc_-_slc)
+
+        sd err
+        sd file_pos
+        sd ptr_file_pos^file_pos
+
+        setcall err file_tell(file,ptr_file_pos)
+        if err!=(noerror)
+            return 0
+        endif
+
+        setcall err file_write(esds,esds_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+
+        const _DCD^version
+        const DCD_^bufferSizeDB
+        add file_pos (DCD_-_DCD)
+
+        sd off
+        setcall off mp4_sound_esds_items_offset()
+        set off# file_pos
+    else
+        setcall err file_seek_cursor(file,(sound_bufferSizeDB_offset))
+        if err!=(noerror)
+            return 0
+        endif
+        sd bf_sz
+        setcall err file_read(#bf_sz,3,file)
+        if err!=(noerror)
+            return 0
+        endif
+        setcall bf_sz dword_reverse(bf_sz)
+        div bf_sz 0x100
+        call mp4_audio_bufferSz_set(bf_sz)
+        #
+        setcall err file_get_dword(file,#maxBitrate)
+        if err!=(noerror)
+            return 0
+        endif
+        setcall maxBitrate dword_reverse(maxBitrate)
+        div maxBitrate 8
+        call mp4_audio_maxBitrate_set(maxBitrate)
+    endelse
+    return 1
+endfunction
+
+function mp4_sound_esds_items_offset()
+    data offset#1
+    data p^offset
+    return p
+endfunction
+
+#bool
+function mp4_soundstts(sd file)
+const soundstts_start=\
+    char version_u8={0}
+    char *flags_u24={0,0,0}
+    char *list_count={0,0,0,1}
+    data sampleCount#1
+    data sampleDelta#1
+const soundstts_size=\-soundstts_start
+    data stts^version_u8
+    data stts_size=soundstts_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        sd sample_count
+        setcall sample_count mp4_sample_count()
+        setcall sampleCount dword_reverse(sample_count#)
+        setcall sampleDelta dword_reverse((samp_per_frame))
+
+        sd err
+        setcall err file_write(stts,stts_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_soundstsc(sd file)
+const soundstsc_start=\
+    char version={0}
+    char *flags={0,0,0}
+    char *list_count={0,0,0,1}
+    char *firstChunk={0,0,0,1}
+    data samplesPerChunk#1
+    char *sampleDescriptionIndex={0,0,0,1}
+const soundstsc_size=\-soundstsc_start
+    data stsc^version
+    data stsc_size=soundstsc_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        sd sample_count
+        setcall sample_count mp4_sample_count()
+        setcall samplesPerChunk dword_reverse(sample_count#)
+
+        sd err
+        setcall err file_write(stsc,stsc_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_soundstsz(sd file)
+const soundstsz_start=\
+    char version={0}
+    char *flags={0,0,0}
+    data sampleSize#1
+    data sampleCount#1
+const soundstsz_size=\-soundstsz_start
+    data stsz^version
+    data stsz_size=soundstsz_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        sd err
+        sd file_pos
+        sd ptr_file_pos^file_pos
+        setcall err file_tell(file,ptr_file_pos)
+        if err!=(noerror)
+            return 0
+        endif
+        const _stsz_size^version
+        const stsz_size_^sampleSize
+        sd off
+        setcall off mp4_entrysize_offset()
+        add file_pos (stsz_size_-_stsz_size)
+        set off# file_pos
+
+        sd sample_count
+        setcall sample_count mp4_sample_count()
+        setcall sampleCount dword_reverse(sample_count#)
+
+        setcall err file_write(stsz,stsz_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    endif
+    return 1
+endfunction
+
+#bool
+function mp4_soundstco(sd file)
+const soundstco_start=\
+    char version={0}
+    char *flags={0,0,0}
+    char *entries={0,0,0,1}
+const soundstco_offset_pos=\-soundstco_start
+    data offset#1
+const soundstco_size=\-soundstco_start
+    data stco^version
+    data stco_size=soundstco_size
+
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        sd err
+        sd file_pos
+        sd ptr_file_pos^file_pos
+        setcall err file_tell(file,ptr_file_pos)
+        if err!=(noerror)
+            return 0
+        endif
+        const _stco_off^version
+        const stco_off_^offset
+        sd off
+        setcall off mp4_chunkoff()
+        add file_pos (stco_off_-_stco_off)
+        set off# file_pos
+
+        setcall err file_write(stco,stco_size,file)
+        if err!=(noerror)
+            return 0
+        endif
+    else
+        setcall err file_seek_cursor_get_dword_reverse(file,(soundstco_offset_pos),#offset)
+        if err!=(noerror)
+            return 0
+        endif
+        call mp4_audio_offset_set(offset)
+    endelse
+    return 1
+endfunction
+
+#
+#bool
+function mp4_sound_init(sd all_size)
+    #all samples
+    sd all_samples
+    setcall all_samples mp4_all_samples()
+    sd samples
+    set samples all_size
+    div samples (buffer_size)
+    mult samples (buffer_size)
+    div samples (mp3_channels*mp3_bytespersample)
+    set all_samples# samples
+    #duration at the default timescale
+    import "fmul_quad" fmul_quad
+    sd duration
+    call fild_value(samples)
+    sd tscale
+    setcall tscale mp4_tscale()
+    data double_data#2
+    data double^double_data
+    call fild_value(tscale)
+    call fstp_quad(double)
+    call fmul_quad(double)
+    call fild_value((mp3_samplerate))
+    call fstp_quad(double)
+    call fdiv_quad(double)
+    setcall duration mp4_sound_duration()
+    call fstp_quad(double)
+    sd sound_duration
+    setcall sound_duration double_to_int(double)
+    setcall duration# dword_reverse(sound_duration)
+    #sample count
+    div samples (samp_per_frame)
+    sd sample_count
+    setcall sample_count mp4_sample_count()
+    set sample_count# samples
+    #sound or video duration for all file
+    sd video_duration
+    setcall video_duration mp4_duration((value_get))
+    if sound_duration>video_duration
+        sd l_duration
+        setcall l_duration mp4_longest_duration()
+        set l_duration# sound_duration
+    endif
+    #next track
+    call mp4_next_track_set((emptyId))
+    #Not part of MPEG-4 audio profiles
+    call mp4_audio_profile_set(0xfe)
+    #verify for the used format
+    import "stage_sound_channels" stage_sound_channels
+    import "stage_sound_bps" stage_sound_bps
+    import "stage_sound_rate" stage_sound_rate
+    sd ch
+    setcall ch stage_sound_channels((value_get))
+    if ch!=(mp3_channels)
+        str ch_err="Sound with 2 channels required"
+        call texter(ch_err)
+        return 0
+    endif
+    sd bps
+    setcall bps stage_sound_bps((value_get))
+    if bps!=(mp3_bitspersample)
+        str bps_err="Sound with 16 bits-per-sample required"
+        call texter(bps_err)
+        return 0
+    endif
+    sd rate
+    setcall rate stage_sound_rate((value_get))
+    if rate!=(mp3_samplerate)
+        str sr_err="Sound with 48000 sample rate required"
+        call texter(sr_err)
+        return 0
+    endif
+    return 1
+endfunction
+
+
+##extend + write
+import "file_write_forward" file_write_forward
+function mp4_dialog(ss filename)
+    #init expand values
+    sd presence
+    setcall presence mp4_sound_presence()
+    set presence# 0
+    call mp4_video_samples_set(0)
+    call mp4_video_bufferSz_set(0)
+    call mp4_video_offset_set(0)
+    call mp4_audio_samples_set(0)
+    call mp4_audio_bufferSz_set(0)
+    call mp4_audio_maxBitrate_set(0)
+    call mp4_audio_offset_set(0)
+    #
+    call mp4_info_set(0)
+    #
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        #write
+        call file_write_forward(filename,mp4_filewrite)
+    else
+        #expand
+        #mem for temp file path name
+        import "slen" slen
+        sd len
+        setcall len slen(filename)
+        inc len
+        ss mem
+        setcall mem memalloc(len)
+        if mem!=0
+            call mp4_expand_go(filename,mem)
+            call free(mem)
+        endif
+    endelse
+
+    sd info
+    setcall info mp4_info_get()
+    if info=(TRUE)
+        import "save_inform_saved" save_inform_saved
+        call save_inform_saved(filename)
+    endif
+
+    call av_dialog_close()
+endfunction
+
+#bool
+function mp4_write_seek(sd mem,sd size,sd file)
+    sd procedure
+    sd err
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_write)
+        setcall err file_write(mem,size,file)
+        if err!=(noerror)
+            return (FALSE)
+        endif
+    else
+        setcall err file_seek_cursor(file,size)
+        if err!=(noerror)
+            return (FALSE)
+        endif
+    endelse
+    return (TRUE)
+endfunction
+
+#err
+function mp4_write_or_no(sd mem,sd size,sd file)
+    sd procedure
+    setcall procedure mp4_write_expand_get()
+    if procedure=(mp4_expand)
+        return (noerror)
+    endif
+    sd err
+    setcall err file_write(mem,size,file)
+    return err
+endfunction
+
+#implement expand mp4
+#at video:
+#             all sample count at samplecount for a few factors
+#             bufferSz at         max_size
+#at sound:
+#             all pcm samples at all_size(at sound init)
+#             maxBitrate at      max_rate
+#             bufferSizeDB at    max_sound_size
+#at takings, also get the video and sound movie data offset and size
+#at write calculate:
+#             all video size at   all_size for avgbitrate
+#             all sound size at  all_sound_size for avg
+
+function mp4_extend(ss filename)
+    call mp4_write_expand_set((mp4_expand))
+    call av_dialog_run(mp4_dialog,filename)
+endfunction
+import "change_name" change_name
+importx "_remove" remove
+function mp4_expand_go(ss filepath,ss temppath)
+    #rename
+    import "cpymem" cpymem
+    sd len
+    setcall len slen(filepath)
+    dec len
+    call cpymem(temppath,filepath,len)
+    ss cursor
+    set cursor temppath
+    add cursor len
+    set cursor# 0
+    sd ret
+    setcall ret change_name(filepath,temppath)
+    if ret!=0
+        return (void)
+    endif
+    #open read to get previous values
+    import "openfile" openfile
+    importx "_fclose" fclose
+    sd file
+    sd err
+    setcall err openfile(#file,temppath,"rb")
+    if err=(noerror)
+        #info
+        call dialog_modal_texter_draw("Prepare the original file")
+        #store read handle for reading at the other file
+        call mp4_expand_startfile_set(file)
+        sd info
+        #read data
+        sd read_bool
+        setcall read_bool mp4_start(file)
+        if read_bool=(TRUE)
+            #open write
+            call mp4_write_expand_set((mp4_write))
+            call file_write_forward(filepath,mp4_filewrite)
+            #
+            setcall info mp4_info_get()
+        endif
+        #close old file
+        call fclose(file)
+        if read_bool=(FALSE)
+            #change back if was an error at read
+            call change_name(temppath,filepath)
+        else
+            if info=(TRUE)
+                #remove initial file
+                call remove(temppath)
+            endif
+        endelse
+    endif
+endfunction
--- ovideo-1.orig/src/media/mp4.s
+++ /dev/null
@@ -1,2507 +0,0 @@
-
-format elfobj
-
-include "../_include/include.h"
-
-import "mp4_sizes" mp4_sizes
-import "mp4_times" mp4_times
-import "mp4_tscale" mp4_tscale
-import "mp4_duration" mp4_duration
-import "mp4_timescale" mp4_timescale
-import "mp4_duration_1000" mp4_duration_1000
-import "mp4_SampleCount" mp4_SampleCount
-
-import "avc_init" avc_init
-import "avc_free" avc_free
-import "avc_ProfileIndication" avc_ProfileIndication
-import "avc_profile_compatibility" avc_profile_compatibility
-import "avc_LevelIndication" avc_LevelIndication
-import "avc_encode" avc_encode
-
-import "mp4_write_expand_set" mp4_write_expand_set
-import "mp4_write_expand_get" mp4_write_expand_get
-#0 is write
-const mp4_write=0
-#1 is expand
-const mp4_expand=1
-import "mp4_sound_presence" mp4_sound_presence
-import "mp4_sound_presence_get" mp4_sound_presence_get
-import "mp4_audio_samples_set" mp4_audio_samples_set
-import "mp4_audio_samples_get" mp4_audio_samples_get
-import "mp4_info_set" mp4_info_set
-import "mp4_info_get" mp4_info_get
-
-import "dialog_modal_texter_draw" dialog_modal_texter_draw
-const videoId=1
-const soundId=2
-const emptyId=3
-
-const enable_flag=1
-const sample_delta=1000
-
-import "stage_nthwidgetFromcontainer" stage_nthwidgetFromcontainer
-import "file_write" file_write
-
-import "av_dialog_run" av_dialog_run
-import "av_dialog_close" av_dialog_close
-import "av_dialog_stop" av_dialog_stop
-
-
-
-#importx "_fread" fread
-#importx "_fwrite" fwrite
-#function extragere(ss location)
-#	data extragere_off1#1
-#	const extr_1^extragere_off1
-#	data extragere_off2#1
-#	const extr_2^extragere_off2
-#	sd file
-#	call openfile(#file,location,"rb")
-#	sd mp3_file
-#	call openfile(#mp3_file,"captures/file.mp3","wb")
-#	sd mp3_sz;set mp3_sz extragere_off2;sub mp3_sz extragere_off1
-#	call file_seek_set(file,extragere_off1)
-#	sd mp3Mem;setcall mp3Mem memalloc(mp3_sz)
-#	Call fread(mp3Mem,1,mp3_sz,file)
-#	Call fwrite(mp3Mem,1,mp3_sz,mp3_file)
-#	call fclose(mp3_file)
-#	call fclose(file)
-#endfunction
-
-
-
-
-function mp4_write()
-    call mp4_write_expand_set((mp4_write))
-    ss location
-    import "stage_get_output_container" stage_get_output_container
-    setcall location stage_get_output_container()
-    call av_dialog_run(mp4_dialog,location)
-
-#call extragere(location)
-
-endfunction
-#
-function mp4_filewrite(sd file)
-    sd ebox
-    setcall ebox stage_nthwidgetFromcontainer(0)
-    import "object_get_dword_name" object_get_dword_name
-    sd pixbuf
-    setcall pixbuf object_get_dword_name(ebox)
-    call mp4_container(file,pixbuf)
-endfunction
-
-import "mp3_init" mp3_init
-import "mp3_free" mp3_free
-
-function mp4_container(sd file,sd pixbuf)
-    sd bool
-    setcall bool avc_init(pixbuf)
-    if bool!=1
-        return 0
-    endif
-    setcall bool mp3_init()
-    if bool==1
-        call mp4_file(file,pixbuf)
-        call mp3_free()
-    endif
-    call avc_free()
-endfunction
-
-import "mp4_longest_duration" mp4_longest_duration
-import "mp4_next_track" mp4_next_track
-import "mp4_next_track_set" mp4_next_track_set
-import "mp4_audio_profile" mp4_audio_profile
-import "mp4_audio_profile_set" mp4_audio_profile_set
-
-import "stage_sound_alloc_getremainingsize" stage_sound_alloc_getremainingsize
-import "mp4_all_samples" mp4_all_samples
-import "mp4_sound_duration" mp4_sound_duration
-import "mp4_sample_count" mp4_sample_count
-import "mp4_entrysize_offset" mp4_entrysize_offset
-import "mp4_chunkoff" mp4_chunkoff
-
-function mp4_file(sd file,sd pixbuf)
-    call mp4_SampleCount((value_set))
-    call mp4_sizes((value_set),pixbuf)
-    call mp4_timescale((value_set))
-    call mp4_duration((value_set))
-    call mp4_duration_1000((value_set))
-    sd duration
-    setcall duration mp4_duration((value_get))
-    sd l_duration
-    setcall l_duration mp4_longest_duration()
-    set l_duration# duration
-    call mp4_next_track_set((soundId))
-        #No audio capability required
-    call mp4_audio_profile_set(0xff)
-    sd bool
-    #sound
-    import "stage_sound_sizedone" stage_sound_sizedone
-    call stage_sound_sizedone((value_set),0)
-    sd is_sound_or_is_not
-    setcall is_sound_or_is_not mp4_sound_presence_get()
-    if is_sound_or_is_not==0
-        setcall is_sound_or_is_not stage_sound_alloc_getremainingsize()
-    endif
-    if is_sound_or_is_not!=0
-        sd sz
-        setcall sz stage_sound_alloc_getremainingsize()
-        addcall sz mp4_audio_samples_get()
-        setcall bool mp4_sound_init(sz)
-        if bool!=1
-            return (void)
-        endif
-    endif
-    #
-    setcall bool mp4_start(file)
-    if bool==(TRUE)
-        call mp4_info_set(1)
-    endif
-endfunction
-#bool
-function mp4_start(sd file)
-    sd bool
-    str type="ftyp"
-    data type_fwd^mp4_ftyp
-    setcall bool mp4_piece(file,type,type_fwd)
-    if bool!=1
-        return (FALSE)
-    endif
-    str mov="moov"
-    data mov_fwd^mp4_moov
-    setcall bool mp4_piece(file,mov,mov_fwd)
-    if bool!=1
-        return (FALSE)
-    endif
-    #
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_expand)
-        #at read for expand stop here
-        return (TRUE)
-    endif
-    #
-    str md="mdat"
-    data md_fwd^mp4_mdat
-    setcall bool mp4_piece(file,md,md_fwd)
-    if bool!=1
-        return (FALSE)
-    endif
-    return (TRUE)
-endfunction
-
-#bool
-function mp4_piece(sd file,sd name,sd forward)
-    sd bool
-    setcall bool mp4_content(file,name,forward,0,4,0)
-    return bool
-endfunction
-
-#bool
-function mp4_content(sd file,sd name,sd forward,sd f_data,sd sizefield_bytes,sd substract)
-    sd bool
-    setcall bool mp4_wrap(file,name,forward,f_data,sizefield_bytes,substract,0)
-    return bool
-endfunction
-import "file_read" file_read
-#bool
-function mp4_wrap(sd file,sd name,sd forward,sd f_data,sd sizefield_bytes,sd substract,sd p_SizeOfSample)
-    import "file_tell" file_tell
-    sd err
-    #get the point for calculations
-    sd file_pos_in
-    sd ptr_file_pos_in^file_pos_in
-    setcall err file_tell(file,ptr_file_pos_in)
-    if err!=(noerror)
-        return 0
-    endif
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        sd dummy_size
-        sd dummy^dummy_size
-        setcall err file_write(dummy,sizefield_bytes,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        sd read_size
-        setcall err file_read(#read_size,sizefield_bytes,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-    sd bool
-    if name!=0
-        setcall bool mp4_write_seek(name,4,file)
-        if bool!=(TRUE)
-            return (FALSE)
-        endif
-    endif
-
-    setcall bool forward(file,f_data)
-    if bool!=1
-        return 0
-    endif
-
-    sd arrange_size=1
-    sd count
-    set count sizefield_bytes
-    while count!=4
-        mult arrange_size 0x100
-        inc count
-    endwhile
-
-    if procedure==(mp4_write)
-        sd file_pos_out
-        sd ptr_file_pos_out^file_pos_out
-        setcall err file_tell(file,ptr_file_pos_out)
-        if err!=(noerror)
-            return 0
-        endif
-        import "file_seek_set" file_seek_set
-        import "dword_reverse" dword_reverse
-        sd size
-        sd p_size^size
-        set size file_pos_out
-
-        sub size file_pos_in
-        sub size substract
-        mult size arrange_size
-
-        if p_SizeOfSample!=0
-            set p_SizeOfSample# size
-        endif
-        setcall size dword_reverse(size)
-        setcall err file_seek_set(file,file_pos_in)
-        if err!=(noerror)
-            return 0
-        endif
-        setcall err file_write(p_size,sizefield_bytes,file)
-        if err!=(noerror)
-            return 0
-        endif
-        setcall err file_seek_set(file,file_pos_out)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        setcall read_size dword_reverse(read_size)
-        div read_size arrange_size
-        add read_size substract
-        add read_size file_pos_in
-        setcall err file_seek_set(file,read_size)
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-
-    return 1
-endfunction
-
-#bool
-function mp4_ftyp(sd file)
-const ftyp_start=!
-    char GF_ISOM_BRAND_ISOM={i,s,o,m}
-    char *minorVersion={0,0,0,1}
-    char *brand={i,s,o,m}
-    char *brand_1={a,v,c,_1}
-const ftyp_size=!-ftyp_start
-    data ftyp^GF_ISOM_BRAND_ISOM
-    data ftyp_size=ftyp_size
-
-    sd err
-    setcall err mp4_write_or_no(ftyp,ftyp_size,file)
-    if err!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_moov(sd file)
-    call mp4_times((value_set))
-
-    str hd="mvhd"
-    data hd_fwd^mp4_mvhd
-    sd bool
-    setcall bool mp4_piece(file,hd,hd_fwd)
-    if bool!=1
-        return 0
-    endif
-    str iod="iods"
-    data iod_fwd^mp4_iods
-    setcall bool mp4_piece(file,iod,iod_fwd)
-    if bool!=1
-        return 0
-    endif
-    str trk="trak"
-    data trk_fwd^mp4_trak
-    setcall bool mp4_piece(file,trk,trk_fwd)
-    if bool!=1
-        return 0
-    endif
-
-    #sound
-    sd is_sound_or_is_not
-    setcall is_sound_or_is_not mp4_sound_presence_get()
-    if is_sound_or_is_not!=0
-        str soundtrk="trak"
-        data soundtrk_fwd^mp4_soundtrak
-        setcall bool mp4_piece(file,soundtrk,soundtrk_fwd)
-        if bool!=1
-            return 0
-        endif
-    endif
-    #
-
-    return 1
-endfunction
-
-import "file_seek_cursor" file_seek_cursor
-import "word_reverse" word_reverse
-import "file_get_dword" file_get_dword
-
-#bool
-function mp4_mvhd(sd file)
-const mvhd_start=!
-    #movie header
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    data creationTime#1
-    data *modificationTime#1
-    data timeScale#1
-    data duration#1
-    data preferredRate#1
-    char preferredVolume#2
-    char *reserved={0,0,0,0,0,0,0,0,0,0}
-    data matrixA#1
-    data *matrixB=0
-    data *matrixU=0
-    data *matrixC=0
-    data matrixD#1
-    data *matrixV=0
-    data *matrixX=0
-    data *matrixY=0
-    data matrixW#1
-    data *previewTime=0
-    data *previewDuration=0
-    data *posterTime=0
-    data *selectionTime=0
-    data *selectionDuration=0
-    data *currentTime=0
-const off_to_nexttrack=!-mvhd_start
-    data nextTrackID#1
-const mvhd_size=!-mvhd_start
-    data mvhd^version_u8
-    data mvhd_size=mvhd_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        data times^creationTime
-        call mp4_times((value_get),times)
-        setcall timeScale mp4_tscale((value_get))
-        setcall timeScale dword_reverse(timeScale)
-        #
-        setcall duration mp4_longest_duration()
-        setcall duration dword_reverse(duration#)
-        #
-        setcall preferredRate dword_reverse((2$16))
-        ss vol^preferredVolume
-        call word_reverse((2$8),vol)
-        setcall matrixA dword_reverse((2$16))
-        setcall matrixD dword_reverse((2$16))
-        setcall matrixW dword_reverse((2$30))
-        #
-        sd nexttrack
-        setcall nexttrack mp4_next_track()
-        setcall nextTrackID dword_reverse(nexttrack#)
-
-        sd err
-        setcall err file_write(mvhd,mvhd_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        setcall err file_seek_cursor(file,(off_to_nexttrack))
-        if err!=(noerror)
-            return 0
-        endif
-        setcall err file_get_dword(file,#nextTrackID)
-        if err!=(noerror)
-            return 0
-        endif
-    endelse
-    #back to little endian
-    setcall nextTrackID dword_reverse(nextTrackID)
-    if nextTrackID>(soundId)
-        #incrementation because one or two calls means sound and zero means no sound
-        sd presence
-        setcall presence mp4_sound_presence()
-        inc presence#
-    endif
-
-    return 1
-endfunction
-
-#bool
-function mp4_iods(sd file)
-    #InitialObjectDescriptor
-    const GF_ODF_ISOM_IOD_TAG=0x10
-    const iod_objectDescriptorId=1
-    const iod_URLFlag=0
-    const iod_inlineProfileFlag=0
-    const iod_reserved=0xf
-
-    char version=0
-    char *flags={0,0,0}
-
-    char *tag=GF_ODF_ISOM_IOD_TAG
-    char *tag_size=7
-    char iod_attr_data#2
-    char *OD_profileAndLevel=0xff
-    char *scene_profileAndLevel=0xff
-    char audio_profileAndLevel#1
-    #AVC/H264 Profile
-    char *visual_profileAndLevel=0x15
-    char *graphics_profileAndLevel=0xff
-
-    data iod^version
-    data _iod^iod
-    data iod_size#1
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        set iod_size _iod
-        sub iod_size iod
-
-        sd data=iod_reserved
-        sd mover=0x10
-        sd concat
-
-        set concat (iod_inlineProfileFlag)
-        mult concat mover
-        or data concat
-        mult mover 2
-
-        set concat (iod_URLFlag)
-        mult concat mover
-        or data concat
-        mult mover 2
-
-        set concat (iod_objectDescriptorId)
-        mult concat mover
-        or data concat
-
-        str iod_attr^iod_attr_data
-        call word_reverse(data,iod_attr)
-
-        ss profile
-        setcall profile mp4_audio_profile()
-        set audio_profileAndLevel profile#
-
-        sd err
-        setcall err file_write(iod,iod_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-
-    return 1
-endfunction
-
-#bool
-function mp4_trak(sd file)
-    sd bool
-
-    str tkh="tkhd"
-    data tkh_fwd^mp4_tkhd
-    setcall bool mp4_piece(file,tkh,tkh_fwd)
-    if bool!=1
-        return 0
-    endif
-    str md="mdia"
-    data md_fwd^mp4_mdia
-    setcall bool mp4_piece(file,md,md_fwd)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_tkhd(sd file)
-    char version_u8={0}
-    char *flags_u24={0,0,enable_flag}
-    data creationTime#1
-    data *modificationTime#1
-    char *trackID={0,0,0,videoId}
-    data *reserved1=0
-    data duration#1
-    data *reserved2={0,0}
-    char *layer={0,0}
-    char *alternate_group={0,0}
-    char *volume={0,0}
-    char *reserved3={0,0}
-    char *matrix0={0,1,0,0}
-    data *matrix1=0
-    data *matrix2=0
-    data *matrix3=0
-    char *matrix4={0,1,0,0}
-    data *matrix5=0
-    data *matrix6=0
-    data *matrix7=0
-    char *matrix8={0x40,0,0,0}
-    data width#1
-    data height#1
-
-    data tkhd^version_u8
-    data _tkhd^tkhd
-    data tkhd_size#1
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        set tkhd_size _tkhd
-        sub tkhd_size tkhd
-
-        data tm^creationTime
-        call mp4_times((value_get),tm)
-        setcall duration mp4_duration((value_get))
-        setcall duration dword_reverse(duration)
-        sd wh^width
-        call mp4_sizes((value_get),wh)
-        mult width 0x10000
-        mult height 0x10000
-        setcall width dword_reverse(width)
-        setcall height dword_reverse(height)
-
-        sd err
-        setcall err file_write(tkhd,tkhd_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_mdia(sd file)
-    sd bool
-
-    str mhd="mdhd"
-    data mhd_fwd^mp4_mdhd
-    setcall bool mp4_piece(file,mhd,mhd_fwd)
-    if bool!=1
-        return 0
-    endif
-    str hdl="hdlr"
-    data hdl_fwd^mp4_hdlr
-    setcall bool mp4_piece(file,hdl,hdl_fwd)
-    if bool!=1
-        return 0
-    endif
-    str mi="minf"
-    data mi_fwd^mp4_minf
-    setcall bool mp4_piece(file,mi,mi_fwd)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_mdhd(sd file)
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    data creationTime#1
-    data *modificationTime#1
-    data timeScale#1
-    data duration#1
-    char language#2
-    char *reserved={0,0}
-
-    data mdhd^version_u8
-    data _mdhd^mdhd
-    data mdhd_size#1
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        set mdhd_size _mdhd
-        sub mdhd_size mdhd
-
-        sd times^creationTime
-        call mp4_times((value_get),times)
-
-        setcall timeScale mp4_timescale((value_get))
-        setcall timeScale dword_reverse(timeScale)
-        setcall duration mp4_duration_1000((value_get))
-        setcall duration dword_reverse(duration)
-
-        data lang_str^language
-        call mp4_set_language(lang_str)
-
-        sd err
-        setcall err file_write(mdhd,mdhd_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-function mp4_set_language(sd pword)
-    sd word=0
-    sd aux
-    ss lang="und"
-    sd mover=0x8000
-    #SPECS: BIT(1) of padding
-
-    set aux lang#
-    sub aux 0x60
-    div mover (2$5)
-    mult aux mover
-    or word aux
-
-    inc lang
-    set aux lang#
-    sub aux 0x60
-    div mover (2$5)
-    mult aux mover
-    or word aux
-
-    inc lang
-    set aux lang#
-    sub aux 0x60
-    div mover (2$5)
-    mult aux mover
-    or word aux
-
-    call word_reverse(word,pword)
-endfunction
-
-#bool
-function mp4_hdlr(sd file)
-const hdlr_start=!
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    data *reserved1=0
-    char *handlerType={v,i,d,e}
-    char *reserved2={0,0,0,0,0,0,0,0,0,0,0,0}
-    #is null terminated
-    #char *nameUTF8="GPAC ISO Video Handler"
-    char *nameUTF8="OApplications Video"
-const hdlr_size=!-hdlr_start
-    data hdlr^version_u8
-    data hdlr_size=hdlr_size
-
-    sd err
-    setcall err mp4_write_or_no(hdlr,hdlr_size,file)
-    if err!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_minf(sd file)
-    sd bool
-
-    str vhd="vmhd"
-    data vhd_fwd^mp4_vmhd
-    setcall bool mp4_piece(file,vhd,vhd_fwd)
-    if bool!=1
-        return 0
-    endif
-    #data info
-    str di="dinf"
-    data di_fwd^mp4_dinf
-    setcall bool mp4_piece(file,di,di_fwd)
-    if bool!=1
-        return 0
-    endif
-    #sample table
-    str stb="stbl"
-    data stb_fwd^mp4_stbl
-    setcall bool mp4_piece(file,stb,stb_fwd)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_vmhd(sd file)
-    char version_u8={0}
-    char *flags_u24={0,0,enable_flag}
-    char *reserved={0,0,0,0,0,0,0,0}
-
-    data vmhd^version_u8
-    data _vmhd^vmhd
-    data vmhd_size#1
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        set vmhd_size _vmhd
-        sub vmhd_size vmhd
-
-        sd err
-        setcall err file_write(vmhd,vmhd_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_dinf(sd file)
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        sd bool
-        str drf="dref"
-        data drf_fwd^mp4_dref
-        setcall bool mp4_piece(file,drf,drf_fwd)
-        if bool!=1
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_dref(sd file)
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    char *count={0,0,0,1}
-
-    data dref^version_u8
-    data _dref^dref
-    data dref_size#1
-    set dref_size _dref
-    sub dref_size dref
-
-    sd err
-    setcall err file_write(dref,dref_size,file)
-    if err!=(noerror)
-        return 0
-    endif
-
-    sd bool
-    str url="url "
-    data url_fwd^mp4_url
-    setcall bool mp4_piece(file,url,url_fwd)
-    if bool!=1
-        return 0
-    endif
-
-    return 1
-endfunction
-
-#bool
-function mp4_url(sd file)
-    char version_u8={0}
-    char *flags_u24={0,0,enable_flag}
-
-    data url^version_u8
-    data _url^url
-    data url_size#1
-    set url_size _url
-    sub url_size url
-
-    sd err
-    setcall err file_write(url,url_size,file)
-    if err!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_stbl(sd file)
-    sd bool
-    #sample description
-    str sd="stsd"
-    data sd_fwd^mp4_stsd
-    setcall bool mp4_piece(file,sd,sd_fwd)
-    if bool!=1
-        return 0
-    endif
-    #time scale
-    str ts="stts"
-    data ts_fwd^mp4_stts
-    setcall bool mp4_piece(file,ts,ts_fwd)
-    if bool!=1
-        return 0
-    endif
-    #sync sample
-    str ss="stss"
-    data ss_fwd^mp4_stss
-    setcall bool mp4_piece(file,ss,ss_fwd)
-    if bool!=1
-        return 0
-    endif
-    #sample to chunk
-    str sc="stsc"
-    data sc_fwd^mp4_stsc
-    setcall bool mp4_piece(file,sc,sc_fwd)
-    if bool!=1
-        return 0
-    endif
-    #sample size
-    str sz="stsz"
-    data sz_fwd^mp4_stsz
-    setcall bool mp4_piece(file,sz,sz_fwd)
-    if bool!=1
-        return 0
-    endif
-    #chunk offset
-    str co="stco"
-    data co_fwd^mp4_stco
-    setcall bool mp4_piece(file,co,co_fwd)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_stsd(sd file)
-const stsd_start=!
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    char *entryCount={0,0,0,1}
-const stsd_size=!-stsd_start
-    data stsd^version_u8
-    data stsd_size=stsd_size
-
-    sd bool
-    setcall bool mp4_write_seek(stsd,stsd_size,file)
-    if bool!=1
-        return 0
-    endif
-
-    str avc="avc1"
-    data avc_fwd^mp4_avc1
-    setcall bool mp4_piece(file,avc,avc_fwd)
-    if bool!=1
-        return 0
-    endif
-
-    return 1
-endfunction
-
-#bool
-function mp4_avc1(sd file)
-const avc1_start=!
-    char reserved={0,0,0,0,0,0}
-    char *dataReferenceIndex={0,videoId}
-    char *version={0,0}
-    char *revision={0,0}
-    data *vendor=0
-    data *temporal_quality=0
-    data *spacial_quality=0
-    char Width#2
-    char Height#2
-    char *horiz_res={0,0x48,0,0}
-    char *vert_res={0,0x48,0,0}
-    data *entry_data_size=0
-    char *frames_per_sample={0,1}
-    char *compressor_name={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
-    char *bit_depth={0,0x18}
-    char color_table_index#2
-const avc1_size=!-avc1_start
-    data avc1^reserved
-    data avc1_size=avc1_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        sd w
-        sd h
-        sd wh^w
-        call mp4_sizes((value_get),wh)
-        sd W^Width
-        sd H^Height
-        call word_reverse(w,W)
-        call word_reverse(h,H)
-        sd cti^color_table_index
-        call word_reverse(-1,cti)
-    endif
-
-    sd bool
-    setcall bool mp4_write_seek(avc1,avc1_size,file)
-    if bool!=1
-        return 0
-    endif
-
-    #avc_config
-    str avC="avcC"
-    data avC_fwd^mp4_avcC
-    setcall bool mp4_piece(file,avC,avC_fwd)
-    if bool!=1
-        return 0
-    endif
-    #bitrate
-    str br="btrt"
-    data br_fwd^mp4_btrt
-    setcall bool mp4_piece(file,br,br_fwd)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_avcC(sd file)
-const avcC_start=!
-    char configurationVersion=1
-    char AVCProfileIndication#1
-    char profile_compatibility#1
-    char AVCLevelIndication#1
-    char cfg_data#2
-const avcC_size=!-avcC_start
-    data avcfg_main^configurationVersion
-    data avcfg_main_size=avcC_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        setcall AVCProfileIndication avc_ProfileIndication((value_get))
-        setcall profile_compatibility avc_profile_compatibility((value_get))
-        setcall AVCLevelIndication avc_LevelIndication((value_get))
-
-        sd word=0
-        sd aux
-        sd mover=0x10000
-
-        set aux 0x3f
-        div mover (2$6)
-        mult aux mover
-        or word aux
-
-        sd nal_unit_size=4
-        sub nal_unit_size 1
-        div mover (2$2)
-        mult nal_unit_size mover
-        or word nal_unit_size
-
-        set aux 0x7
-        div mover (2$3)
-        mult aux mover
-        or word aux
-
-        sd list_count=1
-        or word list_count
-
-        sd cfg_d^cfg_data
-        call word_reverse(word,cfg_d)
-
-        sd err
-        sd bool
-        #
-        setcall err file_write(avcfg_main,avcfg_main_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-        #
-        data avc_fn^avc_encode
-        setcall bool mp4_content(file,0,avc_fn,(avc_sequence_param),2,2)
-        if bool!=1
-            return 0
-        endif
-        #
-        char count=1
-        sd p_count^count
-        setcall err file_write(p_count,1,file)
-        if err!=(noerror)
-            return 0
-        endif
-        #
-        setcall bool mp4_content(file,0,avc_fn,(avc_picture_param),2,2)
-        if bool!=1
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-import "mp4_bufferSzOffset" mp4_bufferSzOffset
-import "mp4_avgbitrateOffset" mp4_avgbitrateOffset
-
-import "mp4_video_bufferSz_set" mp4_video_bufferSz_set
-import "mp4_video_bufferSz_get" mp4_video_bufferSz_get
-
-#bool
-function mp4_btrt(sd file)
-const btrt_start=!
-    data bufferSizeDB#1
-    data *maxBitrate=0
-    data *avgBitrate#1
-const btrt_size=!-btrt_start
-    data btrt^bufferSizeDB
-    data btrt_size=btrt_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        sd file_pos
-        sd ptr_file_pos^file_pos
-        sd err
-        setcall err file_tell(file,ptr_file_pos)
-        if err!=(noerror)
-            return 0
-        endif
-        call mp4_bufferSzOffset((value_set),file_pos)
-        add file_pos 8
-        call mp4_avgbitrateOffset((value_set),file_pos)
-
-        setcall err file_write(btrt,btrt_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        setcall err file_get_dword(file,#bufferSizeDB)
-        if err!=(noerror)
-            return 0
-        endif
-        setcall bufferSizeDB dword_reverse(bufferSizeDB)
-        call mp4_video_bufferSz_set(bufferSizeDB)
-    endelse
-    return 1
-endfunction
-
-import "mp4_video_samples_set" mp4_video_samples_set
-import "mp4_video_samples_get" mp4_video_samples_get
-import "file_seek_cursor_get_dword_reverse" file_seek_cursor_get_dword_reverse
-
-#bool
-function mp4_stts(sd file)
-const mp4_stts_start=!
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    char *list_count={0,0,0,1}
-const mp4_stts_sampleCount_offset=!-mp4_stts_start
-    data sampleCount#1
-    data sampleDelta#1
-const mp4_stts_size=!-mp4_stts_start
-
-    data stts^version_u8
-    data stts_size=mp4_stts_size
-
-    sd err
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        setcall sampleCount mp4_SampleCount((value_get))
-        setcall sampleCount dword_reverse(sampleCount)
-        setcall sampleDelta dword_reverse((sample_delta))
-
-        setcall err file_write(stts,stts_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        setcall err file_seek_cursor_get_dword_reverse(file,(mp4_stts_sampleCount_offset),#sampleCount)
-        if err!=(noerror)
-            return 0
-        endif
-        call mp4_video_samples_set(sampleCount)
-    endelse
-
-    return 1
-endfunction
-
-#bool
-function mp4_stss(sd file)
-const stss_start=!
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    char *entryCount={0,0,0,1}
-    char *sampleNumber={0,0,0,1}
-const stss_size=!-stss_start
-    data stss^version_u8
-    data stss_size=stss_size
-
-    sd err
-    setcall err mp4_write_or_no(stss,stss_size,file)
-    if err!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_stsc(sd file)
-const stsc_start=!
-    char version={0}
-    char *flags={0,0,0}
-    char *list_count={0,0,0,1}
-    char *firstChunk={0,0,0,1}
-    data samplesPerChunk#1
-    char *sampleDescriptionIndex={0,0,0,1}
-const stsc_size=!-stsc_start
-    data stsc^version
-    data stsc_size=stsc_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        setcall samplesPerChunk mp4_SampleCount((value_get))
-        setcall samplesPerChunk dword_reverse(samplesPerChunk)
-
-        sd err
-        setcall err file_write(stsc,stsc_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_stsz(sd file)
-const stsz_start=!
-    char version={0}
-    char *flags={0,0,0}
-    data *sampleSize=0
-    data sampleCount#1
-const stsz_size=!-stsz_start
-    data stsz^version
-    data stsz_size=stsz_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        sd NrOfSamples
-        setcall NrOfSamples mp4_SampleCount((value_write))
-        setcall sampleCount dword_reverse(NrOfSamples)
-
-        sd err
-        setcall err file_write(stsz,stsz_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-
-        import "mp4_samplesOffset" mp4_samplesOffset
-        sd file_pos
-        sd ptr_file_pos^file_pos
-        setcall err file_tell(file,ptr_file_pos)
-        if err!=(noerror)
-            return 0
-        endif
-        call mp4_samplesOffset((value_set),file_pos)
-        sd dummy_data
-        sd dummy^dummy_data
-        while NrOfSamples!=0
-            setcall err file_write(dummy,4,file)
-            if err!=(noerror)
-                return 0
-            endif
-            dec NrOfSamples
-        endwhile
-    endif
-    return 1
-endfunction
-import "mp4_video_offset_set" mp4_video_offset_set
-import "mp4_video_offset_get" mp4_video_offset_get
-#bool
-function mp4_stco(sd file)
-const stco_start=!
-    char version={0}
-    char *flags={0,0,0}
-    char *entries={0,0,0,1}
-const stco_offset_pos=!-stco_start
-    data offset#1
-const stco_size=!-stco_start
-    data stco^version
-    data stco_size=stco_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        import "mp4_chunksOffset" mp4_chunksOffset
-        sd file_pos
-        sd ptr_file_pos^file_pos
-        sd err
-        setcall err file_tell(file,ptr_file_pos)
-        if err!=(noerror)
-            return 0
-        endif
-        add file_pos 8
-        call mp4_chunksOffset((value_set),file_pos)
-
-        setcall err file_write(stco,stco_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        setcall err file_seek_cursor_get_dword_reverse(file,(stco_offset_pos),#offset)
-        if err!=(noerror)
-            return 0
-        endif
-        call mp4_video_offset_set(offset)
-    endelse
-    return 1
-endfunction
-
-import "memalloc" memalloc
-importx "_free" free
-import "texter" texter
-
-import "mp4_expand_startfile_set" mp4_expand_startfile_set
-import "mp4_expand_startfile_get" mp4_expand_startfile_get
-
-import "file_seekSet_setDwRev_goEnd" file_seekSet_setDwRev_goEnd
-
-#bool
-function mp4_mdat(sd file)
-
-#data off1%extr_1
-#call file_tell(file,off1)
-
-    sd bool
-    setcall bool mp4_mdat_sound(file)
-    if bool!=1
-        return 0
-    endif
-
-    #get chunk offset
-    sd ch_off
-    setcall ch_off mp4_chunksOffset((value_get))
-    sd file_pos
-    sd ptr_file_pos^file_pos
-    sd err
-    setcall err file_tell(file,ptr_file_pos)
-    if err!=(noerror)
-        return 0
-    endif
-    setcall bool file_seekSet_setDwRev_goEnd(file,ch_off,file_pos)
-    if bool!=(TRUE)
-        return (FALSE)
-    endif
-
-#data off2%extr_2
-#set off2# file_pos
-
-    #
-    sd all_size_of_sample
-    sd p_all_size_of_sample^all_size_of_sample
-    #
-    sd sz_off
-    setcall sz_off mp4_samplesOffset((value_get))
-    #
-    sd size_of_sample
-    sd p_size_of_sample^size_of_sample
-    #
-    sd max_size
-    setcall max_size mp4_video_bufferSz_get()
-    #
-    sd all_size=0
-
-    const chunk_size_sz=4
-
-    data avc_fn^avc_encode
-    setcall bool mp4_wrap(file,0,avc_fn,(avc_frame0_headers),(chunk_size_sz),(chunk_size_sz),p_all_size_of_sample)
-    if bool!=1
-        return 0
-    endif
-    add all_size_of_sample (chunk_size_sz)
-
-    sd force_start_encode=30
-
-    #can be expand
-    sd off_v
-    setcall off_v mp4_video_offset_get()
-    if off_v!=0
-        sd ex_file
-        setcall ex_file mp4_expand_startfile_get()
-        setcall err file_seek_set(ex_file,off_v)
-        if err!=(noerror)
-            return 0
-        endif
-        #skip header
-        import "file_get_dword_reverse" file_get_dword_reverse
-        setcall err file_get_dword_reverse(ex_file,p_size_of_sample)
-        if err!=(noerror)
-            return 0
-        endif
-        setcall err file_seek_cursor(ex_file,size_of_sample)
-        if err!=(noerror)
-            return 0
-        endif
-        #
-        sd mem
-        setcall mem memalloc(max_size)
-        if mem==0
-            return 0
-        endif
-        sd ex_samples
-        setcall ex_samples mp4_video_samples_get()
-        while ex_samples!=0
-            #
-            setcall err file_get_dword_reverse(ex_file,p_size_of_sample)
-            if err!=(noerror)
-                call free(mem)
-                return 0
-            endif
-            sd sz
-            setcall sz dword_reverse(size_of_sample)
-            setcall err file_write(#sz,(chunk_size_sz),file)
-            if err!=(noerror)
-                call free(mem)
-                return 0
-            endif
-            if max_size<size_of_sample
-                call texter("error at expand video")
-                call free(mem)
-                return 0
-            endif
-            setcall err file_read(mem,size_of_sample,ex_file)
-            if err!=(noerror)
-                call free(mem)
-                return 0
-            endif
-            setcall err file_write(mem,size_of_sample,file)
-            if err!=(noerror)
-                call free(mem)
-                return 0
-            endif
-            #
-            add size_of_sample (chunk_size_sz)
-            setcall bool mp4_avc_loop_sizes(file,size_of_sample,p_all_size_of_sample,#sz_off,#max_size,#all_size)
-            if bool!=1
-                call free(mem)
-                return 0
-            endif
-            dec ex_samples
-        endwhile
-        call free(mem)
-        set force_start_encode 0
-    endif
-
-    #
-    import "stage_get_frames" stage_get_frames
-    sd current_frame=0
-    sd f_size=-1
-    sd number_of_slices
-    setcall number_of_slices stage_get_frames()
-    sd current_slice=0
-    while current_slice!=number_of_slices
-        sd encode_slice
-        if f_size<0
-            set encode_slice current_slice
-        elseif current_frame>force_start_encode
-            set encode_slice -1
-        else
-        #at fixed frame rate we use zero length frames at this version
-        #some players may skip the start frame (frames?), encode at the beginning as p_skip
-            set encode_slice current_slice
-        endelse
-        data fn^mp4_avc
-        setcall bool mp4_wrap(file,0,fn,encode_slice,(chunk_size_sz),(chunk_size_sz),p_size_of_sample)
-        if bool!=1
-            return 0
-        endif
-        add size_of_sample (chunk_size_sz)
-        setcall bool mp4_avc_loop_sizes(file,size_of_sample,p_all_size_of_sample,#sz_off,#max_size,#all_size)
-        if bool!=1
-            return 0
-        endif
-        if f_size<0
-            import "stage_frame_time_numbers" stage_frame_time_numbers
-            setcall f_size stage_frame_time_numbers((stage_frame_time_get_at_index),encode_slice)
-        endif
-        dec f_size
-        if f_size==0
-            set f_size -1
-            inc current_slice
-        endif
-        inc current_frame
-    endwhile
-
-    #max buffer
-    sd bf_offset
-    setcall bf_offset mp4_bufferSzOffset((value_get))
-    setcall bool file_seekSet_setDwRev_goEnd(file,bf_offset,max_size)
-    if bool==0
-        return 0
-    endif
-    #average bit rate
-    import "int_to_double" int_to_double
-    import "double_div" double_div
-    import "double_to_int" double_to_int
-    sd avgBitrate
-    set avgBitrate all_size
-    sd br_double#2
-    sd br^br_double
-    sd tscale_double#2
-    sd tscale^tscale_double
-    sd avgb_double#2
-    sd avgb^avgb_double
-    sd value
-    setcall value mp4_timescale((value_get))
-    sd len
-    setcall len mp4_SampleCount((value_get))
-    mult len (sample_delta)
-    call int_to_double(len,br)
-    call int_to_double(value,tscale)
-    call double_div(br,tscale)
-    call int_to_double(avgBitrate,avgb)
-    call double_div(avgb,br)
-    setcall avgBitrate double_to_int(avgb)
-    mult avgBitrate 8
-    sd avg_off
-    setcall avg_off mp4_avgbitrateOffset((value_get))
-    setcall bool file_seekSet_setDwRev_goEnd(file,avg_off,avgBitrate)
-    if bool!=1
-        return 0
-    endif
-    #avgBitrate = (u32) ((Double) (s64)avg_rate / br)
-    #avgBitrate *= 8
-    return 1
-endfunction
-
-#bool
-function mp4_avc_loop_sizes(sd file,sd size_of_sample,sd p_all_size_of_sample,sd p_sz_off,sd p_max_size,sd p_all_size)
-    #all_size_of_sample is needed at start when we have the header included in the first frame
-    add p_all_size_of_sample# size_of_sample
-    if p_all_size_of_sample#>p_max_size#
-        #about max buffer size
-        set p_max_size# p_all_size_of_sample#
-    endif
-    #about average bit rate
-    add p_all_size# p_all_size_of_sample#
-    #add at stsz
-    sd bool
-    setcall bool file_seekSet_setDwRev_goEnd(file,p_sz_off#,p_all_size_of_sample#)
-    if bool!=(TRUE)
-        return (FALSE)
-    endif
-    #next offset at stsz
-    add p_sz_off# 4
-    #
-    set p_all_size_of_sample# 0
-    return (TRUE)
-endfunction
-
-#bool
-function mp4_avc(sd file,sd current_slice)
-    sd stop
-    setcall stop av_dialog_stop((value_get))
-    if stop==1
-        return 0
-    endif
-    if current_slice<0
-        return 1
-    endif
-    #
-    import "av_display_info" av_display_info
-    call av_display_info((value_get),file)
-    #
-    sd bool
-    sd eventbox
-    setcall eventbox stage_nthwidgetFromcontainer(current_slice)
-    sd pixbuf
-    setcall pixbuf object_get_dword_name(eventbox)
-    setcall bool avc_encode(file,(avc_frame),pixbuf)
-    if bool!=1
-        return 0
-    endif
-    #info display
-    import "av_display_info_progress" av_display_info_progress
-    call av_display_info_progress(file,current_slice)
-    #
-    return 1
-endfunction
-
-#sound
-import "mp4_audio_offset_set" mp4_audio_offset_set
-import "mp4_audio_offset_get" mp4_audio_offset_get
-import "mp4_audio_bufferSz_set" mp4_audio_bufferSz_set
-import "mp4_audio_bufferSz_get" mp4_audio_bufferSz_get
-import "mp4_audio_maxBitrate_set" mp4_audio_maxBitrate_set
-import "mp4_audio_maxBitrate_get" mp4_audio_maxBitrate_get
-
-#bool
-function mp4_mdat_sound(sd file)
-    sd bool
-    sd err
-    sd file_pos
-    sd ptr_file_pos^file_pos
-
-    #sound
-    import "mp3_encode" mp3_encode
-    sd is_sound_or_is_not
-    setcall is_sound_or_is_not mp4_sound_presence_get()
-    if is_sound_or_is_not!=0
-        sd off
-        #sound offset
-        setcall off mp4_chunkoff()
-        setcall err file_tell(file,ptr_file_pos)
-        if err!=(noerror)
-            return 0
-        endif
-        #
-        setcall bool file_seekSet_setDwRev_goEnd(file,off#,file_pos)
-        if bool!=1
-            return 0
-        endif
-        #
-        sd sound_size=0
-        sd p_sound_size^sound_size
-        #can be expand
-        sd off_a
-        setcall off_a mp4_audio_offset_get()
-        if off_a!=0
-            sd off_v
-            setcall off_v mp4_video_offset_get()
-            if off_v!=0
-                set sound_size off_v
-                sub sound_size off_a
-                sd ex_file
-                setcall ex_file mp4_expand_startfile_get()
-                setcall err file_seek_set(ex_file,off_a)
-                if err!=(noerror)
-                    return 0
-                endif
-                sd mem
-                setcall mem memalloc(sound_size)
-                if mem==0
-                    call free(mem)
-                    return 0
-                endif
-                setcall err file_read(mem,sound_size,ex_file)
-                if err!=(noerror)
-                    call free(mem)
-                    return 0
-                endif
-                setcall err file_write(mem,sound_size,file)
-                if err!=(noerror)
-                    call free(mem)
-                    return 0
-                endif
-                call free(mem)
-            endif
-        endif
-        #
-        sd max_sound_size
-        setcall max_sound_size mp4_audio_bufferSz_get()
-        #
-        sd all_sound_size
-        set all_sound_size sound_size
-        #
-        #sd count=0
-        sd rate=0
-        #
-        sd max_rate
-        setcall max_rate mp4_audio_maxBitrate_get()
-        #
-        sd timescale=mp3_samplerate
-        sd samples=0
-        sd loop=1
-        while loop==1
-            sd stop_question
-            setcall stop_question av_dialog_stop((value_get))
-            if stop_question==1
-                return 0
-            endif
-            setcall err file_tell(file,ptr_file_pos)
-            if err!=(noerror)
-                return 0
-            endif
-            setcall bool mp3_encode(file)
-            if bool!=1
-                return 0
-            endif
-            setcall err file_tell(file,p_sound_size)
-            if err!=(noerror)
-                return 0
-            endif
-            sub sound_size file_pos
-            if max_sound_size<sound_size
-                set max_sound_size sound_size
-            endif
-            #inc count
-            add rate sound_size
-            add samples (samp_per_frame)
-            add all_sound_size sound_size
-            if samples>=timescale
-                if max_rate<rate
-                    set max_rate rate
-                endif
-                set samples 0
-                set rate 0
-            endif
-            #
-            importx "_sprintf" sprintf
-            sd bytesleft
-            setcall bytesleft stage_sound_alloc_getremainingsize()
-            const soundbufstart=!
-            char format="Sound Bytes Left: %u"
-            char buffer#!-soundbufstart-2+dword_max
-            vstr buf^buffer
-            call sprintf(buf,#format,bytesleft)
-            call dialog_modal_texter_draw(buf)
-            #
-            import "mp3_encode_test" mp3_encode_test
-            setcall loop mp3_encode_test()
-        endwhile
-        #at stsz
-        setcall off mp4_entrysize_offset()
-        setcall bool file_seekSet_setDwRev_goEnd(file,off#,max_sound_size)
-        if bool!=1
-            return 0
-        endif
-        #move to esds
-        sd esds_offsets
-        setcall esds_offsets mp4_sound_esds_items_offset()
-        setcall err file_seek_set(file,esds_offsets#)
-        if err!=(noerror)
-            return 0
-        endif
-        #bufferSizeDB
-        mult max_sound_size 0x100
-        setcall max_sound_size dword_reverse(max_sound_size)
-        sd p_max^max_sound_size
-        setcall err file_write(p_max,3,file)
-        if err!=(noerror)
-            return 0
-        endif
-        #maxBitrate
-        sd maxBitrate
-        sd p_maxBitrate^maxBitrate
-        set maxBitrate max_rate
-        mult maxBitrate 8
-        setcall maxBitrate dword_reverse(maxBitrate)
-        setcall err file_write(p_maxBitrate,4,file)
-        if err!=(noerror)
-            return 0
-        endif
-        #avgBitrate
-        import "fild_value" fild_value
-        import "fstp_quad" fstp_quad
-        import "fdiv_quad" fdiv_quad
-        import "fistp" fistp
-        call fild_value(all_sound_size)
-        sd all_samples
-        setcall all_samples mp4_all_samples()
-        call fild_value(all_samples#)
-        data double_data#2
-        data double^double_data
-        call fild_value(timescale)
-        call fstp_quad(double)
-        call fdiv_quad(double)
-        call fstp_quad(double)
-        call fdiv_quad(double)
-        data sound_avgBitrate#1
-        data p_sound_avgBitrate^sound_avgBitrate
-        call fistp(p_sound_avgBitrate)
-        mult sound_avgBitrate 8
-        setcall sound_avgBitrate dword_reverse(sound_avgBitrate)
-        setcall err file_write(p_sound_avgBitrate,4,file)
-        if err!=(noerror)
-            return 0
-        endif
-        #
-        import "file_seek_end" file_seek_end
-        setcall err file_seek_end(file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-
-    return 1
-endfunction
-
-#bool
-function mp4_soundtrak(sd file)
-    sd bool
-    str tkh="tkhd"
-    data tkh_fwd^mp4_soundtkhd
-    setcall bool mp4_piece(file,tkh,tkh_fwd)
-    if bool!=1
-        return 0
-    endif
-    str md="mdia"
-    data md_fwd^mp4_soundmdia
-    setcall bool mp4_piece(file,md,md_fwd)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_soundtkhd(sd file)
-const soundtkhd_start=!
-    char version_u8={0}
-    char *flags_u24={0,0,enable_flag}
-    data creationTime#1
-    data *modificationTime#1
-    char *trackID={0,0,0,soundId}
-    data *reserved1=0
-    data duration#1
-    data *reserved2={0,0}
-    char *layer={0,0}
-    char *alternate_group={0,0}
-    char *volume={1,0}
-    char *reserved3={0,0}
-    char *matrix0={0,1,0,0}
-    data *matrix1=0
-    data *matrix2=0
-    data *matrix3=0
-    char *matrix4={0,1,0,0}
-    data *matrix5=0
-    data *matrix6=0
-    data *matrix7=0
-    char *matrix8={0x40,0,0,0}
-    data *width=0
-    data *height=0
-const soundtkhd_size=!-soundtkhd_start
-    data tkhd^version_u8
-    data tkhd_size=soundtkhd_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        data tm^creationTime
-        call mp4_times((value_get),tm)
-        setcall duration mp4_sound_duration()
-        set duration duration#
-
-        sd err
-        setcall err file_write(tkhd,tkhd_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_soundmdia(sd file)
-    sd bool
-
-    str mhd="mdhd"
-    data mhd_fwd^mp4_soundmdhd
-    setcall bool mp4_piece(file,mhd,mhd_fwd)
-    if bool!=1
-        return 0
-    endif
-    str hdl="hdlr"
-    data hdl_fwd^mp4_soundhdlr
-    setcall bool mp4_piece(file,hdl,hdl_fwd)
-    if bool!=1
-        return 0
-    endif
-    str mi="minf"
-    data mi_fwd^mp4_soundminf
-    setcall bool mp4_piece(file,mi,mi_fwd)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_soundmdhd(sd file)
-const soundmdhd_start=!
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    data creationTime#1
-    data *modificationTime#1
-    data timeScale#1
-const soundmdhd_duration=!-soundmdhd_start
-    data duration#1
-    char language#2
-    char *reserved={0,0}
-const soundmdhd_size=!-soundmdhd_start
-    data mdhd^version_u8
-    data mdhd_size=soundmdhd_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        sd times^creationTime
-        call mp4_times((value_get),times)
-        set timeScale (mp3_samplerate)
-        setcall timeScale dword_reverse(timeScale)
-        setcall duration mp4_all_samples()
-        setcall duration dword_reverse(duration#)
-        data lang_str^language
-        call mp4_set_language(lang_str)
-        sd err
-        setcall err file_write(mdhd,mdhd_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        setcall err file_seek_cursor_get_dword_reverse(file,(soundmdhd_duration),#duration)
-        if err!=(noerror)
-            return 0
-        endif
-        mult duration (mp3_blockalign)
-        call mp4_audio_samples_set(duration)
-    endelse
-    return 1
-endfunction
-
-#bool
-function mp4_soundhdlr(sd file)
-const soundhdlr_start=!
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    data *reserved1=0
-    char *handlerType={s,o,u,n}
-    char *reserved2={0,0,0,0,0,0,0,0,0,0,0,0}
-    #is null terminated
-    #char *nameUTF8="GPAC ISO Audio Handler"
-    char *nameUTF8="OApplications Audio"
-const soundhdlr_size=!-soundhdlr_start
-    data hdlr^version_u8
-    data hdlr_size=soundhdlr_size
-
-    sd err
-    setcall err mp4_write_or_no(hdlr,hdlr_size,file)
-    if err!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_soundminf(sd file)
-    sd bool
-    str shd="smhd"
-    data shd_fwd^mp4_smhd
-    setcall bool mp4_piece(file,shd,shd_fwd)
-    if bool!=1
-        return 0
-    endif
-    #data info
-    str di="dinf"
-    data di_fwd^mp4_dinf
-    setcall bool mp4_piece(file,di,di_fwd)
-    if bool!=1
-        return 0
-    endif
-    #sample table
-    str stb="stbl"
-    data stb_fwd^mp4_soundstbl
-    setcall bool mp4_piece(file,stb,stb_fwd)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_smhd(sd file)
-const sound_smhd_start=!
-    char version=0
-    char *flags={0,0,0}
-    data *reserved=0
-const sound_smhd_size=!-sound_smhd_start
-    data smhd^version
-    data smhd_size=sound_smhd_size
-
-    sd err
-    setcall err mp4_write_or_no(smhd,smhd_size,file)
-    if err!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_soundstbl(sd file)
-    sd bool
-    #sample description
-    str sd="stsd"
-    data sd_fwd^mp4_soundstsd
-    setcall bool mp4_piece(file,sd,sd_fwd)
-    if bool!=1
-        return 0
-    endif
-    #time scale
-    str ts="stts"
-    data ts_fwd^mp4_soundstts
-    setcall bool mp4_piece(file,ts,ts_fwd)
-    if bool!=1
-        return 0
-    endif
-    #sample to chunk
-    str sc="stsc"
-    data sc_fwd^mp4_soundstsc
-    setcall bool mp4_piece(file,sc,sc_fwd)
-    if bool!=1
-        return 0
-    endif
-    #sample size
-    str sz="stsz"
-    data sz_fwd^mp4_soundstsz
-    setcall bool mp4_piece(file,sz,sz_fwd)
-    if bool!=1
-        return 0
-    endif
-    #chunk offset
-    str co="stco"
-    data co_fwd^mp4_soundstco
-    setcall bool mp4_piece(file,co,co_fwd)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_soundstsd(sd file)
-const soundstsd_start=!
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    char *entryCount={0,0,0,1}
-const soundstsd_size=!-soundstsd_start
-    data stsd^version_u8
-    data stsd_size=soundstsd_size
-
-    sd bool
-    setcall bool mp4_write_seek(stsd,stsd_size,file)
-    if bool!=1
-        return 0
-    endif
-
-    str avc="mp4a"
-    data avc_fwd^mp4_mp4a
-    setcall bool mp4_piece(file,avc,avc_fwd)
-    if bool!=1
-        return 0
-    endif
-
-    return 1
-endfunction
-
-#bool
-function mp4_mp4a(sd file)
-const mp4a_start=!
-    char reserved={0,0,0,0,0,0}
-    char *dataReferenceIndex={0,videoId}
-    char *version={0,0}
-    char *revision={0,0}
-    data *vendor=0
-    char *channel_count={0,mp3_channels}
-    char *bitspersample={0,mp3_bitspersample}
-    char *compression_id={0,0}
-    char *packet_size={0,0}
-    char samplerate_hi#2
-    char *samplerate_lo={0,0}
-const mp4a_size=!-mp4a_start
-    data mp4a^reserved
-    data mp4a_size=mp4a_size
-    #
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        import "int_into_short" int_into_short
-        sd sr
-        setcall sr dword_reverse((mp3_samplerate))
-        div sr (0x100*0x100)
-        sd p^samplerate_hi
-        call int_into_short(sr,p)
-    endif
-
-    sd bool
-    setcall bool mp4_write_seek(mp4a,mp4a_size,file)
-    if bool!=(TRUE)
-        return (FALSE)
-    endif
-
-
-    str esds="esds"
-    data esds_fwd^mp4_esds
-    setcall bool mp4_piece(file,esds,esds_fwd)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
-
-
-#bool
-function mp4_esds(sd file)
-const esds_start=!
-    char version=0
-    char *flags={0,0,0}
-    char *GF_ODF_ESD_TAG=3
-    char esd_size#1
-
-    char ESID={0,0}
-    #lengths: dependsOnESID 1,URLString 1,OCRESID 1,streamPriority 5
-    char *info=0
-
-    char *GF_ODF_DCD_TAG=4
-    char dcd_size#1
-        const objectTypeIndication_MPEG1Audio=0x6b
-    char objectTypeIndication=objectTypeIndication_MPEG1Audio
-        const GF_STREAM_AUDIO=5
-    const streamType_value=GF_STREAM_AUDIO
-    const upstream_value=0
-    const upstream_shift=2$1
-    const reserved_value=1
-        const reserved_shift=2$1
-        const upstream_pack=upstream_value*reserved_shift
-        const streamType_shift_pack=reserved_shift*upstream_shift
-        const streamType_pack=streamType_value*streamType_shift_pack
-    char *info=streamType_pack|upstream_pack|reserved_value
-const sound_bufferSizeDB_offset=!-esds_start
-    char bufferSizeDB#3
-    data maxBitrate#1
-    data *avgBitrate#1
-
-    char GF_ODF_SLC_TAG=6
-    char slc_size#1
-        const SLPredef_MP4=2
-    char predefined=SLPredef_MP4
-const esds_size=!-esds_start
-    data esds^version
-    data esds_size=esds_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        const _esds^ESID
-        const esds_^esds
-        set esd_size (esds_-_esds)
-
-        const _dcd^objectTypeIndication
-        const dcd_^GF_ODF_SLC_TAG
-        set dcd_size (dcd_-_dcd)
-
-        const _slc^predefined
-        const slc_^esds
-        set slc_size (slc_-_slc)
-
-        sd err
-        sd file_pos
-        sd ptr_file_pos^file_pos
-
-        setcall err file_tell(file,ptr_file_pos)
-        if err!=(noerror)
-            return 0
-        endif
-
-        setcall err file_write(esds,esds_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-
-        const _DCD^version
-        const DCD_^bufferSizeDB
-        add file_pos (DCD_-_DCD)
-
-        sd off
-        setcall off mp4_sound_esds_items_offset()
-        set off# file_pos
-    else
-        setcall err file_seek_cursor(file,(sound_bufferSizeDB_offset))
-        if err!=(noerror)
-            return 0
-        endif
-        sd bf_sz
-        setcall err file_read(#bf_sz,3,file)
-        if err!=(noerror)
-            return 0
-        endif
-        setcall bf_sz dword_reverse(bf_sz)
-        div bf_sz 0x100
-        call mp4_audio_bufferSz_set(bf_sz)
-        #
-        setcall err file_get_dword(file,#maxBitrate)
-        if err!=(noerror)
-            return 0
-        endif
-        setcall maxBitrate dword_reverse(maxBitrate)
-        div maxBitrate 8
-        call mp4_audio_maxBitrate_set(maxBitrate)
-    endelse
-    return 1
-endfunction
-
-function mp4_sound_esds_items_offset()
-    data offset#1
-    data p^offset
-    return p
-endfunction
-
-#bool
-function mp4_soundstts(sd file)
-const soundstts_start=!
-    char version_u8={0}
-    char *flags_u24={0,0,0}
-    char *list_count={0,0,0,1}
-    data sampleCount#1
-    data sampleDelta#1
-const soundstts_size=!-soundstts_start
-    data stts^version_u8
-    data stts_size=soundstts_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        sd sample_count
-        setcall sample_count mp4_sample_count()
-        setcall sampleCount dword_reverse(sample_count#)
-        setcall sampleDelta dword_reverse((samp_per_frame))
-
-        sd err
-        setcall err file_write(stts,stts_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_soundstsc(sd file)
-const soundstsc_start=!
-    char version={0}
-    char *flags={0,0,0}
-    char *list_count={0,0,0,1}
-    char *firstChunk={0,0,0,1}
-    data samplesPerChunk#1
-    char *sampleDescriptionIndex={0,0,0,1}
-const soundstsc_size=!-soundstsc_start
-    data stsc^version
-    data stsc_size=soundstsc_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        sd sample_count
-        setcall sample_count mp4_sample_count()
-        setcall samplesPerChunk dword_reverse(sample_count#)
-
-        sd err
-        setcall err file_write(stsc,stsc_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_soundstsz(sd file)
-const soundstsz_start=!
-    char version={0}
-    char *flags={0,0,0}
-    data sampleSize#1
-    data sampleCount#1
-const soundstsz_size=!-soundstsz_start
-    data stsz^version
-    data stsz_size=soundstsz_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        sd err
-        sd file_pos
-        sd ptr_file_pos^file_pos
-        setcall err file_tell(file,ptr_file_pos)
-        if err!=(noerror)
-            return 0
-        endif
-        const _stsz_size^version
-        const stsz_size_^sampleSize
-        sd off
-        setcall off mp4_entrysize_offset()
-        add file_pos (stsz_size_-_stsz_size)
-        set off# file_pos
-
-        sd sample_count
-        setcall sample_count mp4_sample_count()
-        setcall sampleCount dword_reverse(sample_count#)
-
-        setcall err file_write(stsz,stsz_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    endif
-    return 1
-endfunction
-
-#bool
-function mp4_soundstco(sd file)
-const soundstco_start=!
-    char version={0}
-    char *flags={0,0,0}
-    char *entries={0,0,0,1}
-const soundstco_offset_pos=!-soundstco_start
-    data offset#1
-const soundstco_size=!-soundstco_start
-    data stco^version
-    data stco_size=soundstco_size
-
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        sd err
-        sd file_pos
-        sd ptr_file_pos^file_pos
-        setcall err file_tell(file,ptr_file_pos)
-        if err!=(noerror)
-            return 0
-        endif
-        const _stco_off^version
-        const stco_off_^offset
-        sd off
-        setcall off mp4_chunkoff()
-        add file_pos (stco_off_-_stco_off)
-        set off# file_pos
-
-        setcall err file_write(stco,stco_size,file)
-        if err!=(noerror)
-            return 0
-        endif
-    else
-        setcall err file_seek_cursor_get_dword_reverse(file,(soundstco_offset_pos),#offset)
-        if err!=(noerror)
-            return 0
-        endif
-        call mp4_audio_offset_set(offset)
-    endelse
-    return 1
-endfunction
-
-#
-#bool
-function mp4_sound_init(sd all_size)
-    #all samples
-    sd all_samples
-    setcall all_samples mp4_all_samples()
-    sd samples
-    set samples all_size
-    div samples (buffer_size)
-    mult samples (buffer_size)
-    div samples (mp3_channels*mp3_bytespersample)
-    set all_samples# samples
-    #duration at the default timescale
-    import "fmul_quad" fmul_quad
-    sd duration
-    call fild_value(samples)
-    sd tscale
-    setcall tscale mp4_tscale()
-    data double_data#2
-    data double^double_data
-    call fild_value(tscale)
-    call fstp_quad(double)
-    call fmul_quad(double)
-    call fild_value((mp3_samplerate))
-    call fstp_quad(double)
-    call fdiv_quad(double)
-    setcall duration mp4_sound_duration()
-    call fstp_quad(double)
-    sd sound_duration
-    setcall sound_duration double_to_int(double)
-    setcall duration# dword_reverse(sound_duration)
-    #sample count
-    div samples (samp_per_frame)
-    sd sample_count
-    setcall sample_count mp4_sample_count()
-    set sample_count# samples
-    #sound or video duration for all file
-    sd video_duration
-    setcall video_duration mp4_duration((value_get))
-    if sound_duration>video_duration
-        sd l_duration
-        setcall l_duration mp4_longest_duration()
-        set l_duration# sound_duration
-    endif
-    #next track
-    call mp4_next_track_set((emptyId))
-    #Not part of MPEG-4 audio profiles
-    call mp4_audio_profile_set(0xfe)
-    #verify for the used format
-    import "stage_sound_channels" stage_sound_channels
-    import "stage_sound_bps" stage_sound_bps
-    import "stage_sound_rate" stage_sound_rate
-    sd ch
-    setcall ch stage_sound_channels((value_get))
-    if ch!=(mp3_channels)
-        str ch_err="Sound with 2 channels required"
-        call texter(ch_err)
-        return 0
-    endif
-    sd bps
-    setcall bps stage_sound_bps((value_get))
-    if bps!=(mp3_bitspersample)
-        str bps_err="Sound with 16 bits-per-sample required"
-        call texter(bps_err)
-        return 0
-    endif
-    sd rate
-    setcall rate stage_sound_rate((value_get))
-    if rate!=(mp3_samplerate)
-        str sr_err="Sound with 48000 sample rate required"
-        call texter(sr_err)
-        return 0
-    endif
-    return 1
-endfunction
-
-
-##extend + write
-import "file_write_forward" file_write_forward
-function mp4_dialog(ss filename)
-    #init expand values
-    sd presence
-    setcall presence mp4_sound_presence()
-    set presence# 0
-    call mp4_video_samples_set(0)
-    call mp4_video_bufferSz_set(0)
-    call mp4_video_offset_set(0)
-    call mp4_audio_samples_set(0)
-    call mp4_audio_bufferSz_set(0)
-    call mp4_audio_maxBitrate_set(0)
-    call mp4_audio_offset_set(0)
-    #
-    call mp4_info_set(0)
-    #
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        #write
-        call file_write_forward(filename,mp4_filewrite)
-    else
-        #expand
-        #mem for temp file path name
-        import "slen" slen
-        sd len
-        setcall len slen(filename)
-        inc len
-        ss mem
-        setcall mem memalloc(len)
-        if mem!=0
-            call mp4_expand_go(filename,mem)
-            call free(mem)
-        endif
-    endelse
-
-    sd info
-    setcall info mp4_info_get()
-    if info==(TRUE)
-        import "save_inform_saved" save_inform_saved
-        call save_inform_saved(filename)
-    endif
-
-    call av_dialog_close()
-endfunction
-
-#bool
-function mp4_write_seek(sd mem,sd size,sd file)
-    sd procedure
-    sd err
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_write)
-        setcall err file_write(mem,size,file)
-        if err!=(noerror)
-            return (FALSE)
-        endif
-    else
-        setcall err file_seek_cursor(file,size)
-        if err!=(noerror)
-            return (FALSE)
-        endif
-    endelse
-    return (TRUE)
-endfunction
-
-#err
-function mp4_write_or_no(sd mem,sd size,sd file)
-    sd procedure
-    setcall procedure mp4_write_expand_get()
-    if procedure==(mp4_expand)
-        return (noerror)
-    endif
-    sd err
-    setcall err file_write(mem,size,file)
-    return err
-endfunction
-
-#implement expand mp4
-#at video:
-#             all sample count at samplecount for a few factors
-#             bufferSz at         max_size
-#at sound:
-#             all pcm samples at all_size(at sound init)
-#             maxBitrate at      max_rate
-#             bufferSizeDB at    max_sound_size
-#at takings, also get the video and sound movie data offset and size
-#at write calculate:
-#             all video size at   all_size for avgbitrate
-#             all sound size at  all_sound_size for avg
-
-function mp4_extend(ss filename)
-    call mp4_write_expand_set((mp4_expand))
-    call av_dialog_run(mp4_dialog,filename)
-endfunction
-import "change_name" change_name
-importx "_remove" remove
-function mp4_expand_go(ss filepath,ss temppath)
-    #rename
-    import "cpymem" cpymem
-    sd len
-    setcall len slen(filepath)
-    dec len
-    call cpymem(temppath,filepath,len)
-    ss cursor
-    set cursor temppath
-    add cursor len
-    set cursor# 0
-    sd ret
-    setcall ret change_name(filepath,temppath)
-    if ret!=0
-        return (void)
-    endif
-    #open read to get previous values
-    import "openfile" openfile
-    importx "_fclose" fclose
-    sd file
-    sd err
-    setcall err openfile(#file,temppath,"rb")
-    if err==(noerror)
-        #info
-        call dialog_modal_texter_draw("Prepare the original file")
-        #store read handle for reading at the other file
-        call mp4_expand_startfile_set(file)
-        sd info
-        #read data
-        sd read_bool
-        setcall read_bool mp4_start(file)
-        if read_bool==(TRUE)
-            #open write
-            call mp4_write_expand_set((mp4_write))
-            call file_write_forward(filepath,mp4_filewrite)
-            #
-            setcall info mp4_info_get()
-        endif
-        #close old file
-        call fclose(file)
-        if read_bool==(FALSE)
-            #change back if was an error at read
-            call change_name(temppath,filepath)
-        else
-            if info==(TRUE)
-                #remove initial file
-                call remove(temppath)
-            endif
-        endelse
-    endif
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mp4_data.oc
@@ -0,0 +1,393 @@
+
+format elfobj
+
+include "../_include/include.h"
+
+function mp4_sizes(sd way,sd arg)
+    data w#1
+    data h#1
+    data wh^w
+    if way=(value_set)
+        import "pixbuf_get_wh" pixbuf_get_wh
+        call pixbuf_get_wh(arg,wh)
+    else
+        set arg# w
+        add arg 4
+        set arg# h
+    endelse
+endfunction
+
+#208284480
+const GF_ISOM_MAC_TIME_OFFSET=2082758400
+import "dword_reverse" dword_reverse
+
+function mp4_times(sd way,sd p_time)
+    import "timeNode" time
+    data f_time#1
+    if way=(value_set)
+        setcall f_time time(0)
+        add f_time (GF_ISOM_MAC_TIME_OFFSET)
+        setcall f_time dword_reverse(f_time)
+    else
+        set p_time# f_time
+        add p_time 4
+        set p_time# f_time
+    endelse
+endfunction
+
+import "stage_file_options_fps" stage_file_options_fps
+import "rule3" rule3
+
+function mp4_tscale()
+    #600 is our default movie TimeScale
+    data t=600
+    return t
+endfunction
+function mp4_duration(sd way)
+    data duration#1
+    if way=(value_set)
+        sd dur
+        setcall dur mp4_SampleCount((value_get))
+        sd timescale
+        setcall timescale mp4_tscale((value_get))
+        sd fps
+        setcall fps stage_file_options_fps()
+        setcall duration rule3(dur,fps,timescale)
+    else
+        return duration
+    endelse
+endfunction
+
+function mp4_timescale(sd way)
+    data timescale#1
+    if way=(value_set)
+        sd fps_1000
+        setcall fps_1000 stage_file_options_fps()
+        #u32 fps_1000 = (u32) (fps*+ 0.5);
+        mult fps_1000 1000
+        if fps_1000=29970
+            set timescale 30000
+        elseif fps_1000=23976
+            set timescale 24000
+        elseif fps_1000=59940
+            set timescale 60000
+        else
+            set timescale fps_1000
+        endelse
+    else
+        return timescale
+    endelse
+endfunction
+function mp4_duration_1000(sd way)
+    data duration#1
+    if way=(value_set)
+        sd dur
+        setcall dur mp4_SampleCount((value_get))
+        sd ts
+        setcall ts mp4_timescale((value_get))
+        sd fps
+        setcall fps stage_file_options_fps()
+        setcall duration rule3(dur,fps,ts)
+    else
+        return duration
+    endelse
+endfunction
+
+
+#function mp4_AVCProfileIndication(sd way,sd value)
+#    data AVCProfileIndication#1
+#    if way==(value_set)
+#        set AVCProfileIndication value
+#    else
+#        return AVCProfileIndication
+#    endelse
+#endfunction
+#function mp4_profile_compatibility(sd way,sd value)
+#    data profile_compatibility#1
+#    if way==(value_set)
+#        set profile_compatibility value
+#    else
+#        return profile_compatibility
+#    endelse
+#endfunction
+#function mp4_AVCLevelIndication(sd way,sd value)
+#    data AVCLevelIndication#1
+#    if way==(value_set)
+#        set AVCLevelIndication value
+#    else
+#        return AVCLevelIndication
+#    endelse
+#endfunction
+
+function mp4_SampleCount(sd way)
+    data SampleCount#1
+    if way=(value_set)
+        import "stage_frame_time_numbers" stage_frame_time_numbers
+        setcall SampleCount stage_frame_time_numbers((stage_frame_time_total_sum))
+        addcall SampleCount mp4_video_samples_get()
+    else
+        return SampleCount
+    endelse
+endfunction
+function mp4_samplesOffset(sd way,sd value)
+    data samplesOffset#1
+    if way=(value_set)
+        set samplesOffset value
+    else
+        return samplesOffset
+    endelse
+endfunction
+function mp4_bufferSzOffset(sd way,sd value)
+    data bufferSzOffset#1
+    if way=(value_set)
+        set bufferSzOffset value
+    else
+        return bufferSzOffset
+    endelse
+endfunction
+function mp4_avgbitrateOffset(sd way,sd value)
+    data avgbitrateOffset#1
+    if way=(value_set)
+        set avgbitrateOffset value
+    else
+        return avgbitrateOffset
+    endelse
+endfunction
+function mp4_chunksOffset(sd way,sd value)
+    data chunkOffsets#1
+    if way=(value_set)
+        set chunkOffsets value
+    else
+        return chunkOffsets
+    endelse
+endfunction
+
+#
+
+function mp4_longest_duration()
+    data longest_duration#1
+    data p^longest_duration
+    return p
+endfunction
+
+function mp4_next_track()
+    data next_track#1
+    data p^next_track
+    return p
+endfunction
+function mp4_next_track_set(sd value)
+    sd nt
+    setcall nt mp4_next_track()
+    set nt# value
+endfunction
+
+function mp4_audio_profile()
+    data profile#1
+    data p^profile
+    return p
+endfunction
+function mp4_audio_profile_set(sd value)
+    sd profile
+    setcall profile mp4_audio_profile()
+    set profile# value
+endfunction
+#
+
+#sound
+
+function mp4_all_samples()
+    data nr#1
+    data p^nr
+    return p
+endfunction
+
+function mp4_sound_duration()
+    data duration#1
+    data p^duration
+    return p
+endfunction
+
+function mp4_sample_count()
+    data sample_count#1
+    data p^sample_count
+    return p
+endfunction
+
+function mp4_entrysize_offset()
+    data offset#1
+    data p^offset
+    return p
+endfunction
+
+function mp4_chunkoff()
+    data offset#1
+    data p^offset
+    return p
+endfunction
+
+
+########expand
+
+function mp4_sound_presence()
+    data sound_presence#1
+    return #sound_presence
+endfunction
+function mp4_sound_presence_get()
+    sd x
+    setcall x mp4_sound_presence()
+    return x#
+endfunction
+#
+function mp4_write_expand()
+    data write_expand#1
+    return #write_expand
+endfunction
+function mp4_write_expand_set(sd value)
+    sd x
+    setcall x mp4_write_expand()
+    set x# value
+endfunction
+function mp4_write_expand_get()
+    sd x
+    setcall x mp4_write_expand()
+    return x#
+endfunction
+#
+function mp4_expand_startfile()
+    data startfile#1
+    return #startfile
+endfunction
+function mp4_expand_startfile_set(sd value)
+    sd x
+    setcall x mp4_expand_startfile()
+    set x# value
+endfunction
+function mp4_expand_startfile_get()
+    sd x
+    setcall x mp4_expand_startfile()
+    return x#
+endfunction
+#
+function mp4_info()
+    data info#1
+    return #info
+endfunction
+function mp4_info_set(sd value)
+    sd x
+    setcall x mp4_info()
+    set x# value
+endfunction
+function mp4_info_get()
+    sd x
+    setcall x mp4_info()
+    return x#
+endfunction
+
+#
+
+function mp4_video_samples()
+    data video_samples#1
+    return #video_samples
+endfunction
+function mp4_video_samples_set(sd value)
+    sd x
+    setcall x mp4_video_samples()
+    set x# value
+endfunction
+function mp4_video_samples_get()
+    sd x
+    setcall x mp4_video_samples()
+    return x#
+endfunction
+#
+function mp4_video_bufferSz()
+    data bufferSz#1
+    return #bufferSz
+endfunction
+function mp4_video_bufferSz_set(sd value)
+    sd x
+    setcall x mp4_video_bufferSz()
+    set x# value
+endfunction
+function mp4_video_bufferSz_get()
+    sd x
+    setcall x mp4_video_bufferSz()
+    return x#
+endfunction
+#
+function mp4_video_offset()
+    data video#1
+    return #video
+endfunction
+function mp4_video_offset_set(sd value)
+    sd x
+    setcall x mp4_video_offset()
+    set x# value
+endfunction
+function mp4_video_offset_get()
+    sd x
+    setcall x mp4_video_offset()
+    return x#
+endfunction
+
+#
+
+function mp4_audio_samples()
+    data audio_samples#1
+    return #audio_samples
+endfunction
+function mp4_audio_samples_set(sd value)
+    sd x
+    setcall x mp4_audio_samples()
+    set x# value
+endfunction
+function mp4_audio_samples_get()
+    sd x
+    setcall x mp4_audio_samples()
+    return x#
+endfunction
+#
+function mp4_audio_bufferSz()
+    data bufferSz#1
+    return #bufferSz
+endfunction
+function mp4_audio_bufferSz_set(sd value)
+    sd x
+    setcall x mp4_audio_bufferSz()
+    set x# value
+endfunction
+function mp4_audio_bufferSz_get()
+    sd x
+    setcall x mp4_audio_bufferSz()
+    return x#
+endfunction
+#
+function mp4_audio_maxBitrate()
+    data maxBitrate#1
+    return #maxBitrate
+endfunction
+function mp4_audio_maxBitrate_set(sd value)
+    sd x
+    setcall x mp4_audio_maxBitrate()
+    set x# value
+endfunction
+function mp4_audio_maxBitrate_get()
+    sd x
+    setcall x mp4_audio_maxBitrate()
+    return x#
+endfunction
+#
+function mp4_audio_offset()
+    data offset#1
+    return #offset
+endfunction
+function mp4_audio_offset_set(sd value)
+    sd x
+    setcall x mp4_audio_offset()
+    set x# value
+endfunction
+function mp4_audio_offset_get()
+    sd x
+    setcall x mp4_audio_offset()
+    return x#
+endfunction
--- ovideo-1.orig/src/media/mp4_data.s
+++ /dev/null
@@ -1,393 +0,0 @@
-
-format elfobj
-
-include "../_include/include.h"
-
-function mp4_sizes(sd way,sd arg)
-    data w#1
-    data h#1
-    data wh^w
-    if way==(value_set)
-        import "pixbuf_get_wh" pixbuf_get_wh
-        call pixbuf_get_wh(arg,wh)
-    else
-        set arg# w
-        add arg 4
-        set arg# h
-    endelse
-endfunction
-
-#208284480
-const GF_ISOM_MAC_TIME_OFFSET=2082758400
-import "dword_reverse" dword_reverse
-
-function mp4_times(sd way,sd p_time)
-    import "timeNode" time
-    data f_time#1
-    if way==(value_set)
-        setcall f_time time(0)
-        add f_time (GF_ISOM_MAC_TIME_OFFSET)
-        setcall f_time dword_reverse(f_time)
-    else
-        set p_time# f_time
-        add p_time 4
-        set p_time# f_time
-    endelse
-endfunction
-
-import "stage_file_options_fps" stage_file_options_fps
-import "rule3" rule3
-
-function mp4_tscale()
-    #600 is our default movie TimeScale
-    data t=600
-    return t
-endfunction
-function mp4_duration(sd way)
-    data duration#1
-    if way==(value_set)
-        sd dur
-        setcall dur mp4_SampleCount((value_get))
-        sd timescale
-        setcall timescale mp4_tscale((value_get))
-        sd fps
-        setcall fps stage_file_options_fps()
-        setcall duration rule3(dur,fps,timescale)
-    else
-        return duration
-    endelse
-endfunction
-
-function mp4_timescale(sd way)
-    data timescale#1
-    if way==(value_set)
-        sd fps_1000
-        setcall fps_1000 stage_file_options_fps()
-        #u32 fps_1000 = (u32) (fps*+ 0.5);
-        mult fps_1000 1000
-        if fps_1000==29970
-            set timescale 30000
-        elseif fps_1000==23976
-            set timescale 24000
-        elseif fps_1000==59940
-            set timescale 60000
-        else
-            set timescale fps_1000
-        endelse
-    else
-        return timescale
-    endelse
-endfunction
-function mp4_duration_1000(sd way)
-    data duration#1
-    if way==(value_set)
-        sd dur
-        setcall dur mp4_SampleCount((value_get))
-        sd ts
-        setcall ts mp4_timescale((value_get))
-        sd fps
-        setcall fps stage_file_options_fps()
-        setcall duration rule3(dur,fps,ts)
-    else
-        return duration
-    endelse
-endfunction
-
-
-#function mp4_AVCProfileIndication(sd way,sd value)
-#    data AVCProfileIndication#1
-#    if way==(value_set)
-#        set AVCProfileIndication value
-#    else
-#        return AVCProfileIndication
-#    endelse
-#endfunction
-#function mp4_profile_compatibility(sd way,sd value)
-#    data profile_compatibility#1
-#    if way==(value_set)
-#        set profile_compatibility value
-#    else
-#        return profile_compatibility
-#    endelse
-#endfunction
-#function mp4_AVCLevelIndication(sd way,sd value)
-#    data AVCLevelIndication#1
-#    if way==(value_set)
-#        set AVCLevelIndication value
-#    else
-#        return AVCLevelIndication
-#    endelse
-#endfunction
-
-function mp4_SampleCount(sd way)
-    data SampleCount#1
-    if way==(value_set)
-        import "stage_frame_time_numbers" stage_frame_time_numbers
-        setcall SampleCount stage_frame_time_numbers((stage_frame_time_total_sum))
-        addcall SampleCount mp4_video_samples_get()
-    else
-        return SampleCount
-    endelse
-endfunction
-function mp4_samplesOffset(sd way,sd value)
-    data samplesOffset#1
-    if way==(value_set)
-        set samplesOffset value
-    else
-        return samplesOffset
-    endelse
-endfunction
-function mp4_bufferSzOffset(sd way,sd value)
-    data bufferSzOffset#1
-    if way==(value_set)
-        set bufferSzOffset value
-    else
-        return bufferSzOffset
-    endelse
-endfunction
-function mp4_avgbitrateOffset(sd way,sd value)
-    data avgbitrateOffset#1
-    if way==(value_set)
-        set avgbitrateOffset value
-    else
-        return avgbitrateOffset
-    endelse
-endfunction
-function mp4_chunksOffset(sd way,sd value)
-    data chunkOffsets#1
-    if way==(value_set)
-        set chunkOffsets value
-    else
-        return chunkOffsets
-    endelse
-endfunction
-
-#
-
-function mp4_longest_duration()
-    data longest_duration#1
-    data p^longest_duration
-    return p
-endfunction
-
-function mp4_next_track()
-    data next_track#1
-    data p^next_track
-    return p
-endfunction
-function mp4_next_track_set(sd value)
-    sd nt
-    setcall nt mp4_next_track()
-    set nt# value
-endfunction
-
-function mp4_audio_profile()
-    data profile#1
-    data p^profile
-    return p
-endfunction
-function mp4_audio_profile_set(sd value)
-    sd profile
-    setcall profile mp4_audio_profile()
-    set profile# value
-endfunction
-#
-
-#sound
-
-function mp4_all_samples()
-    data nr#1
-    data p^nr
-    return p
-endfunction
-
-function mp4_sound_duration()
-    data duration#1
-    data p^duration
-    return p
-endfunction
-
-function mp4_sample_count()
-    data sample_count#1
-    data p^sample_count
-    return p
-endfunction
-
-function mp4_entrysize_offset()
-    data offset#1
-    data p^offset
-    return p
-endfunction
-
-function mp4_chunkoff()
-    data offset#1
-    data p^offset
-    return p
-endfunction
-
-
-########expand
-
-function mp4_sound_presence()
-    data sound_presence#1
-    return #sound_presence
-endfunction
-function mp4_sound_presence_get()
-    sd x
-    setcall x mp4_sound_presence()
-    return x#
-endfunction
-#
-function mp4_write_expand()
-    data write_expand#1
-    return #write_expand
-endfunction
-function mp4_write_expand_set(sd value)
-    sd x
-    setcall x mp4_write_expand()
-    set x# value
-endfunction
-function mp4_write_expand_get()
-    sd x
-    setcall x mp4_write_expand()
-    return x#
-endfunction
-#
-function mp4_expand_startfile()
-    data startfile#1
-    return #startfile
-endfunction
-function mp4_expand_startfile_set(sd value)
-    sd x
-    setcall x mp4_expand_startfile()
-    set x# value
-endfunction
-function mp4_expand_startfile_get()
-    sd x
-    setcall x mp4_expand_startfile()
-    return x#
-endfunction
-#
-function mp4_info()
-    data info#1
-    return #info
-endfunction
-function mp4_info_set(sd value)
-    sd x
-    setcall x mp4_info()
-    set x# value
-endfunction
-function mp4_info_get()
-    sd x
-    setcall x mp4_info()
-    return x#
-endfunction
-
-#
-
-function mp4_video_samples()
-    data video_samples#1
-    return #video_samples
-endfunction
-function mp4_video_samples_set(sd value)
-    sd x
-    setcall x mp4_video_samples()
-    set x# value
-endfunction
-function mp4_video_samples_get()
-    sd x
-    setcall x mp4_video_samples()
-    return x#
-endfunction
-#
-function mp4_video_bufferSz()
-    data bufferSz#1
-    return #bufferSz
-endfunction
-function mp4_video_bufferSz_set(sd value)
-    sd x
-    setcall x mp4_video_bufferSz()
-    set x# value
-endfunction
-function mp4_video_bufferSz_get()
-    sd x
-    setcall x mp4_video_bufferSz()
-    return x#
-endfunction
-#
-function mp4_video_offset()
-    data video#1
-    return #video
-endfunction
-function mp4_video_offset_set(sd value)
-    sd x
-    setcall x mp4_video_offset()
-    set x# value
-endfunction
-function mp4_video_offset_get()
-    sd x
-    setcall x mp4_video_offset()
-    return x#
-endfunction
-
-#
-
-function mp4_audio_samples()
-    data audio_samples#1
-    return #audio_samples
-endfunction
-function mp4_audio_samples_set(sd value)
-    sd x
-    setcall x mp4_audio_samples()
-    set x# value
-endfunction
-function mp4_audio_samples_get()
-    sd x
-    setcall x mp4_audio_samples()
-    return x#
-endfunction
-#
-function mp4_audio_bufferSz()
-    data bufferSz#1
-    return #bufferSz
-endfunction
-function mp4_audio_bufferSz_set(sd value)
-    sd x
-    setcall x mp4_audio_bufferSz()
-    set x# value
-endfunction
-function mp4_audio_bufferSz_get()
-    sd x
-    setcall x mp4_audio_bufferSz()
-    return x#
-endfunction
-#
-function mp4_audio_maxBitrate()
-    data maxBitrate#1
-    return #maxBitrate
-endfunction
-function mp4_audio_maxBitrate_set(sd value)
-    sd x
-    setcall x mp4_audio_maxBitrate()
-    set x# value
-endfunction
-function mp4_audio_maxBitrate_get()
-    sd x
-    setcall x mp4_audio_maxBitrate()
-    return x#
-endfunction
-#
-function mp4_audio_offset()
-    data offset#1
-    return #offset
-endfunction
-function mp4_audio_offset_set(sd value)
-    sd x
-    setcall x mp4_audio_offset()
-    set x# value
-endfunction
-function mp4_audio_offset_get()
-    sd x
-    setcall x mp4_audio_offset()
-    return x#
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-avc_action.oc
@@ -0,0 +1,550 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+import "array_get_int" array_get_int
+import "get_lower" get_lower
+import "shl" shl
+import "sar32" sar
+import "avc_cabac_bypass" avc_cabac_bypass
+
+function avc_residual_write(sd residual,sd ctxBlockCat,sd count,sd idx)
+    sd coeff=0
+    sd value
+    sd array
+    sd last=0
+    data coeff_abs_m1_data#64
+    data i_coeff_abs_m1^coeff_abs_m1_data
+    data coeff_sign_data#64
+    data i_coeff_sign^coeff_sign_data
+
+    sd coeff_abs_m1^coeff_abs_m1_data
+    sd coeff_sign^coeff_sign_data
+    set array residual
+    sd i=0
+    while i!=count
+        set value array#
+        if value!=0
+            set coeff_abs_m1# value
+            if value<0
+                mult coeff_abs_m1# -1
+            endif
+            dec coeff_abs_m1#
+            if value<0
+                set coeff_sign# 1
+            else
+                set coeff_sign# 0
+            endelse
+
+            add coeff_sign (DWORD)
+            add coeff_abs_m1 (DWORD)
+            inc coeff
+            set last i
+        endif
+        add array (DWORD)
+        inc i
+    endwhile
+
+    #if count!=64
+    set value 85
+    addcall value avc_cabac_mb_cbf_ctxidxinc(ctxBlockCat,idx)
+    sd b
+    if coeff!=0
+        set b 1
+    else
+        set b 0
+    endelse
+    import "avc_cabac_decision" avc_cabac_decision
+    call avc_cabac_decision(value,b)
+    if coeff=0
+        return 0
+    endif
+
+    sd index
+    set index count
+    dec index
+    set array residual
+    set i 0
+    while i!=index
+        sd sig_ctx
+        sd last_ctx
+        if ctxBlockCat=5
+            setcall sig_ctx avc_significant_coeff_flag_offset_8x8(i)
+            setcall last_ctx avc_last_significant_coeff_flag_offset_8x8(i)
+        else
+            set sig_ctx i
+            set last_ctx i
+        endelse
+        if array#!=0
+            setcall value avc_significant_coeff_flag_offset(ctxBlockCat)
+            add value sig_ctx
+            add value 105
+            call avc_cabac_decision(value,1)
+            setcall value avc_last_significant_coeff_flag_offset(ctxBlockCat)
+            add value last_ctx
+            add value 166
+            if i=last
+                call avc_cabac_decision(value,1)
+            else
+                call avc_cabac_decision(value,0)
+            endelse
+        else
+            setcall value avc_significant_coeff_flag_offset(ctxBlockCat)
+            add value sig_ctx
+            add value 105
+            call avc_cabac_decision(value,0)
+        endelse
+        if i=last
+            set i index
+        else
+            add array (DWORD)
+            inc i
+        endelse
+    endwhile
+
+    sd abslevelgt1=0
+    sd abslevel1=0
+    set i coeff
+    dec i
+    while i>=0
+        sd ctxIdxInc
+        sd abs_m1
+        setcall abs_m1 array_get_int(i_coeff_abs_m1,i)
+
+        sd prefix
+        set prefix abs_m1
+        if prefix>14
+            set prefix 14
+        endif
+        if abslevelgt1!=0
+            set ctxIdxInc 0
+        else
+            set value abslevel1
+            inc value
+            setcall ctxIdxInc get_lower(4,value)
+        endelse
+        addcall ctxIdxInc avc_coeff_abs_level_m1_offset(ctxBlockCat)
+        sd ctx
+        set ctx ctxIdxInc
+        add ctx 227
+        if prefix=0
+            call avc_cabac_decision(ctx,0)
+        else
+            call avc_cabac_decision(ctx,1)
+            set ctxIdxInc 5
+            addcall ctxIdxInc get_lower(4,abslevelgt1)
+            addcall ctxIdxInc avc_coeff_abs_level_m1_offset(ctxBlockCat)
+            set ctx ctxIdxInc
+            add ctx 227
+            sd j=0
+            sd max
+            set max prefix
+            dec max
+            while j!=max
+                call avc_cabac_decision(ctx,1)
+                inc j
+            endwhile
+            if prefix<14
+                call avc_cabac_decision(ctx,0)
+            endif
+        endelse
+
+        sd sufix
+        if abs_m1>=14
+            sd k=0
+            set sufix abs_m1
+            sub sufix 14
+            sd loop=1
+            while loop=1
+                setcall value shl(1,k)
+                if sufix>=value
+                    call avc_cabac_bypass(1)
+                    sub sufix value
+                    inc k
+                else
+                    set loop 0
+                endelse
+            endwhile
+            call avc_cabac_bypass(0)
+            while k!=0
+                dec k
+                setcall value sar(sufix,k)
+                and value 1
+                call avc_cabac_bypass(value)
+            endwhile
+        endif
+
+        #write sign
+        setcall value array_get_int(i_coeff_sign,i)
+
+        call avc_cabac_bypass(value)
+        if abs_m1=0
+            inc abslevel1
+        else
+            inc abslevelgt1
+        endelse
+        dec i
+    endwhile
+endfunction
+
+function avc_significant_coeff_flag_offset_8x8(sd i)
+    #[63]
+    data flag_offset={0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5}
+    data *          ={4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9,10, 9, 8, 7}
+    data *          ={7, 6,11,12,13,11, 6, 7, 8, 9,14,10, 9, 8, 6,11}
+    data *          ={12,13,11, 6, 9,14,10, 9,11,12,13,11,14,10,12}
+    sd offset^flag_offset
+    mult i 4
+    add offset i
+    return offset#
+endfunction
+function avc_last_significant_coeff_flag_offset_8x8(sd i)
+    #[63]
+    data flag_offset={0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
+    data *          ={2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}
+    data *          ={3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4}
+    data *          ={5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8}
+    sd offset^flag_offset
+    mult i 4
+    add offset i
+    return offset#
+endfunction
+function avc_coeff_abs_level_m1_offset(sd i)
+    #[6]
+    data m1_offset={0, 10, 20, 30, 39, 199}
+    sd offset^m1_offset
+    mult i 4
+    add offset i
+    return offset#
+endfunction
+function avc_significant_coeff_flag_offset(sd i)
+    #[6]
+    data s_offset={0, 15, 29, 44, 47, 297}
+    sd offset^s_offset
+    mult i 4
+    add offset i
+    return offset#
+endfunction
+function avc_last_significant_coeff_flag_offset(sd i)
+    #[6]
+    data l_offset={0, 15, 29, 44, 47, 251}
+    sd offset^l_offset
+    mult i 4
+    add offset i
+    return offset#
+endfunction
+
+#return ctxidxinc
+function avc_cabac_mb_cbf_ctxidxinc(sd ctxBlockCat,sd idx)
+    sd mba_xy=-1
+    sd mbb_xy=-1
+    sd nza=-1
+    sd nzb=-1
+    sd ctx=0
+    sd left_nr
+    sd top_nr
+    sd left
+    sd top
+    sd mb_stride
+    sd type
+    sd value
+    import "avc_mb_nr_left" avc_mb_nr_left
+    import "avc_mb_nr_top" avc_mb_nr_top
+    import "avc_mb_width" avc_mb_width
+    import "avc_mb_data" avc_mb_data
+    setcall left_nr avc_mb_nr_left((value_get))
+    setcall top_nr avc_mb_nr_top((value_get))
+    setcall mb_stride avc_mb_width((value_get))
+    import "avc_block_idx_x" avc_block_idx_x
+    import "avc_block_idx_y" avc_block_idx_y
+    import "avc_block_idx_xy" avc_block_idx_xy
+    import "avc_mb_non_zero" avc_mb_non_zero
+    sd x
+    sd y
+    sd i8x8a
+    sd i8x8b
+    sd idx_x
+    sd idx_y
+    sd cbp
+    if ctxBlockCat=0
+        if left_nr>0
+            #i_mba_xy = h->mb.i_mb_xy -1; or not -1
+            set mba_xy 0
+
+            set left left_nr
+            dec left
+            setcall type avc_mb_data((value_item),(avc_mb_type_offset),left,top_nr)
+            if type=(avc_I_16x16)
+                setcall nza avc_mb_data((value_item),(avc_mb_cbp_offset),left,top_nr)
+                and nza 0x100
+            endif
+        endif
+        if top_nr>0
+            #i_mbb_xy = h->mb.i_mb_xy - h->mb.i_mb_stride; or not -1
+            set mbb_xy 0
+
+            set top top_nr
+            dec top
+            setcall type avc_mb_data((value_item),(avc_mb_type_offset),left_nr,top)
+            if type=(avc_I_16x16)
+                setcall nzb avc_mb_data((value_item),(avc_mb_cbp_offset),left_nr,top)
+                and nzb 0x100
+            endif
+        endif
+    elseif ctxBlockCat<3
+        setcall x avc_block_idx_x(idx)
+        setcall y avc_block_idx_y(idx)
+        set left left_nr
+        if x>0
+            set mba_xy 0
+        elseif left_nr!=0
+            set mba_xy 0
+            dec left
+        endelseif
+        set top top_nr
+        if y>0
+            set mbb_xy 0
+        elseif top_nr!=0
+            set mbb_xy 0
+            dec top
+        endelseif
+        if mba_xy!=-1
+            set idx_x x
+            dec idx_x
+            and idx_x 0x03
+            setcall i8x8a avc_block_idx_xy(idx_x,y)
+            div i8x8a 4
+            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left,top_nr)
+            and cbp 0x0f
+            setcall cbp sar(cbp,i8x8a)
+            if cbp!=0
+                setcall nza avc_scan8(idx)
+                dec nza
+                setcall nza avc_mb_non_zero((value_get),nza)
+            endif
+        endif
+        if mbb_xy!=-1
+            set idx_y y
+            dec idx_y
+            and idx_y 0x03
+            setcall i8x8b avc_block_idx_xy(x,idx_y)
+            div i8x8b 4
+            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left_nr,top)
+            and cbp 0x0f
+            setcall cbp sar(cbp,i8x8b)
+            if cbp!=0
+                setcall nzb avc_scan8(idx)
+                sub nzb 8
+                setcall nzb avc_mb_non_zero((value_get),nzb)
+            endif
+        endif
+    elseif ctxBlockCat=3
+        if left_nr!=0
+            set mba_xy 0
+            set left left_nr
+            dec left
+            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left,top_nr)
+            set value cbp
+            and value 0x30
+            if value!=0
+                set value idx
+                add value 8
+                setcall value shl(0x02,value)
+                and cbp value
+                set nza cbp
+            endif
+        endif
+        if top_nr!=0
+            set mbb_xy 0
+            set top top_nr
+            dec top
+            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left_nr,top)
+            set value cbp
+            and value 0x30
+            if value!=0
+                set value idx
+                add value 8
+                setcall value shl(0x02,value)
+                and cbp value
+                set nzb cbp
+            endif
+        endif
+    else
+        #if ctxBlockCat==4
+        import "rest" rest
+        sd idx_c
+        setcall idx_c rest(idx,4)
+
+        set left left_nr
+        if idx_c=1
+            set mba_xy 0
+        elseif idx_c=3
+            set mba_xy 0
+        elseif left_nr!=0
+            set mba_xy 0
+            dec left
+        endelseif
+
+        set top top_nr
+        if idx_c=2
+            set mbb_xy 0
+        elseif idx_c=3
+            set mbb_xy 0
+        elseif top_nr!=0
+            set mbb_xy 0
+            dec top
+        endelseif
+
+        if mba_xy!=-1
+            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left,top_nr)
+            and cbp 0x30
+            if cbp=0x20
+                set idx_x idx
+                add idx_x 16
+                setcall nza avc_scan8(idx_x)
+                dec nza
+                setcall nza avc_mb_non_zero((value_get),nza)
+            endif
+        endif
+        if mbb_xy!=-1
+            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left_nr,top)
+            and cbp 0x30
+            if cbp=0x20
+                set idx_y idx
+                add idx_y 16
+                setcall nzb avc_scan8(idx_y)
+                sub nzb 8
+                setcall nzb avc_mb_non_zero((value_get),nzb)
+            endif
+        endif
+    endelse
+    sd ctx_add=0
+    if mba_xy<0
+        set ctx_add 1
+    elseif nza>0
+        set ctx_add 1
+    endelseif
+    if ctx_add=1
+        inc ctx
+    endif
+    set ctx_add 0
+    if mbb_xy<0
+        set ctx_add 1
+    elseif nzb>0
+        set ctx_add 1
+    endelseif
+    if ctx_add=1
+        add ctx 2
+    endif
+    set value ctxBlockCat
+    mult value 4
+    add value ctx
+    return value
+endfunction
+
+function avc_scan8(sd index)
+    data x264_scan8={1*8+4,1*8+5,2*8+4,2*8+5}
+    data *              ={1*8+6,1*8+7,2*8+6,2*8+7}
+    data *              ={3*8+4,3*8+5,4*8+4,4*8+5}
+    data *              ={3*8+6,3*8+7,4*8+6,4*8+7}
+    data *Cb            ={1*8+1,1*8+2}
+    data *              ={2*8+1,2*8+2}
+    data *Cr            ={4*8+1,4*8+2}
+    data *              ={5*8+1,5*8+2}
+    #   0 1 2 3 4 5 6 7
+    # 0
+    # 1   B B   L L L L
+    # 2   B B   L L L L
+    # 3         L L L L
+    # 4   R R   L L L L
+    # 5   R R
+
+    sd scan8^x264_scan8
+    mult index 4
+    add scan8 index
+    return scan8#
+endfunction
+
+function avc_mb_cache_init(sd x,sd y,sd type)
+    sd index
+    sd i
+    sd cache_value
+    sd pos
+
+    call avc_mb_data((value_write),(avc_mb_type_offset),x,y,type)
+
+    if type=(avc_P_SKIP)
+        call avc_mb_data((value_write),(avc_mb_cbp_offset),x,y,0)
+        set i 0
+        while i!=(avc_mb_cache_units)
+            setcall pos avc_scan8(i)
+            call avc_mb_non_zero((value_set),pos,0)
+            inc i
+        endwhile
+        return (void)
+    endif
+
+    sd left
+    set left x
+    dec left
+    sd top
+    set top y
+    dec top
+
+    data prev_top_values={10,11,14,15,16+2,16+3,16+4+2,16+4+3}
+    sd prev_top_cache^prev_top_values
+    data top_values={0,1,4,5,16+0,16+1,16+4+0,16+4+1}
+    sd top_cache^top_values
+    set cache_value 0x80
+    set i 0
+    while i!=8
+        setcall index avc_scan8(top_cache#)
+        sub index 8
+
+        if y>0
+            set pos prev_top_cache#
+            add prev_top_cache (DWORD)
+            setcall cache_value avc_mb_data((value_item),(avc_mb_cache_offset),x,top,pos)
+        endif
+        call avc_mb_non_zero((value_set),index,cache_value)
+
+        add top_cache (DWORD)
+        inc i
+    endwhile
+
+    data prev_left_values={5,7,13,15,16+1,16+3,16+4+1,16+4+3}
+    sd prev_left_cache^prev_left_values
+    data left_values={0,2,8,10,16+0,16+2,16+4+0,16+4+2}
+    sd left_cache^left_values
+    set cache_value 0x80
+    set i 0
+    while i!=8
+        setcall index avc_scan8(left_cache#)
+        dec index
+
+        if x>0
+            set pos prev_left_cache#
+            add prev_left_cache (DWORD)
+            setcall cache_value avc_mb_data((value_item),(avc_mb_cache_offset),left,y,pos)
+        endif
+        call avc_mb_non_zero((value_set),index,cache_value)
+
+        add left_cache (DWORD)
+        inc i
+    endwhile
+endfunction
+
+function avc_mb_cache_save(sd x,sd y)
+    sd pos
+    sd i=0
+    while i!=(avc_mb_cache_units)
+        setcall pos avc_scan8(i)
+        sd nz
+        setcall nz avc_mb_non_zero((value_get),pos)
+        call avc_mb_data((value_write),(avc_mb_cache_offset),x,y,i,nz)
+        inc i
+    endwhile
+endfunction
--- ovideo-1.orig/src/media/mpeg-avc_action.s
+++ /dev/null
@@ -1,550 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-import "array_get_int" array_get_int
-import "get_lower" get_lower
-import "shl" shl
-import "sar32" sar
-import "avc_cabac_bypass" avc_cabac_bypass
-
-function avc_residual_write(sd residual,sd ctxBlockCat,sd count,sd idx)
-    sd coeff=0
-    sd value
-    sd array
-    sd last=0
-    data coeff_abs_m1_data#64
-    data i_coeff_abs_m1^coeff_abs_m1_data
-    data coeff_sign_data#64
-    data i_coeff_sign^coeff_sign_data
-
-    sd coeff_abs_m1^coeff_abs_m1_data
-    sd coeff_sign^coeff_sign_data
-    set array residual
-    sd i=0
-    while i!=count
-        set value array#
-        if value!=0
-            set coeff_abs_m1# value
-            if value<0
-                mult coeff_abs_m1# -1
-            endif
-            dec coeff_abs_m1#
-            if value<0
-                set coeff_sign# 1
-            else
-                set coeff_sign# 0
-            endelse
-
-            add coeff_sign (DWORD)
-            add coeff_abs_m1 (DWORD)
-            inc coeff
-            set last i
-        endif
-        add array (DWORD)
-        inc i
-    endwhile
-
-    #if count!=64
-    set value 85
-    addcall value avc_cabac_mb_cbf_ctxidxinc(ctxBlockCat,idx)
-    sd b
-    if coeff!=0
-        set b 1
-    else
-        set b 0
-    endelse
-    import "avc_cabac_decision" avc_cabac_decision
-    call avc_cabac_decision(value,b)
-    if coeff==0
-        return 0
-    endif
-
-    sd index
-    set index count
-    dec index
-    set array residual
-    set i 0
-    while i!=index
-        sd sig_ctx
-        sd last_ctx
-        if ctxBlockCat==5
-            setcall sig_ctx avc_significant_coeff_flag_offset_8x8(i)
-            setcall last_ctx avc_last_significant_coeff_flag_offset_8x8(i)
-        else
-            set sig_ctx i
-            set last_ctx i
-        endelse
-        if array#!=0
-            setcall value avc_significant_coeff_flag_offset(ctxBlockCat)
-            add value sig_ctx
-            add value 105
-            call avc_cabac_decision(value,1)
-            setcall value avc_last_significant_coeff_flag_offset(ctxBlockCat)
-            add value last_ctx
-            add value 166
-            if i==last
-                call avc_cabac_decision(value,1)
-            else
-                call avc_cabac_decision(value,0)
-            endelse
-        else
-            setcall value avc_significant_coeff_flag_offset(ctxBlockCat)
-            add value sig_ctx
-            add value 105
-            call avc_cabac_decision(value,0)
-        endelse
-        if i==last
-            set i index
-        else
-            add array (DWORD)
-            inc i
-        endelse
-    endwhile
-
-    sd abslevelgt1=0
-    sd abslevel1=0
-    set i coeff
-    dec i
-    while i>=0
-        sd ctxIdxInc
-        sd abs_m1
-        setcall abs_m1 array_get_int(i_coeff_abs_m1,i)
-
-        sd prefix
-        set prefix abs_m1
-        if prefix>14
-            set prefix 14
-        endif
-        if abslevelgt1!=0
-            set ctxIdxInc 0
-        else
-            set value abslevel1
-            inc value
-            setcall ctxIdxInc get_lower(4,value)
-        endelse
-        addcall ctxIdxInc avc_coeff_abs_level_m1_offset(ctxBlockCat)
-        sd ctx
-        set ctx ctxIdxInc
-        add ctx 227
-        if prefix==0
-            call avc_cabac_decision(ctx,0)
-        else
-            call avc_cabac_decision(ctx,1)
-            set ctxIdxInc 5
-            addcall ctxIdxInc get_lower(4,abslevelgt1)
-            addcall ctxIdxInc avc_coeff_abs_level_m1_offset(ctxBlockCat)
-            set ctx ctxIdxInc
-            add ctx 227
-            sd j=0
-            sd max
-            set max prefix
-            dec max
-            while j!=max
-                call avc_cabac_decision(ctx,1)
-                inc j
-            endwhile
-            if prefix<14
-                call avc_cabac_decision(ctx,0)
-            endif
-        endelse
-
-        sd sufix
-        if abs_m1>=14
-            sd k=0
-            set sufix abs_m1
-            sub sufix 14
-            sd loop=1
-            while loop==1
-                setcall value shl(1,k)
-                if sufix>=value
-                    call avc_cabac_bypass(1)
-                    sub sufix value
-                    inc k
-                else
-                    set loop 0
-                endelse
-            endwhile
-            call avc_cabac_bypass(0)
-            while k!=0
-                dec k
-                setcall value sar(sufix,k)
-                and value 1
-                call avc_cabac_bypass(value)
-            endwhile
-        endif
-
-        #write sign
-        setcall value array_get_int(i_coeff_sign,i)
-
-        call avc_cabac_bypass(value)
-        if abs_m1==0
-            inc abslevel1
-        else
-            inc abslevelgt1
-        endelse
-        dec i
-    endwhile
-endfunction
-
-function avc_significant_coeff_flag_offset_8x8(sd i)
-    #[63]
-    data flag_offset={0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5}
-    data *          ={4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9,10, 9, 8, 7}
-    data *          ={7, 6,11,12,13,11, 6, 7, 8, 9,14,10, 9, 8, 6,11}
-    data *          ={12,13,11, 6, 9,14,10, 9,11,12,13,11,14,10,12}
-    sd offset^flag_offset
-    mult i 4
-    add offset i
-    return offset#
-endfunction
-function avc_last_significant_coeff_flag_offset_8x8(sd i)
-    #[63]
-    data flag_offset={0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
-    data *          ={2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}
-    data *          ={3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4}
-    data *          ={5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8}
-    sd offset^flag_offset
-    mult i 4
-    add offset i
-    return offset#
-endfunction
-function avc_coeff_abs_level_m1_offset(sd i)
-    #[6]
-    data m1_offset={0, 10, 20, 30, 39, 199}
-    sd offset^m1_offset
-    mult i 4
-    add offset i
-    return offset#
-endfunction
-function avc_significant_coeff_flag_offset(sd i)
-    #[6]
-    data s_offset={0, 15, 29, 44, 47, 297}
-    sd offset^s_offset
-    mult i 4
-    add offset i
-    return offset#
-endfunction
-function avc_last_significant_coeff_flag_offset(sd i)
-    #[6]
-    data l_offset={0, 15, 29, 44, 47, 251}
-    sd offset^l_offset
-    mult i 4
-    add offset i
-    return offset#
-endfunction
-
-#return ctxidxinc
-function avc_cabac_mb_cbf_ctxidxinc(sd ctxBlockCat,sd idx)
-    sd mba_xy=-1
-    sd mbb_xy=-1
-    sd nza=-1
-    sd nzb=-1
-    sd ctx=0
-    sd left_nr
-    sd top_nr
-    sd left
-    sd top
-    sd mb_stride
-    sd type
-    sd value
-    import "avc_mb_nr_left" avc_mb_nr_left
-    import "avc_mb_nr_top" avc_mb_nr_top
-    import "avc_mb_width" avc_mb_width
-    import "avc_mb_data" avc_mb_data
-    setcall left_nr avc_mb_nr_left((value_get))
-    setcall top_nr avc_mb_nr_top((value_get))
-    setcall mb_stride avc_mb_width((value_get))
-    import "avc_block_idx_x" avc_block_idx_x
-    import "avc_block_idx_y" avc_block_idx_y
-    import "avc_block_idx_xy" avc_block_idx_xy
-    import "avc_mb_non_zero" avc_mb_non_zero
-    sd x
-    sd y
-    sd i8x8a
-    sd i8x8b
-    sd idx_x
-    sd idx_y
-    sd cbp
-    if ctxBlockCat==0
-        if left_nr>0
-            #i_mba_xy = h->mb.i_mb_xy -1; or not -1
-            set mba_xy 0
-
-            set left left_nr
-            dec left
-            setcall type avc_mb_data((value_item),(avc_mb_type_offset),left,top_nr)
-            if type==(avc_I_16x16)
-                setcall nza avc_mb_data((value_item),(avc_mb_cbp_offset),left,top_nr)
-                and nza 0x100
-            endif
-        endif
-        if top_nr>0
-            #i_mbb_xy = h->mb.i_mb_xy - h->mb.i_mb_stride; or not -1
-            set mbb_xy 0
-
-            set top top_nr
-            dec top
-            setcall type avc_mb_data((value_item),(avc_mb_type_offset),left_nr,top)
-            if type==(avc_I_16x16)
-                setcall nzb avc_mb_data((value_item),(avc_mb_cbp_offset),left_nr,top)
-                and nzb 0x100
-            endif
-        endif
-    elseif ctxBlockCat<3
-        setcall x avc_block_idx_x(idx)
-        setcall y avc_block_idx_y(idx)
-        set left left_nr
-        if x>0
-            set mba_xy 0
-        elseif left_nr!=0
-            set mba_xy 0
-            dec left
-        endelseif
-        set top top_nr
-        if y>0
-            set mbb_xy 0
-        elseif top_nr!=0
-            set mbb_xy 0
-            dec top
-        endelseif
-        if mba_xy!=-1
-            set idx_x x
-            dec idx_x
-            and idx_x 0x03
-            setcall i8x8a avc_block_idx_xy(idx_x,y)
-            div i8x8a 4
-            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left,top_nr)
-            and cbp 0x0f
-            setcall cbp sar(cbp,i8x8a)
-            if cbp!=0
-                setcall nza avc_scan8(idx)
-                dec nza
-                setcall nza avc_mb_non_zero((value_get),nza)
-            endif
-        endif
-        if mbb_xy!=-1
-            set idx_y y
-            dec idx_y
-            and idx_y 0x03
-            setcall i8x8b avc_block_idx_xy(x,idx_y)
-            div i8x8b 4
-            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left_nr,top)
-            and cbp 0x0f
-            setcall cbp sar(cbp,i8x8b)
-            if cbp!=0
-                setcall nzb avc_scan8(idx)
-                sub nzb 8
-                setcall nzb avc_mb_non_zero((value_get),nzb)
-            endif
-        endif
-    elseif ctxBlockCat==3
-        if left_nr!=0
-            set mba_xy 0
-            set left left_nr
-            dec left
-            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left,top_nr)
-            set value cbp
-            and value 0x30
-            if value!=0
-                set value idx
-                add value 8
-                setcall value shl(0x02,value)
-                and cbp value
-                set nza cbp
-            endif
-        endif
-        if top_nr!=0
-            set mbb_xy 0
-            set top top_nr
-            dec top
-            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left_nr,top)
-            set value cbp
-            and value 0x30
-            if value!=0
-                set value idx
-                add value 8
-                setcall value shl(0x02,value)
-                and cbp value
-                set nzb cbp
-            endif
-        endif
-    else
-        #if ctxBlockCat==4
-        import "rest" rest
-        sd idx_c
-        setcall idx_c rest(idx,4)
-
-        set left left_nr
-        if idx_c==1
-            set mba_xy 0
-        elseif idx_c==3
-            set mba_xy 0
-        elseif left_nr!=0
-            set mba_xy 0
-            dec left
-        endelseif
-
-        set top top_nr
-        if idx_c==2
-            set mbb_xy 0
-        elseif idx_c==3
-            set mbb_xy 0
-        elseif top_nr!=0
-            set mbb_xy 0
-            dec top
-        endelseif
-
-        if mba_xy!=-1
-            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left,top_nr)
-            and cbp 0x30
-            if cbp==0x20
-                set idx_x idx
-                add idx_x 16
-                setcall nza avc_scan8(idx_x)
-                dec nza
-                setcall nza avc_mb_non_zero((value_get),nza)
-            endif
-        endif
-        if mbb_xy!=-1
-            setcall cbp avc_mb_data((value_item),(avc_mb_cbp_offset),left_nr,top)
-            and cbp 0x30
-            if cbp==0x20
-                set idx_y idx
-                add idx_y 16
-                setcall nzb avc_scan8(idx_y)
-                sub nzb 8
-                setcall nzb avc_mb_non_zero((value_get),nzb)
-            endif
-        endif
-    endelse
-    sd ctx_add=0
-    if mba_xy<0
-        set ctx_add 1
-    elseif nza>0
-        set ctx_add 1
-    endelseif
-    if ctx_add==1
-        inc ctx
-    endif
-    set ctx_add 0
-    if mbb_xy<0
-        set ctx_add 1
-    elseif nzb>0
-        set ctx_add 1
-    endelseif
-    if ctx_add==1
-        add ctx 2
-    endif
-    set value ctxBlockCat
-    mult value 4
-    add value ctx
-    return value
-endfunction
-
-function avc_scan8(sd index)
-    data x264_scan8={1*8+4,1*8+5,2*8+4,2*8+5}
-    data *              ={1*8+6,1*8+7,2*8+6,2*8+7}
-    data *              ={3*8+4,3*8+5,4*8+4,4*8+5}
-    data *              ={3*8+6,3*8+7,4*8+6,4*8+7}
-    data *Cb            ={1*8+1,1*8+2}
-    data *              ={2*8+1,2*8+2}
-    data *Cr            ={4*8+1,4*8+2}
-    data *              ={5*8+1,5*8+2}
-    #   0 1 2 3 4 5 6 7
-    # 0
-    # 1   B B   L L L L
-    # 2   B B   L L L L
-    # 3         L L L L
-    # 4   R R   L L L L
-    # 5   R R
-
-    sd scan8^x264_scan8
-    mult index 4
-    add scan8 index
-    return scan8#
-endfunction
-
-function avc_mb_cache_init(sd x,sd y,sd type)
-    sd index
-    sd i
-    sd cache_value
-    sd pos
-
-    call avc_mb_data((value_write),(avc_mb_type_offset),x,y,type)
-
-    if type==(avc_P_SKIP)
-        call avc_mb_data((value_write),(avc_mb_cbp_offset),x,y,0)
-        set i 0
-        while i!=(avc_mb_cache_units)
-            setcall pos avc_scan8(i)
-            call avc_mb_non_zero((value_set),pos,0)
-            inc i
-        endwhile
-        return (void)
-    endif
-
-    sd left
-    set left x
-    dec left
-    sd top
-    set top y
-    dec top
-
-    data prev_top_values={10,11,14,15,16+2,16+3,16+4+2,16+4+3}
-    sd prev_top_cache^prev_top_values
-    data top_values={0,1,4,5,16+0,16+1,16+4+0,16+4+1}
-    sd top_cache^top_values
-    set cache_value 0x80
-    set i 0
-    while i!=8
-        setcall index avc_scan8(top_cache#)
-        sub index 8
-
-        if y>0
-            set pos prev_top_cache#
-            add prev_top_cache (DWORD)
-            setcall cache_value avc_mb_data((value_item),(avc_mb_cache_offset),x,top,pos)
-        endif
-        call avc_mb_non_zero((value_set),index,cache_value)
-
-        add top_cache (DWORD)
-        inc i
-    endwhile
-
-    data prev_left_values={5,7,13,15,16+1,16+3,16+4+1,16+4+3}
-    sd prev_left_cache^prev_left_values
-    data left_values={0,2,8,10,16+0,16+2,16+4+0,16+4+2}
-    sd left_cache^left_values
-    set cache_value 0x80
-    set i 0
-    while i!=8
-        setcall index avc_scan8(left_cache#)
-        dec index
-
-        if x>0
-            set pos prev_left_cache#
-            add prev_left_cache (DWORD)
-            setcall cache_value avc_mb_data((value_item),(avc_mb_cache_offset),left,y,pos)
-        endif
-        call avc_mb_non_zero((value_set),index,cache_value)
-
-        add left_cache (DWORD)
-        inc i
-    endwhile
-endfunction
-
-function avc_mb_cache_save(sd x,sd y)
-    sd pos
-    sd i=0
-    while i!=(avc_mb_cache_units)
-        setcall pos avc_scan8(i)
-        sd nz
-        setcall nz avc_mb_non_zero((value_get),pos)
-        call avc_mb_data((value_write),(avc_mb_cache_offset),x,y,i,nz)
-        inc i
-    endwhile
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-avc_block.oc
@@ -0,0 +1,1336 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+const luma_count=16
+#const chroma_count=8
+
+#CQM_4IY = 0,
+#CQM_4IC = 2,
+
+function avc_block(sd Y,sd U,sd V,sd x,sd y)
+    #encode luma
+    import "avc_residual_ac" avc_residual_ac
+    sd residual_ac
+    setcall residual_ac avc_residual_ac((value_get))
+    import "avc_residual_luma" avc_residual_luma
+    sd residual_luma_dc
+    setcall residual_luma_dc avc_residual_luma()
+    call avc_enc_16x16(Y,residual_ac,residual_luma_dc)
+    #encode chroma
+    import "avc_residual_ac_ch" avc_residual_ac_ch
+    import "avc_residual_ac_u" avc_residual_ac_u
+    import "avc_residual_ac_v" avc_residual_ac_v
+    sd residual_ac_ch
+    sd residual_ac_u
+    sd residual_ac_v
+    setcall residual_ac_ch avc_residual_ac_ch()
+    setcall residual_ac_u avc_residual_ac_u()
+    setcall residual_ac_v avc_residual_ac_v()
+    import "avc_chroma_dc_u" avc_chroma_dc_u
+    import "avc_chroma_dc_v" avc_chroma_dc_v
+    sd chroma_dc_u
+    sd chroma_dc_v
+    setcall chroma_dc_u avc_chroma_dc_u()
+    setcall chroma_dc_v avc_chroma_dc_v()
+    call avc_enc_8x8_chroma(U,V,residual_ac_u,residual_ac_v,chroma_dc_u,chroma_dc_v)
+    #
+    import "avc_scan8" avc_scan8
+    sd i
+    sd value
+    #calculate luma
+    import "avc_mb_non_zero" avc_mb_non_zero
+    set i 0
+    sd nz
+    sd cbp_luma=0
+    while i!=16
+        setcall nz avc_array_non_zero_count(residual_ac,15)
+        if nz>0
+            set cbp_luma 0x0f
+        endif
+        setcall value avc_scan8(i)
+        call avc_mb_non_zero((value_set),value,nz)
+        add residual_ac (15*DWORD)
+        inc i
+    endwhile
+    import "avc_cbp_luma" avc_cbp_luma
+    call avc_cbp_luma((value_set),cbp_luma)
+    #calculate chroma
+    sd cbp_chroma=0
+    set i 0
+    while i!=8
+        setcall nz avc_array_non_zero_count(residual_ac_ch,15)
+        if nz>0
+            set cbp_chroma 0x02
+        endif
+        set value i
+        add value 16
+        setcall value avc_scan8(value)
+        call avc_mb_non_zero((value_set),value,nz)
+        add residual_ac_ch (15*DWORD)
+        inc i
+    endwhile
+    if cbp_chroma=0
+        setcall value avc_array_non_zero_count(chroma_dc_u,4)
+        addcall value avc_array_non_zero_count(chroma_dc_v,4)
+        if value>0
+            set cbp_chroma 1
+        endif
+    endif
+    import "avc_cbp_chroma" avc_cbp_chroma
+    call avc_cbp_chroma((value_set),cbp_chroma)
+        #for cbp
+    sd cbp_dc
+    setcall value avc_array_non_zero_count(residual_luma_dc,16)
+    if value>0
+        set cbp_dc 0x01
+    else
+        set cbp_dc 0x00
+    endelse
+    setcall value avc_array_non_zero_count(chroma_dc_u,4)
+    if value>0
+        or cbp_dc 0x02
+    endif
+    setcall value avc_array_non_zero_count(chroma_dc_v,4)
+    if value>0
+        or cbp_dc 0x04
+    endif
+    #store cbp
+    import "avc_mb_data" avc_mb_data
+    import "shl" shl
+    sd cbp
+    set cbp cbp_luma
+    orcall cbp shl(cbp_chroma,4)
+    orcall cbp shl(cbp_dc,8)
+    call avc_mb_data((value_write),(avc_mb_cbp_offset),x,y,cbp)
+endfunction
+
+import "avc_width" avc_width
+
+function avc_enc_16x16(sd Y,sd residual_ac,sd residual_luma)
+    char dct_data#16*4*4*WORD
+    data d_dct^dct_data
+    char dct_luma_data#4*4*WORD
+    data d_dct_luma^dct_luma_data
+    sd stride
+    setcall stride avc_width((value_get))
+
+    #ac
+    call avc_enc_block(Y,residual_ac,d_dct,8,d_dct_luma,16,stride)
+    #dc
+    call avc_dct4x4dc(d_dct_luma)
+    call avc_quant(d_dct_luma,4,(TRUE))
+    call avc_scan_zigzag_4x4full(d_dct_luma,residual_luma)
+    #
+    call avc_idct_dc(d_dct_luma)
+    call avc_dequant_dc(d_dct_luma)
+    call avc_dc_coeff_inv(d_dct_luma,d_dct,16,4)
+
+    sd dct_ix
+    sd p_dct^dct_ix
+    set dct_ix d_dct
+    sd index=0
+    sd p_index^index
+    sd Y_deq
+    setcall Y_deq avc_input_dequant_move(Y)
+    call avc_dct_add(p_dct,Y_deq,8,stride,p_index)
+endfunction
+
+function avc_enc_block(sd plane,sd residual,sd dct,sd coef,sd dct_lum_ch,sd mb_count,sd stride)
+    #coef: rounding down to pieces at sub
+    #      =2*arraysize for avc_dc_coeff; [0][0]
+    #      =block_size/2
+    sd block_size
+    set block_size coef
+    mult block_size 2
+    sd dct_ix
+    sd p_dct^dct_ix
+    set dct_ix dct
+    call avc_dct_pred((value_set),plane,stride,block_size)
+    call avc_dct_sub(p_dct,plane,coef,stride)
+
+    sd array_size
+    set array_size coef
+    div array_size 2
+    sd i=0
+    while i!=mb_count
+        call avc_dc_coeff(dct_lum_ch,dct,i,array_size)
+        call avc_quant(dct,4,(FALSE))
+        call avc_scan_zigzag_4x4(dct,residual)
+        call avc_dequant(dct)
+        add residual (15*DWORD)
+        add dct (4*4*WORD)
+        inc i
+    endwhile
+endfunction
+
+import "avc_dct_sub_pred_index" avc_dct_sub_pred_index
+
+function avc_dct_sub(sd p_dct,ss plane,sd coef,sd stride)
+    if coef!=2
+        call avc_dct_sub_row(p_dct,plane,coef,stride)
+        sd second_part
+        set second_part stride
+        mult second_part coef
+        add plane second_part
+        call avc_dct_sub_row(p_dct,plane,coef,stride)
+    else
+        sd value
+        char d_data#4*4*WORD
+        char tmp_data#4*4*WORD
+        data d^d_data
+        data tmp^tmp_data
+        import "sar32" sar
+        ss dif
+        set dif d
+        sd y=0
+        sd tempPlane
+        set tempPlane plane
+        while y!=4
+            sd x=0
+            while x!=4
+                set value plane#
+                subcall value avc_dct_pred((value_get))
+                set dif# value
+                setcall value sar(value,8)
+                inc dif
+                set dif# value
+                inc dif
+                inc plane
+                inc x
+            endwhile
+            add tempPlane stride
+            set plane tempPlane
+            inc y
+        endwhile
+
+        sd pos
+        sd i=0
+        import "array_get_int16" array_get_int16
+        import "array_set_word_bi" array_set_word_bi
+        import "array_bi_index" array_bi_index
+        while i!=4
+            sd s03
+            sd s12
+            sd d03
+            sd d12
+
+            setcall pos array_bi_index(i,4,0)
+            setcall s03 array_get_int16(d,pos)
+            setcall pos array_bi_index(i,4,3)
+            addcall s03 array_get_int16(d,pos)
+
+            setcall pos array_bi_index(i,4,1)
+            setcall s12 array_get_int16(d,pos)
+            setcall pos array_bi_index(i,4,2)
+            addcall s12 array_get_int16(d,pos)
+
+            setcall pos array_bi_index(i,4,0)
+            setcall d03 array_get_int16(d,pos)
+            setcall pos array_bi_index(i,4,3)
+            subcall d03 array_get_int16(d,pos)
+
+            setcall pos array_bi_index(i,4,1)
+            setcall d12 array_get_int16(d,pos)
+            setcall pos array_bi_index(i,4,2)
+            subcall d12 array_get_int16(d,pos)
+
+            set value s03
+            add value s12
+            call array_set_word_bi(tmp,0,4,i,value)
+
+            set value d03
+            mult value 2
+            add value d12
+            call array_set_word_bi(tmp,1,4,i,value)
+
+            set value s03
+            sub value s12
+            call array_set_word_bi(tmp,2,4,i,value)
+
+            set value d12
+            mult value -2
+            add value d03
+            call array_set_word_bi(tmp,3,4,i,value)
+
+            inc i
+        endwhile
+        import "array_get_int16_bi" array_get_int16_bi
+        sd dct
+        set dct p_dct#
+        set i 0
+        while i!=4
+            setcall s03 array_get_int16_bi(tmp,i,4,0)
+            addcall s03 array_get_int16_bi(tmp,i,4,3)
+            setcall s12 array_get_int16_bi(tmp,i,4,1)
+            addcall s12 array_get_int16_bi(tmp,i,4,2)
+            setcall d03 array_get_int16_bi(tmp,i,4,0)
+            subcall d03 array_get_int16_bi(tmp,i,4,3)
+            setcall d12 array_get_int16_bi(tmp,i,4,1)
+            subcall d12 array_get_int16_bi(tmp,i,4,2)
+
+            set value s03
+            add value s12
+            call array_set_word_bi(dct,0,4,i,value)
+            set value d03
+            mult value 2
+            add value d12
+            call array_set_word_bi(dct,1,4,i,value)
+            set value s03
+            sub value s12
+            call array_set_word_bi(dct,2,4,i,value)
+            set value d12
+            mult value -2
+            add value d03
+            call array_set_word_bi(dct,3,4,i,value)
+
+            inc i
+        endwhile
+        add p_dct# (4*4*WORD)
+    endelse
+    setcall value avc_dct_sub_pred_index((value_get))
+    #using just: 0,1,2,3
+    if value<3
+        inc value
+        call avc_dct_sub_pred_index((value_set),value)
+    endif
+endfunction
+function avc_dct_sub_row(sd p_dct,sd plane,sd coef,sd stride)
+    sd ix
+    set ix coef
+    div coef 2
+    call avc_dct_sub(p_dct,plane,coef,stride)
+    add plane ix
+    call avc_dct_sub(p_dct,plane,coef,stride)
+endfunction
+
+import "avc_input" avc_input
+import "avc_input_dequant" avc_input_dequant
+
+function avc_dct_pred(sd way,sd plane,sd stride,sd count)
+    import "array_get_byte" array_get_byte
+    sd value
+    data pred_data#4
+    data preds_init^pred_data
+    sd preds
+    set preds preds_init
+    if way=(value_set)
+        call avc_dct_sub_pred_index((value_set),0)
+        import "avc_mb_nr_left" avc_mb_nr_left
+        import "avc_mb_nr_top" avc_mb_nr_top
+        sd left_nr
+        sd top_nr
+        setcall left_nr avc_mb_nr_left((value_get))
+        setcall top_nr avc_mb_nr_top((value_get))
+        sd n
+        #for quant/dequant on mem imput
+            #change to input dequant
+        setcall plane avc_input_dequant_move(plane)
+        #
+        #dc0    dc1
+        #dc2    dc3
+        sd dc0=0
+        sd dc1=0
+        sd dc2
+        sd dc3
+        #first
+        if left_nr=0
+            if top_nr=0
+                set dc0 0x80
+                set dc1 0x80
+                set dc2 0x80
+                set dc3 0x80
+            endif
+        endif
+        if count=(luma_count)
+        #luma
+            #left
+            if left_nr!=0
+                set n 0
+                while n!=16
+                    set value n
+                    mult value stride
+                    dec value
+                    addcall dc0 array_get_byte(plane,value)
+                    inc n
+                endwhile
+                if top_nr=0
+                #nothing at top, left done
+                    add dc0 8
+                    setcall dc0 sar(dc0,4)
+                    set dc1 dc0
+                    set dc2 dc0
+                    set dc3 dc0
+                endif
+            endif
+            #top, leftTop
+            if top_nr!=0
+                set n 0
+                while n!=16
+                    set value n
+                    sub value stride
+                    addcall dc1 array_get_byte(plane,value)
+                    inc n
+                endwhile
+                if left_nr=0
+                #nothing at left, top done
+                    add dc1 8
+                    setcall dc1 sar(dc1,4)
+                    set dc0 dc1
+                    set dc2 dc1
+                    set dc3 dc1
+                else
+                #left top
+                    add dc0 dc1
+                    add dc0 16
+                    setcall dc0 sar(dc0,5)
+                    set dc1 dc0
+                    set dc2 dc0
+                    set dc3 dc0
+                endelse
+            endif
+        else
+        #chroma
+        #   s0    s1
+        #s2
+        #s3
+            sd s0=0
+            sd s1=0
+            sd s2=0
+            sd s3=0
+            #left
+            if left_nr!=0
+                set n 0
+                while n!=4
+                    set value n
+                    mult value stride
+                    dec value
+                    addcall s2 array_get_byte(plane,value)
+                    set value n
+                    add value 4
+                    mult value stride
+                    dec value
+                    addcall s3 array_get_byte(plane,value)
+                    inc n
+                endwhile
+                if top_nr=0
+                #nothing at top, left done
+                    set dc0 s2
+                    add dc0 2
+                    setcall dc0 sar(dc0,2)
+                    set dc2 s3
+                    add dc2 2
+                    setcall dc2 sar(dc2,2)
+                    set dc1 dc0
+                    set dc3 dc2
+                endif
+            endif
+            #top, leftTop
+            if top_nr!=0
+                set n 0
+                while n!=4
+                    set value n
+                    sub value stride
+                    addcall s0 array_get_byte(plane,value)
+                    set value n
+                    add value 4
+                    sub value stride
+                    addcall s1 array_get_byte(plane,value)
+                    inc n
+                endwhile
+                if left_nr=0
+                #nothing at left, top done
+                    set dc0 s0
+                    add dc0 2
+                    setcall dc0 sar(dc0,2)
+                    set dc1 s1
+                    add dc1 2
+                    setcall dc1 sar(dc1,2)
+                    set dc2 dc0
+                    set dc3 dc1
+                else
+                #left top
+                    set dc0 s0
+                    add dc0 s2
+                    add dc0 4
+                    setcall dc0 sar(dc0,3)
+                    set dc1 s1
+                    add dc1 2
+                    setcall dc1 sar(dc1,2)
+                    set dc2 s3
+                    add dc2 2
+                    setcall dc2 sar(dc2,2)
+                    set dc3 s1
+                    add dc3 s3
+                    add dc3 4
+                    setcall dc3 sar(dc3,3)
+                endelse
+            endif
+        endelse
+
+        set preds# dc0
+        add preds (DWORD)
+        set preds# dc1
+        add preds (DWORD)
+        set preds# dc2
+        add preds (DWORD)
+        set preds# dc3
+        add preds (DWORD)
+        #set for next macroblocks
+        ss mem_deq_left
+        set mem_deq_left plane
+        add mem_deq_left count
+        dec mem_deq_left
+        ss mem_deq_top
+        set mem_deq_top plane
+        #from 1 to let at the last row
+        set n 1
+        while n!=count
+            add mem_deq_top stride
+            inc n
+        endwhile
+        #left is from top-right to bottom-right; top is from bottom-left to bottom-right
+        set n 0
+        sd m
+        set m count
+        div m 2
+        while n!=m
+            set mem_deq_left# dc1
+            add mem_deq_left stride
+            set mem_deq_top# dc2
+            inc mem_deq_top
+            inc n
+        endwhile
+        set n 0
+        while n!=m
+            set mem_deq_left# dc3
+            add mem_deq_left stride
+            set mem_deq_top# dc3
+            inc mem_deq_top
+            inc n
+        endwhile
+        #
+    else
+        #value
+        setcall value avc_dct_sub_pred_index((value_get))
+        mult value 4
+        add preds value
+        return preds#
+    endelse
+endfunction
+
+function avc_input_dequant_move(sd plane)
+    #input deq start
+    ss mem_deq
+    setcall mem_deq avc_input_dequant((value_get))
+    #input start
+    ss mem_in
+    setcall mem_in avc_input((value_get))
+    #from plane to dequant
+    sd dif
+    set dif plane
+    sub dif mem_in
+    add mem_deq dif
+    return mem_deq
+endfunction
+
+function avc_quant_mf_set()
+    #[4][4]
+    data d_def_quant4#4*4
+    data def_quant4^d_def_quant4
+    #
+    data d_def_dequant4#4*4
+    data def_dequant4^d_def_dequant4
+
+    sd def_quant
+    sd def_dequant
+    set def_quant def_quant4
+    set def_dequant def_dequant4
+    sd i=0
+    sd value
+    while i!=16
+        sd j
+        set j i
+        and j 1
+        setcall value sar(i,2)
+        and value 1
+        add j value
+        setcall def_quant# avc_quant4_scale(j)
+        setcall def_dequant# avc_dequant4_scale(j)
+        add def_quant 4
+        add def_dequant 4
+        inc i
+    endwhile
+    set i 0
+    set def_quant def_quant4
+    set def_dequant def_dequant4
+    sd quant_mf_set
+    sd dequant_mf_set
+    setcall quant_mf_set avc_quant_mf_array()
+    setcall dequant_mf_set avc_dequant_mf_array()
+    while i!=16
+        set value def_quant#
+        mult value 16
+        div value 0x10
+        set quant_mf_set# value
+
+        set value def_dequant#
+        mult value 0x10
+        set dequant_mf_set# value
+
+        add quant_mf_set 4
+        add def_quant 4
+        add dequant_mf_set 4
+        add def_dequant 4
+        inc i
+    endwhile
+endfunction
+
+function avc_quant_mf_array()
+    data d_quant_mf#4*4
+    data d^d_quant_mf
+    return d
+endfunction
+
+function avc_dequant_mf_array()
+    data d_dequant_mf#4*4
+    data d^d_dequant_mf
+    return d
+endfunction
+
+function avc_quant4_scale(sd x)
+    #[6][3]
+    #        { 13107, 8066, 5243 },
+    #    { 11916, 7490, 4660 },
+    #    { 10082, 6554, 4194 },
+    #    {  9362, 5825, 3647 },
+    #    {  8192, 5243, 3355 },
+    data q={7282, 4559, 2893}
+    sd quant4_scale^q
+    mult x 4
+    add quant4_scale x
+    return quant4_scale#
+endfunction
+
+function avc_dequant4_scale(sd x)
+    #[6][3]
+    #{ 10, 13, 16 },
+    #{ 11, 14, 18 },
+    #{ 13, 16, 20 },
+    #{ 14, 18, 23 },
+    #{ 16, 20, 25 },
+    data dequant={18, 23, 29}
+    sd deq^dequant
+    mult x 4
+    add deq x
+    return deq#
+endfunction
+
+import "short_get_to_int" short_get_to_int
+
+function avc_quant(sd dct,sd upper_limit,sd dc_bool)
+    import "avc_qp_I" avc_qp_I
+    sd qbits
+    sd qscale
+    setcall qscale avc_qp_I()
+    set qbits qscale
+    div qbits 6
+    add qbits 15
+    sd f
+    sd i_qmf
+    sd quant_mf
+    sd shift_value
+    setcall quant_mf avc_quant_mf_array()
+    if dc_bool=0
+        setcall f shl(1,qbits)
+        set shift_value qbits
+    else
+        setcall f shl(2,qbits)
+        set i_qmf quant_mf#
+        set shift_value qbits
+        inc shift_value
+    endelse
+    #/ b_intra ? 3 : 6
+    div f 3
+
+    sd x
+    sd y=0
+    while y!=upper_limit
+        set x 0
+        while x!=upper_limit
+            sd value
+            setcall value short_get_to_int(dct)
+            if value>0
+                if dc_bool=0
+                    mult value quant_mf#
+                else
+                    mult value i_qmf
+                endelse
+                add value f
+                setcall value sar(value,shift_value)
+            else
+                if dc_bool=0
+                    mult value quant_mf#
+                else
+                    mult value i_qmf
+                endelse
+                mult value -1
+                add value f
+                setcall value sar(value,shift_value)
+                mult value -1
+            endelse
+            import "int_into_short" int_into_short
+            call int_into_short(value,dct)
+            add quant_mf 4
+            add dct 2
+            inc x
+        endwhile
+        inc y
+    endwhile
+endfunction
+
+
+function avc_scan_zigzag_4x4(sd dct,sd residual_ac)
+    call avc_zig(residual_ac,0,dct,0,1)
+    call avc_zig(residual_ac,1,dct,1,0)
+    call avc_zig(residual_ac,2,dct,2,0)
+    call avc_zig(residual_ac,3,dct,1,1)
+    call avc_zig(residual_ac,4,dct,0,2)
+    call avc_zig(residual_ac,5,dct,0,3)
+    call avc_zig(residual_ac,6,dct,1,2)
+    call avc_zig(residual_ac,7,dct,2,1)
+    call avc_zig(residual_ac,8,dct,3,0)
+    call avc_zig(residual_ac,9,dct,3,1)
+    call avc_zig(residual_ac,10,dct,2,2)
+    call avc_zig(residual_ac,11,dct,1,3)
+    call avc_zig(residual_ac,12,dct,2,3)
+    call avc_zig(residual_ac,13,dct,3,2)
+    call avc_zig(residual_ac,14,dct,3,3)
+endfunction
+function avc_scan_zigzag_2x2_dc(sd dct,sd residual)
+    call avc_zig2x2(residual,0,dct,0,0)
+    call avc_zig2x2(residual,1,dct,0,1)
+    call avc_zig2x2(residual,2,dct,1,0)
+    call avc_zig2x2(residual,3,dct,1,1)
+endfunction
+function avc_scan_zigzag_4x4full(sd dct,sd residual)
+    call avc_zig(residual,0,dct,0,0)
+    call avc_zig(residual,1,dct,0,1)
+    call avc_zig(residual,2,dct,1,0)
+    call avc_zig(residual,3,dct,2,0)
+    call avc_zig(residual,4,dct,1,1)
+    call avc_zig(residual,5,dct,0,2)
+    call avc_zig(residual,6,dct,0,3)
+    call avc_zig(residual,7,dct,1,2)
+    call avc_zig(residual,8,dct,2,1)
+    call avc_zig(residual,9,dct,3,0)
+    call avc_zig(residual,10,dct,3,1)
+    call avc_zig(residual,11,dct,2,2)
+    call avc_zig(residual,12,dct,1,3)
+    call avc_zig(residual,13,dct,2,3)
+    call avc_zig(residual,14,dct,3,2)
+    call avc_zig(residual,15,dct,3,3)
+endfunction
+
+function avc_zig(sd residual,sd i,sd dct,sd y,sd x)
+    mult i (DWORD)
+    add residual i
+    mult y (4*WORD)
+    add dct y
+    mult x (WORD)
+    add dct x
+    setcall residual# short_get_to_int(dct)
+endfunction
+function avc_zig2x2(sd residual,sd i,sd dct,sd y,sd x)
+    mult i (DWORD)
+    add residual i
+    mult y (2*WORD)
+    add dct y
+    mult x (WORD)
+    add dct x
+    setcall residual# short_get_to_int(dct)
+endfunction
+
+function avc_array_non_zero_count(sd array,sd count)
+    sd i=0
+    sd nz=0
+    while i<count
+        if array#!=0
+            inc nz
+        endif
+        add array (DWORD)
+        inc i
+    endwhile
+    return nz
+endfunction
+
+
+##chroma
+
+function avc_enc_8x8_chroma(sd U,sd V,sd residual_ac_u,sd residual_ac_v,sd chroma_dc_u,sd chroma_dc_v)
+    #U
+    call avc_enc_chroma_block(U,residual_ac_u,chroma_dc_u)
+    #V
+    call avc_enc_chroma_block(V,residual_ac_v,chroma_dc_v)
+endfunction
+function avc_enc_chroma_block(sd plane,sd residual_ac,sd residual_dc)
+    char dct_data#4*4*4*WORD
+    data d_dct^dct_data
+    char dct2x2_data#2*2*WORD
+    data dct2x2^dct2x2_data
+    sd stride
+    setcall stride avc_width((value_get))
+    div stride 2
+    #ac
+    call avc_enc_block(plane,residual_ac,d_dct,4,dct2x2,4,stride)
+    #dc
+    call avc_dct2x2dc(dct2x2)
+    call avc_quant(dct2x2,2,(TRUE))
+    call avc_scan_zigzag_2x2_dc(dct2x2,residual_dc)
+    #
+    call avc_idct_dc_2x2(dct2x2)
+    call avc_dequant_dc_2x2(dct2x2)
+    call avc_dc_coeff_inv(dct2x2,d_dct,4,2)
+
+    sd dct_ix
+    sd p_dct^dct_ix
+    set dct_ix d_dct
+    sd index=16
+    sd p_index^index
+    sd plane_deq
+    setcall plane_deq avc_input_dequant_move(plane)
+    call avc_dct_add(p_dct,plane_deq,4,stride,p_index)
+endfunction
+
+function avc_dc_coeff(sd dct_chroma,ss dct,sd i,sd array_size)
+    sd x
+    sd y
+    setcall x avc_block_idx_x(i)
+    setcall y avc_block_idx_y(i)
+    sd value
+    setcall value short_get_to_int(dct)
+    call array_set_word_bi(dct_chroma,y,array_size,x,value)
+endfunction
+
+
+function avc_dct2x2dc(sd dct)
+    sd a00
+    sd a10
+    sd a01
+    sd a11
+
+    setcall a00 array_get_int16_bi(dct,0,2,0)
+    addcall a00 array_get_int16_bi(dct,0,2,1)
+    setcall a10 array_get_int16_bi(dct,0,2,0)
+    subcall a10 array_get_int16_bi(dct,0,2,1)
+    setcall a01 array_get_int16_bi(dct,1,2,0)
+    addcall a01 array_get_int16_bi(dct,1,2,1)
+    setcall a11 array_get_int16_bi(dct,1,2,0)
+    subcall a11 array_get_int16_bi(dct,1,2,1)
+
+    sd value
+    set value a00
+    add value a01
+    call array_set_word_bi(dct,0,2,0,value)
+    set value a10
+    add value a11
+    call array_set_word_bi(dct,0,2,1,value)
+    set value a00
+    sub value a01
+    call array_set_word_bi(dct,1,2,0,value)
+    set value a10
+    sub value a11
+    call array_set_word_bi(dct,1,2,1,value)
+endfunction
+function avc_dct4x4dc(sd dct)
+    char tmp_data#4*4*WORD
+    data tmp^tmp_data
+    sd s01
+    sd s23
+    sd d01
+    sd d23
+    sd value
+    sd i=0
+    while i!=4
+        setcall s01 array_get_int16_bi(dct,i,4,0)
+        addcall s01 array_get_int16_bi(dct,i,4,1)
+        setcall d01 array_get_int16_bi(dct,i,4,0)
+        subcall d01 array_get_int16_bi(dct,i,4,1)
+        setcall s23 array_get_int16_bi(dct,i,4,2)
+        addcall s23 array_get_int16_bi(dct,i,4,3)
+        setcall d23 array_get_int16_bi(dct,i,4,2)
+        subcall d23 array_get_int16_bi(dct,i,4,3)
+
+        set value s01
+        add value s23
+        call array_set_word_bi(tmp,0,4,i,value)
+        set value s01
+        sub value s23
+        call array_set_word_bi(tmp,1,4,i,value)
+        set value d01
+        sub value d23
+        call array_set_word_bi(tmp,2,4,i,value)
+        set value d01
+        add value d23
+        call array_set_word_bi(tmp,3,4,i,value)
+
+        inc i
+    endwhile
+    set i 0
+    while i!=4
+        setcall s01 array_get_int16_bi(tmp,i,4,0)
+        addcall s01 array_get_int16_bi(tmp,i,4,1)
+        setcall d01 array_get_int16_bi(tmp,i,4,0)
+        subcall d01 array_get_int16_bi(tmp,i,4,1)
+        setcall s23 array_get_int16_bi(tmp,i,4,2)
+        addcall s23 array_get_int16_bi(tmp,i,4,3)
+        setcall d23 array_get_int16_bi(tmp,i,4,2)
+        subcall d23 array_get_int16_bi(tmp,i,4,3)
+
+        set value s01
+        add value s23
+        inc value
+        setcall value sar(value,1)
+        call array_set_word_bi(dct,0,4,i,value)
+        set value s01
+        sub value s23
+        inc value
+        setcall value sar(value,1)
+        call array_set_word_bi(dct,1,4,i,value)
+        set value d01
+        sub value d23
+        inc value
+        setcall value sar(value,1)
+        call array_set_word_bi(dct,2,4,i,value)
+        set value d01
+        add value d23
+        inc value
+        setcall value sar(value,1)
+        call array_set_word_bi(dct,3,4,i,value)
+
+        inc i
+    endwhile
+endfunction
+
+
+
+function avc_block_idx_x(sd x)
+    data idx_x={0, 1, 0, 1, 2, 3, 2, 3, 0, 1, 0, 1, 2, 3, 2, 3}
+    sd idx^idx_x
+    mult x 4
+    add idx x
+    return idx#
+endfunction
+function avc_block_idx_y(sd y)
+    data idx_y={0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3}
+    sd idx^idx_y
+    mult y 4
+    add idx y
+    return idx#
+endfunction
+function avc_block_idx_xy(sd x,sd y)
+    #idx[x][y]
+    data idx_xy={0, 2, 8,  10}
+    data *     ={1, 3, 9,  11}
+    data *     ={4, 6, 12, 14}
+    data *     ={5, 7, 13, 15}
+    sd index^idx_xy
+    mult x (4*DWORD)
+    add index x
+    mult y (DWORD)
+    add index y
+    return index#
+endfunction
+
+
+
+#dequant
+
+function avc_dequant(sd dct)
+    #const int i_mf = i_qscale%6;
+
+    sd qbits
+    setcall qbits avc_qp_I()
+    div qbits 6
+    sub qbits 4
+
+    #qbits is negative, need positive
+    mult qbits -1
+    sd f
+    set f qbits
+    dec f
+    setcall f shl(1,f)
+
+    sd dequant_mf
+    setcall dequant_mf avc_dequant_mf_array()
+    sd value
+    sd n=0
+    while n!=4
+        sd m=0
+        while m!=4
+            setcall value short_get_to_int(dct)
+            mult value dequant_mf#
+            add value f
+            setcall value sar(value,qbits)
+            call int_into_short(value,dct)
+
+            add dct (WORD)
+            add dequant_mf (DWORD)
+            inc m
+        endwhile
+        inc n
+    endwhile
+endfunction
+
+function avc_idct_dc(sd dct)
+    char tmp_data#4*4*WORD
+    data tmp^tmp_data
+    sd s01
+    sd s23
+    sd d01
+    sd d23
+    sd i
+    sd value
+
+    set i 0
+    while i!=4
+        setcall s01 array_get_int16_bi(dct,0,4,i)
+        addcall s01 array_get_int16_bi(dct,1,4,i)
+        setcall d01 array_get_int16_bi(dct,0,4,i)
+        subcall d01 array_get_int16_bi(dct,1,4,i)
+        setcall s23 array_get_int16_bi(dct,2,4,i)
+        addcall s23 array_get_int16_bi(dct,3,4,i)
+        setcall d23 array_get_int16_bi(dct,2,4,i)
+        subcall d23 array_get_int16_bi(dct,3,4,i)
+        set value s01
+        add value s23
+        call array_set_word_bi(tmp,0,4,i,value)
+        set value s01
+        sub value s23
+        call array_set_word_bi(tmp,1,4,i,value)
+        set value d01
+        sub value d23
+        call array_set_word_bi(tmp,2,4,i,value)
+        set value d01
+        add value d23
+        call array_set_word_bi(tmp,3,4,i,value)
+        inc i
+    endwhile
+    set i 0
+    while i!=4
+        setcall value array_get_int16_bi(tmp,i,4,0)
+        setcall d01 array_get_int16_bi(tmp,i,4,1)
+        set s01 value
+        add s01 d01
+        mult d01 -1
+        add d01 value
+        setcall value array_get_int16_bi(tmp,i,4,2)
+        setcall d23 array_get_int16_bi(tmp,i,4,3)
+        set s23 value
+        add s23 d23
+        mult d23 -1
+        add d23 value
+        #
+        set value s01
+        add value s23
+        call int_into_short(value,dct)
+        add dct (WORD)
+        sub s01 s23
+        call int_into_short(s01,dct)
+        add dct (WORD)
+        set value d01
+        sub value d23
+        call int_into_short(value,dct)
+        add dct (WORD)
+        add d01 d23
+        call int_into_short(d01,dct)
+        add dct (WORD)
+        inc i
+    endwhile
+endfunction
+
+function avc_dequant_dc(sd dct)
+    sd qbits
+    setcall qbits avc_qp_I()
+    div qbits 6
+    sub qbits 6
+    sd dequant_mf
+    sd dmf
+    sd f
+    setcall dequant_mf avc_dequant_mf_array()
+    set dmf dequant_mf#
+    mult qbits -1
+    set f qbits
+    dec f
+    setcall f shl(1,f)
+    sd value
+    sd i=0
+    while i!=4
+        sd j=0
+        while j!=4
+            setcall value short_get_to_int(dct)
+            mult value dmf
+            add value f
+            setcall value sar(value,qbits)
+            call int_into_short(value,dct)
+            add dct (WORD)
+            inc j
+        endwhile
+        inc i
+    endwhile
+endfunction
+
+function avc_dc_coeff_inv(sd dct_lum_ch,sd dct,sd count,sd size)
+    sd i=0
+    sd y
+    sd x
+    sd value
+    while i!=count
+        setcall y avc_block_idx_y(i)
+        setcall x avc_block_idx_x(i)
+        setcall value array_get_int16_bi(dct_lum_ch,y,size,x)
+        call int_into_short(value,dct)
+        add dct (4*4*WORD)
+        inc i
+    endwhile
+endfunction
+
+function avc_dct_add(sd p_dct,ss plane,sd coef,sd stride,sd p_index)
+    if coef!=2
+        call avc_dct_add_row(p_dct,plane,coef,stride,p_index)
+        sd second_part
+        set second_part stride
+        mult second_part coef
+        add plane second_part
+        call avc_dct_add_row(p_dct,plane,coef,stride,p_index)
+    else
+        sd index
+        set index p_index#
+        data numbers_data={0,1,2,3, 4,-1,6,-1, 8,9,-2,-2, 12,-1,-2,-3,0,-1,-2,-3}
+        #0  1  4  L   0 L
+        #2  3  5  L   T C
+        #6  7  10 L
+        #T  T  T  C
+        sd numbers^numbers_data
+        mult index (DWORD)
+        add numbers index
+        sd nr
+        set nr numbers#
+        if nr<0
+            char d_data#4*4*WORD
+            data d^d_data
+            char tmp_data#4*4*WORD
+            data tmp^tmp_data
+            sd cursor
+            sd s02
+            sd d02
+            sd s13
+            sd d13
+            sd value
+            sd dct
+            set dct p_dct#
+            set cursor tmp
+            sd i=0
+            while i!=4
+                setcall s02 array_get_int16_bi(dct,i,4,0)
+                setcall value array_get_int16_bi(dct,i,4,2)
+                set d02 value
+                mult d02 -1
+                add d02 s02
+                add s02 value
+                setcall s13 array_get_int16_bi(dct,i,4,1)
+                setcall value array_get_int16_bi(dct,i,4,3)
+                set d13 value
+                mult d13 -1
+                addcall d13 sar(s13,1)
+                addcall s13 sar(value,1)
+
+                set value s02
+                add value s13
+                call int_into_short(value,cursor)
+                add cursor (WORD)
+                set value d02
+                add value d13
+                call int_into_short(value,cursor)
+                add cursor (WORD)
+                set value d02
+                sub value d13
+                call int_into_short(value,cursor)
+                add cursor (WORD)
+                set value s02
+                sub value s13
+                call int_into_short(value,cursor)
+                add cursor (WORD)
+                inc i
+            endwhile
+            set i 0
+            while i!=4
+                setcall s02 array_get_int16_bi(tmp,0,4,i)
+                setcall value array_get_int16_bi(tmp,2,4,i)
+                set d02 value
+                mult d02 -1
+                add d02 s02
+                add s02 value
+                setcall s13 array_get_int16_bi(tmp,1,4,i)
+                setcall value array_get_int16_bi(tmp,3,4,i)
+                set d13 value
+                mult d13 -1
+                addcall d13 sar(s13,1)
+                addcall s13 sar(value,1)
+
+                set value s02
+                add value s13
+                add value 32
+                setcall value sar(value,6)
+                call array_set_word_bi(d,0,4,i,value)
+                set value d02
+                add value d13
+                add value 32
+                setcall value sar(value,6)
+                call array_set_word_bi(d,1,4,i,value)
+                set value d02
+                sub value d13
+                add value 32
+                setcall value sar(value,6)
+                call array_set_word_bi(d,2,4,i,value)
+                set value s02
+                sub value s13
+                add value 32
+                setcall value sar(value,6)
+                call array_set_word_bi(d,3,4,i,value)
+                inc i
+            endwhile
+            ss block
+            if nr!=-2
+            #resolve left; top bottom
+                set block plane
+                add block 3
+                set i 0
+                while i!=3
+                    set value block#
+                    addcall value array_get_int16_bi(d,i,4,3)
+                    setcall block# avc_clip_uint8(value)
+                    add block stride
+                    inc i
+                endwhile
+            endif
+            if nr<-1
+            #resolve top; left right
+                set block plane
+                set i 0
+                while i!=3
+                    add block stride
+                    inc i
+                endwhile
+                set i 0
+                while i!=3
+                    set value block#
+                    addcall value array_get_int16_bi(d,3,4,i)
+                    setcall block# avc_clip_uint8(value)
+                    inc block
+                    inc i
+                endwhile
+            endif
+            #set last value once
+            set value block#
+            addcall value array_get_int16_bi(d,3,4,3)
+            setcall block# avc_clip_uint8(value)
+        endif
+        inc p_index#
+        add p_dct# (4*4*WORD)
+    endelse
+endfunction
+function avc_dct_add_row(sd p_dct,sd plane,sd coef,sd stride,sd p_index)
+    sd ix
+    set ix coef
+    div coef 2
+    call avc_dct_add(p_dct,plane,coef,stride,p_index)
+    add plane ix
+    call avc_dct_add(p_dct,plane,coef,stride,p_index)
+endfunction
+
+
+function avc_clip_uint8(sd a)
+    sd value
+    set value a
+    and value 0xffFFff00
+    if value!=0
+        mult a -1
+        setcall a sar(a,31)
+        return a
+    endif
+    return a
+endfunction
+
+#
+
+function avc_idct_dc_2x2(sd dct)
+    sd t00
+    sd t10
+    sd t01
+    sd t11
+    sd value
+
+    setcall t00 short_get_to_int(dct)
+    add dct (WORD)
+    setcall value short_get_to_int(dct)
+    add dct (WORD)
+    set t10 value
+    mult t10 -1
+    add t10 t00
+    add t00 value
+    setcall t01 short_get_to_int(dct)
+    add dct (WORD)
+    setcall value short_get_to_int(dct)
+    set t11 value
+    mult t11 -1
+    add t11 t01
+    add t01 value
+
+    set value t10
+    sub value t11
+    call int_into_short(value,dct)
+    sub dct (WORD)
+    set value t00
+    sub value t01
+    call int_into_short(value,dct)
+    sub dct (WORD)
+    set value t10
+    add value t11
+    call int_into_short(value,dct)
+    sub dct (WORD)
+    set value t00
+    add value t01
+    call int_into_short(value,dct)
+endfunction
+
+function avc_dequant_dc_2x2(sd dct)
+    sd qbits
+    setcall qbits avc_qp_I()
+    div qbits 6
+    sub qbits 5
+
+    sd dequant_mf
+    sd dmf
+
+    setcall dequant_mf avc_dequant_mf_array()
+    set dmf dequant_mf#
+
+    #qbits is negative
+    mult qbits -1
+
+    sd value
+    sd i=0
+    while i!=4
+        setcall value short_get_to_int(dct)
+        mult value dmf
+        setcall value sar(value,qbits)
+        call int_into_short(value,dct)
+        add dct (WORD)
+        inc i
+    endwhile
+endfunction
+
+
--- ovideo-1.orig/src/media/mpeg-avc_block.s
+++ /dev/null
@@ -1,1336 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-const luma_count=16
-#const chroma_count=8
-
-#CQM_4IY = 0,
-#CQM_4IC = 2,
-
-function avc_block(sd Y,sd U,sd V,sd x,sd y)
-    #encode luma
-    import "avc_residual_ac" avc_residual_ac
-    sd residual_ac
-    setcall residual_ac avc_residual_ac((value_get))
-    import "avc_residual_luma" avc_residual_luma
-    sd residual_luma_dc
-    setcall residual_luma_dc avc_residual_luma()
-    call avc_enc_16x16(Y,residual_ac,residual_luma_dc)
-    #encode chroma
-    import "avc_residual_ac_ch" avc_residual_ac_ch
-    import "avc_residual_ac_u" avc_residual_ac_u
-    import "avc_residual_ac_v" avc_residual_ac_v
-    sd residual_ac_ch
-    sd residual_ac_u
-    sd residual_ac_v
-    setcall residual_ac_ch avc_residual_ac_ch()
-    setcall residual_ac_u avc_residual_ac_u()
-    setcall residual_ac_v avc_residual_ac_v()
-    import "avc_chroma_dc_u" avc_chroma_dc_u
-    import "avc_chroma_dc_v" avc_chroma_dc_v
-    sd chroma_dc_u
-    sd chroma_dc_v
-    setcall chroma_dc_u avc_chroma_dc_u()
-    setcall chroma_dc_v avc_chroma_dc_v()
-    call avc_enc_8x8_chroma(U,V,residual_ac_u,residual_ac_v,chroma_dc_u,chroma_dc_v)
-    #
-    import "avc_scan8" avc_scan8
-    sd i
-    sd value
-    #calculate luma
-    import "avc_mb_non_zero" avc_mb_non_zero
-    set i 0
-    sd nz
-    sd cbp_luma=0
-    while i!=16
-        setcall nz avc_array_non_zero_count(residual_ac,15)
-        if nz>0
-            set cbp_luma 0x0f
-        endif
-        setcall value avc_scan8(i)
-        call avc_mb_non_zero((value_set),value,nz)
-        add residual_ac (15*DWORD)
-        inc i
-    endwhile
-    import "avc_cbp_luma" avc_cbp_luma
-    call avc_cbp_luma((value_set),cbp_luma)
-    #calculate chroma
-    sd cbp_chroma=0
-    set i 0
-    while i!=8
-        setcall nz avc_array_non_zero_count(residual_ac_ch,15)
-        if nz>0
-            set cbp_chroma 0x02
-        endif
-        set value i
-        add value 16
-        setcall value avc_scan8(value)
-        call avc_mb_non_zero((value_set),value,nz)
-        add residual_ac_ch (15*DWORD)
-        inc i
-    endwhile
-    if cbp_chroma==0
-        setcall value avc_array_non_zero_count(chroma_dc_u,4)
-        addcall value avc_array_non_zero_count(chroma_dc_v,4)
-        if value>0
-            set cbp_chroma 1
-        endif
-    endif
-    import "avc_cbp_chroma" avc_cbp_chroma
-    call avc_cbp_chroma((value_set),cbp_chroma)
-        #for cbp
-    sd cbp_dc
-    setcall value avc_array_non_zero_count(residual_luma_dc,16)
-    if value>0
-        set cbp_dc 0x01
-    else
-        set cbp_dc 0x00
-    endelse
-    setcall value avc_array_non_zero_count(chroma_dc_u,4)
-    if value>0
-        or cbp_dc 0x02
-    endif
-    setcall value avc_array_non_zero_count(chroma_dc_v,4)
-    if value>0
-        or cbp_dc 0x04
-    endif
-    #store cbp
-    import "avc_mb_data" avc_mb_data
-    import "shl" shl
-    sd cbp
-    set cbp cbp_luma
-    orcall cbp shl(cbp_chroma,4)
-    orcall cbp shl(cbp_dc,8)
-    call avc_mb_data((value_write),(avc_mb_cbp_offset),x,y,cbp)
-endfunction
-
-import "avc_width" avc_width
-
-function avc_enc_16x16(sd Y,sd residual_ac,sd residual_luma)
-    char dct_data#16*4*4*WORD
-    data d_dct^dct_data
-    char dct_luma_data#4*4*WORD
-    data d_dct_luma^dct_luma_data
-    sd stride
-    setcall stride avc_width((value_get))
-
-    #ac
-    call avc_enc_block(Y,residual_ac,d_dct,8,d_dct_luma,16,stride)
-    #dc
-    call avc_dct4x4dc(d_dct_luma)
-    call avc_quant(d_dct_luma,4,(TRUE))
-    call avc_scan_zigzag_4x4full(d_dct_luma,residual_luma)
-    #
-    call avc_idct_dc(d_dct_luma)
-    call avc_dequant_dc(d_dct_luma)
-    call avc_dc_coeff_inv(d_dct_luma,d_dct,16,4)
-
-    sd dct_ix
-    sd p_dct^dct_ix
-    set dct_ix d_dct
-    sd index=0
-    sd p_index^index
-    sd Y_deq
-    setcall Y_deq avc_input_dequant_move(Y)
-    call avc_dct_add(p_dct,Y_deq,8,stride,p_index)
-endfunction
-
-function avc_enc_block(sd plane,sd residual,sd dct,sd coef,sd dct_lum_ch,sd mb_count,sd stride)
-    #coef: rounding down to pieces at sub
-    #      =2*arraysize for avc_dc_coeff; [0][0]
-    #      =block_size/2
-    sd block_size
-    set block_size coef
-    mult block_size 2
-    sd dct_ix
-    sd p_dct^dct_ix
-    set dct_ix dct
-    call avc_dct_pred((value_set),plane,stride,block_size)
-    call avc_dct_sub(p_dct,plane,coef,stride)
-
-    sd array_size
-    set array_size coef
-    div array_size 2
-    sd i=0
-    while i!=mb_count
-        call avc_dc_coeff(dct_lum_ch,dct,i,array_size)
-        call avc_quant(dct,4,(FALSE))
-        call avc_scan_zigzag_4x4(dct,residual)
-        call avc_dequant(dct)
-        add residual (15*DWORD)
-        add dct (4*4*WORD)
-        inc i
-    endwhile
-endfunction
-
-import "avc_dct_sub_pred_index" avc_dct_sub_pred_index
-
-function avc_dct_sub(sd p_dct,ss plane,sd coef,sd stride)
-    if coef!=2
-        call avc_dct_sub_row(p_dct,plane,coef,stride)
-        sd second_part
-        set second_part stride
-        mult second_part coef
-        add plane second_part
-        call avc_dct_sub_row(p_dct,plane,coef,stride)
-    else
-        sd value
-        char d_data#4*4*WORD
-        char tmp_data#4*4*WORD
-        data d^d_data
-        data tmp^tmp_data
-        import "sar32" sar
-        ss dif
-        set dif d
-        sd y=0
-        sd tempPlane
-        set tempPlane plane
-        while y!=4
-            sd x=0
-            while x!=4
-                set value plane#
-                subcall value avc_dct_pred((value_get))
-                set dif# value
-                setcall value sar(value,8)
-                inc dif
-                set dif# value
-                inc dif
-                inc plane
-                inc x
-            endwhile
-            add tempPlane stride
-            set plane tempPlane
-            inc y
-        endwhile
-
-        sd pos
-        sd i=0
-        import "array_get_int16" array_get_int16
-        import "array_set_word_bi" array_set_word_bi
-        import "array_bi_index" array_bi_index
-        while i!=4
-            sd s03
-            sd s12
-            sd d03
-            sd d12
-
-            setcall pos array_bi_index(i,4,0)
-            setcall s03 array_get_int16(d,pos)
-            setcall pos array_bi_index(i,4,3)
-            addcall s03 array_get_int16(d,pos)
-
-            setcall pos array_bi_index(i,4,1)
-            setcall s12 array_get_int16(d,pos)
-            setcall pos array_bi_index(i,4,2)
-            addcall s12 array_get_int16(d,pos)
-
-            setcall pos array_bi_index(i,4,0)
-            setcall d03 array_get_int16(d,pos)
-            setcall pos array_bi_index(i,4,3)
-            subcall d03 array_get_int16(d,pos)
-
-            setcall pos array_bi_index(i,4,1)
-            setcall d12 array_get_int16(d,pos)
-            setcall pos array_bi_index(i,4,2)
-            subcall d12 array_get_int16(d,pos)
-
-            set value s03
-            add value s12
-            call array_set_word_bi(tmp,0,4,i,value)
-
-            set value d03
-            mult value 2
-            add value d12
-            call array_set_word_bi(tmp,1,4,i,value)
-
-            set value s03
-            sub value s12
-            call array_set_word_bi(tmp,2,4,i,value)
-
-            set value d12
-            mult value -2
-            add value d03
-            call array_set_word_bi(tmp,3,4,i,value)
-
-            inc i
-        endwhile
-        import "array_get_int16_bi" array_get_int16_bi
-        sd dct
-        set dct p_dct#
-        set i 0
-        while i!=4
-            setcall s03 array_get_int16_bi(tmp,i,4,0)
-            addcall s03 array_get_int16_bi(tmp,i,4,3)
-            setcall s12 array_get_int16_bi(tmp,i,4,1)
-            addcall s12 array_get_int16_bi(tmp,i,4,2)
-            setcall d03 array_get_int16_bi(tmp,i,4,0)
-            subcall d03 array_get_int16_bi(tmp,i,4,3)
-            setcall d12 array_get_int16_bi(tmp,i,4,1)
-            subcall d12 array_get_int16_bi(tmp,i,4,2)
-
-            set value s03
-            add value s12
-            call array_set_word_bi(dct,0,4,i,value)
-            set value d03
-            mult value 2
-            add value d12
-            call array_set_word_bi(dct,1,4,i,value)
-            set value s03
-            sub value s12
-            call array_set_word_bi(dct,2,4,i,value)
-            set value d12
-            mult value -2
-            add value d03
-            call array_set_word_bi(dct,3,4,i,value)
-
-            inc i
-        endwhile
-        add p_dct# (4*4*WORD)
-    endelse
-    setcall value avc_dct_sub_pred_index((value_get))
-    #using just: 0,1,2,3
-    if value<3
-        inc value
-        call avc_dct_sub_pred_index((value_set),value)
-    endif
-endfunction
-function avc_dct_sub_row(sd p_dct,sd plane,sd coef,sd stride)
-    sd ix
-    set ix coef
-    div coef 2
-    call avc_dct_sub(p_dct,plane,coef,stride)
-    add plane ix
-    call avc_dct_sub(p_dct,plane,coef,stride)
-endfunction
-
-import "avc_input" avc_input
-import "avc_input_dequant" avc_input_dequant
-
-function avc_dct_pred(sd way,sd plane,sd stride,sd count)
-    import "array_get_byte" array_get_byte
-    sd value
-    data pred_data#4
-    data preds_init^pred_data
-    sd preds
-    set preds preds_init
-    if way==(value_set)
-        call avc_dct_sub_pred_index((value_set),0)
-        import "avc_mb_nr_left" avc_mb_nr_left
-        import "avc_mb_nr_top" avc_mb_nr_top
-        sd left_nr
-        sd top_nr
-        setcall left_nr avc_mb_nr_left((value_get))
-        setcall top_nr avc_mb_nr_top((value_get))
-        sd n
-        #for quant/dequant on mem imput
-            #change to input dequant
-        setcall plane avc_input_dequant_move(plane)
-        #
-        #dc0    dc1
-        #dc2    dc3
-        sd dc0=0
-        sd dc1=0
-        sd dc2
-        sd dc3
-        #first
-        if left_nr==0
-            if top_nr==0
-                set dc0 0x80
-                set dc1 0x80
-                set dc2 0x80
-                set dc3 0x80
-            endif
-        endif
-        if count==(luma_count)
-        #luma
-            #left
-            if left_nr!=0
-                set n 0
-                while n!=16
-                    set value n
-                    mult value stride
-                    dec value
-                    addcall dc0 array_get_byte(plane,value)
-                    inc n
-                endwhile
-                if top_nr==0
-                #nothing at top, left done
-                    add dc0 8
-                    setcall dc0 sar(dc0,4)
-                    set dc1 dc0
-                    set dc2 dc0
-                    set dc3 dc0
-                endif
-            endif
-            #top, leftTop
-            if top_nr!=0
-                set n 0
-                while n!=16
-                    set value n
-                    sub value stride
-                    addcall dc1 array_get_byte(plane,value)
-                    inc n
-                endwhile
-                if left_nr==0
-                #nothing at left, top done
-                    add dc1 8
-                    setcall dc1 sar(dc1,4)
-                    set dc0 dc1
-                    set dc2 dc1
-                    set dc3 dc1
-                else
-                #left top
-                    add dc0 dc1
-                    add dc0 16
-                    setcall dc0 sar(dc0,5)
-                    set dc1 dc0
-                    set dc2 dc0
-                    set dc3 dc0
-                endelse
-            endif
-        else
-        #chroma
-        #   s0    s1
-        #s2
-        #s3
-            sd s0=0
-            sd s1=0
-            sd s2=0
-            sd s3=0
-            #left
-            if left_nr!=0
-                set n 0
-                while n!=4
-                    set value n
-                    mult value stride
-                    dec value
-                    addcall s2 array_get_byte(plane,value)
-                    set value n
-                    add value 4
-                    mult value stride
-                    dec value
-                    addcall s3 array_get_byte(plane,value)
-                    inc n
-                endwhile
-                if top_nr==0
-                #nothing at top, left done
-                    set dc0 s2
-                    add dc0 2
-                    setcall dc0 sar(dc0,2)
-                    set dc2 s3
-                    add dc2 2
-                    setcall dc2 sar(dc2,2)
-                    set dc1 dc0
-                    set dc3 dc2
-                endif
-            endif
-            #top, leftTop
-            if top_nr!=0
-                set n 0
-                while n!=4
-                    set value n
-                    sub value stride
-                    addcall s0 array_get_byte(plane,value)
-                    set value n
-                    add value 4
-                    sub value stride
-                    addcall s1 array_get_byte(plane,value)
-                    inc n
-                endwhile
-                if left_nr==0
-                #nothing at left, top done
-                    set dc0 s0
-                    add dc0 2
-                    setcall dc0 sar(dc0,2)
-                    set dc1 s1
-                    add dc1 2
-                    setcall dc1 sar(dc1,2)
-                    set dc2 dc0
-                    set dc3 dc1
-                else
-                #left top
-                    set dc0 s0
-                    add dc0 s2
-                    add dc0 4
-                    setcall dc0 sar(dc0,3)
-                    set dc1 s1
-                    add dc1 2
-                    setcall dc1 sar(dc1,2)
-                    set dc2 s3
-                    add dc2 2
-                    setcall dc2 sar(dc2,2)
-                    set dc3 s1
-                    add dc3 s3
-                    add dc3 4
-                    setcall dc3 sar(dc3,3)
-                endelse
-            endif
-        endelse
-
-        set preds# dc0
-        add preds (DWORD)
-        set preds# dc1
-        add preds (DWORD)
-        set preds# dc2
-        add preds (DWORD)
-        set preds# dc3
-        add preds (DWORD)
-        #set for next macroblocks
-        ss mem_deq_left
-        set mem_deq_left plane
-        add mem_deq_left count
-        dec mem_deq_left
-        ss mem_deq_top
-        set mem_deq_top plane
-        #from 1 to let at the last row
-        set n 1
-        while n!=count
-            add mem_deq_top stride
-            inc n
-        endwhile
-        #left is from top-right to bottom-right; top is from bottom-left to bottom-right
-        set n 0
-        sd m
-        set m count
-        div m 2
-        while n!=m
-            set mem_deq_left# dc1
-            add mem_deq_left stride
-            set mem_deq_top# dc2
-            inc mem_deq_top
-            inc n
-        endwhile
-        set n 0
-        while n!=m
-            set mem_deq_left# dc3
-            add mem_deq_left stride
-            set mem_deq_top# dc3
-            inc mem_deq_top
-            inc n
-        endwhile
-        #
-    else
-        #value
-        setcall value avc_dct_sub_pred_index((value_get))
-        mult value 4
-        add preds value
-        return preds#
-    endelse
-endfunction
-
-function avc_input_dequant_move(sd plane)
-    #input deq start
-    ss mem_deq
-    setcall mem_deq avc_input_dequant((value_get))
-    #input start
-    ss mem_in
-    setcall mem_in avc_input((value_get))
-    #from plane to dequant
-    sd dif
-    set dif plane
-    sub dif mem_in
-    add mem_deq dif
-    return mem_deq
-endfunction
-
-function avc_quant_mf_set()
-    #[4][4]
-    data d_def_quant4#4*4
-    data def_quant4^d_def_quant4
-    #
-    data d_def_dequant4#4*4
-    data def_dequant4^d_def_dequant4
-
-    sd def_quant
-    sd def_dequant
-    set def_quant def_quant4
-    set def_dequant def_dequant4
-    sd i=0
-    sd value
-    while i!=16
-        sd j
-        set j i
-        and j 1
-        setcall value sar(i,2)
-        and value 1
-        add j value
-        setcall def_quant# avc_quant4_scale(j)
-        setcall def_dequant# avc_dequant4_scale(j)
-        add def_quant 4
-        add def_dequant 4
-        inc i
-    endwhile
-    set i 0
-    set def_quant def_quant4
-    set def_dequant def_dequant4
-    sd quant_mf_set
-    sd dequant_mf_set
-    setcall quant_mf_set avc_quant_mf_array()
-    setcall dequant_mf_set avc_dequant_mf_array()
-    while i!=16
-        set value def_quant#
-        mult value 16
-        div value 0x10
-        set quant_mf_set# value
-
-        set value def_dequant#
-        mult value 0x10
-        set dequant_mf_set# value
-
-        add quant_mf_set 4
-        add def_quant 4
-        add dequant_mf_set 4
-        add def_dequant 4
-        inc i
-    endwhile
-endfunction
-
-function avc_quant_mf_array()
-    data d_quant_mf#4*4
-    data d^d_quant_mf
-    return d
-endfunction
-
-function avc_dequant_mf_array()
-    data d_dequant_mf#4*4
-    data d^d_dequant_mf
-    return d
-endfunction
-
-function avc_quant4_scale(sd x)
-    #[6][3]
-    #        { 13107, 8066, 5243 },
-    #    { 11916, 7490, 4660 },
-    #    { 10082, 6554, 4194 },
-    #    {  9362, 5825, 3647 },
-    #    {  8192, 5243, 3355 },
-    data q={7282, 4559, 2893}
-    sd quant4_scale^q
-    mult x 4
-    add quant4_scale x
-    return quant4_scale#
-endfunction
-
-function avc_dequant4_scale(sd x)
-    #[6][3]
-    #{ 10, 13, 16 },
-    #{ 11, 14, 18 },
-    #{ 13, 16, 20 },
-    #{ 14, 18, 23 },
-    #{ 16, 20, 25 },
-    data dequant={18, 23, 29}
-    sd deq^dequant
-    mult x 4
-    add deq x
-    return deq#
-endfunction
-
-import "short_get_to_int" short_get_to_int
-
-function avc_quant(sd dct,sd upper_limit,sd dc_bool)
-    import "avc_qp_I" avc_qp_I
-    sd qbits
-    sd qscale
-    setcall qscale avc_qp_I()
-    set qbits qscale
-    div qbits 6
-    add qbits 15
-    sd f
-    sd i_qmf
-    sd quant_mf
-    sd shift_value
-    setcall quant_mf avc_quant_mf_array()
-    if dc_bool==0
-        setcall f shl(1,qbits)
-        set shift_value qbits
-    else
-        setcall f shl(2,qbits)
-        set i_qmf quant_mf#
-        set shift_value qbits
-        inc shift_value
-    endelse
-    #/ b_intra ? 3 : 6
-    div f 3
-
-    sd x
-    sd y=0
-    while y!=upper_limit
-        set x 0
-        while x!=upper_limit
-            sd value
-            setcall value short_get_to_int(dct)
-            if value>0
-                if dc_bool==0
-                    mult value quant_mf#
-                else
-                    mult value i_qmf
-                endelse
-                add value f
-                setcall value sar(value,shift_value)
-            else
-                if dc_bool==0
-                    mult value quant_mf#
-                else
-                    mult value i_qmf
-                endelse
-                mult value -1
-                add value f
-                setcall value sar(value,shift_value)
-                mult value -1
-            endelse
-            import "int_into_short" int_into_short
-            call int_into_short(value,dct)
-            add quant_mf 4
-            add dct 2
-            inc x
-        endwhile
-        inc y
-    endwhile
-endfunction
-
-
-function avc_scan_zigzag_4x4(sd dct,sd residual_ac)
-    call avc_zig(residual_ac,0,dct,0,1)
-    call avc_zig(residual_ac,1,dct,1,0)
-    call avc_zig(residual_ac,2,dct,2,0)
-    call avc_zig(residual_ac,3,dct,1,1)
-    call avc_zig(residual_ac,4,dct,0,2)
-    call avc_zig(residual_ac,5,dct,0,3)
-    call avc_zig(residual_ac,6,dct,1,2)
-    call avc_zig(residual_ac,7,dct,2,1)
-    call avc_zig(residual_ac,8,dct,3,0)
-    call avc_zig(residual_ac,9,dct,3,1)
-    call avc_zig(residual_ac,10,dct,2,2)
-    call avc_zig(residual_ac,11,dct,1,3)
-    call avc_zig(residual_ac,12,dct,2,3)
-    call avc_zig(residual_ac,13,dct,3,2)
-    call avc_zig(residual_ac,14,dct,3,3)
-endfunction
-function avc_scan_zigzag_2x2_dc(sd dct,sd residual)
-    call avc_zig2x2(residual,0,dct,0,0)
-    call avc_zig2x2(residual,1,dct,0,1)
-    call avc_zig2x2(residual,2,dct,1,0)
-    call avc_zig2x2(residual,3,dct,1,1)
-endfunction
-function avc_scan_zigzag_4x4full(sd dct,sd residual)
-    call avc_zig(residual,0,dct,0,0)
-    call avc_zig(residual,1,dct,0,1)
-    call avc_zig(residual,2,dct,1,0)
-    call avc_zig(residual,3,dct,2,0)
-    call avc_zig(residual,4,dct,1,1)
-    call avc_zig(residual,5,dct,0,2)
-    call avc_zig(residual,6,dct,0,3)
-    call avc_zig(residual,7,dct,1,2)
-    call avc_zig(residual,8,dct,2,1)
-    call avc_zig(residual,9,dct,3,0)
-    call avc_zig(residual,10,dct,3,1)
-    call avc_zig(residual,11,dct,2,2)
-    call avc_zig(residual,12,dct,1,3)
-    call avc_zig(residual,13,dct,2,3)
-    call avc_zig(residual,14,dct,3,2)
-    call avc_zig(residual,15,dct,3,3)
-endfunction
-
-function avc_zig(sd residual,sd i,sd dct,sd y,sd x)
-    mult i (DWORD)
-    add residual i
-    mult y (4*WORD)
-    add dct y
-    mult x (WORD)
-    add dct x
-    setcall residual# short_get_to_int(dct)
-endfunction
-function avc_zig2x2(sd residual,sd i,sd dct,sd y,sd x)
-    mult i (DWORD)
-    add residual i
-    mult y (2*WORD)
-    add dct y
-    mult x (WORD)
-    add dct x
-    setcall residual# short_get_to_int(dct)
-endfunction
-
-function avc_array_non_zero_count(sd array,sd count)
-    sd i=0
-    sd nz=0
-    while i<count
-        if array#!=0
-            inc nz
-        endif
-        add array (DWORD)
-        inc i
-    endwhile
-    return nz
-endfunction
-
-
-##chroma
-
-function avc_enc_8x8_chroma(sd U,sd V,sd residual_ac_u,sd residual_ac_v,sd chroma_dc_u,sd chroma_dc_v)
-    #U
-    call avc_enc_chroma_block(U,residual_ac_u,chroma_dc_u)
-    #V
-    call avc_enc_chroma_block(V,residual_ac_v,chroma_dc_v)
-endfunction
-function avc_enc_chroma_block(sd plane,sd residual_ac,sd residual_dc)
-    char dct_data#4*4*4*WORD
-    data d_dct^dct_data
-    char dct2x2_data#2*2*WORD
-    data dct2x2^dct2x2_data
-    sd stride
-    setcall stride avc_width((value_get))
-    div stride 2
-    #ac
-    call avc_enc_block(plane,residual_ac,d_dct,4,dct2x2,4,stride)
-    #dc
-    call avc_dct2x2dc(dct2x2)
-    call avc_quant(dct2x2,2,(TRUE))
-    call avc_scan_zigzag_2x2_dc(dct2x2,residual_dc)
-    #
-    call avc_idct_dc_2x2(dct2x2)
-    call avc_dequant_dc_2x2(dct2x2)
-    call avc_dc_coeff_inv(dct2x2,d_dct,4,2)
-
-    sd dct_ix
-    sd p_dct^dct_ix
-    set dct_ix d_dct
-    sd index=16
-    sd p_index^index
-    sd plane_deq
-    setcall plane_deq avc_input_dequant_move(plane)
-    call avc_dct_add(p_dct,plane_deq,4,stride,p_index)
-endfunction
-
-function avc_dc_coeff(sd dct_chroma,ss dct,sd i,sd array_size)
-    sd x
-    sd y
-    setcall x avc_block_idx_x(i)
-    setcall y avc_block_idx_y(i)
-    sd value
-    setcall value short_get_to_int(dct)
-    call array_set_word_bi(dct_chroma,y,array_size,x,value)
-endfunction
-
-
-function avc_dct2x2dc(sd dct)
-    sd a00
-    sd a10
-    sd a01
-    sd a11
-
-    setcall a00 array_get_int16_bi(dct,0,2,0)
-    addcall a00 array_get_int16_bi(dct,0,2,1)
-    setcall a10 array_get_int16_bi(dct,0,2,0)
-    subcall a10 array_get_int16_bi(dct,0,2,1)
-    setcall a01 array_get_int16_bi(dct,1,2,0)
-    addcall a01 array_get_int16_bi(dct,1,2,1)
-    setcall a11 array_get_int16_bi(dct,1,2,0)
-    subcall a11 array_get_int16_bi(dct,1,2,1)
-
-    sd value
-    set value a00
-    add value a01
-    call array_set_word_bi(dct,0,2,0,value)
-    set value a10
-    add value a11
-    call array_set_word_bi(dct,0,2,1,value)
-    set value a00
-    sub value a01
-    call array_set_word_bi(dct,1,2,0,value)
-    set value a10
-    sub value a11
-    call array_set_word_bi(dct,1,2,1,value)
-endfunction
-function avc_dct4x4dc(sd dct)
-    char tmp_data#4*4*WORD
-    data tmp^tmp_data
-    sd s01
-    sd s23
-    sd d01
-    sd d23
-    sd value
-    sd i=0
-    while i!=4
-        setcall s01 array_get_int16_bi(dct,i,4,0)
-        addcall s01 array_get_int16_bi(dct,i,4,1)
-        setcall d01 array_get_int16_bi(dct,i,4,0)
-        subcall d01 array_get_int16_bi(dct,i,4,1)
-        setcall s23 array_get_int16_bi(dct,i,4,2)
-        addcall s23 array_get_int16_bi(dct,i,4,3)
-        setcall d23 array_get_int16_bi(dct,i,4,2)
-        subcall d23 array_get_int16_bi(dct,i,4,3)
-
-        set value s01
-        add value s23
-        call array_set_word_bi(tmp,0,4,i,value)
-        set value s01
-        sub value s23
-        call array_set_word_bi(tmp,1,4,i,value)
-        set value d01
-        sub value d23
-        call array_set_word_bi(tmp,2,4,i,value)
-        set value d01
-        add value d23
-        call array_set_word_bi(tmp,3,4,i,value)
-
-        inc i
-    endwhile
-    set i 0
-    while i!=4
-        setcall s01 array_get_int16_bi(tmp,i,4,0)
-        addcall s01 array_get_int16_bi(tmp,i,4,1)
-        setcall d01 array_get_int16_bi(tmp,i,4,0)
-        subcall d01 array_get_int16_bi(tmp,i,4,1)
-        setcall s23 array_get_int16_bi(tmp,i,4,2)
-        addcall s23 array_get_int16_bi(tmp,i,4,3)
-        setcall d23 array_get_int16_bi(tmp,i,4,2)
-        subcall d23 array_get_int16_bi(tmp,i,4,3)
-
-        set value s01
-        add value s23
-        inc value
-        setcall value sar(value,1)
-        call array_set_word_bi(dct,0,4,i,value)
-        set value s01
-        sub value s23
-        inc value
-        setcall value sar(value,1)
-        call array_set_word_bi(dct,1,4,i,value)
-        set value d01
-        sub value d23
-        inc value
-        setcall value sar(value,1)
-        call array_set_word_bi(dct,2,4,i,value)
-        set value d01
-        add value d23
-        inc value
-        setcall value sar(value,1)
-        call array_set_word_bi(dct,3,4,i,value)
-
-        inc i
-    endwhile
-endfunction
-
-
-
-function avc_block_idx_x(sd x)
-    data idx_x={0, 1, 0, 1, 2, 3, 2, 3, 0, 1, 0, 1, 2, 3, 2, 3}
-    sd idx^idx_x
-    mult x 4
-    add idx x
-    return idx#
-endfunction
-function avc_block_idx_y(sd y)
-    data idx_y={0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3}
-    sd idx^idx_y
-    mult y 4
-    add idx y
-    return idx#
-endfunction
-function avc_block_idx_xy(sd x,sd y)
-    #idx[x][y]
-    data idx_xy={0, 2, 8,  10}
-    data *     ={1, 3, 9,  11}
-    data *     ={4, 6, 12, 14}
-    data *     ={5, 7, 13, 15}
-    sd index^idx_xy
-    mult x (4*DWORD)
-    add index x
-    mult y (DWORD)
-    add index y
-    return index#
-endfunction
-
-
-
-#dequant
-
-function avc_dequant(sd dct)
-    #const int i_mf = i_qscale%6;
-
-    sd qbits
-    setcall qbits avc_qp_I()
-    div qbits 6
-    sub qbits 4
-
-    #qbits is negative, need positive
-    mult qbits -1
-    sd f
-    set f qbits
-    dec f
-    setcall f shl(1,f)
-
-    sd dequant_mf
-    setcall dequant_mf avc_dequant_mf_array()
-    sd value
-    sd n=0
-    while n!=4
-        sd m=0
-        while m!=4
-            setcall value short_get_to_int(dct)
-            mult value dequant_mf#
-            add value f
-            setcall value sar(value,qbits)
-            call int_into_short(value,dct)
-
-            add dct (WORD)
-            add dequant_mf (DWORD)
-            inc m
-        endwhile
-        inc n
-    endwhile
-endfunction
-
-function avc_idct_dc(sd dct)
-    char tmp_data#4*4*WORD
-    data tmp^tmp_data
-    sd s01
-    sd s23
-    sd d01
-    sd d23
-    sd i
-    sd value
-
-    set i 0
-    while i!=4
-        setcall s01 array_get_int16_bi(dct,0,4,i)
-        addcall s01 array_get_int16_bi(dct,1,4,i)
-        setcall d01 array_get_int16_bi(dct,0,4,i)
-        subcall d01 array_get_int16_bi(dct,1,4,i)
-        setcall s23 array_get_int16_bi(dct,2,4,i)
-        addcall s23 array_get_int16_bi(dct,3,4,i)
-        setcall d23 array_get_int16_bi(dct,2,4,i)
-        subcall d23 array_get_int16_bi(dct,3,4,i)
-        set value s01
-        add value s23
-        call array_set_word_bi(tmp,0,4,i,value)
-        set value s01
-        sub value s23
-        call array_set_word_bi(tmp,1,4,i,value)
-        set value d01
-        sub value d23
-        call array_set_word_bi(tmp,2,4,i,value)
-        set value d01
-        add value d23
-        call array_set_word_bi(tmp,3,4,i,value)
-        inc i
-    endwhile
-    set i 0
-    while i!=4
-        setcall value array_get_int16_bi(tmp,i,4,0)
-        setcall d01 array_get_int16_bi(tmp,i,4,1)
-        set s01 value
-        add s01 d01
-        mult d01 -1
-        add d01 value
-        setcall value array_get_int16_bi(tmp,i,4,2)
-        setcall d23 array_get_int16_bi(tmp,i,4,3)
-        set s23 value
-        add s23 d23
-        mult d23 -1
-        add d23 value
-        #
-        set value s01
-        add value s23
-        call int_into_short(value,dct)
-        add dct (WORD)
-        sub s01 s23
-        call int_into_short(s01,dct)
-        add dct (WORD)
-        set value d01
-        sub value d23
-        call int_into_short(value,dct)
-        add dct (WORD)
-        add d01 d23
-        call int_into_short(d01,dct)
-        add dct (WORD)
-        inc i
-    endwhile
-endfunction
-
-function avc_dequant_dc(sd dct)
-    sd qbits
-    setcall qbits avc_qp_I()
-    div qbits 6
-    sub qbits 6
-    sd dequant_mf
-    sd dmf
-    sd f
-    setcall dequant_mf avc_dequant_mf_array()
-    set dmf dequant_mf#
-    mult qbits -1
-    set f qbits
-    dec f
-    setcall f shl(1,f)
-    sd value
-    sd i=0
-    while i!=4
-        sd j=0
-        while j!=4
-            setcall value short_get_to_int(dct)
-            mult value dmf
-            add value f
-            setcall value sar(value,qbits)
-            call int_into_short(value,dct)
-            add dct (WORD)
-            inc j
-        endwhile
-        inc i
-    endwhile
-endfunction
-
-function avc_dc_coeff_inv(sd dct_lum_ch,sd dct,sd count,sd size)
-    sd i=0
-    sd y
-    sd x
-    sd value
-    while i!=count
-        setcall y avc_block_idx_y(i)
-        setcall x avc_block_idx_x(i)
-        setcall value array_get_int16_bi(dct_lum_ch,y,size,x)
-        call int_into_short(value,dct)
-        add dct (4*4*WORD)
-        inc i
-    endwhile
-endfunction
-
-function avc_dct_add(sd p_dct,ss plane,sd coef,sd stride,sd p_index)
-    if coef!=2
-        call avc_dct_add_row(p_dct,plane,coef,stride,p_index)
-        sd second_part
-        set second_part stride
-        mult second_part coef
-        add plane second_part
-        call avc_dct_add_row(p_dct,plane,coef,stride,p_index)
-    else
-        sd index
-        set index p_index#
-        data numbers_data={0,1,2,3, 4,-1,6,-1, 8,9,-2,-2, 12,-1,-2,-3,0,-1,-2,-3}
-        #0  1  4  L   0 L
-        #2  3  5  L   T C
-        #6  7  10 L
-        #T  T  T  C
-        sd numbers^numbers_data
-        mult index (DWORD)
-        add numbers index
-        sd nr
-        set nr numbers#
-        if nr<0
-            char d_data#4*4*WORD
-            data d^d_data
-            char tmp_data#4*4*WORD
-            data tmp^tmp_data
-            sd cursor
-            sd s02
-            sd d02
-            sd s13
-            sd d13
-            sd value
-            sd dct
-            set dct p_dct#
-            set cursor tmp
-            sd i=0
-            while i!=4
-                setcall s02 array_get_int16_bi(dct,i,4,0)
-                setcall value array_get_int16_bi(dct,i,4,2)
-                set d02 value
-                mult d02 -1
-                add d02 s02
-                add s02 value
-                setcall s13 array_get_int16_bi(dct,i,4,1)
-                setcall value array_get_int16_bi(dct,i,4,3)
-                set d13 value
-                mult d13 -1
-                addcall d13 sar(s13,1)
-                addcall s13 sar(value,1)
-
-                set value s02
-                add value s13
-                call int_into_short(value,cursor)
-                add cursor (WORD)
-                set value d02
-                add value d13
-                call int_into_short(value,cursor)
-                add cursor (WORD)
-                set value d02
-                sub value d13
-                call int_into_short(value,cursor)
-                add cursor (WORD)
-                set value s02
-                sub value s13
-                call int_into_short(value,cursor)
-                add cursor (WORD)
-                inc i
-            endwhile
-            set i 0
-            while i!=4
-                setcall s02 array_get_int16_bi(tmp,0,4,i)
-                setcall value array_get_int16_bi(tmp,2,4,i)
-                set d02 value
-                mult d02 -1
-                add d02 s02
-                add s02 value
-                setcall s13 array_get_int16_bi(tmp,1,4,i)
-                setcall value array_get_int16_bi(tmp,3,4,i)
-                set d13 value
-                mult d13 -1
-                addcall d13 sar(s13,1)
-                addcall s13 sar(value,1)
-
-                set value s02
-                add value s13
-                add value 32
-                setcall value sar(value,6)
-                call array_set_word_bi(d,0,4,i,value)
-                set value d02
-                add value d13
-                add value 32
-                setcall value sar(value,6)
-                call array_set_word_bi(d,1,4,i,value)
-                set value d02
-                sub value d13
-                add value 32
-                setcall value sar(value,6)
-                call array_set_word_bi(d,2,4,i,value)
-                set value s02
-                sub value s13
-                add value 32
-                setcall value sar(value,6)
-                call array_set_word_bi(d,3,4,i,value)
-                inc i
-            endwhile
-            ss block
-            if nr!=-2
-            #resolve left; top bottom
-                set block plane
-                add block 3
-                set i 0
-                while i!=3
-                    set value block#
-                    addcall value array_get_int16_bi(d,i,4,3)
-                    setcall block# avc_clip_uint8(value)
-                    add block stride
-                    inc i
-                endwhile
-            endif
-            if nr<-1
-            #resolve top; left right
-                set block plane
-                set i 0
-                while i!=3
-                    add block stride
-                    inc i
-                endwhile
-                set i 0
-                while i!=3
-                    set value block#
-                    addcall value array_get_int16_bi(d,3,4,i)
-                    setcall block# avc_clip_uint8(value)
-                    inc block
-                    inc i
-                endwhile
-            endif
-            #set last value once
-            set value block#
-            addcall value array_get_int16_bi(d,3,4,3)
-            setcall block# avc_clip_uint8(value)
-        endif
-        inc p_index#
-        add p_dct# (4*4*WORD)
-    endelse
-endfunction
-function avc_dct_add_row(sd p_dct,sd plane,sd coef,sd stride,sd p_index)
-    sd ix
-    set ix coef
-    div coef 2
-    call avc_dct_add(p_dct,plane,coef,stride,p_index)
-    add plane ix
-    call avc_dct_add(p_dct,plane,coef,stride,p_index)
-endfunction
-
-
-function avc_clip_uint8(sd a)
-    sd value
-    set value a
-    and value 0xffFFff00
-    if value!=0
-        mult a -1
-        setcall a sar(a,31)
-        return a
-    endif
-    return a
-endfunction
-
-#
-
-function avc_idct_dc_2x2(sd dct)
-    sd t00
-    sd t10
-    sd t01
-    sd t11
-    sd value
-
-    setcall t00 short_get_to_int(dct)
-    add dct (WORD)
-    setcall value short_get_to_int(dct)
-    add dct (WORD)
-    set t10 value
-    mult t10 -1
-    add t10 t00
-    add t00 value
-    setcall t01 short_get_to_int(dct)
-    add dct (WORD)
-    setcall value short_get_to_int(dct)
-    set t11 value
-    mult t11 -1
-    add t11 t01
-    add t01 value
-
-    set value t10
-    sub value t11
-    call int_into_short(value,dct)
-    sub dct (WORD)
-    set value t00
-    sub value t01
-    call int_into_short(value,dct)
-    sub dct (WORD)
-    set value t10
-    add value t11
-    call int_into_short(value,dct)
-    sub dct (WORD)
-    set value t00
-    add value t01
-    call int_into_short(value,dct)
-endfunction
-
-function avc_dequant_dc_2x2(sd dct)
-    sd qbits
-    setcall qbits avc_qp_I()
-    div qbits 6
-    sub qbits 5
-
-    sd dequant_mf
-    sd dmf
-
-    setcall dequant_mf avc_dequant_mf_array()
-    set dmf dequant_mf#
-
-    #qbits is negative
-    mult qbits -1
-
-    sd value
-    sd i=0
-    while i!=4
-        setcall value short_get_to_int(dct)
-        mult value dmf
-        setcall value sar(value,qbits)
-        call int_into_short(value,dct)
-        add dct (WORD)
-        inc i
-    endwhile
-endfunction
-
-
--- /dev/null
+++ ovideo-1/src/media/mpeg-avc_bs.oc
@@ -0,0 +1,142 @@
+
+format elfobj
+
+include "../_include/include.h"
+
+import "avc_output" avc_output
+import "avc_output_pos" avc_output_pos
+import "avc_output_size" avc_output_size
+import "avc_allsize" avc_allsize
+
+import "shl" shl
+import "sar32" sar
+import "array_get_int" array_get_int
+
+function avc_bs_write(sd value,sd len)
+    sd size
+    setcall size avc_output_size((value_get))
+    sd allsize
+    setcall allsize avc_allsize((value_get))
+    sd pos
+    setcall pos avc_output_pos((value_get))
+    while len!=0
+        if size>=allsize
+            call avc_output_size((value_set),size)
+            call avc_output_pos((value_set),pos)
+            return 0
+        endif
+
+        ss mem
+        setcall mem avc_output((value_get))
+        add mem size
+
+        dec len
+        dec pos
+        sd test=1
+        setcall test shl(test,len)
+        and test value
+        sd unit=1
+        setcall unit shl(unit,pos)
+        if test!=0
+            or mem# unit
+        else
+            xor unit -1
+            and mem# unit
+        endelse
+        if pos=0
+            inc size
+            set pos 8
+        endif
+    endwhile
+    call avc_output_size((value_set),size)
+    call avc_output_pos((value_set),pos)
+endfunction
+
+function avc_bs_write_ue(sd value)
+    sd i_size=0
+    #i_size0_255[256]
+    data i_size_tab_data={1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5}
+    data *              ={6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6}
+    data *              ={7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7}
+    data *              ={7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7}
+    data *              ={8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8}
+    data *              ={8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8}
+    data *              ={8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8}
+    data i_size_tab^i_size_tab_data
+    if value=0
+        call avc_bs_write(1,1)
+    else
+        #unsigned int temp
+        inc value
+        sd temp
+        set temp value
+        sd enter=0
+        if temp<0
+            set enter 1
+        elseif temp>=0x00010000
+            set enter 1
+        endelseif
+        if enter=1
+            add i_size 16
+            setcall temp sar(temp,16)
+        endif
+        if temp>=0x100
+            add i_size 8
+            setcall temp sar(temp,8)
+        endif
+        addcall i_size array_get_int(i_size_tab,temp)
+        mult i_size 2
+        dec i_size
+        call avc_bs_write(value,i_size)
+    endelse
+endfunction
+
+function avc_bs_write_se(sd value)
+    if value<=0
+        mult value -2
+        call avc_bs_write_ue(value)
+    else
+        mult value 2
+        dec value
+        call avc_bs_write_ue(value)
+    endelse
+endfunction
+
+function avc_bs_write_byte(sd value)
+    call avc_bs_write(value,8)
+endfunction
+
+function avc_bs_trailing()
+    call avc_bs_write(1,1)
+    sd pos
+    setcall pos avc_output_pos((value_get))
+    if pos!=8
+        call avc_bs_write(0,pos)
+    endif
+endfunction
+function avc_bs_align_byte()
+    sd pos
+    setcall pos avc_output_pos((value_get))
+    if pos!=8
+        call avc_bs_write(-1,pos)
+    endif
+endfunction
+function avc_bs_align_byte_with_0()
+    sd pos
+    setcall pos avc_output_pos((value_get))
+    if pos!=8
+        call avc_bs_write(0,pos)
+    endif
+endfunction
+
+function avc_bs_write_data(ss bytes,sd count)
+    while count!=0
+        call avc_bs_write_byte(bytes#)
+        inc bytes
+        dec count
+    endwhile
+endfunction
+
+function avc_bs_write_bit(sd value)
+    call avc_bs_write(value,1)
+endfunction
--- ovideo-1.orig/src/media/mpeg-avc_bs.s
+++ /dev/null
@@ -1,142 +0,0 @@
-
-format elfobj
-
-include "../_include/include.h"
-
-import "avc_output" avc_output
-import "avc_output_pos" avc_output_pos
-import "avc_output_size" avc_output_size
-import "avc_allsize" avc_allsize
-
-import "shl" shl
-import "sar32" sar
-import "array_get_int" array_get_int
-
-function avc_bs_write(sd value,sd len)
-    sd size
-    setcall size avc_output_size((value_get))
-    sd allsize
-    setcall allsize avc_allsize((value_get))
-    sd pos
-    setcall pos avc_output_pos((value_get))
-    while len!=0
-        if size>=allsize
-            call avc_output_size((value_set),size)
-            call avc_output_pos((value_set),pos)
-            return 0
-        endif
-
-        ss mem
-        setcall mem avc_output((value_get))
-        add mem size
-
-        dec len
-        dec pos
-        sd test=1
-        setcall test shl(test,len)
-        and test value
-        sd unit=1
-        setcall unit shl(unit,pos)
-        if test!=0
-            or mem# unit
-        else
-            xor unit -1
-            and mem# unit
-        endelse
-        if pos==0
-            inc size
-            set pos 8
-        endif
-    endwhile
-    call avc_output_size((value_set),size)
-    call avc_output_pos((value_set),pos)
-endfunction
-
-function avc_bs_write_ue(sd value)
-    sd i_size=0
-    #i_size0_255[256]
-    data i_size_tab_data={1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5}
-    data *              ={6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6}
-    data *              ={7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7}
-    data *              ={7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7}
-    data *              ={8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8}
-    data *              ={8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8}
-    data *              ={8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8}
-    data i_size_tab^i_size_tab_data
-    if value==0
-        call avc_bs_write(1,1)
-    else
-        #unsigned int temp
-        inc value
-        sd temp
-        set temp value
-        sd enter=0
-        if temp<0
-            set enter 1
-        elseif temp>=0x00010000
-            set enter 1
-        endelseif
-        if enter==1
-            add i_size 16
-            setcall temp sar(temp,16)
-        endif
-        if temp>=0x100
-            add i_size 8
-            setcall temp sar(temp,8)
-        endif
-        addcall i_size array_get_int(i_size_tab,temp)
-        mult i_size 2
-        dec i_size
-        call avc_bs_write(value,i_size)
-    endelse
-endfunction
-
-function avc_bs_write_se(sd value)
-    if value<=0
-        mult value -2
-        call avc_bs_write_ue(value)
-    else
-        mult value 2
-        dec value
-        call avc_bs_write_ue(value)
-    endelse
-endfunction
-
-function avc_bs_write_byte(sd value)
-    call avc_bs_write(value,8)
-endfunction
-
-function avc_bs_trailing()
-    call avc_bs_write(1,1)
-    sd pos
-    setcall pos avc_output_pos((value_get))
-    if pos!=8
-        call avc_bs_write(0,pos)
-    endif
-endfunction
-function avc_bs_align_byte()
-    sd pos
-    setcall pos avc_output_pos((value_get))
-    if pos!=8
-        call avc_bs_write(-1,pos)
-    endif
-endfunction
-function avc_bs_align_byte_with_0()
-    sd pos
-    setcall pos avc_output_pos((value_get))
-    if pos!=8
-        call avc_bs_write(0,pos)
-    endif
-endfunction
-
-function avc_bs_write_data(ss bytes,sd count)
-    while count!=0
-        call avc_bs_write_byte(bytes#)
-        inc bytes
-        dec count
-    endwhile
-endfunction
-
-function avc_bs_write_bit(sd value)
-    call avc_bs_write(value,1)
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-avc_data.oc
@@ -0,0 +1,385 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+const X264_SCAN8_SIZE=6*8
+
+function avc_pre_input(sd action,sd value)
+    data mem#1
+    if action=(value_set)
+        set mem value
+    else
+        return mem
+    endelse
+endfunction
+function avc_input(sd action,sd value)
+    data mem#1
+    if action=(value_set)
+        set mem value
+    else
+        return mem
+    endelse
+endfunction
+function avc_input_dequant(sd action,sd value)
+    data mem#1
+    if action=(value_set)
+        set mem value
+    else
+        return mem
+    endelse
+endfunction
+function avc_output(sd action,sd value)
+    data mem#1
+    if action=(value_set)
+        set mem value
+    else
+        return mem
+    endelse
+endfunction
+function avc_output_size(sd action,sd value)
+    data size#1
+    if action=(value_set)
+        set size value
+    else
+        return size
+    endelse
+endfunction
+function avc_allsize(sd action,sd value)
+    data allsize#1
+    if action=(value_set)
+        set allsize value
+    else
+        return allsize
+    endelse
+endfunction
+function avc_output_pos(sd action,sd value)
+    data pos#1
+    if action=(value_set)
+        set pos value
+    else
+        return pos
+    endelse
+endfunction
+function avc_nal_output(sd action,sd value)
+    data mem#1
+    if action=(value_set)
+        set mem value
+    else
+        return mem
+    endelse
+endfunction
+
+#cabac bs
+
+function avc_cabac_range(sd way,sd value)
+    data range#1
+    if way=(value_set)
+        set range value
+    else
+        return range
+    endelse
+endfunction
+function avc_cabac_low(sd way,sd value)
+    data range#1
+    if way=(value_set)
+        set range value
+    else
+        return range
+    endelse
+endfunction
+function avc_cabac_sym_cnt(sd way,sd value)
+    data sym_cnt#1
+    if way=(value_set)
+        set sym_cnt value
+    else
+        return sym_cnt
+    endelse
+endfunction
+function avc_cabac_bits_outstanding(sd way,sd value)
+    data bits_outstanding#1
+    if way=(value_set)
+        set bits_outstanding value
+    else
+        return bits_outstanding
+    endelse
+endfunction
+function avc_cabac_first_bit(sd way,sd value)
+    data first_bit#1
+    if way=(value_set)
+        set first_bit value
+    else
+        return first_bit
+    endelse
+endfunction
+
+function avc_mb_nr_left(sd way,sd value)
+    data nr_left#1
+    if way=(value_set)
+        set nr_left value
+    else
+        return nr_left
+    endelse
+endfunction
+function avc_mb_nr_top(sd way,sd value)
+    data nr_top#1
+    if way=(value_set)
+        set nr_top value
+    else
+        return nr_top
+    endelse
+endfunction
+function avc_mb_width(sd action,sd value)
+    data mb_width#1
+    if action=(value_set)
+        set mb_width value
+    else
+        return mb_width
+    endelse
+endfunction
+function avc_mb_height(sd action,sd value)
+    data mb_height#1
+    if action=(value_set)
+        set mb_height value
+    else
+        return mb_height
+    endelse
+endfunction
+function avc_width(sd action,sd value)
+    data width#1
+    if action=(value_set)
+        set width value
+    else
+        return width
+    endelse
+endfunction
+function avc_height(sd action,sd value)
+    data height#1
+    if action=(value_set)
+        set height value
+    else
+        return height
+    endelse
+endfunction
+#
+function avc_cbp_luma(sd way,sd value)
+    data cbp_luma#1
+    if way=(value_set)
+        set cbp_luma value
+    else
+        return cbp_luma
+    endelse
+endfunction
+function avc_cbp_chroma(sd way,sd value)
+    data cbp_chroma#1
+    if way=(value_set)
+        set cbp_chroma value
+    else
+        return cbp_chroma
+    endelse
+endfunction
+#
+function avc_ProfileIndication(sd action,sd value)
+    data ProfileIndication#1
+    if action=(value_set)
+        set ProfileIndication value
+    else
+        return ProfileIndication
+    endelse
+endfunction
+function avc_profile_compatibility(sd action,sd value)
+    data profile_compatibility#1
+    if action=(value_set)
+        set profile_compatibility value
+    else
+        return profile_compatibility
+    endelse
+endfunction
+function avc_LevelIndication(sd action,sd value)
+    data LevelIndication#1
+    if action=(value_set)
+        set LevelIndication value
+    else
+        return LevelIndication
+    endelse
+endfunction
+
+function avc_dct_sub_pred_index(sd way,sd value)
+    data pred_index#1
+    if way=(value_set)
+        set pred_index value
+    else
+        return pred_index
+    endelse
+endfunction
+
+function avc_frame_num(sd way,sd value)
+    data frame_num#1
+    if way=(value_set)
+        set frame_num value
+    else
+        return frame_num
+    endelse
+endfunction
+function avc_log2_max_frame_num(sd way,sd value)
+    data log2_max_frame_num#1
+    if way=(value_set)
+        set log2_max_frame_num value
+    else
+        return log2_max_frame_num
+    endelse
+endfunction
+function avc_idr_pic_id(sd way,sd value)
+    data idr_pic_id#1
+    if way=(value_set)
+        set idr_pic_id value
+    else
+        return idr_pic_id
+    endelse
+endfunction
+function avc_log2_max_poc_lsb(sd way,sd value)
+    data log2_max_poc_lsb#1
+    if way=(value_set)
+        set log2_max_poc_lsb value
+    else
+        return log2_max_poc_lsb
+    endelse
+endfunction
+
+function avc_qp_I()
+    #i_qp_constant=26
+    #f_ip_factor = 1.4
+    #x264_clip3( (int)( qscale2qp( qp2qscale( h->param.rc.i_qp_constant ) / fabs( h->param.rc.f_ip_factor )) + 0.5 ), 0, 51 )
+    #0x17
+    return 0x17
+endfunction
+
+function avc_slice_type(sd way,sd value)
+    data slice_type#1
+    if way=(value_set)
+        set slice_type value
+    else
+        return slice_type
+    endelse
+endfunction
+
+#cabac state
+
+function avc_cabac_ctxstate()
+    data ctxstate#avc_ctxstate_total*avc_ctxstate_size
+    #int i_state;
+    #int i_mps;
+    #int i_count;
+    data c_ctxstate^ctxstate
+    return c_ctxstate
+endfunction
+function avc_cabac_ctxstate_value_get(sd i,sd item)
+    mult i (avc_ctxstate_size)
+    add i item
+    mult i 4
+    addcall i avc_cabac_ctxstate()
+    return i
+endfunction
+function avc_cabac_ctxstate_value(sd i,sd item)
+    setcall i avc_cabac_ctxstate_value_get(i,item)
+    return i#
+endfunction
+function avc_cabac_ctxstate_value_set(sd i,sd item,sd value)
+    setcall i avc_cabac_ctxstate_value_get(i,item)
+    set i# value
+endfunction
+
+#
+
+#luma ac
+function avc_residual_ac()
+    data residual_ac_data#16*15
+    data residual_ac^residual_ac_data
+    return residual_ac
+endfunction
+#luma dc
+function avc_residual_luma()
+    data residual_luma_data#1*16
+    data res^residual_luma_data
+    return res
+endfunction
+#chroma ac
+function avc_residual_ac_ch()
+    data residual_ac_ch_data#8*15
+    data residual_ac_ch^residual_ac_ch_data
+    return residual_ac_ch
+endfunction
+function avc_residual_ac_u()
+    sd residual_ac_u
+    setcall residual_ac_u avc_residual_ac_ch()
+    return residual_ac_u
+endfunction
+function avc_residual_ac_v()
+    sd residual_ac_v
+    setcall residual_ac_v avc_residual_ac_ch()
+    add residual_ac_v (4*15*DWORD)
+    return residual_ac_v
+endfunction
+#chroma dc
+function avc_chroma_dc()
+    data chroma_dc_data#2*4
+    data chroma_dc^chroma_dc_data
+    return chroma_dc
+endfunction
+function avc_chroma_dc_u()
+    sd res
+    setcall res avc_chroma_dc()
+    return res
+endfunction
+function avc_chroma_dc_v()
+    sd res
+    setcall res avc_chroma_dc()
+    add res (4*DWORD)
+    return res
+endfunction
+
+function avc_mb_non_zero(sd way,sd index,sd value)
+    data non_zero#X264_SCAN8_SIZE
+    sd non_zero_count^non_zero
+    mult index (DWORD)
+    add non_zero_count index
+    if way=(value_set)
+        set non_zero_count# value
+    else
+        return non_zero_count#
+    endelse
+endfunction
+
+function avc_mb_data(sd way,sd arg,sd x,sd y,sd value,sd opt)
+    data mem#1
+    if way=(value_set)
+        set mem arg
+    elseif way=(value_get)
+        return mem
+    else
+        sd item
+        set item mem
+        sd item_value
+        sd mb_stride
+        setcall mb_stride avc_mb_width((value_get))
+        mult y mb_stride
+        set item_value y
+        add item_value x
+        mult item_value (avc_mb_size)
+        add item_value arg
+        add item item_value
+        if arg=(avc_mb_cache_offset)
+            mult value (DWORD)
+            add item value
+            if way=(value_write)
+                set value opt
+            endif
+        endif
+        if way=(value_write)
+            set item# value
+        else
+            return item#
+        endelse
+    endelse
+endfunction
--- ovideo-1.orig/src/media/mpeg-avc_data.s
+++ /dev/null
@@ -1,385 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-const X264_SCAN8_SIZE=6*8
-
-function avc_pre_input(sd action,sd value)
-    data mem#1
-    if action==(value_set)
-        set mem value
-    else
-        return mem
-    endelse
-endfunction
-function avc_input(sd action,sd value)
-    data mem#1
-    if action==(value_set)
-        set mem value
-    else
-        return mem
-    endelse
-endfunction
-function avc_input_dequant(sd action,sd value)
-    data mem#1
-    if action==(value_set)
-        set mem value
-    else
-        return mem
-    endelse
-endfunction
-function avc_output(sd action,sd value)
-    data mem#1
-    if action==(value_set)
-        set mem value
-    else
-        return mem
-    endelse
-endfunction
-function avc_output_size(sd action,sd value)
-    data size#1
-    if action==(value_set)
-        set size value
-    else
-        return size
-    endelse
-endfunction
-function avc_allsize(sd action,sd value)
-    data allsize#1
-    if action==(value_set)
-        set allsize value
-    else
-        return allsize
-    endelse
-endfunction
-function avc_output_pos(sd action,sd value)
-    data pos#1
-    if action==(value_set)
-        set pos value
-    else
-        return pos
-    endelse
-endfunction
-function avc_nal_output(sd action,sd value)
-    data mem#1
-    if action==(value_set)
-        set mem value
-    else
-        return mem
-    endelse
-endfunction
-
-#cabac bs
-
-function avc_cabac_range(sd way,sd value)
-    data range#1
-    if way==(value_set)
-        set range value
-    else
-        return range
-    endelse
-endfunction
-function avc_cabac_low(sd way,sd value)
-    data range#1
-    if way==(value_set)
-        set range value
-    else
-        return range
-    endelse
-endfunction
-function avc_cabac_sym_cnt(sd way,sd value)
-    data sym_cnt#1
-    if way==(value_set)
-        set sym_cnt value
-    else
-        return sym_cnt
-    endelse
-endfunction
-function avc_cabac_bits_outstanding(sd way,sd value)
-    data bits_outstanding#1
-    if way==(value_set)
-        set bits_outstanding value
-    else
-        return bits_outstanding
-    endelse
-endfunction
-function avc_cabac_first_bit(sd way,sd value)
-    data first_bit#1
-    if way==(value_set)
-        set first_bit value
-    else
-        return first_bit
-    endelse
-endfunction
-
-function avc_mb_nr_left(sd way,sd value)
-    data nr_left#1
-    if way==(value_set)
-        set nr_left value
-    else
-        return nr_left
-    endelse
-endfunction
-function avc_mb_nr_top(sd way,sd value)
-    data nr_top#1
-    if way==(value_set)
-        set nr_top value
-    else
-        return nr_top
-    endelse
-endfunction
-function avc_mb_width(sd action,sd value)
-    data mb_width#1
-    if action==(value_set)
-        set mb_width value
-    else
-        return mb_width
-    endelse
-endfunction
-function avc_mb_height(sd action,sd value)
-    data mb_height#1
-    if action==(value_set)
-        set mb_height value
-    else
-        return mb_height
-    endelse
-endfunction
-function avc_width(sd action,sd value)
-    data width#1
-    if action==(value_set)
-        set width value
-    else
-        return width
-    endelse
-endfunction
-function avc_height(sd action,sd value)
-    data height#1
-    if action==(value_set)
-        set height value
-    else
-        return height
-    endelse
-endfunction
-#
-function avc_cbp_luma(sd way,sd value)
-    data cbp_luma#1
-    if way==(value_set)
-        set cbp_luma value
-    else
-        return cbp_luma
-    endelse
-endfunction
-function avc_cbp_chroma(sd way,sd value)
-    data cbp_chroma#1
-    if way==(value_set)
-        set cbp_chroma value
-    else
-        return cbp_chroma
-    endelse
-endfunction
-#
-function avc_ProfileIndication(sd action,sd value)
-    data ProfileIndication#1
-    if action==(value_set)
-        set ProfileIndication value
-    else
-        return ProfileIndication
-    endelse
-endfunction
-function avc_profile_compatibility(sd action,sd value)
-    data profile_compatibility#1
-    if action==(value_set)
-        set profile_compatibility value
-    else
-        return profile_compatibility
-    endelse
-endfunction
-function avc_LevelIndication(sd action,sd value)
-    data LevelIndication#1
-    if action==(value_set)
-        set LevelIndication value
-    else
-        return LevelIndication
-    endelse
-endfunction
-
-function avc_dct_sub_pred_index(sd way,sd value)
-    data pred_index#1
-    if way==(value_set)
-        set pred_index value
-    else
-        return pred_index
-    endelse
-endfunction
-
-function avc_frame_num(sd way,sd value)
-    data frame_num#1
-    if way==(value_set)
-        set frame_num value
-    else
-        return frame_num
-    endelse
-endfunction
-function avc_log2_max_frame_num(sd way,sd value)
-    data log2_max_frame_num#1
-    if way==(value_set)
-        set log2_max_frame_num value
-    else
-        return log2_max_frame_num
-    endelse
-endfunction
-function avc_idr_pic_id(sd way,sd value)
-    data idr_pic_id#1
-    if way==(value_set)
-        set idr_pic_id value
-    else
-        return idr_pic_id
-    endelse
-endfunction
-function avc_log2_max_poc_lsb(sd way,sd value)
-    data log2_max_poc_lsb#1
-    if way==(value_set)
-        set log2_max_poc_lsb value
-    else
-        return log2_max_poc_lsb
-    endelse
-endfunction
-
-function avc_qp_I()
-    #i_qp_constant=26
-    #f_ip_factor = 1.4
-    #x264_clip3( (int)( qscale2qp( qp2qscale( h->param.rc.i_qp_constant ) / fabs( h->param.rc.f_ip_factor )) + 0.5 ), 0, 51 )
-    #0x17
-    return 0x17
-endfunction
-
-function avc_slice_type(sd way,sd value)
-    data slice_type#1
-    if way==(value_set)
-        set slice_type value
-    else
-        return slice_type
-    endelse
-endfunction
-
-#cabac state
-
-function avc_cabac_ctxstate()
-    data ctxstate#avc_ctxstate_total*avc_ctxstate_size
-    #int i_state;
-    #int i_mps;
-    #int i_count;
-    data c_ctxstate^ctxstate
-    return c_ctxstate
-endfunction
-function avc_cabac_ctxstate_value_get(sd i,sd item)
-    mult i (avc_ctxstate_size)
-    add i item
-    mult i 4
-    addcall i avc_cabac_ctxstate()
-    return i
-endfunction
-function avc_cabac_ctxstate_value(sd i,sd item)
-    setcall i avc_cabac_ctxstate_value_get(i,item)
-    return i#
-endfunction
-function avc_cabac_ctxstate_value_set(sd i,sd item,sd value)
-    setcall i avc_cabac_ctxstate_value_get(i,item)
-    set i# value
-endfunction
-
-#
-
-#luma ac
-function avc_residual_ac()
-    data residual_ac_data#16*15
-    data residual_ac^residual_ac_data
-    return residual_ac
-endfunction
-#luma dc
-function avc_residual_luma()
-    data residual_luma_data#1*16
-    data res^residual_luma_data
-    return res
-endfunction
-#chroma ac
-function avc_residual_ac_ch()
-    data residual_ac_ch_data#8*15
-    data residual_ac_ch^residual_ac_ch_data
-    return residual_ac_ch
-endfunction
-function avc_residual_ac_u()
-    sd residual_ac_u
-    setcall residual_ac_u avc_residual_ac_ch()
-    return residual_ac_u
-endfunction
-function avc_residual_ac_v()
-    sd residual_ac_v
-    setcall residual_ac_v avc_residual_ac_ch()
-    add residual_ac_v (4*15*DWORD)
-    return residual_ac_v
-endfunction
-#chroma dc
-function avc_chroma_dc()
-    data chroma_dc_data#2*4
-    data chroma_dc^chroma_dc_data
-    return chroma_dc
-endfunction
-function avc_chroma_dc_u()
-    sd res
-    setcall res avc_chroma_dc()
-    return res
-endfunction
-function avc_chroma_dc_v()
-    sd res
-    setcall res avc_chroma_dc()
-    add res (4*DWORD)
-    return res
-endfunction
-
-function avc_mb_non_zero(sd way,sd index,sd value)
-    data non_zero#X264_SCAN8_SIZE
-    sd non_zero_count^non_zero
-    mult index (DWORD)
-    add non_zero_count index
-    if way==(value_set)
-        set non_zero_count# value
-    else
-        return non_zero_count#
-    endelse
-endfunction
-
-function avc_mb_data(sd way,sd arg,sd x,sd y,sd value,sd opt)
-    data mem#1
-    if way==(value_set)
-        set mem arg
-    elseif way==(value_get)
-        return mem
-    else
-        sd item
-        set item mem
-        sd item_value
-        sd mb_stride
-        setcall mb_stride avc_mb_width((value_get))
-        mult y mb_stride
-        set item_value y
-        add item_value x
-        mult item_value (avc_mb_size)
-        add item_value arg
-        add item item_value
-        if arg==(avc_mb_cache_offset)
-            mult value (DWORD)
-            add item value
-            if way==(value_write)
-                set value opt
-            endif
-        endif
-        if way==(value_write)
-            set item# value
-        else
-            return item#
-        endelse
-    endelse
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-avc_encode.oc
@@ -0,0 +1,731 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+const NAL_SLICE=1
+const NAL_SLICE_IDR=5
+const NAL_SEI=6
+const NAL_SPS=7
+const NAL_PPS=8
+
+#const NAL_PRIORITY_DISPOSABLE=0
+#const NAL_PRIORITY_LOW=1
+const NAL_PRIORITY_HIGH=2
+const NAL_PRIORITY_HIGHEST=3
+
+const X264_TYPE_AUTO=0x0000
+#const X264_TYPE_IDR=0x0001
+const X264_TYPE_I=0x0002
+#const X264_TYPE_P=0x0003
+
+import "avc_output" avc_output
+import "avc_output_size" avc_output_size
+import "avc_output_pos" avc_output_pos
+import "avc_nal_output" avc_nal_output
+
+import "avc_bs_write_ue" avc_bs_write_ue
+import "avc_bs_align_byte" avc_bs_align_byte
+
+#bool
+function avc_encode(sd file,sd settype,sd pixbuf)
+    call avc_output_size((value_set),0)
+    call avc_output_pos((value_set),8)
+
+    if settype=(avc_sequence_param)
+        call avc_sequenceParameterSet()
+    elseif settype=(avc_picture_param)
+        call avc_pictureParameterSet()
+    elseif settype=(avc_frame0_headers)
+        call avc_ini_headers()
+    else
+        call avc_enc_frame(pixbuf)
+    endelse
+
+    sd bool
+    setcall bool avc_write(file)
+    return bool
+endfunction
+
+#bool
+function avc_write(sd file)
+    import "file_write" file_write
+    ss mem
+    sd size
+    setcall mem avc_output((value_get))
+    setcall size avc_output_size((value_get))
+
+    import "avc_allsize" avc_allsize
+    ss nal_mem
+    setcall nal_mem avc_nal_output((value_get))
+    sd nal_size=0
+    sd allsize
+    setcall allsize avc_allsize((value_get))
+    sd count=-1
+    #-1 at count will ignore the header
+    while size!=0
+        if nal_size!=allsize
+            sd src_byte
+            set src_byte mem#
+            if count=2
+                if src_byte<=0x3
+                    set nal_mem# 0x3
+                    set count 0
+                    inc nal_mem
+                    inc nal_size
+                endif
+            endif
+            if src_byte=0
+                inc count
+            else
+                set count 0
+            endelse
+            set nal_mem# src_byte
+            inc nal_mem
+            inc nal_size
+        endif
+        inc mem
+        dec size
+    endwhile
+    setcall nal_mem avc_nal_output((value_get))
+
+    sd er
+    setcall er file_write(nal_mem,nal_size,file)
+    if er!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+import "shl" shl
+import "avc_bs_write" avc_bs_write
+import "avc_bs_write_byte" avc_bs_write_byte
+import "avc_bs_trailing" avc_bs_trailing
+import "avc_bs_write_data" avc_bs_write_data
+
+function avc_ini_headers()
+    call avc_bs_write_byte((NAL_SEI))
+    #payload_type = user_data_unregistered
+    call avc_bs_write_byte(0x5)
+
+    import "slen" slen
+    sd length=16
+    sd ver_len
+    #
+    #importx "_sprintf" sprintf
+    #char version_data#256
+    #str version^version_data
+    #str format="x264 - core %d%s - H.264/MPEG-4 AVC codec - Copyleft 2005 - http://www.videolan.org/x264.html"
+    #sd X264_BUILD=34
+    #str X264_VERSION=""
+    #call sprintf(version,format,X264_BUILD,X264_VERSION)
+    str version="OApplications"
+
+    setcall ver_len slen(version)
+    inc ver_len
+    add length ver_len
+
+    call avc_bs_write_byte(length)
+
+    char id_data={0xdc,0x45,0xe9,0xbd,0xe6,0xd9,0x48,0xb7}
+    char *      ={0x96,0x2c,0xd8,0x20,0xd9,0x23,0xee,0xef}
+    data id^id_data
+
+    call avc_bs_write_data(id,16)
+    call avc_bs_write_data(version,ver_len)
+
+    call avc_bs_trailing()
+endfunction
+
+import "avc_bs_write_bit" avc_bs_write_bit
+
+function avc_sequenceParameterSet()
+    sd nal_header
+    setcall nal_header shl((NAL_PRIORITY_HIGHEST),5)
+    or nal_header (NAL_SPS)
+    call avc_bs_write_byte(nal_header)
+
+    import "avc_ProfileIndication" avc_ProfileIndication
+    import "avc_profile_compatibility" avc_profile_compatibility
+    import "avc_LevelIndication" avc_LevelIndication
+
+    sd ProfileIndication
+    setcall ProfileIndication avc_ProfileIndication((value_get))
+    call avc_bs_write_byte(ProfileIndication)
+    sd profile_compatibility
+    setcall profile_compatibility avc_profile_compatibility((value_get))
+    call avc_bs_write_byte(profile_compatibility)
+    sd LevelIndication
+    setcall LevelIndication avc_LevelIndication((value_get))
+    call avc_bs_write_byte(LevelIndication)
+
+    #id=0
+    call avc_bs_write_ue(0)
+    #i_log2_max_frame_num
+    sd i_log2_max_frame_num=4
+    sd loop=1
+    while loop=1
+        sd nr
+        setcall nr shl(1,i_log2_max_frame_num)
+        if nr<=(avc_keyint_max)
+            inc i_log2_max_frame_num
+        else
+            set loop 0
+        endelse
+    endwhile
+        #just in case
+    inc i_log2_max_frame_num
+        #
+    sd log
+    set log i_log2_max_frame_num
+    sub log 4
+    call avc_bs_write_ue(log)
+    import "avc_log2_max_frame_num" avc_log2_max_frame_num
+    call avc_log2_max_frame_num((value_set),i_log2_max_frame_num)
+    #i_poc_type=0
+    call avc_bs_write_ue(0)
+    #
+    import "avc_log2_max_poc_lsb" avc_log2_max_poc_lsb
+    sd i_log2_max_poc_lsb=1
+    add i_log2_max_poc_lsb i_log2_max_frame_num
+    set log i_log2_max_poc_lsb
+    sub log 4
+    call avc_bs_write_ue(log)
+    call avc_log2_max_poc_lsb((value_set),i_log2_max_poc_lsb)
+    #i_num_reorder_frames = b_bframe_pyramid ? 2 : i_bframe ? 1 : 0;
+    #i_frame_reference=1
+    #i_num_ref_frames = X264_MIN(16, i_frame_reference + i_num_reorder_frames);
+    call avc_bs_write_ue(1)
+    #b_gaps_in_frame_num_value_allowed
+    call avc_bs_write(0,1)
+    import "avc_mb_width" avc_mb_width
+    import "avc_mb_height" avc_mb_height
+    sd w
+    sd h
+    setcall w avc_mb_width((value_get))
+    setcall h avc_mb_height((value_get))
+    dec w
+    dec h
+    call avc_bs_write_ue(w)
+    call avc_bs_write_ue(h)
+    #b_frame_mbs_only=1
+    call avc_bs_write(1,1)
+    #analyse.inter = X264_ANALYSE_I4x4 | X264_ANALYSE_I8x8 | X264_ANALYSE_PSUB16x16 | X264_ANALYSE_BSUB16x16
+    #0x113
+    #b_transform_8x8=0
+    # !b_transform_8x8
+    #          analyse.inter &= ~X264_ANALYSE_I8x8
+    #0x111
+    #if !(analyse.inter & X264_ANALYSE_PSUB8x8) )
+    #b_direct8x8_inference=1
+    call avc_bs_write(1,1)
+
+    #b_crop
+    import "avc_width" avc_width
+    import "avc_height" avc_height
+    sd width
+    sd height
+    setcall width avc_width((value_get))
+    setcall height avc_height((value_get))
+    import "rest" rest
+    sd w_rem
+    sd h_rem
+    setcall w_rem rest(width,16)
+    setcall h_rem rest(height,16)
+    sd b_crop=0
+    if w_rem!=0
+        set b_crop 1
+    elseif h_rem!=0
+        set b_crop 1
+    endelseif
+    call avc_bs_write(b_crop,1)
+    if b_crop=1
+        #left
+        call avc_bs_write_ue(0)
+        #right
+        sd crop_right=16
+        sub crop_right w_rem
+        div crop_right 2
+        call avc_bs_write_ue(crop_right)
+        #top
+        call avc_bs_write_ue(0)
+        #bottom
+        sd crop_bottom=16
+        sub crop_bottom h_rem
+        div crop_bottom 2
+        call avc_bs_write_ue(crop_bottom)
+    endif
+    #b_vui
+    #i_fps_den=1000
+    #i_fps_num = (int)(fps * 1000 + .5);
+    #if i_fps_num>0 && i_fps_den>0
+    #          b_timing_info_present = 1
+    #          i_num_units_in_tick = i_fps_den
+    #          i_time_scale = i_fps_num
+    #          b_fixed_frame_rate = 1
+    sd b_timing_info_present=1
+    sd i_num_units_in_tick=1000
+
+    import "stage_file_options_fps" stage_file_options_fps
+    sd i_time_scale
+    setcall i_time_scale stage_file_options_fps()
+    mult i_time_scale 1000
+
+    sd b_fixed_frame_rate=1
+    #b_vui|=b_timing_info_present
+    call avc_bs_write(1,1)
+
+    #b_aspect_ratio_info_present=0
+    #i_sar_width>0 && i_sar_height>0 then b_aspect_ratio_info_present is 0
+    call avc_bs_write_bit(0)
+    #overscan_info_present_flag
+    call avc_bs_write_bit(0)
+    #video_signal_type_present_flag
+    call avc_bs_write_bit(0)
+    #chroma_loc_info_present_flag
+    call avc_bs_write_bit(0)
+
+    #b_timing_info_present
+    call avc_bs_write_bit(b_timing_info_present)
+    #i_num_units_in_tick
+    call avc_bs_write(i_num_units_in_tick,32)
+    #i_time_scale
+    call avc_bs_write(i_time_scale,32)
+    #b_fixed_frame_rate
+    call avc_bs_write_bit(b_fixed_frame_rate)
+
+    #nal_hrd_parameters_present_flag
+    call avc_bs_write_bit(0)
+    #vcl_hrd_parameters_present_flag
+    call avc_bs_write_bit(0)
+    #pic_struct_present_flag
+    call avc_bs_write_bit(0)
+    #b_bitstream_restriction
+    call avc_bs_write_bit(0)
+
+    call avc_bs_trailing()
+endfunction
+
+import "avc_bs_write_se" avc_bs_write_se
+
+function avc_pictureParameterSet()
+    sd nal_header
+    setcall nal_header shl((NAL_PRIORITY_HIGHEST),5)
+    or nal_header (NAL_PPS)
+    call avc_bs_write_byte(nal_header)
+
+    sd value
+
+    #id=0
+    call avc_bs_write_ue(0)
+    #sps_id=id
+    call avc_bs_write_ue(0)
+
+    #b_cabac=1
+    call avc_bs_write(1,1)
+    #b_pic_order=0
+    call avc_bs_write(0,1)
+    #i_num_slice_groups=1
+    sd s_groups=1
+    set value s_groups
+    dec value
+    call avc_bs_write_ue(value)
+    #i_num_ref_idx_l0_active=1;write num-1
+    call avc_bs_write_ue(0)
+    #i_num_ref_idx_l1_active=1;write num-1
+    call avc_bs_write_ue(0)
+    #b_weighted_pred=0
+    call avc_bs_write(0,1)
+    #b_weighted_bipred=0
+    call avc_bs_write(0,2)
+
+    #i_pic_init_qp
+    sd pic_init_qp=avc_pic_init_qp
+    set value pic_init_qp
+    sub value 26
+    call avc_bs_write_se(value)
+    #i_pic_init_qs
+    sd pic_init_qs=26
+    set value pic_init_qs
+    sub value 26
+    call avc_bs_write_se(value)
+    #i_chroma_qp_index_offset=i_chroma_qp_offset=0
+    call avc_bs_write_se(0)
+
+    #b_deblocking_filter_control=1
+    call avc_bs_write(1,1)
+    #b_constrained_intra_pred
+    call avc_bs_write(0,1)
+    #b_redundant_pic_cnt
+    call avc_bs_write(0,1)
+
+    call avc_bs_trailing()
+endfunction
+
+import "avc_slice_type" avc_slice_type
+import "avc_pre_input" avc_pre_input
+import "avc_input" avc_input
+
+function avc_enc_frame(sd pixbuf)
+    #get pixbuf to input i420
+    sd input
+    setcall input avc_pre_input((value_get))
+    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+    sd bytes
+    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
+    import "rgb_to_yuvi420" rgb_to_yuvi420
+    sd w
+    sd h
+    setcall w avc_width((value_get))
+    setcall h avc_height((value_get))
+    call rgb_to_yuvi420(bytes,input,w,h)
+
+    #write header
+    call avc_enc_frame_header()
+    #align
+    call avc_bs_align_byte()
+    #encode
+    call avc_enc_frame_content()
+endfunction
+function avc_enc_frame_header()
+    sd nal_slice_type
+    sd nal_priority
+    sd type=X264_TYPE_I
+    import "avc_frame_num" avc_frame_num
+    sd frame_num
+    setcall frame_num avc_frame_num((value_get))
+    import "avc_idr_pic_id" avc_idr_pic_id
+    #-1 if nal_type != 5
+    sd idr_pic_id
+    setcall idr_pic_id avc_idr_pic_id((value_get))
+    if frame_num=(avc_keyint_max)
+        set nal_slice_type (NAL_SLICE_IDR)
+        set nal_priority (NAL_PRIORITY_HIGHEST)
+        set type (X264_TYPE_I)
+
+        set frame_num 0
+        inc idr_pic_id
+        call avc_idr_pic_id((value_set),idr_pic_id)
+        setcall idr_pic_id rest(idr_pic_id,65536)
+        call avc_slice_type((value_set),(SLICE_TYPE_I))
+    else
+        set nal_slice_type (NAL_SLICE)
+        set type (X264_TYPE_AUTO)
+        set nal_priority (NAL_PRIORITY_HIGH)
+
+        inc frame_num
+        set idr_pic_id -1
+        call avc_slice_type((value_set),(SLICE_TYPE_P))
+    endelse
+    call avc_frame_num((value_set),frame_num)
+
+    #header
+    sd value
+
+    sd nal_header
+    setcall nal_header shl(nal_priority,5)
+    or nal_header nal_slice_type
+    call avc_bs_write(nal_header,8)
+
+    #i_first_mb
+    call avc_bs_write_ue(0)
+    #i_type
+    set value type
+    add value 5
+    call avc_bs_write_ue(value)
+    #i_pps_id=0
+    call avc_bs_write_ue(0)
+    #frame_num
+    sd log2_max_frame_num
+    setcall log2_max_frame_num avc_log2_max_frame_num((value_get))
+    call avc_bs_write(frame_num,log2_max_frame_num)
+    #idr_pic_id
+    if idr_pic_id>=0
+        call avc_bs_write_ue(idr_pic_id)
+    endif
+    #if poc_type==0
+
+    sd i_poc
+    sd log2_max_poc_lsb
+    sd i_poc_lsb
+    set i_poc frame_num
+    mult i_poc 2
+    setcall log2_max_poc_lsb avc_log2_max_poc_lsb((value_get))
+    setcall i_poc_lsb shl(1,log2_max_poc_lsb)
+    dec i_poc_lsb
+    and i_poc_lsb i_poc
+    call avc_bs_write(i_poc_lsb,log2_max_poc_lsb)
+
+    if type!=(X264_TYPE_I)
+        sd b_num_ref_idx_override=1
+        call avc_bs_write_bit(b_num_ref_idx_override)
+        sd i_num_ref_idx_l0_active=1
+        set value i_num_ref_idx_l0_active
+        dec value
+        call avc_bs_write_ue(value)
+
+        sd b_ref_pic_list_reordering_l0=0
+        call avc_bs_write_bit(b_ref_pic_list_reordering_l0)
+    endif
+
+    #NAL_PRIORITY_DISPOSABLE at B frames
+    #i_nal_ref_idc!=NAL_PRIORITY_DISPOSABLE
+    if idr_pic_id>=0
+        #no output of prior pics flag
+        call avc_bs_write_bit(0)
+        #long term reference flag
+        call avc_bs_write_bit(0)
+    else
+        #adaptive_ref_pic_marking_mode_flag
+        call avc_bs_write_bit(0)
+    endelse
+
+    #b_cabac && sh->i_type != SLICE_TYPE_I
+    if type!=(X264_TYPE_I)
+        sd i_cabac_init_idc=0
+        call avc_bs_write_ue(i_cabac_init_idc)
+    endif
+
+    #slice qp delta
+    import "avc_qp_I" avc_qp_I
+    sd qp_delta
+    setcall qp_delta avc_qp_I()
+    sub qp_delta (avc_pic_init_qp)
+    call avc_bs_write_se(qp_delta)
+
+    #if b_deblocking_filter_control
+        #qp_delta
+            #i_disable_deblocking_filter_idc=1
+    call avc_bs_write_ue(1)
+            #i_disable_deblocking_filter_idc!=1
+                #i_alpha_c0_offset
+    #call avc_bs_write_se(0)
+                #i_beta_offset
+    #call avc_bs_write_se(0)
+endfunction
+
+import "avc_mb_nr_left" avc_mb_nr_left
+import "avc_mb_nr_top" avc_mb_nr_top
+
+import "sar32" sar
+
+function avc_enc_frame_content()
+    import "avc_cabac_context_init" avc_cabac_context_init
+    call avc_cabac_context_init()
+    import "avc_cabac_range" avc_cabac_range
+    call avc_cabac_range((value_set),0x1fe)
+    import "avc_cabac_low" avc_cabac_low
+    call avc_cabac_low((value_set),0)
+    import "avc_cabac_sym_cnt" avc_cabac_sym_cnt
+    call avc_cabac_sym_cnt((value_set),0)
+    import "avc_cabac_bits_outstanding" avc_cabac_bits_outstanding
+    call avc_cabac_bits_outstanding((value_set),0)
+    import "avc_cabac_first_bit" avc_cabac_first_bit
+    call avc_cabac_first_bit((value_set),1)
+
+    sd mb_width
+    sd mb_height
+    setcall mb_width avc_mb_width((value_get))
+    setcall mb_height avc_mb_height((value_get))
+    sd pre_input
+    setcall pre_input avc_pre_input((value_get))
+    sd input
+    setcall input avc_input((value_get))
+    import "yuv_get_all_sizes" yuv_get_all_sizes
+    sd Y_area_pre
+    sd U_area_pre
+    sd V_area_pre
+    sd Y_area
+    sd U_area
+    sd V_area
+    sd planeY
+    sd planeU
+    sd planeV
+    sd planeY_pre
+    sd planeU_pre
+    sd planeV_pre
+    sd p_planeU^planeU
+    sd p_planeV^planeV
+    sd width
+    sd height
+    setcall width avc_width((value_get))
+    setcall height avc_height((value_get))
+    call yuv_get_all_sizes(width,height,p_planeU,p_planeV)
+    set planeU_pre planeU
+    set planeV_pre planeV
+    set planeY_pre pre_input
+    add planeU_pre pre_input
+    add planeV_pre pre_input
+    set Y_area_pre planeY_pre
+    set U_area_pre planeU_pre
+    set V_area_pre planeV_pre
+    set planeY input
+    add planeU input
+    add planeV input
+    set Y_area planeY
+    set U_area planeU
+    set V_area planeV
+    sd strideY
+    sd strideUV
+    set strideY width
+    set strideUV width
+    div strideUV 2
+
+    sd y=0
+    while y!=mb_height
+        call avc_mb_nr_top((value_set),y)
+        sd x=0
+        while x!=mb_width
+            call avc_mb_nr_left((value_set),x)
+            #skip or code
+            sd mb_type=avc_I_16x16
+            sd slice_type
+            setcall slice_type avc_slice_type((value_get))
+            if slice_type!=(SLICE_TYPE_I)
+                import "mpeg_block_iteration_compare" mpeg_block_iteration_compare
+                sd mode
+                setcall mode mpeg_block_iteration_compare(Y_area,Y_area_pre,U_area,U_area_pre,V_area,V_area_pre,strideY,strideUV,x,y)
+                if mode=(SKIP)
+                    set mb_type (avc_P_SKIP)
+                endif
+            endif
+            if mb_type=(avc_I_16x16)
+                #get the block bytes on the current input
+                import "mpeg_block_iteration_copy" mpeg_block_iteration_copy
+                call mpeg_block_iteration_copy(Y_area,Y_area_pre,U_area,U_area_pre,V_area,V_area_pre,strideY,strideUV,x,y)
+            endif
+
+            #init cache
+            import "avc_mb_cache_init" avc_mb_cache_init
+            call avc_mb_cache_init(x,y,mb_type)
+
+            sd call_terminal=1
+            if y=0
+                if x=0
+                    set call_terminal 0
+                endif
+            endif
+            if call_terminal=1
+                import "avc_cabac_terminal" avc_cabac_terminal
+                call avc_cabac_terminal(0)
+            endif
+            if mb_type=(avc_P_SKIP)
+                call avc_cabac_skip(1,x,y)
+            else
+                import "avc_block" avc_block
+                call avc_block(planeY,planeU,planeV,x,y)
+                if slice_type!=(SLICE_TYPE_I)
+                    call avc_cabac_skip(0,x,y)
+                endif
+                import "avc_mb_write_cabac" avc_mb_write_cabac
+                call avc_mb_write_cabac(slice_type)
+            endelse
+            import "avc_mb_cache_save" avc_mb_cache_save
+            call avc_mb_cache_save(x,y)
+
+            add planeY_pre 16
+            add planeU_pre 8
+            add planeV_pre 8
+            add planeY 16
+            add planeU 8
+            add planeV 8
+            inc x
+        endwhile
+        #add 16-1 rows at luma input and 8-1 rows at chroma
+        sd alpha=0
+        while alpha!=15
+            add planeY_pre strideY
+            add planeY strideY
+            inc alpha
+        endwhile
+        set alpha 0
+        while alpha!=7
+            add planeU_pre strideUV
+            add planeV_pre strideUV
+            add planeU strideUV
+            add planeV strideUV
+            inc alpha
+        endwhile
+        inc y
+    endwhile
+    call avc_cabac_terminal(1)
+    call avc_cabac_flush()
+    #i_cabac_word =
+    #(
+    #    (
+    #        (
+    #            3 * h->cabac.i_sym_cnt - 3 * 96 * h->sps->i_mb_width * h->sps->i_mb_height
+    #        )
+    #        /32
+    #    )
+    #    - bs_pos( &h->out.bs)/8
+    #)
+    #/3
+    sd cabac_word
+    sd value
+    setcall cabac_word avc_cabac_sym_cnt((value_get))
+    mult cabac_word 3
+    set value (3*96)
+    mult value mb_width
+    mult value mb_height
+    sub cabac_word value
+    div cabac_word 32
+
+    #8 * ( s->p - s->p_start ) + 8 - s->i_left
+    setcall value avc_output_size((value_get))
+
+    #div value 8
+    sub cabac_word value
+    div cabac_word 3
+    while cabac_word>0
+        call avc_bs_write(0x0000,16)
+        dec cabac_word
+    endwhile
+endfunction
+
+function avc_cabac_flush()
+    import "avc_cabac_putbit" avc_cabac_putbit
+    sd value
+    setcall value avc_cabac_low((value_get))
+    setcall value sar(value,9)
+    and value 1
+    call avc_cabac_putbit(value)
+    setcall value avc_cabac_low((value_get))
+    setcall value sar(value,8)
+    and value 1
+    call avc_bs_write_bit(value)
+    call avc_bs_write_bit(1)
+    import "avc_bs_align_byte_with_0" avc_bs_align_byte_with_0
+    call avc_bs_align_byte_with_0()
+endfunction
+
+import "avc_cabac_decision" avc_cabac_decision
+
+function avc_cabac_skip(sd b_skip,sd x,sd y)
+    sd ctx=0
+    sd left
+    sd top
+    import "avc_mb_data" avc_mb_data
+    if x>0
+        sd left_type
+        set left x
+        dec left
+        setcall left_type avc_mb_data((value_item),(avc_mb_type_offset),left,y)
+        if left_type!=(avc_P_SKIP)
+            inc ctx
+        endif
+    endif
+    if y>0
+        sd top_type
+        set top y
+        dec top
+        setcall top_type avc_mb_data((value_item),(avc_mb_type_offset),x,top)
+        if top_type!=(avc_P_SKIP)
+            inc ctx
+        endif
+    endif
+
+    add ctx 11
+    call avc_cabac_decision(ctx,b_skip)
+endfunction
--- ovideo-1.orig/src/media/mpeg-avc_encode.s
+++ /dev/null
@@ -1,731 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-const NAL_SLICE=1
-const NAL_SLICE_IDR=5
-const NAL_SEI=6
-const NAL_SPS=7
-const NAL_PPS=8
-
-#const NAL_PRIORITY_DISPOSABLE=0
-#const NAL_PRIORITY_LOW=1
-const NAL_PRIORITY_HIGH=2
-const NAL_PRIORITY_HIGHEST=3
-
-const X264_TYPE_AUTO=0x0000
-#const X264_TYPE_IDR=0x0001
-const X264_TYPE_I=0x0002
-#const X264_TYPE_P=0x0003
-
-import "avc_output" avc_output
-import "avc_output_size" avc_output_size
-import "avc_output_pos" avc_output_pos
-import "avc_nal_output" avc_nal_output
-
-import "avc_bs_write_ue" avc_bs_write_ue
-import "avc_bs_align_byte" avc_bs_align_byte
-
-#bool
-function avc_encode(sd file,sd settype,sd pixbuf)
-    call avc_output_size((value_set),0)
-    call avc_output_pos((value_set),8)
-
-    if settype==(avc_sequence_param)
-        call avc_sequenceParameterSet()
-    elseif settype==(avc_picture_param)
-        call avc_pictureParameterSet()
-    elseif settype==(avc_frame0_headers)
-        call avc_ini_headers()
-    else
-        call avc_enc_frame(pixbuf)
-    endelse
-
-    sd bool
-    setcall bool avc_write(file)
-    return bool
-endfunction
-
-#bool
-function avc_write(sd file)
-    import "file_write" file_write
-    ss mem
-    sd size
-    setcall mem avc_output((value_get))
-    setcall size avc_output_size((value_get))
-
-    import "avc_allsize" avc_allsize
-    ss nal_mem
-    setcall nal_mem avc_nal_output((value_get))
-    sd nal_size=0
-    sd allsize
-    setcall allsize avc_allsize((value_get))
-    sd count=-1
-    #-1 at count will ignore the header
-    while size!=0
-        if nal_size!=allsize
-            sd src_byte
-            set src_byte mem#
-            if count==2
-                if src_byte<=0x3
-                    set nal_mem# 0x3
-                    set count 0
-                    inc nal_mem
-                    inc nal_size
-                endif
-            endif
-            if src_byte==0
-                inc count
-            else
-                set count 0
-            endelse
-            set nal_mem# src_byte
-            inc nal_mem
-            inc nal_size
-        endif
-        inc mem
-        dec size
-    endwhile
-    setcall nal_mem avc_nal_output((value_get))
-
-    sd er
-    setcall er file_write(nal_mem,nal_size,file)
-    if er!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-import "shl" shl
-import "avc_bs_write" avc_bs_write
-import "avc_bs_write_byte" avc_bs_write_byte
-import "avc_bs_trailing" avc_bs_trailing
-import "avc_bs_write_data" avc_bs_write_data
-
-function avc_ini_headers()
-    call avc_bs_write_byte((NAL_SEI))
-    #payload_type = user_data_unregistered
-    call avc_bs_write_byte(0x5)
-
-    import "slen" slen
-    sd length=16
-    sd ver_len
-    #
-    #importx "_sprintf" sprintf
-    #char version_data#256
-    #str version^version_data
-    #str format="x264 - core %d%s - H.264/MPEG-4 AVC codec - Copyleft 2005 - http://www.videolan.org/x264.html"
-    #sd X264_BUILD=34
-    #str X264_VERSION=""
-    #call sprintf(version,format,X264_BUILD,X264_VERSION)
-    str version="OApplications"
-
-    setcall ver_len slen(version)
-    inc ver_len
-    add length ver_len
-
-    call avc_bs_write_byte(length)
-
-    char id_data={0xdc,0x45,0xe9,0xbd,0xe6,0xd9,0x48,0xb7}
-    char *      ={0x96,0x2c,0xd8,0x20,0xd9,0x23,0xee,0xef}
-    data id^id_data
-
-    call avc_bs_write_data(id,16)
-    call avc_bs_write_data(version,ver_len)
-
-    call avc_bs_trailing()
-endfunction
-
-import "avc_bs_write_bit" avc_bs_write_bit
-
-function avc_sequenceParameterSet()
-    sd nal_header
-    setcall nal_header shl((NAL_PRIORITY_HIGHEST),5)
-    or nal_header (NAL_SPS)
-    call avc_bs_write_byte(nal_header)
-
-    import "avc_ProfileIndication" avc_ProfileIndication
-    import "avc_profile_compatibility" avc_profile_compatibility
-    import "avc_LevelIndication" avc_LevelIndication
-
-    sd ProfileIndication
-    setcall ProfileIndication avc_ProfileIndication((value_get))
-    call avc_bs_write_byte(ProfileIndication)
-    sd profile_compatibility
-    setcall profile_compatibility avc_profile_compatibility((value_get))
-    call avc_bs_write_byte(profile_compatibility)
-    sd LevelIndication
-    setcall LevelIndication avc_LevelIndication((value_get))
-    call avc_bs_write_byte(LevelIndication)
-
-    #id=0
-    call avc_bs_write_ue(0)
-    #i_log2_max_frame_num
-    sd i_log2_max_frame_num=4
-    sd loop=1
-    while loop==1
-        sd nr
-        setcall nr shl(1,i_log2_max_frame_num)
-        if nr<=(avc_keyint_max)
-            inc i_log2_max_frame_num
-        else
-            set loop 0
-        endelse
-    endwhile
-        #just in case
-    inc i_log2_max_frame_num
-        #
-    sd log
-    set log i_log2_max_frame_num
-    sub log 4
-    call avc_bs_write_ue(log)
-    import "avc_log2_max_frame_num" avc_log2_max_frame_num
-    call avc_log2_max_frame_num((value_set),i_log2_max_frame_num)
-    #i_poc_type=0
-    call avc_bs_write_ue(0)
-    #
-    import "avc_log2_max_poc_lsb" avc_log2_max_poc_lsb
-    sd i_log2_max_poc_lsb=1
-    add i_log2_max_poc_lsb i_log2_max_frame_num
-    set log i_log2_max_poc_lsb
-    sub log 4
-    call avc_bs_write_ue(log)
-    call avc_log2_max_poc_lsb((value_set),i_log2_max_poc_lsb)
-    #i_num_reorder_frames = b_bframe_pyramid ? 2 : i_bframe ? 1 : 0;
-    #i_frame_reference=1
-    #i_num_ref_frames = X264_MIN(16, i_frame_reference + i_num_reorder_frames);
-    call avc_bs_write_ue(1)
-    #b_gaps_in_frame_num_value_allowed
-    call avc_bs_write(0,1)
-    import "avc_mb_width" avc_mb_width
-    import "avc_mb_height" avc_mb_height
-    sd w
-    sd h
-    setcall w avc_mb_width((value_get))
-    setcall h avc_mb_height((value_get))
-    dec w
-    dec h
-    call avc_bs_write_ue(w)
-    call avc_bs_write_ue(h)
-    #b_frame_mbs_only=1
-    call avc_bs_write(1,1)
-    #analyse.inter = X264_ANALYSE_I4x4 | X264_ANALYSE_I8x8 | X264_ANALYSE_PSUB16x16 | X264_ANALYSE_BSUB16x16
-    #0x113
-    #b_transform_8x8=0
-    # !b_transform_8x8
-    #          analyse.inter &= ~X264_ANALYSE_I8x8
-    #0x111
-    #if !(analyse.inter & X264_ANALYSE_PSUB8x8) )
-    #b_direct8x8_inference=1
-    call avc_bs_write(1,1)
-
-    #b_crop
-    import "avc_width" avc_width
-    import "avc_height" avc_height
-    sd width
-    sd height
-    setcall width avc_width((value_get))
-    setcall height avc_height((value_get))
-    import "rest" rest
-    sd w_rem
-    sd h_rem
-    setcall w_rem rest(width,16)
-    setcall h_rem rest(height,16)
-    sd b_crop=0
-    if w_rem!=0
-        set b_crop 1
-    elseif h_rem!=0
-        set b_crop 1
-    endelseif
-    call avc_bs_write(b_crop,1)
-    if b_crop==1
-        #left
-        call avc_bs_write_ue(0)
-        #right
-        sd crop_right=16
-        sub crop_right w_rem
-        div crop_right 2
-        call avc_bs_write_ue(crop_right)
-        #top
-        call avc_bs_write_ue(0)
-        #bottom
-        sd crop_bottom=16
-        sub crop_bottom h_rem
-        div crop_bottom 2
-        call avc_bs_write_ue(crop_bottom)
-    endif
-    #b_vui
-    #i_fps_den=1000
-    #i_fps_num = (int)(fps * 1000 + .5);
-    #if i_fps_num>0 && i_fps_den>0
-    #          b_timing_info_present = 1
-    #          i_num_units_in_tick = i_fps_den
-    #          i_time_scale = i_fps_num
-    #          b_fixed_frame_rate = 1
-    sd b_timing_info_present=1
-    sd i_num_units_in_tick=1000
-
-    import "stage_file_options_fps" stage_file_options_fps
-    sd i_time_scale
-    setcall i_time_scale stage_file_options_fps()
-    mult i_time_scale 1000
-
-    sd b_fixed_frame_rate=1
-    #b_vui|=b_timing_info_present
-    call avc_bs_write(1,1)
-
-    #b_aspect_ratio_info_present=0
-    #i_sar_width>0 && i_sar_height>0 then b_aspect_ratio_info_present is 0
-    call avc_bs_write_bit(0)
-    #overscan_info_present_flag
-    call avc_bs_write_bit(0)
-    #video_signal_type_present_flag
-    call avc_bs_write_bit(0)
-    #chroma_loc_info_present_flag
-    call avc_bs_write_bit(0)
-
-    #b_timing_info_present
-    call avc_bs_write_bit(b_timing_info_present)
-    #i_num_units_in_tick
-    call avc_bs_write(i_num_units_in_tick,32)
-    #i_time_scale
-    call avc_bs_write(i_time_scale,32)
-    #b_fixed_frame_rate
-    call avc_bs_write_bit(b_fixed_frame_rate)
-
-    #nal_hrd_parameters_present_flag
-    call avc_bs_write_bit(0)
-    #vcl_hrd_parameters_present_flag
-    call avc_bs_write_bit(0)
-    #pic_struct_present_flag
-    call avc_bs_write_bit(0)
-    #b_bitstream_restriction
-    call avc_bs_write_bit(0)
-
-    call avc_bs_trailing()
-endfunction
-
-import "avc_bs_write_se" avc_bs_write_se
-
-function avc_pictureParameterSet()
-    sd nal_header
-    setcall nal_header shl((NAL_PRIORITY_HIGHEST),5)
-    or nal_header (NAL_PPS)
-    call avc_bs_write_byte(nal_header)
-
-    sd value
-
-    #id=0
-    call avc_bs_write_ue(0)
-    #sps_id=id
-    call avc_bs_write_ue(0)
-
-    #b_cabac=1
-    call avc_bs_write(1,1)
-    #b_pic_order=0
-    call avc_bs_write(0,1)
-    #i_num_slice_groups=1
-    sd s_groups=1
-    set value s_groups
-    dec value
-    call avc_bs_write_ue(value)
-    #i_num_ref_idx_l0_active=1;write num-1
-    call avc_bs_write_ue(0)
-    #i_num_ref_idx_l1_active=1;write num-1
-    call avc_bs_write_ue(0)
-    #b_weighted_pred=0
-    call avc_bs_write(0,1)
-    #b_weighted_bipred=0
-    call avc_bs_write(0,2)
-
-    #i_pic_init_qp
-    sd pic_init_qp=avc_pic_init_qp
-    set value pic_init_qp
-    sub value 26
-    call avc_bs_write_se(value)
-    #i_pic_init_qs
-    sd pic_init_qs=26
-    set value pic_init_qs
-    sub value 26
-    call avc_bs_write_se(value)
-    #i_chroma_qp_index_offset=i_chroma_qp_offset=0
-    call avc_bs_write_se(0)
-
-    #b_deblocking_filter_control=1
-    call avc_bs_write(1,1)
-    #b_constrained_intra_pred
-    call avc_bs_write(0,1)
-    #b_redundant_pic_cnt
-    call avc_bs_write(0,1)
-
-    call avc_bs_trailing()
-endfunction
-
-import "avc_slice_type" avc_slice_type
-import "avc_pre_input" avc_pre_input
-import "avc_input" avc_input
-
-function avc_enc_frame(sd pixbuf)
-    #get pixbuf to input i420
-    sd input
-    setcall input avc_pre_input((value_get))
-    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-    sd bytes
-    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
-    import "rgb_to_yuvi420" rgb_to_yuvi420
-    sd w
-    sd h
-    setcall w avc_width((value_get))
-    setcall h avc_height((value_get))
-    call rgb_to_yuvi420(bytes,input,w,h)
-
-    #write header
-    call avc_enc_frame_header()
-    #align
-    call avc_bs_align_byte()
-    #encode
-    call avc_enc_frame_content()
-endfunction
-function avc_enc_frame_header()
-    sd nal_slice_type
-    sd nal_priority
-    sd type=X264_TYPE_I
-    import "avc_frame_num" avc_frame_num
-    sd frame_num
-    setcall frame_num avc_frame_num((value_get))
-    import "avc_idr_pic_id" avc_idr_pic_id
-    #-1 if nal_type != 5
-    sd idr_pic_id
-    setcall idr_pic_id avc_idr_pic_id((value_get))
-    if frame_num==(avc_keyint_max)
-        set nal_slice_type (NAL_SLICE_IDR)
-        set nal_priority (NAL_PRIORITY_HIGHEST)
-        set type (X264_TYPE_I)
-
-        set frame_num 0
-        inc idr_pic_id
-        call avc_idr_pic_id((value_set),idr_pic_id)
-        setcall idr_pic_id rest(idr_pic_id,65536)
-        call avc_slice_type((value_set),(SLICE_TYPE_I))
-    else
-        set nal_slice_type (NAL_SLICE)
-        set type (X264_TYPE_AUTO)
-        set nal_priority (NAL_PRIORITY_HIGH)
-
-        inc frame_num
-        set idr_pic_id -1
-        call avc_slice_type((value_set),(SLICE_TYPE_P))
-    endelse
-    call avc_frame_num((value_set),frame_num)
-
-    #header
-    sd value
-
-    sd nal_header
-    setcall nal_header shl(nal_priority,5)
-    or nal_header nal_slice_type
-    call avc_bs_write(nal_header,8)
-
-    #i_first_mb
-    call avc_bs_write_ue(0)
-    #i_type
-    set value type
-    add value 5
-    call avc_bs_write_ue(value)
-    #i_pps_id=0
-    call avc_bs_write_ue(0)
-    #frame_num
-    sd log2_max_frame_num
-    setcall log2_max_frame_num avc_log2_max_frame_num((value_get))
-    call avc_bs_write(frame_num,log2_max_frame_num)
-    #idr_pic_id
-    if idr_pic_id>=0
-        call avc_bs_write_ue(idr_pic_id)
-    endif
-    #if poc_type==0
-
-    sd i_poc
-    sd log2_max_poc_lsb
-    sd i_poc_lsb
-    set i_poc frame_num
-    mult i_poc 2
-    setcall log2_max_poc_lsb avc_log2_max_poc_lsb((value_get))
-    setcall i_poc_lsb shl(1,log2_max_poc_lsb)
-    dec i_poc_lsb
-    and i_poc_lsb i_poc
-    call avc_bs_write(i_poc_lsb,log2_max_poc_lsb)
-
-    if type!=(X264_TYPE_I)
-        sd b_num_ref_idx_override=1
-        call avc_bs_write_bit(b_num_ref_idx_override)
-        sd i_num_ref_idx_l0_active=1
-        set value i_num_ref_idx_l0_active
-        dec value
-        call avc_bs_write_ue(value)
-
-        sd b_ref_pic_list_reordering_l0=0
-        call avc_bs_write_bit(b_ref_pic_list_reordering_l0)
-    endif
-
-    #NAL_PRIORITY_DISPOSABLE at B frames
-    #i_nal_ref_idc!=NAL_PRIORITY_DISPOSABLE
-    if idr_pic_id>=0
-        #no output of prior pics flag
-        call avc_bs_write_bit(0)
-        #long term reference flag
-        call avc_bs_write_bit(0)
-    else
-        #adaptive_ref_pic_marking_mode_flag
-        call avc_bs_write_bit(0)
-    endelse
-
-    #b_cabac && sh->i_type != SLICE_TYPE_I
-    if type!=(X264_TYPE_I)
-        sd i_cabac_init_idc=0
-        call avc_bs_write_ue(i_cabac_init_idc)
-    endif
-
-    #slice qp delta
-    import "avc_qp_I" avc_qp_I
-    sd qp_delta
-    setcall qp_delta avc_qp_I()
-    sub qp_delta (avc_pic_init_qp)
-    call avc_bs_write_se(qp_delta)
-
-    #if b_deblocking_filter_control
-        #qp_delta
-            #i_disable_deblocking_filter_idc=1
-    call avc_bs_write_ue(1)
-            #i_disable_deblocking_filter_idc!=1
-                #i_alpha_c0_offset
-    #call avc_bs_write_se(0)
-                #i_beta_offset
-    #call avc_bs_write_se(0)
-endfunction
-
-import "avc_mb_nr_left" avc_mb_nr_left
-import "avc_mb_nr_top" avc_mb_nr_top
-
-import "sar32" sar
-
-function avc_enc_frame_content()
-    import "avc_cabac_context_init" avc_cabac_context_init
-    call avc_cabac_context_init()
-    import "avc_cabac_range" avc_cabac_range
-    call avc_cabac_range((value_set),0x1fe)
-    import "avc_cabac_low" avc_cabac_low
-    call avc_cabac_low((value_set),0)
-    import "avc_cabac_sym_cnt" avc_cabac_sym_cnt
-    call avc_cabac_sym_cnt((value_set),0)
-    import "avc_cabac_bits_outstanding" avc_cabac_bits_outstanding
-    call avc_cabac_bits_outstanding((value_set),0)
-    import "avc_cabac_first_bit" avc_cabac_first_bit
-    call avc_cabac_first_bit((value_set),1)
-
-    sd mb_width
-    sd mb_height
-    setcall mb_width avc_mb_width((value_get))
-    setcall mb_height avc_mb_height((value_get))
-    sd pre_input
-    setcall pre_input avc_pre_input((value_get))
-    sd input
-    setcall input avc_input((value_get))
-    import "yuv_get_all_sizes" yuv_get_all_sizes
-    sd Y_area_pre
-    sd U_area_pre
-    sd V_area_pre
-    sd Y_area
-    sd U_area
-    sd V_area
-    sd planeY
-    sd planeU
-    sd planeV
-    sd planeY_pre
-    sd planeU_pre
-    sd planeV_pre
-    sd p_planeU^planeU
-    sd p_planeV^planeV
-    sd width
-    sd height
-    setcall width avc_width((value_get))
-    setcall height avc_height((value_get))
-    call yuv_get_all_sizes(width,height,p_planeU,p_planeV)
-    set planeU_pre planeU
-    set planeV_pre planeV
-    set planeY_pre pre_input
-    add planeU_pre pre_input
-    add planeV_pre pre_input
-    set Y_area_pre planeY_pre
-    set U_area_pre planeU_pre
-    set V_area_pre planeV_pre
-    set planeY input
-    add planeU input
-    add planeV input
-    set Y_area planeY
-    set U_area planeU
-    set V_area planeV
-    sd strideY
-    sd strideUV
-    set strideY width
-    set strideUV width
-    div strideUV 2
-
-    sd y=0
-    while y!=mb_height
-        call avc_mb_nr_top((value_set),y)
-        sd x=0
-        while x!=mb_width
-            call avc_mb_nr_left((value_set),x)
-            #skip or code
-            sd mb_type=avc_I_16x16
-            sd slice_type
-            setcall slice_type avc_slice_type((value_get))
-            if slice_type!=(SLICE_TYPE_I)
-                import "mpeg_block_iteration_compare" mpeg_block_iteration_compare
-                sd mode
-                setcall mode mpeg_block_iteration_compare(Y_area,Y_area_pre,U_area,U_area_pre,V_area,V_area_pre,strideY,strideUV,x,y)
-                if mode==(SKIP)
-                    set mb_type (avc_P_SKIP)
-                endif
-            endif
-            if mb_type==(avc_I_16x16)
-                #get the block bytes on the current input
-                import "mpeg_block_iteration_copy" mpeg_block_iteration_copy
-                call mpeg_block_iteration_copy(Y_area,Y_area_pre,U_area,U_area_pre,V_area,V_area_pre,strideY,strideUV,x,y)
-            endif
-
-            #init cache
-            import "avc_mb_cache_init" avc_mb_cache_init
-            call avc_mb_cache_init(x,y,mb_type)
-
-            sd call_terminal=1
-            if y==0
-                if x==0
-                    set call_terminal 0
-                endif
-            endif
-            if call_terminal==1
-                import "avc_cabac_terminal" avc_cabac_terminal
-                call avc_cabac_terminal(0)
-            endif
-            if mb_type==(avc_P_SKIP)
-                call avc_cabac_skip(1,x,y)
-            else
-                import "avc_block" avc_block
-                call avc_block(planeY,planeU,planeV,x,y)
-                if slice_type!=(SLICE_TYPE_I)
-                    call avc_cabac_skip(0,x,y)
-                endif
-                import "avc_mb_write_cabac" avc_mb_write_cabac
-                call avc_mb_write_cabac(slice_type)
-            endelse
-            import "avc_mb_cache_save" avc_mb_cache_save
-            call avc_mb_cache_save(x,y)
-
-            add planeY_pre 16
-            add planeU_pre 8
-            add planeV_pre 8
-            add planeY 16
-            add planeU 8
-            add planeV 8
-            inc x
-        endwhile
-        #add 16-1 rows at luma input and 8-1 rows at chroma
-        sd alpha=0
-        while alpha!=15
-            add planeY_pre strideY
-            add planeY strideY
-            inc alpha
-        endwhile
-        set alpha 0
-        while alpha!=7
-            add planeU_pre strideUV
-            add planeV_pre strideUV
-            add planeU strideUV
-            add planeV strideUV
-            inc alpha
-        endwhile
-        inc y
-    endwhile
-    call avc_cabac_terminal(1)
-    call avc_cabac_flush()
-    #i_cabac_word =
-    #(
-    #    (
-    #        (
-    #            3 * h->cabac.i_sym_cnt - 3 * 96 * h->sps->i_mb_width * h->sps->i_mb_height
-    #        )
-    #        /32
-    #    )
-    #    - bs_pos( &h->out.bs)/8
-    #)
-    #/3
-    sd cabac_word
-    sd value
-    setcall cabac_word avc_cabac_sym_cnt((value_get))
-    mult cabac_word 3
-    set value (3*96)
-    mult value mb_width
-    mult value mb_height
-    sub cabac_word value
-    div cabac_word 32
-
-    #8 * ( s->p - s->p_start ) + 8 - s->i_left
-    setcall value avc_output_size((value_get))
-
-    #div value 8
-    sub cabac_word value
-    div cabac_word 3
-    while cabac_word>0
-        call avc_bs_write(0x0000,16)
-        dec cabac_word
-    endwhile
-endfunction
-
-function avc_cabac_flush()
-    import "avc_cabac_putbit" avc_cabac_putbit
-    sd value
-    setcall value avc_cabac_low((value_get))
-    setcall value sar(value,9)
-    and value 1
-    call avc_cabac_putbit(value)
-    setcall value avc_cabac_low((value_get))
-    setcall value sar(value,8)
-    and value 1
-    call avc_bs_write_bit(value)
-    call avc_bs_write_bit(1)
-    import "avc_bs_align_byte_with_0" avc_bs_align_byte_with_0
-    call avc_bs_align_byte_with_0()
-endfunction
-
-import "avc_cabac_decision" avc_cabac_decision
-
-function avc_cabac_skip(sd b_skip,sd x,sd y)
-    sd ctx=0
-    sd left
-    sd top
-    import "avc_mb_data" avc_mb_data
-    if x>0
-        sd left_type
-        set left x
-        dec left
-        setcall left_type avc_mb_data((value_item),(avc_mb_type_offset),left,y)
-        if left_type!=(avc_P_SKIP)
-            inc ctx
-        endif
-    endif
-    if y>0
-        sd top_type
-        set top y
-        dec top
-        setcall top_type avc_mb_data((value_item),(avc_mb_type_offset),x,top)
-        if top_type!=(avc_P_SKIP)
-            inc ctx
-        endif
-    endif
-
-    add ctx 11
-    call avc_cabac_decision(ctx,b_skip)
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-avc_mb.oc
@@ -0,0 +1,697 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+const I_PRED_16x16_DC=2
+#const I_PRED_CHROMA_DC=0
+
+import "array_get_int" array_get_int
+import "sar32" sar
+import "shl" shl
+import "avc_cabac_ctxstate" avc_cabac_ctxstate
+
+function avc_cabac_context_init()
+    sd cabac
+    import "avc_slice_type" avc_slice_type
+    sd slice_type
+    setcall slice_type avc_slice_type((value_get))
+    if slice_type=(SLICE_TYPE_I)
+        setcall cabac avc_cabac_context_init_I()
+    else
+        setcall cabac avc_cabac_context_init_P()
+    endelse
+    sd i=0
+    import "avc_qp_I" avc_qp_I
+    sd qp
+    setcall qp avc_qp_I()
+    sd ctxstate
+    setcall ctxstate avc_cabac_ctxstate()
+    while i<(avc_ctxstate_total)
+        sd pre_state
+        sd a_value
+        sd b_value
+        sd pos=2
+        mult pos i
+        setcall a_value array_get_int(cabac,pos)
+        inc pos
+        setcall b_value array_get_int(cabac,pos)
+        mult a_value qp
+        setcall a_value sar(a_value,4)
+        add a_value b_value
+        setcall pre_state avc_clip3(a_value,1,126)
+        if pre_state<=63
+            set ctxstate# 63
+            sub ctxstate# pre_state
+            add ctxstate 4
+            set ctxstate# 0
+            add ctxstate 4
+        else
+            set ctxstate# pre_state
+            sub ctxstate# 64
+            add ctxstate 4
+            set ctxstate# 1
+            add ctxstate 4
+        endelse
+        set ctxstate# 0
+        add ctxstate 4
+        inc i
+    endwhile
+endfunction
+
+function avc_clip3(sd x,sd min,sd max)
+	if x<min
+        return min
+	endif
+	if x>max
+            return max
+	endif
+            return x
+endfunction
+
+function avc_cabac_context_init_I()
+    #[460][2]
+    data    context_0_10={20, -15,    2, 54,     3,  74,     20, -15}
+    data *              ={2,  54,     3, 74,     -28,127,    -23,104}
+    data *              ={-6, 53,     -1,54,     7,  51}
+    data *11-23 not at I={0,  0,      0, 0,      0,  0,      0,  0}
+    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
+    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
+    data *              ={0,  0}
+    data *24-39         ={0,  0,      0, 0,      0,  0,      0,  0}
+    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
+    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
+    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
+    data *40-53         ={0,  0,      0, 0,      0,  0,      0,  0}
+    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
+    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
+    data *              ={0,  0,      0, 0}
+    data *54-59         ={0,  0,      0, 0,      0,  0,      0,  0}
+    data *              ={0,  0,      0, 0}
+    data *60-69         ={0,  41,     0, 63,     0,  63,     0,  63}
+    data *              ={-9, 83,     4, 86,     0,  97,     -7, 72}
+    data *              ={13, 41,     3, 62}
+    data *70-87         ={0,  11,     1, 55,     0,  69,     -17,127}
+    data *              ={-13,102,    0, 82,     -7, 74,     -21,107}
+    data *              ={-27,127,   -31,127,    -24,127,    -18,95}
+    data *              ={-27,127,   -21,114,    -30,127,    -17,123}
+    data *              ={-12,115,   -16,122}
+    data *88-104        ={-11,115,   -12,63,     -2, 68,     -15,84}
+    data *              ={-13,104,   -3, 70,     -8, 93,     -10,90}
+    data *              ={-30,127,   -1, 74,     -6, 97,     -7, 91}
+    data *              ={-20,127,   -4, 56,     -5, 82,     -7, 76}
+    data *              ={-22,125}
+    data *105-135       ={-7, 93,    -11,87,     -3, 77,     -5, 71}
+    data *              ={-4, 63,    -4, 68,     -12,84,     -7, 62}
+    data *              ={-7, 65,    8,  61,     5,  56,     -2, 66}
+    data *              ={1,  64,    0,  61,     -2, 78,     1,  50}
+    data *              ={7,  52,    10, 35,     0,  44,     11, 38}
+    data *              ={1,  45,    0,  46,     5,  44,     31, 17}
+    data *              ={1,  51,    7,  50,     28, 19,     16, 33}
+    data *              ={14, 62,    -13,108,    -15,100}
+    data *136-165       ={-13, 101, -13, 91,  -12, 94,    -10, 88}
+    data *              ={-16, 84,  -10, 86,  -7, 83,     -13, 87}
+    data *              ={-19, 94,  1, 70,    0, 72,      -5, 74}
+    data *              ={18, 59,   -8, 102,  -15, 100,   0, 95}
+    data *              ={-4, 75,   2, 72,    -11, 75,    -3, 71}
+    data *              ={15, 46,   -13, 69,  0, 62,      0, 65}
+    data *              ={21, 37,   -15, 72,  9, 57,      16, 54}
+    data *              ={0, 62,    12, 72}
+    data *166-196       ={24, 0,   15, 9,   8, 25,     13, 18}
+    data *              ={15, 9,   13, 19,  10, 37,    12, 18}
+    data *              ={6, 29,   20, 33,  15, 30,    4, 45}
+    data *              ={1, 58,   0, 62,   7, 61,     12, 38}
+    data *              ={11, 45,  15, 39,  11, 42,    13, 44}
+    data *              ={16, 45,  12, 41,  10, 49,    30, 34}
+    data *              ={18, 42,  10, 55,  17, 51,    17, 46}
+    data *              ={0, 89,   26, -19, 22, -17}
+    data *197-226       ={26, -17, 30, -25, 28, -20,   33, -23}
+    data *              ={37, -27, 33, -23, 40, -28,   38, -17}
+    data *              ={33, -11, 40, -15, 41, -6,    38, 1}
+    data *              ={41, 17,  30, -6,  27, 3,     26, 22}
+    data *              ={37, -16, 35, -4,  38, -8,    38, -3}
+    data *              ={37, 3,   38, 5,   42, 0,     35, 16}
+    data *              ={39, 22,  14, 48,  27, 37,    21, 60}
+    data *              ={12, 68,  2, 97}
+    data *227-251       ={-3, 71,  -6, 42,  -5, 50,    -3, 54}
+    data *              ={-2, 62,  0, 58,   1, 63,     -2, 72}
+    data *              ={-1, 74,  -9, 91,  -5, 67,    -5, 27}
+    data *              ={-3, 39,  -2, 44,  0, 46,     -16, 64}
+    data *              ={-8, 68,  -10, 78, -6, 77,    -10, 86}
+    data *              ={-12, 92, -15, 55, -10, 60,   -6, 62}
+    data *              ={-4, 65}
+    data *252-275       ={-12, 73, -8, 76,  -7, 80,    -9, 88}
+    data *              ={-17, 110,-11, 97, -20, 84,   -11, 79}
+    data *              ={-6, 73,  -4, 74,  -13, 86,   -13, 96}
+    data *              ={-11, 97, -19, 117,-8, 78,    -5, 33}
+    data *              ={-4, 48,  -2, 53,  -3, 62,    -13, 71}
+    data *              ={-10, 79, -12, 86, -13, 90,   -14, 97}
+    #276 is special (not used, x264_cabac_encode_bypass is used instead)
+    data *              ={0, 0}
+    data *277-307       ={-6, 93,  -6, 84,  -8, 79,    0, 66}
+    data *              ={-1, 71,  0, 62,   -2, 60,    -2, 59}
+    data *              ={-5, 75,  -3, 62,  -4, 58,    -9, 66}
+    data *              ={-1, 79,  0, 71,   3, 68,     10, 44}
+    data *              ={-7, 62,  15, 36,  14, 40,    16, 27}
+    data *              ={12, 29,  1, 44,   20, 36,    18, 32}
+    data *              ={5, 42,   1, 48,   10, 62,    17, 46}
+    data *              ={9, 64,   -12, 104,-11, 97}
+    data *308-337       ={-16, 96, -7, 88,  -8, 85,    -7, 85}
+    data *              ={-9, 85,  -13, 88, 4, 66,     -3, 77}
+    data *              ={-3, 76,  -6, 76,  10, 58,    -1, 76}
+    data *              ={-1, 83,  -7, 99,  -14, 95,   2, 95}
+    data *              ={0, 76,   -5, 74,  0, 70,     -11, 75}
+    data *              ={1, 68,   0, 65,   -14, 73,   3, 62}
+    data *              ={4, 62,   -1, 68,  -13, 75,   11, 55}
+    data *              ={5, 64,   12, 70}
+    data *338-368       ={15, 6,   6, 19,   7, 16,     12, 14}
+    data *              ={18, 13,  13, 11,  13, 15,    15, 16}
+    data *              ={12, 23,  13, 23,  15, 20,    14, 26}
+    data *              ={14, 44,  17, 40,  17, 47,    24, 17}
+    data *              ={21, 21,  25, 22,  31, 27,    22, 29}
+    data *              ={19, 35,  14, 50,  10, 57,    7, 63}
+    data *              ={-2, 77,  -4, 82,  -3, 94,    9, 69}
+    data *              ={-12, 109,36, -35, 36, -34}
+    data *369-398       ={32, -26, 37, -30, 44, -32,   34, -18}
+    data *              ={34, -15, 40, -15, 33, -7,    35, -5}
+    data *              ={33, 0,   38, 2,   33, 13,    23, 35}
+    data *              ={13, 58,  29, -3,  26, 0,     22, 30}
+    data *              ={31, -7,  35, -15, 34, -3,    34, 3}
+    data *              ={36, -1,  34, 5,   32, 11,    35, 5}
+    data *              ={34, 12,  39, 11,  30, 29,    34, 26}
+    data *              ={29, 39,  19, 66}
+    data *399-435       ={31,  21,  31,  31,  25,  50}
+    data *              ={-17, 120, -20, 112, -18, 114, -11,  85}
+    data *              ={-15,  92, -14,  89, -26,  71, -15,  81}
+    data *              ={-14,  80,   0,  68, -14,  70, -24,  56}
+    data *              ={-23,  68, -24,  50, -11,  74,  23, -13}
+    data *              ={26, -13,  40, -15,  49, -14,  44,   3}
+    data *              ={45,   6,  44,  34,  33,  54,  19,  82}
+    data *              ={-3,  75,  -1,  23,   1,  34,   1,  43}
+    data *              ={0,  54,  -2,  55,   0,  61,   1,  64}
+    data *              ={0,  68,  -9,  92}
+    data *436-459       ={-14, 106, -13,  97, -15,  90, -12,  90}
+    data *              ={-18,  88, -10,  73, -9,  79, -14,  86}
+    data *              ={-10,  73, -10,  70, -10,  69, -5,  66}
+    data *              ={-9,  64, -5,  58,  2,  59, 21, -10}
+    data *              ={24, -11, 28,  -8, 28,  -1, 29,   3}
+    data *              ={29,   9, 35,  20, 29,  36, 14,  67}
+    data cabac_I^context_0_10
+    return cabac_I
+endfunction
+
+function avc_cabac_context_init_P()
+    #[460][2]
+    data context_0_10={20, -15,    2,  54,    3,  74,   20, -15}
+    data *           ={2,  54,    3,  74,  -28, 127,  -23, 104}
+    data *           ={-6,  53,   -1,  54,    7,  51}
+    data *11-23      ={23,  33,   23,   2,   21,   0,    1,   9}
+    data *           ={0,  49,  -37, 118,    5,  57,  -13,  78}
+    data *           ={-11,  65,    1,  62,   12,  49,   -4,  73}
+    data *           ={17,  50}
+    data *24-39      ={18,  64,    9,  43,   29,   0,   26,  67}
+    data *           ={16,  90,    9, 104,  -46, 127,  -20, 104}
+    data *           ={1,  67,  -13,  78,  -11,  65,    1,  62}
+    data *           ={-6,  86,  -17,  95,   -6,  61,    9,  45}
+    data *40-53      ={-3,  69,   -6,  81,  -11,  96,    6,  55}
+    data *           ={7,  67,   -5,  86,    2,  88,    0,  58}
+    data *           ={-3,  76,  -10,  94,    5,  54,    4,  69}
+    data *           ={-3,  81,    0,  88}
+    data *54-59      ={-7,  67,   -5,  74,   -4,  74,   -5,  80}
+    data *           ={-7,  72,    1,  58}
+    data *60-69      ={0,  41,    0,  63,    0,  63,  0, 63}
+    data *           ={-9,  83,    4,  86,    0,  97,  -7, 72}
+    data *           ={13,  41,    3,  62}
+    data *70-87      ={0,  45,   -4,  78,   -3,  96,  -27,  126}
+    data *           ={-28,  98,  -25, 101,  -23,  67,  -28,  82}
+    data *           ={-20,  94,  -16,  83,  -22, 110,  -21,  91}
+    data *           ={-18, 102,  -13,  93,  -29, 127,   -7,  92}
+    data *           ={-5,  89,   -7,  96,  -13, 108,   -3,  46}
+    data *           ={-1,  65,   -1,  57,   -9,  93,   -3,  74}
+    data *           ={-9,  92,   -8,  87,  -23, 126,    5,  54}
+    data *           ={6,  60,    6,  59,    6,  69,   -1,  48}
+    data *           ={0,  68,   -4,  69,   -8,  88}
+    data *105-165    ={-2,  85,   -6,  78,   -1,  75,   -7,  77}
+    data *           ={2,  54,    5,  50,   -3,  68,    1,  50}
+    data *           ={6,  42,   -4,  81,    1,  63,   -4,  70}
+    data *           ={0,  67,    2,  57,   -2,  76,   11,  35}
+    data *           ={4,  64,    1,  61,   11,  35,   18,  25}
+    data *           ={12,  24,   13,  29,   13,  36,  -10,  93}
+    data *           ={-7,  73,   -2,  73,   13,  46,    9,  49}
+    data *           ={-7, 100,    9,  53,    2,  53,    5,  53}
+    data *           ={-2,  61,    0,  56,    0,  56,  -13,  63}
+    data *           ={-5,  60,   -1,  62,    4,  57,   -6,  69}
+    data *           ={4,  57,   14,  39,    4,  51,   13,  68}
+    data *           ={3,  64,    1,  61,    9,  63,   7,  50}
+    data *           ={16,  39,    5,  44,    4,  52,   11,  48}
+    data *           ={-5,  60,   -1,  59,   0,  59,   22,  33}
+    data *           ={5,  44,   14,  43,   -1,  78,    0,  60}
+    data *           ={9,  69}
+    data *166 - 226  ={11,  28,    2,  40,    3,  44,    0,  49}
+    data *           ={0,  46,    2,  44,    2,  51,    0,  47}
+    data *           ={4,  39,    2,  62,    6,  46,    0,  54}
+    data *           ={3,  54,    2,  58,    4,  63,    6,  51}
+    data *           ={6,  57,    7,  53,    6,  52,    6,  55}
+    data *           ={11,  45,  14,  36,    8,  53,   -1,  82}
+    data *           ={7,  55,   -3,  78,   15,  46,   22,  31}
+    data *           ={-1,  84,   25,   7,   30,  -7,   28,   3}
+    data *           ={28,   4,   32,   0,   34,  -1,   30,   6}
+    data *           ={30,   6,   32,   9,   31,  19,   26,  27}
+    data *           ={26,  30,   37,  20,   28,  34,   17,  70}
+    data *           ={1,  67,    5,  59,    9,  67,   16,  30}
+    data *           ={18,  32,   18,  35,   22,  29,   24,  31}
+    data *           ={23,  38,   18,  43,   20,  41,   11,  63}
+    data *           ={9,  59,    9,  64,   -1,  94,   -2,  89}
+    data *           ={-9, 108}
+    data *227 - 275  ={-6,  76,   -2,  44,    0,  45,    0,  52}
+    data *           ={-3,  64,   -2,  59,   -4,  70,   -4,  75}
+    data *           ={-8,  82,  -17, 102,   -9,  77,    3,  24}
+    data *           ={0,  42,    0,  48,    0,  55,   -6,  59}
+    data *           ={-7,  71,  -12,  83,  -11,  87,  -30, 119}
+    data *           ={1,  58,   -3,  29,   -1,  36,    1,  38}
+    data *           ={2,  43,   -6,  55,    0,  58,    0,  64}
+    data *           ={-3,  74,  -10,  90,    0,  70,   -4,  29}
+    data *           ={5,  31,    7,  42,    1,  59,   -2,  58}
+    data *           ={-3,  72,   -3,  81,  -11,  97,    0,  58}
+    data *           ={8,   5,  10,  14,   14,  18,   13,  27}
+    data *           ={2,  40,    0,  58,   -3,  70,   -6,  79}
+    data *           ={-8,  85}
+    #276 (not used, x264_cabac_encode_bypass is used instead)
+    data *           ={0, 0}
+    data *277 - 337  ={-13, 106,  -16, 106,  -10,  87,  -21, 114}
+    data *           ={-18, 110,  -14,  98,  -22, 110,  -21, 106}
+    data *           ={-18, 103,  -21, 107,  -23, 108,  -26, 112}
+    data *           ={-10,  96,  -12,  95,   -5,  91,   -9,  93}
+    data *           ={-22,  94,   -5,  86,    9,  67,   -4,  80}
+    data *           ={-10,  85,   -1,  70,    7,  60,    9,  58}
+    data *           ={5,  61,   12,  50,   15,  50,   18,  49}
+    data *           ={17,  54,   10,  41,    7,  46,   -1,  51}
+    data *           ={7,  49,    8,  52,    9,  41,    6,  47}
+    data *           ={2,  55,   13,  41,   10,  44,    6,  50}
+    data *           ={5,  53,   13,  49,    4,  63,    6,  64}
+    data *           ={-2,  69,   -2,  59,    6,  70,   10,  44}
+    data *           ={9,  31,   12,  43,    3,  53,   14,  34}
+    data *           ={10,  38,   -3,  52,   13,  40,   17,  32}
+    data *           ={7,  44,    7,  38,   13,  50,   10,  57}
+    data *           ={26,  43}
+    data *338 - 398  ={14,  11,   11,  14,    9,  11,   18,  11}
+    data *           ={21,   9,   23,  -2,   32, -15,   32, -15}
+    data *           ={34, -21,   39, -23,   42, -33,   41, -31}
+    data *           ={46, -28,   38, -12,   21,  29,   45, -24}
+    data *           ={53, -45,   48, -26,   65, -43,   43, -19}
+    data *           ={39, -10,   30,   9,   18,  26,   20,  27}
+    data *           ={0,  57,  -14,  82,   -5,  75,  -19,  97}
+    data *           ={-35, 125,   27,   0,   28,   0,   31,  -4}
+    data *           ={27,   6,   34,   8,   30,  10,   24,  22}
+    data *           ={33,  19,   22,  32,   26,  31,   21,  41}
+    data *           ={26,  44,   23,  47,   16,  65,   14,  71}
+    data *           ={8,  60,    6,  63,   17,  65,   21,  24}
+    data *           ={23,  20,   26,  23,   27,  32,   28,  23}
+    data *           ={28,  24,   23,  40,   24,  32,   28,  29}
+    data *           ={23,  42,   19,  57,   22,  53,   22,  61}
+    data *           ={11,  86}
+    data *399 - 435  ={12,  40,   11,  51,   14,  59}
+    data *           ={-4,  79,   -7,  71,   -5,  69,   -9,  70}
+    data *           ={-8,  66,  -10,  68,  -19,  73,  -12,  69}
+    data *           ={-16,  70,  -15,  67,  -20,  62,  -19,  70}
+    data *           ={-16,  66,  -22,  65,  -20,  63,    9,  -2}
+    data *           ={26,  -9,   33,  -9,   39,  -7,   41,  -2}
+    data *           ={45,   3,   49,   9,   45,  27,   36,  59}
+    data *           ={-6,  66,   -7,  35,   -7,  42,   -8,  45}
+    data *           ={-5,  48,  -12,  56,   -6,  60,   -5,  62}
+    data *           ={-8,  66,   -8,  76}
+    data *436 - 459  ={-5,  85,   -6,  81,  -10,  77,   -7,  81}
+    data *           ={-17,  80,  -18,  73,   -4,  74,  -10,  83}
+    data *           ={-9,  71,   -9,  67,   -1,  61,   -8,  66}
+    data *           ={-14,  66,    0,  59,    2,  59,   21, -13}
+    data *           ={33, -14,   39,  -7,   46,  -2,   51,   2}
+    data *           ={60,   6,   61,  17,   55,  34,   42,  62}
+    data cabac_P^context_0_10
+    return cabac_P
+endfunction
+
+
+function avc_cabac_range_lps(sd a,sd b)
+    #[64][4]
+    data cabac_range={128, 176, 208, 240, 128, 167, 197, 227, 128, 158, 187, 216}
+    data *          ={123, 150, 178, 205, 116, 142, 169, 195, 111, 135, 160, 185}
+    data *          ={105, 128, 152, 175, 100, 122, 144, 166,  95, 116, 137, 158}
+    data *          ={90, 110, 130, 150,  85, 104, 123, 142,  81,  99, 117, 135}
+    data *          ={77,  94, 111, 128,  73,  89, 105, 122,  69,  85, 100, 116}
+    data *          ={66,  80,  95, 110,  62,  76,  90, 104,  59,  72,  86,  99}
+    data *          ={56,  69,  81,  94,  53,  65,  77,  89,  51,  62,  73,  85}
+    data *          ={48,  59,  69,  80,  46,  56,  66,  76,  43,  53,  63,  72}
+    data *          ={41,  50,  59,  69,  39,  48,  56,  65,  37,  45,  54,  62}
+    data *          ={35,  43,  51,  59,  33,  41,  48,  56,  32,  39,  46,  53}
+    data *          ={30,  37,  43,  50,  29,  35,  41,  48,  27,  33,  39,  45}
+    data *          ={26,  31,  37,  43,  24,  30,  35,  41,  23,  28,  33,  39}
+    data *          ={22,  27,  32,  37,  21,  26,  30,  35,  20,  24,  29,  33}
+    data *          ={19,  23,  27,  31,  18,  22,  26,  30,  17,  21,  25,  28}
+    data *          ={16,  20,  23,  27,  15,  19,  22,  25,  14,  18,  21,  24}
+    data *          ={14,  17,  20,  23,  13,  16,  19,  22,  12,  15,  18,  21}
+    data *          ={12,  14,  17,  20,  11,  14,  16,  19,  11,  13,  15,  18}
+    data *          ={10,  12,  15,  17,  10,  12,  14,  16,   9,  11,  13,  15}
+    data *          ={9,  11,  12,  14,   8,  10,  12,  14,   8,   9,  11,  13}
+    data *          ={7,   9,  11,  12,   7,   9,  10,  12,   7,   8,  10,  11}
+    data *          ={6,   8,   9,  11,   6,   7,   9,  10,   6,   7,   8,   9}
+    data *          ={2,   2,   2,   2}
+    sd cabac^cabac_range
+    mult a (4*4)
+    mult b 4
+    add cabac a
+    add cabac b
+    return cabac#
+endfunction
+
+function avc_transition_lps(sd a)
+    #[64]
+    data transition={0, 0, 1, 2, 2, 4, 4, 5, 6, 7, 8, 9, 9,11,11,12}
+    data *         ={13,13,15,15,16,16,18,18,19,19,21,21,22,22,23,24}
+    data *         ={24,25,26,26,27,27,28,29,29,30,30,30,31,32,32,33}
+    data *         ={33,33,34,34,35,35,35,36,36,36,37,37,37,38,38,63}
+    sd trans^transition
+    mult a 4
+    add trans a
+    return trans#
+endfunction
+
+function avc_transition_mps(sd a)
+    #[64]
+    data transition={1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16}
+    data *         ={17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32}
+    data *         ={33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48}
+    data *         ={49,50,51,52,53,54,55,56,57,58,59,60,61,62,62,63}
+    sd trans^transition
+    mult a 4
+    add trans a
+    return trans#
+endfunction
+
+import "avc_mb_nr_left" avc_mb_nr_left
+import "avc_mb_nr_top" avc_mb_nr_top
+
+function avc_mb_write_cabac(sd slice_type)
+    #Write the MB type
+    call avc_mb_type(slice_type)
+
+    #write chroma pred mode
+    call avc_mb_intra_chroma_pred_mode()
+
+    #i_cbp_luma > 0 || i_cbp_chroma > 0 || i_mb_type == I_16x16
+    import "avc_residual_luma" avc_residual_luma
+    import "avc_residual_write" avc_residual_write
+    import "avc_cbp_luma" avc_cbp_luma
+    call avc_mb_qp_delta()
+    #dc luma
+    sd residual_luma
+    setcall residual_luma avc_residual_luma()
+                                             #,idx=0
+    call avc_residual_write(residual_luma,0,16)
+    #ac luma
+    sd i
+    sd cbp_luma
+    setcall cbp_luma avc_cbp_luma((value_get))
+    if cbp_luma!=0
+        import "avc_residual_ac" avc_residual_ac
+        sd residual_ac
+        setcall residual_ac avc_residual_ac((value_get))
+        set i 0
+        while i!=16
+            call avc_residual_write(residual_ac,1,15,i)
+            add residual_ac (15*DWORD)
+            inc i
+        endwhile
+    endif
+
+    #Chroma DC residual present
+    import "avc_cbp_chroma" avc_cbp_chroma
+    sd cbp_chroma
+    setcall cbp_chroma avc_cbp_chroma((value_get))
+    sd value
+    set value cbp_chroma
+    and value 3
+    if value!=0
+        import "avc_chroma_dc_u" avc_chroma_dc_u
+        import "avc_chroma_dc_v" avc_chroma_dc_v
+        sd chroma_dc_u
+        sd chroma_dc_v
+        setcall chroma_dc_u avc_chroma_dc_u()
+        setcall chroma_dc_v avc_chroma_dc_v()
+        call avc_residual_write(chroma_dc_u,3,4,0)
+        call avc_residual_write(chroma_dc_v,3,4,1)
+    endif
+
+    #Chroma AC residual present
+    set value cbp_chroma
+    and value 2
+    if value!=0
+        import "avc_residual_ac_ch" avc_residual_ac_ch
+        sd residual_ac_ch
+        setcall residual_ac_ch avc_residual_ac_ch()
+        set i 0
+        while i<8
+            call avc_residual_write(residual_ac_ch,4,15,i)
+            add residual_ac_ch (15*DWORD)
+            inc i
+        endwhile
+    endif
+endfunction
+
+function avc_mb_type(sd slice_type)
+    sd mb_nr_left
+    sd mb_nr_top
+    if slice_type=(SLICE_TYPE_I)
+        setcall mb_nr_left avc_mb_nr_left((value_get))
+        setcall mb_nr_top avc_mb_nr_top((value_get))
+        sd ctx=0
+        if mb_nr_left>0
+            inc ctx
+        endif
+        if mb_nr_top>0
+            inc ctx
+        endif
+        sd value
+        set value ctx
+        add value 3
+        call avc_mb_type_intra(value,(3+3),(3+4),(3+5),(3+6),(3+7))
+    else
+        #prefix
+        call avc_cabac_decision(14,1)
+        #suffix
+        call avc_mb_type_intra((17+0),(17+1),(17+2),(17+2),(17+3),(17+3))
+    endelse
+endfunction
+
+function avc_mb_type_intra(sd ctx0,sd ctx1,sd ctx2,sd ctx3,sd ctx4,sd ctx5)
+    call avc_cabac_decision(ctx0,1)
+    call avc_cabac_terminal(0)
+    sd cbp_luma
+    setcall cbp_luma avc_cbp_luma((value_get))
+    if cbp_luma=0
+        call avc_cabac_decision(ctx1,0)
+    else
+        call avc_cabac_decision(ctx1,1)
+    endelse
+
+    sd cbp_chroma
+    setcall cbp_chroma avc_cbp_chroma((value_get))
+    if cbp_chroma=0
+        call avc_cabac_decision(ctx2,0)
+    else
+        call avc_cabac_decision(ctx2,1)
+        if cbp_chroma=1
+            call avc_cabac_decision(ctx3,0)
+        else
+            call avc_cabac_decision(ctx3,1)
+        endelse
+    endelse
+
+    sd i_intra16x16_pred_mode=I_PRED_16x16_DC
+    import "rest" rest
+    sd pred_mode_rest
+    setcall pred_mode_rest rest(i_intra16x16_pred_mode,2)
+    div i_intra16x16_pred_mode 2
+    if i_intra16x16_pred_mode!=0
+        call avc_cabac_decision(ctx4,1)
+    else
+        call avc_cabac_decision(ctx4,0)
+    endelse
+    call avc_cabac_decision(ctx5,pred_mode_rest)
+endfunction
+
+import "avc_cabac_ctxstate_value" avc_cabac_ctxstate_value
+import "avc_cabac_ctxstate_value_set" avc_cabac_ctxstate_value_set
+import "avc_cabac_range" avc_cabac_range
+import "avc_cabac_low" avc_cabac_low
+import "avc_cabac_sym_cnt" avc_cabac_sym_cnt
+
+function avc_cabac_decision(sd ctx,sd b)
+    sd state
+    setcall state avc_cabac_ctxstate_value(ctx,(avc_ctxstate_state))
+    sd mps
+    setcall mps avc_cabac_ctxstate_value(ctx,(avc_ctxstate_mps))
+    sd range
+    setcall range avc_cabac_range((value_get))
+    sd i_range
+    set i_range range
+    setcall i_range sar(range,6)
+    and i_range 0x03
+    sd range_lps
+    setcall range_lps avc_cabac_range_lps(state,i_range)
+
+    sub range range_lps
+    call avc_cabac_range((value_set),range)
+    sd value
+    if b!=mps
+        sd low
+        setcall low avc_cabac_low((value_get))
+        add low range
+        call avc_cabac_low((value_set),low)
+        call avc_cabac_range((value_set),range_lps)
+        if state=0
+            set value 1
+            sub value mps
+            call avc_cabac_ctxstate_value_set(ctx,(avc_ctxstate_mps),value)
+        endif
+        setcall value avc_transition_lps(state)
+        call avc_cabac_ctxstate_value_set(ctx,(avc_ctxstate_state),value)
+    else
+        setcall value avc_transition_mps(state)
+        call avc_cabac_ctxstate_value_set(ctx,(avc_ctxstate_state),value)
+    endelse
+    setcall value avc_cabac_ctxstate_value(ctx,(avc_ctxstate_count))
+    inc value
+    call avc_cabac_ctxstate_value_set(ctx,(avc_ctxstate_count),value)
+
+    call avc_cabac_encode_renorm()
+
+    setcall value avc_cabac_sym_cnt((value_get))
+    inc value
+    call avc_cabac_sym_cnt((value_set),value)
+endfunction
+
+import "avc_cabac_bits_outstanding" avc_cabac_bits_outstanding
+
+function avc_cabac_encode_renorm()
+    sd range
+    setcall range avc_cabac_range((value_get))
+    sd low
+    setcall low avc_cabac_low((value_get))
+    while range<0x0100
+        if low<0x100
+            call avc_cabac_putbit(0)
+        else
+            if low>=0x200
+                sub low 0x200
+                call avc_cabac_low((value_set),low)
+                call avc_cabac_putbit(1)
+            else
+                sub low 0x100
+                call avc_cabac_low((value_set),low)
+                sd bits
+                setcall bits avc_cabac_bits_outstanding((value_get))
+                inc bits
+                call avc_cabac_bits_outstanding((value_set),bits)
+            endelse
+        endelse
+        setcall range shl(range,1)
+        call avc_cabac_range((value_set),range)
+        setcall low shl(low,1)
+        call avc_cabac_low((value_set),low)
+    endwhile
+endfunction
+
+import "avc_bs_write_bit" avc_bs_write_bit
+
+import "avc_cabac_first_bit" avc_cabac_first_bit
+
+function avc_cabac_putbit(sd bit)
+    sd first_bit
+    setcall first_bit avc_cabac_first_bit((value_get))
+    if first_bit!=0
+        call avc_cabac_first_bit((value_set),0)
+    else
+        call avc_bs_write_bit(bit)
+    endelse
+    sd bits
+    setcall bits avc_cabac_bits_outstanding((value_get))
+    sd b
+    set b 1
+    sub b bit
+    while bits>0
+        call avc_bs_write_bit(b)
+        dec bits
+    endwhile
+    call avc_cabac_bits_outstanding((value_set),bits)
+endfunction
+function avc_cabac_bypass(sd b)
+    sd low
+    setcall low avc_cabac_low((value_get))
+    mult low 2
+    call avc_cabac_low((value_set),low)
+    if b!=0
+        sd range
+        setcall range avc_cabac_range((value_get))
+        add low range
+        call avc_cabac_low((value_set),low)
+    endif
+
+    if low>=0x400
+        call avc_cabac_putbit(1)
+        sub low 0x400
+        call avc_cabac_low((value_set),low)
+    else
+        if low<0x200
+            call avc_cabac_putbit(0)
+        else
+            sub low 0x200
+            call avc_cabac_low((value_set),low)
+            sd bits_outstanding
+            setcall bits_outstanding avc_cabac_bits_outstanding((value_get))
+            inc bits_outstanding
+            call avc_cabac_bits_outstanding((value_set),bits_outstanding)
+        endelse
+    endelse
+    sd sym
+    setcall sym avc_cabac_sym_cnt((value_get))
+    inc sym
+    call avc_cabac_sym_cnt((value_set),sym)
+endfunction
+function avc_cabac_terminal(sd b)
+    sd range
+    setcall range avc_cabac_range((value_get))
+    sub range 2
+    call avc_cabac_range((value_set),range)
+    if b!=0
+        sd low
+        setcall low avc_cabac_low((value_get))
+        add low range
+        call avc_cabac_low((value_set),low)
+        call avc_cabac_range((value_set),2)
+    endif
+    call avc_cabac_encode_renorm()
+    sd value
+    setcall value avc_cabac_sym_cnt((value_get))
+    inc value
+    call avc_cabac_sym_cnt((value_set),value)
+endfunction
+
+
+#write chroma pred mode
+function avc_mb_intra_chroma_pred_mode()
+    #sd pred_mode8x8c=I_PRED_CHROMA_DC
+    sd ctx=0
+    sd value
+    set value ctx
+    add value 64
+    call avc_cabac_decision(value,0)
+endfunction
+
+function avc_mb_qp_delta()
+    sd ctx=0
+    sd value
+    set value 60
+    add value ctx
+    call avc_cabac_decision(value,0)
+endfunction
--- ovideo-1.orig/src/media/mpeg-avc_mb.s
+++ /dev/null
@@ -1,699 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-const I_PRED_16x16_DC=2
-#const I_PRED_CHROMA_DC=0
-
-import "array_get_int" array_get_int
-import "sar32" sar
-import "shl" shl
-import "avc_cabac_ctxstate" avc_cabac_ctxstate
-
-function avc_cabac_context_init()
-    sd cabac
-    import "avc_slice_type" avc_slice_type
-    sd slice_type
-    setcall slice_type avc_slice_type((value_get))
-    if slice_type==(SLICE_TYPE_I)
-        setcall cabac avc_cabac_context_init_I()
-    else
-        setcall cabac avc_cabac_context_init_P()
-    endelse
-    sd i=0
-    import "avc_qp_I" avc_qp_I
-    sd qp
-    setcall qp avc_qp_I()
-    sd ctxstate
-    setcall ctxstate avc_cabac_ctxstate()
-    while i<(avc_ctxstate_total)
-        sd pre_state
-        sd a_value
-        sd b_value
-        sd pos=2
-        mult pos i
-        setcall a_value array_get_int(cabac,pos)
-        inc pos
-        setcall b_value array_get_int(cabac,pos)
-        mult a_value qp
-        setcall a_value sar(a_value,4)
-        add a_value b_value
-        setcall pre_state avc_clip3(a_value,1,126)
-        if pre_state<=63
-            set ctxstate# 63
-            sub ctxstate# pre_state
-            add ctxstate 4
-            set ctxstate# 0
-            add ctxstate 4
-        else
-            set ctxstate# pre_state
-            sub ctxstate# 64
-            add ctxstate 4
-            set ctxstate# 1
-            add ctxstate 4
-        endelse
-        set ctxstate# 0
-        add ctxstate 4
-        inc i
-    endwhile
-endfunction
-
-function avc_clip3(sd x,sd min,sd max)
-    if x<min
-        return min
-    else
-        if x>max
-            return max
-        else
-            return x
-        endelse
-    endelse
-endfunction
-
-function avc_cabac_context_init_I()
-    #[460][2]
-    data    context_0_10={20, -15,    2, 54,     3,  74,     20, -15}
-    data *              ={2,  54,     3, 74,     -28,127,    -23,104}
-    data *              ={-6, 53,     -1,54,     7,  51}
-    data *11-23 not at I={0,  0,      0, 0,      0,  0,      0,  0}
-    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
-    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
-    data *              ={0,  0}
-    data *24-39         ={0,  0,      0, 0,      0,  0,      0,  0}
-    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
-    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
-    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
-    data *40-53         ={0,  0,      0, 0,      0,  0,      0,  0}
-    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
-    data *              ={0,  0,      0, 0,      0,  0,      0,  0}
-    data *              ={0,  0,      0, 0}
-    data *54-59         ={0,  0,      0, 0,      0,  0,      0,  0}
-    data *              ={0,  0,      0, 0}
-    data *60-69         ={0,  41,     0, 63,     0,  63,     0,  63}
-    data *              ={-9, 83,     4, 86,     0,  97,     -7, 72}
-    data *              ={13, 41,     3, 62}
-    data *70-87         ={0,  11,     1, 55,     0,  69,     -17,127}
-    data *              ={-13,102,    0, 82,     -7, 74,     -21,107}
-    data *              ={-27,127,   -31,127,    -24,127,    -18,95}
-    data *              ={-27,127,   -21,114,    -30,127,    -17,123}
-    data *              ={-12,115,   -16,122}
-    data *88-104        ={-11,115,   -12,63,     -2, 68,     -15,84}
-    data *              ={-13,104,   -3, 70,     -8, 93,     -10,90}
-    data *              ={-30,127,   -1, 74,     -6, 97,     -7, 91}
-    data *              ={-20,127,   -4, 56,     -5, 82,     -7, 76}
-    data *              ={-22,125}
-    data *105-135       ={-7, 93,    -11,87,     -3, 77,     -5, 71}
-    data *              ={-4, 63,    -4, 68,     -12,84,     -7, 62}
-    data *              ={-7, 65,    8,  61,     5,  56,     -2, 66}
-    data *              ={1,  64,    0,  61,     -2, 78,     1,  50}
-    data *              ={7,  52,    10, 35,     0,  44,     11, 38}
-    data *              ={1,  45,    0,  46,     5,  44,     31, 17}
-    data *              ={1,  51,    7,  50,     28, 19,     16, 33}
-    data *              ={14, 62,    -13,108,    -15,100}
-    data *136-165       ={-13, 101, -13, 91,  -12, 94,    -10, 88}
-    data *              ={-16, 84,  -10, 86,  -7, 83,     -13, 87}
-    data *              ={-19, 94,  1, 70,    0, 72,      -5, 74}
-    data *              ={18, 59,   -8, 102,  -15, 100,   0, 95}
-    data *              ={-4, 75,   2, 72,    -11, 75,    -3, 71}
-    data *              ={15, 46,   -13, 69,  0, 62,      0, 65}
-    data *              ={21, 37,   -15, 72,  9, 57,      16, 54}
-    data *              ={0, 62,    12, 72}
-    data *166-196       ={24, 0,   15, 9,   8, 25,     13, 18}
-    data *              ={15, 9,   13, 19,  10, 37,    12, 18}
-    data *              ={6, 29,   20, 33,  15, 30,    4, 45}
-    data *              ={1, 58,   0, 62,   7, 61,     12, 38}
-    data *              ={11, 45,  15, 39,  11, 42,    13, 44}
-    data *              ={16, 45,  12, 41,  10, 49,    30, 34}
-    data *              ={18, 42,  10, 55,  17, 51,    17, 46}
-    data *              ={0, 89,   26, -19, 22, -17}
-    data *197-226       ={26, -17, 30, -25, 28, -20,   33, -23}
-    data *              ={37, -27, 33, -23, 40, -28,   38, -17}
-    data *              ={33, -11, 40, -15, 41, -6,    38, 1}
-    data *              ={41, 17,  30, -6,  27, 3,     26, 22}
-    data *              ={37, -16, 35, -4,  38, -8,    38, -3}
-    data *              ={37, 3,   38, 5,   42, 0,     35, 16}
-    data *              ={39, 22,  14, 48,  27, 37,    21, 60}
-    data *              ={12, 68,  2, 97}
-    data *227-251       ={-3, 71,  -6, 42,  -5, 50,    -3, 54}
-    data *              ={-2, 62,  0, 58,   1, 63,     -2, 72}
-    data *              ={-1, 74,  -9, 91,  -5, 67,    -5, 27}
-    data *              ={-3, 39,  -2, 44,  0, 46,     -16, 64}
-    data *              ={-8, 68,  -10, 78, -6, 77,    -10, 86}
-    data *              ={-12, 92, -15, 55, -10, 60,   -6, 62}
-    data *              ={-4, 65}
-    data *252-275       ={-12, 73, -8, 76,  -7, 80,    -9, 88}
-    data *              ={-17, 110,-11, 97, -20, 84,   -11, 79}
-    data *              ={-6, 73,  -4, 74,  -13, 86,   -13, 96}
-    data *              ={-11, 97, -19, 117,-8, 78,    -5, 33}
-    data *              ={-4, 48,  -2, 53,  -3, 62,    -13, 71}
-    data *              ={-10, 79, -12, 86, -13, 90,   -14, 97}
-    #276 is special (not used, x264_cabac_encode_bypass is used instead)
-    data *              ={0, 0}
-    data *277-307       ={-6, 93,  -6, 84,  -8, 79,    0, 66}
-    data *              ={-1, 71,  0, 62,   -2, 60,    -2, 59}
-    data *              ={-5, 75,  -3, 62,  -4, 58,    -9, 66}
-    data *              ={-1, 79,  0, 71,   3, 68,     10, 44}
-    data *              ={-7, 62,  15, 36,  14, 40,    16, 27}
-    data *              ={12, 29,  1, 44,   20, 36,    18, 32}
-    data *              ={5, 42,   1, 48,   10, 62,    17, 46}
-    data *              ={9, 64,   -12, 104,-11, 97}
-    data *308-337       ={-16, 96, -7, 88,  -8, 85,    -7, 85}
-    data *              ={-9, 85,  -13, 88, 4, 66,     -3, 77}
-    data *              ={-3, 76,  -6, 76,  10, 58,    -1, 76}
-    data *              ={-1, 83,  -7, 99,  -14, 95,   2, 95}
-    data *              ={0, 76,   -5, 74,  0, 70,     -11, 75}
-    data *              ={1, 68,   0, 65,   -14, 73,   3, 62}
-    data *              ={4, 62,   -1, 68,  -13, 75,   11, 55}
-    data *              ={5, 64,   12, 70}
-    data *338-368       ={15, 6,   6, 19,   7, 16,     12, 14}
-    data *              ={18, 13,  13, 11,  13, 15,    15, 16}
-    data *              ={12, 23,  13, 23,  15, 20,    14, 26}
-    data *              ={14, 44,  17, 40,  17, 47,    24, 17}
-    data *              ={21, 21,  25, 22,  31, 27,    22, 29}
-    data *              ={19, 35,  14, 50,  10, 57,    7, 63}
-    data *              ={-2, 77,  -4, 82,  -3, 94,    9, 69}
-    data *              ={-12, 109,36, -35, 36, -34}
-    data *369-398       ={32, -26, 37, -30, 44, -32,   34, -18}
-    data *              ={34, -15, 40, -15, 33, -7,    35, -5}
-    data *              ={33, 0,   38, 2,   33, 13,    23, 35}
-    data *              ={13, 58,  29, -3,  26, 0,     22, 30}
-    data *              ={31, -7,  35, -15, 34, -3,    34, 3}
-    data *              ={36, -1,  34, 5,   32, 11,    35, 5}
-    data *              ={34, 12,  39, 11,  30, 29,    34, 26}
-    data *              ={29, 39,  19, 66}
-    data *399-435       ={31,  21,  31,  31,  25,  50}
-    data *              ={-17, 120, -20, 112, -18, 114, -11,  85}
-    data *              ={-15,  92, -14,  89, -26,  71, -15,  81}
-    data *              ={-14,  80,   0,  68, -14,  70, -24,  56}
-    data *              ={-23,  68, -24,  50, -11,  74,  23, -13}
-    data *              ={26, -13,  40, -15,  49, -14,  44,   3}
-    data *              ={45,   6,  44,  34,  33,  54,  19,  82}
-    data *              ={-3,  75,  -1,  23,   1,  34,   1,  43}
-    data *              ={0,  54,  -2,  55,   0,  61,   1,  64}
-    data *              ={0,  68,  -9,  92}
-    data *436-459       ={-14, 106, -13,  97, -15,  90, -12,  90}
-    data *              ={-18,  88, -10,  73, -9,  79, -14,  86}
-    data *              ={-10,  73, -10,  70, -10,  69, -5,  66}
-    data *              ={-9,  64, -5,  58,  2,  59, 21, -10}
-    data *              ={24, -11, 28,  -8, 28,  -1, 29,   3}
-    data *              ={29,   9, 35,  20, 29,  36, 14,  67}
-    data cabac_I^context_0_10
-    return cabac_I
-endfunction
-
-function avc_cabac_context_init_P()
-    #[460][2]
-    data context_0_10={20, -15,    2,  54,    3,  74,   20, -15}
-    data *           ={2,  54,    3,  74,  -28, 127,  -23, 104}
-    data *           ={-6,  53,   -1,  54,    7,  51}
-    data *11-23      ={23,  33,   23,   2,   21,   0,    1,   9}
-    data *           ={0,  49,  -37, 118,    5,  57,  -13,  78}
-    data *           ={-11,  65,    1,  62,   12,  49,   -4,  73}
-    data *           ={17,  50}
-    data *24-39      ={18,  64,    9,  43,   29,   0,   26,  67}
-    data *           ={16,  90,    9, 104,  -46, 127,  -20, 104}
-    data *           ={1,  67,  -13,  78,  -11,  65,    1,  62}
-    data *           ={-6,  86,  -17,  95,   -6,  61,    9,  45}
-    data *40-53      ={-3,  69,   -6,  81,  -11,  96,    6,  55}
-    data *           ={7,  67,   -5,  86,    2,  88,    0,  58}
-    data *           ={-3,  76,  -10,  94,    5,  54,    4,  69}
-    data *           ={-3,  81,    0,  88}
-    data *54-59      ={-7,  67,   -5,  74,   -4,  74,   -5,  80}
-    data *           ={-7,  72,    1,  58}
-    data *60-69      ={0,  41,    0,  63,    0,  63,  0, 63}
-    data *           ={-9,  83,    4,  86,    0,  97,  -7, 72}
-    data *           ={13,  41,    3,  62}
-    data *70-87      ={0,  45,   -4,  78,   -3,  96,  -27,  126}
-    data *           ={-28,  98,  -25, 101,  -23,  67,  -28,  82}
-    data *           ={-20,  94,  -16,  83,  -22, 110,  -21,  91}
-    data *           ={-18, 102,  -13,  93,  -29, 127,   -7,  92}
-    data *           ={-5,  89,   -7,  96,  -13, 108,   -3,  46}
-    data *           ={-1,  65,   -1,  57,   -9,  93,   -3,  74}
-    data *           ={-9,  92,   -8,  87,  -23, 126,    5,  54}
-    data *           ={6,  60,    6,  59,    6,  69,   -1,  48}
-    data *           ={0,  68,   -4,  69,   -8,  88}
-    data *105-165    ={-2,  85,   -6,  78,   -1,  75,   -7,  77}
-    data *           ={2,  54,    5,  50,   -3,  68,    1,  50}
-    data *           ={6,  42,   -4,  81,    1,  63,   -4,  70}
-    data *           ={0,  67,    2,  57,   -2,  76,   11,  35}
-    data *           ={4,  64,    1,  61,   11,  35,   18,  25}
-    data *           ={12,  24,   13,  29,   13,  36,  -10,  93}
-    data *           ={-7,  73,   -2,  73,   13,  46,    9,  49}
-    data *           ={-7, 100,    9,  53,    2,  53,    5,  53}
-    data *           ={-2,  61,    0,  56,    0,  56,  -13,  63}
-    data *           ={-5,  60,   -1,  62,    4,  57,   -6,  69}
-    data *           ={4,  57,   14,  39,    4,  51,   13,  68}
-    data *           ={3,  64,    1,  61,    9,  63,   7,  50}
-    data *           ={16,  39,    5,  44,    4,  52,   11,  48}
-    data *           ={-5,  60,   -1,  59,   0,  59,   22,  33}
-    data *           ={5,  44,   14,  43,   -1,  78,    0,  60}
-    data *           ={9,  69}
-    data *166 - 226  ={11,  28,    2,  40,    3,  44,    0,  49}
-    data *           ={0,  46,    2,  44,    2,  51,    0,  47}
-    data *           ={4,  39,    2,  62,    6,  46,    0,  54}
-    data *           ={3,  54,    2,  58,    4,  63,    6,  51}
-    data *           ={6,  57,    7,  53,    6,  52,    6,  55}
-    data *           ={11,  45,  14,  36,    8,  53,   -1,  82}
-    data *           ={7,  55,   -3,  78,   15,  46,   22,  31}
-    data *           ={-1,  84,   25,   7,   30,  -7,   28,   3}
-    data *           ={28,   4,   32,   0,   34,  -1,   30,   6}
-    data *           ={30,   6,   32,   9,   31,  19,   26,  27}
-    data *           ={26,  30,   37,  20,   28,  34,   17,  70}
-    data *           ={1,  67,    5,  59,    9,  67,   16,  30}
-    data *           ={18,  32,   18,  35,   22,  29,   24,  31}
-    data *           ={23,  38,   18,  43,   20,  41,   11,  63}
-    data *           ={9,  59,    9,  64,   -1,  94,   -2,  89}
-    data *           ={-9, 108}
-    data *227 - 275  ={-6,  76,   -2,  44,    0,  45,    0,  52}
-    data *           ={-3,  64,   -2,  59,   -4,  70,   -4,  75}
-    data *           ={-8,  82,  -17, 102,   -9,  77,    3,  24}
-    data *           ={0,  42,    0,  48,    0,  55,   -6,  59}
-    data *           ={-7,  71,  -12,  83,  -11,  87,  -30, 119}
-    data *           ={1,  58,   -3,  29,   -1,  36,    1,  38}
-    data *           ={2,  43,   -6,  55,    0,  58,    0,  64}
-    data *           ={-3,  74,  -10,  90,    0,  70,   -4,  29}
-    data *           ={5,  31,    7,  42,    1,  59,   -2,  58}
-    data *           ={-3,  72,   -3,  81,  -11,  97,    0,  58}
-    data *           ={8,   5,  10,  14,   14,  18,   13,  27}
-    data *           ={2,  40,    0,  58,   -3,  70,   -6,  79}
-    data *           ={-8,  85}
-    #276 (not used, x264_cabac_encode_bypass is used instead)
-    data *           ={0, 0}
-    data *277 - 337  ={-13, 106,  -16, 106,  -10,  87,  -21, 114}
-    data *           ={-18, 110,  -14,  98,  -22, 110,  -21, 106}
-    data *           ={-18, 103,  -21, 107,  -23, 108,  -26, 112}
-    data *           ={-10,  96,  -12,  95,   -5,  91,   -9,  93}
-    data *           ={-22,  94,   -5,  86,    9,  67,   -4,  80}
-    data *           ={-10,  85,   -1,  70,    7,  60,    9,  58}
-    data *           ={5,  61,   12,  50,   15,  50,   18,  49}
-    data *           ={17,  54,   10,  41,    7,  46,   -1,  51}
-    data *           ={7,  49,    8,  52,    9,  41,    6,  47}
-    data *           ={2,  55,   13,  41,   10,  44,    6,  50}
-    data *           ={5,  53,   13,  49,    4,  63,    6,  64}
-    data *           ={-2,  69,   -2,  59,    6,  70,   10,  44}
-    data *           ={9,  31,   12,  43,    3,  53,   14,  34}
-    data *           ={10,  38,   -3,  52,   13,  40,   17,  32}
-    data *           ={7,  44,    7,  38,   13,  50,   10,  57}
-    data *           ={26,  43}
-    data *338 - 398  ={14,  11,   11,  14,    9,  11,   18,  11}
-    data *           ={21,   9,   23,  -2,   32, -15,   32, -15}
-    data *           ={34, -21,   39, -23,   42, -33,   41, -31}
-    data *           ={46, -28,   38, -12,   21,  29,   45, -24}
-    data *           ={53, -45,   48, -26,   65, -43,   43, -19}
-    data *           ={39, -10,   30,   9,   18,  26,   20,  27}
-    data *           ={0,  57,  -14,  82,   -5,  75,  -19,  97}
-    data *           ={-35, 125,   27,   0,   28,   0,   31,  -4}
-    data *           ={27,   6,   34,   8,   30,  10,   24,  22}
-    data *           ={33,  19,   22,  32,   26,  31,   21,  41}
-    data *           ={26,  44,   23,  47,   16,  65,   14,  71}
-    data *           ={8,  60,    6,  63,   17,  65,   21,  24}
-    data *           ={23,  20,   26,  23,   27,  32,   28,  23}
-    data *           ={28,  24,   23,  40,   24,  32,   28,  29}
-    data *           ={23,  42,   19,  57,   22,  53,   22,  61}
-    data *           ={11,  86}
-    data *399 - 435  ={12,  40,   11,  51,   14,  59}
-    data *           ={-4,  79,   -7,  71,   -5,  69,   -9,  70}
-    data *           ={-8,  66,  -10,  68,  -19,  73,  -12,  69}
-    data *           ={-16,  70,  -15,  67,  -20,  62,  -19,  70}
-    data *           ={-16,  66,  -22,  65,  -20,  63,    9,  -2}
-    data *           ={26,  -9,   33,  -9,   39,  -7,   41,  -2}
-    data *           ={45,   3,   49,   9,   45,  27,   36,  59}
-    data *           ={-6,  66,   -7,  35,   -7,  42,   -8,  45}
-    data *           ={-5,  48,  -12,  56,   -6,  60,   -5,  62}
-    data *           ={-8,  66,   -8,  76}
-    data *436 - 459  ={-5,  85,   -6,  81,  -10,  77,   -7,  81}
-    data *           ={-17,  80,  -18,  73,   -4,  74,  -10,  83}
-    data *           ={-9,  71,   -9,  67,   -1,  61,   -8,  66}
-    data *           ={-14,  66,    0,  59,    2,  59,   21, -13}
-    data *           ={33, -14,   39,  -7,   46,  -2,   51,   2}
-    data *           ={60,   6,   61,  17,   55,  34,   42,  62}
-    data cabac_P^context_0_10
-    return cabac_P
-endfunction
-
-
-function avc_cabac_range_lps(sd a,sd b)
-    #[64][4]
-    data cabac_range={128, 176, 208, 240, 128, 167, 197, 227, 128, 158, 187, 216}
-    data *          ={123, 150, 178, 205, 116, 142, 169, 195, 111, 135, 160, 185}
-    data *          ={105, 128, 152, 175, 100, 122, 144, 166,  95, 116, 137, 158}
-    data *          ={90, 110, 130, 150,  85, 104, 123, 142,  81,  99, 117, 135}
-    data *          ={77,  94, 111, 128,  73,  89, 105, 122,  69,  85, 100, 116}
-    data *          ={66,  80,  95, 110,  62,  76,  90, 104,  59,  72,  86,  99}
-    data *          ={56,  69,  81,  94,  53,  65,  77,  89,  51,  62,  73,  85}
-    data *          ={48,  59,  69,  80,  46,  56,  66,  76,  43,  53,  63,  72}
-    data *          ={41,  50,  59,  69,  39,  48,  56,  65,  37,  45,  54,  62}
-    data *          ={35,  43,  51,  59,  33,  41,  48,  56,  32,  39,  46,  53}
-    data *          ={30,  37,  43,  50,  29,  35,  41,  48,  27,  33,  39,  45}
-    data *          ={26,  31,  37,  43,  24,  30,  35,  41,  23,  28,  33,  39}
-    data *          ={22,  27,  32,  37,  21,  26,  30,  35,  20,  24,  29,  33}
-    data *          ={19,  23,  27,  31,  18,  22,  26,  30,  17,  21,  25,  28}
-    data *          ={16,  20,  23,  27,  15,  19,  22,  25,  14,  18,  21,  24}
-    data *          ={14,  17,  20,  23,  13,  16,  19,  22,  12,  15,  18,  21}
-    data *          ={12,  14,  17,  20,  11,  14,  16,  19,  11,  13,  15,  18}
-    data *          ={10,  12,  15,  17,  10,  12,  14,  16,   9,  11,  13,  15}
-    data *          ={9,  11,  12,  14,   8,  10,  12,  14,   8,   9,  11,  13}
-    data *          ={7,   9,  11,  12,   7,   9,  10,  12,   7,   8,  10,  11}
-    data *          ={6,   8,   9,  11,   6,   7,   9,  10,   6,   7,   8,   9}
-    data *          ={2,   2,   2,   2}
-    sd cabac^cabac_range
-    mult a (4*4)
-    mult b 4
-    add cabac a
-    add cabac b
-    return cabac#
-endfunction
-
-function avc_transition_lps(sd a)
-    #[64]
-    data transition={0, 0, 1, 2, 2, 4, 4, 5, 6, 7, 8, 9, 9,11,11,12}
-    data *         ={13,13,15,15,16,16,18,18,19,19,21,21,22,22,23,24}
-    data *         ={24,25,26,26,27,27,28,29,29,30,30,30,31,32,32,33}
-    data *         ={33,33,34,34,35,35,35,36,36,36,37,37,37,38,38,63}
-    sd trans^transition
-    mult a 4
-    add trans a
-    return trans#
-endfunction
-
-function avc_transition_mps(sd a)
-    #[64]
-    data transition={1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16}
-    data *         ={17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32}
-    data *         ={33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48}
-    data *         ={49,50,51,52,53,54,55,56,57,58,59,60,61,62,62,63}
-    sd trans^transition
-    mult a 4
-    add trans a
-    return trans#
-endfunction
-
-import "avc_mb_nr_left" avc_mb_nr_left
-import "avc_mb_nr_top" avc_mb_nr_top
-
-function avc_mb_write_cabac(sd slice_type)
-    #Write the MB type
-    call avc_mb_type(slice_type)
-
-    #write chroma pred mode
-    call avc_mb_intra_chroma_pred_mode()
-
-    #i_cbp_luma > 0 || i_cbp_chroma > 0 || i_mb_type == I_16x16
-    import "avc_residual_luma" avc_residual_luma
-    import "avc_residual_write" avc_residual_write
-    import "avc_cbp_luma" avc_cbp_luma
-    call avc_mb_qp_delta()
-    #dc luma
-    sd residual_luma
-    setcall residual_luma avc_residual_luma()
-                                             #,idx=0
-    call avc_residual_write(residual_luma,0,16)
-    #ac luma
-    sd i
-    sd cbp_luma
-    setcall cbp_luma avc_cbp_luma((value_get))
-    if cbp_luma!=0
-        import "avc_residual_ac" avc_residual_ac
-        sd residual_ac
-        setcall residual_ac avc_residual_ac((value_get))
-        set i 0
-        while i!=16
-            call avc_residual_write(residual_ac,1,15,i)
-            add residual_ac (15*DWORD)
-            inc i
-        endwhile
-    endif
-
-    #Chroma DC residual present
-    import "avc_cbp_chroma" avc_cbp_chroma
-    sd cbp_chroma
-    setcall cbp_chroma avc_cbp_chroma((value_get))
-    sd value
-    set value cbp_chroma
-    and value 3
-    if value!=0
-        import "avc_chroma_dc_u" avc_chroma_dc_u
-        import "avc_chroma_dc_v" avc_chroma_dc_v
-        sd chroma_dc_u
-        sd chroma_dc_v
-        setcall chroma_dc_u avc_chroma_dc_u()
-        setcall chroma_dc_v avc_chroma_dc_v()
-        call avc_residual_write(chroma_dc_u,3,4,0)
-        call avc_residual_write(chroma_dc_v,3,4,1)
-    endif
-
-    #Chroma AC residual present
-    set value cbp_chroma
-    and value 2
-    if value!=0
-        import "avc_residual_ac_ch" avc_residual_ac_ch
-        sd residual_ac_ch
-        setcall residual_ac_ch avc_residual_ac_ch()
-        set i 0
-        while i<8
-            call avc_residual_write(residual_ac_ch,4,15,i)
-            add residual_ac_ch (15*DWORD)
-            inc i
-        endwhile
-    endif
-endfunction
-
-function avc_mb_type(sd slice_type)
-    sd mb_nr_left
-    sd mb_nr_top
-    if slice_type==(SLICE_TYPE_I)
-        setcall mb_nr_left avc_mb_nr_left((value_get))
-        setcall mb_nr_top avc_mb_nr_top((value_get))
-        sd ctx=0
-        if mb_nr_left>0
-            inc ctx
-        endif
-        if mb_nr_top>0
-            inc ctx
-        endif
-        sd value
-        set value ctx
-        add value 3
-        call avc_mb_type_intra(value,(3+3),(3+4),(3+5),(3+6),(3+7))
-    else
-        #prefix
-        call avc_cabac_decision(14,1)
-        #suffix
-        call avc_mb_type_intra((17+0),(17+1),(17+2),(17+2),(17+3),(17+3))
-    endelse
-endfunction
-
-function avc_mb_type_intra(sd ctx0,sd ctx1,sd ctx2,sd ctx3,sd ctx4,sd ctx5)
-    call avc_cabac_decision(ctx0,1)
-    call avc_cabac_terminal(0)
-    sd cbp_luma
-    setcall cbp_luma avc_cbp_luma((value_get))
-    if cbp_luma==0
-        call avc_cabac_decision(ctx1,0)
-    else
-        call avc_cabac_decision(ctx1,1)
-    endelse
-
-    sd cbp_chroma
-    setcall cbp_chroma avc_cbp_chroma((value_get))
-    if cbp_chroma==0
-        call avc_cabac_decision(ctx2,0)
-    else
-        call avc_cabac_decision(ctx2,1)
-        if cbp_chroma==1
-            call avc_cabac_decision(ctx3,0)
-        else
-            call avc_cabac_decision(ctx3,1)
-        endelse
-    endelse
-
-    sd i_intra16x16_pred_mode=I_PRED_16x16_DC
-    import "rest" rest
-    sd pred_mode_rest
-    setcall pred_mode_rest rest(i_intra16x16_pred_mode,2)
-    div i_intra16x16_pred_mode 2
-    if i_intra16x16_pred_mode!=0
-        call avc_cabac_decision(ctx4,1)
-    else
-        call avc_cabac_decision(ctx4,0)
-    endelse
-    call avc_cabac_decision(ctx5,pred_mode_rest)
-endfunction
-
-import "avc_cabac_ctxstate_value" avc_cabac_ctxstate_value
-import "avc_cabac_ctxstate_value_set" avc_cabac_ctxstate_value_set
-import "avc_cabac_range" avc_cabac_range
-import "avc_cabac_low" avc_cabac_low
-import "avc_cabac_sym_cnt" avc_cabac_sym_cnt
-
-function avc_cabac_decision(sd ctx,sd b)
-    sd state
-    setcall state avc_cabac_ctxstate_value(ctx,(avc_ctxstate_state))
-    sd mps
-    setcall mps avc_cabac_ctxstate_value(ctx,(avc_ctxstate_mps))
-    sd range
-    setcall range avc_cabac_range((value_get))
-    sd i_range
-    set i_range range
-    setcall i_range sar(range,6)
-    and i_range 0x03
-    sd range_lps
-    setcall range_lps avc_cabac_range_lps(state,i_range)
-
-    sub range range_lps
-    call avc_cabac_range((value_set),range)
-    sd value
-    if b!=mps
-        sd low
-        setcall low avc_cabac_low((value_get))
-        add low range
-        call avc_cabac_low((value_set),low)
-        call avc_cabac_range((value_set),range_lps)
-        if state==0
-            set value 1
-            sub value mps
-            call avc_cabac_ctxstate_value_set(ctx,(avc_ctxstate_mps),value)
-        endif
-        setcall value avc_transition_lps(state)
-        call avc_cabac_ctxstate_value_set(ctx,(avc_ctxstate_state),value)
-    else
-        setcall value avc_transition_mps(state)
-        call avc_cabac_ctxstate_value_set(ctx,(avc_ctxstate_state),value)
-    endelse
-    setcall value avc_cabac_ctxstate_value(ctx,(avc_ctxstate_count))
-    inc value
-    call avc_cabac_ctxstate_value_set(ctx,(avc_ctxstate_count),value)
-
-    call avc_cabac_encode_renorm()
-
-    setcall value avc_cabac_sym_cnt((value_get))
-    inc value
-    call avc_cabac_sym_cnt((value_set),value)
-endfunction
-
-import "avc_cabac_bits_outstanding" avc_cabac_bits_outstanding
-
-function avc_cabac_encode_renorm()
-    sd range
-    setcall range avc_cabac_range((value_get))
-    sd low
-    setcall low avc_cabac_low((value_get))
-    while range<0x0100
-        if low<0x100
-            call avc_cabac_putbit(0)
-        else
-            if low>=0x200
-                sub low 0x200
-                call avc_cabac_low((value_set),low)
-                call avc_cabac_putbit(1)
-            else
-                sub low 0x100
-                call avc_cabac_low((value_set),low)
-                sd bits
-                setcall bits avc_cabac_bits_outstanding((value_get))
-                inc bits
-                call avc_cabac_bits_outstanding((value_set),bits)
-            endelse
-        endelse
-        setcall range shl(range,1)
-        call avc_cabac_range((value_set),range)
-        setcall low shl(low,1)
-        call avc_cabac_low((value_set),low)
-    endwhile
-endfunction
-
-import "avc_bs_write_bit" avc_bs_write_bit
-
-import "avc_cabac_first_bit" avc_cabac_first_bit
-
-function avc_cabac_putbit(sd bit)
-    sd first_bit
-    setcall first_bit avc_cabac_first_bit((value_get))
-    if first_bit!=0
-        call avc_cabac_first_bit((value_set),0)
-    else
-        call avc_bs_write_bit(bit)
-    endelse
-    sd bits
-    setcall bits avc_cabac_bits_outstanding((value_get))
-    sd b
-    set b 1
-    sub b bit
-    while bits>0
-        call avc_bs_write_bit(b)
-        dec bits
-    endwhile
-    call avc_cabac_bits_outstanding((value_set),bits)
-endfunction
-function avc_cabac_bypass(sd b)
-    sd low
-    setcall low avc_cabac_low((value_get))
-    mult low 2
-    call avc_cabac_low((value_set),low)
-    if b!=0
-        sd range
-        setcall range avc_cabac_range((value_get))
-        add low range
-        call avc_cabac_low((value_set),low)
-    endif
-
-    if low>=0x400
-        call avc_cabac_putbit(1)
-        sub low 0x400
-        call avc_cabac_low((value_set),low)
-    else
-        if low<0x200
-            call avc_cabac_putbit(0)
-        else
-            sub low 0x200
-            call avc_cabac_low((value_set),low)
-            sd bits_outstanding
-            setcall bits_outstanding avc_cabac_bits_outstanding((value_get))
-            inc bits_outstanding
-            call avc_cabac_bits_outstanding((value_set),bits_outstanding)
-        endelse
-    endelse
-    sd sym
-    setcall sym avc_cabac_sym_cnt((value_get))
-    inc sym
-    call avc_cabac_sym_cnt((value_set),sym)
-endfunction
-function avc_cabac_terminal(sd b)
-    sd range
-    setcall range avc_cabac_range((value_get))
-    sub range 2
-    call avc_cabac_range((value_set),range)
-    if b!=0
-        sd low
-        setcall low avc_cabac_low((value_get))
-        add low range
-        call avc_cabac_low((value_set),low)
-        call avc_cabac_range((value_set),2)
-    endif
-    call avc_cabac_encode_renorm()
-    sd value
-    setcall value avc_cabac_sym_cnt((value_get))
-    inc value
-    call avc_cabac_sym_cnt((value_set),value)
-endfunction
-
-
-#write chroma pred mode
-function avc_mb_intra_chroma_pred_mode()
-    #sd pred_mode8x8c=I_PRED_CHROMA_DC
-    sd ctx=0
-    sd value
-    set value ctx
-    add value 64
-    call avc_cabac_decision(value,0)
-endfunction
-
-function avc_mb_qp_delta()
-    sd ctx=0
-    sd value
-    set value 60
-    add value ctx
-    call avc_cabac_decision(value,0)
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-avc_wrap.oc
@@ -0,0 +1,161 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+const PROFILE_MAIN=77
+
+import "avc_pre_input" avc_pre_input
+import "avc_input" avc_input
+import "avc_output" avc_output
+import "avc_allsize" avc_allsize
+import "avc_nal_output" avc_nal_output
+import "avc_mb_data" avc_mb_data
+import "avc_input_dequant" avc_input_dequant
+
+import "memalloc" memalloc
+importx "_free" free
+
+#bool
+function avc_init(sd pixbuf)
+    import "pixbuf_get_wh" pixbuf_get_wh
+    import "rgb_get_size" rgb_get_size
+    sd w
+    sd h
+    sd wh^w
+    call pixbuf_get_wh(pixbuf,wh)
+    sd boolSum
+    setcall boolSum avc_rounding(w)
+    addcall boolSum avc_rounding(h)
+    if boolSum!=2
+        return 0
+    endif
+
+    import "avc_mb_width" avc_mb_width
+    import "avc_mb_height" avc_mb_height
+    import "avc_width" avc_width
+    import "avc_height" avc_height
+    sd mb_w
+    sd mb_h
+    set mb_w w
+    set mb_h h
+    div mb_w 16
+    div mb_h 16
+    call avc_mb_width((value_set),mb_w)
+    call avc_mb_height((value_set),mb_h)
+    call avc_width((value_set),w)
+    call avc_height((value_set),h)
+    sd alloc_size=1000
+    addcall alloc_size rgb_get_size(w,h)
+    #call avc_pre_input((value_set),0)
+    call avc_input((value_set),0)
+    call avc_output((value_set),0)
+    call avc_nal_output((value_set),0)
+    call avc_mb_data((value_set),0)
+    call avc_input_dequant((value_set),0)
+
+    sd mem_pre_in
+    setcall mem_pre_in memalloc(alloc_size)
+    if mem_pre_in=0
+        return 0
+    endif
+    call avc_pre_input((value_set),mem_pre_in)
+    sd mem_in
+    setcall mem_in memalloc(alloc_size)
+    if mem_in=0
+        call avc_free()
+        return 0
+    endif
+    call avc_input((value_set),mem_in)
+    sd mem_out
+    setcall mem_out memalloc(alloc_size)
+    if mem_out=0
+        call avc_free()
+        return 0
+    endif
+    call avc_output((value_set),mem_out)
+    sd mem_nal_out
+    setcall mem_nal_out memalloc(alloc_size)
+    if mem_nal_out=0
+        call avc_free()
+        return 0
+    endif
+    call avc_nal_output((value_set),mem_nal_out)
+    sd mem_mb
+    set mem_mb mb_w
+    mult mem_mb mb_h
+    mult mem_mb (avc_mb_size)
+    setcall mem_mb memalloc(mem_mb)
+    if mem_mb=0
+        call avc_free()
+        return 0
+    endif
+    call avc_mb_data((value_set),mem_mb)
+    sd mem_input_deq
+    setcall mem_input_deq memalloc(alloc_size)
+    if mem_input_deq=0
+        call avc_free()
+        return 0
+    endif
+    call avc_input_dequant((value_set),mem_input_deq)
+    call avc_allsize((value_set),alloc_size)
+
+    import "avc_ProfileIndication" avc_ProfileIndication
+    import "avc_profile_compatibility" avc_profile_compatibility
+    import "avc_LevelIndication" avc_LevelIndication
+    call avc_ProfileIndication((value_set),(PROFILE_MAIN))
+    #b_constraint_set0=0;b_constraint_set1=0;b_constraint_set2=0;5 bits reserved
+    call avc_profile_compatibility((value_set),0)
+    #level 4.0
+    call avc_LevelIndication((value_set),40)
+
+    import "avc_frame_num" avc_frame_num
+    import "avc_idr_pic_id" avc_idr_pic_id
+    call avc_frame_num((value_set),(avc_keyint_max))
+    call avc_idr_pic_id((value_set),-1)
+
+    import "avc_quant_mf_set" avc_quant_mf_set
+    call avc_quant_mf_set()
+
+    return 1
+endfunction
+
+#bool
+function avc_rounding(sd value)
+    import "rest" rest
+    setcall value rest(value,16)
+    if value!=0
+        import "texter" texter
+        str er="Width or height isn't a multiple of 16."
+        call texter(er)
+        return 0
+    endif
+    return 1
+endfunction
+
+function avc_free()
+    sd mem
+    setcall mem avc_pre_input((value_get))
+    call free(mem)
+    setcall mem avc_input((value_get))
+    if mem!=0
+        call free(mem)
+    endif
+    setcall mem avc_output((value_get))
+    if mem!=0
+        call free(mem)
+    endif
+    setcall mem avc_nal_output((value_get))
+    if mem!=0
+        call free(mem)
+    endif
+    setcall mem avc_mb_data((value_get))
+    if mem!=0
+        call free(mem)
+    endif
+    setcall mem avc_input_dequant((value_get))
+    if mem!=0
+        call free(mem)
+    endif
+endfunction
--- ovideo-1.orig/src/media/mpeg-avc_wrap.s
+++ /dev/null
@@ -1,161 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-const PROFILE_MAIN=77
-
-import "avc_pre_input" avc_pre_input
-import "avc_input" avc_input
-import "avc_output" avc_output
-import "avc_allsize" avc_allsize
-import "avc_nal_output" avc_nal_output
-import "avc_mb_data" avc_mb_data
-import "avc_input_dequant" avc_input_dequant
-
-import "memalloc" memalloc
-importx "_free" free
-
-#bool
-function avc_init(sd pixbuf)
-    import "pixbuf_get_wh" pixbuf_get_wh
-    import "rgb_get_size" rgb_get_size
-    sd w
-    sd h
-    sd wh^w
-    call pixbuf_get_wh(pixbuf,wh)
-    sd boolSum
-    setcall boolSum avc_rounding(w)
-    addcall boolSum avc_rounding(h)
-    if boolSum!=2
-        return 0
-    endif
-
-    import "avc_mb_width" avc_mb_width
-    import "avc_mb_height" avc_mb_height
-    import "avc_width" avc_width
-    import "avc_height" avc_height
-    sd mb_w
-    sd mb_h
-    set mb_w w
-    set mb_h h
-    div mb_w 16
-    div mb_h 16
-    call avc_mb_width((value_set),mb_w)
-    call avc_mb_height((value_set),mb_h)
-    call avc_width((value_set),w)
-    call avc_height((value_set),h)
-    sd alloc_size=1000
-    addcall alloc_size rgb_get_size(w,h)
-    #call avc_pre_input((value_set),0)
-    call avc_input((value_set),0)
-    call avc_output((value_set),0)
-    call avc_nal_output((value_set),0)
-    call avc_mb_data((value_set),0)
-    call avc_input_dequant((value_set),0)
-
-    sd mem_pre_in
-    setcall mem_pre_in memalloc(alloc_size)
-    if mem_pre_in==0
-        return 0
-    endif
-    call avc_pre_input((value_set),mem_pre_in)
-    sd mem_in
-    setcall mem_in memalloc(alloc_size)
-    if mem_in==0
-        call avc_free()
-        return 0
-    endif
-    call avc_input((value_set),mem_in)
-    sd mem_out
-    setcall mem_out memalloc(alloc_size)
-    if mem_out==0
-        call avc_free()
-        return 0
-    endif
-    call avc_output((value_set),mem_out)
-    sd mem_nal_out
-    setcall mem_nal_out memalloc(alloc_size)
-    if mem_nal_out==0
-        call avc_free()
-        return 0
-    endif
-    call avc_nal_output((value_set),mem_nal_out)
-    sd mem_mb
-    set mem_mb mb_w
-    mult mem_mb mb_h
-    mult mem_mb (avc_mb_size)
-    setcall mem_mb memalloc(mem_mb)
-    if mem_mb==0
-        call avc_free()
-        return 0
-    endif
-    call avc_mb_data((value_set),mem_mb)
-    sd mem_input_deq
-    setcall mem_input_deq memalloc(alloc_size)
-    if mem_input_deq==0
-        call avc_free()
-        return 0
-    endif
-    call avc_input_dequant((value_set),mem_input_deq)
-    call avc_allsize((value_set),alloc_size)
-
-    import "avc_ProfileIndication" avc_ProfileIndication
-    import "avc_profile_compatibility" avc_profile_compatibility
-    import "avc_LevelIndication" avc_LevelIndication
-    call avc_ProfileIndication((value_set),(PROFILE_MAIN))
-    #b_constraint_set0=0;b_constraint_set1=0;b_constraint_set2=0;5 bits reserved
-    call avc_profile_compatibility((value_set),0)
-    #level 4.0
-    call avc_LevelIndication((value_set),40)
-
-    import "avc_frame_num" avc_frame_num
-    import "avc_idr_pic_id" avc_idr_pic_id
-    call avc_frame_num((value_set),(avc_keyint_max))
-    call avc_idr_pic_id((value_set),-1)
-
-    import "avc_quant_mf_set" avc_quant_mf_set
-    call avc_quant_mf_set()
-
-    return 1
-endfunction
-
-#bool
-function avc_rounding(sd value)
-    import "rest" rest
-    setcall value rest(value,16)
-    if value!=0
-        import "texter" texter
-        str er="Width or height isn't a multiple of 16."
-        call texter(er)
-        return 0
-    endif
-    return 1
-endfunction
-
-function avc_free()
-    sd mem
-    setcall mem avc_pre_input((value_get))
-    call free(mem)
-    setcall mem avc_input((value_get))
-    if mem!=0
-        call free(mem)
-    endif
-    setcall mem avc_output((value_get))
-    if mem!=0
-        call free(mem)
-    endif
-    setcall mem avc_nal_output((value_get))
-    if mem!=0
-        call free(mem)
-    endif
-    setcall mem avc_mb_data((value_get))
-    if mem!=0
-        call free(mem)
-    endif
-    setcall mem avc_input_dequant((value_get))
-    if mem!=0
-        call free(mem)
-    endif
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-mp3_bs.oc
@@ -0,0 +1,53 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+import "mp3_output" mp3_output
+import "mp3_allsize" mp3_allsize
+import "mp3_output_size" mp3_output_size
+import "mp3_output_pos" mp3_output_pos
+
+import "shl" shl
+
+function mp3_bs_write(sd value,sd len)
+    sd size
+    setcall size mp3_output_size((value_get))
+    sd allsize
+    setcall allsize mp3_allsize((value_get))
+    sd pos
+    setcall pos mp3_output_pos((value_get))
+    while len!=0
+        if size>=allsize
+            call mp3_output_size((value_set),size)
+            call mp3_output_pos((value_set),pos)
+            return 0
+        endif
+
+        ss mem
+        setcall mem mp3_output((value_get))
+        add mem size
+
+        dec len
+        dec pos
+        sd test=1
+        setcall test shl(test,len)
+        and test value
+        sd unit=1
+        setcall unit shl(unit,pos)
+        if test!=0
+            or mem# unit
+        else
+            xor unit -1
+            and mem# unit
+        endelse
+        if pos=0
+            inc size
+            set pos 8
+        endif
+    endwhile
+    call mp3_output_size((value_set),size)
+    call mp3_output_pos((value_set),pos)
+endfunction
--- ovideo-1.orig/src/media/mpeg-mp3_bs.s
+++ /dev/null
@@ -1,53 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-import "mp3_output" mp3_output
-import "mp3_allsize" mp3_allsize
-import "mp3_output_size" mp3_output_size
-import "mp3_output_pos" mp3_output_pos
-
-import "shl" shl
-
-function mp3_bs_write(sd value,sd len)
-    sd size
-    setcall size mp3_output_size((value_get))
-    sd allsize
-    setcall allsize mp3_allsize((value_get))
-    sd pos
-    setcall pos mp3_output_pos((value_get))
-    while len!=0
-        if size>=allsize
-            call mp3_output_size((value_set),size)
-            call mp3_output_pos((value_set),pos)
-            return 0
-        endif
-
-        ss mem
-        setcall mem mp3_output((value_get))
-        add mem size
-
-        dec len
-        dec pos
-        sd test=1
-        setcall test shl(test,len)
-        and test value
-        sd unit=1
-        setcall unit shl(unit,pos)
-        if test!=0
-            or mem# unit
-        else
-            xor unit -1
-            and mem# unit
-        endelse
-        if pos==0
-            inc size
-            set pos 8
-        endif
-    endwhile
-    call mp3_output_size((value_set),size)
-    call mp3_output_pos((value_set),pos)
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-mp3_data.oc
@@ -0,0 +1,169 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+function mp3_output(sd way,sd value)
+    data output#1
+    if way=(value_set)
+        set output value
+    else
+        return output
+    endelse
+endfunction
+function mp3_allsize(sd way,sd value)
+    data allsize#1
+    if way=(value_set)
+        set allsize value
+    else
+        return allsize
+    endelse
+endfunction
+function mp3_output_size(sd way,sd value)
+    data output_size#1
+    if way=(value_set)
+        set output_size value
+    else
+        return output_size
+    endelse
+endfunction
+function mp3_output_pos(sd way,sd value)
+    data output_pos#1
+    if way=(value_set)
+        set output_pos value
+    else
+        return output_pos
+    endelse
+endfunction
+
+#l3 inits
+
+function mp3_steptab_double()
+    data steptab_data#128*QWORD
+    data steptab^steptab_data
+    return steptab
+endfunction
+function mp3_steptab_double_get_p(sd index)
+    sd tab
+    setcall tab mp3_steptab_double()
+    mult index (QWORD)
+    add tab index
+    return tab
+endfunction
+function mp3_steptabi()
+    data steptabi_data#128*DWORD
+    data steptabi^steptabi_data
+    return steptabi
+endfunction
+function mp3_steptabi_get(sd index)
+    sd tab
+    setcall tab mp3_steptabi()
+    mult index (DWORD)
+    add tab index
+    return tab#
+endfunction
+
+function mp3_int2idx()
+    data int2idx#10000
+    data p_int2idx^int2idx
+    return p_int2idx
+endfunction
+function mp3_int2idx_get(sd index)
+    sd i
+    setcall i mp3_int2idx()
+    mult index (DWORD)
+    add i index
+    return i#
+endfunction
+
+
+#l3_enc
+
+const l3_enc_channelSize=samp_per_frame2*DWORD
+const l3_enc_granuleSize=mp3_channels*l3_enc_channelSize
+#pointer
+function l3_enc(sd granule,sd channel)
+    data l3_enc_data#2*mp3_channels*samp_per_frame2
+    sd l3^l3_enc_data
+    mult granule (l3_enc_granuleSize)
+    add l3 granule
+    mult channel (l3_enc_channelSize)
+    add l3 channel
+    return l3
+endfunction
+#value
+function l3_enc_sample_get(sd set,sd samp_nr)
+    mult samp_nr (DWORD)
+    add set samp_nr
+    return set#
+endfunction
+
+#gr info
+
+const gr_info_items=gr_info_channelSize/DWORD
+const gr_info_granuleSize=mp3_channels*gr_info_channelSize
+#pointer
+function mp3_gr_info(sd granule,sd channel)
+    #side informations
+    data gr_info_data#2*mp3_channels*gr_info_items
+    sd gr_info^gr_info_data
+    mult granule (gr_info_granuleSize)
+    add gr_info granule
+    mult channel (gr_info_channelSize)
+    add gr_info channel
+    return gr_info
+endfunction
+#value
+function mp3_gr_info_itemGet(sd pack,sd item)
+    add pack item
+    return pack#
+endfunction
+#
+function mp3_gr_info_itemSet(sd pack,sd item,sd value)
+    add pack item
+    set pack# value
+endfunction
+
+
+function mp3_xrabs()
+    data xrabs#samp_per_frame2
+    data p^xrabs
+    return p
+endfunction
+function mp3_xrabs_get(sd index)
+    sd tab
+    setcall tab mp3_xrabs()
+    mult index (DWORD)
+    add tab index
+    return tab#
+endfunction
+#
+function mp3_xrmax()
+    data xrmax#1
+    data p_xrmax^xrmax
+    return p_xrmax
+endfunction
+function mp3_xrmax_get()
+    sd x
+    setcall x mp3_xrmax()
+    return x#
+endfunction
+function mp3_xrmax_set(sd value)
+    sd x
+    setcall x mp3_xrmax()
+    set x# value
+endfunction
+
+
+function mp3_l3_sb_sample()
+    data l3_sb_sample_data#l3_sb_sample_units
+    data l3_sb_sample^l3_sb_sample_data
+    return l3_sb_sample
+endfunction
+
+function mp3_mean_bits()
+    data mean_bits#1
+    data p^mean_bits
+    return p
+endfunction
--- ovideo-1.orig/src/media/mpeg-mp3_data.s
+++ /dev/null
@@ -1,169 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-function mp3_output(sd way,sd value)
-    data output#1
-    if way==(value_set)
-        set output value
-    else
-        return output
-    endelse
-endfunction
-function mp3_allsize(sd way,sd value)
-    data allsize#1
-    if way==(value_set)
-        set allsize value
-    else
-        return allsize
-    endelse
-endfunction
-function mp3_output_size(sd way,sd value)
-    data output_size#1
-    if way==(value_set)
-        set output_size value
-    else
-        return output_size
-    endelse
-endfunction
-function mp3_output_pos(sd way,sd value)
-    data output_pos#1
-    if way==(value_set)
-        set output_pos value
-    else
-        return output_pos
-    endelse
-endfunction
-
-#l3 inits
-
-function mp3_steptab_double()
-    data steptab_data#128*QWORD
-    data steptab^steptab_data
-    return steptab
-endfunction
-function mp3_steptab_double_get_p(sd index)
-    sd tab
-    setcall tab mp3_steptab_double()
-    mult index (QWORD)
-    add tab index
-    return tab
-endfunction
-function mp3_steptabi()
-    data steptabi_data#128*DWORD
-    data steptabi^steptabi_data
-    return steptabi
-endfunction
-function mp3_steptabi_get(sd index)
-    sd tab
-    setcall tab mp3_steptabi()
-    mult index (DWORD)
-    add tab index
-    return tab#
-endfunction
-
-function mp3_int2idx()
-    data int2idx#10000
-    data p_int2idx^int2idx
-    return p_int2idx
-endfunction
-function mp3_int2idx_get(sd index)
-    sd i
-    setcall i mp3_int2idx()
-    mult index (DWORD)
-    add i index
-    return i#
-endfunction
-
-
-#l3_enc
-
-const l3_enc_channelSize=samp_per_frame2*DWORD
-const l3_enc_granuleSize=mp3_channels*l3_enc_channelSize
-#pointer
-function l3_enc(sd granule,sd channel)
-    data l3_enc_data#2*mp3_channels*samp_per_frame2
-    sd l3^l3_enc_data
-    mult granule (l3_enc_granuleSize)
-    add l3 granule
-    mult channel (l3_enc_channelSize)
-    add l3 channel
-    return l3
-endfunction
-#value
-function l3_enc_sample_get(sd set,sd samp_nr)
-    mult samp_nr (DWORD)
-    add set samp_nr
-    return set#
-endfunction
-
-#gr info
-
-const gr_info_items=gr_info_channelSize/DWORD
-const gr_info_granuleSize=mp3_channels*gr_info_channelSize
-#pointer
-function mp3_gr_info(sd granule,sd channel)
-    #side informations
-    data gr_info_data#2*mp3_channels*gr_info_items
-    sd gr_info^gr_info_data
-    mult granule (gr_info_granuleSize)
-    add gr_info granule
-    mult channel (gr_info_channelSize)
-    add gr_info channel
-    return gr_info
-endfunction
-#value
-function mp3_gr_info_itemGet(sd pack,sd item)
-    add pack item
-    return pack#
-endfunction
-#
-function mp3_gr_info_itemSet(sd pack,sd item,sd value)
-    add pack item
-    set pack# value
-endfunction
-
-
-function mp3_xrabs()
-    data xrabs#samp_per_frame2
-    data p^xrabs
-    return p
-endfunction
-function mp3_xrabs_get(sd index)
-    sd tab
-    setcall tab mp3_xrabs()
-    mult index (DWORD)
-    add tab index
-    return tab#
-endfunction
-#
-function mp3_xrmax()
-    data xrmax#1
-    data p_xrmax^xrmax
-    return p_xrmax
-endfunction
-function mp3_xrmax_get()
-    sd x
-    setcall x mp3_xrmax()
-    return x#
-endfunction
-function mp3_xrmax_set(sd value)
-    sd x
-    setcall x mp3_xrmax()
-    set x# value
-endfunction
-
-
-function mp3_l3_sb_sample()
-    data l3_sb_sample_data#l3_sb_sample_units
-    data l3_sb_sample^l3_sb_sample_data
-    return l3_sb_sample
-endfunction
-
-function mp3_mean_bits()
-    data mean_bits#1
-    data p^mean_bits
-    return p
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-mp3_encode.oc
@@ -0,0 +1,584 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+import "mp3_output_size" mp3_output_size
+import "mp3_output_pos" mp3_output_pos
+
+#define         MPG_MD_STEREO           0
+const MPG_MD_DUAL_CHANNEL=2
+#define         MPG_MD_MONO             3
+
+const MPG_MD_LR_LR=0
+#define         MPG_MD_LR_I              1
+#define         MPG_MD_MS_LR             2
+#define         MPG_MD_MS_I              3
+
+#bool
+function mp3_encode(sd file)
+    call mp3_output_size((value_set),0)
+    call mp3_output_pos((value_set),8)
+
+    call mp3_encode_frame()
+
+    import "file_write" file_write
+    import "mp3_output" mp3_output
+    ss mem
+    sd size
+    setcall mem mp3_output((value_get))
+    setcall size mp3_output_size((value_get))
+    sd er
+    setcall er file_write(mem,size,file)
+    if er!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+import "fild_value" fild_value
+import "fstp_quad" fstp_quad
+import "fdiv_quad" fdiv_quad
+import "fmul_quad" fmul_quad
+import "double_to_int" double_to_int
+import "sar32" sar
+
+import "mp3_mean_bits" mp3_mean_bits
+import "mp3_l3_sb_sample" mp3_l3_sb_sample
+
+function mp3_encode_init()
+    #sd avg_slots_per_frame
+    #(
+    #    (double)config->mpeg.samples_per_frame /
+    #    (
+    #        (double)config->wave.samplerate/1000
+    #    )
+    #)*(
+    #    (double)config->mpeg.bitr /
+    #    (double)config->mpeg.bits_per_slot
+    #);
+    sd samp_per_frame=samp_per_frame
+    sd samplerate=mp3_samplerate
+    sd bits_per_slot=8
+    sd bitrate
+    setcall bitrate mp3_bitrate()
+    data double_low#1
+    data *double_high#1
+    data double^double_low
+
+    call fild_value(samp_per_frame)
+    call fild_value(samplerate)
+    call fild_value(1000)
+    call fstp_quad(double)
+    call fdiv_quad(double)
+    call fstp_quad(double)
+    call fdiv_quad(double)
+    call fild_value(bitrate)
+    call fild_value(bits_per_slot)
+    call fstp_quad(double)
+    call fdiv_quad(double)
+    call fstp_quad(double)
+    call fmul_quad(double)
+    data whole_slots_per_frame#1
+    data p_whole_slots_per_frame^whole_slots_per_frame
+    call fstp_quad(double)
+    setcall p_whole_slots_per_frame# double_to_int(double)
+    #call fistp(p_whole_slots_per_frame)
+
+    sd bits_per_frame
+    set bits_per_frame whole_slots_per_frame
+    mult bits_per_frame 8
+
+    sd sideinfo_len
+    if (mp3_channels)=1
+        set sideinfo_len 168
+    else
+        set sideinfo_len 288
+    endelse
+
+    sd mean_bits
+    set mean_bits bits_per_frame
+    sub mean_bits sideinfo_len
+    setcall mean_bits sar(mean_bits,1)
+
+    sd p_mean_bits
+    setcall p_mean_bits mp3_mean_bits()
+    set p_mean_bits# mean_bits
+
+    import "setmemzero" setmemzero
+    sd l3_sb_sample
+    setcall l3_sb_sample mp3_l3_sb_sample()
+    call setmemzero(l3_sb_sample,(l3_sb_sample_size))
+endfunction
+
+function mp3_encode_frame()
+    sd mean_bits
+    setcall mean_bits mp3_mean_bits()
+    set mean_bits mean_bits#
+    #
+    char buffer_data#buffer_size
+    data buffer^buffer_data
+    #
+    sd l3_sb_sample
+    setcall l3_sb_sample mp3_l3_sb_sample()
+    #
+    const mdct_freq_size=2*mdct_freq_granule_size
+    data mdct_freq_data#mdct_freq_size
+    data mdct_freq^mdct_freq_data
+    #call setmemzero(mdct_freq,(mdct_freq_size))
+
+    #get from input
+    import "mp3_get_pcm" mp3_get_pcm
+    call mp3_get_pcm(buffer)
+    #polyphase filtering
+    sd buf
+    sd l3_sb
+    import "l3_window_filter_subband" l3_window_filter_subband
+    sd granule=0
+    const buffer_granule_size=buffer_channel_size/2
+    const buffer_band_size=buffer_granule_size/18
+    sd sizeadd
+    set buf buffer
+    set l3_sb l3_sb_sample
+    add l3_sb (l3_sb_sample_granule_size)
+    while granule!=2
+        set sizeadd granule
+        mult sizeadd (buffer_granule_size)
+        add sizeadd (buffer_size)
+        add buf sizeadd
+        #
+        set sizeadd granule
+        mult sizeadd (l3_sb_sample_granule_size)
+        add sizeadd (l3_sb_sample_size)
+        add l3_sb sizeadd
+        #
+        sd channel=mp3_channels
+        while channel!=0
+            dec channel
+            sub buf (buffer_channel_size)
+            sub l3_sb (l3_sb_sample_channel_size)
+            #
+            sd i=0
+            while i<18
+                call l3_window_filter_subband(buf,l3_sb,channel)
+                add buf (buffer_band_size)
+                add l3_sb (l3_sb_sample_band_size)
+                inc i
+            endwhile
+            sub buf (buffer_granule_size)
+            sub l3_sb (l3_sb_sample_granule_size)
+        endwhile
+        inc granule
+    endwhile
+    #apply mdct to the polyphase output
+    import "mp3_mdct" mp3_mdct
+    call mp3_mdct(l3_sb_sample,mdct_freq)
+    #bit and noise allocation
+    import "mp3_iteration" mp3_iteration
+    call mp3_iteration(mdct_freq,mean_bits)
+    #write the frame to the bitstream
+    call mp3_format_bitstream(mdct_freq)
+endfunction
+
+function mp3_bitrate()
+    data bitrate=128
+    return bitrate
+endfunction
+
+import "l3_enc" l3_enc
+
+function mp3_format_bitstream(sd mdct_freq)
+    #from mdct to l3_enc sign is lost, change back
+    sd l3enc_tt
+    setcall l3enc_tt l3_enc(0,0)
+    sd granule=0
+    while granule<2
+        sd channel=0
+        while channel<(mp3_channels)
+            sd i=0
+            while i<(samp_per_frame2)
+                if mdct_freq#<0
+                    #if l3enc_tt#>0
+                    mult l3enc_tt# -1
+                    #endif
+                endif
+                add mdct_freq (DWORD)
+                add l3enc_tt (DWORD)
+                inc i
+            endwhile
+            inc channel
+        endwhile
+        inc granule
+    endwhile
+    #
+    call mp3_side_info()
+    call mp3_main_data()
+endfunction
+
+function mp3_side_info()
+    call mp3_header()
+    call mp3_frameSI()
+endfunction
+
+import "int_in_set" int_in_set
+
+function mp3_header()
+    import "mp3_bs_write" mp3_bs_write
+    #sync
+    call mp3_bs_write(0xfff,12)
+    #version name, 0="MPEG-2 LSF", 1="MPEG-1"
+    call mp3_bs_write(1,1)
+    #layer; (4-layer), 3="III"
+    call mp3_bs_write(1,2)
+    #error_protection=0,(!error_protection)
+    call mp3_bs_write((0+1),1)
+    #biterate index
+    sd biterate_index
+    sd btrt
+    setcall btrt mp3_bitrate()
+    data bitratex_data={0,32,40,48,56,64,80,96,112,128,160,192,224,256,320}
+    data bitratex^bitratex_data
+    setcall biterate_index int_in_set(btrt,bitratex,15)
+    call mp3_bs_write(biterate_index,4)
+    #samplerate index
+    sd samplerate_index
+    data samplerateex_data={44100, 48000, 32000}
+    data samplerateex^samplerateex_data
+    setcall samplerate_index int_in_set(48000,samplerateex,3)
+    call mp3_bs_write(samplerate_index,2)
+    #padding
+    call mp3_bs_write(0,1)
+    #extension
+    call mp3_bs_write(0,1)
+    #mode
+    call mp3_bs_write((MPG_MD_DUAL_CHANNEL),2)
+    #mode_ext
+    call mp3_bs_write((MPG_MD_LR_LR),2)
+    #copyright
+    call mp3_bs_write(0,1)
+    #wantedOriginal = TRUE
+    call mp3_bs_write((TRUE),1)
+    #emphasis
+    call mp3_bs_write(0,2)
+endfunction
+
+import "mp3_gr_info" mp3_gr_info
+import "mp3_gr_info_itemGet" mp3_gr_info_itemGet
+
+function mp3_frameSI()
+    #main_data_begin
+    call mp3_bs_write(0,9)
+    #private_bits
+    #if config->wave.channels == 2
+    call mp3_bs_write(0,3)
+    #scalefactor select information
+    sd i=0
+    while i<(mp3_channels)
+        sd scfsi_band=0
+        while scfsi_band<4
+            call mp3_bs_write(0,1)
+            inc scfsi_band
+        endwhile
+        inc i
+    endwhile
+    sd value
+    sd granule=0
+    while granule<2
+        sd channel=0
+        while channel<(mp3_channels)
+            sd gr_info
+            setcall gr_info mp3_gr_info(granule,channel)
+            #
+            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_part2_3_length))
+            call mp3_bs_write(value,12)
+            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_big_values))
+            call mp3_bs_write(value,9)
+            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_global_gain))
+            call mp3_bs_write(value,8)
+            #scalefac_compress
+            call mp3_bs_write(0,4)
+            call mp3_bs_write(0,1)
+            #
+            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_table_select_0))
+            call mp3_bs_write(value,5)
+            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_table_select_1))
+            call mp3_bs_write(value,5)
+            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_table_select_2))
+            call mp3_bs_write(value,5)
+            #
+            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_region0_count))
+            call mp3_bs_write(value,4)
+            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_region1_count))
+            call mp3_bs_write(value,3)
+            #
+            #preflag
+            call mp3_bs_write(0,1)
+            #scalefac_scale
+            call mp3_bs_write(0,1)
+            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_count1table_select))
+            call mp3_bs_write(value,1)
+            #
+            inc channel
+        endwhile
+        inc granule
+    endwhile
+endfunction
+
+#main data
+
+function mp3_main_data()
+    sd granule=0
+    while granule<2
+        sd channel=0
+        while channel<(mp3_channels)
+            sd gr_info
+            setcall gr_info mp3_gr_info(granule,channel)
+            sd l3enc_tt
+            setcall l3enc_tt l3_enc(granule,channel)
+            #
+            call mp3_Huffmancodebits(gr_info,l3enc_tt)
+            inc channel
+        endwhile
+        inc granule
+    endwhile
+endfunction
+
+import "l3_enc_sample_get" l3_enc_sample_get
+import "scalefac_band_long_get" scalefac_band_long_get
+
+function mp3_Huffmancodebits(sd gr_info,sd l3enc)
+    data code#1
+    data p_code^code
+    data bisize#1
+    data p_bisize^bisize
+    data ext#1
+    data p_ext^ext
+    data ext_bisize#1
+    data p_ext_bisize^ext_bisize
+    sd index
+    sd tableindex
+    sd bigvalues
+    setcall bigvalues mp3_gr_info_itemGet(gr_info,(gr_info_big_values))
+    mult bigvalues 2
+    #1: Write the bigvalues
+    sd scalefac_index
+    sd region1Start
+    setcall scalefac_index mp3_gr_info_itemGet(gr_info,(gr_info_region0_count))
+    inc scalefac_index
+    setcall region1Start scalefac_band_long_get(scalefac_index)
+    sd region2Start
+    addcall scalefac_index mp3_gr_info_itemGet(gr_info,(gr_info_region1_count))
+    inc scalefac_index
+    setcall region2Start scalefac_band_long_get(scalefac_index)
+    sd v
+    sd w
+    sd x
+    sd y
+    sd bitsWritten=0
+    sd i=0
+    while i<bigvalues
+        #get table pointer
+        if i<region1Start
+            setcall tableindex mp3_gr_info_itemGet(gr_info,(gr_info_table_select_0))
+        elseif i<region2Start
+            setcall tableindex mp3_gr_info_itemGet(gr_info,(gr_info_table_select_1))
+        else
+            setcall tableindex mp3_gr_info_itemGet(gr_info,(gr_info_table_select_2))
+        endelse
+        if tableindex!=0
+            set index i
+            setcall x l3_enc_sample_get(l3enc,index)
+            inc index
+            setcall y l3_enc_sample_get(l3enc,index)
+            addcall bitsWritten mp3_HuffmanCode(tableindex,x,y,p_code,p_bisize,p_ext,p_ext_bisize)
+            call mp3_bs_write(code,bisize)
+            call mp3_bs_write(ext,ext_bisize)
+        endif
+        #
+        add i 2
+    endwhile
+    #2: Write count1 area
+    setcall tableindex mp3_gr_info_itemGet(gr_info,(gr_info_count1table_select))
+    add tableindex 32
+    sd count1End
+    setcall count1End mp3_gr_info_itemGet(gr_info,(gr_info_count1))
+    mult count1End 4
+    add count1End bigvalues
+    set i bigvalues
+    while i!=count1End
+        set index i
+        setcall v l3_enc_sample_get(l3enc,index)
+        inc index
+        setcall w l3_enc_sample_get(l3enc,index)
+        inc index
+        setcall x l3_enc_sample_get(l3enc,index)
+        inc index
+        setcall y l3_enc_sample_get(l3enc,index)
+        addcall bitsWritten l3_huffman_coder_count1(tableindex,v,w,x,y)
+        add i 4
+    endwhile
+    import "rest" rest
+    sd stuffingBits
+    setcall stuffingBits mp3_gr_info_itemGet(gr_info,(gr_info_part2_3_length))
+    sub stuffingBits bitsWritten
+    if stuffingBits!=0
+        #Due to the nature of the Huffman code tables, we will pad with ones
+        sd stuffingWords
+        set stuffingWords stuffingBits
+        div stuffingWords 32
+        sd remainingBits
+        setcall remainingBits rest(stuffingBits,32)
+        while stuffingWords!=0
+            dec stuffingWords
+            call mp3_bs_write(-1,32)
+        endwhile
+        if remainingBits!=0
+            call mp3_bs_write(-1,remainingBits)
+        endif
+    endif
+endfunction
+
+import "huffman_tabs" huffman_tabs
+import "huffman_table" huffman_table
+import "huffman_hlen" huffman_hlen
+
+#bits
+function mp3_HuffmanCode(sd tableindex,sd x,sd y,sd p_code,sd p_bisize,sd p_ext,sd p_ext_bisize)
+    sd linbits
+    sd linbitsx=0
+    sd linbitsy=0
+    sd ylen
+    setcall ylen huffman_tabs(tableindex,(huffman_ylen))
+    setcall linbits huffman_tabs(tableindex,(huffman_linbits))
+    sd signx=0
+    if x<0
+        mult x -1
+        set signx 1
+    endif
+    sd signy=0
+    if y<0
+        mult y -1
+        set signy 1
+    endif
+    import "shl" shl
+    sd code
+    sd bisize
+    sd ext=0
+    sd ext_bisize=0
+    sd idx
+    if tableindex>15
+        #ESC-table is used
+        if x>14
+            set linbitsx x
+            sub linbitsx 15
+            set x 15
+        endif
+        if y>14
+            set linbitsy y
+            sub linbitsy 15
+            set y 15
+        endif
+        set idx ylen
+        mult idx x
+        add idx y
+        setcall code huffman_table(tableindex,idx)
+        setcall bisize huffman_hlen(tableindex,idx)
+        if x>14
+            or ext linbitsx
+            add ext_bisize linbits
+        endif
+        if x!=0
+            mult ext 2
+            or ext signx
+            add ext_bisize 1
+        endif
+        if y>14
+            setcall ext shl(ext,linbits)
+            or ext linbitsy
+            add ext_bisize linbits
+        endif
+        if y!=0
+            mult ext 2
+            or ext signy
+            add ext_bisize 1
+        endif
+    else
+        #No ESC-words
+        set idx ylen
+        mult idx x
+        add idx y
+        setcall code huffman_table(tableindex,idx)
+        setcall bisize huffman_hlen(tableindex,idx)
+        if x!=0
+            mult code 2
+            or code signx
+            inc bisize
+        endif
+        if y!=0
+            mult code 2
+            or code signy
+            inc bisize
+        endif
+    endelse
+    set p_code# code
+    set p_bisize# bisize
+    set p_ext# ext
+    set p_ext_bisize# ext_bisize
+    add bisize ext_bisize
+    return bisize
+endfunction
+
+#bits
+function l3_huffman_coder_count1(sd tableindex,sd v,sd w,sd x,sd y)
+    sd totalBits=0
+    sd signv=0
+    if v<0
+        mult v -1
+        set signv 1
+    endif
+    sd signw=0
+    if w<0
+        mult w -1
+        set signw 1
+    endif
+    sd signx=0
+    if x<0
+        mult x -1
+        set signx 1
+    endif
+    sd signy=0
+    if y<0
+        mult y -1
+        set signy 1
+    endif
+    sd p
+    set p v
+    addcall p shl(w,1)
+    addcall p shl(x,2)
+    addcall p shl(y,3)
+    sd code
+    setcall code huffman_table(tableindex,p)
+    sd len
+    setcall len huffman_hlen(tableindex,p)
+    call mp3_bs_write(code,len)
+    add totalBits len
+    if v!=0
+        call mp3_bs_write(signv,1)
+        inc totalBits
+    endif
+    if w!=0
+        call mp3_bs_write(signw,1)
+        inc totalBits
+    endif
+    if x!=0
+        call mp3_bs_write(signx,1)
+        inc totalBits
+    endif
+    if y!=0
+        call mp3_bs_write(signy,1)
+        inc totalBits
+    endif
+    return totalBits
+endfunction
--- ovideo-1.orig/src/media/mpeg-mp3_encode.s
+++ /dev/null
@@ -1,584 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-import "mp3_output_size" mp3_output_size
-import "mp3_output_pos" mp3_output_pos
-
-#define         MPG_MD_STEREO           0
-const MPG_MD_DUAL_CHANNEL=2
-#define         MPG_MD_MONO             3
-
-const MPG_MD_LR_LR=0
-#define         MPG_MD_LR_I              1
-#define         MPG_MD_MS_LR             2
-#define         MPG_MD_MS_I              3
-
-#bool
-function mp3_encode(sd file)
-    call mp3_output_size((value_set),0)
-    call mp3_output_pos((value_set),8)
-
-    call mp3_encode_frame()
-
-    import "file_write" file_write
-    import "mp3_output" mp3_output
-    ss mem
-    sd size
-    setcall mem mp3_output((value_get))
-    setcall size mp3_output_size((value_get))
-    sd er
-    setcall er file_write(mem,size,file)
-    if er!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-import "fild_value" fild_value
-import "fstp_quad" fstp_quad
-import "fdiv_quad" fdiv_quad
-import "fmul_quad" fmul_quad
-import "double_to_int" double_to_int
-import "sar32" sar
-
-import "mp3_mean_bits" mp3_mean_bits
-import "mp3_l3_sb_sample" mp3_l3_sb_sample
-
-function mp3_encode_init()
-    #sd avg_slots_per_frame
-    #(
-    #    (double)config->mpeg.samples_per_frame /
-    #    (
-    #        (double)config->wave.samplerate/1000
-    #    )
-    #)*(
-    #    (double)config->mpeg.bitr /
-    #    (double)config->mpeg.bits_per_slot
-    #);
-    sd samp_per_frame=samp_per_frame
-    sd samplerate=mp3_samplerate
-    sd bits_per_slot=8
-    sd bitrate
-    setcall bitrate mp3_bitrate()
-    data double_low#1
-    data *double_high#1
-    data double^double_low
-
-    call fild_value(samp_per_frame)
-    call fild_value(samplerate)
-    call fild_value(1000)
-    call fstp_quad(double)
-    call fdiv_quad(double)
-    call fstp_quad(double)
-    call fdiv_quad(double)
-    call fild_value(bitrate)
-    call fild_value(bits_per_slot)
-    call fstp_quad(double)
-    call fdiv_quad(double)
-    call fstp_quad(double)
-    call fmul_quad(double)
-    data whole_slots_per_frame#1
-    data p_whole_slots_per_frame^whole_slots_per_frame
-    call fstp_quad(double)
-    setcall p_whole_slots_per_frame# double_to_int(double)
-    #call fistp(p_whole_slots_per_frame)
-
-    sd bits_per_frame
-    set bits_per_frame whole_slots_per_frame
-    mult bits_per_frame 8
-
-    sd sideinfo_len
-    if (mp3_channels)==1
-        set sideinfo_len 168
-    else
-        set sideinfo_len 288
-    endelse
-
-    sd mean_bits
-    set mean_bits bits_per_frame
-    sub mean_bits sideinfo_len
-    setcall mean_bits sar(mean_bits,1)
-
-    sd p_mean_bits
-    setcall p_mean_bits mp3_mean_bits()
-    set p_mean_bits# mean_bits
-
-    import "setmemzero" setmemzero
-    sd l3_sb_sample
-    setcall l3_sb_sample mp3_l3_sb_sample()
-    call setmemzero(l3_sb_sample,(l3_sb_sample_size))
-endfunction
-
-function mp3_encode_frame()
-    sd mean_bits
-    setcall mean_bits mp3_mean_bits()
-    set mean_bits mean_bits#
-    #
-    char buffer_data#buffer_size
-    data buffer^buffer_data
-    #
-    sd l3_sb_sample
-    setcall l3_sb_sample mp3_l3_sb_sample()
-    #
-    const mdct_freq_size=2*mdct_freq_granule_size
-    data mdct_freq_data#mdct_freq_size
-    data mdct_freq^mdct_freq_data
-    #call setmemzero(mdct_freq,(mdct_freq_size))
-
-    #get from input
-    import "mp3_get_pcm" mp3_get_pcm
-    call mp3_get_pcm(buffer)
-    #polyphase filtering
-    sd buf
-    sd l3_sb
-    import "l3_window_filter_subband" l3_window_filter_subband
-    sd granule=0
-    const buffer_granule_size=buffer_channel_size/2
-    const buffer_band_size=buffer_granule_size/18
-    sd sizeadd
-    set buf buffer
-    set l3_sb l3_sb_sample
-    add l3_sb (l3_sb_sample_granule_size)
-    while granule!=2
-        set sizeadd granule
-        mult sizeadd (buffer_granule_size)
-        add sizeadd (buffer_size)
-        add buf sizeadd
-        #
-        set sizeadd granule
-        mult sizeadd (l3_sb_sample_granule_size)
-        add sizeadd (l3_sb_sample_size)
-        add l3_sb sizeadd
-        #
-        sd channel=mp3_channels
-        while channel!=0
-            dec channel
-            sub buf (buffer_channel_size)
-            sub l3_sb (l3_sb_sample_channel_size)
-            #
-            sd i=0
-            while i<18
-                call l3_window_filter_subband(buf,l3_sb,channel)
-                add buf (buffer_band_size)
-                add l3_sb (l3_sb_sample_band_size)
-                inc i
-            endwhile
-            sub buf (buffer_granule_size)
-            sub l3_sb (l3_sb_sample_granule_size)
-        endwhile
-        inc granule
-    endwhile
-    #apply mdct to the polyphase output
-    import "mp3_mdct" mp3_mdct
-    call mp3_mdct(l3_sb_sample,mdct_freq)
-    #bit and noise allocation
-    import "mp3_iteration" mp3_iteration
-    call mp3_iteration(mdct_freq,mean_bits)
-    #write the frame to the bitstream
-    call mp3_format_bitstream(mdct_freq)
-endfunction
-
-function mp3_bitrate()
-    data bitrate=128
-    return bitrate
-endfunction
-
-import "l3_enc" l3_enc
-
-function mp3_format_bitstream(sd mdct_freq)
-    #from mdct to l3_enc sign is lost, change back
-    sd l3enc_tt
-    setcall l3enc_tt l3_enc(0,0)
-    sd granule=0
-    while granule<2
-        sd channel=0
-        while channel<(mp3_channels)
-            sd i=0
-            while i<(samp_per_frame2)
-                if mdct_freq#<0
-                    #if l3enc_tt#>0
-                    mult l3enc_tt# -1
-                    #endif
-                endif
-                add mdct_freq (DWORD)
-                add l3enc_tt (DWORD)
-                inc i
-            endwhile
-            inc channel
-        endwhile
-        inc granule
-    endwhile
-    #
-    call mp3_side_info()
-    call mp3_main_data()
-endfunction
-
-function mp3_side_info()
-    call mp3_header()
-    call mp3_frameSI()
-endfunction
-
-import "int_in_set" int_in_set
-
-function mp3_header()
-    import "mp3_bs_write" mp3_bs_write
-    #sync
-    call mp3_bs_write(0xfff,12)
-    #version name, 0="MPEG-2 LSF", 1="MPEG-1"
-    call mp3_bs_write(1,1)
-    #layer; (4-layer), 3="III"
-    call mp3_bs_write(1,2)
-    #error_protection=0,(!error_protection)
-    call mp3_bs_write((0+1),1)
-    #biterate index
-    sd biterate_index
-    sd btrt
-    setcall btrt mp3_bitrate()
-    data bitratex_data={0,32,40,48,56,64,80,96,112,128,160,192,224,256,320}
-    data bitratex^bitratex_data
-    setcall biterate_index int_in_set(btrt,bitratex,15)
-    call mp3_bs_write(biterate_index,4)
-    #samplerate index
-    sd samplerate_index
-    data samplerateex_data={44100, 48000, 32000}
-    data samplerateex^samplerateex_data
-    setcall samplerate_index int_in_set(48000,samplerateex,3)
-    call mp3_bs_write(samplerate_index,2)
-    #padding
-    call mp3_bs_write(0,1)
-    #extension
-    call mp3_bs_write(0,1)
-    #mode
-    call mp3_bs_write((MPG_MD_DUAL_CHANNEL),2)
-    #mode_ext
-    call mp3_bs_write((MPG_MD_LR_LR),2)
-    #copyright
-    call mp3_bs_write(0,1)
-    #wantedOriginal = TRUE
-    call mp3_bs_write((TRUE),1)
-    #emphasis
-    call mp3_bs_write(0,2)
-endfunction
-
-import "mp3_gr_info" mp3_gr_info
-import "mp3_gr_info_itemGet" mp3_gr_info_itemGet
-
-function mp3_frameSI()
-    #main_data_begin
-    call mp3_bs_write(0,9)
-    #private_bits
-    #if config->wave.channels == 2
-    call mp3_bs_write(0,3)
-    #scalefactor select information
-    sd i=0
-    while i<(mp3_channels)
-        sd scfsi_band=0
-        while scfsi_band<4
-            call mp3_bs_write(0,1)
-            inc scfsi_band
-        endwhile
-        inc i
-    endwhile
-    sd value
-    sd granule=0
-    while granule<2
-        sd channel=0
-        while channel<(mp3_channels)
-            sd gr_info
-            setcall gr_info mp3_gr_info(granule,channel)
-            #
-            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_part2_3_length))
-            call mp3_bs_write(value,12)
-            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_big_values))
-            call mp3_bs_write(value,9)
-            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_global_gain))
-            call mp3_bs_write(value,8)
-            #scalefac_compress
-            call mp3_bs_write(0,4)
-            call mp3_bs_write(0,1)
-            #
-            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_table_select_0))
-            call mp3_bs_write(value,5)
-            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_table_select_1))
-            call mp3_bs_write(value,5)
-            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_table_select_2))
-            call mp3_bs_write(value,5)
-            #
-            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_region0_count))
-            call mp3_bs_write(value,4)
-            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_region1_count))
-            call mp3_bs_write(value,3)
-            #
-            #preflag
-            call mp3_bs_write(0,1)
-            #scalefac_scale
-            call mp3_bs_write(0,1)
-            setcall value mp3_gr_info_itemGet(gr_info,(gr_info_count1table_select))
-            call mp3_bs_write(value,1)
-            #
-            inc channel
-        endwhile
-        inc granule
-    endwhile
-endfunction
-
-#main data
-
-function mp3_main_data()
-    sd granule=0
-    while granule<2
-        sd channel=0
-        while channel<(mp3_channels)
-            sd gr_info
-            setcall gr_info mp3_gr_info(granule,channel)
-            sd l3enc_tt
-            setcall l3enc_tt l3_enc(granule,channel)
-            #
-            call mp3_Huffmancodebits(gr_info,l3enc_tt)
-            inc channel
-        endwhile
-        inc granule
-    endwhile
-endfunction
-
-import "l3_enc_sample_get" l3_enc_sample_get
-import "scalefac_band_long_get" scalefac_band_long_get
-
-function mp3_Huffmancodebits(sd gr_info,sd l3enc)
-    data code#1
-    data p_code^code
-    data bisize#1
-    data p_bisize^bisize
-    data ext#1
-    data p_ext^ext
-    data ext_bisize#1
-    data p_ext_bisize^ext_bisize
-    sd index
-    sd tableindex
-    sd bigvalues
-    setcall bigvalues mp3_gr_info_itemGet(gr_info,(gr_info_big_values))
-    mult bigvalues 2
-    #1: Write the bigvalues
-    sd scalefac_index
-    sd region1Start
-    setcall scalefac_index mp3_gr_info_itemGet(gr_info,(gr_info_region0_count))
-    inc scalefac_index
-    setcall region1Start scalefac_band_long_get(scalefac_index)
-    sd region2Start
-    addcall scalefac_index mp3_gr_info_itemGet(gr_info,(gr_info_region1_count))
-    inc scalefac_index
-    setcall region2Start scalefac_band_long_get(scalefac_index)
-    sd v
-    sd w
-    sd x
-    sd y
-    sd bitsWritten=0
-    sd i=0
-    while i<bigvalues
-        #get table pointer
-        if i<region1Start
-            setcall tableindex mp3_gr_info_itemGet(gr_info,(gr_info_table_select_0))
-        elseif i<region2Start
-            setcall tableindex mp3_gr_info_itemGet(gr_info,(gr_info_table_select_1))
-        else
-            setcall tableindex mp3_gr_info_itemGet(gr_info,(gr_info_table_select_2))
-        endelse
-        if tableindex!=0
-            set index i
-            setcall x l3_enc_sample_get(l3enc,index)
-            inc index
-            setcall y l3_enc_sample_get(l3enc,index)
-            addcall bitsWritten mp3_HuffmanCode(tableindex,x,y,p_code,p_bisize,p_ext,p_ext_bisize)
-            call mp3_bs_write(code,bisize)
-            call mp3_bs_write(ext,ext_bisize)
-        endif
-        #
-        add i 2
-    endwhile
-    #2: Write count1 area
-    setcall tableindex mp3_gr_info_itemGet(gr_info,(gr_info_count1table_select))
-    add tableindex 32
-    sd count1End
-    setcall count1End mp3_gr_info_itemGet(gr_info,(gr_info_count1))
-    mult count1End 4
-    add count1End bigvalues
-    set i bigvalues
-    while i!=count1End
-        set index i
-        setcall v l3_enc_sample_get(l3enc,index)
-        inc index
-        setcall w l3_enc_sample_get(l3enc,index)
-        inc index
-        setcall x l3_enc_sample_get(l3enc,index)
-        inc index
-        setcall y l3_enc_sample_get(l3enc,index)
-        addcall bitsWritten l3_huffman_coder_count1(tableindex,v,w,x,y)
-        add i 4
-    endwhile
-    import "rest" rest
-    sd stuffingBits
-    setcall stuffingBits mp3_gr_info_itemGet(gr_info,(gr_info_part2_3_length))
-    sub stuffingBits bitsWritten
-    if stuffingBits!=0
-        #Due to the nature of the Huffman code tables, we will pad with ones
-        sd stuffingWords
-        set stuffingWords stuffingBits
-        div stuffingWords 32
-        sd remainingBits
-        setcall remainingBits rest(stuffingBits,32)
-        while stuffingWords!=0
-            dec stuffingWords
-            call mp3_bs_write(-1,32)
-        endwhile
-        if remainingBits!=0
-            call mp3_bs_write(-1,remainingBits)
-        endif
-    endif
-endfunction
-
-import "huffman_tabs" huffman_tabs
-import "huffman_table" huffman_table
-import "huffman_hlen" huffman_hlen
-
-#bits
-function mp3_HuffmanCode(sd tableindex,sd x,sd y,sd p_code,sd p_bisize,sd p_ext,sd p_ext_bisize)
-    sd linbits
-    sd linbitsx=0
-    sd linbitsy=0
-    sd ylen
-    setcall ylen huffman_tabs(tableindex,(huffman_ylen))
-    setcall linbits huffman_tabs(tableindex,(huffman_linbits))
-    sd signx=0
-    if x<0
-        mult x -1
-        set signx 1
-    endif
-    sd signy=0
-    if y<0
-        mult y -1
-        set signy 1
-    endif
-    import "shl" shl
-    sd code
-    sd bisize
-    sd ext=0
-    sd ext_bisize=0
-    sd idx
-    if tableindex>15
-        #ESC-table is used
-        if x>14
-            set linbitsx x
-            sub linbitsx 15
-            set x 15
-        endif
-        if y>14
-            set linbitsy y
-            sub linbitsy 15
-            set y 15
-        endif
-        set idx ylen
-        mult idx x
-        add idx y
-        setcall code huffman_table(tableindex,idx)
-        setcall bisize huffman_hlen(tableindex,idx)
-        if x>14
-            or ext linbitsx
-            add ext_bisize linbits
-        endif
-        if x!=0
-            mult ext 2
-            or ext signx
-            add ext_bisize 1
-        endif
-        if y>14
-            setcall ext shl(ext,linbits)
-            or ext linbitsy
-            add ext_bisize linbits
-        endif
-        if y!=0
-            mult ext 2
-            or ext signy
-            add ext_bisize 1
-        endif
-    else
-        #No ESC-words
-        set idx ylen
-        mult idx x
-        add idx y
-        setcall code huffman_table(tableindex,idx)
-        setcall bisize huffman_hlen(tableindex,idx)
-        if x!=0
-            mult code 2
-            or code signx
-            inc bisize
-        endif
-        if y!=0
-            mult code 2
-            or code signy
-            inc bisize
-        endif
-    endelse
-    set p_code# code
-    set p_bisize# bisize
-    set p_ext# ext
-    set p_ext_bisize# ext_bisize
-    add bisize ext_bisize
-    return bisize
-endfunction
-
-#bits
-function l3_huffman_coder_count1(sd tableindex,sd v,sd w,sd x,sd y)
-    sd totalBits=0
-    sd signv=0
-    if v<0
-        mult v -1
-        set signv 1
-    endif
-    sd signw=0
-    if w<0
-        mult w -1
-        set signw 1
-    endif
-    sd signx=0
-    if x<0
-        mult x -1
-        set signx 1
-    endif
-    sd signy=0
-    if y<0
-        mult y -1
-        set signy 1
-    endif
-    sd p
-    set p v
-    addcall p shl(w,1)
-    addcall p shl(x,2)
-    addcall p shl(y,3)
-    sd code
-    setcall code huffman_table(tableindex,p)
-    sd len
-    setcall len huffman_hlen(tableindex,p)
-    call mp3_bs_write(code,len)
-    add totalBits len
-    if v!=0
-        call mp3_bs_write(signv,1)
-        inc totalBits
-    endif
-    if w!=0
-        call mp3_bs_write(signw,1)
-        inc totalBits
-    endif
-    if x!=0
-        call mp3_bs_write(signx,1)
-        inc totalBits
-    endif
-    if y!=0
-        call mp3_bs_write(signy,1)
-        inc totalBits
-    endif
-    return totalBits
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-mp3_huffman.oc
@@ -0,0 +1,179 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+#HTN     34
+
+function huffman_hlen(sd tab,sd index)
+    char tab1={1, 3, 2, 3}
+    const t1^tab1
+    char tab2={1, 3, 6, 3, 3, 5, 5, 5, 6}
+    const t2^tab2
+    char tab3={2, 2, 6, 3, 2, 5, 5, 5, 6}
+    const t3^tab3
+    char tab5={1, 3, 6, 7, 3, 3, 6, 7, 6, 6, 7, 8, 7, 6, 7, 8}
+    const t5^tab5
+    char tab6={3, 3, 5, 7, 3, 2, 4, 5, 4, 4, 5, 6, 6, 5, 6, 7}
+    const t6^tab6
+    char tab7={1, 3, 6, 8, 8, 9, 3, 4, 6, 7, 7, 8, 6, 5, 7, 8, 8, 9, 7, 7, 8, 9, 9, 9, 7, 7, 8, 9, 9, 10, 8, 8, 9, 10, 10, 10}
+    const t7^tab7
+    char tab8={2, 3, 6, 8, 8, 9, 3, 2, 4, 8, 8, 8, 6, 4, 6, 8, 8, 9, 8, 8, 8, 9, 9, 10, 8, 7, 8, 9, 10, 10, 9, 8, 9, 9, 11, 11}
+    const t8^tab8
+    char tab9={3, 3, 5, 6, 8, 9, 3, 3, 4, 5, 6, 8, 4, 4, 5, 6, 7, 8, 6, 5, 6, 7, 7, 8, 7, 6, 7, 7, 8, 9, 8, 7, 8, 8, 9, 9}
+    const t9^tab9
+    char tab10={1, 3, 6, 8, 9, 9, 9, 10, 3, 4, 6, 7, 8, 9, 8, 8, 6, 6, 7, 8, 9, 10, 9, 9, 7, 7, 8, 9, 10, 10, 9, 10, 8, 8, 9, 10, 10, 10, 10, 10, 9, 9, 10, 10, 11, 11, 10, 11, 8, 8, 9, 10, 10, 10, 11, 11, 9, 8, 9, 10, 10, 11, 11, 11}
+    const t10^tab10
+    char tab11={2, 3, 5, 7, 8, 9, 8, 9, 3, 3, 4, 6, 8, 8, 7, 8, 5, 5, 6, 7, 8, 9, 8, 8, 7, 6, 7, 9, 8, 10, 8, 9, 8, 8, 8, 9, 9, 10, 9, 10, 8, 8, 9, 10, 10, 11, 10, 11, 8, 7, 7, 8, 9, 10, 10, 10, 8, 7, 8, 9, 10, 10, 10, 10}
+    const t11^tab11
+    char tab12={4, 3, 5, 7, 8, 9, 9, 9, 3, 3, 4, 5, 7, 7, 8, 8, 5, 4, 5, 6, 7, 8, 7, 8, 6, 5, 6, 6, 7, 8, 8, 8, 7, 6, 7, 7, 8, 8, 8, 9, 8, 7, 8, 8, 8, 9, 8, 9, 8, 7, 7, 8, 8, 9, 9, 10, 9, 8, 8, 9, 9, 9, 9, 10}
+    const t12^tab12
+    char tab13={1, 4, 6, 7, 8, 9, 9, 10, 9, 10, 11, 11, 12, 12, 13, 13, 3, 4, 6, 7, 8, 8, 9, 9, 9, 9, 10, 10, 11, 12, 12, 12, 6, 6, 7, 8, 9, 9, 10, 10, 9, 10, 10, 11, 11, 12, 13, 13, 7, 7, 8, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 13}
+    char *  ={8, 7, 9, 9, 10, 10, 11, 11, 10, 11, 11, 12, 12, 13, 13, 14, 9, 8, 9, 10, 10, 10, 11, 11, 11, 11, 12, 11, 13, 13, 14, 14, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 14, 10, 9, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 16, 16, 9, 8, 9, 10}
+    char *  ={10, 11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 15, 10, 9, 10, 10, 11, 11, 11, 13, 12, 13, 13, 14, 14, 14, 16, 15, 10, 10, 10, 11, 11, 12, 12, 13, 12, 13, 14, 13, 14, 15, 16, 17, 11, 10, 10, 11, 12, 12, 12, 12, 13, 13, 13, 14, 15, 15, 15, 16, 11, 11, 11, 12, 12}
+    char *  ={13, 12, 13, 14, 14, 15, 15, 15, 16, 16, 16, 12, 11, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 16, 15, 16, 16, 13, 12, 12, 13, 13, 13, 15, 14, 14, 17, 15, 15, 15, 17, 16, 16, 12, 12, 13, 14, 14, 14, 15, 14, 15, 15, 16, 16, 19, 18, 19, 16}
+    const t13^tab13
+    char tab15={3, 4, 5, 7, 7, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 13, 4, 3, 5, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 10, 11, 11, 5, 5, 5, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 11, 11, 11, 6, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 7, 6, 7}
+    char *  ={7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 8, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 11, 11, 11, 12, 9, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 12, 12, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 12, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11}
+    char *  ={12, 12, 12, 9, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 10, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 12, 10, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 11, 10, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 13, 13}
+    char *  ={11, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 12, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 12, 13, 12, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13}
+    const t15^tab15
+    char tab16={1, 4, 6, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 9, 3, 4, 6, 7, 8, 9, 9, 9, 10, 10, 10, 11, 12, 11, 12, 8, 6, 6, 7, 8, 9, 9, 10, 10, 11, 10, 11, 11, 11, 12, 12, 9, 8, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13}
+    char *  ={10, 9, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 9, 9, 8, 9, 9, 10, 11, 11, 12, 11, 12, 12, 13, 13, 13, 14, 10, 10, 9, 9, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 10, 10, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 15, 15, 10, 10, 10}
+    char *  ={10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 10, 11, 10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 14, 13, 14, 13, 11, 11, 11, 10, 11, 12, 12, 12, 12, 13, 14, 14, 14, 15, 15, 14, 10, 12, 11, 11, 11, 12, 12, 13, 14, 14, 14, 14, 14, 14, 13, 14, 11, 12, 12}
+    char *  ={12, 12, 12, 13, 13, 13, 13, 15, 14, 14, 14, 14, 16, 11, 14, 12, 12, 12, 13, 13, 14, 14, 14, 16, 15, 15, 15, 17, 15, 11, 13, 13, 11, 12, 14, 14, 13, 14, 14, 15, 16, 15, 17, 15, 14, 11, 9, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8}
+    const t16^tab16
+    char tab24={4, 4, 6, 7, 8, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 9, 4, 4, 5, 6, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 8, 6, 5, 6, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 7, 7, 6, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 7, 8, 7, 7, 8}
+    char *  ={8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 7, 9, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 7, 9, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 7, 10, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 8, 10, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11}
+    char *  ={8, 10, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 8, 11, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 8, 11, 10, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 8, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 8, 11, 10, 10}
+    char *  ={10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8, 12, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4}
+    const t24^tab24
+    char tab32={1, 4, 4, 5, 4, 6, 5, 6, 4, 5, 5, 6, 5, 6, 6, 6}
+    const t32^tab32
+    char tab33={4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4}
+    const t33^tab33
+
+    data hlen%{0,t1, t2, t3,0, t5, t6, t7, t8, t9, t10, t11, t12, t13,0, t15}
+    data *   %{t16, t16, t16, t16, t16, t16, t16, t16, t24, t24, t24, t24, t24, t24, t24, t24}
+    data *   %{t32, t33}
+    sd hlen_tabs^hlen
+    mult tab (DWORD)
+    add hlen_tabs tab
+    ss len
+    set len hlen_tabs#
+    add len index
+    return len#
+endfunction
+
+function huffman_table(sd tab,sd index)
+    data t1={1, 1, 1, 0}
+    const t1HB^t1
+    data t2={1, 2, 1, 3, 1, 1, 3, 2, 0}
+    const t2HB^t2
+    data t3={3, 2, 1, 1, 1, 1, 3, 2, 0}
+    const t3HB^t3
+    data t5={1, 2, 6, 5, 3, 1, 4, 4, 7, 5, 7, 1, 6, 1, 1, 0}
+    const t5HB^t5
+    data t6={7, 3, 5, 1, 6, 2, 3, 2, 5, 4, 4, 1, 3, 3, 2, 0}
+    const t6HB^t6
+    data t7={1, 2, 10, 19, 16, 10, 3, 3, 7, 10, 5, 3, 11, 4, 13, 17, 8, 4, 12, 11, 18, 15, 11, 2, 7, 6, 9, 14, 3, 1, 6, 4, 5, 3, 2, 0}
+    const t7HB^t7
+    data t8={3, 4, 6, 18, 12, 5, 5, 1, 2, 16, 9, 3, 7, 3, 5, 14, 7, 3, 19, 17, 15, 13, 10, 4, 13, 5, 8, 11, 5, 1, 12, 4, 4, 1, 1, 0}
+    const t8HB^t8
+    data t9={7, 5, 9, 14, 15, 7, 6, 4, 5, 5, 6, 7, 7, 6, 8, 8, 8, 5, 15, 6, 9, 10, 5, 1, 11, 7, 9, 6, 4, 1, 14, 4, 6, 2, 6, 0}
+    const t9HB^t9
+    data t10={1, 2, 10, 23, 35, 30, 12, 17, 3, 3, 8, 12, 18, 21, 12, 7, 11, 9, 15, 21, 32, 40, 19, 6, 14, 13, 22, 34, 46, 23, 18, 7, 20, 19, 33, 47, 27, 22, 9, 3, 31, 22, 41, 26, 21, 20, 5, 3, 14, 13, 10, 11, 16, 6, 5, 1, 9, 8, 7, 8, 4, 4, 2, 0}
+    const t10HB^t10
+    data t11={3, 4, 10, 24, 34, 33, 21, 15, 5, 3, 4, 10, 32, 17, 11, 10, 11, 7, 13, 18, 30, 31, 20, 5, 25, 11, 19, 59, 27, 18, 12, 5, 35, 33, 31, 58, 30, 16, 7, 5, 28, 26, 32, 19, 17, 15, 8, 14, 14, 12, 9, 13, 14, 9, 4, 1, 11, 4, 6, 6, 6, 3, 2, 0}
+    const t11HB^t11
+    data t12={9, 6, 16, 33, 41, 39, 38, 26, 7, 5, 6, 9, 23, 16, 26, 11, 17, 7, 11, 14, 21, 30, 10, 7, 17, 10, 15, 12, 18, 28, 14, 5, 32, 13, 22, 19, 18, 16, 9, 5, 40, 17, 31, 29, 17, 13, 4, 2, 27, 12, 11, 15, 10, 7, 4, 1, 27, 12, 8, 12, 6, 3, 1, 0}
+    const t12HB^t12
+    data t13={1, 5, 14, 21, 34, 51, 46, 71, 42, 52, 68, 52, 67, 44, 43, 19, 3, 4, 12, 19, 31, 26, 44, 33, 31, 24, 32, 24, 31, 35, 22, 14, 15, 13, 23, 36, 59, 49, 77, 65, 29, 40, 30, 40, 27, 33, 42, 16, 22}
+    data *  ={20, 37, 61, 56, 79, 73, 64, 43, 76, 56, 37, 26, 31, 25, 14, 35, 16, 60, 57, 97, 75, 114, 91, 54, 73, 55, 41, 48, 53, 23, 24, 58, 27, 50, 96, 76, 70, 93, 84, 77, 58, 79, 29, 74, 49, 41, 17, 47}
+    data *  ={45, 78, 74, 115, 94, 90, 79, 69, 83, 71, 50, 59, 38, 36, 15, 72, 34, 56, 95, 92, 85, 91, 90, 86, 73, 77, 65, 51, 44, 43, 42, 43, 20, 30, 44, 55, 78, 72, 87, 78, 61, 46, 54, 37, 30, 20, 16, 53}
+    data *  ={25, 41, 37, 44, 59, 54, 81, 66, 76, 57, 54, 37, 18, 39, 11, 35, 33, 31, 57, 42, 82, 72, 80, 47, 58, 55, 21, 22, 26, 38, 22, 53, 25, 23, 38, 70, 60, 51, 36, 55, 26, 34, 23, 27, 14, 9, 7, 34, 32}
+    data *  ={28, 39, 49, 75, 30, 52, 48, 40, 52, 28, 18, 17, 9, 5, 45, 21, 34, 64, 56, 50, 49, 45, 31, 19, 12, 15, 10, 7, 6, 3, 48, 23, 20, 39, 36, 35, 53, 21, 16, 23, 13, 10, 6, 1, 4, 2, 16, 15, 17, 27, 25}
+    data *  ={20, 29, 11, 17, 12, 16, 8, 1, 1, 0, 1}
+    const t13HB^t13
+    data t15={7, 12, 18, 53, 47, 76, 124, 108, 89, 123, 108, 119, 107, 81, 122, 63, 13, 5, 16, 27, 46, 36, 61, 51, 42, 70, 52, 83, 65, 41, 59, 36, 19, 17, 15, 24, 41, 34, 59, 48, 40, 64, 50, 78, 62, 80, 56}
+    data *  ={33, 29, 28, 25, 43, 39, 63, 55, 93, 76, 59, 93, 72, 54, 75, 50, 29, 52, 22, 42, 40, 67, 57, 95, 79, 72, 57, 89, 69, 49, 66, 46, 27, 77, 37, 35, 66, 58, 52, 91, 74, 62, 48, 79, 63, 90, 62, 40, 38}
+    data *  ={125, 32, 60, 56, 50, 92, 78, 65, 55, 87, 71, 51, 73, 51, 70, 30, 109, 53, 49, 94, 88, 75, 66, 122, 91, 73, 56, 42, 64, 44, 21, 25, 90, 43, 41, 77, 73, 63, 56, 92, 77, 66, 47, 67, 48, 53, 36, 20}
+    data *  ={71, 34, 67, 60, 58, 49, 88, 76, 67, 106, 71, 54, 38, 39, 23, 15, 109, 53, 51, 47, 90, 82, 58, 57, 48, 72, 57, 41, 23, 27, 62, 9, 86, 42, 40, 37, 70, 64, 52, 43, 70, 55, 42, 25, 29, 18, 11, 11}
+    data *  ={118, 68, 30, 55, 50, 46, 74, 65, 49, 39, 24, 16, 22, 13, 14, 7, 91, 44, 39, 38, 34, 63, 52, 45, 31, 52, 28, 19, 14, 8, 9, 3, 123, 60, 58, 53, 47, 43, 32, 22, 37, 24, 17, 12, 15, 10, 2, 1, 71}
+    data *  ={37, 34, 30, 28, 20, 17, 26, 21, 16, 10, 6, 8, 6, 2, 0}
+    const t15HB^t15
+    data t16={1, 5, 14, 44, 74, 63, 110, 93, 172, 149, 138, 242, 225, 195, 376, 17, 3, 4, 12, 20, 35, 62, 53, 47, 83, 75, 68, 119, 201, 107, 207, 9, 15, 13, 23, 38, 67, 58, 103, 90, 161, 72, 127, 117}
+    data *  ={110, 209, 206, 16, 45, 21, 39, 69, 64, 114, 99, 87, 158, 140, 252, 212, 199, 387, 365, 26, 75, 36, 68, 65, 115, 101, 179, 164, 155, 264, 246, 226, 395, 382, 362, 9, 66, 30, 59, 56, 102}
+    data *  ={185, 173, 265, 142, 253, 232, 400, 388, 378, 445, 16, 111, 54, 52, 100, 184, 178, 160, 133, 257, 244, 228, 217, 385, 366, 715, 10, 98, 48, 91, 88, 165, 157, 148, 261, 248, 407, 397, 372}
+    data *  ={380, 889, 884, 8, 85, 84, 81, 159, 156, 143, 260, 249, 427, 401, 392, 383, 727, 713, 708, 7, 154, 76, 73, 141, 131, 256, 245, 426, 406, 394, 384, 735, 359, 710, 352, 11, 139, 129, 67, 125}
+    data *  ={247, 233, 229, 219, 393, 743, 737, 720, 885, 882, 439, 4, 243, 120, 118, 115, 227, 223, 396, 746, 742, 736, 721, 712, 706, 223, 436, 6, 202, 224, 222, 218, 216, 389, 386, 381, 364, 888}
+    data *  ={443, 707, 440, 437, 1728, 4, 747, 211, 210, 208, 370, 379, 734, 723, 714, 1735, 883, 877, 876, 3459, 865, 2, 377, 369, 102, 187, 726, 722, 358, 711, 709, 866, 1734, 871, 3458, 870, 434}
+    data *  ={0, 12, 10, 7, 11, 10, 17, 11, 9, 13, 12, 10, 7, 5, 3, 1, 3}
+    const t16HB^t16
+    data t24={15, 13, 46, 80, 146, 262, 248, 434, 426, 669, 653, 649, 621, 517, 1032, 88, 14, 12, 21, 38, 71, 130, 122, 216, 209, 198, 327, 345, 319, 297, 279, 42, 47, 22, 41, 74, 68, 128, 120, 221}
+    data *  ={207, 194, 182, 340, 315, 295, 541, 18, 81, 39, 75, 70, 134, 125, 116, 220, 204, 190, 178, 325, 311, 293, 271, 16, 147, 72, 69, 135, 127, 118, 112, 210, 200, 188, 352, 323, 306, 285}
+    data *  ={540, 14, 263, 66, 129, 126, 119, 114, 214, 202, 192, 180, 341, 317, 301, 281, 262, 12, 249, 123, 121, 117, 113, 215, 206, 195, 185, 347, 330, 308, 291, 272, 520, 10, 435, 115, 111}
+    data *  ={109, 211, 203, 196, 187, 353, 332, 313, 298, 283, 531, 381, 17, 427, 212, 208, 205, 201, 193, 186, 177, 169, 320, 303, 286, 268, 514, 377, 16, 335, 199, 197, 191, 189, 181, 174, 333}
+    data *  ={321, 305, 289, 275, 521, 379, 371, 11, 668, 184, 183, 179, 175, 344, 331, 314, 304, 290, 277, 530, 383, 373, 366, 10, 652, 346, 171, 168, 164, 318, 309, 299, 287, 276, 263, 513, 375}
+    data *  ={368, 362, 6, 648, 322, 316, 312, 307, 302, 292, 284, 269, 261, 512, 376, 370, 364, 359, 4, 620, 300, 296, 294, 288, 282, 273, 266, 515, 380, 374, 369, 365, 361, 357, 2, 1033, 280, 278}
+    data *  ={274, 267, 264, 259, 382, 378, 372, 367, 363, 360, 358, 356, 0, 43, 20, 19, 17, 15, 13, 11, 9, 7, 6, 4, 7, 5, 3, 1, 3}
+    const t24HB^t24
+    data t32={1, 5, 4, 5, 6, 5, 4, 4, 7, 3, 6, 0, 7, 2, 3, 1}
+    const t32HB^t32
+    data t33={15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
+    const t33HB^t33
+    data table_data%{NULL,t1HB,t2HB,t3HB,NULL,t5HB,t6HB,t7HB,t8HB,t9HB,t10HB,t11HB,t12HB,t13HB,NULL,t15HB}
+    data *         %{t16HB,t16HB,t16HB,t16HB,t16HB,t16HB,t16HB,t16HB,t24HB,t24HB,t24HB,t24HB,t24HB,t24HB,t24HB,t24HB,t32HB,t33HB}
+    sd table^table_data
+    mult tab (DWORD)
+    add table tab
+    set table table#
+    mult index (DWORD)
+    add table index
+    return table#
+endfunction
+
+function huffman_tabs(sd index,sd item)
+    #xlen,ylen,linbits,linmax
+    data ent={0,0,0,0}
+    data *  ={2,2,0,0}
+    data *  ={3,3,0,0}
+    data *  ={3,3,0,0}
+    data *  ={0,0,0,0}
+    data *  ={4,4,0,0}
+    data *  ={4,4,0,0}
+    data *  ={6,6,0,0}
+    data *  ={6,6,0,0}
+    data *  ={6,6,0,0}
+    data *  ={8,8,0,0}
+    data *  ={8,8,0,0}
+    data *  ={8,8,0,0}
+    data *  ={16,16,0,0}
+    data *  ={0,0,0,0}
+    data *  ={16,16,0,0}
+    data *  ={16,16,1,1}
+    data *  ={16,16,2,3}
+    data *  ={16,16,3,7}
+    data *  ={16,16,4,15}
+    data *  ={16,16,6,63}
+    data *  ={16,16,8,255}
+    data *  ={16,16,10,1023}
+    data *  ={16,16,13,8191}
+    data *  ={16,16,4,15}
+    data *  ={16,16,5,31}
+    data *  ={16,16,6,63}
+    data *  ={16,16,7,127}
+    data *  ={16,16,8,255}
+    data *  ={16,16,9,511}
+    data *  ={16,16,11,2047}
+    data *  ={16,16,13,8191}
+    data *  ={1,16,0,0}
+    data *  ={1,16,0,0}
+    sd x^ent
+    mult index (huffman_entry)
+    add x index
+    add x item
+    return x#
+endfunction
--- ovideo-1.orig/src/media/mpeg-mp3_huffman.s
+++ /dev/null
@@ -1,179 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-#HTN     34
-
-function huffman_hlen(sd tab,sd index)
-    char tab1={1, 3, 2, 3}
-    const t1^tab1
-    char tab2={1, 3, 6, 3, 3, 5, 5, 5, 6}
-    const t2^tab2
-    char tab3={2, 2, 6, 3, 2, 5, 5, 5, 6}
-    const t3^tab3
-    char tab5={1, 3, 6, 7, 3, 3, 6, 7, 6, 6, 7, 8, 7, 6, 7, 8}
-    const t5^tab5
-    char tab6={3, 3, 5, 7, 3, 2, 4, 5, 4, 4, 5, 6, 6, 5, 6, 7}
-    const t6^tab6
-    char tab7={1, 3, 6, 8, 8, 9, 3, 4, 6, 7, 7, 8, 6, 5, 7, 8, 8, 9, 7, 7, 8, 9, 9, 9, 7, 7, 8, 9, 9, 10, 8, 8, 9, 10, 10, 10}
-    const t7^tab7
-    char tab8={2, 3, 6, 8, 8, 9, 3, 2, 4, 8, 8, 8, 6, 4, 6, 8, 8, 9, 8, 8, 8, 9, 9, 10, 8, 7, 8, 9, 10, 10, 9, 8, 9, 9, 11, 11}
-    const t8^tab8
-    char tab9={3, 3, 5, 6, 8, 9, 3, 3, 4, 5, 6, 8, 4, 4, 5, 6, 7, 8, 6, 5, 6, 7, 7, 8, 7, 6, 7, 7, 8, 9, 8, 7, 8, 8, 9, 9}
-    const t9^tab9
-    char tab10={1, 3, 6, 8, 9, 9, 9, 10, 3, 4, 6, 7, 8, 9, 8, 8, 6, 6, 7, 8, 9, 10, 9, 9, 7, 7, 8, 9, 10, 10, 9, 10, 8, 8, 9, 10, 10, 10, 10, 10, 9, 9, 10, 10, 11, 11, 10, 11, 8, 8, 9, 10, 10, 10, 11, 11, 9, 8, 9, 10, 10, 11, 11, 11}
-    const t10^tab10
-    char tab11={2, 3, 5, 7, 8, 9, 8, 9, 3, 3, 4, 6, 8, 8, 7, 8, 5, 5, 6, 7, 8, 9, 8, 8, 7, 6, 7, 9, 8, 10, 8, 9, 8, 8, 8, 9, 9, 10, 9, 10, 8, 8, 9, 10, 10, 11, 10, 11, 8, 7, 7, 8, 9, 10, 10, 10, 8, 7, 8, 9, 10, 10, 10, 10}
-    const t11^tab11
-    char tab12={4, 3, 5, 7, 8, 9, 9, 9, 3, 3, 4, 5, 7, 7, 8, 8, 5, 4, 5, 6, 7, 8, 7, 8, 6, 5, 6, 6, 7, 8, 8, 8, 7, 6, 7, 7, 8, 8, 8, 9, 8, 7, 8, 8, 8, 9, 8, 9, 8, 7, 7, 8, 8, 9, 9, 10, 9, 8, 8, 9, 9, 9, 9, 10}
-    const t12^tab12
-    char tab13={1, 4, 6, 7, 8, 9, 9, 10, 9, 10, 11, 11, 12, 12, 13, 13, 3, 4, 6, 7, 8, 8, 9, 9, 9, 9, 10, 10, 11, 12, 12, 12, 6, 6, 7, 8, 9, 9, 10, 10, 9, 10, 10, 11, 11, 12, 13, 13, 7, 7, 8, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 13}
-    char *  ={8, 7, 9, 9, 10, 10, 11, 11, 10, 11, 11, 12, 12, 13, 13, 14, 9, 8, 9, 10, 10, 10, 11, 11, 11, 11, 12, 11, 13, 13, 14, 14, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 14, 10, 9, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 16, 16, 9, 8, 9, 10}
-    char *  ={10, 11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 15, 10, 9, 10, 10, 11, 11, 11, 13, 12, 13, 13, 14, 14, 14, 16, 15, 10, 10, 10, 11, 11, 12, 12, 13, 12, 13, 14, 13, 14, 15, 16, 17, 11, 10, 10, 11, 12, 12, 12, 12, 13, 13, 13, 14, 15, 15, 15, 16, 11, 11, 11, 12, 12}
-    char *  ={13, 12, 13, 14, 14, 15, 15, 15, 16, 16, 16, 12, 11, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 16, 15, 16, 16, 13, 12, 12, 13, 13, 13, 15, 14, 14, 17, 15, 15, 15, 17, 16, 16, 12, 12, 13, 14, 14, 14, 15, 14, 15, 15, 16, 16, 19, 18, 19, 16}
-    const t13^tab13
-    char tab15={3, 4, 5, 7, 7, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 13, 4, 3, 5, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 10, 11, 11, 5, 5, 5, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 11, 11, 11, 6, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 7, 6, 7}
-    char *  ={7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 8, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 11, 11, 11, 12, 9, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 12, 12, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 12, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11}
-    char *  ={12, 12, 12, 9, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 10, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 12, 10, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 11, 10, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 13, 13}
-    char *  ={11, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 12, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 12, 13, 12, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13}
-    const t15^tab15
-    char tab16={1, 4, 6, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 9, 3, 4, 6, 7, 8, 9, 9, 9, 10, 10, 10, 11, 12, 11, 12, 8, 6, 6, 7, 8, 9, 9, 10, 10, 11, 10, 11, 11, 11, 12, 12, 9, 8, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13}
-    char *  ={10, 9, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 9, 9, 8, 9, 9, 10, 11, 11, 12, 11, 12, 12, 13, 13, 13, 14, 10, 10, 9, 9, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 10, 10, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 15, 15, 10, 10, 10}
-    char *  ={10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 10, 11, 10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 14, 13, 14, 13, 11, 11, 11, 10, 11, 12, 12, 12, 12, 13, 14, 14, 14, 15, 15, 14, 10, 12, 11, 11, 11, 12, 12, 13, 14, 14, 14, 14, 14, 14, 13, 14, 11, 12, 12}
-    char *  ={12, 12, 12, 13, 13, 13, 13, 15, 14, 14, 14, 14, 16, 11, 14, 12, 12, 12, 13, 13, 14, 14, 14, 16, 15, 15, 15, 17, 15, 11, 13, 13, 11, 12, 14, 14, 13, 14, 14, 15, 16, 15, 17, 15, 14, 11, 9, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8}
-    const t16^tab16
-    char tab24={4, 4, 6, 7, 8, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 9, 4, 4, 5, 6, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 8, 6, 5, 6, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 7, 7, 6, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 7, 8, 7, 7, 8}
-    char *  ={8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 7, 9, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 7, 9, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 7, 10, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 8, 10, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11}
-    char *  ={8, 10, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 8, 11, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 8, 11, 10, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 8, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 8, 11, 10, 10}
-    char *  ={10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8, 12, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4}
-    const t24^tab24
-    char tab32={1, 4, 4, 5, 4, 6, 5, 6, 4, 5, 5, 6, 5, 6, 6, 6}
-    const t32^tab32
-    char tab33={4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4}
-    const t33^tab33
-
-    data hlen%{0,t1, t2, t3,0, t5, t6, t7, t8, t9, t10, t11, t12, t13,0, t15}
-    data *   %{t16, t16, t16, t16, t16, t16, t16, t16, t24, t24, t24, t24, t24, t24, t24, t24}
-    data *   %{t32, t33}
-    sd hlen_tabs^hlen
-    mult tab (DWORD)
-    add hlen_tabs tab
-    ss len
-    set len hlen_tabs#
-    add len index
-    return len#
-endfunction
-
-function huffman_table(sd tab,sd index)
-    data t1={1, 1, 1, 0}
-    const t1HB^t1
-    data t2={1, 2, 1, 3, 1, 1, 3, 2, 0}
-    const t2HB^t2
-    data t3={3, 2, 1, 1, 1, 1, 3, 2, 0}
-    const t3HB^t3
-    data t5={1, 2, 6, 5, 3, 1, 4, 4, 7, 5, 7, 1, 6, 1, 1, 0}
-    const t5HB^t5
-    data t6={7, 3, 5, 1, 6, 2, 3, 2, 5, 4, 4, 1, 3, 3, 2, 0}
-    const t6HB^t6
-    data t7={1, 2, 10, 19, 16, 10, 3, 3, 7, 10, 5, 3, 11, 4, 13, 17, 8, 4, 12, 11, 18, 15, 11, 2, 7, 6, 9, 14, 3, 1, 6, 4, 5, 3, 2, 0}
-    const t7HB^t7
-    data t8={3, 4, 6, 18, 12, 5, 5, 1, 2, 16, 9, 3, 7, 3, 5, 14, 7, 3, 19, 17, 15, 13, 10, 4, 13, 5, 8, 11, 5, 1, 12, 4, 4, 1, 1, 0}
-    const t8HB^t8
-    data t9={7, 5, 9, 14, 15, 7, 6, 4, 5, 5, 6, 7, 7, 6, 8, 8, 8, 5, 15, 6, 9, 10, 5, 1, 11, 7, 9, 6, 4, 1, 14, 4, 6, 2, 6, 0}
-    const t9HB^t9
-    data t10={1, 2, 10, 23, 35, 30, 12, 17, 3, 3, 8, 12, 18, 21, 12, 7, 11, 9, 15, 21, 32, 40, 19, 6, 14, 13, 22, 34, 46, 23, 18, 7, 20, 19, 33, 47, 27, 22, 9, 3, 31, 22, 41, 26, 21, 20, 5, 3, 14, 13, 10, 11, 16, 6, 5, 1, 9, 8, 7, 8, 4, 4, 2, 0}
-    const t10HB^t10
-    data t11={3, 4, 10, 24, 34, 33, 21, 15, 5, 3, 4, 10, 32, 17, 11, 10, 11, 7, 13, 18, 30, 31, 20, 5, 25, 11, 19, 59, 27, 18, 12, 5, 35, 33, 31, 58, 30, 16, 7, 5, 28, 26, 32, 19, 17, 15, 8, 14, 14, 12, 9, 13, 14, 9, 4, 1, 11, 4, 6, 6, 6, 3, 2, 0}
-    const t11HB^t11
-    data t12={9, 6, 16, 33, 41, 39, 38, 26, 7, 5, 6, 9, 23, 16, 26, 11, 17, 7, 11, 14, 21, 30, 10, 7, 17, 10, 15, 12, 18, 28, 14, 5, 32, 13, 22, 19, 18, 16, 9, 5, 40, 17, 31, 29, 17, 13, 4, 2, 27, 12, 11, 15, 10, 7, 4, 1, 27, 12, 8, 12, 6, 3, 1, 0}
-    const t12HB^t12
-    data t13={1, 5, 14, 21, 34, 51, 46, 71, 42, 52, 68, 52, 67, 44, 43, 19, 3, 4, 12, 19, 31, 26, 44, 33, 31, 24, 32, 24, 31, 35, 22, 14, 15, 13, 23, 36, 59, 49, 77, 65, 29, 40, 30, 40, 27, 33, 42, 16, 22}
-    data *  ={20, 37, 61, 56, 79, 73, 64, 43, 76, 56, 37, 26, 31, 25, 14, 35, 16, 60, 57, 97, 75, 114, 91, 54, 73, 55, 41, 48, 53, 23, 24, 58, 27, 50, 96, 76, 70, 93, 84, 77, 58, 79, 29, 74, 49, 41, 17, 47}
-    data *  ={45, 78, 74, 115, 94, 90, 79, 69, 83, 71, 50, 59, 38, 36, 15, 72, 34, 56, 95, 92, 85, 91, 90, 86, 73, 77, 65, 51, 44, 43, 42, 43, 20, 30, 44, 55, 78, 72, 87, 78, 61, 46, 54, 37, 30, 20, 16, 53}
-    data *  ={25, 41, 37, 44, 59, 54, 81, 66, 76, 57, 54, 37, 18, 39, 11, 35, 33, 31, 57, 42, 82, 72, 80, 47, 58, 55, 21, 22, 26, 38, 22, 53, 25, 23, 38, 70, 60, 51, 36, 55, 26, 34, 23, 27, 14, 9, 7, 34, 32}
-    data *  ={28, 39, 49, 75, 30, 52, 48, 40, 52, 28, 18, 17, 9, 5, 45, 21, 34, 64, 56, 50, 49, 45, 31, 19, 12, 15, 10, 7, 6, 3, 48, 23, 20, 39, 36, 35, 53, 21, 16, 23, 13, 10, 6, 1, 4, 2, 16, 15, 17, 27, 25}
-    data *  ={20, 29, 11, 17, 12, 16, 8, 1, 1, 0, 1}
-    const t13HB^t13
-    data t15={7, 12, 18, 53, 47, 76, 124, 108, 89, 123, 108, 119, 107, 81, 122, 63, 13, 5, 16, 27, 46, 36, 61, 51, 42, 70, 52, 83, 65, 41, 59, 36, 19, 17, 15, 24, 41, 34, 59, 48, 40, 64, 50, 78, 62, 80, 56}
-    data *  ={33, 29, 28, 25, 43, 39, 63, 55, 93, 76, 59, 93, 72, 54, 75, 50, 29, 52, 22, 42, 40, 67, 57, 95, 79, 72, 57, 89, 69, 49, 66, 46, 27, 77, 37, 35, 66, 58, 52, 91, 74, 62, 48, 79, 63, 90, 62, 40, 38}
-    data *  ={125, 32, 60, 56, 50, 92, 78, 65, 55, 87, 71, 51, 73, 51, 70, 30, 109, 53, 49, 94, 88, 75, 66, 122, 91, 73, 56, 42, 64, 44, 21, 25, 90, 43, 41, 77, 73, 63, 56, 92, 77, 66, 47, 67, 48, 53, 36, 20}
-    data *  ={71, 34, 67, 60, 58, 49, 88, 76, 67, 106, 71, 54, 38, 39, 23, 15, 109, 53, 51, 47, 90, 82, 58, 57, 48, 72, 57, 41, 23, 27, 62, 9, 86, 42, 40, 37, 70, 64, 52, 43, 70, 55, 42, 25, 29, 18, 11, 11}
-    data *  ={118, 68, 30, 55, 50, 46, 74, 65, 49, 39, 24, 16, 22, 13, 14, 7, 91, 44, 39, 38, 34, 63, 52, 45, 31, 52, 28, 19, 14, 8, 9, 3, 123, 60, 58, 53, 47, 43, 32, 22, 37, 24, 17, 12, 15, 10, 2, 1, 71}
-    data *  ={37, 34, 30, 28, 20, 17, 26, 21, 16, 10, 6, 8, 6, 2, 0}
-    const t15HB^t15
-    data t16={1, 5, 14, 44, 74, 63, 110, 93, 172, 149, 138, 242, 225, 195, 376, 17, 3, 4, 12, 20, 35, 62, 53, 47, 83, 75, 68, 119, 201, 107, 207, 9, 15, 13, 23, 38, 67, 58, 103, 90, 161, 72, 127, 117}
-    data *  ={110, 209, 206, 16, 45, 21, 39, 69, 64, 114, 99, 87, 158, 140, 252, 212, 199, 387, 365, 26, 75, 36, 68, 65, 115, 101, 179, 164, 155, 264, 246, 226, 395, 382, 362, 9, 66, 30, 59, 56, 102}
-    data *  ={185, 173, 265, 142, 253, 232, 400, 388, 378, 445, 16, 111, 54, 52, 100, 184, 178, 160, 133, 257, 244, 228, 217, 385, 366, 715, 10, 98, 48, 91, 88, 165, 157, 148, 261, 248, 407, 397, 372}
-    data *  ={380, 889, 884, 8, 85, 84, 81, 159, 156, 143, 260, 249, 427, 401, 392, 383, 727, 713, 708, 7, 154, 76, 73, 141, 131, 256, 245, 426, 406, 394, 384, 735, 359, 710, 352, 11, 139, 129, 67, 125}
-    data *  ={247, 233, 229, 219, 393, 743, 737, 720, 885, 882, 439, 4, 243, 120, 118, 115, 227, 223, 396, 746, 742, 736, 721, 712, 706, 223, 436, 6, 202, 224, 222, 218, 216, 389, 386, 381, 364, 888}
-    data *  ={443, 707, 440, 437, 1728, 4, 747, 211, 210, 208, 370, 379, 734, 723, 714, 1735, 883, 877, 876, 3459, 865, 2, 377, 369, 102, 187, 726, 722, 358, 711, 709, 866, 1734, 871, 3458, 870, 434}
-    data *  ={0, 12, 10, 7, 11, 10, 17, 11, 9, 13, 12, 10, 7, 5, 3, 1, 3}
-    const t16HB^t16
-    data t24={15, 13, 46, 80, 146, 262, 248, 434, 426, 669, 653, 649, 621, 517, 1032, 88, 14, 12, 21, 38, 71, 130, 122, 216, 209, 198, 327, 345, 319, 297, 279, 42, 47, 22, 41, 74, 68, 128, 120, 221}
-    data *  ={207, 194, 182, 340, 315, 295, 541, 18, 81, 39, 75, 70, 134, 125, 116, 220, 204, 190, 178, 325, 311, 293, 271, 16, 147, 72, 69, 135, 127, 118, 112, 210, 200, 188, 352, 323, 306, 285}
-    data *  ={540, 14, 263, 66, 129, 126, 119, 114, 214, 202, 192, 180, 341, 317, 301, 281, 262, 12, 249, 123, 121, 117, 113, 215, 206, 195, 185, 347, 330, 308, 291, 272, 520, 10, 435, 115, 111}
-    data *  ={109, 211, 203, 196, 187, 353, 332, 313, 298, 283, 531, 381, 17, 427, 212, 208, 205, 201, 193, 186, 177, 169, 320, 303, 286, 268, 514, 377, 16, 335, 199, 197, 191, 189, 181, 174, 333}
-    data *  ={321, 305, 289, 275, 521, 379, 371, 11, 668, 184, 183, 179, 175, 344, 331, 314, 304, 290, 277, 530, 383, 373, 366, 10, 652, 346, 171, 168, 164, 318, 309, 299, 287, 276, 263, 513, 375}
-    data *  ={368, 362, 6, 648, 322, 316, 312, 307, 302, 292, 284, 269, 261, 512, 376, 370, 364, 359, 4, 620, 300, 296, 294, 288, 282, 273, 266, 515, 380, 374, 369, 365, 361, 357, 2, 1033, 280, 278}
-    data *  ={274, 267, 264, 259, 382, 378, 372, 367, 363, 360, 358, 356, 0, 43, 20, 19, 17, 15, 13, 11, 9, 7, 6, 4, 7, 5, 3, 1, 3}
-    const t24HB^t24
-    data t32={1, 5, 4, 5, 6, 5, 4, 4, 7, 3, 6, 0, 7, 2, 3, 1}
-    const t32HB^t32
-    data t33={15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
-    const t33HB^t33
-    data table_data%{NULL,t1HB,t2HB,t3HB,NULL,t5HB,t6HB,t7HB,t8HB,t9HB,t10HB,t11HB,t12HB,t13HB,NULL,t15HB}
-    data *         %{t16HB,t16HB,t16HB,t16HB,t16HB,t16HB,t16HB,t16HB,t24HB,t24HB,t24HB,t24HB,t24HB,t24HB,t24HB,t24HB,t32HB,t33HB}
-    sd table^table_data
-    mult tab (DWORD)
-    add table tab
-    set table table#
-    mult index (DWORD)
-    add table index
-    return table#
-endfunction
-
-function huffman_tabs(sd index,sd item)
-    #xlen,ylen,linbits,linmax
-    data ent={0,0,0,0}
-    data *  ={2,2,0,0}
-    data *  ={3,3,0,0}
-    data *  ={3,3,0,0}
-    data *  ={0,0,0,0}
-    data *  ={4,4,0,0}
-    data *  ={4,4,0,0}
-    data *  ={6,6,0,0}
-    data *  ={6,6,0,0}
-    data *  ={6,6,0,0}
-    data *  ={8,8,0,0}
-    data *  ={8,8,0,0}
-    data *  ={8,8,0,0}
-    data *  ={16,16,0,0}
-    data *  ={0,0,0,0}
-    data *  ={16,16,0,0}
-    data *  ={16,16,1,1}
-    data *  ={16,16,2,3}
-    data *  ={16,16,3,7}
-    data *  ={16,16,4,15}
-    data *  ={16,16,6,63}
-    data *  ={16,16,8,255}
-    data *  ={16,16,10,1023}
-    data *  ={16,16,13,8191}
-    data *  ={16,16,4,15}
-    data *  ={16,16,5,31}
-    data *  ={16,16,6,63}
-    data *  ={16,16,7,127}
-    data *  ={16,16,8,255}
-    data *  ={16,16,9,511}
-    data *  ={16,16,11,2047}
-    data *  ={16,16,13,8191}
-    data *  ={1,16,0,0}
-    data *  ={1,16,0,0}
-    sd x^ent
-    mult index (huffman_entry)
-    add x index
-    add x item
-    return x#
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-mp3_input.oc
@@ -0,0 +1,415 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+import "stage_sound_alloc_getremainingsize" stage_sound_alloc_getremainingsize
+import "stage_sound_sizedone" stage_sound_sizedone
+import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
+
+const HAN_SIZE=512
+const han_bytes_size=HAN_SIZE*DWORD
+#get pcm
+
+function mp3_get_pcm(sd buffer)
+    #get the remaining size
+    sd remainingsize
+    setcall remainingsize stage_sound_alloc_getremainingsize()
+    #frame size all the raw size of a channel(samp_per_frame*mp3_bytespersample)
+    sd frame_ch_size
+    setcall frame_ch_size mp3_frame_ch_size()
+    #get size is all the raw size to read
+    sd get_size
+    set get_size frame_ch_size
+    mult get_size (mp3_channels)
+    #can be less remaining size than a frame
+    if get_size>remainingsize
+        set get_size remainingsize
+    endif
+    #get the bytes and add the sizedone
+    sd sizedone
+    sd bytes
+    setcall bytes stage_sound_alloc_getbytes()
+    setcall sizedone stage_sound_sizedone((value_get))
+    add bytes sizedone
+    add sizedone get_size
+    call stage_sound_sizedone((value_set),sizedone)
+    #
+    sd get_ch_size
+    set get_ch_size get_size
+    div get_ch_size (mp3_channels)
+    #raw data to buffer
+    import "cpymem" cpymem
+    sd cursor
+    sd next_channel
+    sd i=0
+    sd cursor_size
+    sd buffer_cursor
+    sd sizeadd
+    while i!=(mp3_channels)
+        set cursor bytes
+        set next_channel i
+        mult next_channel (mp3_bytespersample)
+        add cursor next_channel
+        #
+        set buffer_cursor buffer
+        set sizeadd (buffer_channel_size)
+        mult sizeadd i
+        add buffer_cursor sizeadd
+        #
+        set cursor_size 0
+        while cursor_size!=get_ch_size
+            call cpymem(buffer_cursor,cursor,(mp3_bytespersample))
+            add cursor (mp3_bytespersample*mp3_channels)
+            add buffer_cursor (WORD)
+            add cursor_size (mp3_bytespersample)
+        endwhile
+        inc i
+    endwhile
+    #actions if less than a frame readed
+    #if get_ch_size!=frame_ch_size
+    #    set i 0
+    #    while i!=(mp3_channels)
+    #        set buffer_cursor buffer
+    #        set sizeadd (buffer_channel_size)
+    #        mult sizeadd i
+    #        add buffer_cursor sizeadd
+    #        add buffer_cursor get_ch_size
+            #
+    #        set cursor_size get_ch_size
+    #        while cursor_size!=frame_ch_size
+    #            data silent_data=0
+    #            data p_silent_data^silent_data
+    #            call cpymem(buffer_cursor,p_silent_data,(mp3_bytespersample))
+    #            add buffer_cursor (WORD)
+    #            add cursor_size (mp3_bytespersample)
+    #        endwhile
+    #        inc i
+    #    endwhile
+    #endif
+endfunction
+
+#bool
+function mp3_encode_test()
+    sd sz
+    setcall sz stage_sound_alloc_getremainingsize()
+    sd frame_ch_size
+    setcall frame_ch_size mp3_frame_ch_size()
+    sub sz frame_ch_size
+    if sz<0
+        return 0
+    endif
+    return 1
+endfunction
+
+#frame_ch_size
+function mp3_frame_ch_size()
+    sd frame_ch_size=samp_per_frame
+    mult frame_ch_size (mp3_bytespersample)
+    return frame_ch_size
+endfunction
+
+#subband
+
+const l3_sb_fl_units=SBLIMIT*64
+const l3_sb_fl_size=l3_sb_fl_units*DWORD
+function l3_subband_init()
+    call l3_sb_off_set(0,0)
+    call l3_sb_off_set(1,0)
+    #
+    sd x
+    setcall x l3_sb_x()
+    sd i=0
+    sd j
+    while i!=2
+        set j 0
+        while j!=(HAN_SIZE)
+            set x# 0
+            add x (DWORD)
+            inc j
+        endwhile
+        inc i
+    endwhile
+    #
+    import "str_to_double" str_to_double
+    import "double_mult" double_mult
+    data double_low#1
+    data double_high#1
+    data double^double_low
+    data PI64_low#1
+    data *PI64_high#1
+    data PI64^PI64_low
+    str PI64_str="0.049087385212"
+    call str_to_double(PI64_str,PI64)
+    data const1_low#1
+    data *const1_high#1
+    data const1^const1_low
+    str const1_str="1e9"
+    call str_to_double(const1_str,const1)
+    data const2_low#1
+    data *const2_high#1
+    data const2^const2_low
+    str const2_str="0.5"
+    call str_to_double(const2_str,const2)
+    data const3_low#1
+    data *const3_high#1
+    data const3^const3_low
+    str const3_str="1e-9"
+    call str_to_double(const3_str,const3)
+    data const4_low#1
+    data *const4_high#1
+    data const4^const4_low
+    str const4_str="0"
+    call str_to_double(const4_str,const4)
+    #
+    call double_mult(const4,const3)
+    import "fld_quad" fld_quad
+    import "fild_value" fild_value
+    import "fmul_quad" fmul_quad
+    import "fstp_quad" fstp_quad
+    import "fcom_quad_greater_or_equal" fcom_quad_greater_or_equal
+    import "fsub_quad" fsub_quad
+    import "fadd_quad" fadd_quad
+    import "double_to_int" double_to_int
+    importx "_modf" modf
+    sd value
+    sd value_2
+    sd fl
+    setcall fl l3_sb_fl()
+    add fl (l3_sb_fl_size)
+    set i (SBLIMIT)
+    while i!=0
+        dec i
+        set j 64
+        while j!=0
+            dec j
+            sub fl (DWORD)
+            #
+            set value i
+            mult value 2
+            inc value
+            set value_2 16
+            sub value_2 j
+            mult value value_2
+            call fild_value(value)
+            call fmul_quad(PI64)
+
+		#this is problematic on linux
+		#call fstp_quad(double)
+		#importx "_cos" cos
+		#call cos(double_low,double_high)
+		#small diffs only
+		import "fcos" fcos
+		call fcos()
+
+            call fmul_quad(const1)
+            sd bool
+            setcall bool fcom_quad_greater_or_equal(const4)
+            if bool=1
+                call fadd_quad(const2)
+            else
+                call fsub_quad(const2)
+            endelse
+            call fstp_quad(double)
+            call modf(double_low,double_high,double)
+            call fild_value(0x7fFFffFF)
+            call fmul_quad(const3)
+            call fmul_quad(double)
+            #call fistp(fl)
+            call fstp_quad(double)
+            setcall fl# double_to_int(double)
+            #pop the modf result to clean the fpu stack
+            call fstp_quad(double)
+        endwhile
+    endwhile
+    #
+    import "mp3_tables_enwindow" mp3_tables_enwindow
+    import "slen" slen
+    sd enwindow
+    setcall enwindow mp3_tables_enwindow()
+    sd ew
+    setcall ew l3_sb_ew()
+    set i 0
+    while i<(HAN_SIZE)
+        call str_to_double(enwindow,double)
+        call fld_quad(double)
+        call fild_value(0x7fffffff)
+        call fstp_quad(double)
+        call fmul_quad(double)
+        call fstp_quad(double)
+        setcall ew# double_to_int(double)
+        #
+        inc i
+        add ew (DWORD)
+        addcall enwindow slen(enwindow)
+        inc enwindow
+    endwhile
+endfunction
+
+function l3_sb_off()
+    data off#2
+    data p^off
+    return p
+endfunction
+function l3_sb_off_get(sd index)
+    sd off
+    setcall off l3_sb_off()
+    mult index (DWORD)
+    add off index
+    return off#
+endfunction
+function l3_sb_off_set(sd index,sd value)
+    sd off
+    setcall off l3_sb_off()
+    mult index (DWORD)
+    add off index
+    set off# value
+endfunction
+#
+function l3_sb_x()
+    data x#2*HAN_SIZE
+    data p_x^x
+    return p_x
+endfunction
+function l3_sb_x_set(sd channel,sd index,sd value)
+    sd x
+    setcall x l3_sb_x()
+    mult channel (han_bytes_size)
+    add x channel
+    mult index (DWORD)
+    add x index
+    set x# value
+endfunction
+function l3_sb_x_get(sd channel,sd index)
+    sd x
+    setcall x l3_sb_x()
+    mult channel (han_bytes_size)
+    add x channel
+    mult index (DWORD)
+    add x index
+    return x#
+endfunction
+#
+function l3_sb_z()
+    data z#2*HAN_SIZE
+    data p_z^z
+    return p_z
+endfunction
+function l3_sb_z_get(sd channel,sd index)
+    sd z
+    setcall z l3_sb_z()
+    mult channel (han_bytes_size)
+    add z channel
+    mult index (DWORD)
+    add z index
+    return z#
+endfunction
+#
+function l3_sb_ew()
+    data ew#HAN_SIZE
+    data p^ew
+    return p
+endfunction
+function l3_sb_ew_get(sd index)
+    sd ew
+    setcall ew l3_sb_ew()
+    mult index (DWORD)
+    add ew index
+    return ew#
+endfunction
+#
+function l3_sb_fl()
+    data fl#l3_sb_fl_units
+    data p^fl
+    return p
+endfunction
+#
+
+import "short_get_to_int" short_get_to_int
+import "shl" shl
+import "mult64" mult64
+function l3_window_filter_subband(sd buf,sd l3_sb,sd channel)
+    sd index
+    sd value
+    sd p_value^value
+    sd off
+    setcall off l3_sb_off_get(channel)
+    #replace 32 oldest samples with 32 new samples
+    sd i=31
+    while i>=0
+        setcall value short_get_to_int(buf)
+        add buf (WORD)
+        setcall value shl(value,16)
+        set index i
+        add index off
+        call l3_sb_x_set(channel,index,value)
+        dec i
+    endwhile
+    #shift samples into proper window positions
+    set i (HAN_SIZE)
+    sd z
+    set z channel
+    inc z
+    mult z (han_bytes_size)
+    addcall z l3_sb_z()
+    while i!=0
+        dec i
+        sub z (DWORD)
+        #
+        set index i
+        add index off
+        and index (HAN_SIZE-1)
+        setcall value l3_sb_x_get(channel,index)
+        sd ew
+        setcall ew l3_sb_ew_get(i)
+        call mult64(value,ew,z)
+    endwhile
+    #offset is modulo (HAN_SIZE)
+    add off 480
+    and off (HAN_SIZE-1)
+    call l3_sb_off_set(channel,off)
+    #
+    data y_data#64
+    data y_data_set^y_data
+    sd y^y_data
+    sd j
+    add y (64*DWORD)
+    set i 64
+    while i!=0
+        dec i
+        sub y (DWORD)
+        #
+        set y# 0
+        set j 8
+        while j!=0
+            dec j
+            set index i
+            addcall index shl(j,6)
+            addcall y# l3_sb_z_get(channel,index)
+        endwhile
+    endwhile
+    #
+    sd fl
+    setcall fl l3_sb_fl()
+    add fl (l3_sb_fl_size)
+    set i (SBLIMIT)
+    add l3_sb (SBLIMIT*DWORD)
+    while i!=0
+        dec i
+        sub l3_sb (DWORD)
+        #
+        set l3_sb# 0
+        set j 64
+        set y y_data_set
+        add y (64*DWORD)
+        while j!=0
+            dec j
+            sub y (DWORD)
+            sub fl (DWORD)
+            #
+            call mult64(fl#,y#,p_value)
+            add l3_sb# value
+        endwhile
+    endwhile
+endfunction
--- ovideo-1.orig/src/media/mpeg-mp3_input.s
+++ /dev/null
@@ -1,415 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-import "stage_sound_alloc_getremainingsize" stage_sound_alloc_getremainingsize
-import "stage_sound_sizedone" stage_sound_sizedone
-import "stage_sound_alloc_getbytes" stage_sound_alloc_getbytes
-
-const HAN_SIZE=512
-const han_bytes_size=HAN_SIZE*DWORD
-#get pcm
-
-function mp3_get_pcm(sd buffer)
-    #get the remaining size
-    sd remainingsize
-    setcall remainingsize stage_sound_alloc_getremainingsize()
-    #frame size all the raw size of a channel(samp_per_frame*mp3_bytespersample)
-    sd frame_ch_size
-    setcall frame_ch_size mp3_frame_ch_size()
-    #get size is all the raw size to read
-    sd get_size
-    set get_size frame_ch_size
-    mult get_size (mp3_channels)
-    #can be less remaining size than a frame
-    if get_size>remainingsize
-        set get_size remainingsize
-    endif
-    #get the bytes and add the sizedone
-    sd sizedone
-    sd bytes
-    setcall bytes stage_sound_alloc_getbytes()
-    setcall sizedone stage_sound_sizedone((value_get))
-    add bytes sizedone
-    add sizedone get_size
-    call stage_sound_sizedone((value_set),sizedone)
-    #
-    sd get_ch_size
-    set get_ch_size get_size
-    div get_ch_size (mp3_channels)
-    #raw data to buffer
-    import "cpymem" cpymem
-    sd cursor
-    sd next_channel
-    sd i=0
-    sd cursor_size
-    sd buffer_cursor
-    sd sizeadd
-    while i!=(mp3_channels)
-        set cursor bytes
-        set next_channel i
-        mult next_channel (mp3_bytespersample)
-        add cursor next_channel
-        #
-        set buffer_cursor buffer
-        set sizeadd (buffer_channel_size)
-        mult sizeadd i
-        add buffer_cursor sizeadd
-        #
-        set cursor_size 0
-        while cursor_size!=get_ch_size
-            call cpymem(buffer_cursor,cursor,(mp3_bytespersample))
-            add cursor (mp3_bytespersample*mp3_channels)
-            add buffer_cursor (WORD)
-            add cursor_size (mp3_bytespersample)
-        endwhile
-        inc i
-    endwhile
-    #actions if less than a frame readed
-    #if get_ch_size!=frame_ch_size
-    #    set i 0
-    #    while i!=(mp3_channels)
-    #        set buffer_cursor buffer
-    #        set sizeadd (buffer_channel_size)
-    #        mult sizeadd i
-    #        add buffer_cursor sizeadd
-    #        add buffer_cursor get_ch_size
-            #
-    #        set cursor_size get_ch_size
-    #        while cursor_size!=frame_ch_size
-    #            data silent_data=0
-    #            data p_silent_data^silent_data
-    #            call cpymem(buffer_cursor,p_silent_data,(mp3_bytespersample))
-    #            add buffer_cursor (WORD)
-    #            add cursor_size (mp3_bytespersample)
-    #        endwhile
-    #        inc i
-    #    endwhile
-    #endif
-endfunction
-
-#bool
-function mp3_encode_test()
-    sd sz
-    setcall sz stage_sound_alloc_getremainingsize()
-    sd frame_ch_size
-    setcall frame_ch_size mp3_frame_ch_size()
-    sub sz frame_ch_size
-    if sz<0
-        return 0
-    endif
-    return 1
-endfunction
-
-#frame_ch_size
-function mp3_frame_ch_size()
-    sd frame_ch_size=samp_per_frame
-    mult frame_ch_size (mp3_bytespersample)
-    return frame_ch_size
-endfunction
-
-#subband
-
-const l3_sb_fl_units=SBLIMIT*64
-const l3_sb_fl_size=l3_sb_fl_units*DWORD
-function l3_subband_init()
-    call l3_sb_off_set(0,0)
-    call l3_sb_off_set(1,0)
-    #
-    sd x
-    setcall x l3_sb_x()
-    sd i=0
-    sd j
-    while i!=2
-        set j 0
-        while j!=(HAN_SIZE)
-            set x# 0
-            add x (DWORD)
-            inc j
-        endwhile
-        inc i
-    endwhile
-    #
-    import "str_to_double" str_to_double
-    import "double_mult" double_mult
-    data double_low#1
-    data double_high#1
-    data double^double_low
-    data PI64_low#1
-    data *PI64_high#1
-    data PI64^PI64_low
-    str PI64_str="0.049087385212"
-    call str_to_double(PI64_str,PI64)
-    data const1_low#1
-    data *const1_high#1
-    data const1^const1_low
-    str const1_str="1e9"
-    call str_to_double(const1_str,const1)
-    data const2_low#1
-    data *const2_high#1
-    data const2^const2_low
-    str const2_str="0.5"
-    call str_to_double(const2_str,const2)
-    data const3_low#1
-    data *const3_high#1
-    data const3^const3_low
-    str const3_str="1e-9"
-    call str_to_double(const3_str,const3)
-    data const4_low#1
-    data *const4_high#1
-    data const4^const4_low
-    str const4_str="0"
-    call str_to_double(const4_str,const4)
-    #
-    call double_mult(const4,const3)
-    import "fld_quad" fld_quad
-    import "fild_value" fild_value
-    import "fmul_quad" fmul_quad
-    import "fstp_quad" fstp_quad
-    import "fcom_quad_greater_or_equal" fcom_quad_greater_or_equal
-    import "fsub_quad" fsub_quad
-    import "fadd_quad" fadd_quad
-    import "double_to_int" double_to_int
-    importx "_modf" modf
-    sd value
-    sd value_2
-    sd fl
-    setcall fl l3_sb_fl()
-    add fl (l3_sb_fl_size)
-    set i (SBLIMIT)
-    while i!=0
-        dec i
-        set j 64
-        while j!=0
-            dec j
-            sub fl (DWORD)
-            #
-            set value i
-            mult value 2
-            inc value
-            set value_2 16
-            sub value_2 j
-            mult value value_2
-            call fild_value(value)
-            call fmul_quad(PI64)
-
-		#this is problematic on linux
-		#call fstp_quad(double)
-		#importx "_cos" cos
-		#call cos(double_low,double_high)
-		#small diffs only
-		import "fcos" fcos
-		call fcos()
-
-            call fmul_quad(const1)
-            sd bool
-            setcall bool fcom_quad_greater_or_equal(const4)
-            if bool==1
-                call fadd_quad(const2)
-            else
-                call fsub_quad(const2)
-            endelse
-            call fstp_quad(double)
-            call modf(double_low,double_high,double)
-            call fild_value(0x7fFFffFF)
-            call fmul_quad(const3)
-            call fmul_quad(double)
-            #call fistp(fl)
-            call fstp_quad(double)
-            setcall fl# double_to_int(double)
-            #pop the modf result to clean the fpu stack
-            call fstp_quad(double)
-        endwhile
-    endwhile
-    #
-    import "mp3_tables_enwindow" mp3_tables_enwindow
-    import "slen" slen
-    sd enwindow
-    setcall enwindow mp3_tables_enwindow()
-    sd ew
-    setcall ew l3_sb_ew()
-    set i 0
-    while i<(HAN_SIZE)
-        call str_to_double(enwindow,double)
-        call fld_quad(double)
-        call fild_value(0x7fffffff)
-        call fstp_quad(double)
-        call fmul_quad(double)
-        call fstp_quad(double)
-        setcall ew# double_to_int(double)
-        #
-        inc i
-        add ew (DWORD)
-        addcall enwindow slen(enwindow)
-        inc enwindow
-    endwhile
-endfunction
-
-function l3_sb_off()
-    data off#2
-    data p^off
-    return p
-endfunction
-function l3_sb_off_get(sd index)
-    sd off
-    setcall off l3_sb_off()
-    mult index (DWORD)
-    add off index
-    return off#
-endfunction
-function l3_sb_off_set(sd index,sd value)
-    sd off
-    setcall off l3_sb_off()
-    mult index (DWORD)
-    add off index
-    set off# value
-endfunction
-#
-function l3_sb_x()
-    data x#2*HAN_SIZE
-    data p_x^x
-    return p_x
-endfunction
-function l3_sb_x_set(sd channel,sd index,sd value)
-    sd x
-    setcall x l3_sb_x()
-    mult channel (han_bytes_size)
-    add x channel
-    mult index (DWORD)
-    add x index
-    set x# value
-endfunction
-function l3_sb_x_get(sd channel,sd index)
-    sd x
-    setcall x l3_sb_x()
-    mult channel (han_bytes_size)
-    add x channel
-    mult index (DWORD)
-    add x index
-    return x#
-endfunction
-#
-function l3_sb_z()
-    data z#2*HAN_SIZE
-    data p_z^z
-    return p_z
-endfunction
-function l3_sb_z_get(sd channel,sd index)
-    sd z
-    setcall z l3_sb_z()
-    mult channel (han_bytes_size)
-    add z channel
-    mult index (DWORD)
-    add z index
-    return z#
-endfunction
-#
-function l3_sb_ew()
-    data ew#HAN_SIZE
-    data p^ew
-    return p
-endfunction
-function l3_sb_ew_get(sd index)
-    sd ew
-    setcall ew l3_sb_ew()
-    mult index (DWORD)
-    add ew index
-    return ew#
-endfunction
-#
-function l3_sb_fl()
-    data fl#l3_sb_fl_units
-    data p^fl
-    return p
-endfunction
-#
-
-import "short_get_to_int" short_get_to_int
-import "shl" shl
-import "mult64" mult64
-function l3_window_filter_subband(sd buf,sd l3_sb,sd channel)
-    sd index
-    sd value
-    sd p_value^value
-    sd off
-    setcall off l3_sb_off_get(channel)
-    #replace 32 oldest samples with 32 new samples
-    sd i=31
-    while i>=0
-        setcall value short_get_to_int(buf)
-        add buf (WORD)
-        setcall value shl(value,16)
-        set index i
-        add index off
-        call l3_sb_x_set(channel,index,value)
-        dec i
-    endwhile
-    #shift samples into proper window positions
-    set i (HAN_SIZE)
-    sd z
-    set z channel
-    inc z
-    mult z (han_bytes_size)
-    addcall z l3_sb_z()
-    while i!=0
-        dec i
-        sub z (DWORD)
-        #
-        set index i
-        add index off
-        and index (HAN_SIZE-1)
-        setcall value l3_sb_x_get(channel,index)
-        sd ew
-        setcall ew l3_sb_ew_get(i)
-        call mult64(value,ew,z)
-    endwhile
-    #offset is modulo (HAN_SIZE)
-    add off 480
-    and off (HAN_SIZE-1)
-    call l3_sb_off_set(channel,off)
-    #
-    data y_data#64
-    data y_data_set^y_data
-    sd y^y_data
-    sd j
-    add y (64*DWORD)
-    set i 64
-    while i!=0
-        dec i
-        sub y (DWORD)
-        #
-        set y# 0
-        set j 8
-        while j!=0
-            dec j
-            set index i
-            addcall index shl(j,6)
-            addcall y# l3_sb_z_get(channel,index)
-        endwhile
-    endwhile
-    #
-    sd fl
-    setcall fl l3_sb_fl()
-    add fl (l3_sb_fl_size)
-    set i (SBLIMIT)
-    add l3_sb (SBLIMIT*DWORD)
-    while i!=0
-        dec i
-        sub l3_sb (DWORD)
-        #
-        set l3_sb# 0
-        set j 64
-        set y y_data_set
-        add y (64*DWORD)
-        while j!=0
-            dec j
-            sub y (DWORD)
-            sub fl (DWORD)
-            #
-            call mult64(fl#,y#,p_value)
-            add l3_sb# value
-        endwhile
-    endwhile
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-mp3_iteration.oc
@@ -0,0 +1,299 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+import "mp3_gr_info" mp3_gr_info
+import "mp3_gr_info_itemSet" mp3_gr_info_itemSet
+import "mp3_gr_info_itemGet" mp3_gr_info_itemGet
+import "l3_enc" l3_enc
+import "mp3_xrabs" mp3_xrabs
+import "mult64_highint_rounded" mult64_highint_rounded
+
+function mp3_iteration(sd mdct_freq,sd mean_bits)
+    sd ResvSize=0
+    sd ResvMax=0
+    sd xr
+    sd channel=mp3_channels
+    while channel>0
+        dec channel
+        set xr (mdct_freq_channel_size)
+        mult xr channel
+        add xr mdct_freq
+        sd granule=0
+        while granule<2
+            #abs,  and maximum
+            sd xrmax=0
+            sd i=samp_per_frame2
+            sd xrabs
+            setcall xrabs mp3_xrabs()
+            #sd xrsq
+            #setcall xrsq mp3_xrsq()
+            add xrabs (samp_per_frame2*DWORD)
+            #add xrsq (samp_per_frame2*DWORD)
+            add xr (samp_per_frame2*DWORD)
+            while i!=0
+                dec i
+                sub xrabs (DWORD)
+                #sub xrsq (DWORD)
+                sub xr (DWORD)
+                #
+                #setcall xrsq# mult64_highint_rounded(xr#,xr#)
+                #
+                set xrabs# xr#
+                if xrabs#<0
+                    mult xrabs# -1
+                endif
+                if xrabs#>xrmax
+                    set xrmax xrabs#
+                endif
+            endwhile
+            import "mp3_xrmax_set" mp3_xrmax_set
+            call mp3_xrmax_set(xrmax)
+            #
+            sd l3enc_tt
+            setcall l3enc_tt l3_enc(granule,channel)
+            sd gr_info
+            setcall gr_info mp3_gr_info(granule,channel)
+            #
+            sd max_bits
+            setcall max_bits mp3_ResvMaxBits(mean_bits)
+            #
+            import "setmemzero" setmemzero
+            call setmemzero(gr_info,(gr_info_channelSize))
+            #
+            if xrmax!=0
+                sd part2_3_length
+                setcall part2_3_length mp3_outer_loop(l3enc_tt,gr_info,max_bits)
+                call mp3_gr_info_itemSet(gr_info,(gr_info_part2_3_length),part2_3_length)
+            endif
+            #
+            sd value
+            set value mean_bits
+            div value (mp3_channels)
+            subcall value mp3_gr_info_itemGet(gr_info,(gr_info_part2_3_length))
+            add ResvSize value
+            #
+            sd quantizerStepSize
+            setcall quantizerStepSize mp3_gr_info_itemGet(gr_info,(gr_info_quantizerStepSize))
+            add quantizerStepSize 210
+            call mp3_gr_info_itemSet(gr_info,(gr_info_global_gain),quantizerStepSize)
+            #
+            add xr (mdct_freq_granule_size)
+            inc granule
+        endwhile
+    endwhile
+    call mp3_ResvFrameEnd(ResvSize,ResvMax,mean_bits)
+endfunction
+
+#from main here
+#max_bits
+function mp3_ResvMaxBits(sd mean_bits)
+    sd max_bits
+    div mean_bits (mp3_channels)
+    set max_bits mean_bits
+    if max_bits>4095
+        set max_bits 4095
+    endif
+    return max_bits
+endfunction
+
+#from main here
+#bits
+function mp3_outer_loop(sd l3enc_tt,sd gr_info,sd max_bits)
+    call mp3_search_StepSize(l3enc_tt,gr_info,max_bits)
+    sd value
+    setcall value mp3_inner_loop(l3enc_tt,gr_info,max_bits)
+    return value
+endfunction
+
+function mp3_ResvFrameEnd(sd ResvSize,sd ResvMax,sd mean_bits)
+    #just in case mean_bits is odd, this is necessary...
+    sd value
+    if (mp3_channels)=2
+        set value mean_bits
+        and value 1
+        if value!=0
+            inc ResvSize
+        endif
+    endif
+    sd over_bits
+    set over_bits ResvSize
+    sub over_bits ResvMax
+    if over_bits<0
+        set over_bits 0
+    endif
+    sub ResvSize over_bits
+    sd ancillary_pad=0
+    sd stuffingBits
+    set stuffingBits over_bits
+    add stuffingBits ancillary_pad
+    if stuffingBits!=0
+        sd gr_info
+        setcall gr_info mp3_gr_info(0,0)
+        sd part2_3_length
+        setcall part2_3_length mp3_gr_info_itemGet(gr_info,(gr_info_part2_3_length))
+        add part2_3_length stuffingBits
+        call mp3_gr_info_itemSet(gr_info,(gr_info_part2_3_length),part2_3_length)
+    endif
+endfunction
+
+import "mp3_iteration_code" mp3_iteration_code
+import "sar32" sar
+
+#from outer_loop
+
+function mp3_search_StepSize(sd l3enc_tt,sd gr_info,sd desired_rate)
+    sd top=-120
+    sd next
+    sd last
+    sd bot=0
+    sd value
+    sd bit
+
+    set next top
+    sd loop=1
+    while loop=1
+        set last next
+        set next top
+        add next bot
+        setcall next sar(next,1)
+        setcall value mp3_quantize(l3enc_tt,next)
+        if value>8192
+            #fail
+            set bit 100000
+        else
+            setcall bit mp3_iteration_code(l3enc_tt,gr_info)
+        endelse
+        if bit>desired_rate
+            set top next
+        else
+            set bot next
+        endelse
+        set loop 0
+        if bit!=desired_rate
+            set value last
+            sub value next
+            if value<0
+                mult value -1
+            endif
+            if value>1
+                set loop 1
+            endif
+        endif
+    endwhile
+    call mp3_gr_info_itemSet(gr_info,(gr_info_quantizerStepSize),next)
+endfunction
+
+import "mp3_steptabi_get" mp3_steptabi_get
+import "mp3_int2idx_get" mp3_int2idx_get
+
+#near mp3_iteration_code
+
+#maximum value of l3enc_tt
+function mp3_quantize(sd l3enc_tt,sd stepsize)
+    sd i=127
+    add i stepsize
+    sd scalei
+    setcall scalei mp3_steptabi_get(i)
+    sd value
+    #a quick check to see if max will be less than 8192
+    #  this speeds up the early calls to mp3_search_StepSize
+    import "mp3_xrmax_get" mp3_xrmax_get
+    sd xrmax
+    setcall xrmax mp3_xrmax_get()
+    setcall value mult64_highint_rounded(xrmax,scalei)
+    if value>165140
+        #no point in continuing, stepsize not big enough
+        return 16384
+    endif
+    sd ln
+    sd max=0
+    set i 0
+    while i<(samp_per_frame2)
+        import "mp3_xrabs_get" mp3_xrabs_get
+        sd abs_value
+        setcall abs_value mp3_xrabs_get(i)
+        setcall ln mult64_highint_rounded(abs_value,scalei)
+        if ln<10000
+            setcall l3enc_tt# mp3_int2idx_get(ln)
+        else
+            #outside table range so have to do it using floats
+            import "mp3_steptab_double_get_p" mp3_steptab_double_get_p
+            set value stepsize
+            add value 127
+            sd scale
+            setcall scale mp3_steptab_double_get_p(value)
+            import "fmul_quad" fmul_quad
+            import "fild_value" fild_value
+            import "fstp_quad" fstp_quad
+            importx "_sqrt" sqrt
+            import "double_to_int" double_to_int
+            call fild_value(abs_value)
+            call fmul_quad(scale)
+            setcall value mp3_quantize_const1()
+            call fmul_quad(value)
+            data double_low#1
+            data double_high#1
+            data double^double_low
+            call fstp_quad(double)
+            call sqrt(double_low,double_high)
+            call fmul_quad(double)
+            call fstp_quad(double)
+            call sqrt(double_low,double_high)
+            call fstp_quad(double)
+            setcall l3enc_tt# double_to_int(double)
+        endelse
+        #
+        if max<l3enc_tt#
+            set max l3enc_tt#
+        endif
+        #
+        add l3enc_tt (DWORD)
+        inc i
+    endwhile
+    return max
+endfunction
+function mp3_quantize_const1()
+    data double#2
+    data p^double
+    return p
+endfunction
+function mp3_quantize_init()
+    sd c1
+    setcall c1 mp3_quantize_const1()
+    import "str_to_double" str_to_double
+    str s1="4.656612875e-10"
+    call str_to_double(s1,c1)
+endfunction
+
+#from mp3_outer_loop
+#bits
+function mp3_inner_loop(sd l3enc_tt,sd gr_info,sd max_bits)
+    sd quantizerStepSize
+    setcall quantizerStepSize mp3_gr_info_itemGet(gr_info,(gr_info_quantizerStepSize))
+    if max_bits<0
+        dec quantizerStepSize
+        call mp3_gr_info_itemSet(gr_info,(gr_info_quantizerStepSize),quantizerStepSize)
+    endif
+    sd loop=1
+    while loop=1
+        sd value=8192+1
+        while value>8192
+            setcall quantizerStepSize mp3_gr_info_itemGet(gr_info,(gr_info_quantizerStepSize))
+            inc quantizerStepSize
+            call mp3_gr_info_itemSet(gr_info,(gr_info_quantizerStepSize),quantizerStepSize)
+            setcall value mp3_quantize(l3enc_tt,quantizerStepSize)
+        endwhile
+        sd bits
+        setcall bits mp3_iteration_code(l3enc_tt,gr_info)
+        if bits<=max_bits
+            set loop 0
+        endif
+    endwhile
+    return bits
+endfunction
+
+
--- ovideo-1.orig/src/media/mpeg-mp3_iteration.s
+++ /dev/null
@@ -1,299 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-import "mp3_gr_info" mp3_gr_info
-import "mp3_gr_info_itemSet" mp3_gr_info_itemSet
-import "mp3_gr_info_itemGet" mp3_gr_info_itemGet
-import "l3_enc" l3_enc
-import "mp3_xrabs" mp3_xrabs
-import "mult64_highint_rounded" mult64_highint_rounded
-
-function mp3_iteration(sd mdct_freq,sd mean_bits)
-    sd ResvSize=0
-    sd ResvMax=0
-    sd xr
-    sd channel=mp3_channels
-    while channel>0
-        dec channel
-        set xr (mdct_freq_channel_size)
-        mult xr channel
-        add xr mdct_freq
-        sd granule=0
-        while granule<2
-            #abs,  and maximum
-            sd xrmax=0
-            sd i=samp_per_frame2
-            sd xrabs
-            setcall xrabs mp3_xrabs()
-            #sd xrsq
-            #setcall xrsq mp3_xrsq()
-            add xrabs (samp_per_frame2*DWORD)
-            #add xrsq (samp_per_frame2*DWORD)
-            add xr (samp_per_frame2*DWORD)
-            while i!=0
-                dec i
-                sub xrabs (DWORD)
-                #sub xrsq (DWORD)
-                sub xr (DWORD)
-                #
-                #setcall xrsq# mult64_highint_rounded(xr#,xr#)
-                #
-                set xrabs# xr#
-                if xrabs#<0
-                    mult xrabs# -1
-                endif
-                if xrabs#>xrmax
-                    set xrmax xrabs#
-                endif
-            endwhile
-            import "mp3_xrmax_set" mp3_xrmax_set
-            call mp3_xrmax_set(xrmax)
-            #
-            sd l3enc_tt
-            setcall l3enc_tt l3_enc(granule,channel)
-            sd gr_info
-            setcall gr_info mp3_gr_info(granule,channel)
-            #
-            sd max_bits
-            setcall max_bits mp3_ResvMaxBits(mean_bits)
-            #
-            import "setmemzero" setmemzero
-            call setmemzero(gr_info,(gr_info_channelSize))
-            #
-            if xrmax!=0
-                sd part2_3_length
-                setcall part2_3_length mp3_outer_loop(l3enc_tt,gr_info,max_bits)
-                call mp3_gr_info_itemSet(gr_info,(gr_info_part2_3_length),part2_3_length)
-            endif
-            #
-            sd value
-            set value mean_bits
-            div value (mp3_channels)
-            subcall value mp3_gr_info_itemGet(gr_info,(gr_info_part2_3_length))
-            add ResvSize value
-            #
-            sd quantizerStepSize
-            setcall quantizerStepSize mp3_gr_info_itemGet(gr_info,(gr_info_quantizerStepSize))
-            add quantizerStepSize 210
-            call mp3_gr_info_itemSet(gr_info,(gr_info_global_gain),quantizerStepSize)
-            #
-            add xr (mdct_freq_granule_size)
-            inc granule
-        endwhile
-    endwhile
-    call mp3_ResvFrameEnd(ResvSize,ResvMax,mean_bits)
-endfunction
-
-#from main here
-#max_bits
-function mp3_ResvMaxBits(sd mean_bits)
-    sd max_bits
-    div mean_bits (mp3_channels)
-    set max_bits mean_bits
-    if max_bits>4095
-        set max_bits 4095
-    endif
-    return max_bits
-endfunction
-
-#from main here
-#bits
-function mp3_outer_loop(sd l3enc_tt,sd gr_info,sd max_bits)
-    call mp3_search_StepSize(l3enc_tt,gr_info,max_bits)
-    sd value
-    setcall value mp3_inner_loop(l3enc_tt,gr_info,max_bits)
-    return value
-endfunction
-
-function mp3_ResvFrameEnd(sd ResvSize,sd ResvMax,sd mean_bits)
-    #just in case mean_bits is odd, this is necessary...
-    sd value
-    if (mp3_channels)==2
-        set value mean_bits
-        and value 1
-        if value!=0
-            inc ResvSize
-        endif
-    endif
-    sd over_bits
-    set over_bits ResvSize
-    sub over_bits ResvMax
-    if over_bits<0
-        set over_bits 0
-    endif
-    sub ResvSize over_bits
-    sd ancillary_pad=0
-    sd stuffingBits
-    set stuffingBits over_bits
-    add stuffingBits ancillary_pad
-    if stuffingBits!=0
-        sd gr_info
-        setcall gr_info mp3_gr_info(0,0)
-        sd part2_3_length
-        setcall part2_3_length mp3_gr_info_itemGet(gr_info,(gr_info_part2_3_length))
-        add part2_3_length stuffingBits
-        call mp3_gr_info_itemSet(gr_info,(gr_info_part2_3_length),part2_3_length)
-    endif
-endfunction
-
-import "mp3_iteration_code" mp3_iteration_code
-import "sar32" sar
-
-#from outer_loop
-
-function mp3_search_StepSize(sd l3enc_tt,sd gr_info,sd desired_rate)
-    sd top=-120
-    sd next
-    sd last
-    sd bot=0
-    sd value
-    sd bit
-
-    set next top
-    sd loop=1
-    while loop==1
-        set last next
-        set next top
-        add next bot
-        setcall next sar(next,1)
-        setcall value mp3_quantize(l3enc_tt,next)
-        if value>8192
-            #fail
-            set bit 100000
-        else
-            setcall bit mp3_iteration_code(l3enc_tt,gr_info)
-        endelse
-        if bit>desired_rate
-            set top next
-        else
-            set bot next
-        endelse
-        set loop 0
-        if bit!=desired_rate
-            set value last
-            sub value next
-            if value<0
-                mult value -1
-            endif
-            if value>1
-                set loop 1
-            endif
-        endif
-    endwhile
-    call mp3_gr_info_itemSet(gr_info,(gr_info_quantizerStepSize),next)
-endfunction
-
-import "mp3_steptabi_get" mp3_steptabi_get
-import "mp3_int2idx_get" mp3_int2idx_get
-
-#near mp3_iteration_code
-
-#maximum value of l3enc_tt
-function mp3_quantize(sd l3enc_tt,sd stepsize)
-    sd i=127
-    add i stepsize
-    sd scalei
-    setcall scalei mp3_steptabi_get(i)
-    sd value
-    #a quick check to see if max will be less than 8192
-    #  this speeds up the early calls to mp3_search_StepSize
-    import "mp3_xrmax_get" mp3_xrmax_get
-    sd xrmax
-    setcall xrmax mp3_xrmax_get()
-    setcall value mult64_highint_rounded(xrmax,scalei)
-    if value>165140
-        #no point in continuing, stepsize not big enough
-        return 16384
-    endif
-    sd ln
-    sd max=0
-    set i 0
-    while i<(samp_per_frame2)
-        import "mp3_xrabs_get" mp3_xrabs_get
-        sd abs_value
-        setcall abs_value mp3_xrabs_get(i)
-        setcall ln mult64_highint_rounded(abs_value,scalei)
-        if ln<10000
-            setcall l3enc_tt# mp3_int2idx_get(ln)
-        else
-            #outside table range so have to do it using floats
-            import "mp3_steptab_double_get_p" mp3_steptab_double_get_p
-            set value stepsize
-            add value 127
-            sd scale
-            setcall scale mp3_steptab_double_get_p(value)
-            import "fmul_quad" fmul_quad
-            import "fild_value" fild_value
-            import "fstp_quad" fstp_quad
-            importx "_sqrt" sqrt
-            import "double_to_int" double_to_int
-            call fild_value(abs_value)
-            call fmul_quad(scale)
-            setcall value mp3_quantize_const1()
-            call fmul_quad(value)
-            data double_low#1
-            data double_high#1
-            data double^double_low
-            call fstp_quad(double)
-            call sqrt(double_low,double_high)
-            call fmul_quad(double)
-            call fstp_quad(double)
-            call sqrt(double_low,double_high)
-            call fstp_quad(double)
-            setcall l3enc_tt# double_to_int(double)
-        endelse
-        #
-        if max<l3enc_tt#
-            set max l3enc_tt#
-        endif
-        #
-        add l3enc_tt (DWORD)
-        inc i
-    endwhile
-    return max
-endfunction
-function mp3_quantize_const1()
-    data double#2
-    data p^double
-    return p
-endfunction
-function mp3_quantize_init()
-    sd c1
-    setcall c1 mp3_quantize_const1()
-    import "str_to_double" str_to_double
-    str s1="4.656612875e-10"
-    call str_to_double(s1,c1)
-endfunction
-
-#from mp3_outer_loop
-#bits
-function mp3_inner_loop(sd l3enc_tt,sd gr_info,sd max_bits)
-    sd quantizerStepSize
-    setcall quantizerStepSize mp3_gr_info_itemGet(gr_info,(gr_info_quantizerStepSize))
-    if max_bits<0
-        dec quantizerStepSize
-        call mp3_gr_info_itemSet(gr_info,(gr_info_quantizerStepSize),quantizerStepSize)
-    endif
-    sd loop=1
-    while loop==1
-        sd value=8192+1
-        while value>8192
-            setcall quantizerStepSize mp3_gr_info_itemGet(gr_info,(gr_info_quantizerStepSize))
-            inc quantizerStepSize
-            call mp3_gr_info_itemSet(gr_info,(gr_info_quantizerStepSize),quantizerStepSize)
-            setcall value mp3_quantize(l3enc_tt,quantizerStepSize)
-        endwhile
-        sd bits
-        setcall bits mp3_iteration_code(l3enc_tt,gr_info)
-        if bits<=max_bits
-            set loop 0
-        endif
-    endwhile
-    return bits
-endfunction
-
-
--- /dev/null
+++ ovideo-1/src/media/mpeg-mp3_iteration_code.oc
@@ -0,0 +1,474 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+import "mp3_gr_info_itemSet" mp3_gr_info_itemSet
+
+#bits
+function mp3_iteration_code(sd l3enc_tt,sd gr_info)
+    data addresses#3
+    data p_addresses^addresses
+    data table_select_0#1
+    data table_select_1#1
+    data table_select_2#1
+    data p_table_select^table_select_0
+    sd bits
+    #
+    call mp3_calc_runlen(l3enc_tt,gr_info)
+    setcall bits count1_bitcount(l3enc_tt,gr_info)
+    call subdivide(gr_info,p_addresses)
+    call bigv_tab_select(l3enc_tt,gr_info,p_addresses,p_table_select)
+    addcall bits bigv_bitcount(l3enc_tt,p_addresses,p_table_select)
+    #
+    call mp3_gr_info_itemSet(gr_info,(gr_info_table_select_0),table_select_0)
+    call mp3_gr_info_itemSet(gr_info,(gr_info_table_select_1),table_select_1)
+    call mp3_gr_info_itemSet(gr_info,(gr_info_table_select_2),table_select_2)
+
+    return bits
+endfunction
+#######
+import "l3_enc_sample_get" l3_enc_sample_get
+import "mp3_gr_info_itemGet" mp3_gr_info_itemGet
+function mp3_calc_runlen(sd l3enc_tt,sd gr_info)
+    sd i=samp_per_frame2
+    #int rzero = 0;
+    sd value
+    sd loop=1
+    while loop=1
+        set loop 0
+        if i>1
+            set value i
+            sub value 1
+            setcall value l3_enc_sample_get(l3enc_tt,value)
+            if value=0
+                set value i
+                sub value 2
+                setcall value l3_enc_sample_get(l3enc_tt,value)
+                if value=0
+                    #rzero++
+                    sub i 2
+                    set loop 1
+                endif
+            endif
+        endif
+    endwhile
+    sd index
+    call mp3_gr_info_itemSet(gr_info,(gr_info_count1),0)
+    set loop 1
+    while loop=1
+        set loop 0
+        if i>3
+            set index i
+            #-1
+            dec index
+            setcall value l3_enc_sample_get(l3enc_tt,index)
+            if value<=1
+                #-2
+                dec index
+                setcall value l3_enc_sample_get(l3enc_tt,index)
+                if value<=1
+                    #-3
+                    dec index
+                    setcall value l3_enc_sample_get(l3enc_tt,index)
+                    if value<=1
+                        #-4
+                        dec index
+                        setcall value l3_enc_sample_get(l3enc_tt,index)
+                        if value<=1
+                            sd count1
+                            setcall count1 mp3_gr_info_itemGet(gr_info,(gr_info_count1))
+                            inc count1
+                            call mp3_gr_info_itemSet(gr_info,(gr_info_count1),count1)
+                            #
+                            sub i 4
+                            set loop 1
+                        endif
+                    endif
+                endif
+            endif
+        endif
+    endwhile
+    import "sar32" sar
+    setcall i sar(i,1)
+    call mp3_gr_info_itemSet(gr_info,(gr_info_big_values),i)
+endfunction
+#bits
+function count1_bitcount(sd l3enc_tt,sd gr_info)
+    sd sum0=0
+    sd sum1=0
+    sd v
+    sd w
+    sd x
+    sd y
+    sd p
+    sd i
+    setcall i mp3_gr_info_itemGet(gr_info,(gr_info_big_values))
+    import "shl" shl
+    setcall i shl(i,1)
+    sd k=0
+    sd count1
+    setcall count1 mp3_gr_info_itemGet(gr_info,(gr_info_count1))
+    while k<count1
+        setcall v l3_enc_sample_get(l3enc_tt,i)
+        inc i
+        setcall w l3_enc_sample_get(l3enc_tt,i)
+        inc i
+        setcall x l3_enc_sample_get(l3enc_tt,i)
+        inc i
+        setcall y l3_enc_sample_get(l3enc_tt,i)
+        inc i
+
+        set p v
+        addcall p shl(w,1)
+        addcall p shl(x,2)
+        addcall p shl(y,3)
+
+        sd signbits=0
+        if v!=0
+            inc signbits
+        endif
+        if w!=0
+            inc signbits
+        endif
+        if x!=0
+            inc signbits
+        endif
+        if y!=0
+            inc signbits
+        endif
+
+        add sum0 signbits
+        add sum1 signbits
+        import "huffman_hlen" huffman_hlen
+        addcall sum0 huffman_hlen(32,p)
+        addcall sum1 huffman_hlen(33,p)
+
+        inc k
+    endwhile
+    if sum0<sum1
+        call mp3_gr_info_itemSet(gr_info,(gr_info_count1table_select),0)
+        return sum0
+    endif
+    call mp3_gr_info_itemSet(gr_info,(gr_info_count1table_select),1)
+    return sum1
+endfunction
+import "scalefac_band_long" scalefac_band_long
+import "subdv_table" subdv_table
+function subdivide(sd gr_info,sd p_addresses)
+    sd big_values
+    setcall big_values mp3_gr_info_itemGet(gr_info,(gr_info_big_values))
+    sd bigvalues_region
+    sd scfb_anz=0
+    set bigvalues_region big_values
+    mult bigvalues_region 2
+    sd scalefac_band
+    setcall scalefac_band scalefac_band_long()
+    while scalefac_band#<bigvalues_region
+        inc scfb_anz
+        add scalefac_band (DWORD)
+    endwhile
+    #
+    sd region0_count
+    setcall region0_count subdv_table(scfb_anz,0)
+    sd thiscount
+    sd index
+    set thiscount region0_count
+    set index thiscount
+    inc index
+    setcall scalefac_band scalefac_band_long()
+    sd sizeadd=DWORD
+    mult sizeadd index
+    add scalefac_band sizeadd
+    sd loop=1
+    while loop=1
+        set loop 0
+        if thiscount!=0
+            if scalefac_band#>bigvalues_region
+                dec thiscount
+                dec index
+                sub scalefac_band (DWORD)
+                set loop 1
+            endif
+        endif
+    endwhile
+    set region0_count thiscount
+    call mp3_gr_info_itemSet(gr_info,(gr_info_region0_count),region0_count)
+    #
+    sd region1_count
+    setcall region1_count subdv_table(scfb_anz,1)
+    set thiscount region1_count
+    set index region0_count
+    add index region1_count
+    add index 2
+    setcall scalefac_band scalefac_band_long()
+    set sizeadd (DWORD)
+    mult sizeadd index
+    add scalefac_band sizeadd
+    set loop 1
+    while loop=1
+        set loop 0
+        if thiscount!=0
+            if scalefac_band#>bigvalues_region
+                dec thiscount
+                dec index
+                sub scalefac_band (DWORD)
+                set loop 1
+            endif
+        endif
+    endwhile
+    set region1_count thiscount
+    call mp3_gr_info_itemSet(gr_info,(gr_info_region1_count),region1_count)
+    #
+    import "scalefac_band_long_get" scalefac_band_long_get
+    set index region0_count
+    inc index
+    setcall p_addresses# scalefac_band_long_get(index)
+    #
+    add p_addresses (DWORD)
+    set index region0_count
+    add index region1_count
+    add index 2
+    setcall p_addresses# scalefac_band_long_get(index)
+    #
+    add p_addresses (DWORD)
+    set p_addresses# bigvalues_region
+endfunction
+function bigv_tab_select(sd l3enc_tt,sd gr_info,sd p_addresses,sd p_table_select)
+    #Select huffman code tables for bigvalues regions
+    sd address_1
+    sd address_2
+    sd big_values
+    set address_1 p_addresses#
+    add p_addresses (DWORD)
+    set address_2 p_addresses#
+    setcall big_values mp3_gr_info_itemGet(gr_info,(gr_info_big_values))
+    #
+    set p_table_select# 0
+    if address_1>0
+        setcall p_table_select# mp3_choose_table(l3enc_tt,0,address_1)
+    endif
+    add p_table_select (DWORD)
+    set p_table_select# 0
+    if address_2>address_1
+        setcall p_table_select# mp3_choose_table(l3enc_tt,address_1,address_2)
+    endif
+    add p_table_select (DWORD)
+    set p_table_select# 0
+    mult big_values 2
+    if big_values>address_2
+        setcall p_table_select# mp3_choose_table(l3enc_tt,address_2,big_values)
+    endif
+endfunction
+#bits
+function bigv_bitcount(sd l3enc_tt,sd p_addresses,sd p_table_select)
+    sd bits=0
+    sd table
+    sd addr_1
+    sd addr_2
+    sd addr_3
+    set table p_table_select#
+    set addr_1 p_addresses#
+    if table!=0
+        addcall bits mp3_count_bit(l3enc_tt,0,addr_1,table)
+    endif
+    add p_table_select (DWORD)
+    add p_addresses (DWORD)
+    set table p_table_select#
+    set addr_2 p_addresses#
+    if table!=0
+        addcall bits mp3_count_bit(l3enc_tt,addr_1,addr_2,table)
+    endif
+    add p_table_select (DWORD)
+    add p_addresses (DWORD)
+    set table p_table_select#
+    set addr_3 p_addresses#
+    if table!=0
+        addcall bits mp3_count_bit(l3enc_tt,addr_2,addr_3,table)
+    endif
+    return bits
+endfunction
+#########
+
+import "huffman_tabs" huffman_tabs
+#table_select
+function mp3_choose_table(sd l3enc_tt,sd start,sd end)
+    sd max
+    setcall max mp3_int_max(l3enc_tt,start,end)
+    if max=0
+        return 0
+    endif
+    sd i
+    sd value
+    sd choice_0=0
+    sd choice_1=0
+    sd sum_0
+    sd sum_1
+    if max<15
+        set i 14
+        while i!=0
+            dec i
+            setcall value huffman_tabs(i,(huffman_xlen))
+            if value>max
+                set choice_0 i
+                set i 0
+            endif
+        endwhile
+        setcall sum_0 mp3_count_bit(l3enc_tt,start,end,choice_0)
+        if choice_0=2
+            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,3)
+            if sum_1<=sum_0
+                set choice_0 3
+            endif
+        elseif choice_0=5
+            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,6)
+            if sum_1<=sum_0
+                set choice_0 6
+            endif
+        elseif choice_0=7
+            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,8)
+            if sum_1<=sum_0
+                set choice_0 8
+                set sum_0 sum_1
+            endif
+            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,9)
+            if sum_1<=sum_0
+                set choice_0 9
+            endif
+        elseif choice_0=10
+            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,11)
+            if sum_1<=sum_0
+                set choice_0 11
+                set sum_0 sum_1
+            endif
+            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,12)
+            if sum_1<=sum_0
+                set choice_0 12
+            endif
+        elseif choice_0=13
+            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,15)
+            if sum_1<=sum_0
+                set choice_0 15
+            endif
+        endelseif
+    else
+        #try tables with linbits
+        sub max 15
+        set i 15
+        while i<24
+            setcall value huffman_tabs(i,(huffman_linmax))
+            if value>=max
+                set choice_0 i
+                set i 24
+            else
+                inc i
+            endelse
+        endwhile
+        set i 24
+        while i<32
+            setcall value huffman_tabs(i,(huffman_linmax))
+            if value>=max
+                set choice_1 i
+                set i 32
+            else
+                inc i
+            endelse
+        endwhile
+        setcall sum_0 mp3_count_bit(l3enc_tt,start,end,choice_0)
+        setcall sum_1 mp3_count_bit(l3enc_tt,start,end,choice_1)
+        if sum_1<sum_0
+            set choice_0 choice_1
+        endif
+    endelse
+    return choice_0
+endfunction
+
+#bits
+function mp3_count_bit(sd l3enc_tt,sd start,sd end,sd table)
+    if table=0
+        return 0
+    endif
+    sd ylen
+    sd linbits
+    sd i
+    set i start
+    mult i (DWORD)
+    add l3enc_tt i
+    sd x
+    sd y
+    sd sum=0
+    sd index
+    setcall ylen huffman_tabs(table,(huffman_ylen))
+    setcall linbits huffman_tabs(table,(huffman_linbits))
+    set i start
+    if table>15
+        #ESC-table is used
+        while i<end
+            set x l3enc_tt#
+            add l3enc_tt (DWORD)
+            set y l3enc_tt#
+            add l3enc_tt (DWORD)
+            if x>14
+                set x 15
+                add sum linbits
+            endif
+            if y>14
+                set y 15
+                add sum linbits
+            endif
+            set index x
+            mult index ylen
+            add index y
+            addcall sum huffman_hlen(table,index)
+            if x!=0
+                inc sum
+            endif
+            if y!=0
+                inc sum
+            endif
+            #
+            add i 2
+        endwhile
+    else
+        #No ESC-words
+        while i<end
+            set x l3enc_tt#
+            add l3enc_tt (DWORD)
+            set y l3enc_tt#
+            add l3enc_tt (DWORD)
+            set index x
+            mult index ylen
+            add index y
+            addcall sum huffman_hlen(table,index)
+            if x!=0
+                inc sum
+            endif
+            if y!=0
+                inc sum
+            endif
+            #
+            add i 2
+        endwhile
+    endelse
+    return sum
+endfunction
+
+#maximum
+function mp3_int_max(sd array,sd start,sd end)
+    sd max=0
+    sd i
+    set i start
+    mult i (DWORD)
+    add array i
+    set i start
+    while i<end
+        if max<array#
+            set max array#
+        endif
+        add array (DWORD)
+        inc i
+    endwhile
+    return max
+endfunction
--- ovideo-1.orig/src/media/mpeg-mp3_iteration_code.s
+++ /dev/null
@@ -1,474 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-import "mp3_gr_info_itemSet" mp3_gr_info_itemSet
-
-#bits
-function mp3_iteration_code(sd l3enc_tt,sd gr_info)
-    data addresses#3
-    data p_addresses^addresses
-    data table_select_0#1
-    data table_select_1#1
-    data table_select_2#1
-    data p_table_select^table_select_0
-    sd bits
-    #
-    call mp3_calc_runlen(l3enc_tt,gr_info)
-    setcall bits count1_bitcount(l3enc_tt,gr_info)
-    call subdivide(gr_info,p_addresses)
-    call bigv_tab_select(l3enc_tt,gr_info,p_addresses,p_table_select)
-    addcall bits bigv_bitcount(l3enc_tt,p_addresses,p_table_select)
-    #
-    call mp3_gr_info_itemSet(gr_info,(gr_info_table_select_0),table_select_0)
-    call mp3_gr_info_itemSet(gr_info,(gr_info_table_select_1),table_select_1)
-    call mp3_gr_info_itemSet(gr_info,(gr_info_table_select_2),table_select_2)
-
-    return bits
-endfunction
-#######
-import "l3_enc_sample_get" l3_enc_sample_get
-import "mp3_gr_info_itemGet" mp3_gr_info_itemGet
-function mp3_calc_runlen(sd l3enc_tt,sd gr_info)
-    sd i=samp_per_frame2
-    #int rzero = 0;
-    sd value
-    sd loop=1
-    while loop==1
-        set loop 0
-        if i>1
-            set value i
-            sub value 1
-            setcall value l3_enc_sample_get(l3enc_tt,value)
-            if value==0
-                set value i
-                sub value 2
-                setcall value l3_enc_sample_get(l3enc_tt,value)
-                if value==0
-                    #rzero++
-                    sub i 2
-                    set loop 1
-                endif
-            endif
-        endif
-    endwhile
-    sd index
-    call mp3_gr_info_itemSet(gr_info,(gr_info_count1),0)
-    set loop 1
-    while loop==1
-        set loop 0
-        if i>3
-            set index i
-            #-1
-            dec index
-            setcall value l3_enc_sample_get(l3enc_tt,index)
-            if value<=1
-                #-2
-                dec index
-                setcall value l3_enc_sample_get(l3enc_tt,index)
-                if value<=1
-                    #-3
-                    dec index
-                    setcall value l3_enc_sample_get(l3enc_tt,index)
-                    if value<=1
-                        #-4
-                        dec index
-                        setcall value l3_enc_sample_get(l3enc_tt,index)
-                        if value<=1
-                            sd count1
-                            setcall count1 mp3_gr_info_itemGet(gr_info,(gr_info_count1))
-                            inc count1
-                            call mp3_gr_info_itemSet(gr_info,(gr_info_count1),count1)
-                            #
-                            sub i 4
-                            set loop 1
-                        endif
-                    endif
-                endif
-            endif
-        endif
-    endwhile
-    import "sar32" sar
-    setcall i sar(i,1)
-    call mp3_gr_info_itemSet(gr_info,(gr_info_big_values),i)
-endfunction
-#bits
-function count1_bitcount(sd l3enc_tt,sd gr_info)
-    sd sum0=0
-    sd sum1=0
-    sd v
-    sd w
-    sd x
-    sd y
-    sd p
-    sd i
-    setcall i mp3_gr_info_itemGet(gr_info,(gr_info_big_values))
-    import "shl" shl
-    setcall i shl(i,1)
-    sd k=0
-    sd count1
-    setcall count1 mp3_gr_info_itemGet(gr_info,(gr_info_count1))
-    while k<count1
-        setcall v l3_enc_sample_get(l3enc_tt,i)
-        inc i
-        setcall w l3_enc_sample_get(l3enc_tt,i)
-        inc i
-        setcall x l3_enc_sample_get(l3enc_tt,i)
-        inc i
-        setcall y l3_enc_sample_get(l3enc_tt,i)
-        inc i
-
-        set p v
-        addcall p shl(w,1)
-        addcall p shl(x,2)
-        addcall p shl(y,3)
-
-        sd signbits=0
-        if v!=0
-            inc signbits
-        endif
-        if w!=0
-            inc signbits
-        endif
-        if x!=0
-            inc signbits
-        endif
-        if y!=0
-            inc signbits
-        endif
-
-        add sum0 signbits
-        add sum1 signbits
-        import "huffman_hlen" huffman_hlen
-        addcall sum0 huffman_hlen(32,p)
-        addcall sum1 huffman_hlen(33,p)
-
-        inc k
-    endwhile
-    if sum0<sum1
-        call mp3_gr_info_itemSet(gr_info,(gr_info_count1table_select),0)
-        return sum0
-    endif
-    call mp3_gr_info_itemSet(gr_info,(gr_info_count1table_select),1)
-    return sum1
-endfunction
-import "scalefac_band_long" scalefac_band_long
-import "subdv_table" subdv_table
-function subdivide(sd gr_info,sd p_addresses)
-    sd big_values
-    setcall big_values mp3_gr_info_itemGet(gr_info,(gr_info_big_values))
-    sd bigvalues_region
-    sd scfb_anz=0
-    set bigvalues_region big_values
-    mult bigvalues_region 2
-    sd scalefac_band
-    setcall scalefac_band scalefac_band_long()
-    while scalefac_band#<bigvalues_region
-        inc scfb_anz
-        add scalefac_band (DWORD)
-    endwhile
-    #
-    sd region0_count
-    setcall region0_count subdv_table(scfb_anz,0)
-    sd thiscount
-    sd index
-    set thiscount region0_count
-    set index thiscount
-    inc index
-    setcall scalefac_band scalefac_band_long()
-    sd sizeadd=DWORD
-    mult sizeadd index
-    add scalefac_band sizeadd
-    sd loop=1
-    while loop==1
-        set loop 0
-        if thiscount!=0
-            if scalefac_band#>bigvalues_region
-                dec thiscount
-                dec index
-                sub scalefac_band (DWORD)
-                set loop 1
-            endif
-        endif
-    endwhile
-    set region0_count thiscount
-    call mp3_gr_info_itemSet(gr_info,(gr_info_region0_count),region0_count)
-    #
-    sd region1_count
-    setcall region1_count subdv_table(scfb_anz,1)
-    set thiscount region1_count
-    set index region0_count
-    add index region1_count
-    add index 2
-    setcall scalefac_band scalefac_band_long()
-    set sizeadd (DWORD)
-    mult sizeadd index
-    add scalefac_band sizeadd
-    set loop 1
-    while loop==1
-        set loop 0
-        if thiscount!=0
-            if scalefac_band#>bigvalues_region
-                dec thiscount
-                dec index
-                sub scalefac_band (DWORD)
-                set loop 1
-            endif
-        endif
-    endwhile
-    set region1_count thiscount
-    call mp3_gr_info_itemSet(gr_info,(gr_info_region1_count),region1_count)
-    #
-    import "scalefac_band_long_get" scalefac_band_long_get
-    set index region0_count
-    inc index
-    setcall p_addresses# scalefac_band_long_get(index)
-    #
-    add p_addresses (DWORD)
-    set index region0_count
-    add index region1_count
-    add index 2
-    setcall p_addresses# scalefac_band_long_get(index)
-    #
-    add p_addresses (DWORD)
-    set p_addresses# bigvalues_region
-endfunction
-function bigv_tab_select(sd l3enc_tt,sd gr_info,sd p_addresses,sd p_table_select)
-    #Select huffman code tables for bigvalues regions
-    sd address_1
-    sd address_2
-    sd big_values
-    set address_1 p_addresses#
-    add p_addresses (DWORD)
-    set address_2 p_addresses#
-    setcall big_values mp3_gr_info_itemGet(gr_info,(gr_info_big_values))
-    #
-    set p_table_select# 0
-    if address_1>0
-        setcall p_table_select# mp3_choose_table(l3enc_tt,0,address_1)
-    endif
-    add p_table_select (DWORD)
-    set p_table_select# 0
-    if address_2>address_1
-        setcall p_table_select# mp3_choose_table(l3enc_tt,address_1,address_2)
-    endif
-    add p_table_select (DWORD)
-    set p_table_select# 0
-    mult big_values 2
-    if big_values>address_2
-        setcall p_table_select# mp3_choose_table(l3enc_tt,address_2,big_values)
-    endif
-endfunction
-#bits
-function bigv_bitcount(sd l3enc_tt,sd p_addresses,sd p_table_select)
-    sd bits=0
-    sd table
-    sd addr_1
-    sd addr_2
-    sd addr_3
-    set table p_table_select#
-    set addr_1 p_addresses#
-    if table!=0
-        addcall bits mp3_count_bit(l3enc_tt,0,addr_1,table)
-    endif
-    add p_table_select (DWORD)
-    add p_addresses (DWORD)
-    set table p_table_select#
-    set addr_2 p_addresses#
-    if table!=0
-        addcall bits mp3_count_bit(l3enc_tt,addr_1,addr_2,table)
-    endif
-    add p_table_select (DWORD)
-    add p_addresses (DWORD)
-    set table p_table_select#
-    set addr_3 p_addresses#
-    if table!=0
-        addcall bits mp3_count_bit(l3enc_tt,addr_2,addr_3,table)
-    endif
-    return bits
-endfunction
-#########
-
-import "huffman_tabs" huffman_tabs
-#table_select
-function mp3_choose_table(sd l3enc_tt,sd start,sd end)
-    sd max
-    setcall max mp3_int_max(l3enc_tt,start,end)
-    if max==0
-        return 0
-    endif
-    sd i
-    sd value
-    sd choice_0=0
-    sd choice_1=0
-    sd sum_0
-    sd sum_1
-    if max<15
-        set i 14
-        while i!=0
-            dec i
-            setcall value huffman_tabs(i,(huffman_xlen))
-            if value>max
-                set choice_0 i
-                set i 0
-            endif
-        endwhile
-        setcall sum_0 mp3_count_bit(l3enc_tt,start,end,choice_0)
-        if choice_0==2
-            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,3)
-            if sum_1<=sum_0
-                set choice_0 3
-            endif
-        elseif choice_0==5
-            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,6)
-            if sum_1<=sum_0
-                set choice_0 6
-            endif
-        elseif choice_0==7
-            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,8)
-            if sum_1<=sum_0
-                set choice_0 8
-                set sum_0 sum_1
-            endif
-            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,9)
-            if sum_1<=sum_0
-                set choice_0 9
-            endif
-        elseif choice_0==10
-            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,11)
-            if sum_1<=sum_0
-                set choice_0 11
-                set sum_0 sum_1
-            endif
-            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,12)
-            if sum_1<=sum_0
-                set choice_0 12
-            endif
-        elseif choice_0==13
-            setcall sum_1 mp3_count_bit(l3enc_tt,start,end,15)
-            if sum_1<=sum_0
-                set choice_0 15
-            endif
-        endelseif
-    else
-        #try tables with linbits
-        sub max 15
-        set i 15
-        while i<24
-            setcall value huffman_tabs(i,(huffman_linmax))
-            if value>=max
-                set choice_0 i
-                set i 24
-            else
-                inc i
-            endelse
-        endwhile
-        set i 24
-        while i<32
-            setcall value huffman_tabs(i,(huffman_linmax))
-            if value>=max
-                set choice_1 i
-                set i 32
-            else
-                inc i
-            endelse
-        endwhile
-        setcall sum_0 mp3_count_bit(l3enc_tt,start,end,choice_0)
-        setcall sum_1 mp3_count_bit(l3enc_tt,start,end,choice_1)
-        if sum_1<sum_0
-            set choice_0 choice_1
-        endif
-    endelse
-    return choice_0
-endfunction
-
-#bits
-function mp3_count_bit(sd l3enc_tt,sd start,sd end,sd table)
-    if table==0
-        return 0
-    endif
-    sd ylen
-    sd linbits
-    sd i
-    set i start
-    mult i (DWORD)
-    add l3enc_tt i
-    sd x
-    sd y
-    sd sum=0
-    sd index
-    setcall ylen huffman_tabs(table,(huffman_ylen))
-    setcall linbits huffman_tabs(table,(huffman_linbits))
-    set i start
-    if table>15
-        #ESC-table is used
-        while i<end
-            set x l3enc_tt#
-            add l3enc_tt (DWORD)
-            set y l3enc_tt#
-            add l3enc_tt (DWORD)
-            if x>14
-                set x 15
-                add sum linbits
-            endif
-            if y>14
-                set y 15
-                add sum linbits
-            endif
-            set index x
-            mult index ylen
-            add index y
-            addcall sum huffman_hlen(table,index)
-            if x!=0
-                inc sum
-            endif
-            if y!=0
-                inc sum
-            endif
-            #
-            add i 2
-        endwhile
-    else
-        #No ESC-words
-        while i<end
-            set x l3enc_tt#
-            add l3enc_tt (DWORD)
-            set y l3enc_tt#
-            add l3enc_tt (DWORD)
-            set index x
-            mult index ylen
-            add index y
-            addcall sum huffman_hlen(table,index)
-            if x!=0
-                inc sum
-            endif
-            if y!=0
-                inc sum
-            endif
-            #
-            add i 2
-        endwhile
-    endelse
-    return sum
-endfunction
-
-#maximum
-function mp3_int_max(sd array,sd start,sd end)
-    sd max=0
-    sd i
-    set i start
-    mult i (DWORD)
-    add array i
-    set i start
-    while i<end
-        if max<array#
-            set max array#
-        endif
-        add array (DWORD)
-        inc i
-    endwhile
-    return max
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-mp3_mdct.oc
@@ -0,0 +1,376 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+const cos_l_units=18*36
+const cos_l_size=cos_l_units*DWORD
+const ca_cs_units=8
+const ca_cs_size=ca_cs_units*DWORD
+
+import "mult64" mult64
+
+function mp3_mdct(sd l3_sb_sample,sd mdct_freq)
+    sd l3_sb_gr
+    sd l3_sb_gr_1
+    sd sizeadd
+    sd mdct_enc
+    sd l3_sb_cursor
+    sd m
+    sd value
+    sd p_value^value
+    sd l3_sb_cursor_1
+    sd granule=0
+    while granule<2
+        set mdct_enc mdct_freq
+        set sizeadd (mdct_freq_granule_size)
+        mult sizeadd granule
+        add mdct_enc sizeadd
+        add mdct_enc (mdct_freq_granule_size)
+        #
+        set l3_sb_gr l3_sb_sample
+        set sizeadd granule
+        mult sizeadd (l3_sb_sample_granule_size)
+        add l3_sb_gr sizeadd
+        set l3_sb_gr_1 l3_sb_gr
+        add l3_sb_gr_1 (l3_sb_sample_granule_size)
+        #
+        add l3_sb_gr (l3_sb_sample_size)
+        add l3_sb_gr_1 (l3_sb_sample_size)
+        #
+        sd channel=mp3_channels
+        while channel>0
+            dec channel
+            sub l3_sb_gr (l3_sb_sample_channel_size)
+            sub l3_sb_gr_1 (l3_sb_sample_channel_size)
+            #
+            sub mdct_enc (mdct_freq_channel_size)
+            #Compensate for inversion in the analysis filter
+            #(every odd index of band AND k)
+            sd band=1
+            while band<32
+                set l3_sb_cursor l3_sb_gr_1
+                set sizeadd band
+                mult sizeadd (DWORD)
+                add l3_sb_cursor sizeadd
+                sd k=1
+                add l3_sb_cursor (l3_sb_sample_band_size)
+                while k<18
+                    mult l3_sb_cursor# -1
+                    add l3_sb_cursor (l3_sb_sample_band_size)
+                    add l3_sb_cursor (l3_sb_sample_band_size)
+                    add k 2
+                endwhile
+                add band 2
+            endwhile
+            #Perform imdct of 18 previous subband samples + 18 current subband samples
+            data mdct_in_data#36
+            data mdct_in^mdct_in_data
+            const mdct_in_size=36*DWORD
+            sd mdct_in_cursor
+            sd mdct_in_cursor_18
+            set band 32
+            while band!=0
+                dec band
+                set l3_sb_cursor l3_sb_gr
+                set l3_sb_cursor_1 l3_sb_gr_1
+                set sizeadd band
+                mult sizeadd (DWORD)
+                add l3_sb_cursor sizeadd
+                add l3_sb_cursor_1 sizeadd
+                #
+                set k 18
+                set sizeadd k
+                mult sizeadd (l3_sb_sample_band_size)
+                add l3_sb_cursor sizeadd
+                add l3_sb_cursor_1 sizeadd
+                set mdct_in_cursor mdct_in
+                set mdct_in_cursor_18 mdct_in
+                add mdct_in_cursor (mdct_in_size/2)
+                add mdct_in_cursor_18 (mdct_in_size)
+                while k!=0
+                    dec k
+                    sub l3_sb_cursor (l3_sb_sample_band_size)
+                    sub l3_sb_cursor_1 (l3_sb_sample_band_size)
+                    sub mdct_in_cursor (DWORD)
+                    sub mdct_in_cursor_18 (DWORD)
+                    #
+                    set mdct_in_cursor# l3_sb_cursor#
+                    set mdct_in_cursor_18# l3_sb_cursor_1#
+                endwhile
+                #Calculation of the MDCT,mdct_enc: [576] to [32][18]
+                const mdct_band_size=18*DWORD
+                sd cos_l
+                setcall cos_l l3_cos_l()
+                add cos_l (cos_l_size)
+                set k 18
+                set m mdct_enc
+                set sizeadd band
+                mult sizeadd (mdct_band_size)
+                add m sizeadd
+                add m (mdct_band_size)
+                while k!=0
+                    dec k
+                    sub m (DWORD)
+                    #
+                    set mdct_in_cursor mdct_in
+                    add mdct_in_cursor (mdct_in_size)
+                    sd j=36
+                    set m# 0
+                    while j!=0
+                        dec j
+                        sub mdct_in_cursor (DWORD)
+                        sub cos_l (DWORD)
+                        #
+                        call mult64(mdct_in_cursor#,cos_l#,p_value)
+                        add m# value
+                    endwhile
+                endwhile
+            endwhile
+            #Perform aliasing reduction butterfly
+            sd bu
+            sd bd
+            sd m_1
+            sd m_2
+            sd m_value_1
+            sd m_value_2
+            set band 31
+            while band!=0
+                dec band
+                #
+                set m_1 band
+                mult m_1 (mdct_band_size)
+                add m_1 mdct_enc
+                set m_2 m_1
+                add m_2 (mdct_band_size)
+                #
+                sd ca
+                sd cs
+                sd ca_value
+                sd cs_value
+                setcall ca l3_ca()
+                setcall cs l3_cs()
+                add ca (ca_cs_size)
+                add cs (ca_cs_size)
+                set k 8
+                set sizeadd 17
+                sub sizeadd k
+                mult sizeadd (DWORD)
+                add m_1 sizeadd
+                set sizeadd k
+                mult sizeadd (DWORD)
+                add m_2 sizeadd
+                while k!=0
+                    dec k
+                    add m_1 (DWORD)
+                    sub m_2 (DWORD)
+                    sub ca (DWORD)
+                    sub cs (DWORD)
+                    #must left justify result of multiplication here because the centre
+                    # two values in each block are not touched.
+                    set m_value_1 m_1#
+                    set m_value_2 m_2#
+                    set ca_value ca#
+                    set cs_value cs#
+                    call mult64(m_value_1,cs_value,p_value)
+                    set bu value
+                    call mult64(m_value_2,ca_value,p_value)
+                    add bu value
+                    call mult64(m_value_2,cs_value,p_value)
+                    set bd value
+                    call mult64(m_value_1,ca_value,p_value)
+                    sub bd value
+                    set m_1# bu
+                    set m_2# bd
+                endwhile
+            endwhile
+        endwhile
+        inc granule
+    endwhile
+    #Save latest granule's subband samples to be used in the next mdct call
+    import "cpymem" cpymem
+    sd from
+    sd to
+    set channel 0
+    while channel!=(mp3_channels)
+        set from channel
+        mult from (l3_sb_sample_channel_size)
+        set to from
+        add from (l3_sb_sample_granule_size)
+        add from (l3_sb_sample_granule_size)
+        add from l3_sb_sample
+        add to l3_sb_sample
+        call cpymem(to,from,(l3_sb_sample_granule_size))
+        inc channel
+    endwhile
+endfunction
+
+import "str_to_double" str_to_double
+import "fld_quad" fld_quad
+import "fmul_quad" fmul_quad
+import "fstp_quad" fstp_quad
+import "fadd_quad" fadd_quad
+import "fdiv_quad" fdiv_quad
+import "fild_value" fild_value
+import "double_to_int" double_to_int
+importx "_sqrt" sqrt
+import "slen" slen
+
+function l3_mdct_init()
+    data double_low#1
+    data double_high#1
+    data double^double_low
+    data double_2_low#1
+    data *double_2_high#1
+    data double_2^double_2_low
+    data double_3_low#1
+    data *double_3_high#1
+    data double_3^double_3_low
+    ##prepare the aliasing reduction butterflies
+    char c_data="-0.6"
+    char *="-0.535"
+    char *="-0.33"
+    char *="-0.185"
+    char *="-0.095"
+    char *="-0.041"
+    char *="-0.0142"
+    char *="-0.0037"
+    sd c^c_data
+    sd ca
+    sd cs
+    setcall ca l3_ca()
+    setcall cs l3_cs()
+    call fild_value(0x7fffffff)
+    call fstp_quad(double_3)
+    sd i=0
+    while i!=8
+        call str_to_double(c,double_2)
+        call fld_quad(double_2)
+        call fmul_quad(double_2)
+        call fild_value(1)
+        call fstp_quad(double)
+        call fadd_quad(double)
+        call fstp_quad(double)
+        call sqrt(double_low,double_high)
+        call fstp_quad(double)
+        #
+        call fld_quad(double_2)
+        call fdiv_quad(double)
+        call fmul_quad(double_3)
+        #call fistp(ca)
+        call fstp_quad(double_2)
+        setcall ca# double_to_int(double_2)
+        #
+        call fild_value(1)
+        call fdiv_quad(double)
+        call fmul_quad(double_3)
+        #call fistp(cs)
+        call fstp_quad(double)
+        setcall cs# double_to_int(double)
+        #
+        add ca (DWORD)
+        add cs (DWORD)
+        addcall c slen(c)
+        inc c
+        inc i
+    endwhile
+    ##prepare the mdct coefficients
+    data const1_low#1
+    data *const1_high#1
+    data const1^const1_low
+    str const1_str="0.5"
+    call str_to_double(const1_str,const1)
+    #PI 36
+    data const2_low#1
+    data *const2_high#1
+    data const2^const2_low
+    str const2_str="0.087266462599717"
+    call str_to_double(const2_str,const2)
+    #PI
+    data const3_low#1
+    data *const3_high#1
+    data const3^const3_low
+    str const3_str="3.14159265358979"
+    call str_to_double(const3_str,const3)
+    #
+    sd cos_l
+    setcall cos_l l3_cos_l()
+    add cos_l (cos_l_size)
+    sd k
+    sd value
+    sd value_2
+    sd m=18
+    while m!=0
+        dec m
+        set k 36
+        while k!=0
+            #combine window and mdct coefficients into a single table
+            #scale and convert to fixed point before storing
+            dec k
+            sub cos_l (DWORD)
+            #
+            call fild_value(k)
+            call fadd_quad(const1)
+            call fmul_quad(const2)
+
+		#cos was problematic on linux
+		#call fstp_quad(double)
+		#importx "_sin" sin
+		#call sin(double_low,double_high)
+		#small diffs only
+		import "fsin" fsin
+		call fsin()
+
+            #
+            set value m
+            mult value 2
+            inc value
+            set value_2 k
+            mult value_2 2
+            add value_2 19
+            mult value value_2
+            call fild_value(72)
+            call fstp_quad(double)
+            call fld_quad(const3)
+            call fdiv_quad(double)
+            call fstp_quad(double)
+            call fild_value(value)
+            call fmul_quad(double)
+
+		#this is problematic on linux
+		#call fstp_quad(double)
+		#importx "_cos" cos
+		#call cos(double_low,double_high)
+		import "fcos" fcos
+		call fcos()
+
+            call fstp_quad(double)
+            call fmul_quad(double)
+            #
+            call fild_value(0x7fffffff)
+            call fstp_quad(double)
+            call fmul_quad(double)
+            #call fistp(cos_l)
+            call fstp_quad(double)
+            setcall cos_l# double_to_int(double)
+        endwhile
+    endwhile
+endfunction
+
+function l3_ca()
+    data cs#ca_cs_units
+    data p^cs
+    return p
+endfunction
+function l3_cs()
+    data cs#ca_cs_units
+    data p^cs
+    return p
+endfunction
+
+function l3_cos_l()
+    data cos_l#cos_l_units
+    data p^cos_l
+    return p
+endfunction
--- ovideo-1.orig/src/media/mpeg-mp3_mdct.s
+++ /dev/null
@@ -1,376 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-const cos_l_units=18*36
-const cos_l_size=cos_l_units*DWORD
-const ca_cs_units=8
-const ca_cs_size=ca_cs_units*DWORD
-
-import "mult64" mult64
-
-function mp3_mdct(sd l3_sb_sample,sd mdct_freq)
-    sd l3_sb_gr
-    sd l3_sb_gr_1
-    sd sizeadd
-    sd mdct_enc
-    sd l3_sb_cursor
-    sd m
-    sd value
-    sd p_value^value
-    sd l3_sb_cursor_1
-    sd granule=0
-    while granule<2
-        set mdct_enc mdct_freq
-        set sizeadd (mdct_freq_granule_size)
-        mult sizeadd granule
-        add mdct_enc sizeadd
-        add mdct_enc (mdct_freq_granule_size)
-        #
-        set l3_sb_gr l3_sb_sample
-        set sizeadd granule
-        mult sizeadd (l3_sb_sample_granule_size)
-        add l3_sb_gr sizeadd
-        set l3_sb_gr_1 l3_sb_gr
-        add l3_sb_gr_1 (l3_sb_sample_granule_size)
-        #
-        add l3_sb_gr (l3_sb_sample_size)
-        add l3_sb_gr_1 (l3_sb_sample_size)
-        #
-        sd channel=mp3_channels
-        while channel>0
-            dec channel
-            sub l3_sb_gr (l3_sb_sample_channel_size)
-            sub l3_sb_gr_1 (l3_sb_sample_channel_size)
-            #
-            sub mdct_enc (mdct_freq_channel_size)
-            #Compensate for inversion in the analysis filter
-            #(every odd index of band AND k)
-            sd band=1
-            while band<32
-                set l3_sb_cursor l3_sb_gr_1
-                set sizeadd band
-                mult sizeadd (DWORD)
-                add l3_sb_cursor sizeadd
-                sd k=1
-                add l3_sb_cursor (l3_sb_sample_band_size)
-                while k<18
-                    mult l3_sb_cursor# -1
-                    add l3_sb_cursor (l3_sb_sample_band_size)
-                    add l3_sb_cursor (l3_sb_sample_band_size)
-                    add k 2
-                endwhile
-                add band 2
-            endwhile
-            #Perform imdct of 18 previous subband samples + 18 current subband samples
-            data mdct_in_data#36
-            data mdct_in^mdct_in_data
-            const mdct_in_size=36*DWORD
-            sd mdct_in_cursor
-            sd mdct_in_cursor_18
-            set band 32
-            while band!=0
-                dec band
-                set l3_sb_cursor l3_sb_gr
-                set l3_sb_cursor_1 l3_sb_gr_1
-                set sizeadd band
-                mult sizeadd (DWORD)
-                add l3_sb_cursor sizeadd
-                add l3_sb_cursor_1 sizeadd
-                #
-                set k 18
-                set sizeadd k
-                mult sizeadd (l3_sb_sample_band_size)
-                add l3_sb_cursor sizeadd
-                add l3_sb_cursor_1 sizeadd
-                set mdct_in_cursor mdct_in
-                set mdct_in_cursor_18 mdct_in
-                add mdct_in_cursor (mdct_in_size/2)
-                add mdct_in_cursor_18 (mdct_in_size)
-                while k!=0
-                    dec k
-                    sub l3_sb_cursor (l3_sb_sample_band_size)
-                    sub l3_sb_cursor_1 (l3_sb_sample_band_size)
-                    sub mdct_in_cursor (DWORD)
-                    sub mdct_in_cursor_18 (DWORD)
-                    #
-                    set mdct_in_cursor# l3_sb_cursor#
-                    set mdct_in_cursor_18# l3_sb_cursor_1#
-                endwhile
-                #Calculation of the MDCT,mdct_enc: [576] to [32][18]
-                const mdct_band_size=18*DWORD
-                sd cos_l
-                setcall cos_l l3_cos_l()
-                add cos_l (cos_l_size)
-                set k 18
-                set m mdct_enc
-                set sizeadd band
-                mult sizeadd (mdct_band_size)
-                add m sizeadd
-                add m (mdct_band_size)
-                while k!=0
-                    dec k
-                    sub m (DWORD)
-                    #
-                    set mdct_in_cursor mdct_in
-                    add mdct_in_cursor (mdct_in_size)
-                    sd j=36
-                    set m# 0
-                    while j!=0
-                        dec j
-                        sub mdct_in_cursor (DWORD)
-                        sub cos_l (DWORD)
-                        #
-                        call mult64(mdct_in_cursor#,cos_l#,p_value)
-                        add m# value
-                    endwhile
-                endwhile
-            endwhile
-            #Perform aliasing reduction butterfly
-            sd bu
-            sd bd
-            sd m_1
-            sd m_2
-            sd m_value_1
-            sd m_value_2
-            set band 31
-            while band!=0
-                dec band
-                #
-                set m_1 band
-                mult m_1 (mdct_band_size)
-                add m_1 mdct_enc
-                set m_2 m_1
-                add m_2 (mdct_band_size)
-                #
-                sd ca
-                sd cs
-                sd ca_value
-                sd cs_value
-                setcall ca l3_ca()
-                setcall cs l3_cs()
-                add ca (ca_cs_size)
-                add cs (ca_cs_size)
-                set k 8
-                set sizeadd 17
-                sub sizeadd k
-                mult sizeadd (DWORD)
-                add m_1 sizeadd
-                set sizeadd k
-                mult sizeadd (DWORD)
-                add m_2 sizeadd
-                while k!=0
-                    dec k
-                    add m_1 (DWORD)
-                    sub m_2 (DWORD)
-                    sub ca (DWORD)
-                    sub cs (DWORD)
-                    #must left justify result of multiplication here because the centre
-                    # two values in each block are not touched.
-                    set m_value_1 m_1#
-                    set m_value_2 m_2#
-                    set ca_value ca#
-                    set cs_value cs#
-                    call mult64(m_value_1,cs_value,p_value)
-                    set bu value
-                    call mult64(m_value_2,ca_value,p_value)
-                    add bu value
-                    call mult64(m_value_2,cs_value,p_value)
-                    set bd value
-                    call mult64(m_value_1,ca_value,p_value)
-                    sub bd value
-                    set m_1# bu
-                    set m_2# bd
-                endwhile
-            endwhile
-        endwhile
-        inc granule
-    endwhile
-    #Save latest granule's subband samples to be used in the next mdct call
-    import "cpymem" cpymem
-    sd from
-    sd to
-    set channel 0
-    while channel!=(mp3_channels)
-        set from channel
-        mult from (l3_sb_sample_channel_size)
-        set to from
-        add from (l3_sb_sample_granule_size)
-        add from (l3_sb_sample_granule_size)
-        add from l3_sb_sample
-        add to l3_sb_sample
-        call cpymem(to,from,(l3_sb_sample_granule_size))
-        inc channel
-    endwhile
-endfunction
-
-import "str_to_double" str_to_double
-import "fld_quad" fld_quad
-import "fmul_quad" fmul_quad
-import "fstp_quad" fstp_quad
-import "fadd_quad" fadd_quad
-import "fdiv_quad" fdiv_quad
-import "fild_value" fild_value
-import "double_to_int" double_to_int
-importx "_sqrt" sqrt
-import "slen" slen
-
-function l3_mdct_init()
-    data double_low#1
-    data double_high#1
-    data double^double_low
-    data double_2_low#1
-    data *double_2_high#1
-    data double_2^double_2_low
-    data double_3_low#1
-    data *double_3_high#1
-    data double_3^double_3_low
-    ##prepare the aliasing reduction butterflies
-    char c_data="-0.6"
-    char *="-0.535"
-    char *="-0.33"
-    char *="-0.185"
-    char *="-0.095"
-    char *="-0.041"
-    char *="-0.0142"
-    char *="-0.0037"
-    sd c^c_data
-    sd ca
-    sd cs
-    setcall ca l3_ca()
-    setcall cs l3_cs()
-    call fild_value(0x7fffffff)
-    call fstp_quad(double_3)
-    sd i=0
-    while i!=8
-        call str_to_double(c,double_2)
-        call fld_quad(double_2)
-        call fmul_quad(double_2)
-        call fild_value(1)
-        call fstp_quad(double)
-        call fadd_quad(double)
-        call fstp_quad(double)
-        call sqrt(double_low,double_high)
-        call fstp_quad(double)
-        #
-        call fld_quad(double_2)
-        call fdiv_quad(double)
-        call fmul_quad(double_3)
-        #call fistp(ca)
-        call fstp_quad(double_2)
-        setcall ca# double_to_int(double_2)
-        #
-        call fild_value(1)
-        call fdiv_quad(double)
-        call fmul_quad(double_3)
-        #call fistp(cs)
-        call fstp_quad(double)
-        setcall cs# double_to_int(double)
-        #
-        add ca (DWORD)
-        add cs (DWORD)
-        addcall c slen(c)
-        inc c
-        inc i
-    endwhile
-    ##prepare the mdct coefficients
-    data const1_low#1
-    data *const1_high#1
-    data const1^const1_low
-    str const1_str="0.5"
-    call str_to_double(const1_str,const1)
-    #PI 36
-    data const2_low#1
-    data *const2_high#1
-    data const2^const2_low
-    str const2_str="0.087266462599717"
-    call str_to_double(const2_str,const2)
-    #PI
-    data const3_low#1
-    data *const3_high#1
-    data const3^const3_low
-    str const3_str="3.14159265358979"
-    call str_to_double(const3_str,const3)
-    #
-    sd cos_l
-    setcall cos_l l3_cos_l()
-    add cos_l (cos_l_size)
-    sd k
-    sd value
-    sd value_2
-    sd m=18
-    while m!=0
-        dec m
-        set k 36
-        while k!=0
-            #combine window and mdct coefficients into a single table
-            #scale and convert to fixed point before storing
-            dec k
-            sub cos_l (DWORD)
-            #
-            call fild_value(k)
-            call fadd_quad(const1)
-            call fmul_quad(const2)
-
-		#cos was problematic on linux
-		#call fstp_quad(double)
-		#importx "_sin" sin
-		#call sin(double_low,double_high)
-		#small diffs only
-		import "fsin" fsin
-		call fsin()
-
-            #
-            set value m
-            mult value 2
-            inc value
-            set value_2 k
-            mult value_2 2
-            add value_2 19
-            mult value value_2
-            call fild_value(72)
-            call fstp_quad(double)
-            call fld_quad(const3)
-            call fdiv_quad(double)
-            call fstp_quad(double)
-            call fild_value(value)
-            call fmul_quad(double)
-
-		#this is problematic on linux
-		#call fstp_quad(double)
-		#importx "_cos" cos
-		#call cos(double_low,double_high)
-		import "fcos" fcos
-		call fcos()
-
-            call fstp_quad(double)
-            call fmul_quad(double)
-            #
-            call fild_value(0x7fffffff)
-            call fstp_quad(double)
-            call fmul_quad(double)
-            #call fistp(cos_l)
-            call fstp_quad(double)
-            setcall cos_l# double_to_int(double)
-        endwhile
-    endwhile
-endfunction
-
-function l3_ca()
-    data cs#ca_cs_units
-    data p^cs
-    return p
-endfunction
-function l3_cs()
-    data cs#ca_cs_units
-    data p^cs
-    return p
-endfunction
-
-function l3_cos_l()
-    data cos_l#cos_l_units
-    data p^cos_l
-    return p
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-mp3_tables.oc
@@ -0,0 +1,621 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+function mp3_tables_enwindow()
+    char enwindow_data="0.000000"
+    char *            ="-0.000000"
+    char *            ="-0.000000"
+    char *            ="-0.000000"
+    char *            ="-0.000000"
+    char *            ="-0.000000"
+    char *            ="-0.000000"
+    char *            ="-0.000001"
+    char *            ="-0.000001"
+    char *            ="-0.000001"
+    #
+    char *            ="-0.000001"
+    char *            ="-0.000001"
+    char *            ="-0.000001"
+    char *            ="-0.000002"
+    char *            ="-0.000002"
+    char *            ="-0.000002"
+    char *            ="-0.000002"
+    char *            ="-0.000003"
+    char *            ="-0.000003"
+    char *            ="-0.000003"
+    #
+    char *            ="-0.000004"
+    char *            ="-0.000004"
+    char *            ="-0.000005"
+    char *            ="-0.000005"
+    char *            ="-0.000006"
+    char *            ="-0.000007"
+    char *            ="-0.000008"
+    char *            ="-0.000008"
+    char *            ="-0.000009"
+    char *            ="-0.000010"
+    #
+    char *            ="-0.000011"
+    char *            ="-0.000012"
+    char *            ="-0.000014"
+    char *            ="-0.000015"
+    char *            ="-0.000017"
+    char *            ="-0.000018"
+    char *            ="-0.000020"
+    char *            ="-0.000021"
+    char *            ="-0.000023"
+    char *            ="-0.000025"
+    #
+    char *            ="-0.000028"
+    char *            ="-0.000030"
+    char *            ="-0.000032"
+    char *            ="-0.000035"
+    char *            ="-0.000038"
+    char *            ="-0.000041"
+    char *            ="-0.000043"
+    char *            ="-0.000046"
+    char *            ="-0.000050"
+    char *            ="-0.000053"
+    #
+    char *            ="-0.000056"
+    char *            ="-0.000060"
+    char *            ="-0.000063"
+    char *            ="-0.000066"
+    char *            ="-0.000070"
+    char *            ="-0.000073"
+    char *            ="-0.000077"
+    char *            ="-0.000081"
+    char *            ="-0.000084"
+    char *            ="-0.000087"
+    #
+    char *            ="-0.000091"
+    char *            ="-0.000093"
+    char *            ="-0.000096"
+    char *            ="-0.000099"
+    char *            ="0.000102"
+    char *            ="0.000104"
+    char *            ="0.000106"
+    char *            ="0.000107"
+    char *            ="0.000108"
+    char *            ="0.000109"
+    #
+    char *            ="0.000109"
+    char *            ="0.000108"
+    char *            ="0.000107"
+    char *            ="0.000105"
+    char *            ="0.000103"
+    char *            ="0.000099"
+    char *            ="0.000095"
+    char *            ="0.000090"
+    char *            ="0.000084"
+    char *            ="0.000078"
+    #
+    char *            ="0.000070"
+    char *            ="0.000061"
+    char *            ="0.000051"
+    char *            ="0.000040"
+    char *            ="0.000027"
+    char *            ="0.000014"
+    char *            ="-0.000001"
+    char *            ="-0.000017"
+    char *            ="-0.000034"
+    char *            ="-0.000053"
+    #
+    char *            ="-0.000073"
+    char *            ="-0.000094"
+    char *            ="-0.000116"
+    char *            ="-0.000140"
+    char *            ="-0.000165"
+    char *            ="-0.000191"
+    char *            ="-0.000219"
+    char *            ="-0.000247"
+    char *            ="-0.000277"
+    char *            ="-0.000308"
+    #
+    char *            ="-0.000339"
+    char *            ="-0.000371"
+    char *            ="-0.000404"
+    char *            ="-0.000438"
+    char *            ="-0.000473"
+    char *            ="-0.000507"
+    char *            ="-0.000542"
+    char *            ="-0.000577"
+    char *            ="-0.000612"
+    char *            ="-0.000647"
+    #
+    char *            ="-0.000681"
+    char *            ="-0.000714"
+    char *            ="-0.000747"
+    char *            ="-0.000779"
+    char *            ="-0.000810"
+    char *            ="-0.000839"
+    char *            ="-0.000866"
+    char *            ="-0.000892"
+    char *            ="-0.000915"
+    char *            ="-0.000936"
+    #
+    char *            ="-0.000954"
+    char *            ="-0.000969"
+    char *            ="-0.000981"
+    char *            ="-0.000989"
+    char *            ="-0.000994"
+    char *            ="-0.000995"
+    char *            ="-0.000992"
+    char *            ="-0.000984"
+    char *            ="0.000971"
+    char *            ="0.000954"
+    #
+    char *            ="0.000931"
+    char *            ="0.000903"
+    char *            ="0.000869"
+    char *            ="0.000829"
+    char *            ="0.000784"
+    char *            ="0.000732"
+    char *            ="0.000674"
+    char *            ="0.000610"
+    char *            ="0.000539"
+    char *            ="0.000463"
+    #
+    char *            ="0.000379"
+    char *            ="0.000288"
+    char *            ="0.000192"
+    char *            ="0.000088"
+    char *            ="-0.000021"
+    char *            ="-0.000137"
+    char *            ="-0.000260"
+    char *            ="-0.000388"
+    char *            ="-0.000522"
+    char *            ="-0.000662"
+    #
+    char *            ="-0.000807"
+    char *            ="-0.000957"
+    char *            ="-0.001111"
+    char *            ="-0.001270"
+    char *            ="-0.001432"
+    char *            ="-0.001598"
+    char *            ="-0.001767"
+    char *            ="-0.001937"
+    char *            ="-0.002110"
+    char *            ="-0.002283"
+    #
+    char *            ="-0.002457"
+    char *            ="-0.002631"
+    char *            ="-0.002803"
+    char *            ="-0.002974"
+    char *            ="-0.003142"
+    char *            ="-0.003307"
+    char *            ="-0.003467"
+    char *            ="-0.003623"
+    char *            ="-0.003772"
+    char *            ="-0.003914"
+    #
+    char *            ="-0.004049"
+    char *            ="-0.004175"
+    char *            ="-0.004291"
+    char *            ="-0.004396"
+    char *            ="-0.004490"
+    char *            ="-0.004570"
+    char *            ="-0.004638"
+    char *            ="-0.004691"
+    char *            ="-0.004728"
+    char *            ="-0.004749"
+    #
+    char *            ="-0.004752"
+    char *            ="-0.004737"
+    char *            ="-0.004703"
+    char *            ="-0.004649"
+    char *            ="-0.004574"
+    char *            ="-0.004477"
+    char *            ="-0.004358"
+    char *            ="-0.004215"
+    char *            ="-0.004049"
+    char *            ="-0.003859"
+    #
+    char *            ="-0.003643"
+    char *            ="-0.003402"
+    char *            ="0.003135"
+    char *            ="0.002841"
+    char *            ="0.002522"
+    char *            ="0.002175"
+    char *            ="0.001801"
+    char *            ="0.001400"
+    char *            ="0.000971"
+    char *            ="0.000516"
+    #
+    char *            ="0.000033"
+    char *            ="-0.000476"
+    char *            ="-0.001012"
+    char *            ="-0.001574"
+    char *            ="-0.002162"
+    char *            ="-0.002774"
+    char *            ="-0.003411"
+    char *            ="-0.004072"
+    char *            ="-0.004756"
+    char *            ="-0.005462"
+    #
+    char *            ="-0.006189"
+    char *            ="-0.006937"
+    char *            ="-0.007703"
+    char *            ="-0.008487"
+    char *            ="-0.009288"
+    char *            ="-0.010104"
+    char *            ="-0.010933"
+    char *            ="-0.011775"
+    char *            ="-0.012628"
+    char *            ="-0.013489"
+    #
+    char *            ="-0.014359"
+    char *            ="-0.015234"
+    char *            ="-0.016113"
+    char *            ="-0.016994"
+    char *            ="-0.017876"
+    char *            ="-0.018757"
+    char *            ="-0.019634"
+    char *            ="-0.020507"
+    char *            ="-0.021372"
+    char *            ="-0.022229"
+    #
+    char *            ="-0.023074"
+    char *            ="-0.023907"
+    char *            ="-0.024725"
+    char *            ="-0.025527"
+    char *            ="-0.026311"
+    char *            ="-0.027074"
+    char *            ="-0.027815"
+    char *            ="-0.028533"
+    char *            ="-0.029225"
+    char *            ="-0.029890"
+    #
+    char *            ="-0.030527"
+    char *            ="-0.031133"
+    char *            ="-0.031707"
+    char *            ="-0.032248"
+    char *            ="-0.032755"
+    char *            ="-0.033226"
+    char *            ="-0.033660"
+    char *            ="-0.034056"
+    char *            ="-0.034413"
+    char *            ="-0.034730"
+    #
+    char *            ="-0.035007"
+    char *            ="-0.035242"
+    char *            ="-0.035435"
+    char *            ="-0.035586"
+    char *            ="-0.035694"
+    char *            ="-0.035759"
+    char *            ="0.035781"
+    char *            ="0.035759"
+    char *            ="0.035694"
+    char *            ="0.035586"
+    #
+    char *            ="0.035435"
+    char *            ="0.035242"
+    char *            ="0.035007"
+    char *            ="0.034730"
+    char *            ="0.034413"
+    char *            ="0.034056"
+    char *            ="0.033660"
+    char *            ="0.033226"
+    char *            ="0.032755"
+    char *            ="0.032248"
+    #
+    char *            ="0.031707"
+    char *            ="0.031133"
+    char *            ="0.030527"
+    char *            ="0.029890"
+    char *            ="0.029225"
+    char *            ="0.028533"
+    char *            ="0.027815"
+    char *            ="0.027074"
+    char *            ="0.026311"
+    char *            ="0.025527"
+    #
+    char *            ="0.024725"
+    char *            ="0.023907"
+    char *            ="0.023074"
+    char *            ="0.022229"
+    char *            ="0.021372"
+    char *            ="0.020507"
+    char *            ="0.019634"
+    char *            ="0.018757"
+    char *            ="0.017876"
+    char *            ="0.016994"
+    #
+    char *            ="0.016113"
+    char *            ="0.015234"
+    char *            ="0.014359"
+    char *            ="0.013489"
+    char *            ="0.012628"
+    char *            ="0.011775"
+    char *            ="0.010933"
+    char *            ="0.010104"
+    char *            ="0.009288"
+    char *            ="0.008487"
+    #
+    char *            ="0.007703"
+    char *            ="0.006937"
+    char *            ="0.006189"
+    char *            ="0.005462"
+    char *            ="0.004756"
+    char *            ="0.004072"
+    char *            ="0.003411"
+    char *            ="0.002774"
+    char *            ="0.002162"
+    char *            ="0.001574"
+    #
+    char *            ="0.001012"
+    char *            ="0.000476"
+    char *            ="-0.000033"
+    char *            ="-0.000516"
+    char *            ="-0.000971"
+    char *            ="-0.001400"
+    char *            ="-0.001801"
+    char *            ="-0.002175"
+    char *            ="-0.002522"
+    char *            ="-0.002841"
+    #
+    char *            ="0.003135"
+    char *            ="0.003402"
+    char *            ="0.003643"
+    char *            ="0.003859"
+    char *            ="0.004049"
+    char *            ="0.004215"
+    char *            ="0.004358"
+    char *            ="0.004477"
+    char *            ="0.004574"
+    char *            ="0.004649"
+    #
+    char *            ="0.004703"
+    char *            ="0.004737"
+    char *            ="0.004752"
+    char *            ="0.004749"
+    char *            ="0.004728"
+    char *            ="0.004691"
+    char *            ="0.004638"
+    char *            ="0.004570"
+    char *            ="0.004490"
+    char *            ="0.004396"
+    #
+    char *            ="0.004291"
+    char *            ="0.004175"
+    char *            ="0.004049"
+    char *            ="0.003914"
+    char *            ="0.003772"
+    char *            ="0.003623"
+    char *            ="0.003467"
+    char *            ="0.003307"
+    char *            ="0.003142"
+    char *            ="0.002974"
+    #
+    char *            ="0.002803"
+    char *            ="0.002631"
+    char *            ="0.002457"
+    char *            ="0.002283"
+    char *            ="0.002110"
+    char *            ="0.001937"
+    char *            ="0.001767"
+    char *            ="0.001598"
+    char *            ="0.001432"
+    char *            ="0.001270"
+    #
+    char *            ="0.001111"
+    char *            ="0.000957"
+    char *            ="0.000807"
+    char *            ="0.000662"
+    char *            ="0.000522"
+    char *            ="0.000388"
+    char *            ="0.000260"
+    char *            ="0.000137"
+    char *            ="0.000021"
+    char *            ="-0.000088"
+    #
+    char *            ="-0.000192"
+    char *            ="-0.000288"
+    char *            ="-0.000379"
+    char *            ="-0.000463"
+    char *            ="-0.000539"
+    char *            ="-0.000610"
+    char *            ="-0.000674"
+    char *            ="-0.000732"
+    char *            ="-0.000784"
+    char *            ="-0.000829"
+    #
+    char *            ="-0.000869"
+    char *            ="-0.000903"
+    char *            ="-0.000931"
+    char *            ="-0.000954"
+    char *            ="0.000971"
+    char *            ="0.000984"
+    char *            ="0.000992"
+    char *            ="0.000995"
+    char *            ="0.000994"
+    char *            ="0.000989"
+    #
+    char *            ="0.000981"
+    char *            ="0.000969"
+    char *            ="0.000954"
+    char *            ="0.000936"
+    char *            ="0.000915"
+    char *            ="0.000892"
+    char *            ="0.000866"
+    char *            ="0.000839"
+    char *            ="0.000810"
+    char *            ="0.000779"
+    #
+    char *            ="0.000747"
+    char *            ="0.000714"
+    char *            ="0.000681"
+    char *            ="0.000647"
+    char *            ="0.000612"
+    char *            ="0.000577"
+    char *            ="0.000542"
+    char *            ="0.000507"
+    char *            ="0.000473"
+    char *            ="0.000438"
+    #
+    char *            ="0.000404"
+    char *            ="0.000371"
+    char *            ="0.000339"
+    char *            ="0.000308"
+    char *            ="0.000277"
+    char *            ="0.000247"
+    char *            ="0.000219"
+    char *            ="0.000191"
+    char *            ="0.000165"
+    char *            ="0.000140"
+    #
+    char *            ="0.000116"
+    char *            ="0.000094"
+    char *            ="0.000073"
+    char *            ="0.000053"
+    char *            ="0.000034"
+    char *            ="0.000017"
+    char *            ="0.000001"
+    char *            ="-0.000014"
+    char *            ="-0.000027"
+    char *            ="-0.000040"
+    #
+    char *            ="-0.000051"
+    char *            ="-0.000061"
+    char *            ="-0.000070"
+    char *            ="-0.000078"
+    char *            ="-0.000084"
+    char *            ="-0.000090"
+    char *            ="-0.000095"
+    char *            ="-0.000099"
+    char *            ="-0.000103"
+    char *            ="-0.000105"
+    #
+    char *            ="-0.000107"
+    char *            ="-0.000108"
+    char *            ="-0.000109"
+    char *            ="-0.000109"
+    char *            ="-0.000108"
+    char *            ="-0.000107"
+    char *            ="-0.000106"
+    char *            ="-0.000104"
+    char *            ="0.000102"
+    char *            ="0.000099"
+    #
+    char *            ="0.000096"
+    char *            ="0.000093"
+    char *            ="0.000091"
+    char *            ="0.000087"
+    char *            ="0.000084"
+    char *            ="0.000081"
+    char *            ="0.000077"
+    char *            ="0.000073"
+    char *            ="0.000070"
+    char *            ="0.000066"
+    #
+    char *            ="0.000063"
+    char *            ="0.000060"
+    char *            ="0.000056"
+    char *            ="0.000053"
+    char *            ="0.000050"
+    char *            ="0.000046"
+    char *            ="0.000043"
+    char *            ="0.000041"
+    char *            ="0.000038"
+    char *            ="0.000035"
+    #
+    char *            ="0.000032"
+    char *            ="0.000030"
+    char *            ="0.000028"
+    char *            ="0.000025"
+    char *            ="0.000023"
+    char *            ="0.000021"
+    char *            ="0.000020"
+    char *            ="0.000018"
+    char *            ="0.000017"
+    char *            ="0.000015"
+    #
+    char *            ="0.000014"
+    char *            ="0.000012"
+    char *            ="0.000011"
+    char *            ="0.000010"
+    char *            ="0.000009"
+    char *            ="0.000008"
+    char *            ="0.000008"
+    char *            ="0.000007"
+    char *            ="0.000006"
+    char *            ="0.000005"
+    #
+    char *            ="0.000005"
+    char *            ="0.000004"
+    char *            ="0.000004"
+    char *            ="0.000003"
+    char *            ="0.000003"
+    char *            ="0.000003"
+    char *            ="0.000002"
+    char *            ="0.000002"
+    char *            ="0.000002"
+    char *            ="0.000002"
+    #
+    char *            ="0.000001"
+    char *            ="0.000001"
+    char *            ="0.000001"
+    char *            ="0.000001"
+    char *            ="0.000001"
+    char *            ="0.000001"
+    char *            ="0.000000"
+    char *            ="0.000000"
+    char *            ="0.000000"
+    char *            ="0.000000"
+    #
+    char *            ="0.000000"
+    char *            ="0.000000"
+    data p^enwindow_data
+    return p
+endfunction
+
+
+function scalefac_band_long()
+    #Table B.8.c: 48 kHz
+    data band={0,4,8,12,16,20,24,30,36,42,50,60,72,88,106,128,156,190,230,276,330,384,576}
+    data p^band
+    return p
+endfunction
+function scalefac_band_long_get(sd index)
+    sd tab
+    setcall tab scalefac_band_long()
+    mult index (DWORD)
+    add tab index
+    return tab#
+endfunction
+
+function subdv_table(sd index,sd number)
+    #[23]
+    data r={0, 0}
+    data *={0, 0}
+    data *={0, 0}
+    data *={0, 0}
+    data *={0, 0}
+    data *={0, 1}
+    data *={1, 1}
+    data *={1, 1}
+    data *={1, 2}
+    data *={2, 2}
+    data *={2, 3}
+    data *={2, 3}
+    data *={3, 4}
+    data *={3, 4}
+    data *={3, 4}
+    data *={4, 5}
+    data *={4, 5}
+    data *={4, 6}
+    data *={5, 6}
+    data *={5, 6}
+    data *={5, 7}
+    data *={6, 7}
+    data *={6, 7}
+    sd p^r
+    mult index (2*DWORD)
+    add p index
+    mult number (DWORD)
+    add p number
+    return p#
+endfunction
--- ovideo-1.orig/src/media/mpeg-mp3_tables.s
+++ /dev/null
@@ -1,621 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-function mp3_tables_enwindow()
-    char enwindow_data="0.000000"
-    char *            ="-0.000000"
-    char *            ="-0.000000"
-    char *            ="-0.000000"
-    char *            ="-0.000000"
-    char *            ="-0.000000"
-    char *            ="-0.000000"
-    char *            ="-0.000001"
-    char *            ="-0.000001"
-    char *            ="-0.000001"
-    #
-    char *            ="-0.000001"
-    char *            ="-0.000001"
-    char *            ="-0.000001"
-    char *            ="-0.000002"
-    char *            ="-0.000002"
-    char *            ="-0.000002"
-    char *            ="-0.000002"
-    char *            ="-0.000003"
-    char *            ="-0.000003"
-    char *            ="-0.000003"
-    #
-    char *            ="-0.000004"
-    char *            ="-0.000004"
-    char *            ="-0.000005"
-    char *            ="-0.000005"
-    char *            ="-0.000006"
-    char *            ="-0.000007"
-    char *            ="-0.000008"
-    char *            ="-0.000008"
-    char *            ="-0.000009"
-    char *            ="-0.000010"
-    #
-    char *            ="-0.000011"
-    char *            ="-0.000012"
-    char *            ="-0.000014"
-    char *            ="-0.000015"
-    char *            ="-0.000017"
-    char *            ="-0.000018"
-    char *            ="-0.000020"
-    char *            ="-0.000021"
-    char *            ="-0.000023"
-    char *            ="-0.000025"
-    #
-    char *            ="-0.000028"
-    char *            ="-0.000030"
-    char *            ="-0.000032"
-    char *            ="-0.000035"
-    char *            ="-0.000038"
-    char *            ="-0.000041"
-    char *            ="-0.000043"
-    char *            ="-0.000046"
-    char *            ="-0.000050"
-    char *            ="-0.000053"
-    #
-    char *            ="-0.000056"
-    char *            ="-0.000060"
-    char *            ="-0.000063"
-    char *            ="-0.000066"
-    char *            ="-0.000070"
-    char *            ="-0.000073"
-    char *            ="-0.000077"
-    char *            ="-0.000081"
-    char *            ="-0.000084"
-    char *            ="-0.000087"
-    #
-    char *            ="-0.000091"
-    char *            ="-0.000093"
-    char *            ="-0.000096"
-    char *            ="-0.000099"
-    char *            ="0.000102"
-    char *            ="0.000104"
-    char *            ="0.000106"
-    char *            ="0.000107"
-    char *            ="0.000108"
-    char *            ="0.000109"
-    #
-    char *            ="0.000109"
-    char *            ="0.000108"
-    char *            ="0.000107"
-    char *            ="0.000105"
-    char *            ="0.000103"
-    char *            ="0.000099"
-    char *            ="0.000095"
-    char *            ="0.000090"
-    char *            ="0.000084"
-    char *            ="0.000078"
-    #
-    char *            ="0.000070"
-    char *            ="0.000061"
-    char *            ="0.000051"
-    char *            ="0.000040"
-    char *            ="0.000027"
-    char *            ="0.000014"
-    char *            ="-0.000001"
-    char *            ="-0.000017"
-    char *            ="-0.000034"
-    char *            ="-0.000053"
-    #
-    char *            ="-0.000073"
-    char *            ="-0.000094"
-    char *            ="-0.000116"
-    char *            ="-0.000140"
-    char *            ="-0.000165"
-    char *            ="-0.000191"
-    char *            ="-0.000219"
-    char *            ="-0.000247"
-    char *            ="-0.000277"
-    char *            ="-0.000308"
-    #
-    char *            ="-0.000339"
-    char *            ="-0.000371"
-    char *            ="-0.000404"
-    char *            ="-0.000438"
-    char *            ="-0.000473"
-    char *            ="-0.000507"
-    char *            ="-0.000542"
-    char *            ="-0.000577"
-    char *            ="-0.000612"
-    char *            ="-0.000647"
-    #
-    char *            ="-0.000681"
-    char *            ="-0.000714"
-    char *            ="-0.000747"
-    char *            ="-0.000779"
-    char *            ="-0.000810"
-    char *            ="-0.000839"
-    char *            ="-0.000866"
-    char *            ="-0.000892"
-    char *            ="-0.000915"
-    char *            ="-0.000936"
-    #
-    char *            ="-0.000954"
-    char *            ="-0.000969"
-    char *            ="-0.000981"
-    char *            ="-0.000989"
-    char *            ="-0.000994"
-    char *            ="-0.000995"
-    char *            ="-0.000992"
-    char *            ="-0.000984"
-    char *            ="0.000971"
-    char *            ="0.000954"
-    #
-    char *            ="0.000931"
-    char *            ="0.000903"
-    char *            ="0.000869"
-    char *            ="0.000829"
-    char *            ="0.000784"
-    char *            ="0.000732"
-    char *            ="0.000674"
-    char *            ="0.000610"
-    char *            ="0.000539"
-    char *            ="0.000463"
-    #
-    char *            ="0.000379"
-    char *            ="0.000288"
-    char *            ="0.000192"
-    char *            ="0.000088"
-    char *            ="-0.000021"
-    char *            ="-0.000137"
-    char *            ="-0.000260"
-    char *            ="-0.000388"
-    char *            ="-0.000522"
-    char *            ="-0.000662"
-    #
-    char *            ="-0.000807"
-    char *            ="-0.000957"
-    char *            ="-0.001111"
-    char *            ="-0.001270"
-    char *            ="-0.001432"
-    char *            ="-0.001598"
-    char *            ="-0.001767"
-    char *            ="-0.001937"
-    char *            ="-0.002110"
-    char *            ="-0.002283"
-    #
-    char *            ="-0.002457"
-    char *            ="-0.002631"
-    char *            ="-0.002803"
-    char *            ="-0.002974"
-    char *            ="-0.003142"
-    char *            ="-0.003307"
-    char *            ="-0.003467"
-    char *            ="-0.003623"
-    char *            ="-0.003772"
-    char *            ="-0.003914"
-    #
-    char *            ="-0.004049"
-    char *            ="-0.004175"
-    char *            ="-0.004291"
-    char *            ="-0.004396"
-    char *            ="-0.004490"
-    char *            ="-0.004570"
-    char *            ="-0.004638"
-    char *            ="-0.004691"
-    char *            ="-0.004728"
-    char *            ="-0.004749"
-    #
-    char *            ="-0.004752"
-    char *            ="-0.004737"
-    char *            ="-0.004703"
-    char *            ="-0.004649"
-    char *            ="-0.004574"
-    char *            ="-0.004477"
-    char *            ="-0.004358"
-    char *            ="-0.004215"
-    char *            ="-0.004049"
-    char *            ="-0.003859"
-    #
-    char *            ="-0.003643"
-    char *            ="-0.003402"
-    char *            ="0.003135"
-    char *            ="0.002841"
-    char *            ="0.002522"
-    char *            ="0.002175"
-    char *            ="0.001801"
-    char *            ="0.001400"
-    char *            ="0.000971"
-    char *            ="0.000516"
-    #
-    char *            ="0.000033"
-    char *            ="-0.000476"
-    char *            ="-0.001012"
-    char *            ="-0.001574"
-    char *            ="-0.002162"
-    char *            ="-0.002774"
-    char *            ="-0.003411"
-    char *            ="-0.004072"
-    char *            ="-0.004756"
-    char *            ="-0.005462"
-    #
-    char *            ="-0.006189"
-    char *            ="-0.006937"
-    char *            ="-0.007703"
-    char *            ="-0.008487"
-    char *            ="-0.009288"
-    char *            ="-0.010104"
-    char *            ="-0.010933"
-    char *            ="-0.011775"
-    char *            ="-0.012628"
-    char *            ="-0.013489"
-    #
-    char *            ="-0.014359"
-    char *            ="-0.015234"
-    char *            ="-0.016113"
-    char *            ="-0.016994"
-    char *            ="-0.017876"
-    char *            ="-0.018757"
-    char *            ="-0.019634"
-    char *            ="-0.020507"
-    char *            ="-0.021372"
-    char *            ="-0.022229"
-    #
-    char *            ="-0.023074"
-    char *            ="-0.023907"
-    char *            ="-0.024725"
-    char *            ="-0.025527"
-    char *            ="-0.026311"
-    char *            ="-0.027074"
-    char *            ="-0.027815"
-    char *            ="-0.028533"
-    char *            ="-0.029225"
-    char *            ="-0.029890"
-    #
-    char *            ="-0.030527"
-    char *            ="-0.031133"
-    char *            ="-0.031707"
-    char *            ="-0.032248"
-    char *            ="-0.032755"
-    char *            ="-0.033226"
-    char *            ="-0.033660"
-    char *            ="-0.034056"
-    char *            ="-0.034413"
-    char *            ="-0.034730"
-    #
-    char *            ="-0.035007"
-    char *            ="-0.035242"
-    char *            ="-0.035435"
-    char *            ="-0.035586"
-    char *            ="-0.035694"
-    char *            ="-0.035759"
-    char *            ="0.035781"
-    char *            ="0.035759"
-    char *            ="0.035694"
-    char *            ="0.035586"
-    #
-    char *            ="0.035435"
-    char *            ="0.035242"
-    char *            ="0.035007"
-    char *            ="0.034730"
-    char *            ="0.034413"
-    char *            ="0.034056"
-    char *            ="0.033660"
-    char *            ="0.033226"
-    char *            ="0.032755"
-    char *            ="0.032248"
-    #
-    char *            ="0.031707"
-    char *            ="0.031133"
-    char *            ="0.030527"
-    char *            ="0.029890"
-    char *            ="0.029225"
-    char *            ="0.028533"
-    char *            ="0.027815"
-    char *            ="0.027074"
-    char *            ="0.026311"
-    char *            ="0.025527"
-    #
-    char *            ="0.024725"
-    char *            ="0.023907"
-    char *            ="0.023074"
-    char *            ="0.022229"
-    char *            ="0.021372"
-    char *            ="0.020507"
-    char *            ="0.019634"
-    char *            ="0.018757"
-    char *            ="0.017876"
-    char *            ="0.016994"
-    #
-    char *            ="0.016113"
-    char *            ="0.015234"
-    char *            ="0.014359"
-    char *            ="0.013489"
-    char *            ="0.012628"
-    char *            ="0.011775"
-    char *            ="0.010933"
-    char *            ="0.010104"
-    char *            ="0.009288"
-    char *            ="0.008487"
-    #
-    char *            ="0.007703"
-    char *            ="0.006937"
-    char *            ="0.006189"
-    char *            ="0.005462"
-    char *            ="0.004756"
-    char *            ="0.004072"
-    char *            ="0.003411"
-    char *            ="0.002774"
-    char *            ="0.002162"
-    char *            ="0.001574"
-    #
-    char *            ="0.001012"
-    char *            ="0.000476"
-    char *            ="-0.000033"
-    char *            ="-0.000516"
-    char *            ="-0.000971"
-    char *            ="-0.001400"
-    char *            ="-0.001801"
-    char *            ="-0.002175"
-    char *            ="-0.002522"
-    char *            ="-0.002841"
-    #
-    char *            ="0.003135"
-    char *            ="0.003402"
-    char *            ="0.003643"
-    char *            ="0.003859"
-    char *            ="0.004049"
-    char *            ="0.004215"
-    char *            ="0.004358"
-    char *            ="0.004477"
-    char *            ="0.004574"
-    char *            ="0.004649"
-    #
-    char *            ="0.004703"
-    char *            ="0.004737"
-    char *            ="0.004752"
-    char *            ="0.004749"
-    char *            ="0.004728"
-    char *            ="0.004691"
-    char *            ="0.004638"
-    char *            ="0.004570"
-    char *            ="0.004490"
-    char *            ="0.004396"
-    #
-    char *            ="0.004291"
-    char *            ="0.004175"
-    char *            ="0.004049"
-    char *            ="0.003914"
-    char *            ="0.003772"
-    char *            ="0.003623"
-    char *            ="0.003467"
-    char *            ="0.003307"
-    char *            ="0.003142"
-    char *            ="0.002974"
-    #
-    char *            ="0.002803"
-    char *            ="0.002631"
-    char *            ="0.002457"
-    char *            ="0.002283"
-    char *            ="0.002110"
-    char *            ="0.001937"
-    char *            ="0.001767"
-    char *            ="0.001598"
-    char *            ="0.001432"
-    char *            ="0.001270"
-    #
-    char *            ="0.001111"
-    char *            ="0.000957"
-    char *            ="0.000807"
-    char *            ="0.000662"
-    char *            ="0.000522"
-    char *            ="0.000388"
-    char *            ="0.000260"
-    char *            ="0.000137"
-    char *            ="0.000021"
-    char *            ="-0.000088"
-    #
-    char *            ="-0.000192"
-    char *            ="-0.000288"
-    char *            ="-0.000379"
-    char *            ="-0.000463"
-    char *            ="-0.000539"
-    char *            ="-0.000610"
-    char *            ="-0.000674"
-    char *            ="-0.000732"
-    char *            ="-0.000784"
-    char *            ="-0.000829"
-    #
-    char *            ="-0.000869"
-    char *            ="-0.000903"
-    char *            ="-0.000931"
-    char *            ="-0.000954"
-    char *            ="0.000971"
-    char *            ="0.000984"
-    char *            ="0.000992"
-    char *            ="0.000995"
-    char *            ="0.000994"
-    char *            ="0.000989"
-    #
-    char *            ="0.000981"
-    char *            ="0.000969"
-    char *            ="0.000954"
-    char *            ="0.000936"
-    char *            ="0.000915"
-    char *            ="0.000892"
-    char *            ="0.000866"
-    char *            ="0.000839"
-    char *            ="0.000810"
-    char *            ="0.000779"
-    #
-    char *            ="0.000747"
-    char *            ="0.000714"
-    char *            ="0.000681"
-    char *            ="0.000647"
-    char *            ="0.000612"
-    char *            ="0.000577"
-    char *            ="0.000542"
-    char *            ="0.000507"
-    char *            ="0.000473"
-    char *            ="0.000438"
-    #
-    char *            ="0.000404"
-    char *            ="0.000371"
-    char *            ="0.000339"
-    char *            ="0.000308"
-    char *            ="0.000277"
-    char *            ="0.000247"
-    char *            ="0.000219"
-    char *            ="0.000191"
-    char *            ="0.000165"
-    char *            ="0.000140"
-    #
-    char *            ="0.000116"
-    char *            ="0.000094"
-    char *            ="0.000073"
-    char *            ="0.000053"
-    char *            ="0.000034"
-    char *            ="0.000017"
-    char *            ="0.000001"
-    char *            ="-0.000014"
-    char *            ="-0.000027"
-    char *            ="-0.000040"
-    #
-    char *            ="-0.000051"
-    char *            ="-0.000061"
-    char *            ="-0.000070"
-    char *            ="-0.000078"
-    char *            ="-0.000084"
-    char *            ="-0.000090"
-    char *            ="-0.000095"
-    char *            ="-0.000099"
-    char *            ="-0.000103"
-    char *            ="-0.000105"
-    #
-    char *            ="-0.000107"
-    char *            ="-0.000108"
-    char *            ="-0.000109"
-    char *            ="-0.000109"
-    char *            ="-0.000108"
-    char *            ="-0.000107"
-    char *            ="-0.000106"
-    char *            ="-0.000104"
-    char *            ="0.000102"
-    char *            ="0.000099"
-    #
-    char *            ="0.000096"
-    char *            ="0.000093"
-    char *            ="0.000091"
-    char *            ="0.000087"
-    char *            ="0.000084"
-    char *            ="0.000081"
-    char *            ="0.000077"
-    char *            ="0.000073"
-    char *            ="0.000070"
-    char *            ="0.000066"
-    #
-    char *            ="0.000063"
-    char *            ="0.000060"
-    char *            ="0.000056"
-    char *            ="0.000053"
-    char *            ="0.000050"
-    char *            ="0.000046"
-    char *            ="0.000043"
-    char *            ="0.000041"
-    char *            ="0.000038"
-    char *            ="0.000035"
-    #
-    char *            ="0.000032"
-    char *            ="0.000030"
-    char *            ="0.000028"
-    char *            ="0.000025"
-    char *            ="0.000023"
-    char *            ="0.000021"
-    char *            ="0.000020"
-    char *            ="0.000018"
-    char *            ="0.000017"
-    char *            ="0.000015"
-    #
-    char *            ="0.000014"
-    char *            ="0.000012"
-    char *            ="0.000011"
-    char *            ="0.000010"
-    char *            ="0.000009"
-    char *            ="0.000008"
-    char *            ="0.000008"
-    char *            ="0.000007"
-    char *            ="0.000006"
-    char *            ="0.000005"
-    #
-    char *            ="0.000005"
-    char *            ="0.000004"
-    char *            ="0.000004"
-    char *            ="0.000003"
-    char *            ="0.000003"
-    char *            ="0.000003"
-    char *            ="0.000002"
-    char *            ="0.000002"
-    char *            ="0.000002"
-    char *            ="0.000002"
-    #
-    char *            ="0.000001"
-    char *            ="0.000001"
-    char *            ="0.000001"
-    char *            ="0.000001"
-    char *            ="0.000001"
-    char *            ="0.000001"
-    char *            ="0.000000"
-    char *            ="0.000000"
-    char *            ="0.000000"
-    char *            ="0.000000"
-    #
-    char *            ="0.000000"
-    char *            ="0.000000"
-    data p^enwindow_data
-    return p
-endfunction
-
-
-function scalefac_band_long()
-    #Table B.8.c: 48 kHz
-    data band={0,4,8,12,16,20,24,30,36,42,50,60,72,88,106,128,156,190,230,276,330,384,576}
-    data p^band
-    return p
-endfunction
-function scalefac_band_long_get(sd index)
-    sd tab
-    setcall tab scalefac_band_long()
-    mult index (DWORD)
-    add tab index
-    return tab#
-endfunction
-
-function subdv_table(sd index,sd number)
-    #[23]
-    data r={0, 0}
-    data *={0, 0}
-    data *={0, 0}
-    data *={0, 0}
-    data *={0, 0}
-    data *={0, 1}
-    data *={1, 1}
-    data *={1, 1}
-    data *={1, 2}
-    data *={2, 2}
-    data *={2, 3}
-    data *={2, 3}
-    data *={3, 4}
-    data *={3, 4}
-    data *={3, 4}
-    data *={4, 5}
-    data *={4, 5}
-    data *={4, 6}
-    data *={5, 6}
-    data *={5, 6}
-    data *={5, 7}
-    data *={6, 7}
-    data *={6, 7}
-    sd p^r
-    mult index (2*DWORD)
-    add p index
-    mult number (DWORD)
-    add p number
-    return p#
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg-mp3_wrap.oc
@@ -0,0 +1,164 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+#bool
+function mp3_init()
+    import "mp3_output" mp3_output
+    import "mp3_allsize" mp3_allsize
+    sd output
+    const BUFFER_SIZE=4096
+    sd size=BUFFER_SIZE
+    import "memalloc" memalloc
+    setcall output memalloc(size)
+    if output=0
+        return 0
+    endif
+    call mp3_output((value_set),output)
+    call mp3_allsize((value_set),size)
+
+    import "l3_subband_init" l3_subband_init
+    call l3_subband_init()
+    import "l3_mdct_init" l3_mdct_init
+    call l3_mdct_init()
+    call l3_loop_init()
+
+    import "mp3_encode_init" mp3_encode_init
+    call mp3_encode_init()
+
+    return 1
+endfunction
+
+importx "_free" free
+
+function mp3_free()
+    sd output
+    setcall output mp3_output((value_get))
+    call free(output)
+endfunction
+
+import "fild" fild
+import "fstp_quad" fstp_quad
+importx "_sqrt" sqrt
+import "str_to_double" str_to_double
+import "fimul" fimul
+import "fsub_quad" fsub_quad
+import "fadd_quad" fadd_quad
+import "fdiv_quad" fdiv_quad
+importx "_pow" pow
+import "fst_quad" fst_quad
+import "fcom_quad_greater" fcom_quad_greater
+
+function l3_loop_init()
+    call mp3_steptab_init()
+    call mp3_int2idx_init()
+    import "mp3_quantize_init" mp3_quantize_init
+    call mp3_quantize_init()
+endfunction
+
+import "double_to_int" double_to_int
+
+function mp3_steptab_init()
+    import "mp3_steptab_double" mp3_steptab_double
+    import "mp3_steptabi" mp3_steptabi
+    sd steptab_double
+    sd steptabi
+    setcall steptab_double mp3_steptab_double()
+    setcall steptabi mp3_steptabi()
+    add steptab_double (128*QWORD)
+    add steptabi (128*DWORD)
+    sd value
+    sd p_value^value
+    #
+    data double_low#1
+    data double_high#1
+    data double^double_low
+    data const1_low#1
+    data *const1_high#1
+    data const1^const1_low
+    str str_const1="4"
+    call str_to_double(str_const1,const1)
+    data const2_low#1
+    data const2_high#1
+    data const2^const2_low
+    str str_const2="2.0"
+    call str_to_double(str_const2,const2)
+    data const3_low#1
+    data *const3_high#1
+    data const3^const3_low
+    #0x7fFFffFF
+    str str_const3="2147483647"
+    call str_to_double(str_const3,const3)
+    data const4_low#1
+    data *const4_high#1
+    data const4^const4_low
+    str str_const4="0.5"
+    call str_to_double(str_const4,const4)
+    #
+    sd i=128
+    while i!=0
+        dec i
+        sub steptab_double (QWORD)
+        sub steptabi (DWORD)
+        #
+        set value 127
+        sub value i
+        call fild(p_value)
+        call fdiv_quad(const1)
+        call fstp_quad(double)
+        call pow(const2_low,const2_high,double_low,double_high)
+        call fst_quad(double)
+        call fst_quad(steptab_double)
+        call fadd_quad(double)
+        sd bool
+        setcall bool fcom_quad_greater(const3)
+        if bool=1
+            set steptabi# 0x7fFFffFF
+        else
+            call fadd_quad(const4)
+            #call fistp(steptabi)
+            call fstp_quad(double)
+            setcall steptabi# double_to_int(double)
+        endelse
+    endwhile
+endfunction
+
+function mp3_int2idx_init()
+    data double_low#1
+    data double_high#1
+    data double^double_low
+    data const1_low#1
+    data *const1_high#1
+    data const2_low#1
+    data *const2_high#1
+    data const1^const1_low
+    data const2^const2_low
+    str str_const1="0.0946"
+    str str_const2="0.5"
+    call str_to_double(str_const1,const1)
+    call str_to_double(str_const2,const2)
+    import "mp3_int2idx" mp3_int2idx
+    sd int2idx
+    setcall int2idx mp3_int2idx()
+    add int2idx (10000*DWORD)
+    sd i=10000
+    sd p_i^i
+    while i!=0
+        sub int2idx (DWORD)
+        dec i
+        #
+        call fild(p_i)
+        call fstp_quad(double)
+        call sqrt(double_low,double_high)
+        call fimul(p_i)
+        call fstp_quad(double)
+        call sqrt(double_low,double_high)
+        call fsub_quad(const1)
+        call fadd_quad(const2)
+        #call fistp(int2idx)
+        call fstp_quad(double)
+        setcall int2idx# double_to_int(double)
+    endwhile
+endfunction
--- ovideo-1.orig/src/media/mpeg-mp3_wrap.s
+++ /dev/null
@@ -1,164 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-#bool
-function mp3_init()
-    import "mp3_output" mp3_output
-    import "mp3_allsize" mp3_allsize
-    sd output
-    const BUFFER_SIZE=4096
-    sd size=BUFFER_SIZE
-    import "memalloc" memalloc
-    setcall output memalloc(size)
-    if output==0
-        return 0
-    endif
-    call mp3_output((value_set),output)
-    call mp3_allsize((value_set),size)
-
-    import "l3_subband_init" l3_subband_init
-    call l3_subband_init()
-    import "l3_mdct_init" l3_mdct_init
-    call l3_mdct_init()
-    call l3_loop_init()
-
-    import "mp3_encode_init" mp3_encode_init
-    call mp3_encode_init()
-
-    return 1
-endfunction
-
-importx "_free" free
-
-function mp3_free()
-    sd output
-    setcall output mp3_output((value_get))
-    call free(output)
-endfunction
-
-import "fild" fild
-import "fstp_quad" fstp_quad
-importx "_sqrt" sqrt
-import "str_to_double" str_to_double
-import "fimul" fimul
-import "fsub_quad" fsub_quad
-import "fadd_quad" fadd_quad
-import "fdiv_quad" fdiv_quad
-importx "_pow" pow
-import "fst_quad" fst_quad
-import "fcom_quad_greater" fcom_quad_greater
-
-function l3_loop_init()
-    call mp3_steptab_init()
-    call mp3_int2idx_init()
-    import "mp3_quantize_init" mp3_quantize_init
-    call mp3_quantize_init()
-endfunction
-
-import "double_to_int" double_to_int
-
-function mp3_steptab_init()
-    import "mp3_steptab_double" mp3_steptab_double
-    import "mp3_steptabi" mp3_steptabi
-    sd steptab_double
-    sd steptabi
-    setcall steptab_double mp3_steptab_double()
-    setcall steptabi mp3_steptabi()
-    add steptab_double (128*QWORD)
-    add steptabi (128*DWORD)
-    sd value
-    sd p_value^value
-    #
-    data double_low#1
-    data double_high#1
-    data double^double_low
-    data const1_low#1
-    data *const1_high#1
-    data const1^const1_low
-    str str_const1="4"
-    call str_to_double(str_const1,const1)
-    data const2_low#1
-    data const2_high#1
-    data const2^const2_low
-    str str_const2="2.0"
-    call str_to_double(str_const2,const2)
-    data const3_low#1
-    data *const3_high#1
-    data const3^const3_low
-    #0x7fFFffFF
-    str str_const3="2147483647"
-    call str_to_double(str_const3,const3)
-    data const4_low#1
-    data *const4_high#1
-    data const4^const4_low
-    str str_const4="0.5"
-    call str_to_double(str_const4,const4)
-    #
-    sd i=128
-    while i!=0
-        dec i
-        sub steptab_double (QWORD)
-        sub steptabi (DWORD)
-        #
-        set value 127
-        sub value i
-        call fild(p_value)
-        call fdiv_quad(const1)
-        call fstp_quad(double)
-        call pow(const2_low,const2_high,double_low,double_high)
-        call fst_quad(double)
-        call fst_quad(steptab_double)
-        call fadd_quad(double)
-        sd bool
-        setcall bool fcom_quad_greater(const3)
-        if bool==1
-            set steptabi# 0x7fFFffFF
-        else
-            call fadd_quad(const4)
-            #call fistp(steptabi)
-            call fstp_quad(double)
-            setcall steptabi# double_to_int(double)
-        endelse
-    endwhile
-endfunction
-
-function mp3_int2idx_init()
-    data double_low#1
-    data double_high#1
-    data double^double_low
-    data const1_low#1
-    data *const1_high#1
-    data const2_low#1
-    data *const2_high#1
-    data const1^const1_low
-    data const2^const2_low
-    str str_const1="0.0946"
-    str str_const2="0.5"
-    call str_to_double(str_const1,const1)
-    call str_to_double(str_const2,const2)
-    import "mp3_int2idx" mp3_int2idx
-    sd int2idx
-    setcall int2idx mp3_int2idx()
-    add int2idx (10000*DWORD)
-    sd i=10000
-    sd p_i^i
-    while i!=0
-        sub int2idx (DWORD)
-        dec i
-        #
-        call fild(p_i)
-        call fstp_quad(double)
-        call sqrt(double_low,double_high)
-        call fimul(p_i)
-        call fstp_quad(double)
-        call sqrt(double_low,double_high)
-        call fsub_quad(const1)
-        call fadd_quad(const2)
-        #call fistp(int2idx)
-        call fstp_quad(double)
-        setcall int2idx# double_to_int(double)
-    endwhile
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg.oc
@@ -0,0 +1,1555 @@
+
+format elfobj
+
+
+#MPEG-4 encoder
+
+include "../_include/include.h"
+
+import "shl" shl
+import "shr" shr
+
+const ARG_SLICES=1
+const ARG_BQRATIO=150
+const ARG_BQOFFSET=100
+const ARG_MAXBFRAMES=2
+const ARG_MAXKEYINTERVAL=300
+
+const value_rgbtoyuv=value_custom
+const value_endinterval=value_custom
+
+
+##init
+
+#bool
+function mpeg_init(sd file,sd pixbufSample,sd totalframes)
+    import "macro_blocks" macro_blocks
+
+    data filemem#1
+    set filemem 0
+    data inputmem#1
+    set inputmem 0
+    data macroblocks#1
+    set macroblocks 0
+
+    call mpeg_start(file,pixbufSample)
+    call mpeg_lastframe((value_set),totalframes)
+
+    sd bool
+    setcall bool mpeg_file_mem((value_set))
+    if bool=1
+        set filemem 1
+        setcall bool mpeg_input_mem((value_set))
+        if bool=1
+            set inputmem 1
+            setcall bool macro_blocks((value_set))
+            if bool=1
+                return 1
+            endif
+        endif
+    endif
+
+    if filemem=0
+        return 0
+    endif
+    call mpeg_file_mem((value_unset))
+    if inputmem=0
+        return 0
+    endif
+    call mpeg_input_mem((value_unset))
+    if macroblocks=0
+        return 0
+    endif
+    call macro_blocks((value_unset))
+    return 0
+endfunction
+
+#bool
+function mpeg_encode(sd pixbuf,sd position,sd p_is_key_frame)
+    data b#1
+    data p_b^b
+    sd bool
+    setcall bool mpeg_write_frame(p_b,pixbuf,position,p_is_key_frame)
+    return bool
+endfunction
+
+function mpeg_release()
+    call mpeg_file_mem((value_unset))
+    call mpeg_input_mem((value_unset))
+    call macro_blocks((value_unset))
+endfunction
+
+
+function mpeg_lastframe(sd action,sd value)
+    data lastframe#1
+    if action=(value_set)
+        dec value
+        set lastframe value
+    else
+        return lastframe
+    endelse
+endfunction
+function mpeg_start(sd file,sd pixbufSample)
+    #store output file
+    call mpeg_write_file((value_set),file)
+    #store sizes
+    sd w
+    sd h
+    sd wh^w
+    import "pixbuf_get_wh" pixbuf_get_wh
+    call pixbuf_get_wh(pixbufSample,wh)
+    import "yuv_get_size" yuv_get_size
+    sd size
+    setcall size yuv_get_size(w,h)
+        #get yuv size based on pixbuf and alloc the mpeg4 buffer, mult with 2 for safety
+    mult size 2
+    call mpeg_buffer_size((value_set),size,w,h)
+    #init vlc tables
+    import "mpeg_init_vlc" mpeg_init_vlc
+    call mpeg_init_vlc()
+    #init time
+    call mpeg_time((value_set),0)
+endfunction
+
+const value_is_key=value_custom
+function mpeg_ptr_is_keyframe(sd action,sd value)
+    data ptr_is_keyframe#1
+    if action=(value_set)
+        set ptr_is_keyframe value
+        set ptr_is_keyframe# 0
+    else
+        #if action==(value_is_key)
+        set ptr_is_keyframe# 1
+    endelse
+endfunction
+
+#bool
+function mpeg_write_frame(sd p_bframes,sd argument,sd frameindex,sd p_is_key_frame)
+    sd ind
+    sd bool
+    data sec#1
+    data p_sec^sec
+    data nth_sec#1
+    data p_nth_sec^nth_sec
+    data ivop_comeback#1
+    data ivop_frameindex#1
+    data ivop_pixbuf#1
+    data ivop_wait_bframes#1
+
+    ##bframes store data
+    data bframes_counter#1
+    const bframes_data_mix_size=3
+    #seconds and nth_of_sec and pixbuf
+    data bframes_store_data#ARG_MAXBFRAMES*bframes_data_mix_size
+    data bframes_store^bframes_store_data
+
+    ##set last frame
+    sd framelast
+    setcall framelast mpeg_lastframe((value_get))
+
+    ##reset keyflag
+    call mpeg_ptr_is_keyframe((value_set),p_is_key_frame)
+
+    ##flush bframes
+    if p_bframes=0
+        set p_bframes argument
+
+        if ivop_comeback=1
+            if ivop_wait_bframes=0
+                ##add passed frames
+                call mpeg_time((value_append),ivop_frameindex)
+                ##get new time
+                setcall nth_sec mpeg_time((value_get),p_sec)
+                ##write frame
+                setcall bool mpeg_frame_object((I_VOP),sec,nth_sec,ivop_pixbuf,0)
+                if bool!=1
+                    return 0
+                endif
+                set p_bframes# 0
+                return 1
+            endif
+        endif
+
+        data flush_counter#1
+
+        if bframes_counter!=0
+        #bframe
+            sd pbuf
+            setcall pbuf mpeg_bframe_values(p_sec,p_nth_sec,bframes_store,flush_counter)
+            setcall bool mpeg_frame((B_VOP),sec,nth_sec,pbuf,1)
+            if bool!=1
+                return 0
+            endif
+        else
+        ##empty marker for divx5 decoder compatibility
+            setcall bool mpeg_vop_header((P_VOP),0,0,0)
+            if bool!=1
+                return 0
+            endif
+            setcall bool mpeg_mem_pad((if_needed))
+            if bool!=1
+                return 0
+            endif
+        endelse
+
+        #mpeg_file_mem((value_filewrite))
+
+        if bframes_counter!=0
+            dec bframes_counter
+        else
+            #flag to stop the container loop
+            if ivop_comeback=1
+                set ivop_wait_bframes 0
+            else
+                set p_bframes# 0
+            endelse
+        endelse
+
+        return 1
+    endif
+
+    data key_interval#1
+
+    ##set first frame inits
+    set p_bframes# 0
+    if frameindex=0
+        set bframes_counter 0
+        set key_interval 0
+    endif
+
+    ##input rgb check
+    sd pixbuf
+    set pixbuf argument
+
+    sd width
+    setcall width mpeg_image_w((value_get))
+    sd height
+    setcall height mpeg_image_h((value_get))
+    import "rgb_sizes_test" rgb_sizes_test
+    setcall bool rgb_sizes_test(width,height,pixbuf)
+    if bool!=1
+        return 0
+    endif
+
+    ##frame type and key_interval
+    sd type=I_VOP
+    if frameindex=0
+    #first frame is intra
+    elseif frameindex=framelast
+    #last frame is prediction
+        set type (P_VOP)
+    elseif key_interval=(ARG_MAXKEYINTERVAL)
+    #intra frame
+    else
+        import "me_analyze" me_analyze
+        setcall type me_analyze()
+        if type=(B_VOP)
+            if bframes_counter=(ARG_MAXBFRAMES)
+                #maximum bframes encounter
+                set type (P_VOP)
+            else
+                #add passed frames and increment
+                call mpeg_time((value_append),frameindex)
+                #bframe
+                sd bf_tm
+                set ind bframes_counter
+                mult ind (bframes_data_mix_size*int32)
+                set bf_tm bframes_store
+                add bf_tm ind
+                sd sec_ptr
+                set sec_ptr bf_tm
+                add bf_tm (int32)
+                setcall bf_tm# mpeg_time((value_get),sec_ptr)
+                add bf_tm (int32)
+                set bf_tm# pixbuf
+
+                inc bframes_counter
+            endelse
+        endif
+    endelse
+
+    if type=(I_VOP)
+        set key_interval 0
+    endif
+    inc key_interval
+    if type=(B_VOP)
+        return 1
+    endif
+
+    ##there are bframes to flush
+    set ivop_comeback 0
+    if bframes_counter!=0
+        set p_bframes# 1
+        set flush_counter 0
+        if type=(I_VOP)
+            #keep the values for when the i vop turn comes
+            set ivop_frameindex frameindex
+            set ivop_pixbuf pixbuf
+            #get the last sec, nthsec and pixbuf from bframes
+            sd last_b
+            set last_b bframes_counter
+            dec last_b
+            setcall pixbuf mpeg_bframe_values(p_sec,p_nth_sec,bframes_store,last_b)
+            set ivop_comeback 1
+            dec bframes_counter
+            set ivop_wait_bframes bframes_counter
+            #last bframe becomes prediction
+            set type (P_VOP)
+        endif
+    endif
+
+    if ivop_comeback=0
+        ##add passed frames
+        call mpeg_time((value_append),frameindex)
+        ##get new time
+        setcall nth_sec mpeg_time((value_get),p_sec)
+    endif
+
+    ##write frame
+    setcall bool mpeg_frame_object(type,sec,nth_sec,pixbuf,bframes_counter)
+    if bool!=1
+        return 0
+    endif
+
+    if bframes_counter!=0
+    ##link the P_VOP with the first B_VOP
+        setcall bool mpeg_write_frame(0,p_bframes)
+        if bool!=1
+            return 0
+        endif
+    endif
+
+    return 1
+endfunction
+
+#pbuf
+function mpeg_bframe_values(sd p_sec,sd p_nth_sec,sd bframes_store,sd flush_counter)
+    import "array_get_int" array_get_int
+    sd pbuf
+    sd ind
+
+    set ind flush_counter
+    inc flush_counter
+    mult ind (bframes_data_mix_size)
+
+    setcall p_sec# array_get_int(bframes_store,ind)
+    inc ind
+    setcall p_nth_sec# array_get_int(bframes_store,ind)
+    inc ind
+    setcall pbuf array_get_int(bframes_store,ind)
+
+    return pbuf
+endfunction
+
+#bool
+function mpeg_frame_object(sd type,sd sec,sd nth_sec,sd pixbuf)
+    sd bool
+    ##set rounding type
+    call mpeg_rounding_type((value_set),type)
+
+    ##write frame
+    setcall bool mpeg_frame(type,sec,nth_sec,pixbuf,1)
+    if bool!=1
+        return 0
+    endif
+    #mpeg_file_mem((value_filewrite))
+
+    ##reset time interval
+    call mpeg_time((value_endinterval))
+
+    return 1
+endfunction
+
+#bool
+function mpeg_frame(sd type,sd sec,sd nth_sec,sd pixbuf,sd vop_coded)
+    sd bool
+
+    ##headers
+    if type=(I_VOP)
+        #vol header
+        setcall bool mpeg_vol_header()
+        if bool!=1
+            return 0
+        endif
+
+        setcall bool mpeg_mem_pad((if_needed))
+        if bool!=1
+            return 0
+        endif
+
+        #set the key frame flag for container
+        call mpeg_ptr_is_keyframe((value_is_key))
+    endif
+
+    #vop header
+    setcall bool mpeg_vop_header(type,vop_coded,sec,nth_sec)
+    if bool!=1
+        return 0
+    endif
+
+    ##
+    ##frame blocks
+
+    #rgb to rounded yuv
+    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+    sd bytes
+    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
+    call mpeg_input_mem((value_rgbtoyuv),bytes)
+
+    #(num_slices*1024 / num_threads)
+    sd slices=ARG_SLICES*1024/1
+    #((slices_per_thread + 512) >> 10)
+    #sd start_y=ARG_SLICES-1/ARG_SLICES
+    sd stop_y
+
+    sd add
+    set add slices
+    add add 512
+    setcall add shr(add,10)
+
+    #bound=0
+    #stop_y=(((bound+add) * mb_height + (num_slices-1)) / num_slices)
+    sd mb_height
+    setcall mb_height mpeg_image_h((value_get))
+    add mb_height 15
+    div mb_height 16
+    set stop_y add
+    mult stop_y mb_height
+    add stop_y (ARG_SLICES-1)
+    div stop_y (ARG_SLICES)
+
+    sd mb_width
+    setcall mb_width mpeg_image_w((value_get))
+    add mb_width 15
+    div mb_width 16
+
+    #frame
+    import "mpeg_frame_block" mpeg_frame_block
+    setcall bool mpeg_frame_block(stop_y,mb_width,type)
+    if bool!=1
+        return 0
+    endif
+
+    return 1
+endfunction
+
+
+    const VIDOBJ_START_CODE=0x00000100
+    const VIDOBJLAY_START_CODE=0x00000120
+    const VISOBJSEQ_START_CODE=0x000001b0
+    const USERDATA_START_CODE=0x000001b2
+    const VISOBJ_START_CODE=0x000001b5
+    const VOP_START_CODE=0x000001b6
+
+#################################values functions
+
+function mpeg_buffer_size(sd action,sd size,sd w,sd h)
+    data buffer_size#1
+    if action=(value_set)
+        set buffer_size size
+        call mpeg_image_w((value_set),w)
+        call mpeg_image_h((value_set),h)
+    else
+        return buffer_size
+    endelse
+endfunction
+function mpeg_image_w(sd action,sd w)
+    data width#1
+    if action=(value_set)
+        set width w
+    else
+        return width
+    endelse
+endfunction
+function mpeg_image_h(sd action,sd h)
+    data height#1
+    if action=(value_set)
+        set height h
+    else
+        return height
+    endelse
+endfunction
+
+import "memalloc" memalloc
+importx "_free" free
+
+##input
+
+function mpeg_input_mem(sd action,ss rgb)
+    data mem#1
+    data temp_y#1
+    data temp_u#1
+    data temp_v#1
+    data Y#1
+    data U#1
+    data V#1
+    data width#1
+    data height#1
+    data rounded_width#1
+    data rounded_height#1
+
+    data memory#1
+    data distance#1
+
+	if action=(value_set)
+    #bool
+        sd size
+        import "yuv_get_all_sizes" yuv_get_all_sizes
+        setcall width mpeg_image_w((value_get))
+        setcall height mpeg_image_h((value_get))
+        sd p_temp_u^temp_u
+        sd p_temp_v^temp_v
+        setcall size yuv_get_all_sizes(width,height,p_temp_u,p_temp_v)
+
+#######align at 16 bytes
+        import "multiple_of_nr" multiple_of_nr
+        setcall rounded_width multiple_of_nr(width,16)
+        setcall rounded_height multiple_of_nr(height,16)
+        sd p_U^U
+        sd p_V^V
+        sd roundedsize
+        setcall roundedsize yuv_get_all_sizes(rounded_width,rounded_height,p_U,p_V)
+
+        set Y size
+        add U size
+        add V size
+
+        add size roundedsize
+
+        #for reference image for inter frames comparisons
+        set distance size
+        mult size 2
+
+        setcall mem memalloc(size)
+        if mem=0
+            return 0
+        endif
+
+        #memory is for freeing regardless the reference
+        set memory mem
+
+        set temp_y mem
+        add temp_u mem
+        add temp_v mem
+
+        add Y mem
+        add U mem
+        add V mem
+
+        return 1
+	endif
+	if action=(value_rgbtoyuv)
+        #place the cursor on one of the two images
+        add mem distance
+        add temp_y distance
+        add temp_u distance
+        add temp_v distance
+        add Y distance
+        add U distance
+        add V distance
+
+        mult distance -1
+
+        call mpeg_input_y((value_set),Y,distance)
+        call mpeg_input_u((value_set),U,distance)
+        call mpeg_input_v((value_set),V,distance)
+
+        sd temp_width_crom
+        sd temp_height_crom
+        sd width_crom
+        sd height_crom
+
+        set temp_width_crom width
+        div temp_width_crom 2
+        set temp_height_crom height
+        div temp_height_crom 2
+        set width_crom rounded_width
+        div width_crom 2
+        set height_crom rounded_height
+        div height_crom 2
+
+        import "rgb_to_yuvi420" rgb_to_yuvi420
+        call rgb_to_yuvi420(rgb,mem,width,height)
+
+        call yuv_rounding(temp_y,Y,width,height,rounded_width,rounded_height)
+        call yuv_rounding(temp_u,U,temp_width_crom,temp_height_crom,width_crom,height_crom)
+        call yuv_rounding(temp_v,V,temp_width_crom,temp_height_crom,width_crom,height_crom)
+
+        call mpeg_input_lumstride((value_set),rounded_width)
+        call mpeg_input_cromstride((value_set),width_crom)
+	else
+    #if action==(value_unset)
+        call free(memory)
+	endelse
+endfunction
+function mpeg_input_y(sd action,sd value,sd distance)
+    data y#1
+    data y_ref#1
+    if action=(value_set)
+        set y value
+        set y_ref y
+        add y_ref distance
+    elseif action=(value_get)
+        return y
+    else
+    #if action==(value_get_prev)
+        return y_ref
+    endelse
+endfunction
+function mpeg_input_u(sd action,sd value,sd distance)
+    data u#1
+    data u_ref#1
+    if action=(value_set)
+        set u value
+        set u_ref u
+        add u_ref distance
+    elseif action=(value_get)
+        return u
+    else
+    #if action==(value_get_prev)
+        return u_ref
+    endelse
+endfunction
+function mpeg_input_v(sd action,sd value,sd distance)
+    data v#1
+    data v_ref#1
+    if action=(value_set)
+        set v value
+        set v_ref v
+        add v_ref distance
+    elseif action=(value_get)
+        return v
+    else
+    #if action==(value_get_prev)
+        return v_ref
+    endelse
+endfunction
+function mpeg_input_lumstride(sd action,sd value)
+    data lumstride#1
+    if action=(value_set)
+        set lumstride value
+    else
+        return lumstride
+    endelse
+endfunction
+function mpeg_input_cromstride(sd action,sd value)
+    data cromstride#1
+    if action=(value_set)
+        set cromstride value
+    else
+        return cromstride
+    endelse
+endfunction
+function yuv_rounding(ss src_plane,ss dest_plane,sd src_w,sd src_h,sd dest_w,sd dest_h)
+    sd j=0
+    sd last_i
+    sd src_cursor
+    while j!=dest_h
+        if j<src_h
+            set src_cursor src_plane
+        else
+            set src_plane src_cursor
+        endelse
+        sd i=0
+        while i!=dest_w
+            if i<src_w
+                set last_i src_plane#
+                inc src_plane
+            endif
+            set dest_plane# last_i
+            inc dest_plane
+            inc i
+        endwhile
+        inc j
+    endwhile
+endfunction
+
+##write
+
+function mpeg_write_file(sd action,sd value)
+    data file#1
+    if action=(value_set)
+        set file value
+    else
+        return file
+    endelse
+endfunction
+
+import "file_write" file_write
+
+#bool
+function mpeg_write(sd buffer,sd size)
+    sd file
+    setcall file mpeg_write_file((value_get))
+    sd err
+    setcall err file_write(buffer,size,file)
+    if err!=(noerror)
+        return 0
+    endif
+    return 1
+endfunction
+
+function mpeg_file_mem_append(sd append,sd append_bits)
+    sd bool
+    setcall bool mpeg_file_mem((value_append),append,append_bits)
+    return bool
+endfunction
+
+####output memory
+
+function mpeg_file_mem(sd action,sd append,sd append_bits)
+    data mem#1
+    data size#1
+    data all_size#1
+
+    data bits#1
+    data bits_pos#1
+
+    data p_size^size
+    sd bool
+
+	if action=(value_set)
+    #bool
+        set size 0
+        set bits 0
+        set bits_pos 0
+
+        setcall all_size mpeg_buffer_size((value_get))
+        setcall mem memalloc(all_size)
+        if mem=0
+            return 0
+        endif
+        return 1
+	endif
+	if action=(value_get)
+        return bits_pos
+	endif
+	if action=(value_unset)
+        call free(mem)
+	elseif action=(value_append)
+    #bool
+        import "neg" neg
+
+        sd dif
+        sd bits_count
+
+        sd loop=1
+        while loop=1
+            #32-bitsPos-appendBits
+            sd shift
+            set shift 32
+            sub shift bits_pos
+            sub shift append_bits
+            #
+            if shift>=0
+                orCall bits shl(append,shift)
+                set bits_count append_bits
+            else
+                setcall dif neg(shift)
+                orCall bits shr(append,dif)
+                set bits_count append_bits
+                sub bits_count dif
+            endelse
+
+            add bits_pos bits_count
+            sub append_bits bits_count
+
+            if bits_pos=32
+                setcall bool mpeg_outbuffer_add(p_size,all_size,bits,mem,4)
+                if bool!=1
+                    return 0
+                endif
+                set bits 0
+                set bits_pos 0
+            endif
+            if append_bits=0
+                set loop 0
+            endif
+        endwhile
+        return 1
+	else
+    #if action==(value_filewrite)
+    #bool
+        if bits_pos!=0
+            sd bytes_add
+            set bytes_add bits_pos
+            add bytes_add 7
+            div bytes_add 8
+            setcall bool mpeg_outbuffer_add(p_size,all_size,bits,mem,bytes_add)
+            if bool!=1
+                return 0
+            endif
+        endif
+        setcall bool mpeg_write(mem,size)
+
+        #reset the counters and the bits store for other frames
+        set size 0
+        set bits 0
+        set bits_pos 0
+
+        return bool
+	endelse
+endfunction
+
+#bool
+function mpeg_outbuffer_add(sd p_size,sd all_size,sd bits,sd buffer,sd add_size)
+    sd size
+    set size p_size#
+    add size add_size
+    if size>all_size
+        str sizerr="Size error"
+        import "texter" texter
+        call texter(sizerr)
+        return 0
+    endif
+
+    #transform to big endian
+    import "dword_reverse" dword_reverse
+    setcall bits dword_reverse(bits)
+    add buffer p_size#
+    set buffer# bits
+
+    set p_size# size
+
+    return 1
+endfunction
+
+
+#bool
+function mpeg_mem_pad(sd mode)
+    sd bits_pos
+    setcall bits_pos mpeg_file_mem((value_get))
+    sd pad
+    sd pad_rest
+    import "rest" rest
+    setcall pad_rest rest(bits_pos,8)
+    set pad 8
+    sub pad pad_rest
+
+    if mode=(if_needed)
+        if pad=8
+            return 1
+        endif
+    endif
+    data stuff={0,1,3,7,0xf,0x1f,0x3f,0x7f}
+    sd value
+    set value pad
+    dec value
+    mult value 4
+    sd p_stuff^stuff
+    add p_stuff value
+
+    sd bool
+    setcall bool mpeg_file_mem_append(p_stuff#,pad)
+    return bool
+endfunction
+
+#bool
+function mpeg_mem_bit(sd value)
+    sd bool
+    setcall bool mpeg_file_mem_append(value,1)
+    return bool
+endfunction
+
+#bool
+function mpeg_mem_marker()
+    sd bool
+    setcall bool mpeg_file_mem_append(1,1)
+    return bool
+endfunction
+
+#bool
+function mpeg_mem_userdata(ss string)
+    sd bool
+    setcall bool mpeg_mem_pad((if_needed))
+    if bool!=1
+        return 0
+    endif
+    setcall bool mpeg_file_mem_append((USERDATA_START_CODE),32)
+    if bool!=1
+        return 0
+    endif
+    import "slen" slen
+    sd len
+    setcall len slen(string)
+    while len!=0
+        setcall bool mpeg_file_mem_append(string#,8)
+        if bool!=1
+            return 0
+        endif
+        inc string
+        dec len
+    endwhile
+    return 1
+endfunction
+
+##time
+
+import "stage_file_options_fps" stage_file_options_fps
+
+function mpeg_time(sd action,sd arg)
+    #store the frames interval and process the time
+    data begin#1
+    data end#1
+    if action=(value_set)
+        set begin 0
+        set end 0
+    elseif action=(value_get)
+    #nth_of_sec return
+        sd p_sec
+        set p_sec arg
+        #
+        sd framesstack
+        set framesstack end
+        sub framesstack begin
+        sd fps
+        setcall fps stage_file_options_fps()
+        sd sec
+        set sec framesstack
+        div sec fps
+        set p_sec# sec
+        mult sec fps
+        sd nth_of_sec
+        set nth_of_sec framesstack
+        sub nth_of_sec sec
+        return nth_of_sec
+    elseif action=(value_append)
+        set end arg
+    else
+    #if action==(value_endinterval)
+    #set the new start for the new interval
+        set begin end
+    endelse
+endfunction
+
+function mpeg_get_quant(sd type)
+    sd quant
+    set quant (DEFAULT_QUANT)
+    if type=(B_VOP)
+        add quant (DEFAULT_QUANT)
+        mult quant (ARG_BQRATIO)
+        div quant 2
+        add quant (ARG_BQOFFSET)
+        div quant 100
+    endif
+    return quant
+endfunction
+
+function mpeg_fixcode(sd mv)
+    sd fcode=1
+    whiletrue
+        sd value
+        setcall value shl(16,fcode)
+        if value>mv
+            return fcode
+        endif
+        inc fcode
+    endwhile
+    return fcode
+endfunction
+
+##rounding
+function mpeg_rounding_type(sd action,sd type)
+    data rounding#1
+    if action=(value_set)
+        if type=(I_VOP)
+            set rounding 1
+        else
+        #P_VOP
+            sd value
+            set value rounding
+            set rounding 1
+            sub rounding value
+        endelse
+    else
+        return rounding
+    endelse
+endfunction
+
+##################misc funcs
+function log2bin(sd value)
+    char log2={0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4}
+    sd n=0
+    sd x
+    set x value
+    and x 0xffff0000
+    if x!=0
+        setcall value shr(value,16)
+        add n 16
+    endif
+    set x value
+    and x 0xff00
+    if x!=0
+        setcall value shr(value,8)
+        add n 8
+    endif
+    set x value
+    and x 0xf0
+    if x!=0
+        setcall value shr(value,4)
+        add n 4
+    endif
+    ss log^log2
+    add log value
+    add n log#
+    return n
+endfunction
+
+function log2_resolution()
+    sd bits
+
+    sd fps
+    setcall fps stage_file_options_fps()
+    dec fps
+
+    setcall bits log2bin(fps)
+
+    import "get_higher" get_higher
+    setcall bits get_higher(bits,1)
+    return bits
+endfunction
+
+###########################################VOL header
+
+#bool
+function mpeg_vol_header()
+    const VISOBJ_TYPE_VIDEO=1
+    #const VIDOBJLAY_TYPE_SIMPLE=1
+    const VIDOBJLAY_TYPE_ASP=17
+
+    const Profile_Unrestricted=0xf5
+    const vo_id=0
+    const vol_id=0
+    #const vol_ver_id=1
+    #1:1 vga (square), default if supplied PAR is not a valid value
+    const XVID_PAR_11_VGA=1
+
+    sd bool
+
+    #VOS header
+    setcall bool mpeg_file_mem_append((VISOBJSEQ_START_CODE),32)
+    if bool!=1
+        return 0
+    endif
+    char vol_profile=Profile_Unrestricted
+    setcall bool mpeg_file_mem_append(vol_profile,8)
+    if bool!=1
+        return 0
+    endif
+    #byte padded
+
+    #Visual Object start code
+    setcall bool mpeg_mem_pad((if_needed))
+    if bool!=1
+        return 0
+    endif
+    setcall bool mpeg_file_mem_append((VISOBJ_START_CODE),32)
+    if bool!=1
+        return 0
+    endif
+    #visual_object_identifier=0
+    setcall bool mpeg_file_mem_append(0,1)
+    if bool!=1
+        return 0
+    endif
+
+    #Video type
+    setcall bool mpeg_file_mem_append((VISOBJ_TYPE_VIDEO),4)
+    if bool!=1
+        return 0
+    endif
+    #video_signal_type
+    setcall bool mpeg_file_mem_append(0,1)
+    if bool!=1
+        return 0
+    endif
+
+    #video object start code & vo_id
+    setcall bool mpeg_mem_pad((always))
+    if bool!=1
+        return 0
+    endif
+    setcall bool mpeg_file_mem_append((vo_id&0x5|VIDOBJ_START_CODE),32)
+    if bool!=1
+        return 0
+    endif
+
+    #video_object_layer_start_code & vol_id
+    setcall bool mpeg_mem_pad((if_needed))
+    if bool!=1
+        return 0
+    endif
+    setcall bool mpeg_file_mem_append((vol_id&0x4|VIDOBJLAY_START_CODE),32)
+    if bool!=1
+        return 0
+    endif
+
+        #random_accessible_vol
+    setcall bool mpeg_file_mem_append(0,1)
+    if bool!=1
+        return 0
+    endif
+        #video_object_type_indication
+    setcall bool mpeg_file_mem_append((VIDOBJLAY_TYPE_ASP),8)
+    if bool!=1
+        return 0
+    endif
+
+        #if vol_ver_id=1
+        #is_object_layer_identified (0=not given)
+    setcall bool mpeg_file_mem_append(0,1)
+    if bool!=1
+        return 0
+    endif
+
+    #aspect ratio
+    setcall bool mpeg_file_mem_append((XVID_PAR_11_VGA),4)
+    if bool!=1
+        return 0
+    endif
+
+    #vol_control_parameters
+    setcall bool mpeg_file_mem_append(1,1)
+    if bool!=1
+        return 0
+    endif
+
+    #chroma_format 1="4:2:0"
+    setcall bool mpeg_file_mem_append(1,2)
+    if bool!=1
+        return 0
+    endif
+
+    #low_delay
+    #if max_bframes > 0,ARG_MAXBFRAMES=2
+    setcall bool mpeg_file_mem_append(0,1)
+    if bool!=1
+        return 0
+    endif
+
+    #vbv_parameters (0=not given)
+    setcall bool mpeg_file_mem_append(0,1)
+    if bool!=1
+        return 0
+    endif
+
+    #video_object_layer_shape (0=rectangular)
+    setcall bool mpeg_file_mem_append(0,2)
+    if bool!=1
+        return 0
+    endif
+
+    setcall bool mpeg_mem_marker()
+    if bool!=1
+        return 0
+    endif
+
+    #time_inc_resolution
+
+    #framerate
+    #ARG_DWRATE
+    sd fps
+    setcall fps stage_file_options_fps()
+    setcall bool mpeg_file_mem_append(fps,16)
+    if bool!=1
+        return 0
+    endif
+
+    setcall bool mpeg_mem_marker()
+    if bool!=1
+        return 0
+    endif
+
+    #frame inc
+    #ARG_DWSCALE=1
+
+    #fixed_vop_rate = 1
+    setcall bool mpeg_mem_bit(1)
+    if bool!=1
+        return 0
+    endif
+
+    #fixed_vop_time_increment
+    sd bits
+    setcall bits log2_resolution()
+    setcall bool mpeg_file_mem_append(1,bits)
+    if bool!=1
+        return 0
+    endif
+
+    setcall bool mpeg_mem_marker()
+    if bool!=1
+        return 0
+    endif
+    #width
+    sd w
+    setcall w mpeg_image_w((value_get))
+    setcall bool mpeg_file_mem_append(w,13)
+    if bool!=1
+        return 0
+    endif
+    #
+    setcall bool mpeg_mem_marker()
+    if bool!=1
+        return 0
+    endif
+    #height
+    sd h
+    setcall h mpeg_image_h((value_get))
+    setcall bool mpeg_file_mem_append(h,13)
+    if bool!=1
+        return 0
+    endif
+    #
+    setcall bool mpeg_mem_marker()
+    if bool!=1
+        return 0
+    endif
+
+    #interlace
+    #const XVID_VOL_INTERLACING=(1<<5)
+    #vol_flags=0
+    setcall bool mpeg_mem_bit(0)
+    if bool!=1
+        return 0
+    endif
+    #obmc_disable (overlapped block motion compensation)
+    setcall bool mpeg_mem_bit(1)
+    if bool!=1
+        return 0
+    endif
+
+    #sprite_enable==off
+    setcall bool mpeg_mem_bit(0)
+    if bool!=1
+        return 0
+    endif
+
+    #not_8_bit
+    setcall bool mpeg_mem_bit(0)
+    if bool!=1
+        return 0
+    endif
+
+    #quant_type   0=h.263  1=mpeg4(quantizer tables)
+    #XVID_VOL_MPEGQUANT=(1<<0),vol_flags=0
+    setcall bool mpeg_mem_bit(0)
+    if bool!=1
+        return 0
+    endif
+
+    #complexity_estimation_disable
+    setcall bool mpeg_mem_bit(1)
+    if bool!=1
+        return 0
+    endif
+
+    #resync_marker_disabled
+    setcall bool mpeg_mem_bit((ARG_SLICES))
+    if bool!=1
+        return 0
+    endif
+
+    #data_partitioned
+    setcall bool mpeg_mem_bit(0)
+    if bool!=1
+        return 0
+    endif
+
+    #scalability
+    setcall bool mpeg_mem_bit(0)
+    if bool!=1
+        return 0
+    endif
+
+    setcall bool mpeg_mem_pad((always))
+    if bool!=1
+        return 0
+    endif
+
+    #packed bitstream
+    const XVID_GLOBAL_PACKED=2$0
+    #closed_gop:	was DX50BVOP dx50 bvop compatibility
+    const XVID_GLOBAL_CLOSED_GOP=2$1
+    #write divx5 userdata string,this is implied if XVID_GLOBAL_PACKED is set
+    const XVID_GLOBAL_DIVX5_USERDATA=2$5
+    sd global_flags=XVID_GLOBAL_PACKED|XVID_GLOBAL_CLOSED_GOP|XVID_GLOBAL_DIVX5_USERDATA
+    sd flags
+    set flags global_flags
+    and flags (XVID_GLOBAL_DIVX5_USERDATA)
+    if flags!=0
+        str sign="OApplications"
+        #str divx="DivX503b1393"
+        setcall bool mpeg_mem_userdata(sign)
+        if bool!=1
+            return 0
+        endif
+        #if max_bframes > 0,ARG_MAXBFRAMES=2
+        char p="p"
+        set flags global_flags
+        and flags (XVID_GLOBAL_PACKED)
+        if flags!=0
+            setcall bool mpeg_file_mem_append(p,8)
+            if bool!=1
+                return 0
+            endif
+        endif
+    endif
+
+    #"VOP" flags
+#define XVID_VOP_DEBUG                (1<< 0) /* print debug messages in frames */
+    #use halfpel interpolation
+    #const XVID_VOP_HALFPEL=2$1
+    #use 4 motion vectors per MB
+    #const XVID_VOP_INTER4V=2$2
+    #use trellis based R-D "optimal" quantization
+    #const XVID_VOP_TRELLISQUANT=2$3
+#define XVID_VOP_CHROMAOPT            (1<< 4) /* enable chroma optimization pre-filter */
+#define XVID_VOP_CARTOON              (1<< 5) /* use 'cartoon mode' */
+#define XVID_VOP_GREYSCALE            (1<< 6) /* enable greyscale only mode (even for  color input material chroma is ignored) */
+    #high quality ac prediction
+    #const XVID_VOP_HQACPRED=2$7
+    #enable DCT-ME and use it for mode decision
+    #const XVID_VOP_MODEDECISION_RD=2$8
+#define XVID_VOP_FAST_MODEDECISION_RD (1<<12) /* use simplified R-D mode decision */
+#define XVID_VOP_RD_BVOP              (1<<13) /* enable rate-distortion mode decision in b-frames */
+#define XVID_VOP_RD_PSNRHVSM          (1<<14) /* use PSNR-HVS-M as metric for rate-distortion optimizations */
+    #sd vop_flags=XVID_VOP_HALFPEL|XVID_VOP_INTER4V|XVID_VOP_TRELLISQUANT|XVID_VOP_HQACPRED|XVID_VOP_MODEDECISION_RD
+
+    #str xvid="XviD0064"
+    str signature="OApplications"
+    setcall bool mpeg_mem_userdata(signature)
+    if bool!=1
+        return 0
+    endif
+
+    return 1
+endfunction
+
+
+############vop header
+#bool
+function mpeg_vop_header(sd type,sd vop_coded,sd seconds,sd nth_of_sec)
+    sd bool
+    setcall bool mpeg_file_mem_append((VOP_START_CODE),32)
+    if bool!=1
+        return 0
+    endif
+
+#intra,prediction,backward
+#define I_VOP	0
+#define P_VOP	1
+#define B_VOP	2
+    setcall bool mpeg_file_mem_append(type,2)
+    if bool!=1
+        return 0
+    endif
+
+    #time
+    #frame seconds
+    sd i=0
+    while i<seconds
+        setcall bool mpeg_mem_bit(1)
+        if bool!=1
+            return 0
+        endif
+        inc i
+    endwhile
+        #termination
+    setcall bool mpeg_mem_bit(0)
+    if bool!=1
+        return 0
+    endif
+
+    setcall bool mpeg_mem_marker()
+    if bool!=1
+        return 0
+    endif
+
+    #nth of sec(of fps)
+    sd bits
+    setcall bits log2_resolution()
+    setcall bool mpeg_file_mem_append(nth_of_sec,bits)
+    if bool!=1
+        return 0
+    endif
+
+    setcall bool mpeg_mem_marker()
+    if bool!=1
+        return 0
+    endif
+
+    #not vop_coded
+    if vop_coded=0
+        setcall bool mpeg_mem_bit(0)
+        if bool!=1
+            return 0
+        endif
+        return 1
+    endif
+
+    #vop_coded
+    setcall bool mpeg_mem_bit(1)
+    if bool!=1
+        return 0
+    endif
+
+    #(frame->coding_type == P_VOP) || (frame->coding_type == S_VOP)
+    if type=(P_VOP)
+        #rounding_type
+        sd rounding
+        setcall rounding mpeg_rounding_type((value_get))
+        setcall bool mpeg_mem_bit(rounding)
+        if bool!=1
+            return 0
+        endif
+    endif
+
+    #intra_dc_vlc_threshold
+    setcall bool mpeg_file_mem_append(0,3)
+    if bool!=1
+        return 0
+    endif
+
+    #frame->vol_flags & XVID_VOL_INTERLACING
+
+    #frame->coding_type == S_VOP
+
+    #quantizer
+    sd quant
+    setcall quant mpeg_get_quant(type)
+    setcall bool mpeg_file_mem_append(quant,5)
+    if bool!=1
+        return 0
+    endif
+
+    if type!=(I_VOP)
+    #forward_fixed_code
+        sd fcode
+        setcall fcode mpeg_fixcode(0)
+        setcall bool mpeg_file_mem_append(fcode,3)
+        if bool!=1
+            return 0
+        endif
+
+        if type=(B_VOP)
+    #backward_fixed_code
+            sd bcode
+            setcall bcode mpeg_fixcode(0)
+            setcall bool mpeg_file_mem_append(bcode,3)
+            if bool!=1
+                return 0
+            endif
+        endif
+    endif
+
+    return 1
+endfunction
+
+
+
+
+##########options
+function mpeg_options(sd mem,sd *size)
+    sd value
+    sd p_value^value
+    sd mem_sz^mem
+    import "get_mem_int_advance" get_mem_int_advance
+    sd err
+
+    setcall err get_mem_int_advance(p_value,mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    call mpeg_single_tolerance((value_set),value)
+
+    setcall err get_mem_int_advance(p_value,mem_sz)
+    if err!=(noerror)
+        return 0
+    endif
+    call mpeg_group_tolerance((value_set),value)
+endfunction
+
+function mpeg_single_tolerance(sd action,sd value)
+    data single_tolerance#1
+    if action=(value_set)
+        set single_tolerance value
+    else
+        return single_tolerance
+    endelse
+endfunction
+function mpeg_group_tolerance(sd action,sd value)
+    data group_tolerance#1
+    if action=(value_set)
+        set group_tolerance value
+    else
+        return group_tolerance
+    endelse
+endfunction
+
+function mpeg_settings_init(sd vbox,sd *dialog)
+    import "hscalefield" hscalefield
+    sd scale
+    sd value
+    import "hboxfield_cnt" hboxfield_cnt
+    sd hbox
+    import "labelfield_left_default" labelfield_left_default
+
+    str s="Single Tolerance: "
+    setcall hbox hboxfield_cnt(vbox)
+    call labelfield_left_default(s,hbox)
+    setcall value mpeg_single_tolerance((value_get))
+    setcall scale hscalefield(hbox,0,255,1,value)
+    call mpeg_single_scale((value_set),scale)
+
+    str g="Group Tolerance: "
+    setcall hbox hboxfield_cnt(vbox)
+    call labelfield_left_default(g,hbox)
+    setcall value mpeg_group_tolerance((value_get))
+    setcall scale hscalefield(hbox,0,256,1,value)
+    call mpeg_group_scale((value_set),scale)
+endfunction
+function mpeg_settings_set()
+    import "file_write_forward_sys_folder_enter_leave" file_write_forward_sys_folder_enter_leave
+    data forw_mpeg^mpeg_settings_set_write
+    import "mpeg_file" mpeg_file
+    ss mpeg_fl_str
+    setcall mpeg_fl_str mpeg_file()
+    call file_write_forward_sys_folder_enter_leave(mpeg_fl_str,forw_mpeg)
+endfunction
+
+function mpeg_settings_set_write(sd mpeg_fl)
+    import "hscale_get" hscale_get
+    sd value
+    sd scale
+    sd p_value^value
+
+    setcall scale mpeg_single_scale((value_get))
+    setcall value hscale_get(scale)
+    call mpeg_single_tolerance((value_set),value)
+
+    call file_write(p_value,4,mpeg_fl)
+
+    setcall scale mpeg_group_scale((value_get))
+    setcall value hscale_get(scale)
+    call mpeg_group_tolerance((value_set),value)
+
+    call file_write(p_value,4,mpeg_fl)
+endfunction
+
+function mpeg_single_scale(sd action,sd value)
+    data single_scale#1
+    if action=(value_set)
+        set single_scale value
+    else
+        return single_scale
+    endelse
+endfunction
+function mpeg_group_scale(sd action,sd value)
+    data group_scale#1
+    if action=(value_set)
+        set group_scale value
+    else
+        return group_scale
+    endelse
+endfunction
--- ovideo-1.orig/src/media/mpeg.s
+++ /dev/null
@@ -1,1552 +0,0 @@
-
-format elfobj
-
-
-#MPEG-4 encoder
-
-include "../_include/include.h"
-
-import "shl" shl
-import "shr" shr
-
-const ARG_SLICES=1
-const ARG_BQRATIO=150
-const ARG_BQOFFSET=100
-const ARG_MAXBFRAMES=2
-const ARG_MAXKEYINTERVAL=300
-
-const value_rgbtoyuv=value_custom
-const value_endinterval=value_custom
-
-
-##init
-
-#bool
-function mpeg_init(sd file,sd pixbufSample,sd totalframes)
-    import "macro_blocks" macro_blocks
-
-    data filemem#1
-    set filemem 0
-    data inputmem#1
-    set inputmem 0
-    data macroblocks#1
-    set macroblocks 0
-
-    call mpeg_start(file,pixbufSample)
-    call mpeg_lastframe((value_set),totalframes)
-
-    sd bool
-    setcall bool mpeg_file_mem((value_set))
-    if bool==1
-        set filemem 1
-        setcall bool mpeg_input_mem((value_set))
-        if bool==1
-            set inputmem 1
-            setcall bool macro_blocks((value_set))
-            if bool==1
-                return 1
-            endif
-        endif
-    endif
-
-    if filemem==0
-        return 0
-    endif
-    call mpeg_file_mem((value_unset))
-    if inputmem==0
-        return 0
-    endif
-    call mpeg_input_mem((value_unset))
-    if macroblocks==0
-        return 0
-    endif
-    call macro_blocks((value_unset))
-    return 0
-endfunction
-
-#bool
-function mpeg_encode(sd pixbuf,sd position,sd p_is_key_frame)
-    data b#1
-    data p_b^b
-    sd bool
-    setcall bool mpeg_write_frame(p_b,pixbuf,position,p_is_key_frame)
-    return bool
-endfunction
-
-function mpeg_release()
-    call mpeg_file_mem((value_unset))
-    call mpeg_input_mem((value_unset))
-    call macro_blocks((value_unset))
-endfunction
-
-
-function mpeg_lastframe(sd action,sd value)
-    data lastframe#1
-    if action==(value_set)
-        dec value
-        set lastframe value
-    else
-        return lastframe
-    endelse
-endfunction
-function mpeg_start(sd file,sd pixbufSample)
-    #store output file
-    call mpeg_write_file((value_set),file)
-    #store sizes
-    sd w
-    sd h
-    sd wh^w
-    import "pixbuf_get_wh" pixbuf_get_wh
-    call pixbuf_get_wh(pixbufSample,wh)
-    import "yuv_get_size" yuv_get_size
-    sd size
-    setcall size yuv_get_size(w,h)
-        #get yuv size based on pixbuf and alloc the mpeg4 buffer, mult with 2 for safety
-    mult size 2
-    call mpeg_buffer_size((value_set),size,w,h)
-    #init vlc tables
-    import "mpeg_init_vlc" mpeg_init_vlc
-    call mpeg_init_vlc()
-    #init time
-    call mpeg_time((value_set),0)
-endfunction
-
-const value_is_key=value_custom
-function mpeg_ptr_is_keyframe(sd action,sd value)
-    data ptr_is_keyframe#1
-    if action==(value_set)
-        set ptr_is_keyframe value
-        set ptr_is_keyframe# 0
-    else
-        #if action==(value_is_key)
-        set ptr_is_keyframe# 1
-    endelse
-endfunction
-
-#bool
-function mpeg_write_frame(sd p_bframes,sd argument,sd frameindex,sd p_is_key_frame)
-    sd ind
-    sd bool
-    data sec#1
-    data p_sec^sec
-    data nth_sec#1
-    data p_nth_sec^nth_sec
-    data ivop_comeback#1
-    data ivop_frameindex#1
-    data ivop_pixbuf#1
-    data ivop_wait_bframes#1
-
-    ##bframes store data
-    data bframes_counter#1
-    const bframes_data_mix_size=3
-    #seconds and nth_of_sec and pixbuf
-    data bframes_store_data#ARG_MAXBFRAMES*bframes_data_mix_size
-    data bframes_store^bframes_store_data
-
-    ##set last frame
-    sd framelast
-    setcall framelast mpeg_lastframe((value_get))
-
-    ##reset keyflag
-    call mpeg_ptr_is_keyframe((value_set),p_is_key_frame)
-
-    ##flush bframes
-    if p_bframes==0
-        set p_bframes argument
-
-        if ivop_comeback==1
-            if ivop_wait_bframes==0
-                ##add passed frames
-                call mpeg_time((value_append),ivop_frameindex)
-                ##get new time
-                setcall nth_sec mpeg_time((value_get),p_sec)
-                ##write frame
-                setcall bool mpeg_frame_object((I_VOP),sec,nth_sec,ivop_pixbuf,0)
-                if bool!=1
-                    return 0
-                endif
-                set p_bframes# 0
-                return 1
-            endif
-        endif
-
-        data flush_counter#1
-
-        if bframes_counter!=0
-        #bframe
-            sd pbuf
-            setcall pbuf mpeg_bframe_values(p_sec,p_nth_sec,bframes_store,flush_counter)
-            setcall bool mpeg_frame((B_VOP),sec,nth_sec,pbuf,1)
-            if bool!=1
-                return 0
-            endif
-        else
-        ##empty marker for divx5 decoder compatibility
-            setcall bool mpeg_vop_header((P_VOP),0,0,0)
-            if bool!=1
-                return 0
-            endif
-            setcall bool mpeg_mem_pad((if_needed))
-            if bool!=1
-                return 0
-            endif
-        endelse
-
-        #mpeg_file_mem((value_filewrite))
-
-        if bframes_counter!=0
-            dec bframes_counter
-        else
-            #flag to stop the container loop
-            if ivop_comeback==1
-                set ivop_wait_bframes 0
-            else
-                set p_bframes# 0
-            endelse
-        endelse
-
-        return 1
-    endif
-
-    data key_interval#1
-
-    ##set first frame inits
-    set p_bframes# 0
-    if frameindex==0
-        set bframes_counter 0
-        set key_interval 0
-    endif
-
-    ##input rgb check
-    sd pixbuf
-    set pixbuf argument
-
-    sd width
-    setcall width mpeg_image_w((value_get))
-    sd height
-    setcall height mpeg_image_h((value_get))
-    import "rgb_sizes_test" rgb_sizes_test
-    setcall bool rgb_sizes_test(width,height,pixbuf)
-    if bool!=1
-        return 0
-    endif
-
-    ##frame type and key_interval
-    sd type=I_VOP
-    if frameindex==0
-    #first frame is intra
-    elseif frameindex==framelast
-    #last frame is prediction
-        set type (P_VOP)
-    elseif key_interval==(ARG_MAXKEYINTERVAL)
-    #intra frame
-    else
-        import "me_analyze" me_analyze
-        setcall type me_analyze()
-        if type==(B_VOP)
-            if bframes_counter==(ARG_MAXBFRAMES)
-                #maximum bframes encounter
-                set type (P_VOP)
-            else
-                #add passed frames and increment
-                call mpeg_time((value_append),frameindex)
-                #bframe
-                sd bf_tm
-                set ind bframes_counter
-                mult ind (bframes_data_mix_size*int32)
-                set bf_tm bframes_store
-                add bf_tm ind
-                sd sec_ptr
-                set sec_ptr bf_tm
-                add bf_tm (int32)
-                setcall bf_tm# mpeg_time((value_get),sec_ptr)
-                add bf_tm (int32)
-                set bf_tm# pixbuf
-
-                inc bframes_counter
-            endelse
-        endif
-    endelse
-
-    if type==(I_VOP)
-        set key_interval 0
-    endif
-    inc key_interval
-    if type==(B_VOP)
-        return 1
-    endif
-
-    ##there are bframes to flush
-    set ivop_comeback 0
-    if bframes_counter!=0
-        set p_bframes# 1
-        set flush_counter 0
-        if type==(I_VOP)
-            #keep the values for when the i vop turn comes
-            set ivop_frameindex frameindex
-            set ivop_pixbuf pixbuf
-            #get the last sec, nthsec and pixbuf from bframes
-            sd last_b
-            set last_b bframes_counter
-            dec last_b
-            setcall pixbuf mpeg_bframe_values(p_sec,p_nth_sec,bframes_store,last_b)
-            set ivop_comeback 1
-            dec bframes_counter
-            set ivop_wait_bframes bframes_counter
-            #last bframe becomes prediction
-            set type (P_VOP)
-        endif
-    endif
-
-    if ivop_comeback==0
-        ##add passed frames
-        call mpeg_time((value_append),frameindex)
-        ##get new time
-        setcall nth_sec mpeg_time((value_get),p_sec)
-    endif
-
-    ##write frame
-    setcall bool mpeg_frame_object(type,sec,nth_sec,pixbuf,bframes_counter)
-    if bool!=1
-        return 0
-    endif
-
-    if bframes_counter!=0
-    ##link the P_VOP with the first B_VOP
-        setcall bool mpeg_write_frame(0,p_bframes)
-        if bool!=1
-            return 0
-        endif
-    endif
-
-    return 1
-endfunction
-
-#pbuf
-function mpeg_bframe_values(sd p_sec,sd p_nth_sec,sd bframes_store,sd flush_counter)
-    import "array_get_int" array_get_int
-    sd pbuf
-    sd ind
-
-    set ind flush_counter
-    inc flush_counter
-    mult ind (bframes_data_mix_size)
-
-    setcall p_sec# array_get_int(bframes_store,ind)
-    inc ind
-    setcall p_nth_sec# array_get_int(bframes_store,ind)
-    inc ind
-    setcall pbuf array_get_int(bframes_store,ind)
-
-    return pbuf
-endfunction
-
-#bool
-function mpeg_frame_object(sd type,sd sec,sd nth_sec,sd pixbuf)
-    sd bool
-    ##set rounding type
-    call mpeg_rounding_type((value_set),type)
-
-    ##write frame
-    setcall bool mpeg_frame(type,sec,nth_sec,pixbuf,1)
-    if bool!=1
-        return 0
-    endif
-    #mpeg_file_mem((value_filewrite))
-
-    ##reset time interval
-    call mpeg_time((value_endinterval))
-
-    return 1
-endfunction
-
-#bool
-function mpeg_frame(sd type,sd sec,sd nth_sec,sd pixbuf,sd vop_coded)
-    sd bool
-
-    ##headers
-    if type==(I_VOP)
-        #vol header
-        setcall bool mpeg_vol_header()
-        if bool!=1
-            return 0
-        endif
-
-        setcall bool mpeg_mem_pad((if_needed))
-        if bool!=1
-            return 0
-        endif
-
-        #set the key frame flag for container
-        call mpeg_ptr_is_keyframe((value_is_key))
-    endif
-
-    #vop header
-    setcall bool mpeg_vop_header(type,vop_coded,sec,nth_sec)
-    if bool!=1
-        return 0
-    endif
-
-    ##
-    ##frame blocks
-
-    #rgb to rounded yuv
-    importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-    sd bytes
-    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
-    call mpeg_input_mem((value_rgbtoyuv),bytes)
-
-    #(num_slices*1024 / num_threads)
-    sd slices=ARG_SLICES*1024/1
-    #((slices_per_thread + 512) >> 10)
-    #sd start_y=ARG_SLICES-1/ARG_SLICES
-    sd stop_y
-
-    sd add
-    set add slices
-    add add 512
-    setcall add shr(add,10)
-
-    #bound=0
-    #stop_y=(((bound+add) * mb_height + (num_slices-1)) / num_slices)
-    sd mb_height
-    setcall mb_height mpeg_image_h((value_get))
-    add mb_height 15
-    div mb_height 16
-    set stop_y add
-    mult stop_y mb_height
-    add stop_y (ARG_SLICES-1)
-    div stop_y (ARG_SLICES)
-
-    sd mb_width
-    setcall mb_width mpeg_image_w((value_get))
-    add mb_width 15
-    div mb_width 16
-
-    #frame
-    import "mpeg_frame_block" mpeg_frame_block
-    setcall bool mpeg_frame_block(stop_y,mb_width,type)
-    if bool!=1
-        return 0
-    endif
-
-    return 1
-endfunction
-
-
-    const VIDOBJ_START_CODE=0x00000100
-    const VIDOBJLAY_START_CODE=0x00000120
-    const VISOBJSEQ_START_CODE=0x000001b0
-    const USERDATA_START_CODE=0x000001b2
-    const VISOBJ_START_CODE=0x000001b5
-    const VOP_START_CODE=0x000001b6
-
-#################################values functions
-
-function mpeg_buffer_size(sd action,sd size,sd w,sd h)
-    data buffer_size#1
-    if action==(value_set)
-        set buffer_size size
-        call mpeg_image_w((value_set),w)
-        call mpeg_image_h((value_set),h)
-    else
-        return buffer_size
-    endelse
-endfunction
-function mpeg_image_w(sd action,sd w)
-    data width#1
-    if action==(value_set)
-        set width w
-    else
-        return width
-    endelse
-endfunction
-function mpeg_image_h(sd action,sd h)
-    data height#1
-    if action==(value_set)
-        set height h
-    else
-        return height
-    endelse
-endfunction
-
-import "memalloc" memalloc
-importx "_free" free
-
-##input
-
-function mpeg_input_mem(sd action,ss rgb)
-    data mem#1
-    data temp_y#1
-    data temp_u#1
-    data temp_v#1
-    data Y#1
-    data U#1
-    data V#1
-    data width#1
-    data height#1
-    data rounded_width#1
-    data rounded_height#1
-
-    data memory#1
-    data distance#1
-
-    if action==(value_set)
-    #bool
-        sd size
-        import "yuv_get_all_sizes" yuv_get_all_sizes
-        setcall width mpeg_image_w((value_get))
-        setcall height mpeg_image_h((value_get))
-        sd p_temp_u^temp_u
-        sd p_temp_v^temp_v
-        setcall size yuv_get_all_sizes(width,height,p_temp_u,p_temp_v)
-
-#######align at 16 bytes
-        import "multiple_of_nr" multiple_of_nr
-        setcall rounded_width multiple_of_nr(width,16)
-        setcall rounded_height multiple_of_nr(height,16)
-        sd p_U^U
-        sd p_V^V
-        sd roundedsize
-        setcall roundedsize yuv_get_all_sizes(rounded_width,rounded_height,p_U,p_V)
-
-        set Y size
-        add U size
-        add V size
-
-        add size roundedsize
-
-        #for reference image for inter frames comparisons
-        set distance size
-        mult size 2
-
-        setcall mem memalloc(size)
-        if mem==0
-            return 0
-        endif
-
-        #memory is for freeing regardless the reference
-        set memory mem
-
-        set temp_y mem
-        add temp_u mem
-        add temp_v mem
-
-        add Y mem
-        add U mem
-        add V mem
-
-        return 1
-    elseif action==(value_rgbtoyuv)
-        #place the cursor on one of the two images
-        add mem distance
-        add temp_y distance
-        add temp_u distance
-        add temp_v distance
-        add Y distance
-        add U distance
-        add V distance
-
-        mult distance -1
-
-        call mpeg_input_y((value_set),Y,distance)
-        call mpeg_input_u((value_set),U,distance)
-        call mpeg_input_v((value_set),V,distance)
-
-        sd temp_width_crom
-        sd temp_height_crom
-        sd width_crom
-        sd height_crom
-
-        set temp_width_crom width
-        div temp_width_crom 2
-        set temp_height_crom height
-        div temp_height_crom 2
-        set width_crom rounded_width
-        div width_crom 2
-        set height_crom rounded_height
-        div height_crom 2
-
-        import "rgb_to_yuvi420" rgb_to_yuvi420
-        call rgb_to_yuvi420(rgb,mem,width,height)
-
-        call yuv_rounding(temp_y,Y,width,height,rounded_width,rounded_height)
-        call yuv_rounding(temp_u,U,temp_width_crom,temp_height_crom,width_crom,height_crom)
-        call yuv_rounding(temp_v,V,temp_width_crom,temp_height_crom,width_crom,height_crom)
-
-        call mpeg_input_lumstride((value_set),rounded_width)
-        call mpeg_input_cromstride((value_set),width_crom)
-    else
-    #if action==(value_unset)
-        call free(memory)
-    endelse
-endfunction
-function mpeg_input_y(sd action,sd value,sd distance)
-    data y#1
-    data y_ref#1
-    if action==(value_set)
-        set y value
-        set y_ref y
-        add y_ref distance
-    elseif action==(value_get)
-        return y
-    else
-    #if action==(value_get_prev)
-        return y_ref
-    endelse
-endfunction
-function mpeg_input_u(sd action,sd value,sd distance)
-    data u#1
-    data u_ref#1
-    if action==(value_set)
-        set u value
-        set u_ref u
-        add u_ref distance
-    elseif action==(value_get)
-        return u
-    else
-    #if action==(value_get_prev)
-        return u_ref
-    endelse
-endfunction
-function mpeg_input_v(sd action,sd value,sd distance)
-    data v#1
-    data v_ref#1
-    if action==(value_set)
-        set v value
-        set v_ref v
-        add v_ref distance
-    elseif action==(value_get)
-        return v
-    else
-    #if action==(value_get_prev)
-        return v_ref
-    endelse
-endfunction
-function mpeg_input_lumstride(sd action,sd value)
-    data lumstride#1
-    if action==(value_set)
-        set lumstride value
-    else
-        return lumstride
-    endelse
-endfunction
-function mpeg_input_cromstride(sd action,sd value)
-    data cromstride#1
-    if action==(value_set)
-        set cromstride value
-    else
-        return cromstride
-    endelse
-endfunction
-function yuv_rounding(ss src_plane,ss dest_plane,sd src_w,sd src_h,sd dest_w,sd dest_h)
-    sd j=0
-    sd last_i
-    sd src_cursor
-    while j!=dest_h
-        if j<src_h
-            set src_cursor src_plane
-        else
-            set src_plane src_cursor
-        endelse
-        sd i=0
-        while i!=dest_w
-            if i<src_w
-                set last_i src_plane#
-                inc src_plane
-            endif
-            set dest_plane# last_i
-            inc dest_plane
-            inc i
-        endwhile
-        inc j
-    endwhile
-endfunction
-
-##write
-
-function mpeg_write_file(sd action,sd value)
-    data file#1
-    if action==(value_set)
-        set file value
-    else
-        return file
-    endelse
-endfunction
-
-import "file_write" file_write
-
-#bool
-function mpeg_write(sd buffer,sd size)
-    sd file
-    setcall file mpeg_write_file((value_get))
-    sd err
-    setcall err file_write(buffer,size,file)
-    if err!=(noerror)
-        return 0
-    endif
-    return 1
-endfunction
-
-function mpeg_file_mem_append(sd append,sd append_bits)
-    sd bool
-    setcall bool mpeg_file_mem((value_append),append,append_bits)
-    return bool
-endfunction
-
-####output memory
-
-function mpeg_file_mem(sd action,sd append,sd append_bits)
-    data mem#1
-    data size#1
-    data all_size#1
-
-    data bits#1
-    data bits_pos#1
-
-    data p_size^size
-    sd bool
-
-    if action==(value_set)
-    #bool
-        set size 0
-        set bits 0
-        set bits_pos 0
-
-        setcall all_size mpeg_buffer_size((value_get))
-        setcall mem memalloc(all_size)
-        if mem==0
-            return 0
-        endif
-        return 1
-    elseif action==(value_get)
-        return bits_pos
-    elseif action==(value_unset)
-        call free(mem)
-    elseif action==(value_append)
-    #bool
-        import "neg" neg
-
-        sd dif
-        sd bits_count
-
-        sd loop=1
-        while loop==1
-            #32-bitsPos-appendBits
-            sd shift
-            set shift 32
-            sub shift bits_pos
-            sub shift append_bits
-            #
-            if shift>=0
-                orCall bits shl(append,shift)
-                set bits_count append_bits
-            else
-                setcall dif neg(shift)
-                orCall bits shr(append,dif)
-                set bits_count append_bits
-                sub bits_count dif
-            endelse
-
-            add bits_pos bits_count
-            sub append_bits bits_count
-
-            if bits_pos==32
-                setcall bool mpeg_outbuffer_add(p_size,all_size,bits,mem,4)
-                if bool!=1
-                    return 0
-                endif
-                set bits 0
-                set bits_pos 0
-            endif
-            if append_bits==0
-                set loop 0
-            endif
-        endwhile
-        return 1
-    else
-    #if action==(value_filewrite)
-    #bool
-        if bits_pos!=0
-            sd bytes_add
-            set bytes_add bits_pos
-            add bytes_add 7
-            div bytes_add 8
-            setcall bool mpeg_outbuffer_add(p_size,all_size,bits,mem,bytes_add)
-            if bool!=1
-                return 0
-            endif
-        endif
-        setcall bool mpeg_write(mem,size)
-
-        #reset the counters and the bits store for other frames
-        set size 0
-        set bits 0
-        set bits_pos 0
-
-        return bool
-    endelse
-endfunction
-
-#bool
-function mpeg_outbuffer_add(sd p_size,sd all_size,sd bits,sd buffer,sd add_size)
-    sd size
-    set size p_size#
-    add size add_size
-    if size>all_size
-        str sizerr="Size error"
-        import "texter" texter
-        call texter(sizerr)
-        return 0
-    endif
-
-    #transform to big endian
-    import "dword_reverse" dword_reverse
-    setcall bits dword_reverse(bits)
-    add buffer p_size#
-    set buffer# bits
-
-    set p_size# size
-
-    return 1
-endfunction
-
-
-#bool
-function mpeg_mem_pad(sd mode)
-    sd bits_pos
-    setcall bits_pos mpeg_file_mem((value_get))
-    sd pad
-    sd pad_rest
-    import "rest" rest
-    setcall pad_rest rest(bits_pos,8)
-    set pad 8
-    sub pad pad_rest
-
-    if mode==(if_needed)
-        if pad==8
-            return 1
-        endif
-    endif
-    data stuff={0,1,3,7,0xf,0x1f,0x3f,0x7f}
-    sd value
-    set value pad
-    dec value
-    mult value 4
-    sd p_stuff^stuff
-    add p_stuff value
-
-    sd bool
-    setcall bool mpeg_file_mem_append(p_stuff#,pad)
-    return bool
-endfunction
-
-#bool
-function mpeg_mem_bit(sd value)
-    sd bool
-    setcall bool mpeg_file_mem_append(value,1)
-    return bool
-endfunction
-
-#bool
-function mpeg_mem_marker()
-    sd bool
-    setcall bool mpeg_file_mem_append(1,1)
-    return bool
-endfunction
-
-#bool
-function mpeg_mem_userdata(ss string)
-    sd bool
-    setcall bool mpeg_mem_pad((if_needed))
-    if bool!=1
-        return 0
-    endif
-    setcall bool mpeg_file_mem_append((USERDATA_START_CODE),32)
-    if bool!=1
-        return 0
-    endif
-    import "slen" slen
-    sd len
-    setcall len slen(string)
-    while len!=0
-        setcall bool mpeg_file_mem_append(string#,8)
-        if bool!=1
-            return 0
-        endif
-        inc string
-        dec len
-    endwhile
-    return 1
-endfunction
-
-##time
-
-import "stage_file_options_fps" stage_file_options_fps
-
-function mpeg_time(sd action,sd arg)
-    #store the frames interval and process the time
-    data begin#1
-    data end#1
-    if action==(value_set)
-        set begin 0
-        set end 0
-    elseif action==(value_get)
-    #nth_of_sec return
-        sd p_sec
-        set p_sec arg
-        #
-        sd framesstack
-        set framesstack end
-        sub framesstack begin
-        sd fps
-        setcall fps stage_file_options_fps()
-        sd sec
-        set sec framesstack
-        div sec fps
-        set p_sec# sec
-        mult sec fps
-        sd nth_of_sec
-        set nth_of_sec framesstack
-        sub nth_of_sec sec
-        return nth_of_sec
-    elseif action==(value_append)
-        set end arg
-    else
-    #if action==(value_endinterval)
-    #set the new start for the new interval
-        set begin end
-    endelse
-endfunction
-
-function mpeg_get_quant(sd type)
-    sd quant
-    set quant (DEFAULT_QUANT)
-    if type==(B_VOP)
-        add quant (DEFAULT_QUANT)
-        mult quant (ARG_BQRATIO)
-        div quant 2
-        add quant (ARG_BQOFFSET)
-        div quant 100
-    endif
-    return quant
-endfunction
-
-function mpeg_fixcode(sd mv)
-    sd fcode=1
-    while 1==1
-        sd value
-        setcall value shl(16,fcode)
-        if value>mv
-            return fcode
-        endif
-        inc fcode
-    endwhile
-    return fcode
-endfunction
-
-##rounding
-function mpeg_rounding_type(sd action,sd type)
-    data rounding#1
-    if action==(value_set)
-        if type==(I_VOP)
-            set rounding 1
-        else
-        #P_VOP
-            sd value
-            set value rounding
-            set rounding 1
-            sub rounding value
-        endelse
-    else
-        return rounding
-    endelse
-endfunction
-
-##################misc funcs
-function log2bin(sd value)
-    char log2={0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4}
-    sd n=0
-    sd x
-    set x value
-    and x 0xffff0000
-    if x!=0
-        setcall value shr(value,16)
-        add n 16
-    endif
-    set x value
-    and x 0xff00
-    if x!=0
-        setcall value shr(value,8)
-        add n 8
-    endif
-    set x value
-    and x 0xf0
-    if x!=0
-        setcall value shr(value,4)
-        add n 4
-    endif
-    ss log^log2
-    add log value
-    add n log#
-    return n
-endfunction
-
-function log2_resolution()
-    sd bits
-
-    sd fps
-    setcall fps stage_file_options_fps()
-    dec fps
-
-    setcall bits log2bin(fps)
-
-    import "get_higher" get_higher
-    setcall bits get_higher(bits,1)
-    return bits
-endfunction
-
-###########################################VOL header
-
-#bool
-function mpeg_vol_header()
-    const VISOBJ_TYPE_VIDEO=1
-    #const VIDOBJLAY_TYPE_SIMPLE=1
-    const VIDOBJLAY_TYPE_ASP=17
-
-    const Profile_Unrestricted=0xf5
-    const vo_id=0
-    const vol_id=0
-    #const vol_ver_id=1
-    #1:1 vga (square), default if supplied PAR is not a valid value
-    const XVID_PAR_11_VGA=1
-
-    sd bool
-
-    #VOS header
-    setcall bool mpeg_file_mem_append((VISOBJSEQ_START_CODE),32)
-    if bool!=1
-        return 0
-    endif
-    char vol_profile=Profile_Unrestricted
-    setcall bool mpeg_file_mem_append(vol_profile,8)
-    if bool!=1
-        return 0
-    endif
-    #byte padded
-
-    #Visual Object start code
-    setcall bool mpeg_mem_pad((if_needed))
-    if bool!=1
-        return 0
-    endif
-    setcall bool mpeg_file_mem_append((VISOBJ_START_CODE),32)
-    if bool!=1
-        return 0
-    endif
-    #visual_object_identifier=0
-    setcall bool mpeg_file_mem_append(0,1)
-    if bool!=1
-        return 0
-    endif
-
-    #Video type
-    setcall bool mpeg_file_mem_append((VISOBJ_TYPE_VIDEO),4)
-    if bool!=1
-        return 0
-    endif
-    #video_signal_type
-    setcall bool mpeg_file_mem_append(0,1)
-    if bool!=1
-        return 0
-    endif
-
-    #video object start code & vo_id
-    setcall bool mpeg_mem_pad((always))
-    if bool!=1
-        return 0
-    endif
-    setcall bool mpeg_file_mem_append((vo_id&0x5|VIDOBJ_START_CODE),32)
-    if bool!=1
-        return 0
-    endif
-
-    #video_object_layer_start_code & vol_id
-    setcall bool mpeg_mem_pad((if_needed))
-    if bool!=1
-        return 0
-    endif
-    setcall bool mpeg_file_mem_append((vol_id&0x4|VIDOBJLAY_START_CODE),32)
-    if bool!=1
-        return 0
-    endif
-
-        #random_accessible_vol
-    setcall bool mpeg_file_mem_append(0,1)
-    if bool!=1
-        return 0
-    endif
-        #video_object_type_indication
-    setcall bool mpeg_file_mem_append((VIDOBJLAY_TYPE_ASP),8)
-    if bool!=1
-        return 0
-    endif
-
-        #if vol_ver_id=1
-        #is_object_layer_identified (0=not given)
-    setcall bool mpeg_file_mem_append(0,1)
-    if bool!=1
-        return 0
-    endif
-
-    #aspect ratio
-    setcall bool mpeg_file_mem_append((XVID_PAR_11_VGA),4)
-    if bool!=1
-        return 0
-    endif
-
-    #vol_control_parameters
-    setcall bool mpeg_file_mem_append(1,1)
-    if bool!=1
-        return 0
-    endif
-
-    #chroma_format 1="4:2:0"
-    setcall bool mpeg_file_mem_append(1,2)
-    if bool!=1
-        return 0
-    endif
-
-    #low_delay
-    #if max_bframes > 0,ARG_MAXBFRAMES=2
-    setcall bool mpeg_file_mem_append(0,1)
-    if bool!=1
-        return 0
-    endif
-
-    #vbv_parameters (0=not given)
-    setcall bool mpeg_file_mem_append(0,1)
-    if bool!=1
-        return 0
-    endif
-
-    #video_object_layer_shape (0=rectangular)
-    setcall bool mpeg_file_mem_append(0,2)
-    if bool!=1
-        return 0
-    endif
-
-    setcall bool mpeg_mem_marker()
-    if bool!=1
-        return 0
-    endif
-
-    #time_inc_resolution
-
-    #framerate
-    #ARG_DWRATE
-    sd fps
-    setcall fps stage_file_options_fps()
-    setcall bool mpeg_file_mem_append(fps,16)
-    if bool!=1
-        return 0
-    endif
-
-    setcall bool mpeg_mem_marker()
-    if bool!=1
-        return 0
-    endif
-
-    #frame inc
-    #ARG_DWSCALE=1
-
-    #fixed_vop_rate = 1
-    setcall bool mpeg_mem_bit(1)
-    if bool!=1
-        return 0
-    endif
-
-    #fixed_vop_time_increment
-    sd bits
-    setcall bits log2_resolution()
-    setcall bool mpeg_file_mem_append(1,bits)
-    if bool!=1
-        return 0
-    endif
-
-    setcall bool mpeg_mem_marker()
-    if bool!=1
-        return 0
-    endif
-    #width
-    sd w
-    setcall w mpeg_image_w((value_get))
-    setcall bool mpeg_file_mem_append(w,13)
-    if bool!=1
-        return 0
-    endif
-    #
-    setcall bool mpeg_mem_marker()
-    if bool!=1
-        return 0
-    endif
-    #height
-    sd h
-    setcall h mpeg_image_h((value_get))
-    setcall bool mpeg_file_mem_append(h,13)
-    if bool!=1
-        return 0
-    endif
-    #
-    setcall bool mpeg_mem_marker()
-    if bool!=1
-        return 0
-    endif
-
-    #interlace
-    #const XVID_VOL_INTERLACING=(1<<5)
-    #vol_flags=0
-    setcall bool mpeg_mem_bit(0)
-    if bool!=1
-        return 0
-    endif
-    #obmc_disable (overlapped block motion compensation)
-    setcall bool mpeg_mem_bit(1)
-    if bool!=1
-        return 0
-    endif
-
-    #sprite_enable==off
-    setcall bool mpeg_mem_bit(0)
-    if bool!=1
-        return 0
-    endif
-
-    #not_8_bit
-    setcall bool mpeg_mem_bit(0)
-    if bool!=1
-        return 0
-    endif
-
-    #quant_type   0=h.263  1=mpeg4(quantizer tables)
-    #XVID_VOL_MPEGQUANT=(1<<0),vol_flags=0
-    setcall bool mpeg_mem_bit(0)
-    if bool!=1
-        return 0
-    endif
-
-    #complexity_estimation_disable
-    setcall bool mpeg_mem_bit(1)
-    if bool!=1
-        return 0
-    endif
-
-    #resync_marker_disabled
-    setcall bool mpeg_mem_bit((ARG_SLICES))
-    if bool!=1
-        return 0
-    endif
-
-    #data_partitioned
-    setcall bool mpeg_mem_bit(0)
-    if bool!=1
-        return 0
-    endif
-
-    #scalability
-    setcall bool mpeg_mem_bit(0)
-    if bool!=1
-        return 0
-    endif
-
-    setcall bool mpeg_mem_pad((always))
-    if bool!=1
-        return 0
-    endif
-
-    #packed bitstream
-    const XVID_GLOBAL_PACKED=2$0
-    #closed_gop:	was DX50BVOP dx50 bvop compatibility
-    const XVID_GLOBAL_CLOSED_GOP=2$1
-    #write divx5 userdata string,this is implied if XVID_GLOBAL_PACKED is set
-    const XVID_GLOBAL_DIVX5_USERDATA=2$5
-    sd global_flags=XVID_GLOBAL_PACKED|XVID_GLOBAL_CLOSED_GOP|XVID_GLOBAL_DIVX5_USERDATA
-    sd flags
-    set flags global_flags
-    and flags (XVID_GLOBAL_DIVX5_USERDATA)
-    if flags!=0
-        str sign="OApplications"
-        #str divx="DivX503b1393"
-        setcall bool mpeg_mem_userdata(sign)
-        if bool!=1
-            return 0
-        endif
-        #if max_bframes > 0,ARG_MAXBFRAMES=2
-        char p="p"
-        set flags global_flags
-        and flags (XVID_GLOBAL_PACKED)
-        if flags!=0
-            setcall bool mpeg_file_mem_append(p,8)
-            if bool!=1
-                return 0
-            endif
-        endif
-    endif
-
-    #"VOP" flags
-#define XVID_VOP_DEBUG                (1<< 0) /* print debug messages in frames */
-    #use halfpel interpolation
-    #const XVID_VOP_HALFPEL=2$1
-    #use 4 motion vectors per MB
-    #const XVID_VOP_INTER4V=2$2
-    #use trellis based R-D "optimal" quantization
-    #const XVID_VOP_TRELLISQUANT=2$3
-#define XVID_VOP_CHROMAOPT            (1<< 4) /* enable chroma optimization pre-filter */
-#define XVID_VOP_CARTOON              (1<< 5) /* use 'cartoon mode' */
-#define XVID_VOP_GREYSCALE            (1<< 6) /* enable greyscale only mode (even for  color input material chroma is ignored) */
-    #high quality ac prediction
-    #const XVID_VOP_HQACPRED=2$7
-    #enable DCT-ME and use it for mode decision
-    #const XVID_VOP_MODEDECISION_RD=2$8
-#define XVID_VOP_FAST_MODEDECISION_RD (1<<12) /* use simplified R-D mode decision */
-#define XVID_VOP_RD_BVOP              (1<<13) /* enable rate-distortion mode decision in b-frames */
-#define XVID_VOP_RD_PSNRHVSM          (1<<14) /* use PSNR-HVS-M as metric for rate-distortion optimizations */
-    #sd vop_flags=XVID_VOP_HALFPEL|XVID_VOP_INTER4V|XVID_VOP_TRELLISQUANT|XVID_VOP_HQACPRED|XVID_VOP_MODEDECISION_RD
-
-    #str xvid="XviD0064"
-    str signature="OApplications"
-    setcall bool mpeg_mem_userdata(signature)
-    if bool!=1
-        return 0
-    endif
-
-    return 1
-endfunction
-
-
-############vop header
-#bool
-function mpeg_vop_header(sd type,sd vop_coded,sd seconds,sd nth_of_sec)
-    sd bool
-    setcall bool mpeg_file_mem_append((VOP_START_CODE),32)
-    if bool!=1
-        return 0
-    endif
-
-#intra,prediction,backward
-#define I_VOP	0
-#define P_VOP	1
-#define B_VOP	2
-    setcall bool mpeg_file_mem_append(type,2)
-    if bool!=1
-        return 0
-    endif
-
-    #time
-    #frame seconds
-    sd i=0
-    while i<seconds
-        setcall bool mpeg_mem_bit(1)
-        if bool!=1
-            return 0
-        endif
-        inc i
-    endwhile
-        #termination
-    setcall bool mpeg_mem_bit(0)
-    if bool!=1
-        return 0
-    endif
-
-    setcall bool mpeg_mem_marker()
-    if bool!=1
-        return 0
-    endif
-
-    #nth of sec(of fps)
-    sd bits
-    setcall bits log2_resolution()
-    setcall bool mpeg_file_mem_append(nth_of_sec,bits)
-    if bool!=1
-        return 0
-    endif
-
-    setcall bool mpeg_mem_marker()
-    if bool!=1
-        return 0
-    endif
-
-    #not vop_coded
-    if vop_coded==0
-        setcall bool mpeg_mem_bit(0)
-        if bool!=1
-            return 0
-        endif
-        return 1
-    endif
-
-    #vop_coded
-    setcall bool mpeg_mem_bit(1)
-    if bool!=1
-        return 0
-    endif
-
-    #(frame->coding_type == P_VOP) || (frame->coding_type == S_VOP)
-    if type==(P_VOP)
-        #rounding_type
-        sd rounding
-        setcall rounding mpeg_rounding_type((value_get))
-        setcall bool mpeg_mem_bit(rounding)
-        if bool!=1
-            return 0
-        endif
-    endif
-
-    #intra_dc_vlc_threshold
-    setcall bool mpeg_file_mem_append(0,3)
-    if bool!=1
-        return 0
-    endif
-
-    #frame->vol_flags & XVID_VOL_INTERLACING
-
-    #frame->coding_type == S_VOP
-
-    #quantizer
-    sd quant
-    setcall quant mpeg_get_quant(type)
-    setcall bool mpeg_file_mem_append(quant,5)
-    if bool!=1
-        return 0
-    endif
-
-    if type!=(I_VOP)
-    #forward_fixed_code
-        sd fcode
-        setcall fcode mpeg_fixcode(0)
-        setcall bool mpeg_file_mem_append(fcode,3)
-        if bool!=1
-            return 0
-        endif
-
-        if type==(B_VOP)
-    #backward_fixed_code
-            sd bcode
-            setcall bcode mpeg_fixcode(0)
-            setcall bool mpeg_file_mem_append(bcode,3)
-            if bool!=1
-                return 0
-            endif
-        endif
-    endif
-
-    return 1
-endfunction
-
-
-
-
-##########options
-function mpeg_options(sd mem,sd *size)
-    sd value
-    sd p_value^value
-    sd mem_sz^mem
-    import "get_mem_int_advance" get_mem_int_advance
-    sd err
-
-    setcall err get_mem_int_advance(p_value,mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    call mpeg_single_tolerance((value_set),value)
-
-    setcall err get_mem_int_advance(p_value,mem_sz)
-    if err!=(noerror)
-        return 0
-    endif
-    call mpeg_group_tolerance((value_set),value)
-endfunction
-
-function mpeg_single_tolerance(sd action,sd value)
-    data single_tolerance#1
-    if action==(value_set)
-        set single_tolerance value
-    else
-        return single_tolerance
-    endelse
-endfunction
-function mpeg_group_tolerance(sd action,sd value)
-    data group_tolerance#1
-    if action==(value_set)
-        set group_tolerance value
-    else
-        return group_tolerance
-    endelse
-endfunction
-
-function mpeg_settings_init(sd vbox,sd *dialog)
-    import "hscalefield" hscalefield
-    sd scale
-    sd value
-    import "hboxfield_cnt" hboxfield_cnt
-    sd hbox
-    import "labelfield_left_default" labelfield_left_default
-
-    str s="Single Tolerance: "
-    setcall hbox hboxfield_cnt(vbox)
-    call labelfield_left_default(s,hbox)
-    setcall value mpeg_single_tolerance((value_get))
-    setcall scale hscalefield(hbox,0,255,1,value)
-    call mpeg_single_scale((value_set),scale)
-
-    str g="Group Tolerance: "
-    setcall hbox hboxfield_cnt(vbox)
-    call labelfield_left_default(g,hbox)
-    setcall value mpeg_group_tolerance((value_get))
-    setcall scale hscalefield(hbox,0,256,1,value)
-    call mpeg_group_scale((value_set),scale)
-endfunction
-function mpeg_settings_set()
-    import "file_write_forward_sys_folder_enter_leave" file_write_forward_sys_folder_enter_leave
-    data forw_mpeg^mpeg_settings_set_write
-    import "mpeg_file" mpeg_file
-    ss mpeg_fl_str
-    setcall mpeg_fl_str mpeg_file()
-    call file_write_forward_sys_folder_enter_leave(mpeg_fl_str,forw_mpeg)
-endfunction
-
-function mpeg_settings_set_write(sd mpeg_fl)
-    import "hscale_get" hscale_get
-    sd value
-    sd scale
-    sd p_value^value
-
-    setcall scale mpeg_single_scale((value_get))
-    setcall value hscale_get(scale)
-    call mpeg_single_tolerance((value_set),value)
-
-    call file_write(p_value,4,mpeg_fl)
-
-    setcall scale mpeg_group_scale((value_get))
-    setcall value hscale_get(scale)
-    call mpeg_group_tolerance((value_set),value)
-
-    call file_write(p_value,4,mpeg_fl)
-endfunction
-
-function mpeg_single_scale(sd action,sd value)
-    data single_scale#1
-    if action==(value_set)
-        set single_scale value
-    else
-        return single_scale
-    endelse
-endfunction
-function mpeg_group_scale(sd action,sd value)
-    data group_scale#1
-    if action==(value_set)
-        set group_scale value
-    else
-        return group_scale
-    endelse
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg_code.oc
@@ -0,0 +1,611 @@
+
+
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+const MODE_INTRA=3
+
+import "array_get_int16" array_get_int16
+import "shl" shl
+import "array_get_int" array_get_int
+
+#bool
+function mpeg_mb_code(sd cbp,sd acpred_direction,sd qcoeff,sd type)
+    sd bool
+
+    import "mpeg_file_mem_append" mpeg_file_mem_append
+    import "mpeg_mem_bit" mpeg_mem_bit
+
+    if type=(P_VOP)
+        #not skip
+        setcall bool mpeg_mem_bit(0)
+        if bool!=1
+            return 0
+        endif
+    endif
+
+    const mb_mode=MODE_INTRA
+    #write mcbpc
+    sd mcbpc
+    sd mb_cbp
+    sd code
+    sd len
+    set mcbpc (mb_mode)
+    set mb_cbp cbp
+    if type=(I_VOP)
+        div mcbpc 2
+        and mcbpc 3
+
+        and mb_cbp 3
+        mult mb_cbp 4
+        or mcbpc mb_cbp
+
+        setcall code mcbpc_intra_tab(mcbpc,(VLC_code))
+        setcall len mcbpc_intra_tab(mcbpc,(VLC_len))
+    else
+        and mcbpc 7
+
+        and mb_cbp 3
+        setcall mb_cbp shl(mb_cbp,3)
+        or mcbpc mb_cbp
+
+        setcall code mcbpc_inter_tab(mcbpc,(VLC_code))
+        setcall len mcbpc_inter_tab(mcbpc,(VLC_len))
+    endelse
+    setcall bool mpeg_file_mem_append(code,len)
+    if bool!=1
+        return 0
+    endif
+
+    sd acpred
+    if acpred_direction#!=0
+        set acpred 1
+    else
+        set acpred 0
+    endelse
+    setcall bool mpeg_mem_bit(acpred)
+    if bool!=1
+        return 0
+    endif
+
+    #write cbpy
+    sd cbp_y
+    set cbp_y cbp
+    div cbp_y 4
+
+    setcall code cbpy_tab(cbp_y,(VLC_code))
+    setcall len cbpy_tab(cbp_y,(VLC_len))
+    setcall bool mpeg_file_mem_append(code,len)
+    if bool!=1
+        return 0
+    endif
+
+    #code block coeffs
+    sd i=0
+    sd ind
+    while i<6
+        set ind i
+        mult ind 64
+        setcall ind array_get_int16(qcoeff,ind)
+        add ind 255
+        if i<4
+            setcall code dcy_tab(ind,(VLC_code))
+            setcall len dcy_tab(ind,(VLC_len))
+        else
+            setcall code dcc_tab(ind,(VLC_code))
+            setcall len dcc_tab(ind,(VLC_len))
+        endelse
+        setcall bool mpeg_file_mem_append(code,len)
+        if bool!=1
+            return 0
+        endif
+
+        sd value
+        set value 5
+        sub value i
+        setcall value shl(1,value)
+        and value cbp
+
+        if value!=0
+            set ind (64*int16)
+            mult ind i
+            sd qcoeff_cursor
+            set qcoeff_cursor qcoeff
+            add qcoeff_cursor ind
+
+            setcall ind array_get_int(acpred_direction,i)
+
+            setcall bool coef_intra_calc_code(qcoeff_cursor,ind)
+            if bool!=1
+                return 0
+            endif
+        endif
+
+        inc i
+    endwhile
+    return 1
+endfunction
+
+function mcbpc_intra_tab(sd x,sd block)
+#MCBPC Indexing by cbpc in first two bits, mode in last two.
+#CBPC as in table 4/H.263, MB type (mode): 3 = 01, 4 = 10.
+#Example: cbpc = 01 and mode = 4 gives index = 0110 = 6.
+    char mcbpc_intra_tab_data={0x01,0,0,0, 9, 0x01,0,0,0, 1, 0x01,0,0,0, 4, 0x00,0,0,0, 0}
+    char *                   ={0x00,0,0,0, 0, 0x01,0,0,0, 3, 0x01,0,0,0, 6, 0x00,0,0,0, 0}
+    char *                   ={0x00,0,0,0, 0, 0x02,0,0,0, 3, 0x02,0,0,0, 6, 0x00,0,0,0, 0}
+    char *                   ={0x00,0,0,0, 0, 0x03,0,0,0, 3, 0x03,0,0,0, 6}
+
+    sd ind
+    set ind x
+    mult ind (VLC_size)
+    add ind block
+
+    sd mcbpc_intra^mcbpc_intra_tab_data
+    add mcbpc_intra ind
+	if block=(VLC_code)
+        return mcbpc_intra#
+	endif
+        ss byte
+        set byte mcbpc_intra
+        return byte#
+endfunction
+
+function mcbpc_inter_tab(sd x,sd block)
+    #MCBPC inter.
+    #Addressing: 5 bit ccmmm (cc = CBPC, mmm = mode (1-4 binary))
+    #29 entries
+    char mcbpc_inter_tab_data={0x01,0,0,0, 1, 0x03,0,0,0, 3, 0x02,0,0,0, 3, 0x03,0,0,0, 5, 0x04,0,0,0, 6, 0x01,0,0,0, 9, 0x00,0,0,0, 0, 0x00,0,0,0, 0}
+    char *                   ={0x03,0,0,0, 4, 0x07,0,0,0, 7, 0x05,0,0,0, 7, 0x04,0,0,0, 8, 0x04,0,0,0, 9, 0x00,0,0,0, 0, 0x00,0,0,0, 0, 0x00,0,0,0, 0}
+    char *                   ={0x02,0,0,0, 4, 0x06,0,0,0, 7, 0x04,0,0,0, 7, 0x03,0,0,0, 8, 0x03,0,0,0, 9, 0x00,0,0,0, 0, 0x00,0,0,0, 0, 0x00,0,0,0, 0}
+    char *                   ={0x05,0,0,0, 6, 0x05,0,0,0, 9, 0x05,0,0,0, 8, 0x03,0,0,0, 7, 0x02,0,0,0, 9}
+
+    sd ind
+    set ind x
+    mult ind (VLC_size)
+    add ind block
+
+    sd mcbpc_inter^mcbpc_inter_tab_data
+    add mcbpc_inter ind
+	if block=(VLC_code)
+        return mcbpc_inter#
+	endif
+        ss byte
+        set byte mcbpc_inter
+        return byte#
+endfunction
+
+function cbpy_tab(sd x,sd block)
+    char cbpy_data={3,0,0,0, 4, 5,0,0,0, 5, 4,0,0,0, 5, 9, 0,0,0, 4, 3,0,0,0, 5, 7,0,0,0, 4, 2,0,0,0, 6, 11,0,0,0, 4}
+    char *        ={2,0,0,0, 5, 3,0,0,0, 6, 5,0,0,0, 4, 10,0,0,0, 4, 4,0,0,0, 4, 8,0,0,0, 4, 6,0,0,0, 4, 3, 0,0,0, 2}
+
+    sd ind
+    set ind x
+    mult ind (VLC_size)
+    add ind block
+
+    sd cbpy^cbpy_data
+    add cbpy ind
+	if block=(VLC_code)
+        return cbpy#
+	endif
+        ss byte
+        set byte cbpy
+        return byte#
+endfunction
+
+function dcy_tab(sd x,sd block)
+    char dcy_tab_data={0x00,1,0,0, 15, 0x01,1,0,0, 15, 0x02,1,0,0, 15, 0x03,1,0,0, 15}
+    char *           ={0x04,1,0,0, 15, 0x05,1,0,0, 15, 0x06,1,0,0, 15, 0x07,1,0,0, 15}
+    char *           ={0x08,1,0,0, 15, 0x09,1,0,0, 15, 0x0a,1,0,0, 15, 0x0b,1,0,0, 15}
+    char *           ={0x0c,1,0,0, 15, 0x0d,1,0,0, 15, 0x0e,1,0,0, 15, 0x0f,1,0,0, 15}
+    char *           ={0x10,1,0,0, 15, 0x11,1,0,0, 15, 0x12,1,0,0, 15, 0x13,1,0,0, 15}
+    char *           ={0x14,1,0,0, 15, 0x15,1,0,0, 15, 0x16,1,0,0, 15, 0x17,1,0,0, 15}
+    char *           ={0x18,1,0,0, 15, 0x19,1,0,0, 15, 0x1a,1,0,0, 15, 0x1b,1,0,0, 15}
+    char *           ={0x1c,1,0,0, 15, 0x1d,1,0,0, 15, 0x1e,1,0,0, 15, 0x1f,1,0,0, 15}
+    char *           ={0x20,1,0,0, 15, 0x21,1,0,0, 15, 0x22,1,0,0, 15, 0x23,1,0,0, 15}
+    char *           ={0x24,1,0,0, 15, 0x25,1,0,0, 15, 0x26,1,0,0, 15, 0x27,1,0,0, 15}
+    char *           ={0x28,1,0,0, 15, 0x29,1,0,0, 15, 0x2a,1,0,0, 15, 0x2b,1,0,0, 15}
+    char *           ={0x2c,1,0,0, 15, 0x2d,1,0,0, 15, 0x2e,1,0,0, 15, 0x2f,1,0,0, 15}
+    char *           ={0x30,1,0,0, 15, 0x31,1,0,0, 15, 0x32,1,0,0, 15, 0x33,1,0,0, 15}
+    char *           ={0x34,1,0,0, 15, 0x35,1,0,0, 15, 0x36,1,0,0, 15, 0x37,1,0,0, 15}
+    char *           ={0x38,1,0,0, 15, 0x39,1,0,0, 15, 0x3a,1,0,0, 15, 0x3b,1,0,0, 15}
+    char *           ={0x3c,1,0,0, 15, 0x3d,1,0,0, 15, 0x3e,1,0,0, 15, 0x3f,1,0,0, 15}
+    char *           ={0x40,1,0,0, 15, 0x41,1,0,0, 15, 0x42,1,0,0, 15, 0x43,1,0,0, 15}
+    char *           ={0x44,1,0,0, 15, 0x45,1,0,0, 15, 0x46,1,0,0, 15, 0x47,1,0,0, 15}
+    char *           ={0x48,1,0,0, 15, 0x49,1,0,0, 15, 0x4a,1,0,0, 15, 0x4b,1,0,0, 15}
+    char *           ={0x4c,1,0,0, 15, 0x4d,1,0,0, 15, 0x4e,1,0,0, 15, 0x4f,1,0,0, 15}
+    char *           ={0x50,1,0,0, 15, 0x51,1,0,0, 15, 0x52,1,0,0, 15, 0x53,1,0,0, 15}
+    char *           ={0x54,1,0,0, 15, 0x55,1,0,0, 15, 0x56,1,0,0, 15, 0x57,1,0,0, 15}
+    char *           ={0x58,1,0,0, 15, 0x59,1,0,0, 15, 0x5a,1,0,0, 15, 0x5b,1,0,0, 15}
+    char *           ={0x5c,1,0,0, 15, 0x5d,1,0,0, 15, 0x5e,1,0,0, 15, 0x5f,1,0,0, 15}
+    char *           ={0x60,1,0,0, 15, 0x61,1,0,0, 15, 0x62,1,0,0, 15, 0x63,1,0,0, 15}
+    char *           ={0x64,1,0,0, 15, 0x65,1,0,0, 15, 0x66,1,0,0, 15, 0x67,1,0,0, 15}
+    char *           ={0x68,1,0,0, 15, 0x69,1,0,0, 15, 0x6a,1,0,0, 15, 0x6b,1,0,0, 15}
+    char *           ={0x6c,1,0,0, 15, 0x6d,1,0,0, 15, 0x6e,1,0,0, 15, 0x6f,1,0,0, 15}
+    char *           ={0x70,1,0,0, 15, 0x71,1,0,0, 15, 0x72,1,0,0, 15, 0x73,1,0,0, 15}
+    char *           ={0x74,1,0,0, 15, 0x75,1,0,0, 15, 0x76,1,0,0, 15, 0x77,1,0,0, 15}
+    char *           ={0x78,1,0,0, 15, 0x79,1,0,0, 15, 0x7a,1,0,0, 15, 0x7b,1,0,0, 15}
+    char *           ={0x7c,1,0,0, 15, 0x7d,1,0,0, 15, 0x7e,1,0,0, 15, 0x7f,1,0,0, 15}
+    char *           ={0x80,0,0,0, 13, 0x81,0,0,0, 13, 0x82,0,0,0, 13, 0x83,0,0,0, 13}
+    char *           ={0x84,0,0,0, 13, 0x85,0,0,0, 13, 0x86,0,0,0, 13, 0x87,0,0,0, 13}
+    char *           ={0x88,0,0,0, 13, 0x89,0,0,0, 13, 0x8a,0,0,0, 13, 0x8b,0,0,0, 13}
+    char *           ={0x8c,0,0,0, 13, 0x8d,0,0,0, 13, 0x8e,0,0,0, 13, 0x8f,0,0,0, 13}
+    char *           ={0x90,0,0,0, 13, 0x91,0,0,0, 13, 0x92,0,0,0, 13, 0x93,0,0,0, 13}
+    char *           ={0x94,0,0,0, 13, 0x95,0,0,0, 13, 0x96,0,0,0, 13, 0x97,0,0,0, 13}
+    char *           ={0x98,0,0,0, 13, 0x99,0,0,0, 13, 0x9a,0,0,0, 13, 0x9b,0,0,0, 13}
+    char *           ={0x9c,0,0,0, 13, 0x9d,0,0,0, 13, 0x9e,0,0,0, 13, 0x9f,0,0,0, 13}
+    char *           ={0xa0,0,0,0, 13, 0xa1,0,0,0, 13, 0xa2,0,0,0, 13, 0xa3,0,0,0, 13}
+    char *           ={0xa4,0,0,0, 13, 0xa5,0,0,0, 13, 0xa6,0,0,0, 13, 0xa7,0,0,0, 13}
+    char *           ={0xa8,0,0,0, 13, 0xa9,0,0,0, 13, 0xaa,0,0,0, 13, 0xab,0,0,0, 13}
+    char *           ={0xac,0,0,0, 13, 0xad,0,0,0, 13, 0xae,0,0,0, 13, 0xaf,0,0,0, 13}
+    char *           ={0xb0,0,0,0, 13, 0xb1,0,0,0, 13, 0xb2,0,0,0, 13, 0xb3,0,0,0, 13}
+    char *           ={0xb4,0,0,0, 13, 0xb5,0,0,0, 13, 0xb6,0,0,0, 13, 0xb7,0,0,0, 13}
+    char *           ={0xb8,0,0,0, 13, 0xb9,0,0,0, 13, 0xba,0,0,0, 13, 0xbb,0,0,0, 13}
+    char *           ={0xbc,0,0,0, 13, 0xbd,0,0,0, 13, 0xbe,0,0,0, 13, 0xbf,0,0,0, 13}
+    char *           ={0x40,0,0,0, 11, 0x41,0,0,0, 11, 0x42,0,0,0, 11, 0x43,0,0,0, 11}
+    char *           ={0x44,0,0,0, 11, 0x45,0,0,0, 11, 0x46,0,0,0, 11, 0x47,0,0,0, 11}
+    char *           ={0x48,0,0,0, 11, 0x49,0,0,0, 11, 0x4a,0,0,0, 11, 0x4b,0,0,0, 11}
+    char *           ={0x4c,0,0,0, 11, 0x4d,0,0,0, 11, 0x4e,0,0,0, 11, 0x4f,0,0,0, 11}
+    char *           ={0x50,0,0,0, 11, 0x51,0,0,0, 11, 0x52,0,0,0, 11, 0x53,0,0,0, 11}
+    char *           ={0x54,0,0,0, 11, 0x55,0,0,0, 11, 0x56,0,0,0, 11, 0x57,0,0,0, 11}
+    char *           ={0x58,0,0,0, 11, 0x59,0,0,0, 11, 0x5a,0,0,0, 11, 0x5b,0,0,0, 11}
+    char *           ={0x5c,0,0,0, 11, 0x5d,0,0,0, 11, 0x5e,0,0,0, 11, 0x5f,0,0,0, 11}
+    char *           ={0x20,0,0,0, 9,  0x21,0,0,0, 9,  0x22,0,0,0, 9,  0x23,0,0,0, 9}
+    char *           ={0x24,0,0,0, 9,  0x25,0,0,0, 9,  0x26,0,0,0, 9,  0x27,0,0,0, 9}
+    char *           ={0x28,0,0,0, 9,  0x29,0,0,0, 9,  0x2a,0,0,0, 9,  0x2b,0,0,0, 9}
+    char *           ={0x2c,0,0,0, 9,  0x2d,0,0,0, 9,  0x2e,0,0,0, 9,  0x2f,0,0,0, 9}
+    char *           ={0x10,0,0,0, 7,  0x11,0,0,0, 7,  0x12,0,0,0, 7,  0x13,0,0,0, 7}
+    char *           ={0x14,0,0,0, 7,  0x15,0,0,0, 7,  0x16,0,0,0, 7,  0x17,0,0,0, 7}
+    char *           ={0x10,0,0,0, 6,  0x11,0,0,0, 6,  0x12,0,0,0, 6,  0x13,0,0,0, 6}
+    char *           ={0x08,0,0,0, 4,  0x09,0,0,0, 4,  0x06,0,0,0, 3,  0x03,0,0,0, 3}
+    char *           ={0x07,0,0,0, 3,  0x0a,0,0,0, 4,  0x0b,0,0,0, 4,  0x14,0,0,0, 6}
+    char *           ={0x15,0,0,0, 6,  0x16,0,0,0, 6,  0x17,0,0,0, 6,  0x18,0,0,0, 7}
+    char *           ={0x19,0,0,0, 7,  0x1a,0,0,0, 7,  0x1b,0,0,0, 7,  0x1c,0,0,0, 7}
+    char *           ={0x1d,0,0,0, 7,  0x1e,0,0,0, 7,  0x1f,0,0,0, 7,  0x30,0,0,0, 9}
+    char *           ={0x31,0,0,0, 9,  0x32,0,0,0, 9,  0x33,0,0,0, 9,  0x34,0,0,0, 9}
+    char *           ={0x35,0,0,0, 9,  0x36,0,0,0, 9,  0x37,0,0,0, 9,  0x38,0,0,0, 9}
+    char *           ={0x39,0,0,0, 9,  0x3a,0,0,0, 9,  0x3b,0,0,0, 9,  0x3c,0,0,0, 9}
+    char *           ={0x3d,0,0,0, 9,  0x3e,0,0,0, 9,  0x3f,0,0,0, 9,  0x60,0,0,0, 11}
+    char *           ={0x61,0,0,0, 11, 0x62,0,0,0, 11, 0x63,0,0,0, 11, 0x64,0,0,0, 11}
+    char *           ={0x65,0,0,0, 11, 0x66,0,0,0, 11, 0x67,0,0,0, 11, 0x68,0,0,0, 11}
+    char *           ={0x69,0,0,0, 11, 0x6a,0,0,0, 11, 0x6b,0,0,0, 11, 0x6c,0,0,0, 11}
+    char *           ={0x6d,0,0,0, 11, 0x6e,0,0,0, 11, 0x6f,0,0,0, 11, 0x70,0,0,0, 11}
+    char *           ={0x71,0,0,0, 11, 0x72,0,0,0, 11, 0x73,0,0,0, 11, 0x74,0,0,0, 11}
+    char *           ={0x75,0,0,0, 11, 0x76,0,0,0, 11, 0x77,0,0,0, 11, 0x78,0,0,0, 11}
+    char *           ={0x79,0,0,0, 11, 0x7a,0,0,0, 11, 0x7b,0,0,0, 11, 0x7c,0,0,0, 11}
+    char *           ={0x7d,0,0,0, 11, 0x7e,0,0,0, 11, 0x7f,0,0,0, 11, 0xc0,0,0,0, 13}
+    char *           ={0xc1,0,0,0, 13, 0xc2,0,0,0, 13, 0xc3,0,0,0, 13, 0xc4,0,0,0, 13}
+    char *           ={0xc5,0,0,0, 13, 0xc6,0,0,0, 13, 0xc7,0,0,0, 13, 0xc8,0,0,0, 13}
+    char *           ={0xc9,0,0,0, 13, 0xca,0,0,0, 13, 0xcb,0,0,0, 13, 0xcc,0,0,0, 13}
+    char *           ={0xcd,0,0,0, 13, 0xce,0,0,0, 13, 0xcf,0,0,0, 13, 0xd0,0,0,0, 13}
+    char *           ={0xd1,0,0,0, 13, 0xd2,0,0,0, 13, 0xd3,0,0,0, 13, 0xd4,0,0,0, 13}
+    char *           ={0xd5,0,0,0, 13, 0xd6,0,0,0, 13, 0xd7,0,0,0, 13, 0xd8,0,0,0, 13}
+    char *           ={0xd9,0,0,0, 13, 0xda,0,0,0, 13, 0xdb,0,0,0, 13, 0xdc,0,0,0, 13}
+    char *           ={0xdd,0,0,0, 13, 0xde,0,0,0, 13, 0xdf,0,0,0, 13, 0xe0,0,0,0, 13}
+    char *           ={0xe1,0,0,0, 13, 0xe2,0,0,0, 13, 0xe3,0,0,0, 13, 0xe4,0,0,0, 13}
+    char *           ={0xe5,0,0,0, 13, 0xe6,0,0,0, 13, 0xe7,0,0,0, 13, 0xe8,0,0,0, 13}
+    char *           ={0xe9,0,0,0, 13, 0xea,0,0,0, 13, 0xeb,0,0,0, 13, 0xec,0,0,0, 13}
+    char *           ={0xed,0,0,0, 13, 0xee,0,0,0, 13, 0xef,0,0,0, 13, 0xf0,0,0,0, 13}
+    char *           ={0xf1,0,0,0, 13, 0xf2,0,0,0, 13, 0xf3,0,0,0, 13, 0xf4,0,0,0, 13}
+    char *           ={0xf5,0,0,0, 13, 0xf6,0,0,0, 13, 0xf7,0,0,0, 13, 0xf8,0,0,0, 13}
+    char *           ={0xf9,0,0,0, 13, 0xfa,0,0,0, 13, 0xfb,0,0,0, 13, 0xfc,0,0,0, 13}
+    char *           ={0xfd,0,0,0, 13, 0xfe,0,0,0, 13, 0xff,0,0,0, 13, 0x80,1,0,0, 15}
+    char *           ={0x81,1,0,0, 15, 0x82,1,0,0, 15, 0x83,1,0,0, 15, 0x84,1,0,0, 15}
+    char *           ={0x85,1,0,0, 15, 0x86,1,0,0, 15, 0x87,1,0,0, 15, 0x88,1,0,0, 15}
+    char *           ={0x89,1,0,0, 15, 0x8a,1,0,0, 15, 0x8b,1,0,0, 15, 0x8c,1,0,0, 15}
+    char *           ={0x8d,1,0,0, 15, 0x8e,1,0,0, 15, 0x8f,1,0,0, 15, 0x90,1,0,0, 15}
+    char *           ={0x91,1,0,0, 15, 0x92,1,0,0, 15, 0x93,1,0,0, 15, 0x94,1,0,0, 15}
+    char *           ={0x95,1,0,0, 15, 0x96,1,0,0, 15, 0x97,1,0,0, 15, 0x98,1,0,0, 15}
+    char *           ={0x99,1,0,0, 15, 0x9a,1,0,0, 15, 0x9b,1,0,0, 15, 0x9c,1,0,0, 15}
+    char *           ={0x9d,1,0,0, 15, 0x9e,1,0,0, 15, 0x9f,1,0,0, 15, 0xa0,1,0,0, 15}
+    char *           ={0xa1,1,0,0, 15, 0xa2,1,0,0, 15, 0xa3,1,0,0, 15, 0xa4,1,0,0, 15}
+    char *           ={0xa5,1,0,0, 15, 0xa6,1,0,0, 15, 0xa7,1,0,0, 15, 0xa8,1,0,0, 15}
+    char *           ={0xa9,1,0,0, 15, 0xaa,1,0,0, 15, 0xab,1,0,0, 15, 0xac,1,0,0, 15}
+    char *           ={0xad,1,0,0, 15, 0xae,1,0,0, 15, 0xaf,1,0,0, 15, 0xb0,1,0,0, 15}
+    char *           ={0xb1,1,0,0, 15, 0xb2,1,0,0, 15, 0xb3,1,0,0, 15, 0xb4,1,0,0, 15}
+    char *           ={0xb5,1,0,0, 15, 0xb6,1,0,0, 15, 0xb7,1,0,0, 15, 0xb8,1,0,0, 15}
+    char *           ={0xb9,1,0,0, 15, 0xba,1,0,0, 15, 0xbb,1,0,0, 15, 0xbc,1,0,0, 15}
+    char *           ={0xbd,1,0,0, 15, 0xbe,1,0,0, 15, 0xbf,1,0,0, 15, 0xc0,1,0,0, 15}
+    char *           ={0xc1,1,0,0, 15, 0xc2,1,0,0, 15, 0xc3,1,0,0, 15, 0xc4,1,0,0, 15}
+    char *           ={0xc5,1,0,0, 15, 0xc6,1,0,0, 15, 0xc7,1,0,0, 15, 0xc8,1,0,0, 15}
+    char *           ={0xc9,1,0,0, 15, 0xca,1,0,0, 15, 0xcb,1,0,0, 15, 0xcc,1,0,0, 15}
+    char *           ={0xcd,1,0,0, 15, 0xce,1,0,0, 15, 0xcf,1,0,0, 15, 0xd0,1,0,0, 15}
+    char *           ={0xd1,1,0,0, 15, 0xd2,1,0,0, 15, 0xd3,1,0,0, 15, 0xd4,1,0,0, 15}
+    char *           ={0xd5,1,0,0, 15, 0xd6,1,0,0, 15, 0xd7,1,0,0, 15, 0xd8,1,0,0, 15}
+    char *           ={0xd9,1,0,0, 15, 0xda,1,0,0, 15, 0xdb,1,0,0, 15, 0xdc,1,0,0, 15}
+    char *           ={0xdd,1,0,0, 15, 0xde,1,0,0, 15, 0xdf,1,0,0, 15, 0xe0,1,0,0, 15}
+    char *           ={0xe1,1,0,0, 15, 0xe2,1,0,0, 15, 0xe3,1,0,0, 15, 0xe4,1,0,0, 15}
+    char *           ={0xe5,1,0,0, 15, 0xe6,1,0,0, 15, 0xe7,1,0,0, 15, 0xe8,1,0,0, 15}
+    char *           ={0xe9,1,0,0, 15, 0xea,1,0,0, 15, 0xeb,1,0,0, 15, 0xec,1,0,0, 15}
+    char *           ={0xed,1,0,0, 15, 0xee,1,0,0, 15, 0xef,1,0,0, 15, 0xf0,1,0,0, 15}
+    char *           ={0xf1,1,0,0, 15, 0xf2,1,0,0, 15, 0xf3,1,0,0, 15, 0xf4,1,0,0, 15}
+    char *           ={0xf5,1,0,0, 15, 0xf6,1,0,0, 15, 0xf7,1,0,0, 15, 0xf8,1,0,0, 15}
+    char *           ={0xf9,1,0,0, 15, 0xfa,1,0,0, 15, 0xfb,1,0,0, 15, 0xfc,1,0,0, 15}
+    char *           ={0xfd,1,0,0, 15, 0xfe,1,0,0, 15, 0xff,1,0,0, 15}
+
+    sd ind
+    set ind x
+    mult ind (VLC_size)
+    add ind block
+
+    sd dcy^dcy_tab_data
+    add dcy ind
+	if block=(VLC_code)
+        return dcy#
+	endif
+        ss byte
+        set byte dcy
+        return byte#
+endfunction
+
+function dcc_tab(sd x,sd block)
+    char dcc_tab_data={0x00,1,0,0, 16, 0x01,1,0,0, 16, 0x02,1,0,0, 16, 0x03,1,0,0, 16}
+    char *      ={0x04,1,0,0, 16, 0x05,1,0,0, 16, 0x06,1,0,0, 16, 0x07,1,0,0, 16}
+    char *      ={0x08,1,0,0, 16, 0x09,1,0,0, 16, 0x0a,1,0,0, 16, 0x0b,1,0,0, 16}
+    char *      ={0x0c,1,0,0, 16, 0x0d,1,0,0, 16, 0x0e,1,0,0, 16, 0x0f,1,0,0, 16}
+    char *      ={0x10,1,0,0, 16, 0x11,1,0,0, 16, 0x12,1,0,0, 16, 0x13,1,0,0, 16}
+    char *      ={0x14,1,0,0, 16, 0x15,1,0,0, 16, 0x16,1,0,0, 16, 0x17,1,0,0, 16}
+    char *      ={0x18,1,0,0, 16, 0x19,1,0,0, 16, 0x1a,1,0,0, 16, 0x1b,1,0,0, 16}
+    char *      ={0x1c,1,0,0, 16, 0x1d,1,0,0, 16, 0x1e,1,0,0, 16, 0x1f,1,0,0, 16}
+    char *      ={0x20,1,0,0, 16, 0x21,1,0,0, 16, 0x22,1,0,0, 16, 0x23,1,0,0, 16}
+    char *      ={0x24,1,0,0, 16, 0x25,1,0,0, 16, 0x26,1,0,0, 16, 0x27,1,0,0, 16}
+    char *      ={0x28,1,0,0, 16, 0x29,1,0,0, 16, 0x2a,1,0,0, 16, 0x2b,1,0,0, 16}
+    char *      ={0x2c,1,0,0, 16, 0x2d,1,0,0, 16, 0x2e,1,0,0, 16, 0x2f,1,0,0, 16}
+    char *      ={0x30,1,0,0, 16, 0x31,1,0,0, 16, 0x32,1,0,0, 16, 0x33,1,0,0, 16}
+    char *      ={0x34,1,0,0, 16, 0x35,1,0,0, 16, 0x36,1,0,0, 16, 0x37,1,0,0, 16}
+    char *      ={0x38,1,0,0, 16, 0x39,1,0,0, 16, 0x3a,1,0,0, 16, 0x3b,1,0,0, 16}
+    char *      ={0x3c,1,0,0, 16, 0x3d,1,0,0, 16, 0x3e,1,0,0, 16, 0x3f,1,0,0, 16}
+    char *      ={0x40,1,0,0, 16, 0x41,1,0,0, 16, 0x42,1,0,0, 16, 0x43,1,0,0, 16}
+    char *      ={0x44,1,0,0, 16, 0x45,1,0,0, 16, 0x46,1,0,0, 16, 0x47,1,0,0, 16}
+    char *      ={0x48,1,0,0, 16, 0x49,1,0,0, 16, 0x4a,1,0,0, 16, 0x4b,1,0,0, 16}
+    char *      ={0x4c,1,0,0, 16, 0x4d,1,0,0, 16, 0x4e,1,0,0, 16, 0x4f,1,0,0, 16}
+    char *      ={0x50,1,0,0, 16, 0x51,1,0,0, 16, 0x52,1,0,0, 16, 0x53,1,0,0, 16}
+    char *      ={0x54,1,0,0, 16, 0x55,1,0,0, 16, 0x56,1,0,0, 16, 0x57,1,0,0, 16}
+    char *      ={0x58,1,0,0, 16, 0x59,1,0,0, 16, 0x5a,1,0,0, 16, 0x5b,1,0,0, 16}
+    char *      ={0x5c,1,0,0, 16, 0x5d,1,0,0, 16, 0x5e,1,0,0, 16, 0x5f,1,0,0, 16}
+    char *      ={0x60,1,0,0, 16, 0x61,1,0,0, 16, 0x62,1,0,0, 16, 0x63,1,0,0, 16}
+    char *      ={0x64,1,0,0, 16, 0x65,1,0,0, 16, 0x66,1,0,0, 16, 0x67,1,0,0, 16}
+    char *      ={0x68,1,0,0, 16, 0x69,1,0,0, 16, 0x6a,1,0,0, 16, 0x6b,1,0,0, 16}
+    char *      ={0x6c,1,0,0, 16, 0x6d,1,0,0, 16, 0x6e,1,0,0, 16, 0x6f,1,0,0, 16}
+    char *      ={0x70,1,0,0, 16, 0x71,1,0,0, 16, 0x72,1,0,0, 16, 0x73,1,0,0, 16}
+    char *      ={0x74,1,0,0, 16, 0x75,1,0,0, 16, 0x76,1,0,0, 16, 0x77,1,0,0, 16}
+    char *      ={0x78,1,0,0, 16, 0x79,1,0,0, 16, 0x7a,1,0,0, 16, 0x7b,1,0,0, 16}
+    char *      ={0x7c,1,0,0, 16, 0x7d,1,0,0, 16, 0x7e,1,0,0, 16, 0x7f,1,0,0, 16}
+    char *      ={0x80,0,0,0, 14, 0x81,0,0,0, 14, 0x82,0,0,0, 14, 0x83,0,0,0, 14}
+    char *      ={0x84,0,0,0, 14, 0x85,0,0,0, 14, 0x86,0,0,0, 14, 0x87,0,0,0, 14}
+    char *      ={0x88,0,0,0, 14, 0x89,0,0,0, 14, 0x8a,0,0,0, 14, 0x8b,0,0,0, 14}
+    char *      ={0x8c,0,0,0, 14, 0x8d,0,0,0, 14, 0x8e,0,0,0, 14, 0x8f,0,0,0, 14}
+    char *      ={0x90,0,0,0, 14, 0x91,0,0,0, 14, 0x92,0,0,0, 14, 0x93,0,0,0, 14}
+    char *      ={0x94,0,0,0, 14, 0x95,0,0,0, 14, 0x96,0,0,0, 14, 0x97,0,0,0, 14}
+    char *      ={0x98,0,0,0, 14, 0x99,0,0,0, 14, 0x9a,0,0,0, 14, 0x9b,0,0,0, 14}
+    char *      ={0x9c,0,0,0, 14, 0x9d,0,0,0, 14, 0x9e,0,0,0, 14, 0x9f,0,0,0, 14}
+    char *      ={0xa0,0,0,0, 14, 0xa1,0,0,0, 14, 0xa2,0,0,0, 14, 0xa3,0,0,0, 14}
+    char *      ={0xa4,0,0,0, 14, 0xa5,0,0,0, 14, 0xa6,0,0,0, 14, 0xa7,0,0,0, 14}
+    char *      ={0xa8,0,0,0, 14, 0xa9,0,0,0, 14, 0xaa,0,0,0, 14, 0xab,0,0,0, 14}
+    char *      ={0xac,0,0,0, 14, 0xad,0,0,0, 14, 0xae,0,0,0, 14, 0xaf,0,0,0, 14}
+    char *      ={0xb0,0,0,0, 14, 0xb1,0,0,0, 14, 0xb2,0,0,0, 14, 0xb3,0,0,0, 14}
+    char *      ={0xb4,0,0,0, 14, 0xb5,0,0,0, 14, 0xb6,0,0,0, 14, 0xb7,0,0,0, 14}
+    char *      ={0xb8,0,0,0, 14, 0xb9,0,0,0, 14, 0xba,0,0,0, 14, 0xbb,0,0,0, 14}
+    char *      ={0xbc,0,0,0, 14, 0xbd,0,0,0, 14, 0xbe,0,0,0, 14, 0xbf,0,0,0, 14}
+    char *      ={0x40,0,0,0, 12, 0x41,0,0,0, 12, 0x42,0,0,0, 12, 0x43,0,0,0, 12}
+    char *      ={0x44,0,0,0, 12, 0x45,0,0,0, 12, 0x46,0,0,0, 12, 0x47,0,0,0, 12}
+    char *      ={0x48,0,0,0, 12, 0x49,0,0,0, 12, 0x4a,0,0,0, 12, 0x4b,0,0,0, 12}
+    char *      ={0x4c,0,0,0, 12, 0x4d,0,0,0, 12, 0x4e,0,0,0, 12, 0x4f,0,0,0, 12}
+    char *      ={0x50,0,0,0, 12, 0x51,0,0,0, 12, 0x52,0,0,0, 12, 0x53,0,0,0, 12}
+    char *      ={0x54,0,0,0, 12, 0x55,0,0,0, 12, 0x56,0,0,0, 12, 0x57,0,0,0, 12}
+    char *      ={0x58,0,0,0, 12, 0x59,0,0,0, 12, 0x5a,0,0,0, 12, 0x5b,0,0,0, 12}
+    char *      ={0x5c,0,0,0, 12, 0x5d,0,0,0, 12, 0x5e,0,0,0, 12, 0x5f,0,0,0, 12}
+    char *      ={0x20,0,0,0, 10, 0x21,0,0,0, 10, 0x22,0,0,0, 10, 0x23,0,0,0, 10}
+    char *      ={0x24,0,0,0, 10, 0x25,0,0,0, 10, 0x26,0,0,0, 10, 0x27,0,0,0, 10}
+    char *      ={0x28,0,0,0, 10, 0x29,0,0,0, 10, 0x2a,0,0,0, 10, 0x2b,0,0,0, 10}
+    char *      ={0x2c,0,0,0, 10, 0x2d,0,0,0, 10, 0x2e,0,0,0, 10, 0x2f,0,0,0, 10}
+    char *      ={0x10,0,0,0, 8,  0x11,0,0,0, 8,  0x12,0,0,0, 8,  0x13,0,0,0, 8}
+    char *      ={0x14,0,0,0, 8,  0x15,0,0,0, 8,  0x16,0,0,0, 8,  0x17,0,0,0, 8}
+    char *      ={0x08,0,0,0, 6,  0x09,0,0,0, 6,  0x0a,0,0,0, 6,  0x0b,0,0,0, 6}
+    char *      ={0x04,0,0,0, 4,  0x05,0,0,0, 4,  0x04,0,0,0, 3,  0x03,0,0,0, 2}
+    char *      ={0x05,0,0,0, 3,  0x06,0,0,0, 4,  0x07,0,0,0, 4,  0x0c,0,0,0, 6}
+    char *      ={0x0d,0,0,0, 6,  0x0e,0,0,0, 6,  0x0f,0,0,0, 6,  0x18,0,0,0, 8}
+    char *      ={0x19,0,0,0, 8,  0x1a,0,0,0, 8,  0x1b,0,0,0, 8,  0x1c,0,0,0, 8}
+    char *      ={0x1d,0,0,0, 8,  0x1e,0,0,0, 8,  0x1f,0,0,0, 8,  0x30,0,0,0, 10}
+    char *      ={0x31,0,0,0, 10, 0x32,0,0,0, 10, 0x33,0,0,0, 10, 0x34,0,0,0, 10}
+    char *      ={0x35,0,0,0, 10, 0x36,0,0,0, 10, 0x37,0,0,0, 10, 0x38,0,0,0, 10}
+    char *      ={0x39,0,0,0, 10, 0x3a,0,0,0, 10, 0x3b,0,0,0, 10, 0x3c,0,0,0, 10}
+    char *      ={0x3d,0,0,0, 10, 0x3e,0,0,0, 10, 0x3f,0,0,0, 10, 0x60,0,0,0, 12}
+    char *      ={0x61,0,0,0, 12, 0x62,0,0,0, 12, 0x63,0,0,0, 12, 0x64,0,0,0, 12}
+    char *      ={0x65,0,0,0, 12, 0x66,0,0,0, 12, 0x67,0,0,0, 12, 0x68,0,0,0, 12}
+    char *      ={0x69,0,0,0, 12, 0x6a,0,0,0, 12, 0x6b,0,0,0, 12, 0x6c,0,0,0, 12}
+    char *      ={0x6d,0,0,0, 12, 0x6e,0,0,0, 12, 0x6f,0,0,0, 12, 0x70,0,0,0, 12}
+    char *      ={0x71,0,0,0, 12, 0x72,0,0,0, 12, 0x73,0,0,0, 12, 0x74,0,0,0, 12}
+    char *      ={0x75,0,0,0, 12, 0x76,0,0,0, 12, 0x77,0,0,0, 12, 0x78,0,0,0, 12}
+    char *      ={0x79,0,0,0, 12, 0x7a,0,0,0, 12, 0x7b,0,0,0, 12, 0x7c,0,0,0, 12}
+    char *      ={0x7d,0,0,0, 12, 0x7e,0,0,0, 12, 0x7f,0,0,0, 12, 0xc0,0,0,0, 14}
+    char *      ={0xc1,0,0,0, 14, 0xc2,0,0,0, 14, 0xc3,0,0,0, 14, 0xc4,0,0,0, 14}
+    char *      ={0xc5,0,0,0, 14, 0xc6,0,0,0, 14, 0xc7,0,0,0, 14, 0xc8,0,0,0, 14}
+    char *      ={0xc9,0,0,0, 14, 0xca,0,0,0, 14, 0xcb,0,0,0, 14, 0xcc,0,0,0, 14}
+    char *      ={0xcd,0,0,0, 14, 0xce,0,0,0, 14, 0xcf,0,0,0, 14, 0xd0,0,0,0, 14}
+    char *      ={0xd1,0,0,0, 14, 0xd2,0,0,0, 14, 0xd3,0,0,0, 14, 0xd4,0,0,0, 14}
+    char *      ={0xd5,0,0,0, 14, 0xd6,0,0,0, 14, 0xd7,0,0,0, 14, 0xd8,0,0,0, 14}
+    char *      ={0xd9,0,0,0, 14, 0xda,0,0,0, 14, 0xdb,0,0,0, 14, 0xdc,0,0,0, 14}
+    char *      ={0xdd,0,0,0, 14, 0xde,0,0,0, 14, 0xdf,0,0,0, 14, 0xe0,0,0,0, 14}
+    char *      ={0xe1,0,0,0, 14, 0xe2,0,0,0, 14, 0xe3,0,0,0, 14, 0xe4,0,0,0, 14}
+    char *      ={0xe5,0,0,0, 14, 0xe6,0,0,0, 14, 0xe7,0,0,0, 14, 0xe8,0,0,0, 14}
+    char *      ={0xe9,0,0,0, 14, 0xea,0,0,0, 14, 0xeb,0,0,0, 14, 0xec,0,0,0, 14}
+    char *      ={0xed,0,0,0, 14, 0xee,0,0,0, 14, 0xef,0,0,0, 14, 0xf0,0,0,0, 14}
+    char *      ={0xf1,0,0,0, 14, 0xf2,0,0,0, 14, 0xf3,0,0,0, 14, 0xf4,0,0,0, 14}
+    char *      ={0xf5,0,0,0, 14, 0xf6,0,0,0, 14, 0xf7,0,0,0, 14, 0xf8,0,0,0, 14}
+    char *      ={0xf9,0,0,0, 14, 0xfa,0,0,0, 14, 0xfb,0,0,0, 14, 0xfc,0,0,0, 14}
+    char *      ={0xfd,0,0,0, 14, 0xfe,0,0,0, 14, 0xff,0,0,0, 14, 0x80,1,0,0, 16}
+    char *      ={0x81,1,0,0, 16, 0x82,1,0,0, 16, 0x83,1,0,0, 16, 0x84,1,0,0, 16}
+    char *      ={0x85,1,0,0, 16, 0x86,1,0,0, 16, 0x87,1,0,0, 16, 0x88,1,0,0, 16}
+    char *      ={0x89,1,0,0, 16, 0x8a,1,0,0, 16, 0x8b,1,0,0, 16, 0x8c,1,0,0, 16}
+    char *      ={0x8d,1,0,0, 16, 0x8e,1,0,0, 16, 0x8f,1,0,0, 16, 0x90,1,0,0, 16}
+    char *      ={0x91,1,0,0, 16, 0x92,1,0,0, 16, 0x93,1,0,0, 16, 0x94,1,0,0, 16}
+    char *      ={0x95,1,0,0, 16, 0x96,1,0,0, 16, 0x97,1,0,0, 16, 0x98,1,0,0, 16}
+    char *      ={0x99,1,0,0, 16, 0x9a,1,0,0, 16, 0x9b,1,0,0, 16, 0x9c,1,0,0, 16}
+    char *      ={0x9d,1,0,0, 16, 0x9e,1,0,0, 16, 0x9f,1,0,0, 16, 0xa0,1,0,0, 16}
+    char *      ={0xa1,1,0,0, 16, 0xa2,1,0,0, 16, 0xa3,1,0,0, 16, 0xa4,1,0,0, 16}
+    char *      ={0xa5,1,0,0, 16, 0xa6,1,0,0, 16, 0xa7,1,0,0, 16, 0xa8,1,0,0, 16}
+    char *      ={0xa9,1,0,0, 16, 0xaa,1,0,0, 16, 0xab,1,0,0, 16, 0xac,1,0,0, 16}
+    char *      ={0xad,1,0,0, 16, 0xae,1,0,0, 16, 0xaf,1,0,0, 16, 0xb0,1,0,0, 16}
+    char *      ={0xb1,1,0,0, 16, 0xb2,1,0,0, 16, 0xb3,1,0,0, 16, 0xb4,1,0,0, 16}
+    char *      ={0xb5,1,0,0, 16, 0xb6,1,0,0, 16, 0xb7,1,0,0, 16, 0xb8,1,0,0, 16}
+    char *      ={0xb9,1,0,0, 16, 0xba,1,0,0, 16, 0xbb,1,0,0, 16, 0xbc,1,0,0, 16}
+    char *      ={0xbd,1,0,0, 16, 0xbe,1,0,0, 16, 0xbf,1,0,0, 16, 0xc0,1,0,0, 16}
+    char *      ={0xc1,1,0,0, 16, 0xc2,1,0,0, 16, 0xc3,1,0,0, 16, 0xc4,1,0,0, 16}
+    char *      ={0xc5,1,0,0, 16, 0xc6,1,0,0, 16, 0xc7,1,0,0, 16, 0xc8,1,0,0, 16}
+    char *      ={0xc9,1,0,0, 16, 0xca,1,0,0, 16, 0xcb,1,0,0, 16, 0xcc,1,0,0, 16}
+    char *      ={0xcd,1,0,0, 16, 0xce,1,0,0, 16, 0xcf,1,0,0, 16, 0xd0,1,0,0, 16}
+    char *      ={0xd1,1,0,0, 16, 0xd2,1,0,0, 16, 0xd3,1,0,0, 16, 0xd4,1,0,0, 16}
+    char *      ={0xd5,1,0,0, 16, 0xd6,1,0,0, 16, 0xd7,1,0,0, 16, 0xd8,1,0,0, 16}
+    char *      ={0xd9,1,0,0, 16, 0xda,1,0,0, 16, 0xdb,1,0,0, 16, 0xdc,1,0,0, 16}
+    char *      ={0xdd,1,0,0, 16, 0xde,1,0,0, 16, 0xdf,1,0,0, 16, 0xe0,1,0,0, 16}
+    char *      ={0xe1,1,0,0, 16, 0xe2,1,0,0, 16, 0xe3,1,0,0, 16, 0xe4,1,0,0, 16}
+    char *      ={0xe5,1,0,0, 16, 0xe6,1,0,0, 16, 0xe7,1,0,0, 16, 0xe8,1,0,0, 16}
+    char *      ={0xe9,1,0,0, 16, 0xea,1,0,0, 16, 0xeb,1,0,0, 16, 0xec,1,0,0, 16}
+    char *      ={0xed,1,0,0, 16, 0xee,1,0,0, 16, 0xef,1,0,0, 16, 0xf0,1,0,0, 16}
+    char *      ={0xf1,1,0,0, 16, 0xf2,1,0,0, 16, 0xf3,1,0,0, 16, 0xf4,1,0,0, 16}
+    char *      ={0xf5,1,0,0, 16, 0xf6,1,0,0, 16, 0xf7,1,0,0, 16, 0xf8,1,0,0, 16}
+    char *      ={0xf9,1,0,0, 16, 0xfa,1,0,0, 16, 0xfb,1,0,0, 16, 0xfc,1,0,0, 16}
+    char *      ={0xfd,1,0,0, 16, 0xfe,1,0,0, 16, 0xff,1,0,0, 16}
+
+    sd ind
+    set ind x
+    mult ind (VLC_size)
+    add ind block
+
+    sd dcc^dcc_tab_data
+    add dcc ind
+	if block=(VLC_code)
+        return dcc#
+	endif
+        ss byte
+        set byte dcc
+        return byte#
+endfunction
+
+
+
+##code coeff function
+#return bool
+function coef_intra_calc_code(sd qcoeff,sd index)
+    import "mpeg_scan_tables" mpeg_scan_tables
+    sd scan_table
+    setcall scan_table mpeg_scan_tables(index)
+
+    sd i=1
+    sd run=0
+    sd level
+    sd loop=1
+    while loop=1
+        setcall level array_get_int(scan_table,i)
+        setcall level array_get_int16(qcoeff,level)
+        inc i
+
+        if level!=0
+            set loop 0
+        else
+            if i>=64
+                set loop 0
+            else
+                inc run
+            endelse
+        endelse
+    endwhile
+
+    sd prev_level
+    set prev_level level
+    sd prev_run
+    set prev_run run
+    set run 0
+    sd abs_level
+    sd code
+    sd len
+    import "vlc_tables_intra" vlc_tables_intra
+    sd bool
+    sd value
+    sd p_code
+    ss p_len
+
+    while i<64
+        setcall level array_get_int(scan_table,i)
+        setcall level array_get_int16(qcoeff,level)
+        inc i
+        if level!=0
+            set abs_level prev_level
+            if abs_level<0
+                mult abs_level -1
+            endif
+            if abs_level>=64
+                set abs_level 0
+            endif
+            setcall p_code vlc_tables_intra((value_get),(VLC_code),0,abs_level,prev_run)
+            set code p_code#
+            setcall p_len vlc_tables_intra((value_get),(VLC_len),0,abs_level,prev_run)
+            set len p_len#
+            if len!=128
+                if prev_level<0
+                    or code 1
+                endif
+            else
+                setcall code shl((ESCAPE3),21)
+                orcall code shl(prev_run,14)
+                or code (2$13)
+                set value prev_level
+                and value 0xfFF
+                mult value 2
+                or code value
+                or code 1
+
+                set len 30
+            endelse
+            setcall bool mpeg_file_mem_append(code,len)
+            if bool!=1
+                return 0
+            endif
+            set prev_level level
+            set prev_run run
+            set run 0
+        else
+            inc run
+        endelse
+    endwhile
+
+    set abs_level prev_level
+    if abs_level<0
+        mult abs_level -1
+    endif
+    if abs_level>=64
+        set abs_level 0
+    endif
+
+    setcall p_code vlc_tables_intra((value_get),(VLC_code),1,abs_level,prev_run)
+    set code p_code#
+    setcall p_len vlc_tables_intra((value_get),(VLC_len),1,abs_level,prev_run)
+    set len p_len#
+    if len!=128
+        if prev_level<0
+            or code 1
+        endif
+    else
+        setcall code shl((ESCAPE3),21)
+        or code (2$20)
+        orcall code shl(prev_run,14)
+        or code (2$13)
+        set value prev_level
+        and value 0xfFF
+        mult value 2
+        or code value
+        or code 1
+
+        set len 30
+    endelse
+    setcall bool mpeg_file_mem_append(code,len)
+    if bool!=1
+        return 0
+    endif
+    return 1
+endfunction
--- ovideo-1.orig/src/media/mpeg_code.s
+++ /dev/null
@@ -1,616 +0,0 @@
-
-
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-const MODE_INTRA=3
-
-import "array_get_int16" array_get_int16
-import "shl" shl
-import "array_get_int" array_get_int
-
-#bool
-function mpeg_mb_code(sd cbp,sd acpred_direction,sd qcoeff,sd type)
-    sd bool
-
-    import "mpeg_file_mem_append" mpeg_file_mem_append
-    import "mpeg_mem_bit" mpeg_mem_bit
-
-    if type==(P_VOP)
-        #not skip
-        setcall bool mpeg_mem_bit(0)
-        if bool!=1
-            return 0
-        endif
-    endif
-
-    const mb_mode=MODE_INTRA
-    #write mcbpc
-    sd mcbpc
-    sd mb_cbp
-    sd code
-    sd len
-    set mcbpc (mb_mode)
-    set mb_cbp cbp
-    if type==(I_VOP)
-        div mcbpc 2
-        and mcbpc 3
-
-        and mb_cbp 3
-        mult mb_cbp 4
-        or mcbpc mb_cbp
-
-        setcall code mcbpc_intra_tab(mcbpc,(VLC_code))
-        setcall len mcbpc_intra_tab(mcbpc,(VLC_len))
-    else
-        and mcbpc 7
-
-        and mb_cbp 3
-        setcall mb_cbp shl(mb_cbp,3)
-        or mcbpc mb_cbp
-
-        setcall code mcbpc_inter_tab(mcbpc,(VLC_code))
-        setcall len mcbpc_inter_tab(mcbpc,(VLC_len))
-    endelse
-    setcall bool mpeg_file_mem_append(code,len)
-    if bool!=1
-        return 0
-    endif
-
-    sd acpred
-    if acpred_direction#!=0
-        set acpred 1
-    else
-        set acpred 0
-    endelse
-    setcall bool mpeg_mem_bit(acpred)
-    if bool!=1
-        return 0
-    endif
-
-    #write cbpy
-    sd cbp_y
-    set cbp_y cbp
-    div cbp_y 4
-
-    setcall code cbpy_tab(cbp_y,(VLC_code))
-    setcall len cbpy_tab(cbp_y,(VLC_len))
-    setcall bool mpeg_file_mem_append(code,len)
-    if bool!=1
-        return 0
-    endif
-
-    #code block coeffs
-    sd i=0
-    sd ind
-    while i<6
-        set ind i
-        mult ind 64
-        setcall ind array_get_int16(qcoeff,ind)
-        add ind 255
-        if i<4
-            setcall code dcy_tab(ind,(VLC_code))
-            setcall len dcy_tab(ind,(VLC_len))
-        else
-            setcall code dcc_tab(ind,(VLC_code))
-            setcall len dcc_tab(ind,(VLC_len))
-        endelse
-        setcall bool mpeg_file_mem_append(code,len)
-        if bool!=1
-            return 0
-        endif
-
-        sd value
-        set value 5
-        sub value i
-        setcall value shl(1,value)
-        and value cbp
-
-        if value!=0
-            set ind (64*int16)
-            mult ind i
-            sd qcoeff_cursor
-            set qcoeff_cursor qcoeff
-            add qcoeff_cursor ind
-
-            setcall ind array_get_int(acpred_direction,i)
-
-            setcall bool coef_intra_calc_code(qcoeff_cursor,ind)
-            if bool!=1
-                return 0
-            endif
-        endif
-
-        inc i
-    endwhile
-    return 1
-endfunction
-
-function mcbpc_intra_tab(sd x,sd block)
-#MCBPC Indexing by cbpc in first two bits, mode in last two.
-#CBPC as in table 4/H.263, MB type (mode): 3 = 01, 4 = 10.
-#Example: cbpc = 01 and mode = 4 gives index = 0110 = 6.
-    char mcbpc_intra_tab_data={0x01,0,0,0, 9, 0x01,0,0,0, 1, 0x01,0,0,0, 4, 0x00,0,0,0, 0}
-    char *                   ={0x00,0,0,0, 0, 0x01,0,0,0, 3, 0x01,0,0,0, 6, 0x00,0,0,0, 0}
-    char *                   ={0x00,0,0,0, 0, 0x02,0,0,0, 3, 0x02,0,0,0, 6, 0x00,0,0,0, 0}
-    char *                   ={0x00,0,0,0, 0, 0x03,0,0,0, 3, 0x03,0,0,0, 6}
-
-    sd ind
-    set ind x
-    mult ind (VLC_size)
-    add ind block
-
-    sd mcbpc_intra^mcbpc_intra_tab_data
-    add mcbpc_intra ind
-    if block==(VLC_code)
-        return mcbpc_intra#
-    else
-        ss byte
-        set byte mcbpc_intra
-        return byte#
-    endelse
-endfunction
-
-function mcbpc_inter_tab(sd x,sd block)
-    #MCBPC inter.
-    #Addressing: 5 bit ccmmm (cc = CBPC, mmm = mode (1-4 binary))
-    #29 entries
-    char mcbpc_inter_tab_data={0x01,0,0,0, 1, 0x03,0,0,0, 3, 0x02,0,0,0, 3, 0x03,0,0,0, 5, 0x04,0,0,0, 6, 0x01,0,0,0, 9, 0x00,0,0,0, 0, 0x00,0,0,0, 0}
-    char *                   ={0x03,0,0,0, 4, 0x07,0,0,0, 7, 0x05,0,0,0, 7, 0x04,0,0,0, 8, 0x04,0,0,0, 9, 0x00,0,0,0, 0, 0x00,0,0,0, 0, 0x00,0,0,0, 0}
-    char *                   ={0x02,0,0,0, 4, 0x06,0,0,0, 7, 0x04,0,0,0, 7, 0x03,0,0,0, 8, 0x03,0,0,0, 9, 0x00,0,0,0, 0, 0x00,0,0,0, 0, 0x00,0,0,0, 0}
-    char *                   ={0x05,0,0,0, 6, 0x05,0,0,0, 9, 0x05,0,0,0, 8, 0x03,0,0,0, 7, 0x02,0,0,0, 9}
-
-    sd ind
-    set ind x
-    mult ind (VLC_size)
-    add ind block
-
-    sd mcbpc_inter^mcbpc_inter_tab_data
-    add mcbpc_inter ind
-    if block==(VLC_code)
-        return mcbpc_inter#
-    else
-        ss byte
-        set byte mcbpc_inter
-        return byte#
-    endelse
-endfunction
-
-function cbpy_tab(sd x,sd block)
-    char cbpy_data={3,0,0,0, 4, 5,0,0,0, 5, 4,0,0,0, 5, 9, 0,0,0, 4, 3,0,0,0, 5, 7,0,0,0, 4, 2,0,0,0, 6, 11,0,0,0, 4}
-    char *        ={2,0,0,0, 5, 3,0,0,0, 6, 5,0,0,0, 4, 10,0,0,0, 4, 4,0,0,0, 4, 8,0,0,0, 4, 6,0,0,0, 4, 3, 0,0,0, 2}
-
-    sd ind
-    set ind x
-    mult ind (VLC_size)
-    add ind block
-
-    sd cbpy^cbpy_data
-    add cbpy ind
-    if block==(VLC_code)
-        return cbpy#
-    else
-        ss byte
-        set byte cbpy
-        return byte#
-    endelse
-endfunction
-
-function dcy_tab(sd x,sd block)
-    char dcy_tab_data={0x00,1,0,0, 15, 0x01,1,0,0, 15, 0x02,1,0,0, 15, 0x03,1,0,0, 15}
-    char *           ={0x04,1,0,0, 15, 0x05,1,0,0, 15, 0x06,1,0,0, 15, 0x07,1,0,0, 15}
-    char *           ={0x08,1,0,0, 15, 0x09,1,0,0, 15, 0x0a,1,0,0, 15, 0x0b,1,0,0, 15}
-    char *           ={0x0c,1,0,0, 15, 0x0d,1,0,0, 15, 0x0e,1,0,0, 15, 0x0f,1,0,0, 15}
-    char *           ={0x10,1,0,0, 15, 0x11,1,0,0, 15, 0x12,1,0,0, 15, 0x13,1,0,0, 15}
-    char *           ={0x14,1,0,0, 15, 0x15,1,0,0, 15, 0x16,1,0,0, 15, 0x17,1,0,0, 15}
-    char *           ={0x18,1,0,0, 15, 0x19,1,0,0, 15, 0x1a,1,0,0, 15, 0x1b,1,0,0, 15}
-    char *           ={0x1c,1,0,0, 15, 0x1d,1,0,0, 15, 0x1e,1,0,0, 15, 0x1f,1,0,0, 15}
-    char *           ={0x20,1,0,0, 15, 0x21,1,0,0, 15, 0x22,1,0,0, 15, 0x23,1,0,0, 15}
-    char *           ={0x24,1,0,0, 15, 0x25,1,0,0, 15, 0x26,1,0,0, 15, 0x27,1,0,0, 15}
-    char *           ={0x28,1,0,0, 15, 0x29,1,0,0, 15, 0x2a,1,0,0, 15, 0x2b,1,0,0, 15}
-    char *           ={0x2c,1,0,0, 15, 0x2d,1,0,0, 15, 0x2e,1,0,0, 15, 0x2f,1,0,0, 15}
-    char *           ={0x30,1,0,0, 15, 0x31,1,0,0, 15, 0x32,1,0,0, 15, 0x33,1,0,0, 15}
-    char *           ={0x34,1,0,0, 15, 0x35,1,0,0, 15, 0x36,1,0,0, 15, 0x37,1,0,0, 15}
-    char *           ={0x38,1,0,0, 15, 0x39,1,0,0, 15, 0x3a,1,0,0, 15, 0x3b,1,0,0, 15}
-    char *           ={0x3c,1,0,0, 15, 0x3d,1,0,0, 15, 0x3e,1,0,0, 15, 0x3f,1,0,0, 15}
-    char *           ={0x40,1,0,0, 15, 0x41,1,0,0, 15, 0x42,1,0,0, 15, 0x43,1,0,0, 15}
-    char *           ={0x44,1,0,0, 15, 0x45,1,0,0, 15, 0x46,1,0,0, 15, 0x47,1,0,0, 15}
-    char *           ={0x48,1,0,0, 15, 0x49,1,0,0, 15, 0x4a,1,0,0, 15, 0x4b,1,0,0, 15}
-    char *           ={0x4c,1,0,0, 15, 0x4d,1,0,0, 15, 0x4e,1,0,0, 15, 0x4f,1,0,0, 15}
-    char *           ={0x50,1,0,0, 15, 0x51,1,0,0, 15, 0x52,1,0,0, 15, 0x53,1,0,0, 15}
-    char *           ={0x54,1,0,0, 15, 0x55,1,0,0, 15, 0x56,1,0,0, 15, 0x57,1,0,0, 15}
-    char *           ={0x58,1,0,0, 15, 0x59,1,0,0, 15, 0x5a,1,0,0, 15, 0x5b,1,0,0, 15}
-    char *           ={0x5c,1,0,0, 15, 0x5d,1,0,0, 15, 0x5e,1,0,0, 15, 0x5f,1,0,0, 15}
-    char *           ={0x60,1,0,0, 15, 0x61,1,0,0, 15, 0x62,1,0,0, 15, 0x63,1,0,0, 15}
-    char *           ={0x64,1,0,0, 15, 0x65,1,0,0, 15, 0x66,1,0,0, 15, 0x67,1,0,0, 15}
-    char *           ={0x68,1,0,0, 15, 0x69,1,0,0, 15, 0x6a,1,0,0, 15, 0x6b,1,0,0, 15}
-    char *           ={0x6c,1,0,0, 15, 0x6d,1,0,0, 15, 0x6e,1,0,0, 15, 0x6f,1,0,0, 15}
-    char *           ={0x70,1,0,0, 15, 0x71,1,0,0, 15, 0x72,1,0,0, 15, 0x73,1,0,0, 15}
-    char *           ={0x74,1,0,0, 15, 0x75,1,0,0, 15, 0x76,1,0,0, 15, 0x77,1,0,0, 15}
-    char *           ={0x78,1,0,0, 15, 0x79,1,0,0, 15, 0x7a,1,0,0, 15, 0x7b,1,0,0, 15}
-    char *           ={0x7c,1,0,0, 15, 0x7d,1,0,0, 15, 0x7e,1,0,0, 15, 0x7f,1,0,0, 15}
-    char *           ={0x80,0,0,0, 13, 0x81,0,0,0, 13, 0x82,0,0,0, 13, 0x83,0,0,0, 13}
-    char *           ={0x84,0,0,0, 13, 0x85,0,0,0, 13, 0x86,0,0,0, 13, 0x87,0,0,0, 13}
-    char *           ={0x88,0,0,0, 13, 0x89,0,0,0, 13, 0x8a,0,0,0, 13, 0x8b,0,0,0, 13}
-    char *           ={0x8c,0,0,0, 13, 0x8d,0,0,0, 13, 0x8e,0,0,0, 13, 0x8f,0,0,0, 13}
-    char *           ={0x90,0,0,0, 13, 0x91,0,0,0, 13, 0x92,0,0,0, 13, 0x93,0,0,0, 13}
-    char *           ={0x94,0,0,0, 13, 0x95,0,0,0, 13, 0x96,0,0,0, 13, 0x97,0,0,0, 13}
-    char *           ={0x98,0,0,0, 13, 0x99,0,0,0, 13, 0x9a,0,0,0, 13, 0x9b,0,0,0, 13}
-    char *           ={0x9c,0,0,0, 13, 0x9d,0,0,0, 13, 0x9e,0,0,0, 13, 0x9f,0,0,0, 13}
-    char *           ={0xa0,0,0,0, 13, 0xa1,0,0,0, 13, 0xa2,0,0,0, 13, 0xa3,0,0,0, 13}
-    char *           ={0xa4,0,0,0, 13, 0xa5,0,0,0, 13, 0xa6,0,0,0, 13, 0xa7,0,0,0, 13}
-    char *           ={0xa8,0,0,0, 13, 0xa9,0,0,0, 13, 0xaa,0,0,0, 13, 0xab,0,0,0, 13}
-    char *           ={0xac,0,0,0, 13, 0xad,0,0,0, 13, 0xae,0,0,0, 13, 0xaf,0,0,0, 13}
-    char *           ={0xb0,0,0,0, 13, 0xb1,0,0,0, 13, 0xb2,0,0,0, 13, 0xb3,0,0,0, 13}
-    char *           ={0xb4,0,0,0, 13, 0xb5,0,0,0, 13, 0xb6,0,0,0, 13, 0xb7,0,0,0, 13}
-    char *           ={0xb8,0,0,0, 13, 0xb9,0,0,0, 13, 0xba,0,0,0, 13, 0xbb,0,0,0, 13}
-    char *           ={0xbc,0,0,0, 13, 0xbd,0,0,0, 13, 0xbe,0,0,0, 13, 0xbf,0,0,0, 13}
-    char *           ={0x40,0,0,0, 11, 0x41,0,0,0, 11, 0x42,0,0,0, 11, 0x43,0,0,0, 11}
-    char *           ={0x44,0,0,0, 11, 0x45,0,0,0, 11, 0x46,0,0,0, 11, 0x47,0,0,0, 11}
-    char *           ={0x48,0,0,0, 11, 0x49,0,0,0, 11, 0x4a,0,0,0, 11, 0x4b,0,0,0, 11}
-    char *           ={0x4c,0,0,0, 11, 0x4d,0,0,0, 11, 0x4e,0,0,0, 11, 0x4f,0,0,0, 11}
-    char *           ={0x50,0,0,0, 11, 0x51,0,0,0, 11, 0x52,0,0,0, 11, 0x53,0,0,0, 11}
-    char *           ={0x54,0,0,0, 11, 0x55,0,0,0, 11, 0x56,0,0,0, 11, 0x57,0,0,0, 11}
-    char *           ={0x58,0,0,0, 11, 0x59,0,0,0, 11, 0x5a,0,0,0, 11, 0x5b,0,0,0, 11}
-    char *           ={0x5c,0,0,0, 11, 0x5d,0,0,0, 11, 0x5e,0,0,0, 11, 0x5f,0,0,0, 11}
-    char *           ={0x20,0,0,0, 9,  0x21,0,0,0, 9,  0x22,0,0,0, 9,  0x23,0,0,0, 9}
-    char *           ={0x24,0,0,0, 9,  0x25,0,0,0, 9,  0x26,0,0,0, 9,  0x27,0,0,0, 9}
-    char *           ={0x28,0,0,0, 9,  0x29,0,0,0, 9,  0x2a,0,0,0, 9,  0x2b,0,0,0, 9}
-    char *           ={0x2c,0,0,0, 9,  0x2d,0,0,0, 9,  0x2e,0,0,0, 9,  0x2f,0,0,0, 9}
-    char *           ={0x10,0,0,0, 7,  0x11,0,0,0, 7,  0x12,0,0,0, 7,  0x13,0,0,0, 7}
-    char *           ={0x14,0,0,0, 7,  0x15,0,0,0, 7,  0x16,0,0,0, 7,  0x17,0,0,0, 7}
-    char *           ={0x10,0,0,0, 6,  0x11,0,0,0, 6,  0x12,0,0,0, 6,  0x13,0,0,0, 6}
-    char *           ={0x08,0,0,0, 4,  0x09,0,0,0, 4,  0x06,0,0,0, 3,  0x03,0,0,0, 3}
-    char *           ={0x07,0,0,0, 3,  0x0a,0,0,0, 4,  0x0b,0,0,0, 4,  0x14,0,0,0, 6}
-    char *           ={0x15,0,0,0, 6,  0x16,0,0,0, 6,  0x17,0,0,0, 6,  0x18,0,0,0, 7}
-    char *           ={0x19,0,0,0, 7,  0x1a,0,0,0, 7,  0x1b,0,0,0, 7,  0x1c,0,0,0, 7}
-    char *           ={0x1d,0,0,0, 7,  0x1e,0,0,0, 7,  0x1f,0,0,0, 7,  0x30,0,0,0, 9}
-    char *           ={0x31,0,0,0, 9,  0x32,0,0,0, 9,  0x33,0,0,0, 9,  0x34,0,0,0, 9}
-    char *           ={0x35,0,0,0, 9,  0x36,0,0,0, 9,  0x37,0,0,0, 9,  0x38,0,0,0, 9}
-    char *           ={0x39,0,0,0, 9,  0x3a,0,0,0, 9,  0x3b,0,0,0, 9,  0x3c,0,0,0, 9}
-    char *           ={0x3d,0,0,0, 9,  0x3e,0,0,0, 9,  0x3f,0,0,0, 9,  0x60,0,0,0, 11}
-    char *           ={0x61,0,0,0, 11, 0x62,0,0,0, 11, 0x63,0,0,0, 11, 0x64,0,0,0, 11}
-    char *           ={0x65,0,0,0, 11, 0x66,0,0,0, 11, 0x67,0,0,0, 11, 0x68,0,0,0, 11}
-    char *           ={0x69,0,0,0, 11, 0x6a,0,0,0, 11, 0x6b,0,0,0, 11, 0x6c,0,0,0, 11}
-    char *           ={0x6d,0,0,0, 11, 0x6e,0,0,0, 11, 0x6f,0,0,0, 11, 0x70,0,0,0, 11}
-    char *           ={0x71,0,0,0, 11, 0x72,0,0,0, 11, 0x73,0,0,0, 11, 0x74,0,0,0, 11}
-    char *           ={0x75,0,0,0, 11, 0x76,0,0,0, 11, 0x77,0,0,0, 11, 0x78,0,0,0, 11}
-    char *           ={0x79,0,0,0, 11, 0x7a,0,0,0, 11, 0x7b,0,0,0, 11, 0x7c,0,0,0, 11}
-    char *           ={0x7d,0,0,0, 11, 0x7e,0,0,0, 11, 0x7f,0,0,0, 11, 0xc0,0,0,0, 13}
-    char *           ={0xc1,0,0,0, 13, 0xc2,0,0,0, 13, 0xc3,0,0,0, 13, 0xc4,0,0,0, 13}
-    char *           ={0xc5,0,0,0, 13, 0xc6,0,0,0, 13, 0xc7,0,0,0, 13, 0xc8,0,0,0, 13}
-    char *           ={0xc9,0,0,0, 13, 0xca,0,0,0, 13, 0xcb,0,0,0, 13, 0xcc,0,0,0, 13}
-    char *           ={0xcd,0,0,0, 13, 0xce,0,0,0, 13, 0xcf,0,0,0, 13, 0xd0,0,0,0, 13}
-    char *           ={0xd1,0,0,0, 13, 0xd2,0,0,0, 13, 0xd3,0,0,0, 13, 0xd4,0,0,0, 13}
-    char *           ={0xd5,0,0,0, 13, 0xd6,0,0,0, 13, 0xd7,0,0,0, 13, 0xd8,0,0,0, 13}
-    char *           ={0xd9,0,0,0, 13, 0xda,0,0,0, 13, 0xdb,0,0,0, 13, 0xdc,0,0,0, 13}
-    char *           ={0xdd,0,0,0, 13, 0xde,0,0,0, 13, 0xdf,0,0,0, 13, 0xe0,0,0,0, 13}
-    char *           ={0xe1,0,0,0, 13, 0xe2,0,0,0, 13, 0xe3,0,0,0, 13, 0xe4,0,0,0, 13}
-    char *           ={0xe5,0,0,0, 13, 0xe6,0,0,0, 13, 0xe7,0,0,0, 13, 0xe8,0,0,0, 13}
-    char *           ={0xe9,0,0,0, 13, 0xea,0,0,0, 13, 0xeb,0,0,0, 13, 0xec,0,0,0, 13}
-    char *           ={0xed,0,0,0, 13, 0xee,0,0,0, 13, 0xef,0,0,0, 13, 0xf0,0,0,0, 13}
-    char *           ={0xf1,0,0,0, 13, 0xf2,0,0,0, 13, 0xf3,0,0,0, 13, 0xf4,0,0,0, 13}
-    char *           ={0xf5,0,0,0, 13, 0xf6,0,0,0, 13, 0xf7,0,0,0, 13, 0xf8,0,0,0, 13}
-    char *           ={0xf9,0,0,0, 13, 0xfa,0,0,0, 13, 0xfb,0,0,0, 13, 0xfc,0,0,0, 13}
-    char *           ={0xfd,0,0,0, 13, 0xfe,0,0,0, 13, 0xff,0,0,0, 13, 0x80,1,0,0, 15}
-    char *           ={0x81,1,0,0, 15, 0x82,1,0,0, 15, 0x83,1,0,0, 15, 0x84,1,0,0, 15}
-    char *           ={0x85,1,0,0, 15, 0x86,1,0,0, 15, 0x87,1,0,0, 15, 0x88,1,0,0, 15}
-    char *           ={0x89,1,0,0, 15, 0x8a,1,0,0, 15, 0x8b,1,0,0, 15, 0x8c,1,0,0, 15}
-    char *           ={0x8d,1,0,0, 15, 0x8e,1,0,0, 15, 0x8f,1,0,0, 15, 0x90,1,0,0, 15}
-    char *           ={0x91,1,0,0, 15, 0x92,1,0,0, 15, 0x93,1,0,0, 15, 0x94,1,0,0, 15}
-    char *           ={0x95,1,0,0, 15, 0x96,1,0,0, 15, 0x97,1,0,0, 15, 0x98,1,0,0, 15}
-    char *           ={0x99,1,0,0, 15, 0x9a,1,0,0, 15, 0x9b,1,0,0, 15, 0x9c,1,0,0, 15}
-    char *           ={0x9d,1,0,0, 15, 0x9e,1,0,0, 15, 0x9f,1,0,0, 15, 0xa0,1,0,0, 15}
-    char *           ={0xa1,1,0,0, 15, 0xa2,1,0,0, 15, 0xa3,1,0,0, 15, 0xa4,1,0,0, 15}
-    char *           ={0xa5,1,0,0, 15, 0xa6,1,0,0, 15, 0xa7,1,0,0, 15, 0xa8,1,0,0, 15}
-    char *           ={0xa9,1,0,0, 15, 0xaa,1,0,0, 15, 0xab,1,0,0, 15, 0xac,1,0,0, 15}
-    char *           ={0xad,1,0,0, 15, 0xae,1,0,0, 15, 0xaf,1,0,0, 15, 0xb0,1,0,0, 15}
-    char *           ={0xb1,1,0,0, 15, 0xb2,1,0,0, 15, 0xb3,1,0,0, 15, 0xb4,1,0,0, 15}
-    char *           ={0xb5,1,0,0, 15, 0xb6,1,0,0, 15, 0xb7,1,0,0, 15, 0xb8,1,0,0, 15}
-    char *           ={0xb9,1,0,0, 15, 0xba,1,0,0, 15, 0xbb,1,0,0, 15, 0xbc,1,0,0, 15}
-    char *           ={0xbd,1,0,0, 15, 0xbe,1,0,0, 15, 0xbf,1,0,0, 15, 0xc0,1,0,0, 15}
-    char *           ={0xc1,1,0,0, 15, 0xc2,1,0,0, 15, 0xc3,1,0,0, 15, 0xc4,1,0,0, 15}
-    char *           ={0xc5,1,0,0, 15, 0xc6,1,0,0, 15, 0xc7,1,0,0, 15, 0xc8,1,0,0, 15}
-    char *           ={0xc9,1,0,0, 15, 0xca,1,0,0, 15, 0xcb,1,0,0, 15, 0xcc,1,0,0, 15}
-    char *           ={0xcd,1,0,0, 15, 0xce,1,0,0, 15, 0xcf,1,0,0, 15, 0xd0,1,0,0, 15}
-    char *           ={0xd1,1,0,0, 15, 0xd2,1,0,0, 15, 0xd3,1,0,0, 15, 0xd4,1,0,0, 15}
-    char *           ={0xd5,1,0,0, 15, 0xd6,1,0,0, 15, 0xd7,1,0,0, 15, 0xd8,1,0,0, 15}
-    char *           ={0xd9,1,0,0, 15, 0xda,1,0,0, 15, 0xdb,1,0,0, 15, 0xdc,1,0,0, 15}
-    char *           ={0xdd,1,0,0, 15, 0xde,1,0,0, 15, 0xdf,1,0,0, 15, 0xe0,1,0,0, 15}
-    char *           ={0xe1,1,0,0, 15, 0xe2,1,0,0, 15, 0xe3,1,0,0, 15, 0xe4,1,0,0, 15}
-    char *           ={0xe5,1,0,0, 15, 0xe6,1,0,0, 15, 0xe7,1,0,0, 15, 0xe8,1,0,0, 15}
-    char *           ={0xe9,1,0,0, 15, 0xea,1,0,0, 15, 0xeb,1,0,0, 15, 0xec,1,0,0, 15}
-    char *           ={0xed,1,0,0, 15, 0xee,1,0,0, 15, 0xef,1,0,0, 15, 0xf0,1,0,0, 15}
-    char *           ={0xf1,1,0,0, 15, 0xf2,1,0,0, 15, 0xf3,1,0,0, 15, 0xf4,1,0,0, 15}
-    char *           ={0xf5,1,0,0, 15, 0xf6,1,0,0, 15, 0xf7,1,0,0, 15, 0xf8,1,0,0, 15}
-    char *           ={0xf9,1,0,0, 15, 0xfa,1,0,0, 15, 0xfb,1,0,0, 15, 0xfc,1,0,0, 15}
-    char *           ={0xfd,1,0,0, 15, 0xfe,1,0,0, 15, 0xff,1,0,0, 15}
-
-    sd ind
-    set ind x
-    mult ind (VLC_size)
-    add ind block
-
-    sd dcy^dcy_tab_data
-    add dcy ind
-    if block==(VLC_code)
-        return dcy#
-    else
-        ss byte
-        set byte dcy
-        return byte#
-    endelse
-endfunction
-
-function dcc_tab(sd x,sd block)
-    char dcc_tab_data={0x00,1,0,0, 16, 0x01,1,0,0, 16, 0x02,1,0,0, 16, 0x03,1,0,0, 16}
-    char *      ={0x04,1,0,0, 16, 0x05,1,0,0, 16, 0x06,1,0,0, 16, 0x07,1,0,0, 16}
-    char *      ={0x08,1,0,0, 16, 0x09,1,0,0, 16, 0x0a,1,0,0, 16, 0x0b,1,0,0, 16}
-    char *      ={0x0c,1,0,0, 16, 0x0d,1,0,0, 16, 0x0e,1,0,0, 16, 0x0f,1,0,0, 16}
-    char *      ={0x10,1,0,0, 16, 0x11,1,0,0, 16, 0x12,1,0,0, 16, 0x13,1,0,0, 16}
-    char *      ={0x14,1,0,0, 16, 0x15,1,0,0, 16, 0x16,1,0,0, 16, 0x17,1,0,0, 16}
-    char *      ={0x18,1,0,0, 16, 0x19,1,0,0, 16, 0x1a,1,0,0, 16, 0x1b,1,0,0, 16}
-    char *      ={0x1c,1,0,0, 16, 0x1d,1,0,0, 16, 0x1e,1,0,0, 16, 0x1f,1,0,0, 16}
-    char *      ={0x20,1,0,0, 16, 0x21,1,0,0, 16, 0x22,1,0,0, 16, 0x23,1,0,0, 16}
-    char *      ={0x24,1,0,0, 16, 0x25,1,0,0, 16, 0x26,1,0,0, 16, 0x27,1,0,0, 16}
-    char *      ={0x28,1,0,0, 16, 0x29,1,0,0, 16, 0x2a,1,0,0, 16, 0x2b,1,0,0, 16}
-    char *      ={0x2c,1,0,0, 16, 0x2d,1,0,0, 16, 0x2e,1,0,0, 16, 0x2f,1,0,0, 16}
-    char *      ={0x30,1,0,0, 16, 0x31,1,0,0, 16, 0x32,1,0,0, 16, 0x33,1,0,0, 16}
-    char *      ={0x34,1,0,0, 16, 0x35,1,0,0, 16, 0x36,1,0,0, 16, 0x37,1,0,0, 16}
-    char *      ={0x38,1,0,0, 16, 0x39,1,0,0, 16, 0x3a,1,0,0, 16, 0x3b,1,0,0, 16}
-    char *      ={0x3c,1,0,0, 16, 0x3d,1,0,0, 16, 0x3e,1,0,0, 16, 0x3f,1,0,0, 16}
-    char *      ={0x40,1,0,0, 16, 0x41,1,0,0, 16, 0x42,1,0,0, 16, 0x43,1,0,0, 16}
-    char *      ={0x44,1,0,0, 16, 0x45,1,0,0, 16, 0x46,1,0,0, 16, 0x47,1,0,0, 16}
-    char *      ={0x48,1,0,0, 16, 0x49,1,0,0, 16, 0x4a,1,0,0, 16, 0x4b,1,0,0, 16}
-    char *      ={0x4c,1,0,0, 16, 0x4d,1,0,0, 16, 0x4e,1,0,0, 16, 0x4f,1,0,0, 16}
-    char *      ={0x50,1,0,0, 16, 0x51,1,0,0, 16, 0x52,1,0,0, 16, 0x53,1,0,0, 16}
-    char *      ={0x54,1,0,0, 16, 0x55,1,0,0, 16, 0x56,1,0,0, 16, 0x57,1,0,0, 16}
-    char *      ={0x58,1,0,0, 16, 0x59,1,0,0, 16, 0x5a,1,0,0, 16, 0x5b,1,0,0, 16}
-    char *      ={0x5c,1,0,0, 16, 0x5d,1,0,0, 16, 0x5e,1,0,0, 16, 0x5f,1,0,0, 16}
-    char *      ={0x60,1,0,0, 16, 0x61,1,0,0, 16, 0x62,1,0,0, 16, 0x63,1,0,0, 16}
-    char *      ={0x64,1,0,0, 16, 0x65,1,0,0, 16, 0x66,1,0,0, 16, 0x67,1,0,0, 16}
-    char *      ={0x68,1,0,0, 16, 0x69,1,0,0, 16, 0x6a,1,0,0, 16, 0x6b,1,0,0, 16}
-    char *      ={0x6c,1,0,0, 16, 0x6d,1,0,0, 16, 0x6e,1,0,0, 16, 0x6f,1,0,0, 16}
-    char *      ={0x70,1,0,0, 16, 0x71,1,0,0, 16, 0x72,1,0,0, 16, 0x73,1,0,0, 16}
-    char *      ={0x74,1,0,0, 16, 0x75,1,0,0, 16, 0x76,1,0,0, 16, 0x77,1,0,0, 16}
-    char *      ={0x78,1,0,0, 16, 0x79,1,0,0, 16, 0x7a,1,0,0, 16, 0x7b,1,0,0, 16}
-    char *      ={0x7c,1,0,0, 16, 0x7d,1,0,0, 16, 0x7e,1,0,0, 16, 0x7f,1,0,0, 16}
-    char *      ={0x80,0,0,0, 14, 0x81,0,0,0, 14, 0x82,0,0,0, 14, 0x83,0,0,0, 14}
-    char *      ={0x84,0,0,0, 14, 0x85,0,0,0, 14, 0x86,0,0,0, 14, 0x87,0,0,0, 14}
-    char *      ={0x88,0,0,0, 14, 0x89,0,0,0, 14, 0x8a,0,0,0, 14, 0x8b,0,0,0, 14}
-    char *      ={0x8c,0,0,0, 14, 0x8d,0,0,0, 14, 0x8e,0,0,0, 14, 0x8f,0,0,0, 14}
-    char *      ={0x90,0,0,0, 14, 0x91,0,0,0, 14, 0x92,0,0,0, 14, 0x93,0,0,0, 14}
-    char *      ={0x94,0,0,0, 14, 0x95,0,0,0, 14, 0x96,0,0,0, 14, 0x97,0,0,0, 14}
-    char *      ={0x98,0,0,0, 14, 0x99,0,0,0, 14, 0x9a,0,0,0, 14, 0x9b,0,0,0, 14}
-    char *      ={0x9c,0,0,0, 14, 0x9d,0,0,0, 14, 0x9e,0,0,0, 14, 0x9f,0,0,0, 14}
-    char *      ={0xa0,0,0,0, 14, 0xa1,0,0,0, 14, 0xa2,0,0,0, 14, 0xa3,0,0,0, 14}
-    char *      ={0xa4,0,0,0, 14, 0xa5,0,0,0, 14, 0xa6,0,0,0, 14, 0xa7,0,0,0, 14}
-    char *      ={0xa8,0,0,0, 14, 0xa9,0,0,0, 14, 0xaa,0,0,0, 14, 0xab,0,0,0, 14}
-    char *      ={0xac,0,0,0, 14, 0xad,0,0,0, 14, 0xae,0,0,0, 14, 0xaf,0,0,0, 14}
-    char *      ={0xb0,0,0,0, 14, 0xb1,0,0,0, 14, 0xb2,0,0,0, 14, 0xb3,0,0,0, 14}
-    char *      ={0xb4,0,0,0, 14, 0xb5,0,0,0, 14, 0xb6,0,0,0, 14, 0xb7,0,0,0, 14}
-    char *      ={0xb8,0,0,0, 14, 0xb9,0,0,0, 14, 0xba,0,0,0, 14, 0xbb,0,0,0, 14}
-    char *      ={0xbc,0,0,0, 14, 0xbd,0,0,0, 14, 0xbe,0,0,0, 14, 0xbf,0,0,0, 14}
-    char *      ={0x40,0,0,0, 12, 0x41,0,0,0, 12, 0x42,0,0,0, 12, 0x43,0,0,0, 12}
-    char *      ={0x44,0,0,0, 12, 0x45,0,0,0, 12, 0x46,0,0,0, 12, 0x47,0,0,0, 12}
-    char *      ={0x48,0,0,0, 12, 0x49,0,0,0, 12, 0x4a,0,0,0, 12, 0x4b,0,0,0, 12}
-    char *      ={0x4c,0,0,0, 12, 0x4d,0,0,0, 12, 0x4e,0,0,0, 12, 0x4f,0,0,0, 12}
-    char *      ={0x50,0,0,0, 12, 0x51,0,0,0, 12, 0x52,0,0,0, 12, 0x53,0,0,0, 12}
-    char *      ={0x54,0,0,0, 12, 0x55,0,0,0, 12, 0x56,0,0,0, 12, 0x57,0,0,0, 12}
-    char *      ={0x58,0,0,0, 12, 0x59,0,0,0, 12, 0x5a,0,0,0, 12, 0x5b,0,0,0, 12}
-    char *      ={0x5c,0,0,0, 12, 0x5d,0,0,0, 12, 0x5e,0,0,0, 12, 0x5f,0,0,0, 12}
-    char *      ={0x20,0,0,0, 10, 0x21,0,0,0, 10, 0x22,0,0,0, 10, 0x23,0,0,0, 10}
-    char *      ={0x24,0,0,0, 10, 0x25,0,0,0, 10, 0x26,0,0,0, 10, 0x27,0,0,0, 10}
-    char *      ={0x28,0,0,0, 10, 0x29,0,0,0, 10, 0x2a,0,0,0, 10, 0x2b,0,0,0, 10}
-    char *      ={0x2c,0,0,0, 10, 0x2d,0,0,0, 10, 0x2e,0,0,0, 10, 0x2f,0,0,0, 10}
-    char *      ={0x10,0,0,0, 8,  0x11,0,0,0, 8,  0x12,0,0,0, 8,  0x13,0,0,0, 8}
-    char *      ={0x14,0,0,0, 8,  0x15,0,0,0, 8,  0x16,0,0,0, 8,  0x17,0,0,0, 8}
-    char *      ={0x08,0,0,0, 6,  0x09,0,0,0, 6,  0x0a,0,0,0, 6,  0x0b,0,0,0, 6}
-    char *      ={0x04,0,0,0, 4,  0x05,0,0,0, 4,  0x04,0,0,0, 3,  0x03,0,0,0, 2}
-    char *      ={0x05,0,0,0, 3,  0x06,0,0,0, 4,  0x07,0,0,0, 4,  0x0c,0,0,0, 6}
-    char *      ={0x0d,0,0,0, 6,  0x0e,0,0,0, 6,  0x0f,0,0,0, 6,  0x18,0,0,0, 8}
-    char *      ={0x19,0,0,0, 8,  0x1a,0,0,0, 8,  0x1b,0,0,0, 8,  0x1c,0,0,0, 8}
-    char *      ={0x1d,0,0,0, 8,  0x1e,0,0,0, 8,  0x1f,0,0,0, 8,  0x30,0,0,0, 10}
-    char *      ={0x31,0,0,0, 10, 0x32,0,0,0, 10, 0x33,0,0,0, 10, 0x34,0,0,0, 10}
-    char *      ={0x35,0,0,0, 10, 0x36,0,0,0, 10, 0x37,0,0,0, 10, 0x38,0,0,0, 10}
-    char *      ={0x39,0,0,0, 10, 0x3a,0,0,0, 10, 0x3b,0,0,0, 10, 0x3c,0,0,0, 10}
-    char *      ={0x3d,0,0,0, 10, 0x3e,0,0,0, 10, 0x3f,0,0,0, 10, 0x60,0,0,0, 12}
-    char *      ={0x61,0,0,0, 12, 0x62,0,0,0, 12, 0x63,0,0,0, 12, 0x64,0,0,0, 12}
-    char *      ={0x65,0,0,0, 12, 0x66,0,0,0, 12, 0x67,0,0,0, 12, 0x68,0,0,0, 12}
-    char *      ={0x69,0,0,0, 12, 0x6a,0,0,0, 12, 0x6b,0,0,0, 12, 0x6c,0,0,0, 12}
-    char *      ={0x6d,0,0,0, 12, 0x6e,0,0,0, 12, 0x6f,0,0,0, 12, 0x70,0,0,0, 12}
-    char *      ={0x71,0,0,0, 12, 0x72,0,0,0, 12, 0x73,0,0,0, 12, 0x74,0,0,0, 12}
-    char *      ={0x75,0,0,0, 12, 0x76,0,0,0, 12, 0x77,0,0,0, 12, 0x78,0,0,0, 12}
-    char *      ={0x79,0,0,0, 12, 0x7a,0,0,0, 12, 0x7b,0,0,0, 12, 0x7c,0,0,0, 12}
-    char *      ={0x7d,0,0,0, 12, 0x7e,0,0,0, 12, 0x7f,0,0,0, 12, 0xc0,0,0,0, 14}
-    char *      ={0xc1,0,0,0, 14, 0xc2,0,0,0, 14, 0xc3,0,0,0, 14, 0xc4,0,0,0, 14}
-    char *      ={0xc5,0,0,0, 14, 0xc6,0,0,0, 14, 0xc7,0,0,0, 14, 0xc8,0,0,0, 14}
-    char *      ={0xc9,0,0,0, 14, 0xca,0,0,0, 14, 0xcb,0,0,0, 14, 0xcc,0,0,0, 14}
-    char *      ={0xcd,0,0,0, 14, 0xce,0,0,0, 14, 0xcf,0,0,0, 14, 0xd0,0,0,0, 14}
-    char *      ={0xd1,0,0,0, 14, 0xd2,0,0,0, 14, 0xd3,0,0,0, 14, 0xd4,0,0,0, 14}
-    char *      ={0xd5,0,0,0, 14, 0xd6,0,0,0, 14, 0xd7,0,0,0, 14, 0xd8,0,0,0, 14}
-    char *      ={0xd9,0,0,0, 14, 0xda,0,0,0, 14, 0xdb,0,0,0, 14, 0xdc,0,0,0, 14}
-    char *      ={0xdd,0,0,0, 14, 0xde,0,0,0, 14, 0xdf,0,0,0, 14, 0xe0,0,0,0, 14}
-    char *      ={0xe1,0,0,0, 14, 0xe2,0,0,0, 14, 0xe3,0,0,0, 14, 0xe4,0,0,0, 14}
-    char *      ={0xe5,0,0,0, 14, 0xe6,0,0,0, 14, 0xe7,0,0,0, 14, 0xe8,0,0,0, 14}
-    char *      ={0xe9,0,0,0, 14, 0xea,0,0,0, 14, 0xeb,0,0,0, 14, 0xec,0,0,0, 14}
-    char *      ={0xed,0,0,0, 14, 0xee,0,0,0, 14, 0xef,0,0,0, 14, 0xf0,0,0,0, 14}
-    char *      ={0xf1,0,0,0, 14, 0xf2,0,0,0, 14, 0xf3,0,0,0, 14, 0xf4,0,0,0, 14}
-    char *      ={0xf5,0,0,0, 14, 0xf6,0,0,0, 14, 0xf7,0,0,0, 14, 0xf8,0,0,0, 14}
-    char *      ={0xf9,0,0,0, 14, 0xfa,0,0,0, 14, 0xfb,0,0,0, 14, 0xfc,0,0,0, 14}
-    char *      ={0xfd,0,0,0, 14, 0xfe,0,0,0, 14, 0xff,0,0,0, 14, 0x80,1,0,0, 16}
-    char *      ={0x81,1,0,0, 16, 0x82,1,0,0, 16, 0x83,1,0,0, 16, 0x84,1,0,0, 16}
-    char *      ={0x85,1,0,0, 16, 0x86,1,0,0, 16, 0x87,1,0,0, 16, 0x88,1,0,0, 16}
-    char *      ={0x89,1,0,0, 16, 0x8a,1,0,0, 16, 0x8b,1,0,0, 16, 0x8c,1,0,0, 16}
-    char *      ={0x8d,1,0,0, 16, 0x8e,1,0,0, 16, 0x8f,1,0,0, 16, 0x90,1,0,0, 16}
-    char *      ={0x91,1,0,0, 16, 0x92,1,0,0, 16, 0x93,1,0,0, 16, 0x94,1,0,0, 16}
-    char *      ={0x95,1,0,0, 16, 0x96,1,0,0, 16, 0x97,1,0,0, 16, 0x98,1,0,0, 16}
-    char *      ={0x99,1,0,0, 16, 0x9a,1,0,0, 16, 0x9b,1,0,0, 16, 0x9c,1,0,0, 16}
-    char *      ={0x9d,1,0,0, 16, 0x9e,1,0,0, 16, 0x9f,1,0,0, 16, 0xa0,1,0,0, 16}
-    char *      ={0xa1,1,0,0, 16, 0xa2,1,0,0, 16, 0xa3,1,0,0, 16, 0xa4,1,0,0, 16}
-    char *      ={0xa5,1,0,0, 16, 0xa6,1,0,0, 16, 0xa7,1,0,0, 16, 0xa8,1,0,0, 16}
-    char *      ={0xa9,1,0,0, 16, 0xaa,1,0,0, 16, 0xab,1,0,0, 16, 0xac,1,0,0, 16}
-    char *      ={0xad,1,0,0, 16, 0xae,1,0,0, 16, 0xaf,1,0,0, 16, 0xb0,1,0,0, 16}
-    char *      ={0xb1,1,0,0, 16, 0xb2,1,0,0, 16, 0xb3,1,0,0, 16, 0xb4,1,0,0, 16}
-    char *      ={0xb5,1,0,0, 16, 0xb6,1,0,0, 16, 0xb7,1,0,0, 16, 0xb8,1,0,0, 16}
-    char *      ={0xb9,1,0,0, 16, 0xba,1,0,0, 16, 0xbb,1,0,0, 16, 0xbc,1,0,0, 16}
-    char *      ={0xbd,1,0,0, 16, 0xbe,1,0,0, 16, 0xbf,1,0,0, 16, 0xc0,1,0,0, 16}
-    char *      ={0xc1,1,0,0, 16, 0xc2,1,0,0, 16, 0xc3,1,0,0, 16, 0xc4,1,0,0, 16}
-    char *      ={0xc5,1,0,0, 16, 0xc6,1,0,0, 16, 0xc7,1,0,0, 16, 0xc8,1,0,0, 16}
-    char *      ={0xc9,1,0,0, 16, 0xca,1,0,0, 16, 0xcb,1,0,0, 16, 0xcc,1,0,0, 16}
-    char *      ={0xcd,1,0,0, 16, 0xce,1,0,0, 16, 0xcf,1,0,0, 16, 0xd0,1,0,0, 16}
-    char *      ={0xd1,1,0,0, 16, 0xd2,1,0,0, 16, 0xd3,1,0,0, 16, 0xd4,1,0,0, 16}
-    char *      ={0xd5,1,0,0, 16, 0xd6,1,0,0, 16, 0xd7,1,0,0, 16, 0xd8,1,0,0, 16}
-    char *      ={0xd9,1,0,0, 16, 0xda,1,0,0, 16, 0xdb,1,0,0, 16, 0xdc,1,0,0, 16}
-    char *      ={0xdd,1,0,0, 16, 0xde,1,0,0, 16, 0xdf,1,0,0, 16, 0xe0,1,0,0, 16}
-    char *      ={0xe1,1,0,0, 16, 0xe2,1,0,0, 16, 0xe3,1,0,0, 16, 0xe4,1,0,0, 16}
-    char *      ={0xe5,1,0,0, 16, 0xe6,1,0,0, 16, 0xe7,1,0,0, 16, 0xe8,1,0,0, 16}
-    char *      ={0xe9,1,0,0, 16, 0xea,1,0,0, 16, 0xeb,1,0,0, 16, 0xec,1,0,0, 16}
-    char *      ={0xed,1,0,0, 16, 0xee,1,0,0, 16, 0xef,1,0,0, 16, 0xf0,1,0,0, 16}
-    char *      ={0xf1,1,0,0, 16, 0xf2,1,0,0, 16, 0xf3,1,0,0, 16, 0xf4,1,0,0, 16}
-    char *      ={0xf5,1,0,0, 16, 0xf6,1,0,0, 16, 0xf7,1,0,0, 16, 0xf8,1,0,0, 16}
-    char *      ={0xf9,1,0,0, 16, 0xfa,1,0,0, 16, 0xfb,1,0,0, 16, 0xfc,1,0,0, 16}
-    char *      ={0xfd,1,0,0, 16, 0xfe,1,0,0, 16, 0xff,1,0,0, 16}
-
-    sd ind
-    set ind x
-    mult ind (VLC_size)
-    add ind block
-
-    sd dcc^dcc_tab_data
-    add dcc ind
-    if block==(VLC_code)
-        return dcc#
-    else
-        ss byte
-        set byte dcc
-        return byte#
-    endelse
-endfunction
-
-
-
-##code coeff function
-#return bool
-function coef_intra_calc_code(sd qcoeff,sd index)
-    import "mpeg_scan_tables" mpeg_scan_tables
-    sd scan_table
-    setcall scan_table mpeg_scan_tables(index)
-
-    sd i=1
-    sd run=0
-    sd level
-    sd loop=1
-    while loop==1
-        setcall level array_get_int(scan_table,i)
-        setcall level array_get_int16(qcoeff,level)
-        inc i
-
-        if level!=0
-            set loop 0
-        else
-            if i>=64
-                set loop 0
-            else
-                inc run
-            endelse
-        endelse
-    endwhile
-
-    sd prev_level
-    set prev_level level
-    sd prev_run
-    set prev_run run
-    set run 0
-    sd abs_level
-    sd code
-    sd len
-    import "vlc_tables_intra" vlc_tables_intra
-    sd bool
-    sd value
-    sd p_code
-    ss p_len
-
-    while i<64
-        setcall level array_get_int(scan_table,i)
-        setcall level array_get_int16(qcoeff,level)
-        inc i
-        if level!=0
-            set abs_level prev_level
-            if abs_level<0
-                mult abs_level -1
-            endif
-            if abs_level>=64
-                set abs_level 0
-            endif
-            setcall p_code vlc_tables_intra((value_get),(VLC_code),0,abs_level,prev_run)
-            set code p_code#
-            setcall p_len vlc_tables_intra((value_get),(VLC_len),0,abs_level,prev_run)
-            set len p_len#
-            if len!=128
-                if prev_level<0
-                    or code 1
-                endif
-            else
-                setcall code shl((ESCAPE3),21)
-                orcall code shl(prev_run,14)
-                or code (2$13)
-                set value prev_level
-                and value 0xfFF
-                mult value 2
-                or code value
-                or code 1
-
-                set len 30
-            endelse
-            setcall bool mpeg_file_mem_append(code,len)
-            if bool!=1
-                return 0
-            endif
-            set prev_level level
-            set prev_run run
-            set run 0
-        else
-            inc run
-        endelse
-    endwhile
-
-    set abs_level prev_level
-    if abs_level<0
-        mult abs_level -1
-    endif
-    if abs_level>=64
-        set abs_level 0
-    endif
-
-    setcall p_code vlc_tables_intra((value_get),(VLC_code),1,abs_level,prev_run)
-    set code p_code#
-    setcall p_len vlc_tables_intra((value_get),(VLC_len),1,abs_level,prev_run)
-    set len p_len#
-    if len!=128
-        if prev_level<0
-            or code 1
-        endif
-    else
-        setcall code shl((ESCAPE3),21)
-        or code (2$20)
-        orcall code shl(prev_run,14)
-        or code (2$13)
-        set value prev_level
-        and value 0xfFF
-        mult value 2
-        or code value
-        or code 1
-
-        set len 30
-    endelse
-    setcall bool mpeg_file_mem_append(code,len)
-    if bool!=1
-        return 0
-    endif
-    return 1
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg_enc.oc
@@ -0,0 +1,522 @@
+
+format elfobj
+
+include "../_include/include.h"
+
+#bool
+function mpeg_frame_block(sd max_y,sd max_x,sd type)
+    char dct_codes#6*64*int16
+    char qcoeff#6*64*int16
+
+    data p_dct_codes^dct_codes
+    data p_qcoeff^qcoeff
+
+    data acpred_direction_data#6
+    data acpred_direction^acpred_direction_data
+
+    sd bool
+    import "mpeg_mem_bit" mpeg_mem_bit
+
+    sd y=0
+    while y!=max_y
+        sd x=0
+        while x!=max_x
+            sd mode=INTRA
+            if type=(P_VOP)
+                import "mpeg_compare_block" mpeg_compare_block
+                setcall mode mpeg_compare_block(x,y)
+            endif
+            import "macro_blocks_mode" macro_blocks_mode
+            sd mbpos
+            set mbpos y
+            mult mbpos max_x
+            add mbpos x
+            call macro_blocks_mode((value_set),mbpos,mode)
+            if mode=(INTRA)
+                call mpeg_mb_trans_quant(x,y,p_dct_codes,p_qcoeff)
+
+                import "mpeg_mb_prediction" mpeg_mb_prediction
+                sd cbp
+                setcall cbp mpeg_mb_prediction(x,y,max_x,p_qcoeff,acpred_direction)
+
+                import "mpeg_mb_code" mpeg_mb_code
+                setcall bool mpeg_mb_code(cbp,acpred_direction,p_qcoeff,type)
+                if bool!=1
+                    return 0
+                endif
+            else
+                #skip
+                setcall bool mpeg_mem_bit(1)
+                if bool!=1
+                    return 0
+                endif
+            endelse
+
+            inc x
+        endwhile
+        inc y
+    endwhile
+
+    import "mpeg_mem_pad" mpeg_mem_pad
+    setcall bool mpeg_mem_pad((always))
+    if bool!=1
+        return 0
+    endif
+
+    return 1
+endfunction
+
+function mpeg_mb_trans_quant(sd x,sd y,sd p_dct_codes,sd p_qcoeff)
+    #Transfer data 8 to 16
+    data t8to16^mb_trans_8to16
+    call mpeg_mb_trans(x,y,p_dct_codes,t8to16)
+    #DCT and field decision
+    call mpeg_mb_dct(p_dct_codes)
+    #Quantize the block
+    call mpeg_mb_quant(p_dct_codes,p_qcoeff)
+    #DeQuantize the block
+    #call mpeg_mb_dequant(p_dct_codes,p_qcoeff)
+    #Inverse DCT
+    #call mpeg_mb_inv_dct(p_dct_codes)
+    #Transfer data 16 to 8
+    #data t16to8^mb_trans_16to8
+    #call mpeg_mb_trans(x,y,p_dct_codes,t16to8)
+endfunction
+
+import "mpeg_input_y" mpeg_input_y
+import "mpeg_input_u" mpeg_input_u
+import "mpeg_input_v" mpeg_input_v
+import "mpeg_input_lumstride" mpeg_input_lumstride
+import "mpeg_input_cromstride" mpeg_input_cromstride
+
+#########trans 8 to 16 for dct
+function mpeg_mb_trans(sd x,sd y,sd p_dct_codes,sv function)
+    sd Y
+    sd U
+    sd V
+    setcall Y mpeg_input_y((value_get))
+    setcall U mpeg_input_u((value_get))
+    setcall V mpeg_input_v((value_get))
+    sd lumstride
+    setcall lumstride mpeg_input_lumstride((value_get))
+    sd cromstride
+    setcall cromstride mpeg_input_cromstride((value_get))
+
+    #get plane,plane+8,plane+stride,plane+stride+8
+    sd i
+    sd ptr_dct_codes^p_dct_codes
+    sd cursor
+    set cursor y
+    mult cursor 16
+    mult cursor lumstride
+    set i x
+    mult i 16
+    add cursor i
+    add cursor Y
+    call function(cursor,ptr_dct_codes,lumstride)
+
+    add cursor 8
+    call function(cursor,ptr_dct_codes,lumstride)
+
+    sub cursor 8
+    sd lum_add
+    set lum_add lumstride
+    mult lum_add 8
+    add cursor lum_add
+    call function(cursor,ptr_dct_codes,lumstride)
+
+    add cursor 8
+    call function(cursor,ptr_dct_codes,lumstride)
+
+    set cursor y
+    mult cursor 8
+    mult cursor cromstride
+    set i x
+    mult i 8
+    add cursor i
+    add U cursor
+    call function(U,ptr_dct_codes,cromstride)
+
+    add V cursor
+    call function(V,ptr_dct_codes,cromstride)
+endfunction
+function mb_trans_8to16(ss src,sd p_dest,sd stride)
+    ss dest
+    set dest p_dest#
+
+    ss sign
+    set sign src
+    sd j=0
+    while j!=8
+        set src sign
+        sd i=0
+        while i!=8
+            set dest# src#
+            inc src
+
+            inc dest
+            set dest# 0
+            inc dest
+
+            inc i
+        endwhile
+        add sign stride
+        inc j
+    endwhile
+
+    set p_dest# dest
+endfunction
+
+const FIX=16
+const FPASS=2
+
+const ROT6_C=35468
+const ROT6_SmC=50159
+const ROT6_SpC=121095
+
+const ROT17_C=77062
+const ROT17_SpC=128553
+const ROT17_SmC=25571
+
+const ROT37_C=58981
+const ROT37_SmC=98391
+const ROT37_SpC=19571
+
+const ROT13_C=167963
+const ROT13_SmC=134553
+const ROT13_SpC=201373
+
+const pow_a=FIX-FPASS-1
+const pow_b=FIX+FPASS+3-1
+const pow_c=FPASS+3-1
+
+############dct
+function mpeg_mb_dct(sd dct_codes)
+    sd i=0
+    while i!=6
+        call mpeg_mb_dct_block(dct_codes)
+        add dct_codes (64*int16)
+        inc i
+    endwhile
+endfunction
+
+function mpeg_mb_dct_block(sd dct_codes)
+#perform dct on a 8x8 block
+    sd m0
+    sd m1
+    sd m2
+    sd m3
+    sd m4
+    sd m5
+    sd m6
+    sd m7
+    sd p_m1^m1
+    sd p_m2^m2
+    sd p_m3^m3
+    sd p_m4^m4
+    sd p_m5^m5
+    sd p_m6^m6
+    sd p_m7^m7
+
+    import "array_set_word_off" array_set_word_off
+    import "shl" shl
+    import "sar32" sar
+    sd i=8
+    sd dct_cursor
+    set dct_cursor dct_codes
+    while i>0
+    #even
+        #m1 m6
+        setcall m1 dct_op(p_m6,1,6,dct_cursor)
+        #m2 m5
+        setcall m2 dct_op(p_m5,2,5,dct_cursor)
+        #m3 m4
+        setcall m3 dct_op(p_m4,3,4,dct_cursor)
+        #m0 m7
+        setcall m0 dct_op(p_m7,0,7,dct_cursor)
+
+        #m1 m2
+        setcall m1 dct_calc(m1,p_m2)
+        #m0 m3
+        setcall m0 dct_calc(m0,p_m3)
+
+        #m3 m2 rotate
+        setcall m3 dct_rotate(m3,p_m2,(ROT6_C),(ROT6_SmC),(-ROT6_SpC),(FIX-FPASS),(2$pow_a))
+        #m2
+        call array_set_word_off(dct_cursor,m3,2)
+        #m3
+        call array_set_word_off(dct_cursor,m2,6)
+
+        #m0 m1
+        setcall m0 dct_calc(m0,p_m1)
+        #m0
+        setcall m0 shl(m0,(FPASS))
+        call array_set_word_off(dct_cursor,m0,0)
+        #m1
+        setcall m1 shl(m1,(FPASS))
+        call array_set_word_off(dct_cursor,m1,4)
+    #odd
+        #m3
+        set m3 m5
+        add m3 m7
+        #m2
+        set m2 m4
+        add m2 m6
+        #m2 m3 rotate
+        setcall m2 dct_rotate(m2,p_m3,(ROT17_C),(-ROT17_SpC),(-ROT17_SmC),(FIX-FPASS),(2$pow_a))
+        #m4 m7
+        setcall m4 dct_rotate(m4,p_m7,(-ROT37_C),(ROT37_SpC),(ROT37_SmC),(FIX-FPASS),(2$pow_a))
+        #m7
+        add m7 m3
+        call array_set_word_off(dct_cursor,m7,1)
+
+        #m4
+        add m4 m2
+        call array_set_word_off(dct_cursor,m4,7)
+
+        #m5 m6
+        setcall m5 dct_rotate(m5,p_m6,(-ROT13_C),(ROT13_SmC),(ROT13_SpC),(FIX-FPASS),(2$pow_a))
+        #m5
+        add m5 m3
+        call array_set_word_off(dct_cursor,m5,5)
+        #m6
+        add m6 m2
+        call array_set_word_off(dct_cursor,m6,3)
+
+        add dct_cursor (8*2)
+        dec i
+    endwhile
+    set i 8
+    set dct_cursor dct_codes
+    while i>0
+    #even
+        #m1 m2
+        setcall m1 dct_op(p_m6,(1*8),(6*8),dct_cursor)
+        setcall m2 dct_op(p_m5,(2*8),(5*8),dct_cursor)
+        setcall m1 dct_calc(m1,p_m2)
+
+        #m3 m4
+        setcall m3 dct_op(p_m4,(3*8),(4*8),dct_cursor)
+        #m0 m7
+        setcall m0 dct_op(p_m7,(0*8),(7*8),dct_cursor)
+        setcall m0 dct_calc(m0,p_m3)
+
+        #m3 m2
+        setcall m3 dct_rotate(m3,p_m2,(ROT6_C),(ROT6_SmC),(-ROT6_SpC),0,(2$pow_b))
+        #m3
+        setcall m3 sar(m3,(FIX+FPASS+3))
+        call array_set_word_off(dct_cursor,m3,(2*8))
+        #m2
+        setcall m2 sar(m2,(FIX+FPASS+3))
+        call array_set_word_off(dct_cursor,m2,(6*8))
+
+        #m0 m1
+        add m0 (2$pow_c-1)
+        setcall m0 dct_calc(m0,p_m1)
+        #m0
+        setcall m0 sar(m0,(FPASS+3))
+        call array_set_word_off(dct_cursor,m0,(0*8))
+        #m1
+        setcall m1 sar(m1,(FPASS+3))
+        call array_set_word_off(dct_cursor,m1,(4*8))
+    #odd
+        #m3
+        set m3 m5
+        add m3 m7
+        #m2
+        set m2 m4
+        add m2 m6
+
+        #m2 m3
+        setcall m2 dct_rotate(m2,p_m3,(ROT17_C),(-ROT17_SpC),(-ROT17_SmC),0,(2$pow_b))
+        #m4 m7
+        setcall m4 dct_rotate_simple(m4,p_m7,(-ROT37_C),(ROT37_SpC),(ROT37_SmC))
+        #m7
+        add m7 m3
+        setcall m7 sar(m7,(FIX+FPASS+3))
+        call array_set_word_off(dct_cursor,m7,(1*8))
+        #m4
+        add m4 m2
+        setcall m4 sar(m4,(FIX+FPASS+3))
+        call array_set_word_off(dct_cursor,m4,(7*8))
+
+        #m5 m6
+        setcall m5 dct_rotate_simple(m5,p_m6,(-ROT13_C),(ROT13_SmC),(ROT13_SpC))
+        add m5 m3
+        add m6 m2
+        setcall m5 sar(m5,(FIX+FPASS+3))
+        setcall m6 sar(m6,(FIX+FPASS+3))
+        call array_set_word_off(dct_cursor,m5,(5*8))
+        call array_set_word_off(dct_cursor,m6,(3*8))
+
+        add dct_cursor (1*2)
+        dec i
+    endwhile
+endfunction
+
+function dct_op(sd p_b,sd xa,sd xb,sd codes)
+    import "array_get_int16" array_get_int16
+    sd a
+    setcall a array_get_int16(codes,xa)
+    addcall a array_get_int16(codes,xb)
+    setcall p_b# array_get_int16(codes,xa)
+    subcall p_b# array_get_int16(codes,xb)
+    return a
+endfunction
+
+#temp=a+b;b=a-b;a=tmp
+#return a
+function dct_calc(sd a,sd p_b)
+    sd temp
+    set temp a
+    add temp p_b#
+
+    sd b
+    set b a
+    sub b p_b#
+    set p_b# b
+
+    return temp
+endfunction
+
+#return m1
+function dct_rotate(sd m1,sd p_m2,sd c,sd k1,sd k2,sd fix,sd rnd)
+    sd m2
+    set m2 p_m2#
+#define ROTATE(m1,m2,c,k1,k2,Fix,Rnd)
+    #(temp) = ( (m1) + (m2) )*(c)
+    sd temp
+    set temp m1
+    add temp m2
+    mult temp c
+    #(m1) *= k1
+    mult m1 k1
+    #(m2) *= k2
+    mult m2 k2
+    #(temp) += (Rnd)
+    add temp rnd
+    #(m1) = ((m1)+(temp))>>(Fix)
+    add m1 temp
+    setcall m1 sar(m1,fix)
+    #(m2) = ((m2)+(temp))>>(Fix)
+    add m2 temp
+    setcall m2 sar(m2,fix)
+
+    set p_m2# m2
+    return m1
+endfunction
+
+#return m1
+function dct_rotate_simple(sd m1,sd p_m2,sd c,sd k1,sd k2)
+    sd m2
+    set m2 p_m2#
+#define ROTATE(m1,m2,c,k1,k2)
+    #(temp) = ( (m1) + (m2) )*(c)
+    sd temp
+    set temp m1
+    add temp m2
+    mult temp c
+    #(m1) *= k1
+    mult m1 k1
+    #(m2) *= k2
+    mult m2 k2
+    #(m1) = ((m1)+(temp))
+    add m1 temp
+    #(m2) = ((m2)+(temp))
+    add m2 temp
+
+    set p_m2# m2
+    return m1
+endfunction
+
+############Quantize
+
+function mpeg_mb_quant(sd dct_codes,sd qcoeff)
+    sd scaler_lum=default_scaler
+    sd scaler_crom=default_scaler
+    sd i=0
+    while i!=6
+        sd scaler
+        if i<4
+            set scaler scaler_lum
+        else
+            set scaler scaler_crom
+        endelse
+        call mpeg_mb_quant_block(dct_codes,qcoeff,scaler)
+        add dct_codes (64*int16)
+        add qcoeff (64*int16)
+        inc i
+    endwhile
+endfunction
+
+import "neg" neg
+function mpeg_mb_quant_block(sd dct_codes,sd qcoeff,sd scaler)
+    const SCALEBITS=16
+#define FIX(X)		((1L << SCALEBITS) / (X) + 1)
+    data m_data={0,               2$SCALEBITS/2+1, 2$SCALEBITS/4+1, 2$SCALEBITS/6+1}
+    data      *={2$SCALEBITS/8+1, 2$SCALEBITS/10+1,2$SCALEBITS/12+1,2$SCALEBITS/14+1}
+    data      *={2$SCALEBITS/16+1,2$SCALEBITS/18+1,2$SCALEBITS/20+1,2$SCALEBITS/22+1}
+    data      *={2$SCALEBITS/24+1,2$SCALEBITS/26+1,2$SCALEBITS/28+1,2$SCALEBITS/30+1}
+    data      *={2$SCALEBITS/32+1,2$SCALEBITS/34+1,2$SCALEBITS/36+1,2$SCALEBITS/38+1}
+    data      *={2$SCALEBITS/40+1,2$SCALEBITS/42+1,2$SCALEBITS/44+1,2$SCALEBITS/46+1}
+    data      *={2$SCALEBITS/48+1,2$SCALEBITS/50+1,2$SCALEBITS/52+1,2$SCALEBITS/54+1}
+    data      *={2$SCALEBITS/56+1,2$SCALEBITS/58+1,2$SCALEBITS/60+1,2$SCALEBITS/62+1}
+    data multipliers^m_data
+    import "array_get_int" array_get_int
+    sd multp
+    setcall multp array_get_int(multipliers,(DEFAULT_QUANT))
+
+    sd quant_m_2=DEFAULT_QUANT*2
+    #sd quant_d_2=DEFAULT_QUANT/2
+    #sd sum=0
+
+    sd codes0
+    setcall codes0 array_get_int16(dct_codes,0)
+    sd value
+    setcall value mb_div(codes0,scaler)
+    call array_set_word_off(qcoeff,value,0)
+
+    sd i=1
+    while i<64
+        sd acLevel
+        setcall acLevel array_get_int16(dct_codes,i)
+        if acLevel<0
+            setcall acLevel neg(acLevel)
+            if acLevel<quant_m_2
+                call array_set_word_off(qcoeff,0,i)
+            else
+                mult acLevel multp
+                div acLevel (2$SCALEBITS)
+                #sum += acLevel
+                setcall acLevel neg(acLevel)
+                call array_set_word_off(qcoeff,acLevel,i)
+            endelse
+        else
+            if acLevel<quant_m_2
+                call array_set_word_off(qcoeff,0,i)
+            else
+                mult acLevel multp
+                div acLevel (2$SCALEBITS)
+                #sum += acLevel
+                call array_set_word_off(qcoeff,acLevel,i)
+            endelse
+        endelse
+        inc i
+    endwhile
+endfunction
+
+function mb_div(sd a,sd b)
+    sd temp
+    set temp b
+    div temp 2
+    if a>0
+    #((a)+((b)>>1))/(b)
+        add a temp
+    else
+    #((a)-((b)>>1))/(b))
+        sub a temp
+    endelse
+    div a b
+    return a
+endfunction
+
--- ovideo-1.orig/src/media/mpeg_enc.s
+++ /dev/null
@@ -1,522 +0,0 @@
-
-format elfobj
-
-include "../_include/include.h"
-
-#bool
-function mpeg_frame_block(sd max_y,sd max_x,sd type)
-    char dct_codes#6*64*int16
-    char qcoeff#6*64*int16
-
-    data p_dct_codes^dct_codes
-    data p_qcoeff^qcoeff
-
-    data acpred_direction_data#6
-    data acpred_direction^acpred_direction_data
-
-    sd bool
-    import "mpeg_mem_bit" mpeg_mem_bit
-
-    sd y=0
-    while y!=max_y
-        sd x=0
-        while x!=max_x
-            sd mode=INTRA
-            if type==(P_VOP)
-                import "mpeg_compare_block" mpeg_compare_block
-                setcall mode mpeg_compare_block(x,y)
-            endif
-            import "macro_blocks_mode" macro_blocks_mode
-            sd mbpos
-            set mbpos y
-            mult mbpos max_x
-            add mbpos x
-            call macro_blocks_mode((value_set),mbpos,mode)
-            if mode==(INTRA)
-                call mpeg_mb_trans_quant(x,y,p_dct_codes,p_qcoeff)
-
-                import "mpeg_mb_prediction" mpeg_mb_prediction
-                sd cbp
-                setcall cbp mpeg_mb_prediction(x,y,max_x,p_qcoeff,acpred_direction)
-
-                import "mpeg_mb_code" mpeg_mb_code
-                setcall bool mpeg_mb_code(cbp,acpred_direction,p_qcoeff,type)
-                if bool!=1
-                    return 0
-                endif
-            else
-                #skip
-                setcall bool mpeg_mem_bit(1)
-                if bool!=1
-                    return 0
-                endif
-            endelse
-
-            inc x
-        endwhile
-        inc y
-    endwhile
-
-    import "mpeg_mem_pad" mpeg_mem_pad
-    setcall bool mpeg_mem_pad((always))
-    if bool!=1
-        return 0
-    endif
-
-    return 1
-endfunction
-
-function mpeg_mb_trans_quant(sd x,sd y,sd p_dct_codes,sd p_qcoeff)
-    #Transfer data 8 to 16
-    data t8to16^mb_trans_8to16
-    call mpeg_mb_trans(x,y,p_dct_codes,t8to16)
-    #DCT and field decision
-    call mpeg_mb_dct(p_dct_codes)
-    #Quantize the block
-    call mpeg_mb_quant(p_dct_codes,p_qcoeff)
-    #DeQuantize the block
-    #call mpeg_mb_dequant(p_dct_codes,p_qcoeff)
-    #Inverse DCT
-    #call mpeg_mb_inv_dct(p_dct_codes)
-    #Transfer data 16 to 8
-    #data t16to8^mb_trans_16to8
-    #call mpeg_mb_trans(x,y,p_dct_codes,t16to8)
-endfunction
-
-import "mpeg_input_y" mpeg_input_y
-import "mpeg_input_u" mpeg_input_u
-import "mpeg_input_v" mpeg_input_v
-import "mpeg_input_lumstride" mpeg_input_lumstride
-import "mpeg_input_cromstride" mpeg_input_cromstride
-
-#########trans 8 to 16 for dct
-function mpeg_mb_trans(sd x,sd y,sd p_dct_codes,sd function)
-    sd Y
-    sd U
-    sd V
-    setcall Y mpeg_input_y((value_get))
-    setcall U mpeg_input_u((value_get))
-    setcall V mpeg_input_v((value_get))
-    sd lumstride
-    setcall lumstride mpeg_input_lumstride((value_get))
-    sd cromstride
-    setcall cromstride mpeg_input_cromstride((value_get))
-
-    #get plane,plane+8,plane+stride,plane+stride+8
-    sd i
-    sd ptr_dct_codes^p_dct_codes
-    sd cursor
-    set cursor y
-    mult cursor 16
-    mult cursor lumstride
-    set i x
-    mult i 16
-    add cursor i
-    add cursor Y
-    call function(cursor,ptr_dct_codes,lumstride)
-
-    add cursor 8
-    call function(cursor,ptr_dct_codes,lumstride)
-
-    sub cursor 8
-    sd lum_add
-    set lum_add lumstride
-    mult lum_add 8
-    add cursor lum_add
-    call function(cursor,ptr_dct_codes,lumstride)
-
-    add cursor 8
-    call function(cursor,ptr_dct_codes,lumstride)
-
-    set cursor y
-    mult cursor 8
-    mult cursor cromstride
-    set i x
-    mult i 8
-    add cursor i
-    add U cursor
-    call function(U,ptr_dct_codes,cromstride)
-
-    add V cursor
-    call function(V,ptr_dct_codes,cromstride)
-endfunction
-function mb_trans_8to16(ss src,sd p_dest,sd stride)
-    ss dest
-    set dest p_dest#
-
-    ss sign
-    set sign src
-    sd j=0
-    while j!=8
-        set src sign
-        sd i=0
-        while i!=8
-            set dest# src#
-            inc src
-
-            inc dest
-            set dest# 0
-            inc dest
-
-            inc i
-        endwhile
-        add sign stride
-        inc j
-    endwhile
-
-    set p_dest# dest
-endfunction
-
-const FIX=16
-const FPASS=2
-
-const ROT6_C=35468
-const ROT6_SmC=50159
-const ROT6_SpC=121095
-
-const ROT17_C=77062
-const ROT17_SpC=128553
-const ROT17_SmC=25571
-
-const ROT37_C=58981
-const ROT37_SmC=98391
-const ROT37_SpC=19571
-
-const ROT13_C=167963
-const ROT13_SmC=134553
-const ROT13_SpC=201373
-
-const pow_a=FIX-FPASS-1
-const pow_b=FIX+FPASS+3-1
-const pow_c=FPASS+3-1
-
-############dct
-function mpeg_mb_dct(sd dct_codes)
-    sd i=0
-    while i!=6
-        call mpeg_mb_dct_block(dct_codes)
-        add dct_codes (64*int16)
-        inc i
-    endwhile
-endfunction
-
-function mpeg_mb_dct_block(sd dct_codes)
-#perform dct on a 8x8 block
-    sd m0
-    sd m1
-    sd m2
-    sd m3
-    sd m4
-    sd m5
-    sd m6
-    sd m7
-    sd p_m1^m1
-    sd p_m2^m2
-    sd p_m3^m3
-    sd p_m4^m4
-    sd p_m5^m5
-    sd p_m6^m6
-    sd p_m7^m7
-
-    import "array_set_word_off" array_set_word_off
-    import "shl" shl
-    import "sar32" sar
-    sd i=8
-    sd dct_cursor
-    set dct_cursor dct_codes
-    while i>0
-    #even
-        #m1 m6
-        setcall m1 dct_op(p_m6,1,6,dct_cursor)
-        #m2 m5
-        setcall m2 dct_op(p_m5,2,5,dct_cursor)
-        #m3 m4
-        setcall m3 dct_op(p_m4,3,4,dct_cursor)
-        #m0 m7
-        setcall m0 dct_op(p_m7,0,7,dct_cursor)
-
-        #m1 m2
-        setcall m1 dct_calc(m1,p_m2)
-        #m0 m3
-        setcall m0 dct_calc(m0,p_m3)
-
-        #m3 m2 rotate
-        setcall m3 dct_rotate(m3,p_m2,(ROT6_C),(ROT6_SmC),(-1*ROT6_SpC),(FIX-FPASS),(2$pow_a))
-        #m2
-        call array_set_word_off(dct_cursor,m3,2)
-        #m3
-        call array_set_word_off(dct_cursor,m2,6)
-
-        #m0 m1
-        setcall m0 dct_calc(m0,p_m1)
-        #m0
-        setcall m0 shl(m0,(FPASS))
-        call array_set_word_off(dct_cursor,m0,0)
-        #m1
-        setcall m1 shl(m1,(FPASS))
-        call array_set_word_off(dct_cursor,m1,4)
-    #odd
-        #m3
-        set m3 m5
-        add m3 m7
-        #m2
-        set m2 m4
-        add m2 m6
-        #m2 m3 rotate
-        setcall m2 dct_rotate(m2,p_m3,(ROT17_C),(-1*ROT17_SpC),(-1*ROT17_SmC),(FIX-FPASS),(2$pow_a))
-        #m4 m7
-        setcall m4 dct_rotate(m4,p_m7,(-1*ROT37_C),(ROT37_SpC),(ROT37_SmC),(FIX-FPASS),(2$pow_a))
-        #m7
-        add m7 m3
-        call array_set_word_off(dct_cursor,m7,1)
-
-        #m4
-        add m4 m2
-        call array_set_word_off(dct_cursor,m4,7)
-
-        #m5 m6
-        setcall m5 dct_rotate(m5,p_m6,(-1*ROT13_C),(ROT13_SmC),(ROT13_SpC),(FIX-FPASS),(2$pow_a))
-        #m5
-        add m5 m3
-        call array_set_word_off(dct_cursor,m5,5)
-        #m6
-        add m6 m2
-        call array_set_word_off(dct_cursor,m6,3)
-
-        add dct_cursor (8*2)
-        dec i
-    endwhile
-    set i 8
-    set dct_cursor dct_codes
-    while i>0
-    #even
-        #m1 m2
-        setcall m1 dct_op(p_m6,(1*8),(6*8),dct_cursor)
-        setcall m2 dct_op(p_m5,(2*8),(5*8),dct_cursor)
-        setcall m1 dct_calc(m1,p_m2)
-
-        #m3 m4
-        setcall m3 dct_op(p_m4,(3*8),(4*8),dct_cursor)
-        #m0 m7
-        setcall m0 dct_op(p_m7,(0*8),(7*8),dct_cursor)
-        setcall m0 dct_calc(m0,p_m3)
-
-        #m3 m2
-        setcall m3 dct_rotate(m3,p_m2,(ROT6_C),(ROT6_SmC),(-1*ROT6_SpC),0,(2$pow_b))
-        #m3
-        setcall m3 sar(m3,(FIX+FPASS+3))
-        call array_set_word_off(dct_cursor,m3,(2*8))
-        #m2
-        setcall m2 sar(m2,(FIX+FPASS+3))
-        call array_set_word_off(dct_cursor,m2,(6*8))
-
-        #m0 m1
-        add m0 (2$pow_c-1)
-        setcall m0 dct_calc(m0,p_m1)
-        #m0
-        setcall m0 sar(m0,(FPASS+3))
-        call array_set_word_off(dct_cursor,m0,(0*8))
-        #m1
-        setcall m1 sar(m1,(FPASS+3))
-        call array_set_word_off(dct_cursor,m1,(4*8))
-    #odd
-        #m3
-        set m3 m5
-        add m3 m7
-        #m2
-        set m2 m4
-        add m2 m6
-
-        #m2 m3
-        setcall m2 dct_rotate(m2,p_m3,(ROT17_C),(-1*ROT17_SpC),(-1*ROT17_SmC),0,(2$pow_b))
-        #m4 m7
-        setcall m4 dct_rotate_simple(m4,p_m7,(-1*ROT37_C),(ROT37_SpC),(ROT37_SmC))
-        #m7
-        add m7 m3
-        setcall m7 sar(m7,(FIX+FPASS+3))
-        call array_set_word_off(dct_cursor,m7,(1*8))
-        #m4
-        add m4 m2
-        setcall m4 sar(m4,(FIX+FPASS+3))
-        call array_set_word_off(dct_cursor,m4,(7*8))
-
-        #m5 m6
-        setcall m5 dct_rotate_simple(m5,p_m6,(-1*ROT13_C),(ROT13_SmC),(ROT13_SpC))
-        add m5 m3
-        add m6 m2
-        setcall m5 sar(m5,(FIX+FPASS+3))
-        setcall m6 sar(m6,(FIX+FPASS+3))
-        call array_set_word_off(dct_cursor,m5,(5*8))
-        call array_set_word_off(dct_cursor,m6,(3*8))
-
-        add dct_cursor (1*2)
-        dec i
-    endwhile
-endfunction
-
-function dct_op(sd p_b,sd xa,sd xb,sd codes)
-    import "array_get_int16" array_get_int16
-    sd a
-    setcall a array_get_int16(codes,xa)
-    addcall a array_get_int16(codes,xb)
-    setcall p_b# array_get_int16(codes,xa)
-    subcall p_b# array_get_int16(codes,xb)
-    return a
-endfunction
-
-#temp=a+b;b=a-b;a=tmp
-#return a
-function dct_calc(sd a,sd p_b)
-    sd temp
-    set temp a
-    add temp p_b#
-
-    sd b
-    set b a
-    sub b p_b#
-    set p_b# b
-
-    return temp
-endfunction
-
-#return m1
-function dct_rotate(sd m1,sd p_m2,sd c,sd k1,sd k2,sd fix,sd rnd)
-    sd m2
-    set m2 p_m2#
-#define ROTATE(m1,m2,c,k1,k2,Fix,Rnd)
-    #(temp) = ( (m1) + (m2) )*(c)
-    sd temp
-    set temp m1
-    add temp m2
-    mult temp c
-    #(m1) *= k1
-    mult m1 k1
-    #(m2) *= k2
-    mult m2 k2
-    #(temp) += (Rnd)
-    add temp rnd
-    #(m1) = ((m1)+(temp))>>(Fix)
-    add m1 temp
-    setcall m1 sar(m1,fix)
-    #(m2) = ((m2)+(temp))>>(Fix)
-    add m2 temp
-    setcall m2 sar(m2,fix)
-
-    set p_m2# m2
-    return m1
-endfunction
-
-#return m1
-function dct_rotate_simple(sd m1,sd p_m2,sd c,sd k1,sd k2)
-    sd m2
-    set m2 p_m2#
-#define ROTATE(m1,m2,c,k1,k2)
-    #(temp) = ( (m1) + (m2) )*(c)
-    sd temp
-    set temp m1
-    add temp m2
-    mult temp c
-    #(m1) *= k1
-    mult m1 k1
-    #(m2) *= k2
-    mult m2 k2
-    #(m1) = ((m1)+(temp))
-    add m1 temp
-    #(m2) = ((m2)+(temp))
-    add m2 temp
-
-    set p_m2# m2
-    return m1
-endfunction
-
-############Quantize
-
-function mpeg_mb_quant(sd dct_codes,sd qcoeff)
-    sd scaler_lum=default_scaler
-    sd scaler_crom=default_scaler
-    sd i=0
-    while i!=6
-        sd scaler
-        if i<4
-            set scaler scaler_lum
-        else
-            set scaler scaler_crom
-        endelse
-        call mpeg_mb_quant_block(dct_codes,qcoeff,scaler)
-        add dct_codes (64*int16)
-        add qcoeff (64*int16)
-        inc i
-    endwhile
-endfunction
-
-import "neg" neg
-function mpeg_mb_quant_block(sd dct_codes,sd qcoeff,sd scaler)
-    const SCALEBITS=16
-#define FIX(X)		((1L << SCALEBITS) / (X) + 1)
-    data m_data={0,               2$SCALEBITS/2+1, 2$SCALEBITS/4+1, 2$SCALEBITS/6+1}
-    data      *={2$SCALEBITS/8+1, 2$SCALEBITS/10+1,2$SCALEBITS/12+1,2$SCALEBITS/14+1}
-    data      *={2$SCALEBITS/16+1,2$SCALEBITS/18+1,2$SCALEBITS/20+1,2$SCALEBITS/22+1}
-    data      *={2$SCALEBITS/24+1,2$SCALEBITS/26+1,2$SCALEBITS/28+1,2$SCALEBITS/30+1}
-    data      *={2$SCALEBITS/32+1,2$SCALEBITS/34+1,2$SCALEBITS/36+1,2$SCALEBITS/38+1}
-    data      *={2$SCALEBITS/40+1,2$SCALEBITS/42+1,2$SCALEBITS/44+1,2$SCALEBITS/46+1}
-    data      *={2$SCALEBITS/48+1,2$SCALEBITS/50+1,2$SCALEBITS/52+1,2$SCALEBITS/54+1}
-    data      *={2$SCALEBITS/56+1,2$SCALEBITS/58+1,2$SCALEBITS/60+1,2$SCALEBITS/62+1}
-    data multipliers^m_data
-    import "array_get_int" array_get_int
-    sd multp
-    setcall multp array_get_int(multipliers,(DEFAULT_QUANT))
-
-    sd quant_m_2=DEFAULT_QUANT*2
-    #sd quant_d_2=DEFAULT_QUANT/2
-    #sd sum=0
-
-    sd codes0
-    setcall codes0 array_get_int16(dct_codes,0)
-    sd value
-    setcall value mb_div(codes0,scaler)
-    call array_set_word_off(qcoeff,value,0)
-
-    sd i=1
-    while i<64
-        sd acLevel
-        setcall acLevel array_get_int16(dct_codes,i)
-        if acLevel<0
-            setcall acLevel neg(acLevel)
-            if acLevel<quant_m_2
-                call array_set_word_off(qcoeff,0,i)
-            else
-                mult acLevel multp
-                div acLevel (2$SCALEBITS)
-                #sum += acLevel
-                setcall acLevel neg(acLevel)
-                call array_set_word_off(qcoeff,acLevel,i)
-            endelse
-        else
-            if acLevel<quant_m_2
-                call array_set_word_off(qcoeff,0,i)
-            else
-                mult acLevel multp
-                div acLevel (2$SCALEBITS)
-                #sum += acLevel
-                call array_set_word_off(qcoeff,acLevel,i)
-            endelse
-        endelse
-        inc i
-    endwhile
-endfunction
-
-function mb_div(sd a,sd b)
-    sd temp
-    set temp b
-    div temp 2
-    if a>0
-    #((a)+((b)>>1))/(b)
-        add a temp
-    else
-    #((a)-((b)>>1))/(b))
-        sub a temp
-    endelse
-    div a b
-    return a
-endfunction
-
--- /dev/null
+++ ovideo-1/src/media/mpeg_init.oc
@@ -0,0 +1,404 @@
+
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+function mpeg_init_vlc()
+    call vlc_tables_intra((value_set))
+endfunction
+
+const levelstride=VLC_size
+const runstride=64*levelstride
+const laststride=64*runstride
+
+function vlc_tables_intra(sd action,sd name,sd last,sd run,sd level)
+    const vlc_array_size=2*64*64*VLC_size
+    #[2][64][64]
+    #data code
+    #char len
+    char vlc_data#vlc_array_size
+    if action=(value_set)
+        #set tables to 0 or bad code can be written
+        import "setmem" setmem
+        sd vlc_init^vlc_data
+        call setmem(vlc_init,(vlc_array_size),0)
+        call vlc_tables_len_init()
+        call vlc_tables_len_init2()
+        call vlc_tables_len_init3()
+    else
+    #if action==(value_get)
+    #pointer
+        ss vlc^vlc_data
+        mult last (laststride)
+        mult run (runstride)
+        mult level (levelstride)
+        add vlc last
+        add vlc run
+        add vlc level
+        add vlc name
+        return vlc
+    endelse
+endfunction
+
+##1
+
+#const LEVELOFFSET=32
+function vlc_tables_len_init()
+    sd last=0
+    while last<2
+        sd run=0
+        sd last_run
+        set last_run 63
+        add last_run last
+        while run<last_run
+            sd level=0
+            while level<(32*2)
+                ss vlc_l
+                setcall vlc_l vlc_tables_intra((value_get),(VLC_len),last,level,run)
+                set vlc_l# 128
+
+                inc level
+            endwhile
+            inc run
+        endwhile
+        inc last
+    endwhile
+endfunction
+
+const coeff_tab_vlc=VLC_code
+const coeff_tab_vlc_code=VLC_code
+const coeff_tab_vlc_len=VLC_len
+
+const coeff_tab_event=coeff_tab_vlc_len+1
+const coeff_tab_event_last=0
+const coeff_tab_event_run=1
+const coeff_tab_event_level=2
+
+##2
+
+function vlc_coeff_tab_intra(sd i,sd block,sd subblock)
+    #vlc
+        #code  u32
+        #len   u8
+    #event
+        #last  u8
+        #run   u8
+        #level i8
+    char tab={2, 0,0,0,  2,    0, 0, 1}
+    char *  ={15,0,0,0,  4,    0, 0, 3}
+    char *  ={21,0,0,0,  6,    0, 0, 6}
+    char *  ={23,0,0,0,  7,    0, 0, 9}
+    char *  ={31,0,0,0,  8,    0, 0, 10}
+    char *  ={37,0,0,0,  9,    0, 0, 13}
+    char *  ={36,0,0,0,  9,    0, 0, 14}
+    char *  ={33,0,0,0, 10,    0, 0, 17}
+    char *  ={32,0,0,0, 10,    0, 0, 18}
+    char *  ={ 7,0,0,0, 11,    0, 0, 21}
+    char *  ={ 6,0,0,0, 11,    0, 0, 22}
+    char *  ={32,0,0,0, 11,    0, 0, 23}
+    char *  ={ 6,0,0,0,  3,    0, 0, 2}
+    char *  ={20,0,0,0,  6,    0, 1, 2}
+    char *  ={30,0,0,0,  8,    0, 0, 11}
+    char *  ={15,0,0,0, 10,    0, 0, 19}
+    char *  ={33,0,0,0, 11,    0, 0, 24}
+    char *  ={80,0,0,0, 12,    0, 0, 25}
+    char *  ={14,0,0,0,  4,    0, 1, 1}
+    char *  ={29,0,0,0,  8,    0, 0, 12}
+    char *  ={14,0,0,0, 10,    0, 0, 20}
+    char *  ={81,0,0,0, 12,    0, 0, 26}
+    char *  ={13,0,0,0,  5,    0, 0, 4}
+    char *  ={35,0,0,0,  9,    0, 0, 15}
+    char *  ={13,0,0,0, 10,    0, 1, 7}
+    char *  ={12,0,0,0,  5,    0, 0, 5}
+    char *  ={34,0,0,0,  9,    0, 4, 2}
+    char *  ={82,0,0,0, 12,    0, 0, 27}
+    char *  ={11,0,0,0,  5,    0, 2, 1}
+    char *  ={12,0,0,0, 10,    0, 2, 4}
+    char *  ={83,0,0,0, 12,    0, 1, 9}
+    char *  ={19,0,0,0,  6,    0, 0, 7}
+    char *  ={11,0,0,0, 10,    0, 3, 4}
+    char *  ={84,0,0,0, 12,    0, 6, 3}
+    char *  ={18,0,0,0,  6,    0, 0, 8}
+    char *  ={10,0,0,0, 10,    0, 4, 3}
+    char *  ={17,0,0,0,  6,    0, 3, 1}
+    char *  ={ 9,0,0,0, 10,    0, 8, 2}
+    char *  ={16,0,0,0,  6,    0, 4, 1}
+    char *  ={ 8,0,0,0, 10,    0, 5, 3}
+    char *  ={22,0,0,0,  7,    0, 1, 3}
+    char *  ={85,0,0,0, 12,    0, 1, 10}
+    char *  ={21,0,0,0,  7,    0, 2, 2}
+    char *  ={20,0,0,0,  7,    0, 7, 1}
+    char *  ={28,0,0,0,  8,    0, 1, 4}
+    char *  ={27,0,0,0,  8,    0, 3, 2}
+    char *  ={33,0,0,0,  9,    0, 0, 16}
+    char *  ={32,0,0,0,  9,    0, 1, 5}
+    char *  ={31,0,0,0,  9,    0, 1, 6}
+    char *  ={30,0,0,0,  9,    0, 2, 3}
+    char *  ={29,0,0,0,  9,    0, 3, 3}
+    char *  ={28,0,0,0,  9,    0, 5, 2}
+    char *  ={27,0,0,0,  9,    0, 6, 2}
+    char *  ={26,0,0,0,  9,    0, 7, 2}
+    char *  ={34,0,0,0, 11,    0, 1, 8}
+    char *  ={35,0,0,0, 11,    0, 9, 2}
+    char *  ={86,0,0,0, 12,    0, 2, 5}
+    char *  ={87,0,0,0, 12,    0, 7, 3}
+    char *  ={ 7,0,0,0,  4,    1, 0, 1}
+    char *  ={25,0,0,0,  9,    0, 11, 1}
+    char *  ={ 5,0,0,0, 11,    1, 0, 6}
+    char *  ={15,0,0,0,  6,    1, 1, 1}
+    char *  ={ 4,0,0,0, 11,    1, 0, 7}
+    char *  ={14,0,0,0,  6,    1, 2, 1}
+    char *  ={13,0,0,0,  6,    0, 5, 1}
+    char *  ={12,0,0,0,  6,    1, 0, 2}
+    char *  ={19,0,0,0,  7,    1, 5, 1}
+    char *  ={18,0,0,0,  7,    0, 6, 1}
+    char *  ={17,0,0,0,  7,    1, 3, 1}
+    char *  ={16,0,0,0,  7,    1, 4, 1}
+    char *  ={26,0,0,0,  8,    1, 9, 1}
+    char *  ={25,0,0,0,  8,    0, 8, 1}
+    char *  ={24,0,0,0,  8,    0, 9, 1}
+    char *  ={23,0,0,0,  8,    0, 10, 1}
+    char *  ={22,0,0,0,  8,    1, 0, 3}
+    char *  ={21,0,0,0,  8,    1, 6, 1}
+    char *  ={20,0,0,0,  8,    1, 7, 1}
+    char *  ={19,0,0,0,  8,    1, 8, 1}
+    char *  ={24,0,0,0,  9,    0, 12, 1}
+    char *  ={23,0,0,0,  9,    1, 0, 4}
+    char *  ={22,0,0,0,  9,    1, 1, 2}
+    char *  ={21,0,0,0,  9,    1, 10, 1}
+    char *  ={20,0,0,0,  9,    1, 11, 1}
+    char *  ={19,0,0,0,  9,    1, 12, 1}
+    char *  ={18,0,0,0,  9,    1, 13, 1}
+    char *  ={17,0,0,0,  9,    1, 14, 1}
+    char *  ={7, 0,0,0, 10,    0, 13, 1}
+    char *  ={6, 0,0,0, 10,    1, 0, 5}
+    char *  ={5, 0,0,0, 10,    1, 1, 3}
+    char *  ={4, 0,0,0, 10,    1, 2, 2}
+    char *  ={36,0,0,0, 11,    1, 3, 2}
+    char *  ={37,0,0,0, 11,    1, 4, 2}
+    char *  ={38,0,0,0, 11,    1, 15, 1}
+    char *  ={39,0,0,0, 11,    1, 16, 1}
+    char *  ={88,0,0,0, 12,    0, 14, 1}
+    char *  ={89,0,0,0, 12,    1, 0, 8}
+    char *  ={90,0,0,0, 12,    1, 5, 2}
+    char *  ={91,0,0,0, 12,    1, 6, 2}
+    char *  ={92,0,0,0, 12,    1, 17, 1}
+    char *  ={93,0,0,0, 12,    1, 18, 1}
+    char *  ={94,0,0,0, 12,    1, 19, 1}
+    char *  ={95,0,0,0, 12,    1, 20, 1}
+
+    data coeff_tab^tab
+    data stride=4+1+3
+
+    sd value
+    set value i
+    mult value stride
+    add value block
+    add value subblock
+    add value coeff_tab
+
+    if block=(coeff_tab_vlc)
+        if subblock=(coeff_tab_vlc_code)
+            return value#
+        endif
+    endif
+    ss byte
+    set byte value
+    return byte#
+endfunction
+
+function vlc_tables_len_init2()
+    sd i=0
+    while i<102
+        sd value
+
+        sd run
+        setcall run vlc_coeff_tab_intra(i,(coeff_tab_event),(coeff_tab_event_run))
+        sd level
+        setcall level vlc_coeff_tab_intra(i,(coeff_tab_event),(coeff_tab_event_level))
+        sd last
+        setcall last vlc_coeff_tab_intra(i,(coeff_tab_event),(coeff_tab_event_last))
+
+        #code
+        sd code
+        setcall code vlc_coeff_tab_intra(i,(coeff_tab_vlc),(coeff_tab_vlc_code))
+        mult code 2
+        #
+        sd vlc_c
+        setcall vlc_c vlc_tables_intra((value_get),(VLC_code),last,level,run)
+        set vlc_c# code
+
+        #len
+        setcall value vlc_coeff_tab_intra(i,(coeff_tab_vlc),(coeff_tab_vlc_len))
+        inc value
+        #
+        ss vlc_l
+        setcall vlc_l vlc_tables_intra((value_get),(VLC_len),last,level,run)
+        set vlc_l# value
+
+        inc i
+    endwhile
+endfunction
+
+##3
+
+function vlc_tables_intra_maxrun(sd last,sd pos)
+    char last0={0, 14, 9, 7, 3, 2, 1, 1}
+    char *    ={1, 1,  1, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+
+    char last1={0, 20, 6, 1, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
+
+	if last=0
+        ss max0^last0
+        add max0 pos
+        return max0#
+	endif
+        ss max1^last1
+        add max1 pos
+        return max1#
+endfunction
+
+function vlc_tables_intra_maxlevel(sd last,sd pos)
+    #u8
+    char last0={27,10, 5, 4, 3, 3, 3, 3}
+    char *    ={2,  2, 1, 1, 1, 1, 1, 0}
+    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
+    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
+    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
+    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
+    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
+    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
+
+    char last1={8, 3, 2, 2, 2, 2, 2, 1}
+    char *    ={1, 1, 1, 1, 1, 1, 1, 1}
+    char *    ={1, 1, 1, 1, 1, 0, 0, 0}
+    char *    ={0, 0, 0, 0, 0, 0, 0, 0}
+    char *    ={0, 0, 0, 0, 0, 0, 0, 0}
+    char *    ={0, 0, 0, 0, 0, 0, 0, 0}
+    char *    ={0, 0, 0, 0, 0, 0, 0, 0}
+    char *    ={0, 0, 0, 0, 0, 0, 0, 0}
+
+	if last=0
+        ss max0^last0
+        add max0 pos
+        return max0#
+	endif
+        ss max1^last1
+        add max1 pos
+        return max1#
+endfunction
+
+function vlc_tables_len_init3()
+    sd last=0
+    while last<2
+        sd run=0
+        sd last_run
+        set last_run 63
+        add last_run last
+        while run<last_run
+            sd level=1
+            while level<(32*2)
+                sd condition=0
+                sd max
+                setcall max vlc_tables_intra_maxlevel(last,run)
+                if level<=max
+                    setcall max vlc_tables_intra_maxrun(last,level)
+                    if run<=max
+                        set condition 1
+                    endif
+                endif
+                if condition=0
+                    sd continuation=1
+
+                    sd level_esc
+                    set level_esc level
+                    subcall level_esc vlc_tables_intra_maxlevel(last,run)
+                    sd run_esc
+                    set run_esc run
+                    dec run_esc
+                    subcall run_esc vlc_tables_intra_maxrun(last,level)
+
+                    set condition 0
+                    setcall max vlc_tables_intra_maxlevel(last,run)
+                    if level_esc<=max
+                        setcall max vlc_tables_intra_maxrun(last,level_esc)
+                        if run<=max
+                            set condition 1
+                        endif
+                    endif
+                    sd escape
+                    sd escape_len
+                    if condition=1
+                        set escape (ESCAPE1)
+                        set escape_len (7+1)
+                        set run_esc run
+                    else
+                        set condition 0
+                        setcall max vlc_tables_intra_maxrun(last,level)
+                        if run_esc<=max
+                            if run_esc<0
+                                set max 0
+                            else
+                                setcall max vlc_tables_intra_maxlevel(last,run_esc)
+                            endelse
+                            if level<=max
+                                set condition 1
+                            endif
+                        endif
+                        if condition=1
+                            set escape (ESCAPE2)
+                            set escape_len (7+2)
+                            set level_esc level
+                        else
+                            set continuation 0
+                        endelse
+                    endelse
+
+                    if continuation=1
+                        ss vlc_len_src
+                        setcall vlc_len_src vlc_tables_intra((value_get),(VLC_len),last,level_esc,run_esc)
+                        sd len
+                        set len vlc_len_src#
+
+                        #code
+                        sd vlc_code_dest
+                        setcall vlc_code_dest vlc_tables_intra((value_get),(VLC_code),last,level,run)
+                        sd vlc_code_src
+                        setcall vlc_code_src vlc_tables_intra((value_get),(VLC_code),last,level_esc,run_esc)
+                        sd code
+                        set code vlc_code_src#
+                        import "shl" shl
+                        orcall code shl(escape,len)
+                        #len
+                        ss vlc_len_dest
+                        setcall vlc_len_dest vlc_tables_intra((value_get),(VLC_len),last,level,run)
+                        add len escape_len
+
+                        set vlc_code_dest# code
+                        set vlc_len_dest# len
+                    endif
+                endif
+
+                inc level
+            endwhile
+            inc run
+        endwhile
+        inc last
+    endwhile
+endfunction
--- ovideo-1.orig/src/media/mpeg_init.s
+++ /dev/null
@@ -1,406 +0,0 @@
-
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-function mpeg_init_vlc()
-    call vlc_tables_intra((value_set))
-endfunction
-
-const levelstride=VLC_size
-const runstride=64*levelstride
-const laststride=64*runstride
-
-function vlc_tables_intra(sd action,sd name,sd last,sd run,sd level)
-    const vlc_array_size=2*64*64*VLC_size
-    #[2][64][64]
-    #data code
-    #char len
-    char vlc_data#vlc_array_size
-    if action==(value_set)
-        #set tables to 0 or bad code can be written
-        import "setmem" setmem
-        sd vlc_init^vlc_data
-        call setmem(vlc_init,(vlc_array_size),0)
-        call vlc_tables_len_init()
-        call vlc_tables_len_init2()
-        call vlc_tables_len_init3()
-    else
-    #if action==(value_get)
-    #pointer
-        ss vlc^vlc_data
-        mult last (laststride)
-        mult run (runstride)
-        mult level (levelstride)
-        add vlc last
-        add vlc run
-        add vlc level
-        add vlc name
-        return vlc
-    endelse
-endfunction
-
-##1
-
-#const LEVELOFFSET=32
-function vlc_tables_len_init()
-    sd last=0
-    while last<2
-        sd run=0
-        sd last_run
-        set last_run 63
-        add last_run last
-        while run<last_run
-            sd level=0
-            while level<(32*2)
-                ss vlc_l
-                setcall vlc_l vlc_tables_intra((value_get),(VLC_len),last,level,run)
-                set vlc_l# 128
-
-                inc level
-            endwhile
-            inc run
-        endwhile
-        inc last
-    endwhile
-endfunction
-
-const coeff_tab_vlc=VLC_code
-const coeff_tab_vlc_code=VLC_code
-const coeff_tab_vlc_len=VLC_len
-
-const coeff_tab_event=coeff_tab_vlc_len+1
-const coeff_tab_event_last=0
-const coeff_tab_event_run=1
-const coeff_tab_event_level=2
-
-##2
-
-function vlc_coeff_tab_intra(sd i,sd block,sd subblock)
-    #vlc
-        #code  u32
-        #len   u8
-    #event
-        #last  u8
-        #run   u8
-        #level i8
-    char tab={2, 0,0,0,  2,    0, 0, 1}
-    char *  ={15,0,0,0,  4,    0, 0, 3}
-    char *  ={21,0,0,0,  6,    0, 0, 6}
-    char *  ={23,0,0,0,  7,    0, 0, 9}
-    char *  ={31,0,0,0,  8,    0, 0, 10}
-    char *  ={37,0,0,0,  9,    0, 0, 13}
-    char *  ={36,0,0,0,  9,    0, 0, 14}
-    char *  ={33,0,0,0, 10,    0, 0, 17}
-    char *  ={32,0,0,0, 10,    0, 0, 18}
-    char *  ={ 7,0,0,0, 11,    0, 0, 21}
-    char *  ={ 6,0,0,0, 11,    0, 0, 22}
-    char *  ={32,0,0,0, 11,    0, 0, 23}
-    char *  ={ 6,0,0,0,  3,    0, 0, 2}
-    char *  ={20,0,0,0,  6,    0, 1, 2}
-    char *  ={30,0,0,0,  8,    0, 0, 11}
-    char *  ={15,0,0,0, 10,    0, 0, 19}
-    char *  ={33,0,0,0, 11,    0, 0, 24}
-    char *  ={80,0,0,0, 12,    0, 0, 25}
-    char *  ={14,0,0,0,  4,    0, 1, 1}
-    char *  ={29,0,0,0,  8,    0, 0, 12}
-    char *  ={14,0,0,0, 10,    0, 0, 20}
-    char *  ={81,0,0,0, 12,    0, 0, 26}
-    char *  ={13,0,0,0,  5,    0, 0, 4}
-    char *  ={35,0,0,0,  9,    0, 0, 15}
-    char *  ={13,0,0,0, 10,    0, 1, 7}
-    char *  ={12,0,0,0,  5,    0, 0, 5}
-    char *  ={34,0,0,0,  9,    0, 4, 2}
-    char *  ={82,0,0,0, 12,    0, 0, 27}
-    char *  ={11,0,0,0,  5,    0, 2, 1}
-    char *  ={12,0,0,0, 10,    0, 2, 4}
-    char *  ={83,0,0,0, 12,    0, 1, 9}
-    char *  ={19,0,0,0,  6,    0, 0, 7}
-    char *  ={11,0,0,0, 10,    0, 3, 4}
-    char *  ={84,0,0,0, 12,    0, 6, 3}
-    char *  ={18,0,0,0,  6,    0, 0, 8}
-    char *  ={10,0,0,0, 10,    0, 4, 3}
-    char *  ={17,0,0,0,  6,    0, 3, 1}
-    char *  ={ 9,0,0,0, 10,    0, 8, 2}
-    char *  ={16,0,0,0,  6,    0, 4, 1}
-    char *  ={ 8,0,0,0, 10,    0, 5, 3}
-    char *  ={22,0,0,0,  7,    0, 1, 3}
-    char *  ={85,0,0,0, 12,    0, 1, 10}
-    char *  ={21,0,0,0,  7,    0, 2, 2}
-    char *  ={20,0,0,0,  7,    0, 7, 1}
-    char *  ={28,0,0,0,  8,    0, 1, 4}
-    char *  ={27,0,0,0,  8,    0, 3, 2}
-    char *  ={33,0,0,0,  9,    0, 0, 16}
-    char *  ={32,0,0,0,  9,    0, 1, 5}
-    char *  ={31,0,0,0,  9,    0, 1, 6}
-    char *  ={30,0,0,0,  9,    0, 2, 3}
-    char *  ={29,0,0,0,  9,    0, 3, 3}
-    char *  ={28,0,0,0,  9,    0, 5, 2}
-    char *  ={27,0,0,0,  9,    0, 6, 2}
-    char *  ={26,0,0,0,  9,    0, 7, 2}
-    char *  ={34,0,0,0, 11,    0, 1, 8}
-    char *  ={35,0,0,0, 11,    0, 9, 2}
-    char *  ={86,0,0,0, 12,    0, 2, 5}
-    char *  ={87,0,0,0, 12,    0, 7, 3}
-    char *  ={ 7,0,0,0,  4,    1, 0, 1}
-    char *  ={25,0,0,0,  9,    0, 11, 1}
-    char *  ={ 5,0,0,0, 11,    1, 0, 6}
-    char *  ={15,0,0,0,  6,    1, 1, 1}
-    char *  ={ 4,0,0,0, 11,    1, 0, 7}
-    char *  ={14,0,0,0,  6,    1, 2, 1}
-    char *  ={13,0,0,0,  6,    0, 5, 1}
-    char *  ={12,0,0,0,  6,    1, 0, 2}
-    char *  ={19,0,0,0,  7,    1, 5, 1}
-    char *  ={18,0,0,0,  7,    0, 6, 1}
-    char *  ={17,0,0,0,  7,    1, 3, 1}
-    char *  ={16,0,0,0,  7,    1, 4, 1}
-    char *  ={26,0,0,0,  8,    1, 9, 1}
-    char *  ={25,0,0,0,  8,    0, 8, 1}
-    char *  ={24,0,0,0,  8,    0, 9, 1}
-    char *  ={23,0,0,0,  8,    0, 10, 1}
-    char *  ={22,0,0,0,  8,    1, 0, 3}
-    char *  ={21,0,0,0,  8,    1, 6, 1}
-    char *  ={20,0,0,0,  8,    1, 7, 1}
-    char *  ={19,0,0,0,  8,    1, 8, 1}
-    char *  ={24,0,0,0,  9,    0, 12, 1}
-    char *  ={23,0,0,0,  9,    1, 0, 4}
-    char *  ={22,0,0,0,  9,    1, 1, 2}
-    char *  ={21,0,0,0,  9,    1, 10, 1}
-    char *  ={20,0,0,0,  9,    1, 11, 1}
-    char *  ={19,0,0,0,  9,    1, 12, 1}
-    char *  ={18,0,0,0,  9,    1, 13, 1}
-    char *  ={17,0,0,0,  9,    1, 14, 1}
-    char *  ={7, 0,0,0, 10,    0, 13, 1}
-    char *  ={6, 0,0,0, 10,    1, 0, 5}
-    char *  ={5, 0,0,0, 10,    1, 1, 3}
-    char *  ={4, 0,0,0, 10,    1, 2, 2}
-    char *  ={36,0,0,0, 11,    1, 3, 2}
-    char *  ={37,0,0,0, 11,    1, 4, 2}
-    char *  ={38,0,0,0, 11,    1, 15, 1}
-    char *  ={39,0,0,0, 11,    1, 16, 1}
-    char *  ={88,0,0,0, 12,    0, 14, 1}
-    char *  ={89,0,0,0, 12,    1, 0, 8}
-    char *  ={90,0,0,0, 12,    1, 5, 2}
-    char *  ={91,0,0,0, 12,    1, 6, 2}
-    char *  ={92,0,0,0, 12,    1, 17, 1}
-    char *  ={93,0,0,0, 12,    1, 18, 1}
-    char *  ={94,0,0,0, 12,    1, 19, 1}
-    char *  ={95,0,0,0, 12,    1, 20, 1}
-
-    data coeff_tab^tab
-    data stride=4+1+3
-
-    sd value
-    set value i
-    mult value stride
-    add value block
-    add value subblock
-    add value coeff_tab
-
-    if block==(coeff_tab_vlc)
-        if subblock==(coeff_tab_vlc_code)
-            return value#
-        endif
-    endif
-    ss byte
-    set byte value
-    return byte#
-endfunction
-
-function vlc_tables_len_init2()
-    sd i=0
-    while i<102
-        sd value
-
-        sd run
-        setcall run vlc_coeff_tab_intra(i,(coeff_tab_event),(coeff_tab_event_run))
-        sd level
-        setcall level vlc_coeff_tab_intra(i,(coeff_tab_event),(coeff_tab_event_level))
-        sd last
-        setcall last vlc_coeff_tab_intra(i,(coeff_tab_event),(coeff_tab_event_last))
-
-        #code
-        sd code
-        setcall code vlc_coeff_tab_intra(i,(coeff_tab_vlc),(coeff_tab_vlc_code))
-        mult code 2
-        #
-        sd vlc_c
-        setcall vlc_c vlc_tables_intra((value_get),(VLC_code),last,level,run)
-        set vlc_c# code
-
-        #len
-        setcall value vlc_coeff_tab_intra(i,(coeff_tab_vlc),(coeff_tab_vlc_len))
-        inc value
-        #
-        ss vlc_l
-        setcall vlc_l vlc_tables_intra((value_get),(VLC_len),last,level,run)
-        set vlc_l# value
-
-        inc i
-    endwhile
-endfunction
-
-##3
-
-function vlc_tables_intra_maxrun(sd last,sd pos)
-    char last0={0, 14, 9, 7, 3, 2, 1, 1}
-    char *    ={1, 1,  1, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-
-    char last1={0, 20, 6, 1, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-    char *    ={0, 0,  0, 0, 0, 0, 0, 0}
-
-    if last==0
-        ss max0^last0
-        add max0 pos
-        return max0#
-    else
-        ss max1^last1
-        add max1 pos
-        return max1#
-    endelse
-endfunction
-
-function vlc_tables_intra_maxlevel(sd last,sd pos)
-    #u8
-    char last0={27,10, 5, 4, 3, 3, 3, 3}
-    char *    ={2,  2, 1, 1, 1, 1, 1, 0}
-    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
-    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
-    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
-    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
-    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
-    char *    ={0,  0, 0, 0, 0, 0, 0, 0}
-
-    char last1={8, 3, 2, 2, 2, 2, 2, 1}
-    char *    ={1, 1, 1, 1, 1, 1, 1, 1}
-    char *    ={1, 1, 1, 1, 1, 0, 0, 0}
-    char *    ={0, 0, 0, 0, 0, 0, 0, 0}
-    char *    ={0, 0, 0, 0, 0, 0, 0, 0}
-    char *    ={0, 0, 0, 0, 0, 0, 0, 0}
-    char *    ={0, 0, 0, 0, 0, 0, 0, 0}
-    char *    ={0, 0, 0, 0, 0, 0, 0, 0}
-
-    if last==0
-        ss max0^last0
-        add max0 pos
-        return max0#
-    else
-        ss max1^last1
-        add max1 pos
-        return max1#
-    endelse
-endfunction
-
-function vlc_tables_len_init3()
-    sd last=0
-    while last<2
-        sd run=0
-        sd last_run
-        set last_run 63
-        add last_run last
-        while run<last_run
-            sd level=1
-            while level<(32*2)
-                sd condition=0
-                sd max
-                setcall max vlc_tables_intra_maxlevel(last,run)
-                if level<=max
-                    setcall max vlc_tables_intra_maxrun(last,level)
-                    if run<=max
-                        set condition 1
-                    endif
-                endif
-                if condition==0
-                    sd continuation=1
-
-                    sd level_esc
-                    set level_esc level
-                    subcall level_esc vlc_tables_intra_maxlevel(last,run)
-                    sd run_esc
-                    set run_esc run
-                    dec run_esc
-                    subcall run_esc vlc_tables_intra_maxrun(last,level)
-
-                    set condition 0
-                    setcall max vlc_tables_intra_maxlevel(last,run)
-                    if level_esc<=max
-                        setcall max vlc_tables_intra_maxrun(last,level_esc)
-                        if run<=max
-                            set condition 1
-                        endif
-                    endif
-                    sd escape
-                    sd escape_len
-                    if condition==1
-                        set escape (ESCAPE1)
-                        set escape_len (7+1)
-                        set run_esc run
-                    else
-                        set condition 0
-                        setcall max vlc_tables_intra_maxrun(last,level)
-                        if run_esc<=max
-                            if run_esc<0
-                                set max 0
-                            else
-                                setcall max vlc_tables_intra_maxlevel(last,run_esc)
-                            endelse
-                            if level<=max
-                                set condition 1
-                            endif
-                        endif
-                        if condition==1
-                            set escape (ESCAPE2)
-                            set escape_len (7+2)
-                            set level_esc level
-                        else
-                            set continuation 0
-                        endelse
-                    endelse
-
-                    if continuation==1
-                        ss vlc_len_src
-                        setcall vlc_len_src vlc_tables_intra((value_get),(VLC_len),last,level_esc,run_esc)
-                        sd len
-                        set len vlc_len_src#
-
-                        #code
-                        sd vlc_code_dest
-                        setcall vlc_code_dest vlc_tables_intra((value_get),(VLC_code),last,level,run)
-                        sd vlc_code_src
-                        setcall vlc_code_src vlc_tables_intra((value_get),(VLC_code),last,level_esc,run_esc)
-                        sd code
-                        set code vlc_code_src#
-                        import "shl" shl
-                        orcall code shl(escape,len)
-                        #len
-                        ss vlc_len_dest
-                        setcall vlc_len_dest vlc_tables_intra((value_get),(VLC_len),last,level,run)
-                        add len escape_len
-
-                        set vlc_code_dest# code
-                        set vlc_len_dest# len
-                    endif
-                endif
-
-                inc level
-            endwhile
-            inc run
-        endwhile
-        inc last
-    endwhile
-endfunction
--- /dev/null
+++ ovideo-1/src/media/mpeg_interframe.oc
@@ -0,0 +1,140 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+#?_VOP
+function me_analyze()
+    #at the moment, only P_VOP analyzation is supported
+    return (P_VOP)
+endfunction
+
+const compare=0
+const copy=1
+
+#mode: INTRA=0 or SKIP=1
+function mpeg_compare_block(sd mb_x,sd mb_y)
+    sd y_current
+    sd y_prev
+    sd u_current
+    sd u_prev
+    sd v_current
+    sd v_prev
+
+    import "mpeg_input_y" mpeg_input_y
+    import "mpeg_input_u" mpeg_input_u
+    import "mpeg_input_v" mpeg_input_v
+    setcall y_current mpeg_input_y((value_get))
+    setcall y_prev mpeg_input_y((value_get_prev))
+    setcall u_current mpeg_input_u((value_get))
+    setcall u_prev mpeg_input_u((value_get_prev))
+    setcall v_current mpeg_input_v((value_get))
+    setcall v_prev mpeg_input_v((value_get_prev))
+
+    import "mpeg_input_lumstride" mpeg_input_lumstride
+    import "mpeg_input_cromstride" mpeg_input_cromstride
+    sd lumstride
+    sd cromstride
+    setcall lumstride mpeg_input_lumstride((value_get))
+    setcall cromstride mpeg_input_cromstride((value_get))
+
+    sd mode
+    setcall mode mpeg_block_iteration_compare(y_current,y_prev,u_current,u_prev,v_current,v_prev,lumstride,cromstride,mb_x,mb_y)
+    if mode=(INTRA)
+        return (INTRA)
+    endif
+
+    call mpeg_block_iteration_copy(y_current,y_prev,u_current,u_prev,v_current,v_prev,lumstride,cromstride,mb_x,mb_y)
+    return (SKIP)
+endfunction
+
+#mode
+function mpeg_block_iteration_compare(sd y_current,sd y_prev,sd u_current,sd u_prev,sd v_current,sd v_prev,sd lumstride,sd cromstride,sd mb_x,sd mb_y)
+    sd mode
+    setcall mode mpeg_block_iteration((compare),y_current,y_prev,lumstride,mb_x,mb_y,16)
+    if mode=(INTRA)
+        return (INTRA)
+    endif
+    setcall mode mpeg_block_iteration((compare),u_current,u_prev,cromstride,mb_x,mb_y,8)
+    if mode=(INTRA)
+        return (INTRA)
+    endif
+    setcall mode mpeg_block_iteration((compare),v_current,v_prev,cromstride,mb_x,mb_y,8)
+    if mode=(INTRA)
+        return (INTRA)
+    endif
+    return (SKIP)
+endfunction
+
+function mpeg_block_iteration_copy(sd y_current,sd y_prev,sd u_current,sd u_prev,sd v_current,sd v_prev,sd lumstride,sd cromstride,sd mb_x,sd mb_y)
+    call mpeg_block_iteration((copy),y_current,y_prev,lumstride,mb_x,mb_y,16)
+    call mpeg_block_iteration((copy),u_current,u_prev,cromstride,mb_x,mb_y,8)
+    call mpeg_block_iteration((copy),v_current,v_prev,cromstride,mb_x,mb_y,8)
+endfunction
+
+#mode: INTRA or SKIP
+function mpeg_block_iteration(sd action,ss current,ss prev,sd stride,sd x,sd y,sd compareunit)
+    mult y stride
+    mult y compareunit
+
+    mult x compareunit
+
+    add current y
+    add current x
+    add prev y
+    add prev x
+
+    sd group_tol_index=0
+
+    sd current_rowstart
+    sd prev_rowstart
+    set current_rowstart current
+    set prev_rowstart prev
+
+    import "mpeg_single_tolerance" mpeg_single_tolerance
+    sd single_tolerance
+    setcall single_tolerance mpeg_single_tolerance((value_get))
+    import "mpeg_group_tolerance" mpeg_group_tolerance
+    sd group_tolerance
+    setcall group_tolerance mpeg_group_tolerance((value_get))
+
+    sd j=0
+    while j!=compareunit
+        sd i=0
+        set current current_rowstart
+        set prev prev_rowstart
+        while i!=compareunit
+            if action=(compare)
+                sd dif
+                set dif current#
+                sub dif prev#
+
+                if dif!=0
+                    if dif<0
+                        mult dif -1
+                    endif
+                    if dif>single_tolerance
+                        inc group_tol_index
+                        if group_tol_index>group_tolerance
+                            return (INTRA)
+                        endif
+                    endif
+                endif
+            else
+            #if action==(copy)
+                set current# prev#
+            endelse
+
+            inc current
+            inc prev
+            inc i
+        endwhile
+        add current_rowstart stride
+        add prev_rowstart stride
+        inc j
+    endwhile
+
+    return (SKIP)
+endfunction
+
--- ovideo-1.orig/src/media/mpeg_interframe.s
+++ /dev/null
@@ -1,140 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-#?_VOP
-function me_analyze()
-    #at the moment, only P_VOP analyzation is supported
-    return (P_VOP)
-endfunction
-
-const compare=0
-const copy=1
-
-#mode: INTRA=0 or SKIP=1
-function mpeg_compare_block(sd mb_x,sd mb_y)
-    sd y_current
-    sd y_prev
-    sd u_current
-    sd u_prev
-    sd v_current
-    sd v_prev
-
-    import "mpeg_input_y" mpeg_input_y
-    import "mpeg_input_u" mpeg_input_u
-    import "mpeg_input_v" mpeg_input_v
-    setcall y_current mpeg_input_y((value_get))
-    setcall y_prev mpeg_input_y((value_get_prev))
-    setcall u_current mpeg_input_u((value_get))
-    setcall u_prev mpeg_input_u((value_get_prev))
-    setcall v_current mpeg_input_v((value_get))
-    setcall v_prev mpeg_input_v((value_get_prev))
-
-    import "mpeg_input_lumstride" mpeg_input_lumstride
-    import "mpeg_input_cromstride" mpeg_input_cromstride
-    sd lumstride
-    sd cromstride
-    setcall lumstride mpeg_input_lumstride((value_get))
-    setcall cromstride mpeg_input_cromstride((value_get))
-
-    sd mode
-    setcall mode mpeg_block_iteration_compare(y_current,y_prev,u_current,u_prev,v_current,v_prev,lumstride,cromstride,mb_x,mb_y)
-    if mode==(INTRA)
-        return (INTRA)
-    endif
-
-    call mpeg_block_iteration_copy(y_current,y_prev,u_current,u_prev,v_current,v_prev,lumstride,cromstride,mb_x,mb_y)
-    return (SKIP)
-endfunction
-
-#mode
-function mpeg_block_iteration_compare(sd y_current,sd y_prev,sd u_current,sd u_prev,sd v_current,sd v_prev,sd lumstride,sd cromstride,sd mb_x,sd mb_y)
-    sd mode
-    setcall mode mpeg_block_iteration((compare),y_current,y_prev,lumstride,mb_x,mb_y,16)
-    if mode==(INTRA)
-        return (INTRA)
-    endif
-    setcall mode mpeg_block_iteration((compare),u_current,u_prev,cromstride,mb_x,mb_y,8)
-    if mode==(INTRA)
-        return (INTRA)
-    endif
-    setcall mode mpeg_block_iteration((compare),v_current,v_prev,cromstride,mb_x,mb_y,8)
-    if mode==(INTRA)
-        return (INTRA)
-    endif
-    return (SKIP)
-endfunction
-
-function mpeg_block_iteration_copy(sd y_current,sd y_prev,sd u_current,sd u_prev,sd v_current,sd v_prev,sd lumstride,sd cromstride,sd mb_x,sd mb_y)
-    call mpeg_block_iteration((copy),y_current,y_prev,lumstride,mb_x,mb_y,16)
-    call mpeg_block_iteration((copy),u_current,u_prev,cromstride,mb_x,mb_y,8)
-    call mpeg_block_iteration((copy),v_current,v_prev,cromstride,mb_x,mb_y,8)
-endfunction
-
-#mode: INTRA or SKIP
-function mpeg_block_iteration(sd action,ss current,ss prev,sd stride,sd x,sd y,sd compareunit)
-    mult y stride
-    mult y compareunit
-
-    mult x compareunit
-
-    add current y
-    add current x
-    add prev y
-    add prev x
-
-    sd group_tol_index=0
-
-    sd current_rowstart
-    sd prev_rowstart
-    set current_rowstart current
-    set prev_rowstart prev
-
-    import "mpeg_single_tolerance" mpeg_single_tolerance
-    sd single_tolerance
-    setcall single_tolerance mpeg_single_tolerance((value_get))
-    import "mpeg_group_tolerance" mpeg_group_tolerance
-    sd group_tolerance
-    setcall group_tolerance mpeg_group_tolerance((value_get))
-
-    sd j=0
-    while j!=compareunit
-        sd i=0
-        set current current_rowstart
-        set prev prev_rowstart
-        while i!=compareunit
-            if action==(compare)
-                sd dif
-                set dif current#
-                sub dif prev#
-
-                if dif!=0
-                    if dif<0
-                        mult dif -1
-                    endif
-                    if dif>single_tolerance
-                        inc group_tol_index
-                        if group_tol_index>group_tolerance
-                            return (INTRA)
-                        endif
-                    endif
-                endif
-            else
-            #if action==(copy)
-                set current# prev#
-            endelse
-
-            inc current
-            inc prev
-            inc i
-        endwhile
-        add current_rowstart stride
-        add prev_rowstart stride
-        inc j
-    endwhile
-
-    return (SKIP)
-endfunction
-
--- /dev/null
+++ ovideo-1/src/media/mpeg_pred.oc
@@ -0,0 +1,642 @@
+format elfobj
+
+include "../_include/include.h"
+
+const zig_zag=0
+const horizontal=1
+#const vertical=2
+
+#cbp
+function mpeg_mb_prediction(sd x,sd y,sd mb_width,sd qcoeff,sd acpred_direction)
+    sd s=0
+    char predictors_data#6*8*int16
+    data predictors^predictors_data
+
+    #sd scaler=default_scaler
+
+    sd qcoeff_cursor
+    set qcoeff_cursor qcoeff
+    sd predictors_cursor
+    set predictors_cursor predictors
+
+    sd mbpos
+    set mbpos y
+    mult mbpos mb_width
+    add mbpos x
+
+    sd j=0
+    while j<6
+        call mpeg_predict_acdc(x,mb_width,mbpos,j,predictors_cursor,acpred_direction)
+
+        #XVID_VOP_HQACPRED
+        addcall s calc_acdc_bits(acpred_direction,mbpos,j,qcoeff_cursor,predictors_cursor)
+
+        add qcoeff_cursor (64*int16)
+        add predictors_cursor (8*int16)
+        inc j
+    endwhile
+
+    set j 0
+    sd ac_pred_dir
+    set ac_pred_dir acpred_direction
+    if s<=0
+        #don't predict
+        while j<6
+            set ac_pred_dir# 0
+            add ac_pred_dir 4
+            inc j
+        endwhile
+    else
+    #apply acdc
+        set qcoeff_cursor qcoeff
+        set predictors_cursor predictors
+        while j<6
+            call mpeg_apply_acdc(qcoeff_cursor,predictors_cursor,ac_pred_dir)
+
+            add qcoeff_cursor (64*int16)
+            add predictors_cursor (8*int16)
+            add ac_pred_dir 4
+            inc j
+        endwhile
+    endelse
+
+    sd cbp
+    setcall cbp mpeg_calc_cbp(qcoeff)
+    return cbp
+endfunction
+
+const mb_pred_values=0
+const mb_mode=1
+
+const MBPRED_SIZE=15
+const mbpred_block_size=MBPRED_SIZE*int16
+const pred_values_size=6*mbpred_block_size
+function macro_blocks_core(sd action,sd mbpos,sd sector,sd item)
+    data mem#1
+
+    data mb_width#1
+    data mb_height#1
+
+    data pred_values_size#1
+    data modes_size#1
+
+    import "memalloc" memalloc
+    importx "_free" free
+    import "mpeg_image_w" mpeg_image_w
+    import "mpeg_image_h" mpeg_image_h
+    import "multiple_of_nr" multiple_of_nr
+
+	if action=(value_set)
+    #bool
+        setcall mb_width mpeg_image_w()
+        setcall mb_height mpeg_image_h()
+        setcall mb_width multiple_of_nr(mb_width,16)
+        setcall mb_height multiple_of_nr(mb_height,16)
+        div mb_width 16
+        div mb_height 16
+
+        sd size
+        sd blocks
+        set blocks mb_width
+        mult blocks mb_height
+
+        #pred values
+        set pred_values_size (pred_values_size)
+        mult pred_values_size blocks
+
+        #modes
+        set modes_size 4
+        mult modes_size blocks
+
+        set size pred_values_size
+        add size modes_size
+
+        setcall mem memalloc(size)
+        if mem=0
+            return 0
+        endif
+        return 1
+	endif
+	if action=(value_unset)
+        call free(mem)
+	else
+    #if action==(value_get)
+    #pointer
+        #go to item
+        sd block
+        set block mem
+        if item>(mb_pred_values)
+            add block pred_values_size
+        endif
+
+        #set mbpos and sector
+        if item=(mb_pred_values)
+            mult mbpos (pred_values_size)
+            mult sector (mbpred_block_size)
+        elseif item=(mb_mode)
+            mult mbpos 4
+        endelseif
+
+        #get pointer
+        add block mbpos
+        add block sector
+        return block
+	endelse
+endfunction
+
+function macro_blocks(sd action,sd mbpos,sd sector)
+    sd value
+    setcall value macro_blocks_core(action,mbpos,sector,(mb_pred_values))
+    return value
+endfunction
+
+function macro_blocks_mode(sd action,sd mbpos,sd value)
+    sd mode
+    setcall mode macro_blocks_core((value_get),mbpos,0,(mb_mode))
+    if action=(value_set)
+        set mode# value
+    else
+        return mode#
+    endelse
+endfunction
+
+function mpeg_predict_acdc(sd x,sd mb_width,sd mbpos,sd block,sd predictors,sd acpred_direction)
+    #sd left_quant=DEFAULT_QUANT
+    #sd top_quant=DEFAULT_QUANT
+
+    #int16
+    char default_acdc_values={1024,1024/0x100}
+    char *={0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0}
+    char *={0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0}
+
+    sd p_left^default_acdc_values
+    sd p_top^default_acdc_values
+    sd p_diag^default_acdc_values
+
+    sd index
+    #set index mbpos
+
+    #data acpred_directions_data#6
+    #sd acpred_directions^acpred_directions_data
+    #sd value
+    #set value block
+    #mult value 4
+    #add acpred_directions value
+
+    sd left=0
+    sd top=0
+    sd diag=0
+
+    import "array_get_int16" array_get_int16
+
+    sd mode
+
+    sd condition=0
+    #left,top and diag macroblocks
+    #left
+    if x!=0
+        if mbpos>=1
+            set condition 1
+        endif
+    endif
+    if condition=1
+        set index mbpos
+        dec index
+        setcall mode macro_blocks_mode((value_get),index)
+        if mode=(INTRA)
+            setcall left macro_blocks((value_get),index,0)
+        endif
+    endif
+    #top
+    if mbpos>=mb_width
+        set index mbpos
+        sub index mb_width
+        setcall mode macro_blocks_mode((value_get),index)
+        if mode=(INTRA)
+            setcall top macro_blocks((value_get),index,0)
+        endif
+    endif
+    #diag
+    set condition 0
+    if x!=0
+        set index mb_width
+        inc index
+        if mbpos>=index
+            set condition 1
+        endif
+    endif
+    if condition=1
+        set index mbpos
+        sub index mb_width
+        dec index
+        setcall mode macro_blocks_mode((value_get),index)
+        if mode=(INTRA)
+            setcall diag macro_blocks((value_get),index,0)
+        endif
+    endif
+
+    #pLeft, pTop, pDiag blocks
+    sd current
+    setcall current macro_blocks((value_get),mbpos,0)
+    if block=0
+        if left!=0
+            set p_left left
+            add p_left (mbpred_block_size)
+        endif
+        if top!=0
+            set p_top top
+            add p_top (mbpred_block_size*2)
+        endif
+        if diag!=0
+            set p_diag diag
+            add p_diag (mbpred_block_size*3)
+        endif
+    elseif block=1
+        set p_left current
+        #set left_quant
+        if top!=0
+            set p_top top
+            add p_top (mbpred_block_size*3)
+            set p_diag top
+            add p_diag (mbpred_block_size*2)
+        endif
+    elseif block=2
+        if left!=0
+            set p_left left
+            add p_left (mbpred_block_size*3)
+            set p_diag left
+            add p_diag (mbpred_block_size)
+        endif
+        set p_top current
+    elseif block=3
+        set p_left current
+        add p_left (mbpred_block_size*2)
+        set p_top current
+        add p_top (mbpred_block_size)
+        set p_diag current
+    elseif block=4
+        if left!=0
+            set p_left left
+            add p_left (mbpred_block_size*4)
+        endif
+        if top!=0
+            set p_top top
+            add p_top (mbpred_block_size*4)
+        endif
+        if diag!=0
+            set p_diag diag
+            add p_diag (mbpred_block_size*4)
+        endif
+    elseif block=5
+        if left!=0
+            set p_left left
+            add p_left (mbpred_block_size*5)
+        endif
+        if top!=0
+            set p_top top
+            add p_top (mbpred_block_size*5)
+        endif
+        if diag!=0
+            set p_diag diag
+            add p_diag (mbpred_block_size*5)
+        endif
+    endelseif
+    #determine ac prediction direction & ac/dc predictor place rescaled ac/dc
+    #predictions into predictors[] for later use
+    import "mb_div" mb_div
+    import "array_set_word_off" array_set_word_off
+    import "array_set_int" array_set_int
+    sd value
+    sd i=1
+    sd condition1
+    setcall condition1 array_get_int16(p_left,0)
+    subcall condition1 array_get_int16(p_diag,0)
+    if condition1<0
+        mult condition1 -1
+    endif
+    sd condition2
+    setcall condition2 array_get_int16(p_diag,0)
+    subcall condition2 array_get_int16(p_top,0)
+    if condition2<0
+        mult condition2 -1
+    endif
+    if condition1<condition2
+        #vertical
+        call array_set_int(acpred_direction,block,1)
+        setcall value array_get_int16(p_top,0)
+        setcall value mb_div(value,(default_scaler))
+        call array_set_word_off(predictors,value,0)
+        while i<8
+            setcall value array_get_int16(p_top,i)
+            setcall value mb_rescale(value)
+            call array_set_word_off(predictors,value,i)
+            inc i
+        endwhile
+    else
+        #horizontal
+        call array_set_int(acpred_direction,block,2)
+        setcall value array_get_int16(p_left,0)
+        setcall value mb_div(value,(default_scaler))
+        call array_set_word_off(predictors,value,0)
+        while i<8
+            set value i
+            add value 7
+            setcall value array_get_int16(p_left,value)
+            setcall value mb_rescale(value)
+            call array_set_word_off(predictors,value,i)
+            inc i
+        endwhile
+    endelse
+endfunction
+
+function mb_rescale(sd coef)
+    sd x
+	if coef!=0
+        mult coef (DEFAULT_QUANT)
+        setcall x mb_div(coef,(DEFAULT_QUANT))
+        return x
+	endif
+        return 0
+endfunction
+
+#################calc_acdc_bits
+#return S
+function calc_acdc_bits(sd acpred_direction,sd mbpos,sd sector,sd qcoeff,sd predictors)
+    import "array_get_int" array_get_int
+    sd direction
+    setcall direction array_get_int(acpred_direction,sector)
+    sd pred_values
+    setcall pred_values macro_blocks((value_get),mbpos,sector)
+    #store current coeffs to pred_values[] for future prediction
+    sd value
+    setcall value array_get_int16(qcoeff,0)
+    mult value (default_scaler)
+    setcall value clip_value(value,-2048,2047)
+    call array_set_word_off(pred_values,value,0)
+    sd ind
+    sd i=1
+    while i<8
+        setcall value array_get_int16(qcoeff,i)
+        call array_set_word_off(pred_values,value,i)
+        #
+        set value i
+        mult value 8
+        setcall value array_get_int16(qcoeff,value)
+        set ind i
+        add ind 7
+        call array_set_word_off(pred_values,value,ind)
+        inc i
+    endwhile
+    #dc prediction
+    setcall value array_get_int16(qcoeff,0)
+    subcall value array_get_int16(predictors,0)
+    call array_set_word_off(qcoeff,value,0)
+    #calc cost before ac prediction
+
+    sd z2
+    setcall z2 coef_intra_calc(qcoeff,(zig_zag))
+
+    char tmp#8*int16
+    data temp^tmp
+    set i 1
+    #apply ac prediction & calc cost
+    if direction=1
+        while i<8
+            setcall value array_get_int16(qcoeff,i)
+            call array_set_word_off(temp,value,i)
+
+            setcall value array_get_int16(qcoeff,i)
+            subcall value array_get_int16(predictors,i)
+            call array_set_word_off(qcoeff,value,i)
+
+            setcall value array_get_int16(qcoeff,i)
+            call array_set_word_off(predictors,value,i)
+
+            inc i
+        endwhile
+    else
+    #acpred_direction == 2
+        while i<8
+            set value i
+            mult value 8
+            setcall value array_get_int16(qcoeff,value)
+            call array_set_word_off(temp,value,i)
+
+            set ind i
+            mult ind 8
+
+            setcall value array_get_int16(qcoeff,ind)
+            subcall value array_get_int16(predictors,i)
+            call array_set_word_off(qcoeff,value,ind)
+
+            setcall value array_get_int16(qcoeff,ind)
+            call array_set_word_off(predictors,value,i)
+
+            inc i
+        endwhile
+    endelse
+
+    sd z1
+    setcall z1 coef_intra_calc(qcoeff,direction)
+
+    set i 1
+    #undo prediction
+    if direction=1
+        while i<8
+            setcall value array_get_int16(temp,i)
+            call array_set_word_off(qcoeff,value,i)
+            inc i
+        endwhile
+    else
+    #acpred_direction == 2
+        while i<8
+            setcall value array_get_int16(temp,i)
+            set ind i
+            mult ind 8
+            call array_set_word_off(qcoeff,value,ind)
+            inc i
+        endwhile
+    endelse
+
+    sub z2 z1
+    return z2
+endfunction
+
+function clip_value(sd value,sd min,sd max)
+	if value<min
+        return min
+	endif
+	if value>max
+        return max
+	endif
+    return value
+endfunction
+
+function coef_intra_calc(sd qcoeff,sd index)
+    sd scan_table
+    setcall scan_table mpeg_scan_tables(index)
+    sd bits=0
+    sd i=1
+    sd run=0
+    sd level=0
+    while level=0
+        setcall level array_get_int(scan_table,i)
+        inc i
+        setcall level array_get_int16(qcoeff,level)
+        if level=0
+            if i=64
+                #empty block
+                return 0
+            endif
+            inc run
+        endif
+    endwhile
+    sd prev_level
+    set prev_level level
+    sd prev_run
+    set prev_run run
+    set run 0
+    sd abs_level
+    ss p_len
+    sd len
+    while i<64
+        setcall level array_get_int(scan_table,i)
+        inc i
+        setcall level array_get_int16(qcoeff,level)
+        if level!=0
+            set abs_level prev_level
+            if abs_level<0
+                mult abs_level -1
+            endif
+            if abs_level>=64
+                set abs_level 0
+            endif
+            import "vlc_tables_intra" vlc_tables_intra
+            setcall p_len vlc_tables_intra((value_get),(VLC_len),0,abs_level,prev_run)
+            set len p_len#
+            if len!=128
+                add bits len
+            else
+                add bits 30
+            endelse
+            set prev_level level
+            set prev_run run
+            set run 0
+        else
+            inc run
+        endelse
+    endwhile
+
+    set abs_level prev_level
+    if abs_level<0
+        mult abs_level -1
+    endif
+    if abs_level>=64
+        set abs_level 0
+    endif
+    setcall p_len vlc_tables_intra((value_get),(VLC_len),1,abs_level,prev_run)
+    set len p_len#
+    if len!=128
+        add bits len
+    else
+        add bits 30
+    endelse
+    return bits
+endfunction
+
+function mpeg_scan_tables(sd table)
+    #uint16
+    data zig_zag_data={0,   1,  8, 16,  9,  2,  3, 10}
+    data *           ={17, 24, 32, 25, 18, 11,  4,  5}
+    data *           ={12, 19, 26, 33, 40, 48, 41, 34}
+    data *           ={27, 20, 13,  6,  7, 14, 21, 28}
+    data *           ={35, 42, 49, 56, 57, 50, 43, 36}
+    data *           ={29, 22, 15, 23, 30, 37, 44, 51}
+    data *           ={58, 59, 52, 45, 38, 31, 39, 46}
+    data *           ={53, 60, 61, 54, 47, 55, 62, 63}
+
+    data horizontal_data={0,   1,  2,  3,  8,  9, 16, 17}
+    data *              ={10, 11,  4,  5,  6,  7, 15, 14}
+    data *              ={13, 12, 19, 18, 24, 25, 32, 33}
+    data *              ={26, 27, 20, 21, 22, 23, 28, 29}
+    data *              ={30, 31, 34, 35, 40, 41, 48, 49}
+    data *              ={42, 43, 36, 37, 38, 39, 44, 45}
+    data *              ={46, 47, 50, 51, 56, 57, 58, 59}
+    data *              ={52, 53, 54, 55, 60, 61, 62, 63}
+
+    data   vertical_data={0,   8, 16, 24,  1,  9,  2, 10}
+    data *              ={17, 25, 32, 40, 48, 56, 57, 49}
+    data *              ={41, 33, 26, 18,  3, 11,  4, 12}
+    data *              ={19, 27, 34, 42, 50, 58, 35, 43}
+    data *              ={51, 59, 20, 28,  5, 13,  6, 14}
+    data *              ={21, 29, 36, 44, 52, 60, 37, 45}
+    data *              ={53, 61, 22, 30,  7, 15, 23, 31}
+    data *              ={38, 46, 54, 62, 39, 47, 55, 63}
+
+    data zig_zag^zig_zag_data
+    data horizontal^horizontal_data
+    data vertical^vertical_data
+	if table=(zig_zag)
+        return zig_zag
+	endif
+	if table=(horizontal)
+        return horizontal
+	endif
+        #vertical
+        return vertical
+endfunction
+
+######
+function mpeg_apply_acdc(sd qcoeff,sd predictors,sd direction)
+    sd i=1
+    sd value
+    if direction#=1
+        while i<8
+            setcall value array_get_int16(predictors,i)
+            call array_set_word_off(qcoeff,value,i)
+            inc i
+        endwhile
+    else
+        while i<8
+            setcall value array_get_int16(predictors,i)
+            sd ind
+            set ind i
+            mult ind 8
+            call array_set_word_off(qcoeff,value,ind)
+            inc i
+        endwhile
+    endelse
+endfunction
+
+###
+#cbp
+function mpeg_calc_cbp(sd qcoeff)
+    sd cbp=0
+    sd i=0
+    while i<6
+        add cbp cbp
+
+        sd value
+        setcall value array_get_int16(qcoeff,1)
+        if value!=0
+            inc cbp
+        else
+            sd qcoeff_cursor
+            set qcoeff_cursor qcoeff
+            sd iter=64/2-1
+            while iter!=0
+                add qcoeff_cursor 4
+                dec iter
+
+                if qcoeff_cursor#!=0
+                    inc cbp
+                    set iter 0
+                endif
+            endwhile
+        endelse
+
+        add qcoeff (64*int16)
+        inc i
+    endwhile
+    return cbp
+endfunction
--- ovideo-1.orig/src/media/mpeg_pred.s
+++ /dev/null
@@ -1,641 +0,0 @@
-format elfobj
-
-include "../_include/include.h"
-
-const zig_zag=0
-const horizontal=1
-#const vertical=2
-
-#cbp
-function mpeg_mb_prediction(sd x,sd y,sd mb_width,sd qcoeff,sd acpred_direction)
-    sd s=0
-    char predictors_data#6*8*int16
-    data predictors^predictors_data
-
-    #sd scaler=default_scaler
-
-    sd qcoeff_cursor
-    set qcoeff_cursor qcoeff
-    sd predictors_cursor
-    set predictors_cursor predictors
-
-    sd mbpos
-    set mbpos y
-    mult mbpos mb_width
-    add mbpos x
-
-    sd j=0
-    while j<6
-        call mpeg_predict_acdc(x,mb_width,mbpos,j,predictors_cursor,acpred_direction)
-
-        #XVID_VOP_HQACPRED
-        addcall s calc_acdc_bits(acpred_direction,mbpos,j,qcoeff_cursor,predictors_cursor)
-
-        add qcoeff_cursor (64*int16)
-        add predictors_cursor (8*int16)
-        inc j
-    endwhile
-
-    set j 0
-    sd ac_pred_dir
-    set ac_pred_dir acpred_direction
-    if s<=0
-        #don't predict
-        while j<6
-            set ac_pred_dir# 0
-            add ac_pred_dir 4
-            inc j
-        endwhile
-    else
-    #apply acdc
-        set qcoeff_cursor qcoeff
-        set predictors_cursor predictors
-        while j<6
-            call mpeg_apply_acdc(qcoeff_cursor,predictors_cursor,ac_pred_dir)
-
-            add qcoeff_cursor (64*int16)
-            add predictors_cursor (8*int16)
-            add ac_pred_dir 4
-            inc j
-        endwhile
-    endelse
-
-    sd cbp
-    setcall cbp mpeg_calc_cbp(qcoeff)
-    return cbp
-endfunction
-
-const mb_pred_values=0
-const mb_mode=1
-
-const MBPRED_SIZE=15
-const mbpred_block_size=MBPRED_SIZE*int16
-const pred_values_size=6*mbpred_block_size
-function macro_blocks_core(sd action,sd mbpos,sd sector,sd item)
-    data mem#1
-
-    data mb_width#1
-    data mb_height#1
-
-    data pred_values_size#1
-    data modes_size#1
-
-    import "memalloc" memalloc
-    importx "_free" free
-    import "mpeg_image_w" mpeg_image_w
-    import "mpeg_image_h" mpeg_image_h
-    import "multiple_of_nr" multiple_of_nr
-
-    if action==(value_set)
-    #bool
-        setcall mb_width mpeg_image_w()
-        setcall mb_height mpeg_image_h()
-        setcall mb_width multiple_of_nr(mb_width,16)
-        setcall mb_height multiple_of_nr(mb_height,16)
-        div mb_width 16
-        div mb_height 16
-
-        sd size
-        sd blocks
-        set blocks mb_width
-        mult blocks mb_height
-
-        #pred values
-        set pred_values_size (pred_values_size)
-        mult pred_values_size blocks
-
-        #modes
-        set modes_size 4
-        mult modes_size blocks
-
-        set size pred_values_size
-        add size modes_size
-
-        setcall mem memalloc(size)
-        if mem==0
-            return 0
-        endif
-        return 1
-    elseif action==(value_unset)
-        call free(mem)
-    else
-    #if action==(value_get)
-    #pointer
-        #go to item
-        sd block
-        set block mem
-        if item>(mb_pred_values)
-            add block pred_values_size
-        endif
-
-        #set mbpos and sector
-        if item==(mb_pred_values)
-            mult mbpos (pred_values_size)
-            mult sector (mbpred_block_size)
-        elseif item==(mb_mode)
-            mult mbpos 4
-        endelseif
-
-        #get pointer
-        add block mbpos
-        add block sector
-        return block
-    endelse
-endfunction
-
-function macro_blocks(sd action,sd mbpos,sd sector)
-    sd value
-    setcall value macro_blocks_core(action,mbpos,sector,(mb_pred_values))
-    return value
-endfunction
-
-function macro_blocks_mode(sd action,sd mbpos,sd value)
-    sd mode
-    setcall mode macro_blocks_core((value_get),mbpos,0,(mb_mode))
-    if action==(value_set)
-        set mode# value
-    else
-        return mode#
-    endelse
-endfunction
-
-function mpeg_predict_acdc(sd x,sd mb_width,sd mbpos,sd block,sd predictors,sd acpred_direction)
-    #sd left_quant=DEFAULT_QUANT
-    #sd top_quant=DEFAULT_QUANT
-
-    #int16
-    char default_acdc_values={1024,1024/0x100}
-    char *={0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0}
-    char *={0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0}
-
-    sd p_left^default_acdc_values
-    sd p_top^default_acdc_values
-    sd p_diag^default_acdc_values
-
-    sd index
-    #set index mbpos
-
-    #data acpred_directions_data#6
-    #sd acpred_directions^acpred_directions_data
-    #sd value
-    #set value block
-    #mult value 4
-    #add acpred_directions value
-
-    sd left=0
-    sd top=0
-    sd diag=0
-
-    import "array_get_int16" array_get_int16
-
-    sd mode
-
-    sd condition=0
-    #left,top and diag macroblocks
-    #left
-    if x!=0
-        if mbpos>=1
-            set condition 1
-        endif
-    endif
-    if condition==1
-        set index mbpos
-        dec index
-        setcall mode macro_blocks_mode((value_get),index)
-        if mode==(INTRA)
-            setcall left macro_blocks((value_get),index,0)
-        endif
-    endif
-    #top
-    if mbpos>=mb_width
-        set index mbpos
-        sub index mb_width
-        setcall mode macro_blocks_mode((value_get),index)
-        if mode==(INTRA)
-            setcall top macro_blocks((value_get),index,0)
-        endif
-    endif
-    #diag
-    set condition 0
-    if x!=0
-        set index mb_width
-        inc index
-        if mbpos>=index
-            set condition 1
-        endif
-    endif
-    if condition==1
-        set index mbpos
-        sub index mb_width
-        dec index
-        setcall mode macro_blocks_mode((value_get),index)
-        if mode==(INTRA)
-            setcall diag macro_blocks((value_get),index,0)
-        endif
-    endif
-
-    #pLeft, pTop, pDiag blocks
-    sd current
-    setcall current macro_blocks((value_get),mbpos,0)
-    if block==0
-        if left!=0
-            set p_left left
-            add p_left (mbpred_block_size)
-        endif
-        if top!=0
-            set p_top top
-            add p_top (mbpred_block_size*2)
-        endif
-        if diag!=0
-            set p_diag diag
-            add p_diag (mbpred_block_size*3)
-        endif
-    elseif block==1
-        set p_left current
-        #set left_quant
-        if top!=0
-            set p_top top
-            add p_top (mbpred_block_size*3)
-            set p_diag top
-            add p_diag (mbpred_block_size*2)
-        endif
-    elseif block==2
-        if left!=0
-            set p_left left
-            add p_left (mbpred_block_size*3)
-            set p_diag left
-            add p_diag (mbpred_block_size)
-        endif
-        set p_top current
-    elseif block==3
-        set p_left current
-        add p_left (mbpred_block_size*2)
-        set p_top current
-        add p_top (mbpred_block_size)
-        set p_diag current
-    elseif block==4
-        if left!=0
-            set p_left left
-            add p_left (mbpred_block_size*4)
-        endif
-        if top!=0
-            set p_top top
-            add p_top (mbpred_block_size*4)
-        endif
-        if diag!=0
-            set p_diag diag
-            add p_diag (mbpred_block_size*4)
-        endif
-    elseif block==5
-        if left!=0
-            set p_left left
-            add p_left (mbpred_block_size*5)
-        endif
-        if top!=0
-            set p_top top
-            add p_top (mbpred_block_size*5)
-        endif
-        if diag!=0
-            set p_diag diag
-            add p_diag (mbpred_block_size*5)
-        endif
-    endelseif
-    #determine ac prediction direction & ac/dc predictor place rescaled ac/dc
-    #predictions into predictors[] for later use
-    import "mb_div" mb_div
-    import "array_set_word_off" array_set_word_off
-    import "array_set_int" array_set_int
-    sd value
-    sd i=1
-    sd condition1
-    setcall condition1 array_get_int16(p_left,0)
-    subcall condition1 array_get_int16(p_diag,0)
-    if condition1<0
-        mult condition1 -1
-    endif
-    sd condition2
-    setcall condition2 array_get_int16(p_diag,0)
-    subcall condition2 array_get_int16(p_top,0)
-    if condition2<0
-        mult condition2 -1
-    endif
-    if condition1<condition2
-        #vertical
-        call array_set_int(acpred_direction,block,1)
-        setcall value array_get_int16(p_top,0)
-        setcall value mb_div(value,(default_scaler))
-        call array_set_word_off(predictors,value,0)
-        while i<8
-            setcall value array_get_int16(p_top,i)
-            setcall value mb_rescale(value)
-            call array_set_word_off(predictors,value,i)
-            inc i
-        endwhile
-    else
-        #horizontal
-        call array_set_int(acpred_direction,block,2)
-        setcall value array_get_int16(p_left,0)
-        setcall value mb_div(value,(default_scaler))
-        call array_set_word_off(predictors,value,0)
-        while i<8
-            set value i
-            add value 7
-            setcall value array_get_int16(p_left,value)
-            setcall value mb_rescale(value)
-            call array_set_word_off(predictors,value,i)
-            inc i
-        endwhile
-    endelse
-endfunction
-
-function mb_rescale(sd coef)
-    sd x
-    if coef!=0
-        mult coef (DEFAULT_QUANT)
-        setcall x mb_div(coef,(DEFAULT_QUANT))
-        return x
-    else
-        return 0
-    endelse
-endfunction
-
-#################calc_acdc_bits
-#return S
-function calc_acdc_bits(sd acpred_direction,sd mbpos,sd sector,sd qcoeff,sd predictors)
-    import "array_get_int" array_get_int
-    sd direction
-    setcall direction array_get_int(acpred_direction,sector)
-    sd pred_values
-    setcall pred_values macro_blocks((value_get),mbpos,sector)
-    #store current coeffs to pred_values[] for future prediction
-    sd value
-    setcall value array_get_int16(qcoeff,0)
-    mult value (default_scaler)
-    setcall value clip_value(value,-2048,2047)
-    call array_set_word_off(pred_values,value,0)
-    sd ind
-    sd i=1
-    while i<8
-        setcall value array_get_int16(qcoeff,i)
-        call array_set_word_off(pred_values,value,i)
-        #
-        set value i
-        mult value 8
-        setcall value array_get_int16(qcoeff,value)
-        set ind i
-        add ind 7
-        call array_set_word_off(pred_values,value,ind)
-        inc i
-    endwhile
-    #dc prediction
-    setcall value array_get_int16(qcoeff,0)
-    subcall value array_get_int16(predictors,0)
-    call array_set_word_off(qcoeff,value,0)
-    #calc cost before ac prediction
-
-    sd z2
-    setcall z2 coef_intra_calc(qcoeff,(zig_zag))
-
-    char tmp#8*int16
-    data temp^tmp
-    set i 1
-    #apply ac prediction & calc cost
-    if direction==1
-        while i<8
-            setcall value array_get_int16(qcoeff,i)
-            call array_set_word_off(temp,value,i)
-
-            setcall value array_get_int16(qcoeff,i)
-            subcall value array_get_int16(predictors,i)
-            call array_set_word_off(qcoeff,value,i)
-
-            setcall value array_get_int16(qcoeff,i)
-            call array_set_word_off(predictors,value,i)
-
-            inc i
-        endwhile
-    else
-    #acpred_direction == 2
-        while i<8
-            set value i
-            mult value 8
-            setcall value array_get_int16(qcoeff,value)
-            call array_set_word_off(temp,value,i)
-
-            set ind i
-            mult ind 8
-
-            setcall value array_get_int16(qcoeff,ind)
-            subcall value array_get_int16(predictors,i)
-            call array_set_word_off(qcoeff,value,ind)
-
-            setcall value array_get_int16(qcoeff,ind)
-            call array_set_word_off(predictors,value,i)
-
-            inc i
-        endwhile
-    endelse
-
-    sd z1
-    setcall z1 coef_intra_calc(qcoeff,direction)
-
-    set i 1
-    #undo prediction
-    if direction==1
-        while i<8
-            setcall value array_get_int16(temp,i)
-            call array_set_word_off(qcoeff,value,i)
-            inc i
-        endwhile
-    else
-    #acpred_direction == 2
-        while i<8
-            setcall value array_get_int16(temp,i)
-            set ind i
-            mult ind 8
-            call array_set_word_off(qcoeff,value,ind)
-            inc i
-        endwhile
-    endelse
-
-    sub z2 z1
-    return z2
-endfunction
-
-function clip_value(sd value,sd min,sd max)
-    if value<min
-        return min
-    elseif value>max
-        return max
-    endelseif
-    return value
-endfunction
-
-function coef_intra_calc(sd qcoeff,sd index)
-    sd scan_table
-    setcall scan_table mpeg_scan_tables(index)
-    sd bits=0
-    sd i=1
-    sd run=0
-    sd level=0
-    while level==0
-        setcall level array_get_int(scan_table,i)
-        inc i
-        setcall level array_get_int16(qcoeff,level)
-        if level==0
-            if i==64
-                #empty block
-                return 0
-            endif
-            inc run
-        endif
-    endwhile
-    sd prev_level
-    set prev_level level
-    sd prev_run
-    set prev_run run
-    set run 0
-    sd abs_level
-    ss p_len
-    sd len
-    while i<64
-        setcall level array_get_int(scan_table,i)
-        inc i
-        setcall level array_get_int16(qcoeff,level)
-        if level!=0
-            set abs_level prev_level
-            if abs_level<0
-                mult abs_level -1
-            endif
-            if abs_level>=64
-                set abs_level 0
-            endif
-            import "vlc_tables_intra" vlc_tables_intra
-            setcall p_len vlc_tables_intra((value_get),(VLC_len),0,abs_level,prev_run)
-            set len p_len#
-            if len!=128
-                add bits len
-            else
-                add bits 30
-            endelse
-            set prev_level level
-            set prev_run run
-            set run 0
-        else
-            inc run
-        endelse
-    endwhile
-
-    set abs_level prev_level
-    if abs_level<0
-        mult abs_level -1
-    endif
-    if abs_level>=64
-        set abs_level 0
-    endif
-    setcall p_len vlc_tables_intra((value_get),(VLC_len),1,abs_level,prev_run)
-    set len p_len#
-    if len!=128
-        add bits len
-    else
-        add bits 30
-    endelse
-    return bits
-endfunction
-
-function mpeg_scan_tables(sd table)
-    #uint16
-    data zig_zag_data={0,   1,  8, 16,  9,  2,  3, 10}
-    data *           ={17, 24, 32, 25, 18, 11,  4,  5}
-    data *           ={12, 19, 26, 33, 40, 48, 41, 34}
-    data *           ={27, 20, 13,  6,  7, 14, 21, 28}
-    data *           ={35, 42, 49, 56, 57, 50, 43, 36}
-    data *           ={29, 22, 15, 23, 30, 37, 44, 51}
-    data *           ={58, 59, 52, 45, 38, 31, 39, 46}
-    data *           ={53, 60, 61, 54, 47, 55, 62, 63}
-
-    data horizontal_data={0,   1,  2,  3,  8,  9, 16, 17}
-    data *              ={10, 11,  4,  5,  6,  7, 15, 14}
-    data *              ={13, 12, 19, 18, 24, 25, 32, 33}
-    data *              ={26, 27, 20, 21, 22, 23, 28, 29}
-    data *              ={30, 31, 34, 35, 40, 41, 48, 49}
-    data *              ={42, 43, 36, 37, 38, 39, 44, 45}
-    data *              ={46, 47, 50, 51, 56, 57, 58, 59}
-    data *              ={52, 53, 54, 55, 60, 61, 62, 63}
-
-    data   vertical_data={0,   8, 16, 24,  1,  9,  2, 10}
-    data *              ={17, 25, 32, 40, 48, 56, 57, 49}
-    data *              ={41, 33, 26, 18,  3, 11,  4, 12}
-    data *              ={19, 27, 34, 42, 50, 58, 35, 43}
-    data *              ={51, 59, 20, 28,  5, 13,  6, 14}
-    data *              ={21, 29, 36, 44, 52, 60, 37, 45}
-    data *              ={53, 61, 22, 30,  7, 15, 23, 31}
-    data *              ={38, 46, 54, 62, 39, 47, 55, 63}
-
-    data zig_zag^zig_zag_data
-    data horizontal^horizontal_data
-    data vertical^vertical_data
-    if table==(zig_zag)
-        return zig_zag
-    elseif table==(horizontal)
-        return horizontal
-    else
-        #vertical
-        return vertical
-    endelse
-endfunction
-
-######
-function mpeg_apply_acdc(sd qcoeff,sd predictors,sd direction)
-    sd i=1
-    sd value
-    if direction#==1
-        while i<8
-            setcall value array_get_int16(predictors,i)
-            call array_set_word_off(qcoeff,value,i)
-            inc i
-        endwhile
-    else
-        while i<8
-            setcall value array_get_int16(predictors,i)
-            sd ind
-            set ind i
-            mult ind 8
-            call array_set_word_off(qcoeff,value,ind)
-            inc i
-        endwhile
-    endelse
-endfunction
-
-###
-#cbp
-function mpeg_calc_cbp(sd qcoeff)
-    sd cbp=0
-    sd i=0
-    while i<6
-        add cbp cbp
-
-        sd value
-        setcall value array_get_int16(qcoeff,1)
-        if value!=0
-            inc cbp
-        else
-            sd qcoeff_cursor
-            set qcoeff_cursor qcoeff
-            sd iter=64/2-1
-            while iter!=0
-                add qcoeff_cursor 4
-                dec iter
-
-                if qcoeff_cursor#!=0
-                    inc cbp
-                    set iter 0
-                endif
-            endwhile
-        endelse
-
-        add qcoeff (64*int16)
-        inc i
-    endwhile
-    return cbp
-endfunction
--- /dev/null
+++ ovideo-1/src/mem/alloc.oc
@@ -0,0 +1,146 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+importx "_realloc" realloc
+
+import "strerrno" strerrno
+
+#0/mem
+function memrealloc(sd block,sd size)
+    sd newblock
+    SetCall newblock realloc(block,size)
+    If newblock=0
+            char newmem="Realloc failed with error: "
+            str pnewmem^newmem
+            call strerrno(pnewmem)
+    EndIf
+    return newblock
+EndFunction
+
+#0/mem
+function memalloc(sd size)
+    sd mem
+    setcall mem memrealloc(0,size)
+    return mem
+endfunction
+
+#################
+
+#err
+Function memoryrealloc(data ptrpointer,data size)
+        Data newpointer#1
+        Data oldpointer#1
+        Set oldpointer ptrpointer#
+
+        SetCall newpointer memrealloc(oldpointer,size)
+        If newpointer=0
+                Return (error)
+        EndIf
+        Set ptrpointer# newpointer
+        Data noerr=noerror
+        Return noerr
+EndFunction
+
+#err
+function memoryalloc(data size,data memptr)
+        Data err#1
+        Data null=NULL
+        Set memptr# null
+        SetCall err memoryrealloc(memptr,size)
+        Return err
+endfunction
+
+import "slen" slen
+#e
+#s1+s1+\+...sn+1
+function allocsum_numbers_null(sd strings,sd numbers_total,sd ptrmem)
+    data sizetoalloc#1
+    data z=0
+    data dword=4
+
+    set sizetoalloc z
+    while strings#!=z
+        addcall sizetoalloc slen(strings#)
+        add strings dword
+    endwhile
+
+    if numbers_total!=z
+        data nr=sign_int_null
+        while numbers_total!=z
+            add sizetoalloc nr
+            dec numbers_total
+        endwhile
+    endif
+
+    inc sizetoalloc
+
+    data err#1
+    setcall err memoryalloc(sizetoalloc,ptrmem)
+    return err
+endfunction
+
+#e
+function allocsum_null(sd strings,sd ptrmem)
+    data null=0
+    sd err
+    setcall err allocsum_numbers_null(strings,null,ptrmem)
+    return err
+endfunction
+
+#################################################################
+
+function alloc_block(sd action,sd mem,sd size,sd append,sd append_size)
+    sd err
+	if action=(value_set)
+    #0/block
+        sd value=0
+        sd p_value^value
+        setcall err memoryrealloc(p_value,0)
+        if err!=(noerror)
+            return 0
+        endif
+        return value
+	endif
+	if action=(value_unset)
+        importx "_free" free
+        call free(mem)
+	else
+    #if action==(value_append)
+    #new mem pointer,or old one
+        import "multiple_of_nr" multiple_of_nr
+        sd page=0x1000
+        sd currentsize
+        if size=0
+            set currentsize 0
+        else
+            setcall currentsize multiple_of_nr(size,page)
+        endelse
+
+        sd newsize
+        set newsize size
+        add newsize append_size
+        if newsize>currentsize
+            setcall newsize multiple_of_nr(newsize,page)
+            sd p_mem^mem
+
+            setcall err memoryrealloc(p_mem,newsize)
+            if err!=(noerror)
+                return 0
+            endif
+        endif
+
+        if append!=0
+            sd cursor
+            set cursor mem
+            add cursor size
+
+            import "cpymem" cpymem
+            call cpymem(cursor,append,append_size)
+        endif
+
+        return mem
+	endelse
+endfunction
--- ovideo-1.orig/src/mem/alloc.s
+++ /dev/null
@@ -1,145 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-importx "_realloc" realloc
-
-import "strerrno" strerrno
-
-#0/mem
-function memrealloc(sd block,sd size)
-    sd newblock
-    SetCall newblock realloc(block,size)
-    If newblock==0
-            char newmem="Realloc failed with error: "
-            str pnewmem^newmem
-            call strerrno(pnewmem)
-    EndIf
-    return newblock
-EndFunction
-
-#0/mem
-function memalloc(sd size)
-    sd mem
-    setcall mem memrealloc(0,size)
-    return mem
-endfunction
-
-#################
-
-#err
-Function memoryrealloc(data ptrpointer,data size)
-        Data newpointer#1
-        Data oldpointer#1
-        Set oldpointer ptrpointer#
-
-        SetCall newpointer memrealloc(oldpointer,size)
-        If newpointer==0
-                Return (error)
-        EndIf
-        Set ptrpointer# newpointer
-        Data noerr=noerror
-        Return noerr
-EndFunction
-
-#err
-function memoryalloc(data size,data memptr)
-        Data err#1
-        Data null=NULL
-        Set memptr# null
-        SetCall err memoryrealloc(memptr,size)
-        Return err
-endfunction
-
-import "slen" slen
-#e
-#s1+s1+\+...sn+1
-function allocsum_numbers_null(sd strings,sd numbers_total,sd ptrmem)
-    data sizetoalloc#1
-    data z=0
-    data dword=4
-
-    set sizetoalloc z
-    while strings#!=z
-        addcall sizetoalloc slen(strings#)
-        add strings dword
-    endwhile
-
-    if numbers_total!=z
-        data nr=sign_int_null
-        while numbers_total!=z
-            add sizetoalloc nr
-            dec numbers_total
-        endwhile
-    endif
-
-    inc sizetoalloc
-
-    data err#1
-    setcall err memoryalloc(sizetoalloc,ptrmem)
-    return err
-endfunction
-
-#e
-function allocsum_null(sd strings,sd ptrmem)
-    data null=0
-    sd err
-    setcall err allocsum_numbers_null(strings,null,ptrmem)
-    return err
-endfunction
-
-#################################################################
-
-function alloc_block(sd action,sd mem,sd size,sd append,sd append_size)
-    sd err
-    if action==(value_set)
-    #0/block
-        sd value=0
-        sd p_value^value
-        setcall err memoryrealloc(p_value,0)
-        if err!=(noerror)
-            return 0
-        endif
-        return value
-    elseif action==(value_unset)
-        importx "_free" free
-        call free(mem)
-    else
-    #if action==(value_append)
-    #new mem pointer,or old one
-        import "multiple_of_nr" multiple_of_nr
-        sd page=0x1000
-        sd currentsize
-        if size==0
-            set currentsize 0
-        else
-            setcall currentsize multiple_of_nr(size,page)
-        endelse
-
-        sd newsize
-        set newsize size
-        add newsize append_size
-        if newsize>currentsize
-            setcall newsize multiple_of_nr(newsize,page)
-            sd p_mem^mem
-
-            setcall err memoryrealloc(p_mem,newsize)
-            if err!=(noerror)
-                return 0
-            endif
-        endif
-
-        if append!=0
-            sd cursor
-            set cursor mem
-            add cursor size
-
-            import "cpymem" cpymem
-            call cpymem(cursor,append,append_size)
-        endif
-
-        return mem
-    endelse
-endfunction
--- /dev/null
+++ ovideo-1/src/mem/op.oc
@@ -0,0 +1,231 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+
+##set
+
+#void
+function setmem(str pointer,data size,char value)
+    str end#1
+    set end pointer
+    add end size
+    while pointer!=end
+            set pointer# value
+            inc pointer
+    endwhile
+endfunction
+
+#void
+function setmemzero(str pointer,data size)
+    char zero=0
+    call setmem(pointer,size,zero)
+endfunction
+
+
+##cursors
+
+import "content_size" content_size
+#advance the content/size by value
+Function move_cursors(sd str_sz,data nr)
+    sd mem
+    sd size
+
+    sd ptrdata^mem
+
+    call content_size(str_sz,ptrdata)
+
+    Add mem nr
+
+    #backward advance
+    #take nr if nr>0 or -nr if nr<0
+    Data zero=0
+    If nr<zero
+        import "neg" neg
+        SetCall nr neg(nr)
+    EndIf
+
+    Sub size nr
+    call content_size(ptrdata,str_sz)
+EndFunction
+
+
+##cpy
+
+#void
+function cpymem(ss dest,ss src,sd size)
+    data zero=0
+    while size!=zero
+            set dest# src#
+            inc dest
+            inc src
+            dec size
+    endwhile
+endfunction
+
+#e
+function cpymem_safesrc_advance(sd dest,sd src_sz,sd size)
+    sd src
+    sd sz
+    sd srcsz^src
+    call content_size(src_sz,srcsz)
+    if sz<size
+        import "texter" texter
+        str cpysafesrcerr="Error with the length of some data."
+        call texter(cpysafesrcerr)
+        return cpysafesrcerr
+    endif
+    call cpymem(dest,src,size)
+    call move_cursors(src_sz,size)
+    data noerr=noerror
+    return noerr
+endfunction
+
+#e
+function get_mem_int_advance(sd dest,sd src_sz)
+    sd er
+    data a=4
+    setcall er cpymem_safesrc_advance(dest,src_sz,a)
+    return er
+endfunction
+#e
+function get_str_advance(sd dest,sd size,sd src_sz)
+    sd src
+    sd sz
+    sd srcsz^src
+    call content_size(src_sz,srcsz)
+    sd len
+    import "slen_s" slen_s
+    sd er
+    setcall er slen_s(src,sz,#len)
+    if er!=(noerror)
+        return er
+    endif
+    inc len
+    if len>size
+        str szerr="String size is wrong"
+        call texter(szerr)
+        return szerr
+    endif
+    call cpymem(dest,src,len)
+    call move_cursors(src_sz,len)
+    return (noerror)
+endfunction
+
+##cmp
+
+#0 equal -1 not
+Function cmpmem(str m1,str m2,data size)
+        Data zero=0
+
+        Data equal=equalCompare
+        Data notequal=differentCompare
+
+        char c1#1
+        char c2#1
+        While size!=zero
+                Set c1 m1#
+                Set c2 m2#
+                If c1!=c2
+                        Return notequal
+                EndIf
+                Inc m1
+                Inc m2
+                Dec size
+        EndWhile
+        Return equal
+EndFunction
+
+#0 equal -1 not
+function cmpmem_s(str m1,data s1,str m2,data s2)
+    data different=differentCompare
+    if s1!=s2
+        return different
+    endif
+    data result#1
+    setcall result cmpmem(m1,m2,s1)
+    return result
+endfunction
+
+import "slen" slen
+
+#0 equal -1 not
+function cmpstr(ss s1,ss s2)
+    sd size1
+    sd size2
+    setcall size1 slen(s1)
+    setcall size2 slen(s2)
+    sd result
+    setcall result cmpmem_s(s1,size1,s2,size2)
+    return result
+endfunction
+
+##valinmem
+
+#return the size of the value, if the delim is found the size counts until there
+Function valinmemsens(str content,data size,char delim) #,data sens
+        Data length#1
+        Set length size
+        char byte#1
+        Data zero=0
+
+        If size=zero
+                Return size
+        EndIf
+        #Data backward=BACKWARD
+        #If sens==backward
+                Dec content
+        #EndIf
+        Set byte content#
+        While byte!=delim
+                #If sens!=backward
+                #        Inc content
+                #Else
+                        Dec content
+                #EndElse
+                Dec size
+                If size=zero
+                        Set byte delim
+                Else
+                        Set byte content#
+                EndElse
+        EndWhile
+
+        Sub length size
+        Return length
+EndFunction
+
+
+
+
+##start end , center go
+
+import "strinmem_portions_advance" strinmem_portions_advance
+import "memtostrFw_data" memtostrFw_data
+#v/e
+function find_start_end_forward_center_data(sd mem,sd size,ss start,ss end,sd forward,sd data)
+    data z=0
+    data true=1
+    data false=0
+    sd err
+    sd noerr=noerror
+    while size!=z
+        sd str_sz^mem
+        call strinmem_portions_advance(str_sz,start,false,true)
+        if size!=z
+            sd center
+            sd sz
+            set center mem
+            setcall sz strinmem_portions_advance(str_sz,end,true,true)
+            setcall err memtostrFw_data(center,sz,forward,data)
+            if err!=noerr
+                return err
+            endif
+        endif
+    endwhile
+endfunction
+
+
+
--- ovideo-1.orig/src/mem/op.s
+++ /dev/null
@@ -1,231 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-
-##set
-
-#void
-function setmem(str pointer,data size,char value)
-    str end#1
-    set end pointer
-    add end size
-    while pointer!=end
-            set pointer# value
-            inc pointer
-    endwhile
-endfunction
-
-#void
-function setmemzero(str pointer,data size)
-    char zero=0
-    call setmem(pointer,size,zero)
-endfunction
-
-
-##cursors
-
-import "content_size" content_size
-#advance the content/size by value
-Function move_cursors(sd str_sz,data nr)
-    sd mem
-    sd size
-
-    sd ptrdata^mem
-
-    call content_size(str_sz,ptrdata)
-
-    Add mem nr
-
-    #backward advance
-    #take nr if nr>0 or -nr if nr<0
-    Data zero=0
-    If nr<zero
-        import "neg" neg
-        SetCall nr neg(nr)
-    EndIf
-
-    Sub size nr
-    call content_size(ptrdata,str_sz)
-EndFunction
-
-
-##cpy
-
-#void
-function cpymem(ss dest,ss src,sd size)
-    data zero=0
-    while size!=zero
-            set dest# src#
-            inc dest
-            inc src
-            dec size
-    endwhile
-endfunction
-
-#e
-function cpymem_safesrc_advance(sd dest,sd src_sz,sd size)
-    sd src
-    sd sz
-    sd srcsz^src
-    call content_size(src_sz,srcsz)
-    if sz<size
-        import "texter" texter
-        str cpysafesrcerr="Error with the length of some data."
-        call texter(cpysafesrcerr)
-        return cpysafesrcerr
-    endif
-    call cpymem(dest,src,size)
-    call move_cursors(src_sz,size)
-    data noerr=noerror
-    return noerr
-endfunction
-
-#e
-function get_mem_int_advance(sd dest,sd src_sz)
-    sd er
-    data a=4
-    setcall er cpymem_safesrc_advance(dest,src_sz,a)
-    return er
-endfunction
-#e
-function get_str_advance(sd dest,sd size,sd src_sz)
-    sd src
-    sd sz
-    sd srcsz^src
-    call content_size(src_sz,srcsz)
-    sd len
-    import "slen_s" slen_s
-    sd er
-    setcall er slen_s(src,sz,#len)
-    if er!=(noerror)
-        return er
-    endif
-    inc len
-    if len>size
-        str szerr="String size is wrong"
-        call texter(szerr)
-        return szerr
-    endif
-    call cpymem(dest,src,len)
-    call move_cursors(src_sz,len)
-    return (noerror)
-endfunction
-
-##cmp
-
-#0 equal -1 not
-Function cmpmem(str m1,str m2,data size)
-        Data zero=0
-
-        Data equal=equalCompare
-        Data notequal=differentCompare
-
-        char c1#1
-        char c2#1
-        While size!=zero
-                Set c1 m1#
-                Set c2 m2#
-                If c1!=c2
-                        Return notequal
-                EndIf
-                Inc m1
-                Inc m2
-                Dec size
-        EndWhile
-        Return equal
-EndFunction
-
-#0 equal -1 not
-function cmpmem_s(str m1,data s1,str m2,data s2)
-    data different=differentCompare
-    if s1!=s2
-        return different
-    endif
-    data result#1
-    setcall result cmpmem(m1,m2,s1)
-    return result
-endfunction
-
-import "slen" slen
-
-#0 equal -1 not
-function cmpstr(ss s1,ss s2)
-    sd size1
-    sd size2
-    setcall size1 slen(s1)
-    setcall size2 slen(s2)
-    sd result
-    setcall result cmpmem_s(s1,size1,s2,size2)
-    return result
-endfunction
-
-##valinmem
-
-#return the size of the value, if the delim is found the size counts until there
-Function valinmemsens(str content,data size,char delim) #,data sens
-        Data length#1
-        Set length size
-        char byte#1
-        Data zero=0
-
-        If size==zero
-                Return size
-        EndIf
-        #Data backward=BACKWARD
-        #If sens==backward
-                Dec content
-        #EndIf
-        Set byte content#
-        While byte!=delim
-                #If sens!=backward
-                #        Inc content
-                #Else
-                        Dec content
-                #EndElse
-                Dec size
-                If size==zero
-                        Set byte delim
-                Else
-                        Set byte content#
-                EndElse
-        EndWhile
-
-        Sub length size
-        Return length
-EndFunction
-
-
-
-
-##start end , center go
-
-import "strinmem_portions_advance" strinmem_portions_advance
-import "memtostrFw_data" memtostrFw_data
-#v/e
-function find_start_end_forward_center_data(sd mem,sd size,ss start,ss end,sd forward,sd data)
-    data z=0
-    data true=1
-    data false=0
-    sd err
-    sd noerr=noerror
-    while size!=z
-        sd str_sz^mem
-        call strinmem_portions_advance(str_sz,start,false,true)
-        if size!=z
-            sd center
-            sd sz
-            set center mem
-            setcall sz strinmem_portions_advance(str_sz,end,true,true)
-            setcall err memtostrFw_data(center,sz,forward,data)
-            if err!=noerr
-                return err
-            endif
-        endif
-    endwhile
-endfunction
-
-
-
--- /dev/null
+++ ovideo-1/src/net/net-base.oc
@@ -0,0 +1,112 @@
+
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+importx "_soup_session_sync_new" soup_session_sync_new
+importx "_soup_message_new" soup_message_new
+importx "_soup_session_send_message" soup_session_send_message
+
+#bool
+function getSessionMessageBody(sv sessionMsg,sv ptrmsgmem,sv ptrmsgsize)
+#    GObject             parent
+#All the fields in the GObject structure are private to the GObject implementation and should never be accessed directly.
+#		GTypeInstance g_type_instance; ulong at windows
+#		guint ref_count;
+#		GData *qdata;
+#    const char         *method;
+
+#    guint               status_code;
+#    char               *reason_phrase;
+
+#    SoupMessageBody    *request_body;
+#    SoupMessageHeaders *request_headers;
+
+#    SoupMessageBody    *response_body;
+#    SoupMessageHeaders *response_headers;
+
+	add sessionMsg (:+DWORD+:+          :)
+	sd status
+	set status sessionMsg#d^
+	if status!=(HTTP_STATUS_OK)
+		call uri_err(status)
+		return (FALSE)
+	endif
+	add sessionMsg (DWORD+:+:+:)
+
+	sd response_body#1
+	set response_body sessionMsg#
+
+#        const char *data;
+#        goffset     length;  (gint64)
+	set ptrmsgmem# response_body#
+	data valuesize=4
+	data greatest=8
+	add response_body valuesize
+	import "system_variables_alignment_pad" system_variables_alignment_pad
+	addcall response_body system_variables_alignment_pad(valuesize,greatest)
+	set ptrmsgsize# response_body#
+	return (TRUE)
+endfunction
+
+importx "_soup_session_queue_message" soup_session_queue_message
+
+function uri_queue_content(ss uri,sd callback)
+	sd session
+	setcall session soup_session_sync_new()
+	sd msg
+	setcall msg soup_message_new("GET",uri)
+	call soup_session_queue_message(session,msg,callback,(NULL)) #msg transfer full
+	#If after returning from this callback the message has not been requeued, msg will be unreffed.
+	#call g_object_unref(session)
+	#assertion `queue->head == NULL' failed
+endfunction
+
+function uri_err(sd status)
+	vstr urierr="Error status code: "
+	import "strvaluedisp" strvaluedisp
+	data su=stringUinteger
+	call strvaluedisp(urierr,status,su)
+endfunction
+
+importx "_g_object_unref" g_object_unref
+#msg
+function uri_get_content(ss uri)
+	sd session
+	setcall session soup_session_sync_new()
+
+	vstr get="GET"
+	sd msg
+	setcall msg soup_message_new(get,uri)
+
+	#setcall status soup_session_send_message(session,msg)
+	call soup_session_send_message(session,msg)
+
+	call g_object_unref(session)
+	return msg
+endfunction
+
+
+#void
+function uri_get_content_forward_data(ss uri,sv forward,sd data)
+#                        forward body and size
+	sd msg
+	sd body
+	sd size
+
+	setcall msg uri_get_content(uri)
+	sd bool
+	setcall bool getSessionMessageBody(msg,#body,#size)
+	if bool=(TRUE)
+		call forward(body,size,data)
+	endif
+	call g_object_unref(msg)
+endfunction
+
+#function uri_get_content_forward(ss uri,sd forward)
+#    data null=0
+#    call uri_get_content_forward_data(uri,forward,null)
+#endfunction
--- ovideo-1.orig/src/net/net-base.s
+++ /dev/null
@@ -1,112 +0,0 @@
-
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-importx "_soup_session_sync_new" soup_session_sync_new
-importx "_soup_message_new" soup_message_new
-importx "_soup_session_send_message" soup_session_send_message
-
-#bool
-function getSessionMessageBody(sv sessionMsg,sv ptrmsgmem,sv ptrmsgsize)
-#    GObject             parent
-#All the fields in the GObject structure are private to the GObject implementation and should never be accessed directly.
-#		GTypeInstance g_type_instance; ulong at windows
-#		guint ref_count;
-#		GData *qdata;
-#    const char         *method;
-
-#    guint               status_code;
-#    char               *reason_phrase;
-
-#    SoupMessageBody    *request_body;
-#    SoupMessageHeaders *request_headers;
-
-#    SoupMessageBody    *response_body;
-#    SoupMessageHeaders *response_headers;
-
-	add sessionMsg (:+DWORD+:+          :)
-	sd status
-	set status sessionMsg#d^
-	if status!=(HTTP_STATUS_OK)
-		call uri_err(status)
-		return (FALSE)
-	endif
-	add sessionMsg (DWORD+:+:+:)
-
-	sd response_body#1
-	set response_body sessionMsg#
-
-#        const char *data;
-#        goffset     length;  (gint64)
-	set ptrmsgmem# response_body#
-	data valuesize=4
-	data greatest=8
-	add response_body valuesize
-	import "system_variables_alignment_pad" system_variables_alignment_pad
-	addcall response_body system_variables_alignment_pad(valuesize,greatest)
-	set ptrmsgsize# response_body#
-	return (TRUE)
-endfunction
-
-importx "_soup_session_queue_message" soup_session_queue_message
-
-function uri_queue_content(ss uri,sd callback)
-	sd session
-	setcall session soup_session_sync_new()
-	sd msg
-	setcall msg soup_message_new("GET",uri)
-	call soup_session_queue_message(session,msg,callback,(NULL)) #msg transfer full
-	#If after returning from this callback the message has not been requeued, msg will be unreffed.
-	#call g_object_unref(session)
-	#assertion `queue->head == NULL' failed
-endfunction
-
-function uri_err(sd status)
-	vstr urierr="Error status code: "
-	import "strvaluedisp" strvaluedisp
-	data su=stringUinteger
-	call strvaluedisp(urierr,status,su)
-endfunction
-
-importx "_g_object_unref" g_object_unref
-#msg
-function uri_get_content(ss uri)
-	sd session
-	setcall session soup_session_sync_new()
-
-	vstr get="GET"
-	sd msg
-	setcall msg soup_message_new(get,uri)
-
-	#setcall status soup_session_send_message(session,msg)
-	call soup_session_send_message(session,msg)
-
-	call g_object_unref(session)
-	return msg
-endfunction
-
-
-#void
-function uri_get_content_forward_data(ss uri,sd forward,sd data)
-#                        forward body and size
-	sd msg
-	sd body
-	sd size
-
-	setcall msg uri_get_content(uri)
-	sd bool
-	setcall bool getSessionMessageBody(msg,#body,#size)
-	if bool==(TRUE)
-		call forward(body,size,data)
-	endif
-	call g_object_unref(msg)
-endfunction
-
-#function uri_get_content_forward(ss uri,sd forward)
-#    data null=0
-#    call uri_get_content_forward_data(uri,forward,null)
-#endfunction
--- /dev/null
+++ ovideo-1/src/obj/containers.oc
@@ -0,0 +1,559 @@
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+importx "_gtk_box_pack_start" gtk_box_pack_start
+
+#########box
+function boxpackstart(data box,data subwidget,data space,data padding)
+    call gtk_box_pack_start(box,subwidget,space,space,padding)
+endfunction
+function packstart(sd box,sd widget,sd space)
+    data null=NULL
+    call boxpackstart(box,widget,space,null)
+endfunction
+function packstart_default(sd box,sd widget)
+    data null=NULL
+    call packstart(box,widget,null)
+endfunction
+
+
+importx "_gtk_alignment_new" gtk_alignment_new
+##########alignment
+function alignmentfield(data container)
+    data gtkwidget#1
+    data null=NULL
+    data half=126*0x800000
+    setcall gtkwidget gtk_alignment_new(half,null,null,null)
+    call packstart(container,gtkwidget,null)
+    return gtkwidget
+endfunction
+
+
+
+import "mainwidget" mainwidget
+
+##########dialog
+importx "_gtk_widget_destroy" gtk_widget_destroy
+
+function non_modal_destroy(sd dialog,sd response_id,sv forward)
+    if forward!=0
+        call forward(response_id)
+    endif
+    call gtk_widget_destroy(dialog)
+endfunction
+
+#dialog
+function dialogfield_size_button_core(ss title,sd modal_flag,sv forward_init,sd width,sd height,sd button,sd bresponse)
+    importx "_gtk_dialog_new_with_buttons" gtk_dialog_new_with_buttons
+    sd window
+    setcall window mainwidget()
+
+    data end=0
+    sd dialog
+
+    sd flags=GTK_DIALOG_DESTROY_WITH_PARENT
+    or flags modal_flag
+    setcall dialog gtk_dialog_new_with_buttons(title,window,flags,button,bresponse,end)
+
+    importx "_gtk_window_set_default_size" gtk_window_set_default_size
+    call gtk_window_set_default_size(dialog,width,height)
+
+    importx "_gtk_dialog_get_content_area" gtk_dialog_get_content_area
+    sd vbox
+    setcall vbox gtk_dialog_get_content_area(dialog)
+    call forward_init(vbox,dialog)
+
+    importx "_gtk_widget_show_all" gtk_widget_show_all
+    call gtk_widget_show_all(dialog)
+
+    return dialog
+endfunction
+
+function dialog_handle(sd action,sd value)
+    data dialog#1
+    if action=(value_set)
+        set dialog value
+    else
+        return dialog
+    endelse
+endfunction
+
+#return: dialog(nonmodal case)
+function dialogfield_size_button(ss title,sd modal_flag,sd forward1,sv forward2,sd width,sd height,sd button,sd bresponse)
+    sd dialog
+    setcall dialog dialogfield_size_button_core(title,modal_flag,forward1,width,height,button,bresponse)
+    call dialog_handle((value_set),dialog)
+
+    if modal_flag=(GTK_DIALOG_MODAL)
+    #modal dialog
+        importx "_gtk_dialog_run" gtk_dialog_run
+        sd response
+        setcall response gtk_dialog_run(dialog)
+
+        if response=(GTK_RESPONSE_OK)
+            if forward2!=0
+                call forward2()
+            endif
+        endif
+        call gtk_widget_destroy(dialog)
+    else
+    #non-modal dialog
+        sd fn^non_modal_destroy
+        import "connect_signal_data" connect_signal_data
+        str resp="response"
+        call connect_signal_data(dialog,resp,fn,forward2)
+        return dialog
+    endelse
+endfunction
+
+#return: dialog(nonmodal case)
+function dialogfield_size(ss title,sd modal_flag,sd forward1,sd forward2,sd width,sd height)
+    str GTK_STOCK_OK="gtk-ok"
+    data responseok=GTK_RESPONSE_OK
+    sd dialog
+    setcall dialog dialogfield_size_button(title,modal_flag,forward1,forward2,width,height,GTK_STOCK_OK,responseok)
+    return dialog
+endfunction
+
+function dialogfield(ss title,sd modal_flag,sd forward1,sd forward2)
+    data default=-1
+    sd dialog
+    setcall dialog dialogfield_size(title,modal_flag,forward1,forward2,default,default)
+    return dialog
+endfunction
+#true to not propagate
+function dialogfield_modal_texter_expose(sd widget)
+	call dialogfield_modal_texter_drawtext((value_get),widget)
+	return (TRUE)
+endfunction
+import "cpymem" cpymem
+import "slen" slen
+#const modal_texter_draw_data_size=100
+function dialogfield_modal_texter_drawtext(sd procedure,sd text)
+	char text_data#22+modal_texter_mark+1
+	vstr strtext^text_data
+	if procedure=(value_set)
+	#this is not main thread
+		sd len
+		setcall len slen(text)
+		inc len
+		call cpymem(strtext,text,len)
+	elseif procedure=(value_get)
+	#this is main thread
+		import "draw_expose_text" draw_expose_text
+		call draw_expose_text(text,strtext)
+	else
+	#value_unset
+		set strtext# 0
+	endelse
+endfunction
+#
+const modal_texter_parentdialog_width=500
+#dialogfield_modal_texter
+data forward_init#1
+const p_forward_init^forward_init
+function dialogfield_modal_texter_init(sd vbox,sd dialog)
+    #Text
+    import "drawfield" drawfield
+    import "connect_signal" connect_signal
+    sd draw
+    setcall draw drawfield(vbox)
+    call dialogfield_modal_texter_drawtext((value_unset))
+    #old remark: it's not ok to access at the same time txt[modal_texter_draw_data_size] by threads but it's no problem
+    #import "setmemzero" setmemzero
+    #call setmemzero(txt,(modal_texter_draw_data_size))
+    call dialog_modal_texter_drawwidget((value_set),draw)
+    #
+    str expose="expose-event"
+    data exp^dialogfield_modal_texter_expose
+    call connect_signal(draw,expose,exp)
+    #
+    importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
+    call gtk_widget_set_size_request(draw,(modal_texter_parentdialog_width-20),40)
+
+    #call the main init
+    sd p%p_forward_init
+    if p#!=0
+        sv forward_init
+        set forward_init p#
+        call forward_init(vbox,dialog)
+    endif
+
+    #add the new texter
+    import "new_texter_modal" new_texter_modal
+    call new_texter_modal(vbox,dialog)
+endfunction
+function dialog_modal_texter_drawwidget(sd action,sd value)
+    data drawwidget#1
+    if action=(value_set)
+        set drawwidget value
+    else
+        return drawwidget
+    endelse
+endfunction
+function dialog_modal_texter_draw(ss text)
+#	sd widget
+#	setcall widget dialog_modal_texter_drawwidget((value_get))
+#	if widget!=0
+	call dialogfield_modal_texter_drawtext((value_set),text)
+	importx "_g_idle_add" g_idle_add
+	#the drawing commands must be called from the main thread or sometimes will crash
+	call g_idle_add(dialog_modal_texter_draw_main_thread,(void))
+#	endif
+endfunction
+#FALSE=stop timeout
+function dialog_modal_texter_draw_main_thread(sd *data)
+	sd widget
+	setcall widget dialog_modal_texter_drawwidget((value_get))
+	if widget!=0 #this,at audiovideo,can come later in main after g_thread_join/gtk_widget_destroy
+		import "widget_redraw" widget_redraw
+		importx "_gtk_widget_get_window" gtk_widget_get_window
+		call widget_redraw(widget)
+		sd window
+		setcall window gtk_widget_get_window(widget)
+		if window!=0
+			importx "_gdk_window_process_updates" gdk_window_process_updates
+			call gdk_window_process_updates(window,(FALSE))
+		endif
+	endif
+	return (FALSE)
+endfunction
+
+#void
+function dialogfield_modal_texter_core(ss title,sd forward_init,ss buttontext)
+    sd p%p_forward_init
+    set p# forward_init
+    data init^dialogfield_modal_texter_init
+    sd dialog
+    setcall dialog dialogfield_size_button_core(title,(GTK_DIALOG_MODAL),init,(modal_texter_parentdialog_width),-1,buttontext,(GTK_RESPONSE_CANCEL))
+    return dialog
+endfunction
+#void
+#function dialogfield_modal_texter(ss title,sd forward_init,ss buttontext)
+#    sd dialog
+#    setcall dialog dialogfield_modal_texter_core(title,forward_init,buttontext)
+#    call gtk_dialog_run(dialog)
+#    call gtk_widget_destroy(dialog)
+#endfunction
+function dialogfield_modal_texter_sync(ss title,sd forward_init,ss buttontext,sd global_flag,sd stop_flag)
+    sd dialog
+    setcall dialog dialogfield_modal_texter_core(title,forward_init,buttontext)
+    call gtk_dialog_run(dialog)
+    while global_flag#=1
+        import "sleepMs" sleepMs
+        set stop_flag# 1
+        call sleepMs(500)
+    endwhile
+    call gtk_widget_destroy(dialog)
+endfunction
+
+##########eventbox
+
+importx "_gtk_container_add" gtk_container_add
+import "container_add" container_add
+
+importx "_gtk_event_box_new" gtk_event_box_new
+function eventboxfield(sd box)
+    sd wid
+    setcall wid gtk_event_box_new()
+    call packstart_default(box,wid)
+    return wid
+endfunction
+function eventboxfield_cnt(sd box)
+    sd wid
+    setcall wid gtk_event_box_new()
+    call container_add(box,wid)
+    return wid
+endfunction
+
+##########file chooser
+#file/null
+function file_chooser_get_filename(sd dialog)
+    import "file_chooser_get_fname" file_chooser_get_fname
+    ss file
+    setcall file file_chooser_get_fname(dialog)
+    data z=0
+    if file=z
+        str er="Dialog file name representation error."
+        import "texter" texter
+        call texter(er)
+        return z
+    endif
+    return file
+endfunction
+
+#dialog
+function filechooserfield_core()
+    str open_file="Open File"
+    sd main
+    setcall main mainwidget()
+    data open=GTK_FILE_CHOOSER_ACTION_OPEN
+    str GTK_STOCK_CANCEL="gtk-cancel"
+    data responsecancel=GTK_RESPONSE_CANCEL
+    str GTK_STOCK_OPEN="gtk-open"
+    data null=0
+    importx "_gtk_file_chooser_dialog_new" gtk_file_chooser_dialog_new
+    sd dialog
+    setcall dialog gtk_file_chooser_dialog_new(open_file,main,open,GTK_STOCK_CANCEL,responsecancel,GTK_STOCK_OPEN,(GTK_RESPONSE_ACCEPT),null)
+    return dialog
+endfunction
+
+importx "_g_free" g_free
+
+#0/filename, must be freed
+function filechooserfield()
+    sd dialog
+    setcall dialog filechooserfield_core()
+    sd filename
+    setcall filename filechooserfield_dialog(dialog)
+    return filename
+endfunction
+
+function filechooserfield_dialog(sd dialog)
+    sd filename
+    set filename 0
+
+    sd resp
+    setcall resp gtk_dialog_run(dialog)
+    if resp=(GTK_RESPONSE_ACCEPT)
+        ss file
+        setcall file file_chooser_get_filename(dialog)
+        if file!=0
+            import "memrealloc" memrealloc
+            sd len
+            setcall len slen(file)
+            inc len
+            setcall filename memrealloc(0,len)
+            if filename=0
+                call g_free(file)
+                return filename
+            endif
+            call cpymem(filename,file,len)
+
+            call g_free(file)
+        endif
+    endif
+    call gtk_widget_destroy(dialog)
+    return filename
+endfunction
+
+function filechooserfield_forward(sv forward)
+    sd dialog
+    setcall dialog filechooserfield_core()
+    sd resp
+    setcall resp gtk_dialog_run(dialog)
+    if resp=(GTK_RESPONSE_ACCEPT)
+        ss file
+        setcall file file_chooser_get_filename(dialog)
+        if file!=0
+            call forward(file)
+            call g_free(file)
+        endif
+    endif
+    call gtk_widget_destroy(dialog)
+endfunction
+
+#fchooserbuttonfield
+function fchooserbuttonfield_open(sd container,ss dialogtext)
+    importx "_gtk_file_chooser_button_new" gtk_file_chooser_button_new
+    sd fchooser
+    setcall fchooser gtk_file_chooser_button_new(dialogtext,(GTK_FILE_CHOOSER_ACTION_OPEN))
+    call packstart(container,fchooser,(TRUE))
+    return fchooser
+endfunction
+
+#fchooserbuttonfield
+function fchooserbuttonfield_open_label(sd container,ss dialog_label_text)
+    sd hbox
+    setcall hbox hboxfield_label(container,dialog_label_text)
+    sd fchooser
+    setcall fchooser fchooserbuttonfield_open(hbox,dialog_label_text)
+    return fchooser
+endfunction
+
+##########frame
+function framefield(sd box,ss text)
+    importx "_gtk_frame_new" gtk_frame_new
+    sd frame
+    setcall frame gtk_frame_new(text)
+    if box!=0
+        call packstart_default(box,frame)
+    endif
+    return frame
+endfunction
+
+importx "_gtk_hbox_new" gtk_hbox_new
+##########hbox
+function hboxfield_prepare()
+    data gtkwidget#1
+    data null=0
+    setcall gtkwidget gtk_hbox_new(null,null)
+    return gtkwidget
+endfunction
+function hboxfield_pack_pad(data container,data padding)
+    data gtkwidget#1
+    setcall gtkwidget hboxfield_prepare()
+    data null=0
+    call boxpackstart(container,gtkwidget,null,padding)
+    return gtkwidget
+endfunction
+function hboxfield_cnt(data container)
+    data gtkwidget#1
+    setcall gtkwidget hboxfield_prepare()
+    call container_add(container,gtkwidget)
+    return gtkwidget
+endfunction
+
+#hbox
+function hboxfield_label(sd box,ss text)
+    sd hbox
+    setcall hbox hboxfield_cnt(box)
+    import "labelfield_left_default" labelfield_left_default
+    call labelfield_left_default(text,hbox)
+    return hbox
+endfunction
+
+
+##############scroll
+function scrollfield(sd container)
+    importx "_gtk_scrolled_window_new" gtk_scrolled_window_new
+    data null=0
+    sd scroll
+    setcall scroll gtk_scrolled_window_new(null,null)
+    call gtk_container_add(container,scroll)
+    return scroll
+endfunction
+
+
+
+
+
+importx "_gtk_table_new" gtk_table_new
+##########table
+function tablefield(sd bag,sd row,sd col)
+    sd widget
+    data false=0
+    setcall widget gtk_table_new(row,col,false)
+    call container_add(bag,widget)
+    return widget
+endfunction
+importx "_gtk_table_attach_defaults" gtk_table_attach_defaults
+function table_attach(sd table,sd cell,sd x,sd y)
+    sd next_x
+    sd next_y
+    set next_x x
+    set next_y y
+    inc next_x
+    inc next_y
+    call gtk_table_attach_defaults(table,cell,x,next_x,y,next_y)
+endfunction
+
+importx "_gtk_table_resize" gtk_table_resize
+importx "_gtk_table_get_size" gtk_table_get_size
+
+#returns the row pointer for use at the next row, allCol false case use only
+function table_add_row_allCol(sd table,sd row,sd allCol)
+    sd rows
+    sd columns
+    sd ptr_rows^rows
+    sd ptr_columns^columns
+
+    call gtk_table_get_size(table,ptr_rows,ptr_columns)
+    sd lastrow
+    set lastrow rows
+    inc rows
+    call gtk_table_resize(table,rows,columns)
+
+    data true=1
+    data false=0
+    data dword=4
+    data firstcol=1
+
+    sd c=0
+    sd col
+    if allCol=true
+        set col columns
+    else
+        set col firstcol
+    endelse
+    sd add
+    set add true
+    while add=true
+        if row#!=0
+            call gtk_table_attach_defaults(table,row#,c,col,lastrow,rows)
+        endif
+        add row dword
+        if col!=columns
+            inc c
+            inc col
+        else
+            set add false
+        endelse
+    endwhile
+    return row
+endfunction
+
+function table_add_row(sd table,sd row)
+    data true=1
+    sd ptr_row^row
+    call table_add_row_allCol(table,ptr_row,true)
+endfunction
+
+#returns the cells pointer that may points to the next block
+function table_add_cells(sd table,sd row,sd cells)
+    data false=0
+    sd i=0
+    while i!=row
+        setcall cells table_add_row_allCol(table,cells,false)
+        inc i
+    endwhile
+    return cells
+endfunction
+
+#first 3 arguments for tablefield, widgets arg has rows*cols child cell widgets
+function tablefield_cells(sd bag,sd row,sd col,sd cells)
+    sd widget
+    #0,but goes 1, then first row is lost
+    setcall widget tablefield(bag,0,col)
+    call table_add_cells(widget,row,cells)
+    return widget
+endfunction
+
+function tablefield_row(sd bag,sd col,sd cells)
+    sd widget
+    #0,but goes 1, then first row is lost
+    setcall widget tablefield(bag,0,col)
+    call table_add_row(widget,cells)
+    return widget
+endfunction
+
+
+
+
+
+#############vbox
+importx "_gtk_vbox_new" gtk_vbox_new
+#gtkwidget
+function vboxfield(data container)
+    data gtkwidget#1
+    data null=NULL
+
+    setcall gtkwidget gtk_vbox_new(null,null)
+
+    call gtk_container_add(container,gtkwidget)
+    return gtkwidget
+endfunction
+
+function vboxfield_pack(sd container)
+    data gtkwidget#1
+    data null=NULL
+
+    setcall gtkwidget gtk_vbox_new(null,null)
+
+    call packstart(container,gtkwidget,null)
+    return gtkwidget
+endfunction
--- ovideo-1.orig/src/obj/containers.s
+++ /dev/null
@@ -1,559 +0,0 @@
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-importx "_gtk_box_pack_start" gtk_box_pack_start
-
-#########box
-function boxpackstart(data box,data subwidget,data space,data padding)
-    call gtk_box_pack_start(box,subwidget,space,space,padding)
-endfunction
-function packstart(sd box,sd widget,sd space)
-    data null=NULL
-    call boxpackstart(box,widget,space,null)
-endfunction
-function packstart_default(sd box,sd widget)
-    data null=NULL
-    call packstart(box,widget,null)
-endfunction
-
-
-importx "_gtk_alignment_new" gtk_alignment_new
-##########alignment
-function alignmentfield(data container)
-    data gtkwidget#1
-    data null=NULL
-    data half=126*0x800000
-    setcall gtkwidget gtk_alignment_new(half,null,null,null)
-    call packstart(container,gtkwidget,null)
-    return gtkwidget
-endfunction
-
-
-
-import "mainwidget" mainwidget
-
-##########dialog
-importx "_gtk_widget_destroy" gtk_widget_destroy
-
-function non_modal_destroy(sd dialog,sd response_id,sd forward)
-    if forward!=0
-        call forward(response_id)
-    endif
-    call gtk_widget_destroy(dialog)
-endfunction
-
-#dialog
-function dialogfield_size_button_core(ss title,sd modal_flag,sd forward_init,sd width,sd height,sd button,sd bresponse)
-    importx "_gtk_dialog_new_with_buttons" gtk_dialog_new_with_buttons
-    sd window
-    setcall window mainwidget()
-
-    data end=0
-    sd dialog
-
-    sd flags=GTK_DIALOG_DESTROY_WITH_PARENT
-    or flags modal_flag
-    setcall dialog gtk_dialog_new_with_buttons(title,window,flags,button,bresponse,end)
-
-    importx "_gtk_window_set_default_size" gtk_window_set_default_size
-    call gtk_window_set_default_size(dialog,width,height)
-
-    importx "_gtk_dialog_get_content_area" gtk_dialog_get_content_area
-    sd vbox
-    setcall vbox gtk_dialog_get_content_area(dialog)
-    call forward_init(vbox,dialog)
-
-    importx "_gtk_widget_show_all" gtk_widget_show_all
-    call gtk_widget_show_all(dialog)
-
-    return dialog
-endfunction
-
-function dialog_handle(sd action,sd value)
-    data dialog#1
-    if action==(value_set)
-        set dialog value
-    else
-        return dialog
-    endelse
-endfunction
-
-#return: dialog(nonmodal case)
-function dialogfield_size_button(ss title,sd modal_flag,sd forward1,sd forward2,sd width,sd height,sd button,sd bresponse)
-    sd dialog
-    setcall dialog dialogfield_size_button_core(title,modal_flag,forward1,width,height,button,bresponse)
-    call dialog_handle((value_set),dialog)
-
-    if modal_flag==(GTK_DIALOG_MODAL)
-    #modal dialog
-        importx "_gtk_dialog_run" gtk_dialog_run
-        sd response
-        setcall response gtk_dialog_run(dialog)
-
-        if response==(GTK_RESPONSE_OK)
-            if forward2!=0
-                call forward2()
-            endif
-        endif
-        call gtk_widget_destroy(dialog)
-    else
-    #non-modal dialog
-        sd fn^non_modal_destroy
-        import "connect_signal_data" connect_signal_data
-        str resp="response"
-        call connect_signal_data(dialog,resp,fn,forward2)
-        return dialog
-    endelse
-endfunction
-
-#return: dialog(nonmodal case)
-function dialogfield_size(ss title,sd modal_flag,sd forward1,sd forward2,sd width,sd height)
-    str GTK_STOCK_OK="gtk-ok"
-    data responseok=GTK_RESPONSE_OK
-    sd dialog
-    setcall dialog dialogfield_size_button(title,modal_flag,forward1,forward2,width,height,GTK_STOCK_OK,responseok)
-    return dialog
-endfunction
-
-function dialogfield(ss title,sd modal_flag,sd forward1,sd forward2)
-    data default=-1
-    sd dialog
-    setcall dialog dialogfield_size(title,modal_flag,forward1,forward2,default,default)
-    return dialog
-endfunction
-#true to not propagate
-function dialogfield_modal_texter_expose(sd widget)
-	call dialogfield_modal_texter_drawtext((value_get),widget)
-	return (TRUE)
-endfunction
-import "cpymem" cpymem
-import "slen" slen
-#const modal_texter_draw_data_size=100
-function dialogfield_modal_texter_drawtext(sd procedure,sd text)
-	char text_data#22+modal_texter_mark+1
-	vstr strtext^text_data
-	if procedure==(value_set)
-	#this is not main thread
-		sd len
-		setcall len slen(text)
-		inc len
-		call cpymem(strtext,text,len)
-	elseif procedure==(value_get)
-	#this is main thread
-		import "draw_expose_text" draw_expose_text
-		call draw_expose_text(text,strtext)
-	else
-	#value_unset
-		set strtext# 0
-	endelse
-endfunction
-#
-const modal_texter_parentdialog_width=500
-#dialogfield_modal_texter
-data forward_init#1
-const p_forward_init^forward_init
-function dialogfield_modal_texter_init(sd vbox,sd dialog)
-    #Text
-    import "drawfield" drawfield
-    import "connect_signal" connect_signal
-    sd draw
-    setcall draw drawfield(vbox)
-    call dialogfield_modal_texter_drawtext((value_unset))
-    #old remark: it's not ok to access at the same time txt[modal_texter_draw_data_size] by threads but it's no problem
-    #import "setmemzero" setmemzero
-    #call setmemzero(txt,(modal_texter_draw_data_size))
-    call dialog_modal_texter_drawwidget((value_set),draw)
-    #
-    str expose="expose-event"
-    data exp^dialogfield_modal_texter_expose
-    call connect_signal(draw,expose,exp)
-    #
-    importx "_gtk_widget_set_size_request" gtk_widget_set_size_request
-    call gtk_widget_set_size_request(draw,(modal_texter_parentdialog_width-20),40)
-
-    #call the main init
-    sd p%p_forward_init
-    if p#!=0
-        sd forward_init
-        set forward_init p#
-        call forward_init(vbox,dialog)
-    endif
-
-    #add the new texter
-    import "new_texter_modal" new_texter_modal
-    call new_texter_modal(vbox,dialog)
-endfunction
-function dialog_modal_texter_drawwidget(sd action,sd value)
-    data drawwidget#1
-    if action==(value_set)
-        set drawwidget value
-    else
-        return drawwidget
-    endelse
-endfunction
-function dialog_modal_texter_draw(ss text)
-#	sd widget
-#	setcall widget dialog_modal_texter_drawwidget((value_get))
-#	if widget!=0
-	call dialogfield_modal_texter_drawtext((value_set),text)
-	importx "_g_idle_add" g_idle_add
-	#the drawing commands must be called from the main thread or sometimes will crash
-	call g_idle_add(dialog_modal_texter_draw_main_thread,(void))
-#	endif
-endfunction
-#FALSE=stop timeout
-function dialog_modal_texter_draw_main_thread(sd *data)
-	sd widget
-	setcall widget dialog_modal_texter_drawwidget((value_get))
-	if widget!=0 #this,at audiovideo,can come later in main after g_thread_join/gtk_widget_destroy
-		import "widget_redraw" widget_redraw
-		importx "_gtk_widget_get_window" gtk_widget_get_window
-		call widget_redraw(widget)
-		sd window
-		setcall window gtk_widget_get_window(widget)
-		if window!=0
-			importx "_gdk_window_process_updates" gdk_window_process_updates
-			call gdk_window_process_updates(window,(FALSE))
-		endif
-	endif
-	return (FALSE)
-endfunction
-
-#void
-function dialogfield_modal_texter_core(ss title,sd forward_init,ss buttontext)
-    sd p%p_forward_init
-    set p# forward_init
-    data init^dialogfield_modal_texter_init
-    sd dialog
-    setcall dialog dialogfield_size_button_core(title,(GTK_DIALOG_MODAL),init,(modal_texter_parentdialog_width),-1,buttontext,(GTK_RESPONSE_CANCEL))
-    return dialog
-endfunction
-#void
-#function dialogfield_modal_texter(ss title,sd forward_init,ss buttontext)
-#    sd dialog
-#    setcall dialog dialogfield_modal_texter_core(title,forward_init,buttontext)
-#    call gtk_dialog_run(dialog)
-#    call gtk_widget_destroy(dialog)
-#endfunction
-function dialogfield_modal_texter_sync(ss title,sd forward_init,ss buttontext,sd global_flag,sd stop_flag)
-    sd dialog
-    setcall dialog dialogfield_modal_texter_core(title,forward_init,buttontext)
-    call gtk_dialog_run(dialog)
-    while global_flag#==1
-        import "sleepMs" sleepMs
-        set stop_flag# 1
-        call sleepMs(500)
-    endwhile
-    call gtk_widget_destroy(dialog)
-endfunction
-
-##########eventbox
-
-importx "_gtk_container_add" gtk_container_add
-import "container_add" container_add
-
-importx "_gtk_event_box_new" gtk_event_box_new
-function eventboxfield(sd box)
-    sd wid
-    setcall wid gtk_event_box_new()
-    call packstart_default(box,wid)
-    return wid
-endfunction
-function eventboxfield_cnt(sd box)
-    sd wid
-    setcall wid gtk_event_box_new()
-    call container_add(box,wid)
-    return wid
-endfunction
-
-##########file chooser
-#file/null
-function file_chooser_get_filename(sd dialog)
-    import "file_chooser_get_fname" file_chooser_get_fname
-    ss file
-    setcall file file_chooser_get_fname(dialog)
-    data z=0
-    if file==z
-        str er="Dialog file name representation error."
-        import "texter" texter
-        call texter(er)
-        return z
-    endif
-    return file
-endfunction
-
-#dialog
-function filechooserfield_core()
-    str open_file="Open File"
-    sd main
-    setcall main mainwidget()
-    data open=GTK_FILE_CHOOSER_ACTION_OPEN
-    str GTK_STOCK_CANCEL="gtk-cancel"
-    data responsecancel=GTK_RESPONSE_CANCEL
-    str GTK_STOCK_OPEN="gtk-open"
-    data null=0
-    importx "_gtk_file_chooser_dialog_new" gtk_file_chooser_dialog_new
-    sd dialog
-    setcall dialog gtk_file_chooser_dialog_new(open_file,main,open,GTK_STOCK_CANCEL,responsecancel,GTK_STOCK_OPEN,(GTK_RESPONSE_ACCEPT),null)
-    return dialog
-endfunction
-
-importx "_g_free" g_free
-
-#0/filename, must be freed
-function filechooserfield()
-    sd dialog
-    setcall dialog filechooserfield_core()
-    sd filename
-    setcall filename filechooserfield_dialog(dialog)
-    return filename
-endfunction
-
-function filechooserfield_dialog(sd dialog)
-    sd filename
-    set filename 0
-
-    sd resp
-    setcall resp gtk_dialog_run(dialog)
-    if resp==(GTK_RESPONSE_ACCEPT)
-        ss file
-        setcall file file_chooser_get_filename(dialog)
-        if file!=0
-            import "memrealloc" memrealloc
-            sd len
-            setcall len slen(file)
-            inc len
-            setcall filename memrealloc(0,len)
-            if filename==0
-                call g_free(file)
-                return filename
-            endif
-            call cpymem(filename,file,len)
-
-            call g_free(file)
-        endif
-    endif
-    call gtk_widget_destroy(dialog)
-    return filename
-endfunction
-
-function filechooserfield_forward(sd forward)
-    sd dialog
-    setcall dialog filechooserfield_core()
-    sd resp
-    setcall resp gtk_dialog_run(dialog)
-    if resp==(GTK_RESPONSE_ACCEPT)
-        ss file
-        setcall file file_chooser_get_filename(dialog)
-        if file!=0
-            call forward(file)
-            call g_free(file)
-        endif
-    endif
-    call gtk_widget_destroy(dialog)
-endfunction
-
-#fchooserbuttonfield
-function fchooserbuttonfield_open(sd container,ss dialogtext)
-    importx "_gtk_file_chooser_button_new" gtk_file_chooser_button_new
-    sd fchooser
-    setcall fchooser gtk_file_chooser_button_new(dialogtext,(GTK_FILE_CHOOSER_ACTION_OPEN))
-    call packstart(container,fchooser,(TRUE))
-    return fchooser
-endfunction
-
-#fchooserbuttonfield
-function fchooserbuttonfield_open_label(sd container,ss dialog_label_text)
-    sd hbox
-    setcall hbox hboxfield_label(container,dialog_label_text)
-    sd fchooser
-    setcall fchooser fchooserbuttonfield_open(hbox,dialog_label_text)
-    return fchooser
-endfunction
-
-##########frame
-function framefield(sd box,ss text)
-    importx "_gtk_frame_new" gtk_frame_new
-    sd frame
-    setcall frame gtk_frame_new(text)
-    if box!=0
-        call packstart_default(box,frame)
-    endif
-    return frame
-endfunction
-
-importx "_gtk_hbox_new" gtk_hbox_new
-##########hbox
-function hboxfield_prepare()
-    data gtkwidget#1
-    data null=0
-    setcall gtkwidget gtk_hbox_new(null,null)
-    return gtkwidget
-endfunction
-function hboxfield_pack_pad(data container,data padding)
-    data gtkwidget#1
-    setcall gtkwidget hboxfield_prepare()
-    data null=0
-    call boxpackstart(container,gtkwidget,null,padding)
-    return gtkwidget
-endfunction
-function hboxfield_cnt(data container)
-    data gtkwidget#1
-    setcall gtkwidget hboxfield_prepare()
-    call container_add(container,gtkwidget)
-    return gtkwidget
-endfunction
-
-#hbox
-function hboxfield_label(sd box,ss text)
-    sd hbox
-    setcall hbox hboxfield_cnt(box)
-    import "labelfield_left_default" labelfield_left_default
-    call labelfield_left_default(text,hbox)
-    return hbox
-endfunction
-
-
-##############scroll
-function scrollfield(sd container)
-    importx "_gtk_scrolled_window_new" gtk_scrolled_window_new
-    data null=0
-    sd scroll
-    setcall scroll gtk_scrolled_window_new(null,null)
-    call gtk_container_add(container,scroll)
-    return scroll
-endfunction
-
-
-
-
-
-importx "_gtk_table_new" gtk_table_new
-##########table
-function tablefield(sd bag,sd row,sd col)
-    sd widget
-    data false=0
-    setcall widget gtk_table_new(row,col,false)
-    call container_add(bag,widget)
-    return widget
-endfunction
-importx "_gtk_table_attach_defaults" gtk_table_attach_defaults
-function table_attach(sd table,sd cell,sd x,sd y)
-    sd next_x
-    sd next_y
-    set next_x x
-    set next_y y
-    inc next_x
-    inc next_y
-    call gtk_table_attach_defaults(table,cell,x,next_x,y,next_y)
-endfunction
-
-importx "_gtk_table_resize" gtk_table_resize
-importx "_gtk_table_get_size" gtk_table_get_size
-
-#returns the row pointer for use at the next row, allCol false case use only
-function table_add_row_allCol(sd table,sd row,sd allCol)
-    sd rows
-    sd columns
-    sd ptr_rows^rows
-    sd ptr_columns^columns
-
-    call gtk_table_get_size(table,ptr_rows,ptr_columns)
-    sd lastrow
-    set lastrow rows
-    inc rows
-    call gtk_table_resize(table,rows,columns)
-
-    data true=1
-    data false=0
-    data dword=4
-    data firstcol=1
-
-    sd c=0
-    sd col
-    if allCol==true
-        set col columns
-    else
-        set col firstcol
-    endelse
-    sd add
-    set add true
-    while add==true
-        if row#!=0
-            call gtk_table_attach_defaults(table,row#,c,col,lastrow,rows)
-        endif
-        add row dword
-        if col!=columns
-            inc c
-            inc col
-        else
-            set add false
-        endelse
-    endwhile
-    return row
-endfunction
-
-function table_add_row(sd table,sd row)
-    data true=1
-    sd ptr_row^row
-    call table_add_row_allCol(table,ptr_row,true)
-endfunction
-
-#returns the cells pointer that may points to the next block
-function table_add_cells(sd table,sd row,sd cells)
-    data false=0
-    sd i=0
-    while i!=row
-        setcall cells table_add_row_allCol(table,cells,false)
-        inc i
-    endwhile
-    return cells
-endfunction
-
-#first 3 arguments for tablefield, widgets arg has rows*cols child cell widgets
-function tablefield_cells(sd bag,sd row,sd col,sd cells)
-    sd widget
-    #0,but goes 1, then first row is lost
-    setcall widget tablefield(bag,0,col)
-    call table_add_cells(widget,row,cells)
-    return widget
-endfunction
-
-function tablefield_row(sd bag,sd col,sd cells)
-    sd widget
-    #0,but goes 1, then first row is lost
-    setcall widget tablefield(bag,0,col)
-    call table_add_row(widget,cells)
-    return widget
-endfunction
-
-
-
-
-
-#############vbox
-importx "_gtk_vbox_new" gtk_vbox_new
-#gtkwidget
-function vboxfield(data container)
-    data gtkwidget#1
-    data null=NULL
-
-    setcall gtkwidget gtk_vbox_new(null,null)
-
-    call gtk_container_add(container,gtkwidget)
-    return gtkwidget
-endfunction
-
-function vboxfield_pack(sd container)
-    data gtkwidget#1
-    data null=NULL
-
-    setcall gtkwidget gtk_vbox_new(null,null)
-
-    call packstart(container,gtkwidget,null)
-    return gtkwidget
-endfunction
--- /dev/null
+++ ovideo-1/src/obj/images.oc
@@ -0,0 +1,921 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+##rgb,yuv
+
+##rgb
+
+#rgb
+function yuv_rgb(ss Y,ss U,ss V,sd y_coef,sd u_coef,sd v_coef,sd add)
+    sd value
+    set value Y#
+    mult value y_coef
+
+    sd get
+    set get U#
+    mult get u_coef
+    add value get
+
+    set get V#
+    mult get v_coef
+    add value get
+
+    mult add 100
+    add value add
+
+    div value 100
+    if value<0
+        set value 0
+    elseif value>0xff
+        set value 0xff
+    endelseif
+    return value
+endfunction
+import "multiple_of_nr" multiple_of_nr
+#rgb size
+function rgb_get_all_sizes(sd width,sd height,sd p_rowstride)
+    sd rowstride
+    setcall rowstride rgb_get_rowstride(width)
+    sd rgb_size
+    set rgb_size rowstride
+    mult rgb_size height
+
+    if p_rowstride!=0
+        set p_rowstride# rowstride
+    endif
+    return rgb_size
+endfunction
+#rgb size
+function rgb_get_size(sd width,sd height)
+    sd rowstride
+    setcall rowstride rgb_get_rowstride(width)
+    sd rgb_size
+    set rgb_size rowstride
+    mult rgb_size height
+    return rgb_size
+endfunction
+#rowstride
+function rgb_get_rowstride(sd width)
+    mult width 3
+    setcall width multiple_of_nr(width,4)
+    return width
+endfunction
+#void
+function yuvi420_to_rgb(ss yuv,ss rgb,sd width,sd height)
+    sd rgb_size
+    sd rowstride
+    sd p_rowstride^rowstride
+    setcall rgb_size rgb_get_all_sizes(width,height,p_rowstride)
+
+    sd planeY
+    sd planeU
+    sd planeV
+    sd p_planeU^planeU
+    sd p_planeV^planeV
+
+    call yuv_get_all_sizes(width,height,p_planeU,p_planeV)
+
+    set planeY yuv
+    add planeU yuv
+    add planeV yuv
+#red
+#   1	0	1.4	-179.93
+#green
+#   1	-0.33	-0.71	134.12
+#blue
+#   1	1.78	0.01	-228
+    sd j=0
+    sd uv_w
+    sd uv_h
+    sd uv_stride
+    set uv_stride width
+    div uv_stride 2
+    while j!=height
+        set uv_h j
+        div uv_h 2
+        sd i=0
+        while i!=width
+            set uv_w i
+            div uv_w 2
+
+            sd U
+            sd V
+
+            set U uv_stride
+            mult U uv_h
+            add U uv_w
+
+            set V U
+
+            add U planeU
+            add V planeV
+
+            #red
+            setcall rgb# yuv_rgb(planeY,U,V,100,0,140,-180)
+            inc rgb
+            #green
+            setcall rgb# yuv_rgb(planeY,U,V,100,-33,-71,134)
+            inc rgb
+            #blue
+            setcall rgb# yuv_rgb(planeY,U,V,100,178,1,-228)
+            inc rgb
+
+            inc planeY
+            inc i
+        endwhile
+        mult i 3
+        while i!=rowstride
+            set rgb# 0
+            inc rgb
+            inc i
+        endwhile
+        inc j
+    endwhile
+endfunction
+#bool
+function yuv_to_rgb_from_file(sd file,sd yuv,sd rgb,sd width,sd height)
+    sd yuvsize
+    setcall yuvsize yuv_get_size(width,height)
+    import "file_read" file_read
+    sd err
+    setcall err file_read(yuv,yuvsize,file)
+    if err!=(noerror)
+        return 0
+    endif
+    call yuvi420_to_rgb(yuv,rgb,width,height)
+    return 1
+endfunction
+
+##yuv
+
+function rgb_yuv(ss bytes,ss dest,sd r_proc,sd g_proc,sd b_proc,sd plus)
+    sd value
+
+    sd r
+    sd g
+    sd b
+    set r bytes#
+    inc bytes
+    set g bytes#
+    inc bytes
+    set b bytes#
+
+    mult r r_proc
+    mult g g_proc
+    mult b b_proc
+    mult plus 100
+
+    set value r
+    add value g
+    add value b
+    add value plus
+
+    div value 100
+    set dest# value
+endfunction
+#size
+function yuv_get_all_sizes(sd width,sd height,sd p_planeU,sd p_planeV)
+    sd size
+    set size width
+    mult size height
+
+    if p_planeU!=0
+        set p_planeU# size
+    endif
+
+    sd w_half
+    set w_half width
+    div w_half 2
+    sd h_half
+    set h_half height
+    div h_half 2
+
+    sd halfsize
+    set halfsize w_half
+    mult halfsize h_half
+
+    add size halfsize
+    if p_planeV!=0
+        set p_planeV# size
+    endif
+
+    add size halfsize
+
+    return size
+endfunction
+#yuv size
+function yuv_get_size(sd width,sd height)
+    sd size
+    setcall size yuv_get_all_sizes(width,height,0,0)
+    return size
+endfunction
+
+function rgb_to_yuvi420(ss bitmap_rgb,ss yuv,sd width,sd height)
+    sd bitmap_stride
+    setcall bitmap_stride rgb_get_rowstride(width)
+
+    sd planeY
+    sd planeU
+    sd planeV
+
+    sd p_planeU^planeU
+    sd p_planeV^planeV
+
+    call yuv_get_all_sizes(width,height,p_planeU,p_planeV)
+
+    set planeY yuv
+    add planeU yuv
+    add planeV yuv
+
+##################################################
+#Y    +U            +V
+#(w*h)+((w/2)*(h/2))+((w/2)*(h/2))
+
+    #Y  0.299    0.587    0.114   R
+    #U -0.14713 -0.28886  0.436   G
+    #V  0.615   -0.51499 -0.10001 B
+
+    #Y  30  59  11 R
+    #U -17 -33  50 G
+    #V  50 -42 - 8 B
+    sd j=0
+    sd bitmap_rgb_cursor
+    set bitmap_rgb_cursor bitmap_rgb
+    while j!=height
+        sd i=0
+        set bitmap_rgb bitmap_rgb_cursor
+        while i!=width
+####
+            call rgb_yuv(bitmap_rgb,planeY,30,59,11,0)
+            inc planeY
+
+            sd uv_j
+            set uv_j j
+            and uv_j 1
+            if uv_j=0
+                sd uv_i
+                set uv_i i
+                and uv_i 1
+                if uv_i=0
+                    call rgb_yuv(bitmap_rgb,planeU,-17,-33,50,128)
+                    inc planeU
+                    call rgb_yuv(bitmap_rgb,planeV,50,-42,-8,128)
+                    inc planeV
+                endif
+            endif
+####
+            add bitmap_rgb 3
+            inc i
+        endwhile
+        add bitmap_rgb_cursor bitmap_stride
+        inc j
+    endwhile
+###################################################
+endfunction
+
+importx "_free" free
+
+#e/forward
+function rgb_to_yuvi420_forward_data(sd rgb,sd width,sd height,sv forward,sd data)
+    sd size
+    set size width
+    mult size height
+
+    sd w_half
+    set w_half width
+    div w_half 2
+    sd h_half
+    set h_half height
+    div h_half 2
+
+    sd halfsize
+    set halfsize w_half
+    mult halfsize h_half
+
+    add size halfsize
+    add size halfsize
+
+    import "memoryalloc" memoryalloc
+    sd err
+    sd yuv
+    sd ptr_yuv^yuv
+    setcall err memoryalloc(size,ptr_yuv)
+    if err!=(noerror)
+        return err
+    endif
+
+    call rgb_to_yuvi420(rgb,yuv,width,height)
+
+    setcall err forward(yuv,size,data)
+    call free(yuv)
+    return err
+endfunction
+
+
+##functions
+
+#convert
+
+function convert_row_rgba_to_rgb(ss src,ss dest,sd width)
+    const regs=3*0x40
+    const ecx_rm=1*8
+    const esi_rm=6*8
+    const edi_rm=7*8
+    const shitright_imm=5*8
+    const shifteax=regs|shitright_imm|eax
+
+    hex 0x51,0x56,0x57
+
+    import "getoneax" getoneax
+    call getoneax(src)
+    hex 0x8b,regs|esi_rm|eax
+    call getoneax(dest)
+    hex 0x8b,regs|edi_rm|eax
+    call getoneax(width)
+    hex 0x8b,regs|ecx_rm|eax
+
+#
+    hex 0xad
+
+    hex 0xaa
+    hex 0xc1,shifteax,8
+    hex 0xaa
+    hex 0xc1,shifteax,8
+    hex 0xaa
+
+    const jump_sz=1+ 1+3+ 1+3+ 1+ 2
+    hex 0xe2,-jump_sz
+#
+
+    hex 0x59,0x5e,0x5f
+endfunction
+
+function color_pixel(sd r,sd g,sd b,ss pixel)
+    set pixel# r
+    inc pixel
+    set pixel# g
+    inc pixel
+    set pixel# b
+endfunction
+function rgb_uint_to_colors(sd pixel,sd colors)
+    set colors# pixel
+    and colors# 0xff
+    add colors 4
+    set colors# pixel
+    and colors# 0xff00
+    div colors# 0x100
+    add colors 4
+    set colors# pixel
+    and colors# 0xff0000
+    div colors# 0x10000
+endfunction
+function rgb_colors_to_uint(sd colors)
+    sd pixel
+    set pixel colors#
+
+    sd value
+    add colors 4
+    set value colors#
+    mult value 0x100
+    or pixel value
+
+    add colors 4
+    set value colors#
+    mult value 0x10000
+    or pixel value
+
+    return pixel
+endfunction
+
+function bytes_swap_reverse(sd bytes,sd width,sd height)
+    call rgb_reverse(bytes,width,height)
+    call rgb_color_swap(bytes,width,height)
+endfunction
+
+function rgb_reverse(sd bytes,sd width,sd height)
+    sd src
+    sd dest
+    set src bytes
+    set dest bytes
+
+    sd rowstride
+    setcall rowstride rgb_get_rowstride(width)
+
+    sd size
+    set size rowstride
+    mult size height
+    sub size rowstride
+    add src size
+
+    sd j=0
+    div height 2
+    while j!=height
+        sd i=0
+        sd aux
+        sd src_cursor
+        sd dest_cursor
+        set src_cursor src
+        set dest_cursor dest
+        while i!=rowstride
+            set aux src_cursor#
+            set src_cursor# dest_cursor#
+            set dest_cursor# aux
+            add src_cursor 4
+            add dest_cursor 4
+            add i 4
+        endwhile
+
+        sub src rowstride
+        add dest rowstride
+        inc j
+    endwhile
+endfunction
+function rgb_color_swap(ss bytes,sd width,sd height)
+    sd stride_diff
+    set stride_diff width
+    mult stride_diff 3
+    subcall stride_diff rgb_get_rowstride(width)
+    mult stride_diff -1
+    sd j=0
+    while j!=height
+        sd i=0
+        while i!=width
+            sd a
+            set a bytes#
+            inc bytes
+            sd b
+            set b bytes#
+            inc bytes
+            sd c
+            set c bytes#
+            sub bytes 2
+            set bytes# c
+            inc bytes
+            set bytes# b
+            inc bytes
+            set bytes# a
+            inc bytes
+            inc i
+        endwhile
+        add bytes stride_diff
+        inc j
+    endwhile
+endfunction
+
+#e
+function rgb_to_yuvi420_write_fn(sd yuv,sd size,sd file)
+    import "file_write" file_write
+    sd err
+    setcall err file_write(yuv,size,file)
+    return err
+endfunction
+#e
+function rgb_to_yuvi420_write(sd rgb,sd width,sd height,sd file)
+    data f^rgb_to_yuvi420_write_fn
+    sd err
+    setcall err rgb_to_yuvi420_forward_data(rgb,width,height,f,file)
+    return err
+endfunction
+
+importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
+importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+importx "_g_object_unref" g_object_unref
+import "texter" texter
+
+#pixbuf
+function rgb_test(sd pixbuf)
+#    if pixbuf==0
+#        return 0
+#    endif
+	importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+	sd w
+	setcall w gdk_pixbuf_get_width(pixbuf)
+	sd teststride
+	setcall teststride gdk_pixbuf_get_rowstride(pixbuf)
+	sd three_dif
+	set three_dif w
+	mult three_dif 3
+	sd stride
+	setcall stride multiple_of_nr(three_dif,4)
+	sub three_dif stride
+	neg three_dif
+	if stride!=teststride
+	#this is with alpha
+		importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+		sd h
+		setcall h gdk_pixbuf_get_height(pixbuf)
+		sd size
+		set size stride
+		mult size h
+		import "memalloc" memalloc
+		sd newmem
+		setcall newmem memalloc(size)
+		if newmem!=(NULL)
+			ss bytes
+			setcall bytes gdk_pixbuf_get_pixels(pixbuf)
+			sd end
+			set end h
+			mult end teststride
+			add end bytes
+			ss pointer
+			set pointer newmem
+			while bytes!=end
+				sd row
+				set row bytes
+				add row teststride
+				while bytes!=row
+					set pointer# bytes#
+					inc pointer;inc bytes;set pointer# bytes#
+					inc pointer;inc bytes;set pointer# bytes#
+					inc pointer;add bytes 2
+				endwhile
+				if three_dif!=0
+					add pointer three_dif
+				endif
+			endwhile
+			importx "_gdk_pixbuf_new_from_data" gdk_pixbuf_new_from_data
+			sd newpixbuf
+			setcall newpixbuf gdk_pixbuf_new_from_data(newmem,(GDK_COLORSPACE_RGB),(FALSE),8,w,h,stride,free,newmem)
+			if newpixbuf!=(NULL)
+				call g_object_unref(pixbuf)
+				return newpixbuf
+			endif
+			call texter("error at new pixbuf")
+			call free(newmem)
+		endif
+		return (NULL)
+	endif
+	return pixbuf
+endfunction
+
+#bool
+function rgb_sizes_test(sd width,sd height,sd newpixbuf)
+    import "pixbuf_get_wh" pixbuf_get_wh
+    sd test_w
+    sd test_h
+    sd p_test^test_w
+    call pixbuf_get_wh(newpixbuf,p_test)
+    if test_w<width
+        str w_err="New frame width is too small"
+        call texter(w_err)
+        return 0
+    endif
+    if test_h<height
+        str h_err="New frame height is too small"
+        call texter(h_err)
+        return 0
+    endif
+    return 1
+endfunction
+
+#byte color
+function gdkcolor2byte(ss ptr_g)
+    sd word_color=0
+    sd p_word_color^word_color
+    set p_word_color# ptr_g#
+    inc ptr_g
+    inc p_word_color
+    set p_word_color# ptr_g#
+    import "rule3" rule3
+    sd x
+    setcall x rule3(word_color,0xffFF,255)
+    return x
+endfunction
+
+#considering bps=8(<8 will be bad, >8 the return will be strange)
+#            n_chan=3(<3 bad,>3 doesnt care)
+#rowstride = row[N] - row[N-1]
+function rgb_get_set(ss pointerOut,ss bytes,sd x,sd y,sd bps,sd n_chan,sd rowstride,sd getORset)
+    mult y rowstride
+    add bytes y
+
+    mult x bps
+    data a=bitsperbyte
+    div x a
+    mult x n_chan
+
+    add bytes x
+
+    sd i=0
+    sd n=3
+    while i<n
+        if getORset=(get_rgb)
+            set pointerOut# bytes#
+        else
+            set bytes# pointerOut#
+        endelse
+        inc i
+        inc pointerOut
+        inc bytes
+    endwhile
+    if getORset=(get_rgb)
+        set pointerOut# 0
+    endif
+endfunction
+
+function rgb_px_get(ss bytes,sd x,sd y,sd bps,sd n_chan,sd rowstride)
+    sd value
+    sd p_value^value
+    call rgb_get_set(p_value,bytes,x,y,bps,n_chan,rowstride,(get_rgb))
+    return value
+endfunction
+function rgb_px_set(sd value,ss bytes,sd x,sd y,sd bps,sd n_chan,sd rowstride)
+    sd p_value^value
+    call rgb_get_set(p_value,bytes,x,y,bps,n_chan,rowstride,(set_rgb))
+endfunction
+
+function rgb_pixbuf_get_pixel(ss pixbuf,sd x,sd y,sd bps,sd n_chan)
+    sd pixels
+    setcall pixels gdk_pixbuf_get_pixels(pixbuf)
+    sd rowstride
+    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
+    sd value
+    setcall value rgb_px_get(pixels,x,y,bps,n_chan,rowstride)
+    return value
+endfunction
+function rgb_pixbuf_set_pixel(sd value,ss pixbuf,sd x,sd y,sd bps,sd n_chan)
+    sd pixels
+    setcall pixels gdk_pixbuf_get_pixels(pixbuf)
+    sd rowstride
+    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
+    call rgb_px_set(value,pixels,x,y,bps,n_chan,rowstride)
+endfunction
+
+function rgb_copy(sd srcpixels,sd destpixels,sd left,sd top,sd right,sd bottom,sd rowstride)
+    sd left_start
+    set left_start left
+    while top!=bottom
+        set left left_start
+        while left!=right
+            sd value
+            setcall value rgb_px_get(srcpixels,left,top,8,3,rowstride)
+            call rgb_px_set(value,destpixels,left,top,8,3,rowstride)
+            inc left
+        endwhile
+        inc top
+    endwhile
+endfunction
+
+
+
+
+
+
+##draw
+function draw_expose_text(sd widget,ss text)
+    #get the gdk window
+    importx "_gtk_widget_get_window" gtk_widget_get_window
+    sd wind
+    setcall wind gtk_widget_get_window(widget)
+
+    #creates the cairo context
+    importx "_gdk_cairo_create" gdk_cairo_create
+    sd cairo
+    setcall cairo gdk_cairo_create(wind)
+    import "int_to_double" int_to_double
+    sd cairo_double_low
+    sd cairo_double_high
+    sd p_cairo_double^cairo_double_low
+
+	importx "_cairo_set_source_rgb" cairo_set_source_rgb
+
+	#set white, double 1
+	call cairo_set_source_rgb(cairo,0,0x3fF00000,0,0x3fF00000,0,0x3fF00000)
+	importx "_cairo_paint" cairo_paint
+	call cairo_paint(cairo)
+
+    #set a black source
+    call cairo_set_source_rgb(cairo,0,0,0,0,0,0)
+
+    #set text size
+    importx "_cairo_set_font_size" cairo_set_font_size
+    call int_to_double(20,p_cairo_double)
+    call cairo_set_font_size(cairo,cairo_double_low,cairo_double_high)
+
+    #move to let text space
+    importx "_cairo_move_to" cairo_move_to
+    call cairo_move_to(cairo,0,0,cairo_double_low,cairo_double_high)
+
+    #draw text
+    importx "_cairo_show_text" cairo_show_text
+    call cairo_show_text(cairo,text)
+
+    #free cairo
+    importx "_cairo_destroy" cairo_destroy
+    call cairo_destroy(cairo)
+endfunction
+
+import "get_higher" get_higher
+import "get_lower" get_lower
+
+function pixbuf_draw_text(sd pixbuf,ss text,sd x,sd y,sd size,sd color,sd coordinates_flag)
+    sd width
+    sd height
+    sd p_wh^width
+
+    call pixbuf_get_wh(pixbuf,p_wh)
+
+    importx "_gdk_pixmap_new" gdk_pixmap_new
+    sd pixmap
+    setcall pixmap gdk_pixmap_new(0,width,height,24)
+
+    importx "_gdk_gc_new" gdk_gc_new
+    sd gc
+    setcall gc gdk_gc_new(pixmap)
+
+    importx "_gdk_draw_pixbuf" gdk_draw_pixbuf
+    call gdk_draw_pixbuf(pixmap,gc,pixbuf,0,0,0,0,width,height,(GDK_RGB_DITHER_NONE),0,0)
+
+    importx "_gtk_window_new" gtk_window_new
+    sd scratch
+    setcall scratch gtk_window_new((GTK_WINDOW_TOPLEVEL))
+    importx "_gtk_widget_realize" gtk_widget_realize
+    call gtk_widget_realize(scratch)
+    importx "_gtk_widget_create_pango_layout" gtk_widget_create_pango_layout
+    sd pangolayout
+    setcall pangolayout gtk_widget_create_pango_layout(scratch,0)
+    importx "_gtk_widget_destroy" gtk_widget_destroy
+    call gtk_widget_destroy(scratch)
+
+    importx "_g_strdup_printf" g_strdup_printf
+    ss format="<b><span foreground='#%06x' font='%u'>%s</span></b>"
+    ss markup
+    setcall markup g_strdup_printf(format,color,size,text)
+
+    importx "_pango_layout_set_markup" pango_layout_set_markup
+    call pango_layout_set_markup(pangolayout,markup,-1)
+
+    #determine the positioning method: coordinates(x,y) or location(x factor,y factor)
+    if coordinates_flag=0
+        #location
+        importx "_pango_layout_get_pixel_size" pango_layout_get_pixel_size
+        sd text_width
+        sd text_height
+        sd p_text_width^text_width
+        sd p_text_height^text_height
+        call pango_layout_get_pixel_size(pangolayout,p_text_width,p_text_height)
+
+        sd available_w
+        set available_w width
+        sub available_w text_width
+        setcall available_w get_higher(available_w,0)
+
+        sd available_h
+        set available_h height
+        sub available_h text_height
+        setcall available_h get_higher(available_h,0)
+
+        inc x
+        inc y
+        setcall x rule3(x,2,available_w)
+        setcall y rule3(y,2,available_h)
+    endif
+
+    importx "_gdk_draw_layout" gdk_draw_layout
+    call gdk_draw_layout(pixmap,gc,x,y,pangolayout)
+
+    importx "_gdk_pixbuf_get_from_drawable" gdk_pixbuf_get_from_drawable
+    sd pix_buf
+    setcall pix_buf gdk_pixbuf_get_from_drawable((NULL),pixmap,(NULL),0,0,0,0,width,height)
+
+    importx "_g_free" g_free
+    call g_free(markup)
+    call g_object_unref(pangolayout)
+    call g_object_unref(gc)
+    call g_object_unref(pixmap)
+
+    return pix_buf
+endfunction
+
+
+function draw_default_cursor(sd root,sd def_x,sd def_y,sd width,sd height,sd cairo)
+    importx "_gdk_window_get_pointer" gdk_window_get_pointer
+    sd x
+    sd y
+    sd p_x^x
+    sd p_y^y
+    call gdk_window_get_pointer(root,p_x,p_y,(NULL))
+    sub x def_x
+    sub y def_y
+
+    importx "_gdk_display_get_default" gdk_display_get_default
+    sd display
+    setcall display gdk_display_get_default()
+    if display=0
+        str disp_err="No default display found"
+        call texter(disp_err)
+        return 0
+    endif
+    importx "_gdk_cursor_new_for_display" gdk_cursor_new_for_display
+    importx "_gdk_cursor_get_image" gdk_cursor_get_image
+    importx "_gdk_cursor_unref" gdk_cursor_unref
+    sd Cursor
+    setcall Cursor gdk_cursor_new_for_display(display,(GDK_LEFT_PTR))
+    call draw_cursor(Cursor,x,y,width,height,cairo)
+    call gdk_cursor_unref(Cursor)
+endfunction
+
+function draw_cursor(sd Cursor,sd x,sd y,sd width,sd height,sd cairo)
+    sd cPixbuf
+    setcall cPixbuf gdk_cursor_get_image(Cursor)
+    if cPixbuf=0
+        str pxerr="The cursor image data can't be retrived"
+        call texter(pxerr)
+        return 0
+    endif
+    call draw_pixbuf_cursor(cPixbuf,x,y,width,height,cairo)
+    call g_object_unref(cPixbuf)
+endfunction
+
+function draw_pixbuf_cursor(sd cPixbuf,sd x,sd y,sd width,sd height,sd cairo)
+    #some tests to determine the visible area for overlaying the cursor
+    sd left
+    sd top
+    sd cWidth
+    sd cHeight
+    sd rect^left
+
+    sd bool
+    setcall bool cursor_tests(cPixbuf,x,y,width,height,rect)
+    if bool=0
+        return 0
+    endif
+
+    call cairo_draw_default_cursor(cairo,cPixbuf,x,y,left,top,cWidth,cHeight)
+endfunction
+#bool
+function cursor_tests(sd cPixbuf,sd left,sd top,sd pxWidth,sd pxHeight,sd rect)
+    #if bool,rect get x,y,width,heigth truncated
+    if left>=pxWidth
+        return 0
+    endif
+    if top>=pxHeight
+        return 0
+    endif
+
+    sd cursor_width
+    sd cursor_height
+    sd cursor_wh^cursor_width
+    call pixbuf_get_wh(cPixbuf,cursor_wh)
+
+    sd right
+    set right left
+    add right cursor_width
+    if right<=0
+        return 0
+    endif
+    sd bottom
+    set bottom top
+    add bottom cursor_height
+    if bottom<=0
+        return 0
+    endif
+
+    setcall rect# get_higher(0,left)
+    add rect 4
+    setcall rect# get_higher(0,top)
+    add rect 4
+    setcall rect# get_lower(right,pxWidth)
+    sub rect# left
+    add rect 4
+    setcall rect# get_lower(bottom,pxHeight)
+    sub rect# top
+endfunction
+
+##cairo
+
+function cairo_draw_default_cursor(sd cairo,sd cPixbuf,sd x,sd y,sd left,sd top,sd cWidth,sd cHeight)
+    importx "_gdk_cairo_set_source_pixbuf" gdk_cairo_set_source_pixbuf
+    importx "_cairo_rectangle" cairo_rectangle
+    importx "_cairo_fill" cairo_fill
+    sd double_x_low
+    sd double_x_high
+    sd double_y_low
+    sd double_y_high
+    sd double_x^double_x_low
+    sd double_y^double_y_low
+    call int_to_double(x,double_x)
+    call int_to_double(y,double_y)
+    call gdk_cairo_set_source_pixbuf(cairo,cPixbuf,double_x_low,double_x_high,double_y_low,double_y_high)
+    sd double_left_low
+    sd double_left_high
+    sd double_top_low
+    sd double_top_high
+    sd double_left^double_left_low
+    sd double_top^double_top_low
+    call int_to_double(left,double_left)
+    call int_to_double(top,double_top)
+    sd double_cWidth_low
+    sd double_cWidth_high
+    sd double_cHeight_low
+    sd double_cHeight_high
+    sd double_cWidth^double_cWidth_low
+    sd double_cHeight^double_cHeight_low
+    call int_to_double(cWidth,double_cWidth)
+    call int_to_double(cHeight,double_cHeight)
+    call cairo_rectangle(cairo,double_left_low,double_left_high,double_top_low,double_top_high,double_cWidth_low,double_cWidth_high,double_cHeight_low,double_cHeight_high)
+    call cairo_fill(cairo)
+endfunction
--- ovideo-1.orig/src/obj/images.s
+++ /dev/null
@@ -1,921 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-##rgb,yuv
-
-##rgb
-
-#rgb
-function yuv_rgb(ss Y,ss U,ss V,sd y_coef,sd u_coef,sd v_coef,sd add)
-    sd value
-    set value Y#
-    mult value y_coef
-
-    sd get
-    set get U#
-    mult get u_coef
-    add value get
-
-    set get V#
-    mult get v_coef
-    add value get
-
-    mult add 100
-    add value add
-
-    div value 100
-    if value<0
-        set value 0
-    elseif value>0xff
-        set value 0xff
-    endelseif
-    return value
-endfunction
-import "multiple_of_nr" multiple_of_nr
-#rgb size
-function rgb_get_all_sizes(sd width,sd height,sd p_rowstride)
-    sd rowstride
-    setcall rowstride rgb_get_rowstride(width)
-    sd rgb_size
-    set rgb_size rowstride
-    mult rgb_size height
-
-    if p_rowstride!=0
-        set p_rowstride# rowstride
-    endif
-    return rgb_size
-endfunction
-#rgb size
-function rgb_get_size(sd width,sd height)
-    sd rowstride
-    setcall rowstride rgb_get_rowstride(width)
-    sd rgb_size
-    set rgb_size rowstride
-    mult rgb_size height
-    return rgb_size
-endfunction
-#rowstride
-function rgb_get_rowstride(sd width)
-    mult width 3
-    setcall width multiple_of_nr(width,4)
-    return width
-endfunction
-#void
-function yuvi420_to_rgb(ss yuv,ss rgb,sd width,sd height)
-    sd rgb_size
-    sd rowstride
-    sd p_rowstride^rowstride
-    setcall rgb_size rgb_get_all_sizes(width,height,p_rowstride)
-
-    sd planeY
-    sd planeU
-    sd planeV
-    sd p_planeU^planeU
-    sd p_planeV^planeV
-
-    call yuv_get_all_sizes(width,height,p_planeU,p_planeV)
-
-    set planeY yuv
-    add planeU yuv
-    add planeV yuv
-#red
-#   1	0	1.4	-179.93
-#green
-#   1	-0.33	-0.71	134.12
-#blue
-#   1	1.78	0.01	-228
-    sd j=0
-    sd uv_w
-    sd uv_h
-    sd uv_stride
-    set uv_stride width
-    div uv_stride 2
-    while j!=height
-        set uv_h j
-        div uv_h 2
-        sd i=0
-        while i!=width
-            set uv_w i
-            div uv_w 2
-
-            sd U
-            sd V
-
-            set U uv_stride
-            mult U uv_h
-            add U uv_w
-
-            set V U
-
-            add U planeU
-            add V planeV
-
-            #red
-            setcall rgb# yuv_rgb(planeY,U,V,100,0,140,-180)
-            inc rgb
-            #green
-            setcall rgb# yuv_rgb(planeY,U,V,100,-33,-71,134)
-            inc rgb
-            #blue
-            setcall rgb# yuv_rgb(planeY,U,V,100,178,1,-228)
-            inc rgb
-
-            inc planeY
-            inc i
-        endwhile
-        mult i 3
-        while i!=rowstride
-            set rgb# 0
-            inc rgb
-            inc i
-        endwhile
-        inc j
-    endwhile
-endfunction
-#bool
-function yuv_to_rgb_from_file(sd file,sd yuv,sd rgb,sd width,sd height)
-    sd yuvsize
-    setcall yuvsize yuv_get_size(width,height)
-    import "file_read" file_read
-    sd err
-    setcall err file_read(yuv,yuvsize,file)
-    if err!=(noerror)
-        return 0
-    endif
-    call yuvi420_to_rgb(yuv,rgb,width,height)
-    return 1
-endfunction
-
-##yuv
-
-function rgb_yuv(ss bytes,ss dest,sd r_proc,sd g_proc,sd b_proc,sd plus)
-    sd value
-
-    sd r
-    sd g
-    sd b
-    set r bytes#
-    inc bytes
-    set g bytes#
-    inc bytes
-    set b bytes#
-
-    mult r r_proc
-    mult g g_proc
-    mult b b_proc
-    mult plus 100
-
-    set value r
-    add value g
-    add value b
-    add value plus
-
-    div value 100
-    set dest# value
-endfunction
-#size
-function yuv_get_all_sizes(sd width,sd height,sd p_planeU,sd p_planeV)
-    sd size
-    set size width
-    mult size height
-
-    if p_planeU!=0
-        set p_planeU# size
-    endif
-
-    sd w_half
-    set w_half width
-    div w_half 2
-    sd h_half
-    set h_half height
-    div h_half 2
-
-    sd halfsize
-    set halfsize w_half
-    mult halfsize h_half
-
-    add size halfsize
-    if p_planeV!=0
-        set p_planeV# size
-    endif
-
-    add size halfsize
-
-    return size
-endfunction
-#yuv size
-function yuv_get_size(sd width,sd height)
-    sd size
-    setcall size yuv_get_all_sizes(width,height,0,0)
-    return size
-endfunction
-
-function rgb_to_yuvi420(ss bitmap_rgb,ss yuv,sd width,sd height)
-    sd bitmap_stride
-    setcall bitmap_stride rgb_get_rowstride(width)
-
-    sd planeY
-    sd planeU
-    sd planeV
-
-    sd p_planeU^planeU
-    sd p_planeV^planeV
-
-    call yuv_get_all_sizes(width,height,p_planeU,p_planeV)
-
-    set planeY yuv
-    add planeU yuv
-    add planeV yuv
-
-##################################################
-#Y    +U            +V
-#(w*h)+((w/2)*(h/2))+((w/2)*(h/2))
-
-    #Y  0.299    0.587    0.114   R
-    #U -0.14713 -0.28886  0.436   G
-    #V  0.615   -0.51499 -0.10001 B
-
-    #Y  30  59  11 R
-    #U -17 -33  50 G
-    #V  50 -42 - 8 B
-    sd j=0
-    sd bitmap_rgb_cursor
-    set bitmap_rgb_cursor bitmap_rgb
-    while j!=height
-        sd i=0
-        set bitmap_rgb bitmap_rgb_cursor
-        while i!=width
-####
-            call rgb_yuv(bitmap_rgb,planeY,30,59,11,0)
-            inc planeY
-
-            sd uv_j
-            set uv_j j
-            and uv_j 1
-            if uv_j==0
-                sd uv_i
-                set uv_i i
-                and uv_i 1
-                if uv_i==0
-                    call rgb_yuv(bitmap_rgb,planeU,-17,-33,50,128)
-                    inc planeU
-                    call rgb_yuv(bitmap_rgb,planeV,50,-42,-8,128)
-                    inc planeV
-                endif
-            endif
-####
-            add bitmap_rgb 3
-            inc i
-        endwhile
-        add bitmap_rgb_cursor bitmap_stride
-        inc j
-    endwhile
-###################################################
-endfunction
-
-importx "_free" free
-
-#e/forward
-function rgb_to_yuvi420_forward_data(sd rgb,sd width,sd height,sd forward,sd data)
-    sd size
-    set size width
-    mult size height
-
-    sd w_half
-    set w_half width
-    div w_half 2
-    sd h_half
-    set h_half height
-    div h_half 2
-
-    sd halfsize
-    set halfsize w_half
-    mult halfsize h_half
-
-    add size halfsize
-    add size halfsize
-
-    import "memoryalloc" memoryalloc
-    sd err
-    sd yuv
-    sd ptr_yuv^yuv
-    setcall err memoryalloc(size,ptr_yuv)
-    if err!=(noerror)
-        return err
-    endif
-
-    call rgb_to_yuvi420(rgb,yuv,width,height)
-
-    setcall err forward(yuv,size,data)
-    call free(yuv)
-    return err
-endfunction
-
-
-##functions
-
-#convert
-
-function convert_row_rgba_to_rgb(ss src,ss dest,sd width)
-    const regs=3*0x40
-    const ecx_rm=1*8
-    const esi_rm=6*8
-    const edi_rm=7*8
-    const shitright_imm=5*8
-    const shifteax=regs|shitright_imm|eax
-
-    hex 0x51,0x56,0x57
-
-    import "getoneax" getoneax
-    call getoneax(src)
-    hex 0x8b,regs|esi_rm|eax
-    call getoneax(dest)
-    hex 0x8b,regs|edi_rm|eax
-    call getoneax(width)
-    hex 0x8b,regs|ecx_rm|eax
-
-#
-    hex 0xad
-
-    hex 0xaa
-    hex 0xc1,shifteax,8
-    hex 0xaa
-    hex 0xc1,shifteax,8
-    hex 0xaa
-
-    const jump_sz=1+ 1+3+ 1+3+ 1+ 2
-    hex 0xe2,-1*jump_sz
-#
-
-    hex 0x59,0x5e,0x5f
-endfunction
-
-function color_pixel(sd r,sd g,sd b,ss pixel)
-    set pixel# r
-    inc pixel
-    set pixel# g
-    inc pixel
-    set pixel# b
-endfunction
-function rgb_uint_to_colors(sd pixel,sd colors)
-    set colors# pixel
-    and colors# 0xff
-    add colors 4
-    set colors# pixel
-    and colors# 0xff00
-    div colors# 0x100
-    add colors 4
-    set colors# pixel
-    and colors# 0xff0000
-    div colors# 0x10000
-endfunction
-function rgb_colors_to_uint(sd colors)
-    sd pixel
-    set pixel colors#
-
-    sd value
-    add colors 4
-    set value colors#
-    mult value 0x100
-    or pixel value
-
-    add colors 4
-    set value colors#
-    mult value 0x10000
-    or pixel value
-
-    return pixel
-endfunction
-
-function bytes_swap_reverse(sd bytes,sd width,sd height)
-    call rgb_reverse(bytes,width,height)
-    call rgb_color_swap(bytes,width,height)
-endfunction
-
-function rgb_reverse(sd bytes,sd width,sd height)
-    sd src
-    sd dest
-    set src bytes
-    set dest bytes
-
-    sd rowstride
-    setcall rowstride rgb_get_rowstride(width)
-
-    sd size
-    set size rowstride
-    mult size height
-    sub size rowstride
-    add src size
-
-    sd j=0
-    div height 2
-    while j!=height
-        sd i=0
-        sd aux
-        sd src_cursor
-        sd dest_cursor
-        set src_cursor src
-        set dest_cursor dest
-        while i!=rowstride
-            set aux src_cursor#
-            set src_cursor# dest_cursor#
-            set dest_cursor# aux
-            add src_cursor 4
-            add dest_cursor 4
-            add i 4
-        endwhile
-
-        sub src rowstride
-        add dest rowstride
-        inc j
-    endwhile
-endfunction
-function rgb_color_swap(ss bytes,sd width,sd height)
-    sd stride_diff
-    set stride_diff width
-    mult stride_diff 3
-    subcall stride_diff rgb_get_rowstride(width)
-    mult stride_diff -1
-    sd j=0
-    while j!=height
-        sd i=0
-        while i!=width
-            sd a
-            set a bytes#
-            inc bytes
-            sd b
-            set b bytes#
-            inc bytes
-            sd c
-            set c bytes#
-            sub bytes 2
-            set bytes# c
-            inc bytes
-            set bytes# b
-            inc bytes
-            set bytes# a
-            inc bytes
-            inc i
-        endwhile
-        add bytes stride_diff
-        inc j
-    endwhile
-endfunction
-
-#e
-function rgb_to_yuvi420_write_fn(sd yuv,sd size,sd file)
-    import "file_write" file_write
-    sd err
-    setcall err file_write(yuv,size,file)
-    return err
-endfunction
-#e
-function rgb_to_yuvi420_write(sd rgb,sd width,sd height,sd file)
-    data f^rgb_to_yuvi420_write_fn
-    sd err
-    setcall err rgb_to_yuvi420_forward_data(rgb,width,height,f,file)
-    return err
-endfunction
-
-importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
-importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-importx "_g_object_unref" g_object_unref
-import "texter" texter
-
-#pixbuf
-function rgb_test(sd pixbuf)
-#    if pixbuf==0
-#        return 0
-#    endif
-	importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-	sd w
-	setcall w gdk_pixbuf_get_width(pixbuf)
-	sd teststride
-	setcall teststride gdk_pixbuf_get_rowstride(pixbuf)
-	sd three_dif
-	set three_dif w
-	mult three_dif 3
-	sd stride
-	setcall stride multiple_of_nr(three_dif,4)
-	sub three_dif stride
-	neg three_dif
-	if stride!=teststride
-	#this is with alpha
-		importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-		sd h
-		setcall h gdk_pixbuf_get_height(pixbuf)
-		sd size
-		set size stride
-		mult size h
-		import "memalloc" memalloc
-		sd newmem
-		setcall newmem memalloc(size)
-		if newmem!=(NULL)
-			ss bytes
-			setcall bytes gdk_pixbuf_get_pixels(pixbuf)
-			sd end
-			set end h
-			mult end teststride
-			add end bytes
-			ss pointer
-			set pointer newmem
-			while bytes!=end
-				sd row
-				set row bytes
-				add row teststride
-				while bytes!=row
-					set pointer# bytes#
-					inc pointer;inc bytes;set pointer# bytes#
-					inc pointer;inc bytes;set pointer# bytes#
-					inc pointer;add bytes 2
-				endwhile
-				if three_dif!=0
-					add pointer three_dif
-				endif
-			endwhile
-			importx "_gdk_pixbuf_new_from_data" gdk_pixbuf_new_from_data
-			sd newpixbuf
-			setcall newpixbuf gdk_pixbuf_new_from_data(newmem,(GDK_COLORSPACE_RGB),(FALSE),8,w,h,stride,free,newmem)
-			if newpixbuf!=(NULL)
-				call g_object_unref(pixbuf)
-				return newpixbuf
-			endif
-			call texter("error at new pixbuf")
-			call free(newmem)
-		endif
-		return (NULL)
-	endif
-	return pixbuf
-endfunction
-
-#bool
-function rgb_sizes_test(sd width,sd height,sd newpixbuf)
-    import "pixbuf_get_wh" pixbuf_get_wh
-    sd test_w
-    sd test_h
-    sd p_test^test_w
-    call pixbuf_get_wh(newpixbuf,p_test)
-    if test_w<width
-        str w_err="New frame width is too small"
-        call texter(w_err)
-        return 0
-    endif
-    if test_h<height
-        str h_err="New frame height is too small"
-        call texter(h_err)
-        return 0
-    endif
-    return 1
-endfunction
-
-#byte color
-function gdkcolor2byte(ss ptr_g)
-    sd word_color=0
-    sd p_word_color^word_color
-    set p_word_color# ptr_g#
-    inc ptr_g
-    inc p_word_color
-    set p_word_color# ptr_g#
-    import "rule3" rule3
-    sd x
-    setcall x rule3(word_color,0xffFF,255)
-    return x
-endfunction
-
-#considering bps=8(<8 will be bad, >8 the return will be strange)
-#            n_chan=3(<3 bad,>3 doesnt care)
-#rowstride = row[N] - row[N-1]
-function rgb_get_set(ss pointerOut,ss bytes,sd x,sd y,sd bps,sd n_chan,sd rowstride,sd getORset)
-    mult y rowstride
-    add bytes y
-
-    mult x bps
-    data a=bitsperbyte
-    div x a
-    mult x n_chan
-
-    add bytes x
-
-    sd i=0
-    sd n=3
-    while i<n
-        if getORset==(get_rgb)
-            set pointerOut# bytes#
-        else
-            set bytes# pointerOut#
-        endelse
-        inc i
-        inc pointerOut
-        inc bytes
-    endwhile
-    if getORset==(get_rgb)
-        set pointerOut# 0
-    endif
-endfunction
-
-function rgb_px_get(ss bytes,sd x,sd y,sd bps,sd n_chan,sd rowstride)
-    sd value
-    sd p_value^value
-    call rgb_get_set(p_value,bytes,x,y,bps,n_chan,rowstride,(get_rgb))
-    return value
-endfunction
-function rgb_px_set(sd value,ss bytes,sd x,sd y,sd bps,sd n_chan,sd rowstride)
-    sd p_value^value
-    call rgb_get_set(p_value,bytes,x,y,bps,n_chan,rowstride,(set_rgb))
-endfunction
-
-function rgb_pixbuf_get_pixel(ss pixbuf,sd x,sd y,sd bps,sd n_chan)
-    sd pixels
-    setcall pixels gdk_pixbuf_get_pixels(pixbuf)
-    sd rowstride
-    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
-    sd value
-    setcall value rgb_px_get(pixels,x,y,bps,n_chan,rowstride)
-    return value
-endfunction
-function rgb_pixbuf_set_pixel(sd value,ss pixbuf,sd x,sd y,sd bps,sd n_chan)
-    sd pixels
-    setcall pixels gdk_pixbuf_get_pixels(pixbuf)
-    sd rowstride
-    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
-    call rgb_px_set(value,pixels,x,y,bps,n_chan,rowstride)
-endfunction
-
-function rgb_copy(sd srcpixels,sd destpixels,sd left,sd top,sd right,sd bottom,sd rowstride)
-    sd left_start
-    set left_start left
-    while top!=bottom
-        set left left_start
-        while left!=right
-            sd value
-            setcall value rgb_px_get(srcpixels,left,top,8,3,rowstride)
-            call rgb_px_set(value,destpixels,left,top,8,3,rowstride)
-            inc left
-        endwhile
-        inc top
-    endwhile
-endfunction
-
-
-
-
-
-
-##draw
-function draw_expose_text(sd widget,ss text)
-    #get the gdk window
-    importx "_gtk_widget_get_window" gtk_widget_get_window
-    sd wind
-    setcall wind gtk_widget_get_window(widget)
-
-    #creates the cairo context
-    importx "_gdk_cairo_create" gdk_cairo_create
-    sd cairo
-    setcall cairo gdk_cairo_create(wind)
-    import "int_to_double" int_to_double
-    sd cairo_double_low
-    sd cairo_double_high
-    sd p_cairo_double^cairo_double_low
-
-	importx "_cairo_set_source_rgb" cairo_set_source_rgb
-
-	#set white, double 1
-	call cairo_set_source_rgb(cairo,0,0x3fF00000,0,0x3fF00000,0,0x3fF00000)
-	importx "_cairo_paint" cairo_paint
-	call cairo_paint(cairo)
-
-    #set a black source
-    call cairo_set_source_rgb(cairo,0,0,0,0,0,0)
-
-    #set text size
-    importx "_cairo_set_font_size" cairo_set_font_size
-    call int_to_double(20,p_cairo_double)
-    call cairo_set_font_size(cairo,cairo_double_low,cairo_double_high)
-
-    #move to let text space
-    importx "_cairo_move_to" cairo_move_to
-    call cairo_move_to(cairo,0,0,cairo_double_low,cairo_double_high)
-
-    #draw text
-    importx "_cairo_show_text" cairo_show_text
-    call cairo_show_text(cairo,text)
-
-    #free cairo
-    importx "_cairo_destroy" cairo_destroy
-    call cairo_destroy(cairo)
-endfunction
-
-import "get_higher" get_higher
-import "get_lower" get_lower
-
-function pixbuf_draw_text(sd pixbuf,ss text,sd x,sd y,sd size,sd color,sd coordinates_flag)
-    sd width
-    sd height
-    sd p_wh^width
-
-    call pixbuf_get_wh(pixbuf,p_wh)
-
-    importx "_gdk_pixmap_new" gdk_pixmap_new
-    sd pixmap
-    setcall pixmap gdk_pixmap_new(0,width,height,24)
-
-    importx "_gdk_gc_new" gdk_gc_new
-    sd gc
-    setcall gc gdk_gc_new(pixmap)
-
-    importx "_gdk_draw_pixbuf" gdk_draw_pixbuf
-    call gdk_draw_pixbuf(pixmap,gc,pixbuf,0,0,0,0,width,height,(GDK_RGB_DITHER_NONE),0,0)
-
-    importx "_gtk_window_new" gtk_window_new
-    sd scratch
-    setcall scratch gtk_window_new((GTK_WINDOW_TOPLEVEL))
-    importx "_gtk_widget_realize" gtk_widget_realize
-    call gtk_widget_realize(scratch)
-    importx "_gtk_widget_create_pango_layout" gtk_widget_create_pango_layout
-    sd pangolayout
-    setcall pangolayout gtk_widget_create_pango_layout(scratch,0)
-    importx "_gtk_widget_destroy" gtk_widget_destroy
-    call gtk_widget_destroy(scratch)
-
-    importx "_g_strdup_printf" g_strdup_printf
-    ss format="<b><span foreground='#%06x' font='%u'>%s</span></b>"
-    ss markup
-    setcall markup g_strdup_printf(format,color,size,text)
-
-    importx "_pango_layout_set_markup" pango_layout_set_markup
-    call pango_layout_set_markup(pangolayout,markup,-1)
-
-    #determine the positioning method: coordinates(x,y) or location(x factor,y factor)
-    if coordinates_flag==0
-        #location
-        importx "_pango_layout_get_pixel_size" pango_layout_get_pixel_size
-        sd text_width
-        sd text_height
-        sd p_text_width^text_width
-        sd p_text_height^text_height
-        call pango_layout_get_pixel_size(pangolayout,p_text_width,p_text_height)
-
-        sd available_w
-        set available_w width
-        sub available_w text_width
-        setcall available_w get_higher(available_w,0)
-
-        sd available_h
-        set available_h height
-        sub available_h text_height
-        setcall available_h get_higher(available_h,0)
-
-        inc x
-        inc y
-        setcall x rule3(x,2,available_w)
-        setcall y rule3(y,2,available_h)
-    endif
-
-    importx "_gdk_draw_layout" gdk_draw_layout
-    call gdk_draw_layout(pixmap,gc,x,y,pangolayout)
-
-    importx "_gdk_pixbuf_get_from_drawable" gdk_pixbuf_get_from_drawable
-    sd pix_buf
-    setcall pix_buf gdk_pixbuf_get_from_drawable((NULL),pixmap,(NULL),0,0,0,0,width,height)
-
-    importx "_g_free" g_free
-    call g_free(markup)
-    call g_object_unref(pangolayout)
-    call g_object_unref(gc)
-    call g_object_unref(pixmap)
-
-    return pix_buf
-endfunction
-
-
-function draw_default_cursor(sd root,sd def_x,sd def_y,sd width,sd height,sd cairo)
-    importx "_gdk_window_get_pointer" gdk_window_get_pointer
-    sd x
-    sd y
-    sd p_x^x
-    sd p_y^y
-    call gdk_window_get_pointer(root,p_x,p_y,(NULL))
-    sub x def_x
-    sub y def_y
-
-    importx "_gdk_display_get_default" gdk_display_get_default
-    sd display
-    setcall display gdk_display_get_default()
-    if display==0
-        str disp_err="No default display found"
-        call texter(disp_err)
-        return 0
-    endif
-    importx "_gdk_cursor_new_for_display" gdk_cursor_new_for_display
-    importx "_gdk_cursor_get_image" gdk_cursor_get_image
-    importx "_gdk_cursor_unref" gdk_cursor_unref
-    sd Cursor
-    setcall Cursor gdk_cursor_new_for_display(display,(GDK_LEFT_PTR))
-    call draw_cursor(Cursor,x,y,width,height,cairo)
-    call gdk_cursor_unref(Cursor)
-endfunction
-
-function draw_cursor(sd Cursor,sd x,sd y,sd width,sd height,sd cairo)
-    sd cPixbuf
-    setcall cPixbuf gdk_cursor_get_image(Cursor)
-    if cPixbuf==0
-        str pxerr="The cursor image data can't be retrived"
-        call texter(pxerr)
-        return 0
-    endif
-    call draw_pixbuf_cursor(cPixbuf,x,y,width,height,cairo)
-    call g_object_unref(cPixbuf)
-endfunction
-
-function draw_pixbuf_cursor(sd cPixbuf,sd x,sd y,sd width,sd height,sd cairo)
-    #some tests to determine the visible area for overlaying the cursor
-    sd left
-    sd top
-    sd cWidth
-    sd cHeight
-    sd rect^left
-
-    sd bool
-    setcall bool cursor_tests(cPixbuf,x,y,width,height,rect)
-    if bool==0
-        return 0
-    endif
-
-    call cairo_draw_default_cursor(cairo,cPixbuf,x,y,left,top,cWidth,cHeight)
-endfunction
-#bool
-function cursor_tests(sd cPixbuf,sd left,sd top,sd pxWidth,sd pxHeight,sd rect)
-    #if bool,rect get x,y,width,heigth truncated
-    if left>=pxWidth
-        return 0
-    endif
-    if top>=pxHeight
-        return 0
-    endif
-
-    sd cursor_width
-    sd cursor_height
-    sd cursor_wh^cursor_width
-    call pixbuf_get_wh(cPixbuf,cursor_wh)
-
-    sd right
-    set right left
-    add right cursor_width
-    if right<=0
-        return 0
-    endif
-    sd bottom
-    set bottom top
-    add bottom cursor_height
-    if bottom<=0
-        return 0
-    endif
-
-    setcall rect# get_higher(0,left)
-    add rect 4
-    setcall rect# get_higher(0,top)
-    add rect 4
-    setcall rect# get_lower(right,pxWidth)
-    sub rect# left
-    add rect 4
-    setcall rect# get_lower(bottom,pxHeight)
-    sub rect# top
-endfunction
-
-##cairo
-
-function cairo_draw_default_cursor(sd cairo,sd cPixbuf,sd x,sd y,sd left,sd top,sd cWidth,sd cHeight)
-    importx "_gdk_cairo_set_source_pixbuf" gdk_cairo_set_source_pixbuf
-    importx "_cairo_rectangle" cairo_rectangle
-    importx "_cairo_fill" cairo_fill
-    sd double_x_low
-    sd double_x_high
-    sd double_y_low
-    sd double_y_high
-    sd double_x^double_x_low
-    sd double_y^double_y_low
-    call int_to_double(x,double_x)
-    call int_to_double(y,double_y)
-    call gdk_cairo_set_source_pixbuf(cairo,cPixbuf,double_x_low,double_x_high,double_y_low,double_y_high)
-    sd double_left_low
-    sd double_left_high
-    sd double_top_low
-    sd double_top_high
-    sd double_left^double_left_low
-    sd double_top^double_top_low
-    call int_to_double(left,double_left)
-    call int_to_double(top,double_top)
-    sd double_cWidth_low
-    sd double_cWidth_high
-    sd double_cHeight_low
-    sd double_cHeight_high
-    sd double_cWidth^double_cWidth_low
-    sd double_cHeight^double_cHeight_low
-    call int_to_double(cWidth,double_cWidth)
-    call int_to_double(cHeight,double_cHeight)
-    call cairo_rectangle(cairo,double_left_low,double_left_high,double_top_low,double_top_high,double_cWidth_low,double_cWidth_high,double_cHeight_low,double_cHeight_high)
-    call cairo_fill(cairo)
-endfunction
--- /dev/null
+++ ovideo-1/src/obj/items.oc
@@ -0,0 +1,1042 @@
+
+
+format elfobj
+
+importx "_g_object_unref" g_object_unref
+
+include "../_include/include.h"
+
+
+import "packstart" packstart
+import "packstart_default" packstart_default
+import "container_add" container_add
+
+importx "_gtk_button_new" gtk_button_new
+##########button
+importx "_gtk_button_set_label" gtk_button_set_label
+
+function buttonfield_prepare_with_label(ss text)
+    sd button
+    setcall button gtk_button_new()
+    call gtk_button_set_label(button,text)
+    return button
+endfunction
+
+function buttonfield(data container)
+    data gtkwidget#1
+    setcall gtkwidget gtk_button_new()
+    data n=0
+    call packstart(container,gtkwidget,n)
+    return gtkwidget
+endfunction
+
+importx "_gtk_image_new_from_pixbuf" gtk_image_new_from_pixbuf
+
+importx "_gtk_button_set_image" gtk_button_set_image
+#void
+function buttonfield_setimage_call(data gdkpixbuf,data button)
+    data gtkimage#1
+    setcall gtkimage gtk_image_new_from_pixbuf(gdkpixbuf)
+    call gtk_button_set_image(button,gtkimage)
+endfunction
+#void
+function buttonfield_setimage(str filename,data button)
+    data setimage^buttonfield_setimage_call
+    call pixbuf_from_file_forward_data(filename,setimage,button)
+endfunction
+
+#function buttonfield_label(sd box,sd text)
+#    sd button
+#    setcall button buttonfield(box)
+#    call gtk_button_set_label(button,text)
+#    return button
+#endfunction
+
+
+##########color
+#uint32 rgb, little endian with alpha
+function color_widget_get_color_to_rgb(sd color_entry)
+    sd g_color#3
+    #only 2.5
+    sd ptr_g_color^g_color
+    sd value_colors^g_color
+    add value_colors 4
+
+    #the color
+    importx "_gtk_color_button_get_color" gtk_color_button_get_color
+    call gtk_color_button_get_color(color_entry,ptr_g_color)
+
+    sd red_const
+    sd green_const
+    sd blue_const
+
+    import "gdkcolor2byte" gdkcolor2byte
+    setcall red_const gdkcolor2byte(value_colors)
+    add value_colors 2
+    setcall green_const gdkcolor2byte(value_colors)
+    add value_colors 2
+    setcall blue_const gdkcolor2byte(value_colors)
+
+    sd color
+    setcall color colors_to_littlewithalpha_color(red_const,green_const,blue_const)
+    return color
+endfunction
+
+#color
+function color_widget_get_color(sd color_entry)
+    sd g_color#3
+    #only 2.5
+    sd ptr_g_color^g_color
+    sd value_colors^g_color
+    add value_colors 4
+
+    #the color
+    call gtk_color_button_get_color(color_entry,ptr_g_color)
+
+    sd red_const
+    sd green_const
+    sd blue_const
+
+    setcall red_const gdkcolor2byte(value_colors)
+    add value_colors 2
+    setcall green_const gdkcolor2byte(value_colors)
+    add value_colors 2
+    setcall blue_const gdkcolor2byte(value_colors)
+
+    sd color
+    mult red_const (0x100*0x100)
+    mult green_const 0x100
+    set color blue_const
+    or color red_const
+    or color green_const
+    return color
+endfunction
+
+function colors_to_littlewithalpha_color(sd red_const,sd green_const,sd blue_const)
+    sd color
+    mult red_const 0x1000000
+    set color red_const
+    mult green_const 0x10000
+    or color green_const
+    mult blue_const 0x100
+    or color blue_const
+    return color
+endfunction
+
+import "hboxfield_cnt" hboxfield_cnt
+
+#color button
+function colorbuttonfield_leftlabel(ss text,sd box)
+    #the color
+    sd hbox
+    setcall hbox hboxfield_cnt(box)
+    call labelfield_left_default(text,hbox)
+    importx "_gtk_color_button_new" gtk_color_button_new
+    sd color
+    setcall color gtk_color_button_new()
+    call packstart_default(hbox,color)
+    return color
+endfunction
+
+##########draw
+importx "_gtk_drawing_area_new" gtk_drawing_area_new
+#draw
+function drawfield(data container)
+    data GtkWidget#1
+    setcall GtkWidget gtk_drawing_area_new()
+    data true=TRUE
+    call packstart(container,GtkWidget,true)
+    return GtkWidget
+endfunction
+
+function drawfield_cnt(sd container)
+    data GtkWidget#1
+    setcall GtkWidget gtk_drawing_area_new()
+    call container_add(container,GtkWidget)
+    return GtkWidget
+endfunction
+
+############edit
+importx "_gtk_entry_buffer_new" gtk_entry_buffer_new
+importx "_gtk_entry_buffer_set_max_length" gtk_entry_buffer_set_max_length
+importx "_gtk_entry_new_with_buffer" gtk_entry_new_with_buffer
+importx "_g_signal_connect_data" g_signal_connect_data
+#GtkWidget
+function editfield(data container,data length)
+    data GtkWidget#1
+    data null=NULL
+    data GtkEntryBuffer#1
+
+    setcall GtkEntryBuffer gtk_entry_buffer_new(null,null)
+
+    call gtk_entry_buffer_set_max_length(GtkEntryBuffer,length)
+
+    setcall GtkWidget gtk_entry_new_with_buffer(GtkEntryBuffer)
+
+    call g_object_unref(GtkEntryBuffer)
+
+    call packstart(container,GtkWidget,null)
+
+    return GtkWidget
+endfunction
+
+#GtkWidget
+import "recoverEnter" recoverEnter
+function editfieldEnter(data container,data length,data forward)
+    data GtkWidget#1
+    setcall GtkWidget editfield(container,length)
+
+    char key="key-press-event"
+    str keypress^key
+    data enter^recoverEnter
+    data null=NULL
+    call g_signal_connect_data(GtkWidget,keypress,enter,forward,null,null)
+    return GtkWidget
+endfunction
+
+importx "_gtk_entry_get_text" gtk_entry_get_text
+
+#void
+importx "_gtk_entry_set_text" gtk_entry_set_text
+#edit texter
+import "get_current_texter_pointer" get_current_texter_pointer
+function texter(ss text)
+	sd info#1
+	setcall info get_current_texter_pointer()
+	call gtk_entry_set_text(info#,text)
+	call printer(text)
+endfunction
+function printer(ss text)
+    importx "_printf" printf
+    call printf(text)
+    char nl={0xa,0}
+    str newline^nl
+    call printf(newline)
+endfunction
+
+function new_texter_close(sd *dialog,sd previous_texter)
+    #texter pointer
+    sd info
+    setcall info get_current_texter_pointer()
+
+    #replace texter pointer
+    sd text
+    setcall text gtk_entry_get_text(info#)
+    set info# previous_texter
+
+    #pass the text to the previous texter
+    call texter(text)
+endfunction
+
+function new_texter_modal(sd container,sd dialog)
+    sd newtexter
+    setcall newtexter editinfofield_green(container)
+
+    import "connect_signal_data" connect_signal_data
+    str destr="destroy"
+    data f^new_texter_close
+    sd info#1
+    setcall info get_current_texter_pointer()
+    call connect_signal_data(dialog,destr,f,info#)
+
+    set info# newtexter
+endfunction
+#
+
+importx "_gtk_entry_new" gtk_entry_new
+
+function editfield_pack(sd container)
+    sd edit
+    setcall edit gtk_entry_new()
+    call packstart_default(container,edit)
+    return edit
+endfunction
+
+importx "_gtk_box_pack_start" gtk_box_pack_start
+
+#field
+function edit_info_prepare_texter(sd ptrcolors,ss text,sv p_texter)
+	importx "_gtk_editable_set_editable" gtk_editable_set_editable
+	import "setWidgetBase" setWidgetBase
+	sd info
+	setcall info gtk_entry_new() #this can be label but GtkEditable is used once and is ok for now. https://developer-old.gnome.org/gtk2/stable/GtkEditable.html
+	call gtk_editable_set_editable(info,(FALSE))
+	call gtk_entry_set_text(info,text)
+	if p_texter!=(NULL)
+		set p_texter# info
+	endif
+	#importx "_gtk_container_set_border_width" gtk_container_set_border_width
+	#call gtk_container_set_border_width(info,10)
+
+	importx "_gtk_vbox_new" gtk_vbox_new
+	importx "_gtk_container_add" gtk_container_add
+	sd f
+	setcall f gtk_vbox_new((FALSE),0)
+	importx "_gtk_hseparator_new" gtk_hseparator_new
+	sd s
+	setcall s gtk_hseparator_new()
+	call setWidgetBase(s,ptrcolors)
+	call gtk_container_add(f,s)
+
+	importx "_gtk_hbox_new" gtk_hbox_new
+	importx "_gtk_vseparator_new" gtk_vseparator_new
+	sd h
+	setcall h gtk_hbox_new((FALSE),0)
+	setcall s gtk_vseparator_new()
+	call setWidgetBase(s,ptrcolors)
+	call gtk_box_pack_start(h,s,(FALSE),(FALSE),0)
+	call gtk_box_pack_start(h,info,(TRUE),(TRUE),0)
+	setcall s gtk_vseparator_new()
+	call setWidgetBase(s,ptrcolors)
+	call gtk_box_pack_start(h,s,(FALSE),(FALSE),0)
+	call gtk_container_add(f,h)
+
+	setcall s gtk_hseparator_new()
+	call setWidgetBase(s,ptrcolors)
+	call gtk_container_add(f,s)
+	return f
+endfunction
+
+#field
+function edit_info_prepare_green(ss text)
+	sd w
+	setcall w edit_info_prepare_texter_green(text,(NULL))
+	return w
+endfunction
+
+#field
+function edit_info_prepare_blue(ss text)
+    char infocolors={0x00,0x00,0xff}
+    data infoptrcolors^infocolors
+    sd widget
+    setcall widget edit_info_prepare_texter(infoptrcolors,text,(NULL))
+    return widget
+endfunction
+
+#field
+function edit_info_prepare_texter_green(ss text,sd p_texter)
+    char infocolors={0x00,0xff,0x00}
+    data infoptrcolors^infocolors
+    sd widget
+    setcall widget edit_info_prepare_texter(infoptrcolors,text,p_texter)
+    return widget
+endfunction
+
+function editinfofield_green(sd box)
+	sd wid
+	sd field
+	setcall field edit_info_prepare_texter_green("",#wid)
+	call packstart_default(box,field)
+	return wid
+endfunction
+
+function editfield_with_int(sd int)
+    char spc#sign_int_null
+    str intstring^spc
+    str frm="%i"
+    importx "_sprintf" sprintf
+    call sprintf(intstring,frm,int)
+    sd entry
+    setcall entry gtk_entry_new()
+    call gtk_entry_set_text(entry,intstring)
+    return entry
+endfunction
+
+import "strtoint_positive_N_or_Greater" strtoint_positive_N_or_Greater
+
+#void
+function entry_to_nr_minValue(sd entry,sd p_out,sd min)
+    sd text
+    setcall text gtk_entry_get_text(entry)
+    sd bool
+    setcall bool strtoint_positive_N_or_Greater(text,p_out,min)
+    if bool=0
+        set p_out# min
+    endif
+endfunction
+
+function int_to_entry(sd int,sd entry)
+    sd number#4
+    sd p_nr^number
+    ss frm="%i"
+    call sprintf(p_nr,frm,int)
+    call gtk_entry_set_text(entry,p_nr)
+endfunction
+
+#edit return
+function label_and_edit(sd box,ss text)
+    sd hbox
+    setcall hbox hboxfield_cnt(box)
+    call labelfield_l(text,hbox)
+    sd edit
+    setcall edit editfield_pack(hbox)
+    return edit
+endfunction
+
+#bool
+function entry_to_int_min_N(sd entry,sd p_int,sd N)
+    ss text
+    setcall text gtk_entry_get_text(entry)
+    sd bool
+    setcall bool strtoint_positive_N_or_Greater(text,p_int,N)
+    return bool
+endfunction
+
+#bool
+function entry_to_int_min_N_max_M(sd entry,sd p_int,sd N,sd M)
+    sd bool
+    setcall bool entry_to_int_min_N(entry,p_int,N)
+    if bool=0
+        return 0
+    endif
+    if p_int#>M
+        import "strdworddisp" strdworddisp
+        str errnr="Expecting a number lower or equal with "
+        call strdworddisp(errnr,M)
+        return 0
+    endif
+    return 1
+endfunction
+
+##############hscale
+function hscalefield_main(sd box,sd min,sd max,sd step,sd pos,sd packexpand)
+    import "int_to_double" int_to_double
+
+    importx "_gtk_hscale_new_with_range" gtk_hscale_new_with_range
+    sd min_d_low
+    sd min_d_high
+    sd max_d_low
+    sd max_d_high
+    sd step_d_low
+    sd step_d_high
+    sd p_min_d^min_d_low
+    sd p_max_d^max_d_low
+    sd p_step_d^step_d_low
+    call int_to_double(min,p_min_d)
+    call int_to_double(max,p_max_d)
+    call int_to_double(step,p_step_d)
+
+    sd hscale
+    setcall hscale gtk_hscale_new_with_range(min_d_low,min_d_high,max_d_low,max_d_high,step_d_low,step_d_high)
+
+    importx "_gtk_range_set_value" gtk_range_set_value
+    sd doublepos_low
+    sd doublepos_high
+    sd p_doublepos^doublepos_low
+    call int_to_double(pos,p_doublepos)
+    call gtk_range_set_value(hscale,doublepos_low,doublepos_high)
+
+    call packstart(box,hscale,packexpand)
+
+    return hscale
+endfunction
+
+function hscalefield(sd box,sd min,sd max,sd step,sd pos)
+    sd hscale
+    setcall hscale hscalefield_main(box,min,max,step,pos,(TRUE))
+    return hscale
+endfunction
+
+#int pos
+function hscale_get(sd hscale)
+    importx "_gtk_range_get_value" gtk_range_get_value
+    sd value
+    sd p_value^value
+    import "fistp" fistp
+    call gtk_range_get_value(hscale)
+    call fistp(p_value)
+    return value
+endfunction
+
+##############hseparator
+function hseparatorfield(sd box)
+    sd hsep
+    setcall hsep gtk_hseparator_new()
+    import "boxpackstart" boxpackstart
+    call boxpackstart(box,hsep,0,10)
+    return hsep
+endfunction
+
+function hseparatorfield_nopad(sd box)
+    sd hsep
+    setcall hsep gtk_hseparator_new()
+    call packstart_default(box,hsep)
+    return hsep
+endfunction
+
+function hseparatorfield_table(sd table)
+    sd hsep
+    setcall hsep gtk_hseparator_new()
+    import "table_add_row" table_add_row
+    call table_add_row(table,hsep)
+    return hsep
+endfunction
+
+##############icon
+importx "_gtk_window_set_icon" gtk_window_set_icon
+function window_set_icon(sd pixbuf,sd window)
+    call gtk_window_set_icon(window,pixbuf)
+endfunction
+function setwndicon(data window,str filename)
+    data icon^window_set_icon
+    call pixbuf_from_file_forward_data(filename,icon,window)
+endfunction
+
+
+
+importx "_gtk_widget_new" gtk_widget_new
+importx "_gtk_label_get_type" gtk_label_get_type
+##############label
+function labelfield_left_prepare(ss text)
+    sd widget
+    sd GTK_TYPE_LABEL
+    str label="label"
+    str x="xalign"
+    data left=0
+    data n=0
+
+    setcall GTK_TYPE_LABEL gtk_label_get_type()
+    setcall widget gtk_widget_new(GTK_TYPE_LABEL,label,text,x,left,left,n)
+    return widget
+endfunction
+function labelfield_l(ss text,sd box)
+    sd label
+    setcall label labelfield_left_prepare(text)
+    call packstart(box,label,(TRUE))
+    return label
+endfunction
+function labelfield_left_default(ss text,sd box)
+    sd label
+    setcall label labelfield_left_prepare(text)
+    call packstart(box,label,(FALSE))
+    return label
+endfunction
+
+function labelfield_left_table(ss text,sd table)
+    sd label
+    setcall label labelfield_left_prepare(text)
+    call table_add_row(table,label)
+    return label
+endfunction
+
+#########message dialog
+function message_dialog(sd print)
+    import "mainwidget" mainwidget
+    sd main
+    setcall main mainwidget()
+    importx "_gtk_message_dialog_new" gtk_message_dialog_new
+    importx "_gtk_dialog_run" gtk_dialog_run
+    importx "_gtk_widget_destroy" gtk_widget_destroy
+    sd dialog
+    setcall dialog gtk_message_dialog_new(main,(GTK_DIALOG_DESTROY_WITH_PARENT),(GTK_MESSAGE_INFO),(GTK_BUTTONS_OK),print)
+    call gtk_dialog_run(dialog)
+    call gtk_widget_destroy(dialog)
+endfunction
+
+##############pixbuf
+#pixbuf/0
+function new_pixbuf(sd width,sd height)
+    importx "_gdk_pixbuf_new" gdk_pixbuf_new
+    sd pixbuf
+    setcall pixbuf gdk_pixbuf_new((GDK_COLORSPACE_RGB),0,8,width,height)
+    if pixbuf=0
+        str pxerr="Can't create a pixbuf"
+        call texter(pxerr)
+        return 0
+    endif
+    return pixbuf
+endfunction
+
+#pixbuf/0
+function new_pixbuf_color(sd width,sd height,sd color)
+    sd pixbuf
+    setcall pixbuf new_pixbuf(width,height)
+    if pixbuf=0
+        return 0
+    endif
+    importx "_gdk_pixbuf_fill" gdk_pixbuf_fill
+    call gdk_pixbuf_fill(pixbuf,color)
+    return pixbuf
+endfunction
+
+#return a pixbuf
+function msgelement_pixbuf(sd msg)
+    importx "_gst_message_get_structure" gst_message_get_structure
+    sd struct
+    setcall struct gst_message_get_structure(msg)
+
+    str pix="pixbuf"
+    importx "_gst_structure_get_value" gst_structure_get_value
+    sd value
+    setcall value gst_structure_get_value(struct,pix)
+
+    importx "_g_value_dup_object" g_value_dup_object
+    sd pixbuf
+    setcall pixbuf g_value_dup_object(value)
+
+    return pixbuf
+endfunction
+
+function msgelement_pixbuf_forward_data(sd msg,sv forward,sd data)
+    sd pixbuf
+    setcall pixbuf msgelement_pixbuf(msg)
+
+    call forward(pixbuf,data)
+
+    call g_object_unref(pixbuf)
+endfunction
+
+importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
+importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
+importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
+importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
+
+import "rgb_px_get" rgb_px_get
+import "rgb_px_set" rgb_px_set
+
+#0/pixbuf
+function pixbuf_scale(sd pixbuf,sd w,sd h)
+    sd newpixbuf
+    setcall newpixbuf new_pixbuf(w,h)
+    if newpixbuf=0
+        return 0
+    endif
+    sd old_w
+    sd old_h
+    setcall old_w gdk_pixbuf_get_width(pixbuf)
+    setcall old_h gdk_pixbuf_get_height(pixbuf)
+
+    sd w_ratio
+    set w_ratio old_w
+    div w_ratio w
+    if w_ratio=0
+        set w_ratio 1
+    endif
+    sd h_ratio
+    set h_ratio old_h
+    div h_ratio h
+    if h_ratio=0
+        set h_ratio 1
+    endif
+
+    sd red
+    sd green
+    sd blue
+    sd colors^red
+    sd sum_red
+    sd sum_green
+    sd sum_blue
+    sd sum_colors^sum_red
+
+    sd old_pixels
+    sd pixels
+    setcall old_pixels gdk_pixbuf_get_pixels(pixbuf)
+    setcall pixels gdk_pixbuf_get_pixels(newpixbuf)
+    sd old_stride
+    sd stride
+    setcall old_stride gdk_pixbuf_get_rowstride(pixbuf)
+    setcall stride gdk_pixbuf_get_rowstride(newpixbuf)
+
+    sd j=0
+    while j!=h
+        import "rule3" rule3
+        sd top
+        setcall top rule3(j,h,old_h)
+        sd bottom
+        set bottom top
+        add bottom h_ratio
+        if bottom>old_h
+            set bottom old_h
+        endif
+        #left,right.. on old pixbuf
+        sd i=0
+        while i!=w
+            sd left
+            setcall left rule3(i,w,old_w)
+            sd right
+            set right left
+            add right w_ratio
+            if right>old_w
+                set right old_w
+            endif
+
+            import "rgb_uint_to_colors" rgb_uint_to_colors
+            import "rgb_colors_to_uint" rgb_colors_to_uint
+
+            sd number_of_colors=0
+
+            sd x
+            sd y
+            set y top
+            while y!=bottom
+                set x left
+                while x!=right
+                    sd value
+                    setcall value rgb_px_get(old_pixels,x,y,8,3,old_stride)
+
+                    if number_of_colors=0
+                        call rgb_uint_to_colors(value,sum_colors)
+                    else
+                        call rgb_uint_to_colors(value,colors)
+                        add sum_red red
+                        add sum_green green
+                        add sum_blue blue
+                    endelse
+
+                    inc number_of_colors
+                    inc x
+                endwhile
+                inc y
+            endwhile
+            div sum_red number_of_colors
+            div sum_green number_of_colors
+            div sum_blue number_of_colors
+
+            setcall value rgb_colors_to_uint(sum_colors)
+            call rgb_px_set(value,pixels,i,j,8,3,stride)
+
+            inc i
+        endwhile
+        inc j
+    endwhile
+    return newpixbuf
+endfunction
+
+function pixbuf_scale_forward_data(sd pixbuf,sd scale_w,sd scale_h,sv forward,sd data)
+    sd newpix
+
+    setcall newpix pixbuf_scale(pixbuf,scale_w,scale_h)
+    if newpix=0
+        return (error)
+    endif
+
+    call forward(newpix,data)
+
+    call g_object_unref(newpix)
+endfunction
+
+#forward the fit pixbuf in window
+function pixbuf_in_window_scale_forward(sd pixbuf,sd window,sd forward)
+    sd W
+    sd H
+    sd p_H^H
+
+    sd w
+    sd h
+
+    importx "_gdk_window_get_width" gdk_window_get_width
+    importx "_gdk_window_get_height" gdk_window_get_height
+
+    setcall W gdk_window_get_width(window)
+    if W=0
+        return 0
+    endif
+    setcall H gdk_window_get_height(window)
+    if H=0
+        return 0
+    endif
+    setcall w gdk_pixbuf_get_width(pixbuf)
+    setcall h gdk_pixbuf_get_height(pixbuf)
+
+    import "rectangle_fit_container_rectangle" rectangle_fit_container_rectangle
+    setcall W rectangle_fit_container_rectangle(w,h,W,H,p_H)
+
+    call pixbuf_scale_forward_data(pixbuf,W,H,forward,window)
+endfunction
+
+
+
+#forward a pixbuf
+include "../_include/difl.h" "../_include/difw.h"
+import "gerrtoerr" gerrtoerr
+import "getptrgerr" getptrgerr
+#function pixbuf from file
+function pixbuf_from_file(ss filename)
+	sd pixbuf#1
+	sd ptrgerror#1
+
+	setcall ptrgerror getptrgerr()
+
+	setcall pixbuf gdk_pixbuf_new_from_file(filename,ptrgerror)
+	if pixbuf!=(NULL)
+		import "rgb_test" rgb_test
+		setcall pixbuf rgb_test(pixbuf)
+		if pixbuf!=(NULL)
+			return pixbuf
+		endif
+		call g_object_unref(pixbuf)
+		return (NULL)
+	endif
+	call gerrtoerr(ptrgerror)
+	return (NULL)
+endfunction
+#returns the forward or null
+function pixbuf_from_file_forward_data(ss filename,sv forward,sd data)
+    sd pixbuf
+    setcall pixbuf pixbuf_from_file(filename)
+    sd null=0
+    if pixbuf=null
+        return null
+    endif
+    sd ret
+    setcall ret forward(pixbuf,data)
+    call g_object_unref(pixbuf)
+    return ret
+endfunction
+
+#function pixbuf_from_file_forward(ss filename,sd forward)
+#    data z=0
+#    call pixbuf_from_file_forward_data(filename,forward,z)
+#endfunction
+
+importx "_gdk_pixbuf_copy" gdk_pixbuf_copy
+function pixbuf_copy(sd pixbuf)
+    sd px
+    setcall px gdk_pixbuf_copy(pixbuf)
+    if px=0
+        str er="Could not create a pixbuf"
+        call texter(er)
+        return 0
+    endif
+    return px
+endfunction
+
+function pixbuf_get_wh(sd pixbuf,sd p_coord)
+    setcall p_coord# gdk_pixbuf_get_width(pixbuf)
+    add p_coord 4
+    setcall p_coord# gdk_pixbuf_get_height(pixbuf)
+endfunction
+
+#rowstride
+#function pixbuf_get_wh_rowstride_pixels(sd pixbuf,sd p_p,sd wh)
+#    setcall p_p# gdk_pixbuf_get_pixels(pixbuf)
+#    call pixbuf_get_wh(pixbuf,wh)
+#    sd rw
+#    setcall rw gdk_pixbuf_get_rowstride(pixbuf)
+#    return rw
+#endfunction
+
+#0/pixbuf
+function pixbuf_new_subpixels(sd pixbuf,sd left,sd top,sd right,sd bottom)
+    sd w
+    sd h
+    set w right
+    sub w left
+    set h bottom
+    sub h top
+
+    sd newpixbuf
+    setcall newpixbuf new_pixbuf(w,h)
+    if newpixbuf=0
+        return 0
+    endif
+
+    sd pixels
+    sd newbytes
+    setcall pixels gdk_pixbuf_get_pixels(pixbuf)
+    setcall newbytes gdk_pixbuf_get_pixels(newpixbuf)
+
+    sd mainwidth
+    sd mainheight
+    sd rowstr
+    setcall mainwidth gdk_pixbuf_get_width(pixbuf)
+    setcall mainheight gdk_pixbuf_get_height(pixbuf)
+    setcall rowstr gdk_pixbuf_get_rowstride(pixbuf)
+
+    import "rgb_get_all_sizes" rgb_get_all_sizes
+    sd rowstride
+    sd p_rowstride^rowstride
+    call rgb_get_all_sizes(w,h,p_rowstride)
+
+    sd i
+    sd j
+
+    sd y=0
+
+    set j top
+    while j!=bottom
+        set i left
+        sd x=0
+        while i!=right
+            sd value
+            setcall value rgb_px_get(pixels,i,j,8,3,rowstr)
+            call rgb_px_set(value,newbytes,x,y,8,3,rowstride)
+            inc i
+            inc x
+        endwhile
+        inc j
+        inc y
+    endwhile
+    return newpixbuf
+endfunction
+
+#display the pixbuf
+function pixbuf_draw_onwindow(sd pixbuf,sd drawable)
+    data diether=GDK_RGB_DITHER_NONE
+    importx "_gdk_draw_pixbuf" gdk_draw_pixbuf
+    #(GdkDrawable *drawable,GdkGC *gc,const GdkPixbuf *pixbuf,
+    #gint src_x,gint src_y,gint dest_x,gint dest_y,
+    #gint width,gint height,GdkRgbDither dither,gint x_dither,gint y_dither)
+    data default_size=-1
+    data null=0
+    call gdk_draw_pixbuf(drawable,null,pixbuf,null,null,null,null,default_size,default_size,diether,null,null)
+endfunction
+
+function pixbuf_set_pixel(sd pixbuf,sd value,sd x,sd y)
+    sd bytes
+    sd rowstride
+    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
+    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
+    call rgb_px_set(value,bytes,x,y,8,3,rowstride)
+endfunction
+
+#value
+function pixbuf_get_pixel(sd pixbuf,sd x,sd y)
+    sd bytes
+    sd rowstride
+    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
+    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
+    sd value
+    setcall value rgb_px_get(bytes,x,y,8,3,rowstride)
+    return value
+endfunction
+
+function pixbuf_over_pixbuf(sd overpixbuf,sd laypixbuf,sd min_i,sd max_i,sd min_j,sd max_j)
+    sd y=0
+    sd i
+    sd j
+    set j min_j
+    while j!=max_j
+    sd x=0
+        set i min_i
+        while i!=max_i
+            sd value
+            setcall value pixbuf_get_pixel(overpixbuf,x,y)
+            call pixbuf_set_pixel(laypixbuf,value,i,j)
+            inc x
+            inc i
+        endwhile
+        inc y
+        inc j
+    endwhile
+endfunction
+
+function surface_to_pixbufdata(sd surface,sd pixbuf)
+    sd width
+    sd height
+    sd wh^width
+    call pixbuf_get_wh(pixbuf,wh)
+    importx "_cairo_image_surface_get_data" cairo_image_surface_get_data
+    sd bytes
+    setcall bytes cairo_image_surface_get_data(surface)
+    sd pixels
+    setcall pixels gdk_pixbuf_get_pixels(pixbuf)
+    import "rgb_get_rowstride" rgb_get_rowstride
+    sd p_stride
+    setcall p_stride rgb_get_rowstride(width)
+    sd b_stride
+    set b_stride width
+    mult b_stride 4
+
+    sd b_sz
+    set b_sz b_stride
+    mult b_sz height
+    sub b_sz b_stride
+    add bytes b_sz
+
+    import "convert_row_rgba_to_rgb" convert_row_rgba_to_rgb
+    sd j=0
+    while j!=height
+        call convert_row_rgba_to_rgb(bytes,pixels,width)
+
+        sub bytes b_stride
+        add pixels p_stride
+        inc j
+    endwhile
+endfunction
+
+#pixbuf/0
+function pixbuf_from_pixbuf_reverse(sd pixbuf_reverse)
+	#the new pixbuf
+	sd pixbuf
+	setcall pixbuf pixbuf_copy(pixbuf_reverse)
+	if pixbuf=0
+		return 0
+	endif
+
+	#get width height
+	sd w
+	sd h
+	sd p_wh^w
+	call pixbuf_get_wh(pixbuf,p_wh)
+	#reverse bytes
+	sd bytes
+	setcall bytes gdk_pixbuf_get_pixels(pixbuf)
+	import "rgb_color_swap" rgb_color_swap
+	call rgb_color_swap(bytes,w,h)
+
+	return pixbuf
+endfunction
+
+##############progressbar
+importx "_gtk_progress_bar_new" gtk_progress_bar_new
+function progressfield(sd container)
+    sd wid
+    setcall wid gtk_progress_bar_new()
+    data true=1
+    data false=0
+    call gtk_box_pack_start(container,wid,true,false,false)
+    return wid
+endfunction
+
+##############radio
+#function radiofield_prepare(sd previousbutton,ss text)
+#    importx "_gtk_radio_button_new_with_label" gtk_radio_button_new_with_label
+#    importx "_gtk_radio_button_get_group" gtk_radio_button_get_group
+
+#    sd radiogroup
+#    setcall radiogroup gtk_radio_button_get_group(previousbutton)
+
+#    sd rd
+#    setcall rd gtk_radio_button_new_with_label(radiogroup,text)
+#    return rd
+#endfunction
+
+#function radiofield(sd previousbutton,ss text,sd box)
+#    sd rd
+#    setcall rd radiofield_prepare(previousbutton,text)
+#    call packstart_default(box,rd)
+#    return rd
+#endfunction
+
+##############widget
+#ancestor
+function widget_get_ancestor(sd widget,sd ancestor_parent)
+    importx "_gtk_widget_get_parent" gtk_widget_get_parent
+    sd ancestor
+    while widget!=ancestor_parent
+        set ancestor widget
+        setcall widget gtk_widget_get_parent(widget)
+    endwhile
+    return ancestor
+endfunction
+
+function widget_draw_pixbuf(sd widget,sd pixbuf)
+    importx "_gtk_widget_get_window" gtk_widget_get_window
+    sd drawable
+    setcall drawable gtk_widget_get_window(widget)
+    data fn^pixbuf_draw_onwindow
+    call pixbuf_in_window_scale_forward(pixbuf,drawable,fn)
+endfunction
+
+function widget_redraw(sd widget)
+    sd drawable
+    setcall drawable gtk_widget_get_window(widget)
+    if drawable=0
+        str nodraw="No drawing area error."
+        call texter(nodraw)
+        return nodraw
+    endif
+    importx "_gdk_window_invalidate_rect" gdk_window_invalidate_rect
+    call gdk_window_invalidate_rect(drawable,0,0)
+endfunction
--- ovideo-1.orig/src/obj/items.s
+++ /dev/null
@@ -1,1042 +0,0 @@
-
-
-format elfobj
-
-importx "_g_object_unref" g_object_unref
-
-include "../_include/include.h"
-
-
-import "packstart" packstart
-import "packstart_default" packstart_default
-import "container_add" container_add
-
-importx "_gtk_button_new" gtk_button_new
-##########button
-importx "_gtk_button_set_label" gtk_button_set_label
-
-function buttonfield_prepare_with_label(ss text)
-    sd button
-    setcall button gtk_button_new()
-    call gtk_button_set_label(button,text)
-    return button
-endfunction
-
-function buttonfield(data container)
-    data gtkwidget#1
-    setcall gtkwidget gtk_button_new()
-    data n=0
-    call packstart(container,gtkwidget,n)
-    return gtkwidget
-endfunction
-
-importx "_gtk_image_new_from_pixbuf" gtk_image_new_from_pixbuf
-
-importx "_gtk_button_set_image" gtk_button_set_image
-#void
-function buttonfield_setimage_call(data gdkpixbuf,data button)
-    data gtkimage#1
-    setcall gtkimage gtk_image_new_from_pixbuf(gdkpixbuf)
-    call gtk_button_set_image(button,gtkimage)
-endfunction
-#void
-function buttonfield_setimage(str filename,data button)
-    data setimage^buttonfield_setimage_call
-    call pixbuf_from_file_forward_data(filename,setimage,button)
-endfunction
-
-#function buttonfield_label(sd box,sd text)
-#    sd button
-#    setcall button buttonfield(box)
-#    call gtk_button_set_label(button,text)
-#    return button
-#endfunction
-
-
-##########color
-#uint32 rgb, little endian with alpha
-function color_widget_get_color_to_rgb(sd color_entry)
-    sd g_color#3
-    #only 2.5
-    sd ptr_g_color^g_color
-    sd value_colors^g_color
-    add value_colors 4
-
-    #the color
-    importx "_gtk_color_button_get_color" gtk_color_button_get_color
-    call gtk_color_button_get_color(color_entry,ptr_g_color)
-
-    sd red_const
-    sd green_const
-    sd blue_const
-
-    import "gdkcolor2byte" gdkcolor2byte
-    setcall red_const gdkcolor2byte(value_colors)
-    add value_colors 2
-    setcall green_const gdkcolor2byte(value_colors)
-    add value_colors 2
-    setcall blue_const gdkcolor2byte(value_colors)
-
-    sd color
-    setcall color colors_to_littlewithalpha_color(red_const,green_const,blue_const)
-    return color
-endfunction
-
-#color
-function color_widget_get_color(sd color_entry)
-    sd g_color#3
-    #only 2.5
-    sd ptr_g_color^g_color
-    sd value_colors^g_color
-    add value_colors 4
-
-    #the color
-    call gtk_color_button_get_color(color_entry,ptr_g_color)
-
-    sd red_const
-    sd green_const
-    sd blue_const
-
-    setcall red_const gdkcolor2byte(value_colors)
-    add value_colors 2
-    setcall green_const gdkcolor2byte(value_colors)
-    add value_colors 2
-    setcall blue_const gdkcolor2byte(value_colors)
-
-    sd color
-    mult red_const (0x100*0x100)
-    mult green_const 0x100
-    set color blue_const
-    or color red_const
-    or color green_const
-    return color
-endfunction
-
-function colors_to_littlewithalpha_color(sd red_const,sd green_const,sd blue_const)
-    sd color
-    mult red_const 0x1000000
-    set color red_const
-    mult green_const 0x10000
-    or color green_const
-    mult blue_const 0x100
-    or color blue_const
-    return color
-endfunction
-
-import "hboxfield_cnt" hboxfield_cnt
-
-#color button
-function colorbuttonfield_leftlabel(ss text,sd box)
-    #the color
-    sd hbox
-    setcall hbox hboxfield_cnt(box)
-    call labelfield_left_default(text,hbox)
-    importx "_gtk_color_button_new" gtk_color_button_new
-    sd color
-    setcall color gtk_color_button_new()
-    call packstart_default(hbox,color)
-    return color
-endfunction
-
-##########draw
-importx "_gtk_drawing_area_new" gtk_drawing_area_new
-#draw
-function drawfield(data container)
-    data GtkWidget#1
-    setcall GtkWidget gtk_drawing_area_new()
-    data true=TRUE
-    call packstart(container,GtkWidget,true)
-    return GtkWidget
-endfunction
-
-function drawfield_cnt(sd container)
-    data GtkWidget#1
-    setcall GtkWidget gtk_drawing_area_new()
-    call container_add(container,GtkWidget)
-    return GtkWidget
-endfunction
-
-############edit
-importx "_gtk_entry_buffer_new" gtk_entry_buffer_new
-importx "_gtk_entry_buffer_set_max_length" gtk_entry_buffer_set_max_length
-importx "_gtk_entry_new_with_buffer" gtk_entry_new_with_buffer
-importx "_g_signal_connect_data" g_signal_connect_data
-#GtkWidget
-function editfield(data container,data length)
-    data GtkWidget#1
-    data null=NULL
-    data GtkEntryBuffer#1
-
-    setcall GtkEntryBuffer gtk_entry_buffer_new(null,null)
-
-    call gtk_entry_buffer_set_max_length(GtkEntryBuffer,length)
-
-    setcall GtkWidget gtk_entry_new_with_buffer(GtkEntryBuffer)
-
-    call g_object_unref(GtkEntryBuffer)
-
-    call packstart(container,GtkWidget,null)
-
-    return GtkWidget
-endfunction
-
-#GtkWidget
-import "recoverEnter" recoverEnter
-function editfieldEnter(data container,data length,data forward)
-    data GtkWidget#1
-    setcall GtkWidget editfield(container,length)
-
-    char key="key-press-event"
-    str keypress^key
-    data enter^recoverEnter
-    data null=NULL
-    call g_signal_connect_data(GtkWidget,keypress,enter,forward,null,null)
-    return GtkWidget
-endfunction
-
-importx "_gtk_entry_get_text" gtk_entry_get_text
-
-#void
-importx "_gtk_entry_set_text" gtk_entry_set_text
-#edit texter
-import "get_current_texter_pointer" get_current_texter_pointer
-function texter(ss text)
-	sd info#1
-	setcall info get_current_texter_pointer()
-	call gtk_entry_set_text(info#,text)
-	call printer(text)
-endfunction
-function printer(ss text)
-    importx "_printf" printf
-    call printf(text)
-    char nl={0xa,0}
-    str newline^nl
-    call printf(newline)
-endfunction
-
-function new_texter_close(sd *dialog,sd previous_texter)
-    #texter pointer
-    sd info
-    setcall info get_current_texter_pointer()
-
-    #replace texter pointer
-    sd text
-    setcall text gtk_entry_get_text(info#)
-    set info# previous_texter
-
-    #pass the text to the previous texter
-    call texter(text)
-endfunction
-
-function new_texter_modal(sd container,sd dialog)
-    sd newtexter
-    setcall newtexter editinfofield_green(container)
-
-    import "connect_signal_data" connect_signal_data
-    str destr="destroy"
-    data f^new_texter_close
-    sd info#1
-    setcall info get_current_texter_pointer()
-    call connect_signal_data(dialog,destr,f,info#)
-
-    set info# newtexter
-endfunction
-#
-
-importx "_gtk_entry_new" gtk_entry_new
-
-function editfield_pack(sd container)
-    sd edit
-    setcall edit gtk_entry_new()
-    call packstart_default(container,edit)
-    return edit
-endfunction
-
-importx "_gtk_box_pack_start" gtk_box_pack_start
-
-#field
-function edit_info_prepare_texter(sd ptrcolors,ss text,sv p_texter)
-	importx "_gtk_editable_set_editable" gtk_editable_set_editable
-	import "setWidgetBase" setWidgetBase
-	sd info
-	setcall info gtk_entry_new() #this can be label but GtkEditable is used once and is ok for now. https://developer-old.gnome.org/gtk2/stable/GtkEditable.html
-	call gtk_editable_set_editable(info,(FALSE))
-	call gtk_entry_set_text(info,text)
-	if p_texter!=(NULL)
-		set p_texter# info
-	endif
-	#importx "_gtk_container_set_border_width" gtk_container_set_border_width
-	#call gtk_container_set_border_width(info,10)
-
-	importx "_gtk_vbox_new" gtk_vbox_new
-	importx "_gtk_container_add" gtk_container_add
-	sd f
-	setcall f gtk_vbox_new((FALSE),0)
-	importx "_gtk_hseparator_new" gtk_hseparator_new
-	sd s
-	setcall s gtk_hseparator_new()
-	call setWidgetBase(s,ptrcolors)
-	call gtk_container_add(f,s)
-
-	importx "_gtk_hbox_new" gtk_hbox_new
-	importx "_gtk_vseparator_new" gtk_vseparator_new
-	sd h
-	setcall h gtk_hbox_new((FALSE),0)
-	setcall s gtk_vseparator_new()
-	call setWidgetBase(s,ptrcolors)
-	call gtk_box_pack_start(h,s,(FALSE),(FALSE),0)
-	call gtk_box_pack_start(h,info,(TRUE),(TRUE),0)
-	setcall s gtk_vseparator_new()
-	call setWidgetBase(s,ptrcolors)
-	call gtk_box_pack_start(h,s,(FALSE),(FALSE),0)
-	call gtk_container_add(f,h)
-
-	setcall s gtk_hseparator_new()
-	call setWidgetBase(s,ptrcolors)
-	call gtk_container_add(f,s)
-	return f
-endfunction
-
-#field
-function edit_info_prepare_green(ss text)
-	sd w
-	setcall w edit_info_prepare_texter_green(text,(NULL))
-	return w
-endfunction
-
-#field
-function edit_info_prepare_blue(ss text)
-    char infocolors={0x00,0x00,0xff}
-    data infoptrcolors^infocolors
-    sd widget
-    setcall widget edit_info_prepare_texter(infoptrcolors,text,(NULL))
-    return widget
-endfunction
-
-#field
-function edit_info_prepare_texter_green(ss text,sd p_texter)
-    char infocolors={0x00,0xff,0x00}
-    data infoptrcolors^infocolors
-    sd widget
-    setcall widget edit_info_prepare_texter(infoptrcolors,text,p_texter)
-    return widget
-endfunction
-
-function editinfofield_green(sd box)
-	sd wid
-	sd field
-	setcall field edit_info_prepare_texter_green("",#wid)
-	call packstart_default(box,field)
-	return wid
-endfunction
-
-function editfield_with_int(sd int)
-    char spc#sign_int_null
-    str intstring^spc
-    str frm="%i"
-    importx "_sprintf" sprintf
-    call sprintf(intstring,frm,int)
-    sd entry
-    setcall entry gtk_entry_new()
-    call gtk_entry_set_text(entry,intstring)
-    return entry
-endfunction
-
-import "strtoint_positive_N_or_Greater" strtoint_positive_N_or_Greater
-
-#void
-function entry_to_nr_minValue(sd entry,sd p_out,sd min)
-    sd text
-    setcall text gtk_entry_get_text(entry)
-    sd bool
-    setcall bool strtoint_positive_N_or_Greater(text,p_out,min)
-    if bool==0
-        set p_out# min
-    endif
-endfunction
-
-function int_to_entry(sd int,sd entry)
-    sd number#4
-    sd p_nr^number
-    ss frm="%i"
-    call sprintf(p_nr,frm,int)
-    call gtk_entry_set_text(entry,p_nr)
-endfunction
-
-#edit return
-function label_and_edit(sd box,ss text)
-    sd hbox
-    setcall hbox hboxfield_cnt(box)
-    call labelfield_l(text,hbox)
-    sd edit
-    setcall edit editfield_pack(hbox)
-    return edit
-endfunction
-
-#bool
-function entry_to_int_min_N(sd entry,sd p_int,sd N)
-    ss text
-    setcall text gtk_entry_get_text(entry)
-    sd bool
-    setcall bool strtoint_positive_N_or_Greater(text,p_int,N)
-    return bool
-endfunction
-
-#bool
-function entry_to_int_min_N_max_M(sd entry,sd p_int,sd N,sd M)
-    sd bool
-    setcall bool entry_to_int_min_N(entry,p_int,N)
-    if bool==0
-        return 0
-    endif
-    if p_int#>M
-        import "strdworddisp" strdworddisp
-        str errnr="Expecting a number lower or equal with "
-        call strdworddisp(errnr,M)
-        return 0
-    endif
-    return 1
-endfunction
-
-##############hscale
-function hscalefield_main(sd box,sd min,sd max,sd step,sd pos,sd packexpand)
-    import "int_to_double" int_to_double
-
-    importx "_gtk_hscale_new_with_range" gtk_hscale_new_with_range
-    sd min_d_low
-    sd min_d_high
-    sd max_d_low
-    sd max_d_high
-    sd step_d_low
-    sd step_d_high
-    sd p_min_d^min_d_low
-    sd p_max_d^max_d_low
-    sd p_step_d^step_d_low
-    call int_to_double(min,p_min_d)
-    call int_to_double(max,p_max_d)
-    call int_to_double(step,p_step_d)
-
-    sd hscale
-    setcall hscale gtk_hscale_new_with_range(min_d_low,min_d_high,max_d_low,max_d_high,step_d_low,step_d_high)
-
-    importx "_gtk_range_set_value" gtk_range_set_value
-    sd doublepos_low
-    sd doublepos_high
-    sd p_doublepos^doublepos_low
-    call int_to_double(pos,p_doublepos)
-    call gtk_range_set_value(hscale,doublepos_low,doublepos_high)
-
-    call packstart(box,hscale,packexpand)
-
-    return hscale
-endfunction
-
-function hscalefield(sd box,sd min,sd max,sd step,sd pos)
-    sd hscale
-    setcall hscale hscalefield_main(box,min,max,step,pos,(TRUE))
-    return hscale
-endfunction
-
-#int pos
-function hscale_get(sd hscale)
-    importx "_gtk_range_get_value" gtk_range_get_value
-    sd value
-    sd p_value^value
-    import "fistp" fistp
-    call gtk_range_get_value(hscale)
-    call fistp(p_value)
-    return value
-endfunction
-
-##############hseparator
-function hseparatorfield(sd box)
-    sd hsep
-    setcall hsep gtk_hseparator_new()
-    import "boxpackstart" boxpackstart
-    call boxpackstart(box,hsep,0,10)
-    return hsep
-endfunction
-
-function hseparatorfield_nopad(sd box)
-    sd hsep
-    setcall hsep gtk_hseparator_new()
-    call packstart_default(box,hsep)
-    return hsep
-endfunction
-
-function hseparatorfield_table(sd table)
-    sd hsep
-    setcall hsep gtk_hseparator_new()
-    import "table_add_row" table_add_row
-    call table_add_row(table,hsep)
-    return hsep
-endfunction
-
-##############icon
-importx "_gtk_window_set_icon" gtk_window_set_icon
-function window_set_icon(sd pixbuf,sd window)
-    call gtk_window_set_icon(window,pixbuf)
-endfunction
-function setwndicon(data window,str filename)
-    data icon^window_set_icon
-    call pixbuf_from_file_forward_data(filename,icon,window)
-endfunction
-
-
-
-importx "_gtk_widget_new" gtk_widget_new
-importx "_gtk_label_get_type" gtk_label_get_type
-##############label
-function labelfield_left_prepare(ss text)
-    sd widget
-    sd GTK_TYPE_LABEL
-    str label="label"
-    str x="xalign"
-    data left=0
-    data n=0
-
-    setcall GTK_TYPE_LABEL gtk_label_get_type()
-    setcall widget gtk_widget_new(GTK_TYPE_LABEL,label,text,x,left,left,n)
-    return widget
-endfunction
-function labelfield_l(ss text,sd box)
-    sd label
-    setcall label labelfield_left_prepare(text)
-    call packstart(box,label,(TRUE))
-    return label
-endfunction
-function labelfield_left_default(ss text,sd box)
-    sd label
-    setcall label labelfield_left_prepare(text)
-    call packstart(box,label,(FALSE))
-    return label
-endfunction
-
-function labelfield_left_table(ss text,sd table)
-    sd label
-    setcall label labelfield_left_prepare(text)
-    call table_add_row(table,label)
-    return label
-endfunction
-
-#########message dialog
-function message_dialog(sd print)
-    import "mainwidget" mainwidget
-    sd main
-    setcall main mainwidget()
-    importx "_gtk_message_dialog_new" gtk_message_dialog_new
-    importx "_gtk_dialog_run" gtk_dialog_run
-    importx "_gtk_widget_destroy" gtk_widget_destroy
-    sd dialog
-    setcall dialog gtk_message_dialog_new(main,(GTK_DIALOG_DESTROY_WITH_PARENT),(GTK_MESSAGE_INFO),(GTK_BUTTONS_OK),print)
-    call gtk_dialog_run(dialog)
-    call gtk_widget_destroy(dialog)
-endfunction
-
-##############pixbuf
-#pixbuf/0
-function new_pixbuf(sd width,sd height)
-    importx "_gdk_pixbuf_new" gdk_pixbuf_new
-    sd pixbuf
-    setcall pixbuf gdk_pixbuf_new((GDK_COLORSPACE_RGB),0,8,width,height)
-    if pixbuf==0
-        str pxerr="Can't create a pixbuf"
-        call texter(pxerr)
-        return 0
-    endif
-    return pixbuf
-endfunction
-
-#pixbuf/0
-function new_pixbuf_color(sd width,sd height,sd color)
-    sd pixbuf
-    setcall pixbuf new_pixbuf(width,height)
-    if pixbuf==0
-        return 0
-    endif
-    importx "_gdk_pixbuf_fill" gdk_pixbuf_fill
-    call gdk_pixbuf_fill(pixbuf,color)
-    return pixbuf
-endfunction
-
-#return a pixbuf
-function msgelement_pixbuf(sd msg)
-    importx "_gst_message_get_structure" gst_message_get_structure
-    sd struct
-    setcall struct gst_message_get_structure(msg)
-
-    str pix="pixbuf"
-    importx "_gst_structure_get_value" gst_structure_get_value
-    sd value
-    setcall value gst_structure_get_value(struct,pix)
-
-    importx "_g_value_dup_object" g_value_dup_object
-    sd pixbuf
-    setcall pixbuf g_value_dup_object(value)
-
-    return pixbuf
-endfunction
-
-function msgelement_pixbuf_forward_data(sd msg,sd forward,sd data)
-    sd pixbuf
-    setcall pixbuf msgelement_pixbuf(msg)
-
-    call forward(pixbuf,data)
-
-    call g_object_unref(pixbuf)
-endfunction
-
-importx "_gdk_pixbuf_get_width" gdk_pixbuf_get_width
-importx "_gdk_pixbuf_get_height" gdk_pixbuf_get_height
-importx "_gdk_pixbuf_get_pixels" gdk_pixbuf_get_pixels
-importx "_gdk_pixbuf_get_rowstride" gdk_pixbuf_get_rowstride
-
-import "rgb_px_get" rgb_px_get
-import "rgb_px_set" rgb_px_set
-
-#0/pixbuf
-function pixbuf_scale(sd pixbuf,sd w,sd h)
-    sd newpixbuf
-    setcall newpixbuf new_pixbuf(w,h)
-    if newpixbuf==0
-        return 0
-    endif
-    sd old_w
-    sd old_h
-    setcall old_w gdk_pixbuf_get_width(pixbuf)
-    setcall old_h gdk_pixbuf_get_height(pixbuf)
-
-    sd w_ratio
-    set w_ratio old_w
-    div w_ratio w
-    if w_ratio==0
-        set w_ratio 1
-    endif
-    sd h_ratio
-    set h_ratio old_h
-    div h_ratio h
-    if h_ratio==0
-        set h_ratio 1
-    endif
-
-    sd red
-    sd green
-    sd blue
-    sd colors^red
-    sd sum_red
-    sd sum_green
-    sd sum_blue
-    sd sum_colors^sum_red
-
-    sd old_pixels
-    sd pixels
-    setcall old_pixels gdk_pixbuf_get_pixels(pixbuf)
-    setcall pixels gdk_pixbuf_get_pixels(newpixbuf)
-    sd old_stride
-    sd stride
-    setcall old_stride gdk_pixbuf_get_rowstride(pixbuf)
-    setcall stride gdk_pixbuf_get_rowstride(newpixbuf)
-
-    sd j=0
-    while j!=h
-        import "rule3" rule3
-        sd top
-        setcall top rule3(j,h,old_h)
-        sd bottom
-        set bottom top
-        add bottom h_ratio
-        if bottom>old_h
-            set bottom old_h
-        endif
-        #left,right.. on old pixbuf
-        sd i=0
-        while i!=w
-            sd left
-            setcall left rule3(i,w,old_w)
-            sd right
-            set right left
-            add right w_ratio
-            if right>old_w
-                set right old_w
-            endif
-
-            import "rgb_uint_to_colors" rgb_uint_to_colors
-            import "rgb_colors_to_uint" rgb_colors_to_uint
-
-            sd number_of_colors=0
-
-            sd x
-            sd y
-            set y top
-            while y!=bottom
-                set x left
-                while x!=right
-                    sd value
-                    setcall value rgb_px_get(old_pixels,x,y,8,3,old_stride)
-
-                    if number_of_colors==0
-                        call rgb_uint_to_colors(value,sum_colors)
-                    else
-                        call rgb_uint_to_colors(value,colors)
-                        add sum_red red
-                        add sum_green green
-                        add sum_blue blue
-                    endelse
-
-                    inc number_of_colors
-                    inc x
-                endwhile
-                inc y
-            endwhile
-            div sum_red number_of_colors
-            div sum_green number_of_colors
-            div sum_blue number_of_colors
-
-            setcall value rgb_colors_to_uint(sum_colors)
-            call rgb_px_set(value,pixels,i,j,8,3,stride)
-
-            inc i
-        endwhile
-        inc j
-    endwhile
-    return newpixbuf
-endfunction
-
-function pixbuf_scale_forward_data(sd pixbuf,sd scale_w,sd scale_h,sd forward,sd data)
-    sd newpix
-
-    setcall newpix pixbuf_scale(pixbuf,scale_w,scale_h)
-    if newpix==0
-        return (error)
-    endif
-
-    call forward(newpix,data)
-
-    call g_object_unref(newpix)
-endfunction
-
-#forward the fit pixbuf in window
-function pixbuf_in_window_scale_forward(sd pixbuf,sd window,sd forward)
-    sd W
-    sd H
-    sd p_H^H
-
-    sd w
-    sd h
-
-    importx "_gdk_window_get_width" gdk_window_get_width
-    importx "_gdk_window_get_height" gdk_window_get_height
-
-    setcall W gdk_window_get_width(window)
-    if W==0
-        return 0
-    endif
-    setcall H gdk_window_get_height(window)
-    if H==0
-        return 0
-    endif
-    setcall w gdk_pixbuf_get_width(pixbuf)
-    setcall h gdk_pixbuf_get_height(pixbuf)
-
-    import "rectangle_fit_container_rectangle" rectangle_fit_container_rectangle
-    setcall W rectangle_fit_container_rectangle(w,h,W,H,p_H)
-
-    call pixbuf_scale_forward_data(pixbuf,W,H,forward,window)
-endfunction
-
-
-
-#forward a pixbuf
-include "../_include/difl.h" "../_include/difw.h"
-import "gerrtoerr" gerrtoerr
-import "getptrgerr" getptrgerr
-#function pixbuf from file
-function pixbuf_from_file(ss filename)
-	sd pixbuf#1
-	sd ptrgerror#1
-
-	setcall ptrgerror getptrgerr()
-
-	setcall pixbuf gdk_pixbuf_new_from_file(filename,ptrgerror)
-	if pixbuf!=(NULL)
-		import "rgb_test" rgb_test
-		setcall pixbuf rgb_test(pixbuf)
-		if pixbuf!=(NULL)
-			return pixbuf
-		endif
-		call g_object_unref(pixbuf)
-		return (NULL)
-	endif
-	call gerrtoerr(ptrgerror)
-	return (NULL)
-endfunction
-#returns the forward or null
-function pixbuf_from_file_forward_data(ss filename,sd forward,sd data)
-    sd pixbuf
-    setcall pixbuf pixbuf_from_file(filename)
-    sd null=0
-    if pixbuf==null
-        return null
-    endif
-    sd ret
-    setcall ret forward(pixbuf,data)
-    call g_object_unref(pixbuf)
-    return ret
-endfunction
-
-#function pixbuf_from_file_forward(ss filename,sd forward)
-#    data z=0
-#    call pixbuf_from_file_forward_data(filename,forward,z)
-#endfunction
-
-importx "_gdk_pixbuf_copy" gdk_pixbuf_copy
-function pixbuf_copy(sd pixbuf)
-    sd px
-    setcall px gdk_pixbuf_copy(pixbuf)
-    if px==0
-        str er="Could not create a pixbuf"
-        call texter(er)
-        return 0
-    endif
-    return px
-endfunction
-
-function pixbuf_get_wh(sd pixbuf,sd p_coord)
-    setcall p_coord# gdk_pixbuf_get_width(pixbuf)
-    add p_coord 4
-    setcall p_coord# gdk_pixbuf_get_height(pixbuf)
-endfunction
-
-#rowstride
-#function pixbuf_get_wh_rowstride_pixels(sd pixbuf,sd p_p,sd wh)
-#    setcall p_p# gdk_pixbuf_get_pixels(pixbuf)
-#    call pixbuf_get_wh(pixbuf,wh)
-#    sd rw
-#    setcall rw gdk_pixbuf_get_rowstride(pixbuf)
-#    return rw
-#endfunction
-
-#0/pixbuf
-function pixbuf_new_subpixels(sd pixbuf,sd left,sd top,sd right,sd bottom)
-    sd w
-    sd h
-    set w right
-    sub w left
-    set h bottom
-    sub h top
-
-    sd newpixbuf
-    setcall newpixbuf new_pixbuf(w,h)
-    if newpixbuf==0
-        return 0
-    endif
-
-    sd pixels
-    sd newbytes
-    setcall pixels gdk_pixbuf_get_pixels(pixbuf)
-    setcall newbytes gdk_pixbuf_get_pixels(newpixbuf)
-
-    sd mainwidth
-    sd mainheight
-    sd rowstr
-    setcall mainwidth gdk_pixbuf_get_width(pixbuf)
-    setcall mainheight gdk_pixbuf_get_height(pixbuf)
-    setcall rowstr gdk_pixbuf_get_rowstride(pixbuf)
-
-    import "rgb_get_all_sizes" rgb_get_all_sizes
-    sd rowstride
-    sd p_rowstride^rowstride
-    call rgb_get_all_sizes(w,h,p_rowstride)
-
-    sd i
-    sd j
-
-    sd y=0
-
-    set j top
-    while j!=bottom
-        set i left
-        sd x=0
-        while i!=right
-            sd value
-            setcall value rgb_px_get(pixels,i,j,8,3,rowstr)
-            call rgb_px_set(value,newbytes,x,y,8,3,rowstride)
-            inc i
-            inc x
-        endwhile
-        inc j
-        inc y
-    endwhile
-    return newpixbuf
-endfunction
-
-#display the pixbuf
-function pixbuf_draw_onwindow(sd pixbuf,sd drawable)
-    data diether=GDK_RGB_DITHER_NONE
-    importx "_gdk_draw_pixbuf" gdk_draw_pixbuf
-    #(GdkDrawable *drawable,GdkGC *gc,const GdkPixbuf *pixbuf,
-    #gint src_x,gint src_y,gint dest_x,gint dest_y,
-    #gint width,gint height,GdkRgbDither dither,gint x_dither,gint y_dither)
-    data default_size=-1
-    data null=0
-    call gdk_draw_pixbuf(drawable,null,pixbuf,null,null,null,null,default_size,default_size,diether,null,null)
-endfunction
-
-function pixbuf_set_pixel(sd pixbuf,sd value,sd x,sd y)
-    sd bytes
-    sd rowstride
-    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
-    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
-    call rgb_px_set(value,bytes,x,y,8,3,rowstride)
-endfunction
-
-#value
-function pixbuf_get_pixel(sd pixbuf,sd x,sd y)
-    sd bytes
-    sd rowstride
-    setcall bytes gdk_pixbuf_get_pixels(pixbuf)
-    setcall rowstride gdk_pixbuf_get_rowstride(pixbuf)
-    sd value
-    setcall value rgb_px_get(bytes,x,y,8,3,rowstride)
-    return value
-endfunction
-
-function pixbuf_over_pixbuf(sd overpixbuf,sd laypixbuf,sd min_i,sd max_i,sd min_j,sd max_j)
-    sd y=0
-    sd i
-    sd j
-    set j min_j
-    while j!=max_j
-    sd x=0
-        set i min_i
-        while i!=max_i
-            sd value
-            setcall value pixbuf_get_pixel(overpixbuf,x,y)
-            call pixbuf_set_pixel(laypixbuf,value,i,j)
-            inc x
-            inc i
-        endwhile
-        inc y
-        inc j
-    endwhile
-endfunction
-
-function surface_to_pixbufdata(sd surface,sd pixbuf)
-    sd width
-    sd height
-    sd wh^width
-    call pixbuf_get_wh(pixbuf,wh)
-    importx "_cairo_image_surface_get_data" cairo_image_surface_get_data
-    sd bytes
-    setcall bytes cairo_image_surface_get_data(surface)
-    sd pixels
-    setcall pixels gdk_pixbuf_get_pixels(pixbuf)
-    import "rgb_get_rowstride" rgb_get_rowstride
-    sd p_stride
-    setcall p_stride rgb_get_rowstride(width)
-    sd b_stride
-    set b_stride width
-    mult b_stride 4
-
-    sd b_sz
-    set b_sz b_stride
-    mult b_sz height
-    sub b_sz b_stride
-    add bytes b_sz
-
-    import "convert_row_rgba_to_rgb" convert_row_rgba_to_rgb
-    sd j=0
-    while j!=height
-        call convert_row_rgba_to_rgb(bytes,pixels,width)
-
-        sub bytes b_stride
-        add pixels p_stride
-        inc j
-    endwhile
-endfunction
-
-#pixbuf/0
-function pixbuf_from_pixbuf_reverse(sd pixbuf_reverse)
-	#the new pixbuf
-	sd pixbuf
-	setcall pixbuf pixbuf_copy(pixbuf_reverse)
-	if pixbuf==0
-		return 0
-	endif
-
-	#get width height
-	sd w
-	sd h
-	sd p_wh^w
-	call pixbuf_get_wh(pixbuf,p_wh)
-	#reverse bytes
-	sd bytes
-	setcall bytes gdk_pixbuf_get_pixels(pixbuf)
-	import "rgb_color_swap" rgb_color_swap
-	call rgb_color_swap(bytes,w,h)
-
-	return pixbuf
-endfunction
-
-##############progressbar
-importx "_gtk_progress_bar_new" gtk_progress_bar_new
-function progressfield(sd container)
-    sd wid
-    setcall wid gtk_progress_bar_new()
-    data true=1
-    data false=0
-    call gtk_box_pack_start(container,wid,true,false,false)
-    return wid
-endfunction
-
-##############radio
-#function radiofield_prepare(sd previousbutton,ss text)
-#    importx "_gtk_radio_button_new_with_label" gtk_radio_button_new_with_label
-#    importx "_gtk_radio_button_get_group" gtk_radio_button_get_group
-
-#    sd radiogroup
-#    setcall radiogroup gtk_radio_button_get_group(previousbutton)
-
-#    sd rd
-#    setcall rd gtk_radio_button_new_with_label(radiogroup,text)
-#    return rd
-#endfunction
-
-#function radiofield(sd previousbutton,ss text,sd box)
-#    sd rd
-#    setcall rd radiofield_prepare(previousbutton,text)
-#    call packstart_default(box,rd)
-#    return rd
-#endfunction
-
-##############widget
-#ancestor
-function widget_get_ancestor(sd widget,sd ancestor_parent)
-    importx "_gtk_widget_get_parent" gtk_widget_get_parent
-    sd ancestor
-    while widget!=ancestor_parent
-        set ancestor widget
-        setcall widget gtk_widget_get_parent(widget)
-    endwhile
-    return ancestor
-endfunction
-
-function widget_draw_pixbuf(sd widget,sd pixbuf)
-    importx "_gtk_widget_get_window" gtk_widget_get_window
-    sd drawable
-    setcall drawable gtk_widget_get_window(widget)
-    data fn^pixbuf_draw_onwindow
-    call pixbuf_in_window_scale_forward(pixbuf,drawable,fn)
-endfunction
-
-function widget_redraw(sd widget)
-    sd drawable
-    setcall drawable gtk_widget_get_window(widget)
-    if drawable==0
-        str nodraw="No drawing area error."
-        call texter(nodraw)
-        return nodraw
-    endif
-    importx "_gdk_window_invalidate_rect" gdk_window_invalidate_rect
-    call gdk_window_invalidate_rect(drawable,0,0)
-endfunction
--- /dev/null
+++ ovideo-1/src/obj/tool.oc
@@ -0,0 +1,119 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+#color(base) to a widget
+#importx "_gtk_widget_modify_base" gtk_widget_modify
+#importx "_gtk_widget_modify_text" gtk_widget_modify
+importx "_gtk_widget_modify_bg" gtk_widget_modify
+#importx "_gtk_widget_modify_fg" gtk_widget_modify
+
+#void
+function setWidgetBase(sd widget,ss in_colors)
+	data guint32_pixel=0
+	char *=0;char guint16_red#1
+	char *=0;char guint16_green#1
+	char *=0;char guint16_blue#1
+	set guint16_red in_colors#
+	inc in_colors;set guint16_green in_colors#
+	inc in_colors;set guint16_blue in_colors#
+	call gtk_widget_modify(widget,(GTK_STATE_NORMAL),#guint32_pixel)
+endfunction
+
+###container preadd actions
+#test for scroll viewport need
+function viewport_test(sd container,sd widget)
+    data null=0
+
+    importx "_g_type_name" g_type_name
+    sd obj
+    set obj container#
+    set obj obj#
+    ss typename
+    setcall typename g_type_name(obj)
+    if typename=null
+        return container
+    endif
+
+    str scrolled="GtkScrolledWindow"
+    import "cmpstr" cmpstr
+    Data equal=equalCompare
+    sd ret
+    setcall ret cmpstr(scrolled,typename)
+    if ret!=equal
+        return container
+    endif
+
+    str signal="set_scroll_adjustments_signal"
+    importx "_gtk_widget_class_find_style_property" gtk_widget_class_find_style_property
+    setcall ret gtk_widget_class_find_style_property(widget,signal)
+    if ret!=null
+        return container
+    endif
+
+    importx "_gtk_container_add" gtk_container_add
+    importx "_gtk_viewport_new" gtk_viewport_new
+    sd viewport
+    setcall viewport gtk_viewport_new(null,null)
+    call gtk_container_add(container,viewport)
+    return viewport
+endfunction
+
+function container_add(sd container,sd widget)
+    setcall container viewport_test(container,widget)
+    call gtk_container_add(container,widget)
+endfunction
+
+function container_child(sd container,sd widget)
+    import "firstwidgetFromcontainer" firstwidgetFromcontainer
+    sd old
+    setcall old firstwidgetFromcontainer(container)
+    data z=0
+    if old!=z
+        importx "_gtk_widget_destroy" gtk_widget_destroy
+        call gtk_widget_destroy(old)
+    endif
+    call gtk_container_add(container,widget)
+endfunction
+###
+
+import "getsubject" getsubject
+
+#integer to string to object name
+function object_set_dword_name(sd object,sd int_name)
+    char str_name#dword_null
+    str s_name^str_name
+    str dw_str="%u"
+    importx "_sprintf" sprintf
+    call sprintf(s_name,dw_str,int_name)
+
+    ss name
+    setcall name getsubject()
+    importx "_g_object_set" g_object_set
+    data null=0
+    call g_object_set(object,name,s_name,null)
+endfunction
+
+function object_get_dword_name(sd object)
+    ss name
+    setcall name getsubject()
+
+    ss handle_str
+    sd ptr_str^handle_str
+
+    data null=0
+    importx "_g_object_get" g_object_get
+    call g_object_get(object,name,ptr_str,null)
+
+    import "strtoint" strtoint
+    sd img
+    sd ptr_img^img
+    call strtoint(handle_str,ptr_img)
+
+    importx "_g_free" g_free
+    call g_free(handle_str)
+
+    return img
+endfunction
--- ovideo-1.orig/src/obj/tool.s
+++ /dev/null
@@ -1,119 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-#color(base) to a widget
-#importx "_gtk_widget_modify_base" gtk_widget_modify
-#importx "_gtk_widget_modify_text" gtk_widget_modify
-importx "_gtk_widget_modify_bg" gtk_widget_modify
-#importx "_gtk_widget_modify_fg" gtk_widget_modify
-
-#void
-function setWidgetBase(sd widget,ss in_colors)
-	data guint32_pixel=0
-	char *=0;char guint16_red#1
-	char *=0;char guint16_green#1
-	char *=0;char guint16_blue#1
-	set guint16_red in_colors#
-	inc in_colors;set guint16_green in_colors#
-	inc in_colors;set guint16_blue in_colors#
-	call gtk_widget_modify(widget,(GTK_STATE_NORMAL),#guint32_pixel)
-endfunction
-
-###container preadd actions
-#test for scroll viewport need
-function viewport_test(sd container,sd widget)
-    data null=0
-
-    importx "_g_type_name" g_type_name
-    sd obj
-    set obj container#
-    set obj obj#
-    ss typename
-    setcall typename g_type_name(obj)
-    if typename==null
-        return container
-    endif
-
-    str scrolled="GtkScrolledWindow"
-    import "cmpstr" cmpstr
-    Data equal=equalCompare
-    sd ret
-    setcall ret cmpstr(scrolled,typename)
-    if ret!=equal
-        return container
-    endif
-
-    str signal="set_scroll_adjustments_signal"
-    importx "_gtk_widget_class_find_style_property" gtk_widget_class_find_style_property
-    setcall ret gtk_widget_class_find_style_property(widget,signal)
-    if ret!=null
-        return container
-    endif
-
-    importx "_gtk_container_add" gtk_container_add
-    importx "_gtk_viewport_new" gtk_viewport_new
-    sd viewport
-    setcall viewport gtk_viewport_new(null,null)
-    call gtk_container_add(container,viewport)
-    return viewport
-endfunction
-
-function container_add(sd container,sd widget)
-    setcall container viewport_test(container,widget)
-    call gtk_container_add(container,widget)
-endfunction
-
-function container_child(sd container,sd widget)
-    import "firstwidgetFromcontainer" firstwidgetFromcontainer
-    sd old
-    setcall old firstwidgetFromcontainer(container)
-    data z=0
-    if old!=z
-        importx "_gtk_widget_destroy" gtk_widget_destroy
-        call gtk_widget_destroy(old)
-    endif
-    call gtk_container_add(container,widget)
-endfunction
-###
-
-import "getsubject" getsubject
-
-#integer to string to object name
-function object_set_dword_name(sd object,sd int_name)
-    char str_name#dword_null
-    str s_name^str_name
-    str dw_str="%u"
-    importx "_sprintf" sprintf
-    call sprintf(s_name,dw_str,int_name)
-
-    ss name
-    setcall name getsubject()
-    importx "_g_object_set" g_object_set
-    data null=0
-    call g_object_set(object,name,s_name,null)
-endfunction
-
-function object_get_dword_name(sd object)
-    ss name
-    setcall name getsubject()
-
-    ss handle_str
-    sd ptr_str^handle_str
-
-    data null=0
-    importx "_g_object_get" g_object_get
-    call g_object_get(object,name,ptr_str,null)
-
-    import "strtoint" strtoint
-    sd img
-    sd ptr_img^img
-    call strtoint(handle_str,ptr_img)
-
-    importx "_g_free" g_free
-    call g_free(handle_str)
-
-    return img
-endfunction
--- /dev/null
+++ ovideo-1/src/str/str.oc
@@ -0,0 +1,248 @@
+
+format elfobj
+
+include "../_include/include.h"
+
+import "memoryalloc" memalloc
+
+function tostring(str string,data size)
+        data zero=0
+        str s#1
+
+        set s string
+        add s size
+        set s# zero
+endfunction
+
+import "cpymem" cpymem
+
+#void/err
+function memtostrFw_s(str mem,data size,str dest,data destsize,data forward)
+    if size>destsize
+        import "texter" texter
+        vstr memtostrconflict="Mem2Str: destination is too small."
+        call texter(memtostrconflict)
+    endif
+
+    call cpymem(dest,mem,size)
+    call tostring(dest,size)
+
+    call forward(dest)
+endfunction
+
+#e
+function slen_s(ss str,sd size,sd ptrszout)
+    char term={0}
+    char byte={0}
+    Data zero=0
+    data one=1
+    sd loop
+
+    set ptrszout# size
+    set loop one
+    while loop=one
+        if size=zero
+            set loop zero
+        else
+            Set byte str#
+            if byte=term
+                set loop zero
+            else
+                Inc str
+                dec size
+            endelse
+        endelse
+    endwhile
+    sub ptrszout# size
+    if size=zero
+        str er="String null termination expected."
+        call texter(er)
+        return er
+    endif
+    data ne=noerror
+    return ne
+endfunction
+
+#sizeof the string
+function slen(str str)
+        data maxsize=0xffFFffFF
+        sd sz
+        sd ptrsz^sz
+        call slen_s(str,maxsize,ptrsz)
+        return sz
+endfunction
+
+function path_extension(ss path)
+    sd len
+    ss cursor
+    char delim="."
+
+    setcall len slen(path)
+
+    set cursor path
+    add cursor len
+    while cursor!=path
+        dec cursor
+        if cursor#=delim
+            inc cursor
+            return cursor
+        endif
+    endwhile
+    add path len
+    return path
+endfunction
+
+import "move_cursors" move_cursors
+function move_cursors_test(sd str_sz,sd size,sd advance)
+    data true=1
+    if advance=true
+        call move_cursors(str_sz,size)
+    endif
+endfunction
+
+import "cmpmem" cmpmem
+#size before string(if match found);
+#size(if match is not;if match points to a null string and takeall is true)
+#0(if match points to a null string and takeall is false)
+Function strinmem_portions_advance(sd str_sz,str match,sd takeall,sd advance)
+        data true=1
+        Data zero=0
+        Data nrsz#1
+        SetCall nrsz slen(match)
+
+        ss content
+        sd size
+
+        sd string_size^content
+
+        import "content_size" content_size
+        call content_size(str_sz,string_size)
+
+	if nrsz=zero
+		if takeall=true
+                call move_cursors_test(str_sz,size,advance)
+                return size
+		endif
+		return zero
+	endif
+	if size<nrsz
+            call move_cursors_test(str_sz,size,advance)
+            Return size
+	endif
+
+        Str cnt#1
+        Set cnt content
+        Data sz#1
+        Set sz size
+        Data b#1
+        While sz>=nrsz
+                SetCall b cmpmem(cnt,match,nrsz)
+                If b=zero
+                    Sub cnt content
+                    call move_cursors_test(str_sz,cnt,advance)
+                    call move_cursors_test(str_sz,nrsz,advance)
+                    return cnt
+                EndIf
+                If b!=zero
+                        Inc cnt
+                        Dec sz
+                EndIf
+        EndWhile
+        call move_cursors_test(str_sz,size,advance)
+        Return size
+EndFunction
+
+importx "_free" free
+#e
+function memtostrFw_data(sd mem,sd size,sv forward,sd data)
+    sd err
+    sd noerr=noerror
+    ss alloc
+    sd ptralloc^alloc
+    inc size
+    setcall err memalloc(size,ptralloc)
+    if err!=noerr
+        return err
+    endif
+    dec size
+    call cpymem(alloc,mem,size)
+    add alloc size
+    char n=0
+    set alloc# n
+    sub alloc size
+    call forward(alloc,data)
+    call free(alloc)
+    return noerr
+endfunction
+
+#str
+function get_string_at_index(ss iter,sd index)
+    sd i=0
+    while i!=index
+        while iter#!=0
+            inc iter
+        endwhile
+        inc iter
+        inc i
+    endwhile
+    return iter
+endfunction
+
+#function catstrings(sd strings,ss dest)
+#    sd src
+#    while strings#!=0
+#        #take every string
+#        set src strings#
+#        sd srcsz
+#        #get src size
+#        setcall srcsz slen(src)
+#        #add null term
+#        inc srcsz
+#        #copy
+#        call cpymem(dest,src,srcsz)
+#        #dest cursor at null term
+#        add dest srcsz
+#        dec dest
+#        #advance iterators
+#        add strings 4
+#    endwhile
+#endfunction
+
+#0/alloc
+function string_alloc_escaped(ss unescaped)
+    sd len
+    setcall len slen(unescaped)
+    sd escaped_len
+    set escaped_len len
+    mult escaped_len 2
+    inc escaped_len
+    ss escaped
+    sd p_escaped^escaped
+    sd err
+    setcall err memalloc(escaped_len,p_escaped)
+    if err!=(noerror)
+        return 0
+    endif
+    ss cursor_escaped
+    set cursor_escaped escaped
+    while unescaped#!=0
+        set cursor_escaped# unescaped#
+        char bslash="\\"
+        if unescaped#=bslash
+            inc cursor_escaped
+            set cursor_escaped# bslash
+        endif
+        inc unescaped
+        inc cursor_escaped
+    endwhile
+    set cursor_escaped# 0
+    return escaped
+endfunction
+
+function strcpy(ss dest,ss src)
+    sd len
+    setcall len slen(src)
+    call cpymem(dest,src,len)
+    add dest len
+    set dest# 0
+endfunction
--- ovideo-1.orig/src/str/str.s
+++ /dev/null
@@ -1,248 +0,0 @@
-
-format elfobj
-
-include "../_include/include.h"
-
-import "memoryalloc" memalloc
-
-function tostring(str string,data size)
-        data zero=0
-        str s#1
-
-        set s string
-        add s size
-        set s# zero
-endfunction
-
-import "cpymem" cpymem
-
-#void/err
-function memtostrFw_s(str mem,data size,str dest,data destsize,data forward)
-    if size>destsize
-        import "texter" texter
-        vstr memtostrconflict="Mem2Str: destination is too small."
-        call texter(memtostrconflict)
-    endif
-
-    call cpymem(dest,mem,size)
-    call tostring(dest,size)
-
-    call forward(dest)
-endfunction
-
-#e
-function slen_s(ss str,sd size,sd ptrszout)
-    char term={0}
-    char byte={0}
-    Data zero=0
-    data one=1
-    sd loop
-
-    set ptrszout# size
-    set loop one
-    while loop==one
-        if size==zero
-            set loop zero
-        else
-            Set byte str#
-            if byte==term
-                set loop zero
-            else
-                Inc str
-                dec size
-            endelse
-        endelse
-    endwhile
-    sub ptrszout# size
-    if size==zero
-        str er="String null termination expected."
-        call texter(er)
-        return er
-    endif
-    data ne=noerror
-    return ne
-endfunction
-
-#sizeof the string
-function slen(str str)
-        data maxsize=0xffFFffFF
-        sd sz
-        sd ptrsz^sz
-        call slen_s(str,maxsize,ptrsz)
-        return sz
-endfunction
-
-function path_extension(ss path)
-    sd len
-    ss cursor
-    char delim="."
-
-    setcall len slen(path)
-
-    set cursor path
-    add cursor len
-    while cursor!=path
-        dec cursor
-        if cursor#==delim
-            inc cursor
-            return cursor
-        endif
-    endwhile
-    add path len
-    return path
-endfunction
-
-import "move_cursors" move_cursors
-function move_cursors_test(sd str_sz,sd size,sd advance)
-    data true=1
-    if advance==true
-        call move_cursors(str_sz,size)
-    endif
-endfunction
-
-import "cmpmem" cmpmem
-#size before string(if match found);
-#size(if match is not;if match points to a null string and takeall is true)
-#0(if match points to a null string and takeall is false)
-Function strinmem_portions_advance(sd str_sz,str match,sd takeall,sd advance)
-        data true=1
-        Data zero=0
-        Data nrsz#1
-        SetCall nrsz slen(match)
-
-        ss content
-        sd size
-
-        sd string_size^content
-
-        import "content_size" content_size
-        call content_size(str_sz,string_size)
-
-        if nrsz==zero
-            if takeall==true
-                call move_cursors_test(str_sz,size,advance)
-                return size
-            else
-                return zero
-            endelse
-        elseif size<nrsz
-            call move_cursors_test(str_sz,size,advance)
-            Return size
-        endelseif
-
-        Str cnt#1
-        Set cnt content
-        Data sz#1
-        Set sz size
-        Data b#1
-        While sz>=nrsz
-                SetCall b cmpmem(cnt,match,nrsz)
-                If b==zero
-                    Sub cnt content
-                    call move_cursors_test(str_sz,cnt,advance)
-                    call move_cursors_test(str_sz,nrsz,advance)
-                    return cnt
-                EndIf
-                If b!=zero
-                        Inc cnt
-                        Dec sz
-                EndIf
-        EndWhile
-        call move_cursors_test(str_sz,size,advance)
-        Return size
-EndFunction
-
-importx "_free" free
-#e
-function memtostrFw_data(sd mem,sd size,sd forward,sd data)
-    sd err
-    sd noerr=noerror
-    ss alloc
-    sd ptralloc^alloc
-    inc size
-    setcall err memalloc(size,ptralloc)
-    if err!=noerr
-        return err
-    endif
-    dec size
-    call cpymem(alloc,mem,size)
-    add alloc size
-    char n=0
-    set alloc# n
-    sub alloc size
-    call forward(alloc,data)
-    call free(alloc)
-    return noerr
-endfunction
-
-#str
-function get_string_at_index(ss iter,sd index)
-    sd i=0
-    while i!=index
-        while iter#!=0
-            inc iter
-        endwhile
-        inc iter
-        inc i
-    endwhile
-    return iter
-endfunction
-
-#function catstrings(sd strings,ss dest)
-#    sd src
-#    while strings#!=0
-#        #take every string
-#        set src strings#
-#        sd srcsz
-#        #get src size
-#        setcall srcsz slen(src)
-#        #add null term
-#        inc srcsz
-#        #copy
-#        call cpymem(dest,src,srcsz)
-#        #dest cursor at null term
-#        add dest srcsz
-#        dec dest
-#        #advance iterators
-#        add strings 4
-#    endwhile
-#endfunction
-
-#0/alloc
-function string_alloc_escaped(ss unescaped)
-    sd len
-    setcall len slen(unescaped)
-    sd escaped_len
-    set escaped_len len
-    mult escaped_len 2
-    inc escaped_len
-    ss escaped
-    sd p_escaped^escaped
-    sd err
-    setcall err memalloc(escaped_len,p_escaped)
-    if err!=(noerror)
-        return 0
-    endif
-    ss cursor_escaped
-    set cursor_escaped escaped
-    while unescaped#!=0
-        set cursor_escaped# unescaped#
-        char bslash="\\"
-        if unescaped#==bslash
-            inc cursor_escaped
-            set cursor_escaped# bslash
-        endif
-        inc unescaped
-        inc cursor_escaped
-    endwhile
-    set cursor_escaped# 0
-    return escaped
-endfunction
-
-function strcpy(ss dest,ss src)
-    sd len
-    setcall len slen(src)
-    call cpymem(dest,src,len)
-    add dest len
-    set dest# 0
-endfunction
--- /dev/null
+++ ovideo-1/src/util/asm.oc
@@ -0,0 +1,52 @@
+
+
+format elfobj
+
+include "../_include/include.h"
+
+function getoneax(sd value)
+    return value
+endfunction
+
+#SAR 32
+function sar32(sd value,sd *count)
+    sd p_value^value
+    call getoneax(p_value)
+    #ecx eax
+    hex 0x8b,ecx*to_regopcode|mod_reg|eax
+    #ecx +4
+    hex 0x81,mod_reg|ecx,4,0,0,0
+    #ecx [ecx]
+    hex 0x8b,ecx*to_regopcode|ecx
+    #sar @ [eax]
+    hex 0xd3,7*to_regopcode
+    return value
+endfunction
+
+function shl(sd value,sd *count)
+    sd p_value^value
+    call getoneax(p_value)
+    #ecx eax
+    hex 0x8b,ecx*to_regopcode|mod_reg|eax
+    #ecx +4
+    hex 0x81,mod_reg|ecx,4,0,0,0
+    #ecx [ecx]
+    hex 0x8b,ecx*to_regopcode|ecx
+    #shl @ [eax]
+    hex 0xd3,4*to_regopcode
+    return value
+endfunction
+
+function shr(sd value,sd *count)
+    sd p_value^value
+    call getoneax(p_value)
+    #ecx eax
+    hex 0x8b,ecx*to_regopcode|mod_reg|eax
+    #ecx +4
+    hex 0x81,mod_reg|ecx,4,0,0,0
+    #ecx [ecx]
+    hex 0x8b,ecx*to_regopcode|ecx
+    #shr @ [eax]
+    hex 0xd3,5*to_regopcode
+    return value
+endfunction
--- ovideo-1.orig/src/util/asm.s
+++ /dev/null
@@ -1,52 +0,0 @@
-
-
-format elfobj
-
-include "../_include/include.h"
-
-function getoneax(sd value)
-    return value
-endfunction
-
-#SAR 32
-function sar32(sd value,sd *count)
-    sd p_value^value
-    call getoneax(p_value)
-    #ecx eax
-    hex 0x8b,ecx*to_regopcode|mod_reg|eax
-    #ecx +4
-    hex 0x81,mod_reg|ecx,4,0,0,0
-    #ecx [ecx]
-    hex 0x8b,ecx*to_regopcode|ecx
-    #sar @ [eax]
-    hex 0xd3,7*to_regopcode
-    return value
-endfunction
-
-function shl(sd value,sd *count)
-    sd p_value^value
-    call getoneax(p_value)
-    #ecx eax
-    hex 0x8b,ecx*to_regopcode|mod_reg|eax
-    #ecx +4
-    hex 0x81,mod_reg|ecx,4,0,0,0
-    #ecx [ecx]
-    hex 0x8b,ecx*to_regopcode|ecx
-    #shl @ [eax]
-    hex 0xd3,4*to_regopcode
-    return value
-endfunction
-
-function shr(sd value,sd *count)
-    sd p_value^value
-    call getoneax(p_value)
-    #ecx eax
-    hex 0x8b,ecx*to_regopcode|mod_reg|eax
-    #ecx +4
-    hex 0x81,mod_reg|ecx,4,0,0,0
-    #ecx [ecx]
-    hex 0x8b,ecx*to_regopcode|ecx
-    #shr @ [eax]
-    hex 0xd3,5*to_regopcode
-    return value
-endfunction
--- /dev/null
+++ ovideo-1/src/util/floating.oc
@@ -0,0 +1,289 @@
+
+
+
+format elfobj
+
+#float and double add,sub and other operations
+#we use a trick by placing the cpu asm with HEX language command
+
+include "../_include/include.h"
+
+import "getoneax" getoneax
+
+##float
+
+#float
+function double_to_float(sd p_double)
+    call fld_quad(p_double)
+    sd value
+    sd p_value^value
+    call fstp(p_value)
+    return value
+endfunction
+
+importx "_sscanf" sscanf
+
+#float
+function int_to_float(sd number)
+    sd p_number^number
+    call fild(p_number)
+    call fstp(p_number)
+    return number
+endfunction
+
+function float_to_int(sd number)
+    sd p_number^number
+    call fld(p_number)
+    call fistp(p_number)
+    return number
+endfunction
+
+#float
+function str_to_float(ss strbytes)
+    ss floatformat="%f"
+    sd f
+    sd p_f^f
+    call sscanf(strbytes,floatformat,p_f)
+    return f
+endfunction
+
+##double
+
+#double
+function float_to_double(sd float,sd p_d)
+    sd p^float
+    call fld(p)
+    call fstp_quad(p_d)
+endfunction
+
+#int
+function double_to_int(sd p_double)
+    call fld_quad(p_double)
+    sd value#2
+    sd p_value^value
+    call fstp_quad(p_value)
+    call getoneax(p_value)
+
+    #esi,eax up
+    hex 0x56
+    hex 0x50
+
+    hex 0xf2
+    #MOVUPS
+    hex 0x0f,0x10,0x00
+    hex 0xf2
+    hex 0x0f,0x2c,0xf0
+
+    hex 0x58
+    #esi at [eax]
+    hex 0x89,6*8
+
+    #esi down
+    hex 0x5e
+
+    return value
+endfunction
+
+function str_to_double(ss strbytes,sd p_double)
+    ss doubleformat="%lf"
+    call sscanf(strbytes,doubleformat,p_double)
+endfunction
+
+function int_to_double(sd integer,sd p_double)
+    sd p_int^integer
+    call fild(p_int)
+    call fstp_quad(p_double)
+endfunction
+
+##tricks
+
+function fild(sd p_value)
+    call getoneax(p_value)
+    HEX 0xDB,0
+endfunction
+function fild_value(sd value)
+    sd p_value^value
+    call getoneax(p_value)
+    HEX 0xDB,0
+endfunction
+
+function fld(sd p_value)
+    call getoneax(p_value)
+    HEX 0xD9,0x00
+endfunction
+function fld_quad(sd p_value)
+    call getoneax(p_value)
+    HEX 0xDD,0x00
+endfunction
+
+function fistp(sd p_value)
+    call getoneax(p_value)
+    HEX 0xDB,3*8
+endfunction
+
+function fstp(sd p_value)
+    call getoneax(p_value)
+    HEX 0xD9,0x18
+endfunction
+function fst_quad(sd p_value)
+    call getoneax(p_value)
+    HEX 0xDD,2*to_regopcode
+endfunction
+function fstp_quad(sd p_value)
+    call getoneax(p_value)
+    HEX 0xDD,0x18
+endfunction
+
+#
+const fadd_op=0
+function fiadd(sd p_value)
+    call getoneax(p_value)
+    HEX 0xDA,fadd_op*to_regopcode
+endfunction
+function float_add(sd A,sd B)
+    sd p_A^A
+    sd p_B^B
+    call fld(p_A)
+    call getoneax(p_B)
+    HEX 0xD8,fadd_op*to_regopcode
+    call fstp(p_A)
+    return A
+endfunction
+function double_add(sd p_A,sd p_B)
+    call fld_quad(p_A)
+    call getoneax(p_B)
+    HEX 0xDC,fadd_op*to_regopcode
+    call fstp_quad(p_A)
+endfunction
+function fadd_quad(sd p_A)
+    call getoneax(p_A)
+    HEX 0xDC,fadd_op*to_regopcode
+endfunction
+
+const fsub_op=4
+function float_sub(sd A,sd B)
+    sd p_A^A
+    sd p_B^B
+    call fld(p_A)
+    call getoneax(p_B)
+    HEX 0xD8,fsub_op*to_regopcode
+    call fstp(p_A)
+    return A
+endfunction
+#function double_sub(sd p_A,sd p_B)
+#    call fld_quad(p_A)
+#    call getoneax(p_B)
+#    HEX 0xDC,fsub_op*to_regopcode
+#    call fstp_quad(p_A)
+#endfunction
+function fsub_quad(sd p_A)
+    call getoneax(p_A)
+    HEX 0xDC,fsub_op*to_regopcode
+endfunction
+
+const fmul_op=1
+function fimul(sd p_value)
+    call getoneax(p_value)
+    HEX 0xDA,fmul_op*to_regopcode
+endfunction
+function float_mult(sd A,sd B)
+    sd p_A^A
+    sd p_B^B
+    call fld(p_A)
+    call getoneax(p_B)
+    HEX 0xD8,fmul_op*to_regopcode
+    call fstp(p_A)
+    return A
+endfunction
+function double_mult(sd p_A,sd p_B)
+    call fld_quad(p_A)
+    call getoneax(p_B)
+    HEX 0xDC,fmul_op*to_regopcode
+    call fstp_quad(p_A)
+endfunction
+function fmul_quad(sd p_A)
+    call getoneax(p_A)
+    HEX 0xDC,fmul_op*to_regopcode
+endfunction
+
+const fdiv_op=6
+function fidiv(sd p_value)
+    call getoneax(p_value)
+    HEX 0xDA,fdiv_op*to_regopcode
+endfunction
+function double_div(sd p_A,sd p_B)
+    call fld_quad(p_A)
+    call getoneax(p_B)
+    HEX 0xDC,fdiv_op*to_regopcode
+    call fstp_quad(p_A)
+endfunction
+function fdiv_quad(sd p_A)
+    call getoneax(p_A)
+    HEX 0xDC,fdiv_op*to_regopcode
+endfunction
+
+
+
+#
+#bool
+function fcom_quad_greater(sd p_A)
+    sd aux
+    sd value
+    set aux p_A
+    sd p_aux^aux
+    #
+    call getoneax(p_aux)
+    #ecx eax
+    hex 0x8b,ecx*to_regopcode|mod_reg|eax
+    #eax [eax]
+    hex 0x8b,0
+    #fcom
+    HEX 0xDC,2*to_regopcode
+    #fstsw ax
+    HEX 0xDF,0xE0
+    #ecx +4
+    hex 0x81,mod_reg|ecx,4,0,0,0
+    #[ecx] eax
+    hex 0x8b,ecx*to_regopcode|eax
+    #
+    and value 0x00004100
+	if value=0
+        return 1
+	endif
+        return 0
+endfunction
+#bool
+function fcom_quad_greater_or_equal(sd p_A)
+    sd aux
+    sd value
+    set aux p_A
+    sd p_aux^aux
+    #
+    call getoneax(p_aux)
+    #ecx eax
+    hex 0x8b,ecx*to_regopcode|mod_reg|eax
+    #eax [eax]
+    hex 0x8b,0
+    #fcom
+    HEX 0xDC,2*to_regopcode
+    #fstsw ax
+    HEX 0xDF,0xE0
+    #ecx +4
+    hex 0x81,mod_reg|ecx,4,0,0,0
+    #[ecx] eax
+    hex 0x8b,ecx*to_regopcode|eax
+    #
+    and value 0x00000100
+	if value=0
+        return 1
+	endif
+        return 0
+endfunction
+
+function fcos()
+	hex 0xD9,0xFF
+endfunction
+
+function fsin()
+	hex 0xD9,0xFE
+endfunction
--- ovideo-1.orig/src/util/floating.s
+++ /dev/null
@@ -1,291 +0,0 @@
-
-
-
-format elfobj
-
-#float and double add,sub and other operations
-#we use a trick by placing the cpu asm with HEX language command
-
-include "../_include/include.h"
-
-import "getoneax" getoneax
-
-##float
-
-#float
-function double_to_float(sd p_double)
-    call fld_quad(p_double)
-    sd value
-    sd p_value^value
-    call fstp(p_value)
-    return value
-endfunction
-
-importx "_sscanf" sscanf
-
-#float
-function int_to_float(sd number)
-    sd p_number^number
-    call fild(p_number)
-    call fstp(p_number)
-    return number
-endfunction
-
-function float_to_int(sd number)
-    sd p_number^number
-    call fld(p_number)
-    call fistp(p_number)
-    return number
-endfunction
-
-#float
-function str_to_float(ss strbytes)
-    ss floatformat="%f"
-    sd f
-    sd p_f^f
-    call sscanf(strbytes,floatformat,p_f)
-    return f
-endfunction
-
-##double
-
-#double
-function float_to_double(sd float,sd p_d)
-    sd p^float
-    call fld(p)
-    call fstp_quad(p_d)
-endfunction
-
-#int
-function double_to_int(sd p_double)
-    call fld_quad(p_double)
-    sd value#2
-    sd p_value^value
-    call fstp_quad(p_value)
-    call getoneax(p_value)
-
-    #esi,eax up
-    hex 0x56
-    hex 0x50
-
-    hex 0xf2
-    #MOVUPS
-    hex 0x0f,0x10,0x00
-    hex 0xf2
-    hex 0x0f,0x2c,0xf0
-
-    hex 0x58
-    #esi at [eax]
-    hex 0x89,6*8
-
-    #esi down
-    hex 0x5e
-
-    return value
-endfunction
-
-function str_to_double(ss strbytes,sd p_double)
-    ss doubleformat="%lf"
-    call sscanf(strbytes,doubleformat,p_double)
-endfunction
-
-function int_to_double(sd integer,sd p_double)
-    sd p_int^integer
-    call fild(p_int)
-    call fstp_quad(p_double)
-endfunction
-
-##tricks
-
-function fild(sd p_value)
-    call getoneax(p_value)
-    HEX 0xDB,0
-endfunction
-function fild_value(sd value)
-    sd p_value^value
-    call getoneax(p_value)
-    HEX 0xDB,0
-endfunction
-
-function fld(sd p_value)
-    call getoneax(p_value)
-    HEX 0xD9,0x00
-endfunction
-function fld_quad(sd p_value)
-    call getoneax(p_value)
-    HEX 0xDD,0x00
-endfunction
-
-function fistp(sd p_value)
-    call getoneax(p_value)
-    HEX 0xDB,3*8
-endfunction
-
-function fstp(sd p_value)
-    call getoneax(p_value)
-    HEX 0xD9,0x18
-endfunction
-function fst_quad(sd p_value)
-    call getoneax(p_value)
-    HEX 0xDD,2*to_regopcode
-endfunction
-function fstp_quad(sd p_value)
-    call getoneax(p_value)
-    HEX 0xDD,0x18
-endfunction
-
-#
-const fadd_op=0
-function fiadd(sd p_value)
-    call getoneax(p_value)
-    HEX 0xDA,fadd_op*to_regopcode
-endfunction
-function float_add(sd A,sd B)
-    sd p_A^A
-    sd p_B^B
-    call fld(p_A)
-    call getoneax(p_B)
-    HEX 0xD8,fadd_op*to_regopcode
-    call fstp(p_A)
-    return A
-endfunction
-function double_add(sd p_A,sd p_B)
-    call fld_quad(p_A)
-    call getoneax(p_B)
-    HEX 0xDC,fadd_op*to_regopcode
-    call fstp_quad(p_A)
-endfunction
-function fadd_quad(sd p_A)
-    call getoneax(p_A)
-    HEX 0xDC,fadd_op*to_regopcode
-endfunction
-
-const fsub_op=4
-function float_sub(sd A,sd B)
-    sd p_A^A
-    sd p_B^B
-    call fld(p_A)
-    call getoneax(p_B)
-    HEX 0xD8,fsub_op*to_regopcode
-    call fstp(p_A)
-    return A
-endfunction
-#function double_sub(sd p_A,sd p_B)
-#    call fld_quad(p_A)
-#    call getoneax(p_B)
-#    HEX 0xDC,fsub_op*to_regopcode
-#    call fstp_quad(p_A)
-#endfunction
-function fsub_quad(sd p_A)
-    call getoneax(p_A)
-    HEX 0xDC,fsub_op*to_regopcode
-endfunction
-
-const fmul_op=1
-function fimul(sd p_value)
-    call getoneax(p_value)
-    HEX 0xDA,fmul_op*to_regopcode
-endfunction
-function float_mult(sd A,sd B)
-    sd p_A^A
-    sd p_B^B
-    call fld(p_A)
-    call getoneax(p_B)
-    HEX 0xD8,fmul_op*to_regopcode
-    call fstp(p_A)
-    return A
-endfunction
-function double_mult(sd p_A,sd p_B)
-    call fld_quad(p_A)
-    call getoneax(p_B)
-    HEX 0xDC,fmul_op*to_regopcode
-    call fstp_quad(p_A)
-endfunction
-function fmul_quad(sd p_A)
-    call getoneax(p_A)
-    HEX 0xDC,fmul_op*to_regopcode
-endfunction
-
-const fdiv_op=6
-function fidiv(sd p_value)
-    call getoneax(p_value)
-    HEX 0xDA,fdiv_op*to_regopcode
-endfunction
-function double_div(sd p_A,sd p_B)
-    call fld_quad(p_A)
-    call getoneax(p_B)
-    HEX 0xDC,fdiv_op*to_regopcode
-    call fstp_quad(p_A)
-endfunction
-function fdiv_quad(sd p_A)
-    call getoneax(p_A)
-    HEX 0xDC,fdiv_op*to_regopcode
-endfunction
-
-
-
-#
-#bool
-function fcom_quad_greater(sd p_A)
-    sd aux
-    sd value
-    set aux p_A
-    sd p_aux^aux
-    #
-    call getoneax(p_aux)
-    #ecx eax
-    hex 0x8b,ecx*to_regopcode|mod_reg|eax
-    #eax [eax]
-    hex 0x8b,0
-    #fcom
-    HEX 0xDC,2*to_regopcode
-    #fstsw ax
-    HEX 0xDF,0xE0
-    #ecx +4
-    hex 0x81,mod_reg|ecx,4,0,0,0
-    #[ecx] eax
-    hex 0x8b,ecx*to_regopcode|eax
-    #
-    and value 0x00004100
-    if value==0
-        return 1
-    else
-        return 0
-    endelse
-endfunction
-#bool
-function fcom_quad_greater_or_equal(sd p_A)
-    sd aux
-    sd value
-    set aux p_A
-    sd p_aux^aux
-    #
-    call getoneax(p_aux)
-    #ecx eax
-    hex 0x8b,ecx*to_regopcode|mod_reg|eax
-    #eax [eax]
-    hex 0x8b,0
-    #fcom
-    HEX 0xDC,2*to_regopcode
-    #fstsw ax
-    HEX 0xDF,0xE0
-    #ecx +4
-    hex 0x81,mod_reg|ecx,4,0,0,0
-    #[ecx] eax
-    hex 0x8b,ecx*to_regopcode|eax
-    #
-    and value 0x00000100
-    if value==0
-        return 1
-    else
-        return 0
-    endelse
-endfunction
-
-function fcos()
-	hex 0xD9,0xFF
-endfunction
-
-function fsin()
-	hex 0xD9,0xFE
-endfunction
--- /dev/null
+++ ovideo-1/src/util/lists.oc
@@ -0,0 +1,68 @@
+
+
+
+format elfobj
+
+
+
+##lists
+function widget_get_children_number_count_fn(sd *element,sd data)
+    inc data#
+endfunction
+
+function widget_get_children_number_count(sd list,sd *data)
+    importx "_g_list_foreach" g_list_foreach
+    sd nr=0
+    sd ptr_nr^nr
+    data fn^widget_get_children_number_count_fn
+    call g_list_foreach(list,fn,ptr_nr)
+    return nr
+endfunction
+
+#returns what forward returns
+function widget_forward_children_data(sd widget,sv forward,sd data)
+    sd GList
+    importx "_gtk_container_get_children" gtk_container_get_children
+    setcall GList gtk_container_get_children(widget)
+    sd ret
+    setcall ret forward(GList,data)
+    importx "_g_list_free" g_list_free
+    call g_list_free(GList)
+    return ret
+endfunction
+
+#nr of widget childrens
+function widget_get_children_number(sd widget)
+    data fn^widget_get_children_number_count
+    sd ret
+    setcall ret widget_forward_children_data(widget,fn)
+    return ret
+endfunction
+
+
+#pos
+function widget_position_in_container(sd widget,sd container)
+    importx "_g_list_index" g_list_index
+    data f^g_list_index
+    sd ret
+    setcall ret widget_forward_children_data(container,f,widget)
+    return ret
+endfunction
+
+importx "_g_list_nth_data" g_list_nth_data
+
+function nthwidgetFromcontainer(data container,data index)
+    data widget#1
+    data GList#1
+    setcall GList gtk_container_get_children(container)
+    #the element's data, or NULL if the position is off the end of the GList
+    setcall widget g_list_nth_data(GList,index)
+    call g_list_free(GList)
+    return widget
+endfunction
+
+function firstwidgetFromcontainer(sd container)
+    sd widget
+    setcall widget nthwidgetFromcontainer(container,0)
+    return widget
+endfunction
--- ovideo-1.orig/src/util/lists.s
+++ /dev/null
@@ -1,68 +0,0 @@
-
-
-
-format elfobj
-
-
-
-##lists
-function widget_get_children_number_count_fn(sd *element,sd data)
-    inc data#
-endfunction
-
-function widget_get_children_number_count(sd list,sd *data)
-    importx "_g_list_foreach" g_list_foreach
-    sd nr=0
-    sd ptr_nr^nr
-    data fn^widget_get_children_number_count_fn
-    call g_list_foreach(list,fn,ptr_nr)
-    return nr
-endfunction
-
-#returns what forward returns
-function widget_forward_children_data(sd widget,sd forward,sd data)
-    sd GList
-    importx "_gtk_container_get_children" gtk_container_get_children
-    setcall GList gtk_container_get_children(widget)
-    sd ret
-    setcall ret forward(GList,data)
-    importx "_g_list_free" g_list_free
-    call g_list_free(GList)
-    return ret
-endfunction
-
-#nr of widget childrens
-function widget_get_children_number(sd widget)
-    data fn^widget_get_children_number_count
-    sd ret
-    setcall ret widget_forward_children_data(widget,fn)
-    return ret
-endfunction
-
-
-#pos
-function widget_position_in_container(sd widget,sd container)
-    importx "_g_list_index" g_list_index
-    data f^g_list_index
-    sd ret
-    setcall ret widget_forward_children_data(container,f,widget)
-    return ret
-endfunction
-
-importx "_g_list_nth_data" g_list_nth_data
-
-function nthwidgetFromcontainer(data container,data index)
-    data widget#1
-    data GList#1
-    setcall GList gtk_container_get_children(container)
-    #the element's data, or NULL if the position is off the end of the GList
-    setcall widget g_list_nth_data(GList,index)
-    call g_list_free(GList)
-    return widget
-endfunction
-
-function firstwidgetFromcontainer(sd container)
-    sd widget
-    setcall widget nthwidgetFromcontainer(container,0)
-    return widget
-endfunction
--- /dev/null
+++ ovideo-1/src/util/numbers.oc
@@ -0,0 +1,582 @@
+
+
+format elfobj
+
+
+include "../_include/include.h"
+
+import "getoneax" getoneax
+##math
+#low
+function mult64(sd a,sd *b,sd *ptrhigh)
+    sd pointer^a
+    call getoneax(pointer)
+    #ecx eax
+    hex 0x8b,ecx*to_regopcode|mod_reg|eax
+    #edx [eax+4]
+    hex 0x8b,edx*to_regopcode|mod_disp8|eax,4
+    #eax [eax]
+    hex 0x8b,0
+    #imul,edx
+    hex 0xf7,5*to_regopcode|mod_reg|edx
+    #[ecx] eax
+    hex 0x89,ecx
+    #eax [ecx+8]
+    hex 0x8b,mod_disp8|ecx,8
+    #[eax] edx
+    hex 0x89,edx*to_regopcode
+    #
+    return a
+endfunction
+#highint
+function mult64_highint_rounded(sd A,sd B)
+    sd value
+    sd p_value^value
+    sd low
+    setcall low mult64(A,B,p_value)
+    if low<0
+        inc value
+    endif
+    return value
+endfunction
+
+#return neg(nr)
+Function neg(data nr)
+        Data negative#1
+        Set negative nr
+        Sub nr negative
+        Sub nr negative
+        Return nr
+EndFunction
+
+
+
+function foreach_dword(sd size,sd vars,sv forward,sd data)
+    sd last
+    set last vars
+    add last size
+
+    data dw=4
+    sd e
+    data noe=noerror
+    while vars!=last
+#e
+        setcall e forward(vars,data)
+        if e!=noe
+            return e
+        endif
+        add vars dw
+    endwhile
+endfunction
+
+
+
+#bool numeric
+Function numeric(char c)
+        char zero="0"
+        char nine="9"
+        Data false=FALSE
+        Data true=TRUE
+	If c<zero
+                Return false
+	endif
+	If c>nine
+                Return false
+	EndIf
+        Return true
+EndFunction
+
+#bool
+Function memtoint(str content,data size,data outvalue)
+    set outvalue# 0
+    if size=0
+        return (FALSE)
+    endif
+    sd minusbool=FALSE
+    char negsign="-"
+    If content#=negsign
+        Inc content;Dec size
+        If size=0
+            Return (FALSE)
+        EndIf
+        set minusbool (TRUE)
+    EndIf
+    sd b;setcall b memtoint_add(content,size,outvalue,minusbool)
+    if minusbool=(TRUE)
+        if outvalue#>0
+#will go also at 4.294.967.296-6.442.450.943
+#                8.589.934.592-9.999.999.999
+#the truncations will be the user mistake
+            mult outvalue# -1
+        endif
+    endif
+    return b
+EndFunction
+#bool
+Function memtoint_add(str content,data size,data outvalue,data minusbool)
+#add at outvalue
+    Data number#1
+    data multx#1
+    set multx 1
+    Add content size
+    While size!=0
+        Dec content;Dec size
+
+        Data bool#1
+        char byte#1
+        Set byte content#
+        SetCall bool numeric(byte)
+        If bool=(FALSE)
+            Return (FALSE)
+        EndIf
+        Sub byte (_0)
+        Set number byte
+
+        sd adding;set adding number;mult adding multx
+        sd value;set value outvalue#
+        add outvalue# adding
+
+        const bil_1=1000*1000*1000
+        const bil_2=2*bil_1
+        const max_int=0x80<<8<<8<<8
+        const max_int_bil_2_rest=max_int-bil_2
+        if multx=(bil_1)
+		if size!=0
+                #(...)x xxx xxx xxx
+                while size!=0
+                    Dec content;Dec size
+                    if content#!=(_0)
+                        return (FALSE)
+                    endif
+                endwhile
+		endif
+		if number>2
+                #3 xxx xxx xxx-9 xxx xxx xxx
+                return (FALSE)
+		endif
+		if number=2
+			if value>(max_int_bil_2_rest)
+                    #2 147 483 649-2 999 999 999
+                    return (FALSE)
+			endif
+			if value=(max_int_bil_2_rest)
+                    if minusbool=(FALSE)
+                        #2 147 483 648 is the first positive overflow
+                        return (FALSE)
+                    endif
+			endif
+		endif
+        endif
+        mult multx 10
+    EndWhile
+    Return (TRUE)
+EndFunction
+
+import "slen" slen
+
+#bool
+function strtoint(sd str,sd ptrout)
+    sd sz
+    setcall sz slen(str)
+    sd bool
+    setcall bool memtoint(str,sz,ptrout)
+    return bool
+endfunction
+
+import "texter" texter
+
+#bool
+function strtoint_positive(ss str,sd ptr_out)
+    sd bool
+    setcall bool strtoint(str,ptr_out)
+    str posint="Positive integer number expected"
+    if bool=0
+        call texter(posint)
+        return 0
+    endif
+    if ptr_out#<0
+        call texter(posint)
+        return 0
+    endif
+    return 1
+endfunction
+
+#bool
+function strtoint_positive_not_zero(ss str,sd ptr_out)
+    sd bool
+    setcall bool strtoint_positive(str,ptr_out)
+	if bool=0
+        return 0
+	endif
+	if ptr_out#=0
+        str notzero="Unexpected 0(zero) number"
+        call texter(notzero)
+        return 0
+	endif
+    return 1
+endfunction
+
+#bool
+function strtoint_positive_twoorgreater(ss str,sd ptr_out)
+    sd bool
+    setcall bool strtoint_positive(str,ptr_out)
+	if bool=0
+        return 0
+	endif
+	if ptr_out#<2
+        str errnr="A number equal or greater than 2 expected"
+        call texter(errnr)
+        return 0
+	endif
+    return 1
+endfunction
+
+#bool
+function strtoint_positive_N_or_Greater(ss str,sd ptr_out,sd n)
+    sd bool
+    setcall bool strtoint_positive(str,ptr_out)
+	if bool=0
+        return 0
+	endif
+	if ptr_out#<n
+        import "strdworddisp" strdworddisp
+        str errnr="Expecting a number equal or greater than "
+        call strdworddisp(errnr,n)
+        return 0
+	endif
+    return 1
+endfunction
+
+function word_reverse(sd word,ss dest)
+    #256=0x01 00
+    ss src^word
+
+    #01
+    inc dest
+    set dest# word
+    dec dest
+
+    #00
+    inc src
+    set dest# src#
+endfunction
+
+function dword_reverse(sd value)
+    sd al
+    sd ah
+    sd third
+    sd last
+
+    set al value
+    and al 0xff
+
+    set ah value
+    and ah 0xff00
+
+    set third value
+    and third 0xff0000
+
+    set last value
+    and last 0xff000000
+
+    mult al 0x1000000
+    mult ah 0x100
+    div third 0x100
+    div last 0x1000000
+    #for negative division, the number can be negative
+    and last 0xff
+
+    or al ah
+    or al third
+    or al last
+    return al
+endfunction
+
+function rule3(sd knownA,sd knownB,sd unknownB)
+    #kA       x
+    #kB       uB
+    sd x
+    set x unknownB
+    mult x knownA
+    div x knownB
+    return x
+endfunction
+
+function rule3_offset(sd knownA,sd knownB,sd x_off,sd unknownB)
+#kA    kB
+#x ukB-off
+#x+off
+    sd x
+    sub unknownB x_off
+    setcall x rule3(knownA,knownB,unknownB)
+    add x x_off
+    return x
+endfunction
+
+function rule3_two_offsets(sd k_off,sd knownA,sd knownB,sd x_off,sd unknownB)
+#kA-k_off  kB-k_off
+#x      ukB-off
+#x+off
+    sub knownA k_off
+    sub knownB k_off
+    sd x
+    setcall x rule3_offset(knownA,knownB,x_off,unknownB)
+    return x
+endfunction
+
+#width,height in p_height
+function rectangle_fit_container_rectangle(sd width,sd height,sd c_width,sd c_height,sd p_height)
+    #get the fit width and height
+    sd value
+    #get the width if the height is like container
+    setcall value rule3(width,height,c_height)
+
+    if value<c_width
+        #width is lower and is ok, height is like container
+        set c_width value
+    else
+        #width is higher and like container is returned,get the width
+        setcall c_height rule3(height,width,c_width)
+    endelse
+
+    set p_height# c_height
+    return c_width
+endfunction
+
+#a-(a/b*b)
+function rest(sd a,sd b)
+    sd trunc
+    set trunc a
+    div trunc b
+    mult trunc b
+    sub a trunc
+    return a
+endfunction
+
+function multiple_of_nr(sd value,sd nr)
+    sd result
+    set result value
+    div value nr
+    mult value nr
+    if value=result
+        return result
+    endif
+    div result nr
+    inc result
+    mult result nr
+    return result
+endfunction
+
+
+function centered(sd line,sd part)
+    sub line part
+    div line 2
+    return line
+endfunction
+
+
+function get_lower(sd A,sd B)
+	if A<B
+        return A
+	endif
+        return B
+endfunction
+function get_higher(sd A,sd B)
+	if A>B
+        return A
+	endif
+        return B
+endfunction
+
+##char,short,int
+
+function char_to_int(sd char)
+    sd test
+    set test char
+    and test 0x80
+    sd result=0
+    if test!=0
+        set result 0xffFFff00
+    endif
+    or result char
+    return result
+endfunction
+function short_to_int(sd short)
+    sd test
+    set test short
+    and test 0x8000
+    sd result=0
+    if test!=0
+        set result 0xffFF0000
+    endif
+    or result short
+    return result
+endfunction
+import "cpymem" cpymem
+function short_get_to_int(sd short)
+    sd value=0
+    sd p_value^value
+    call cpymem(p_value,short,2)
+    setcall value short_to_int(value)
+    return value
+endfunction
+function int_into_short(sd int,sd p_short)
+    sd p_int^int
+    call cpymem(p_short,p_int,2)
+endfunction
+
+##structs/arrays
+
+function array_bi_index(sd set1,sd set1_size,sd set2)
+    mult set1 set1_size
+    add set1 set2
+    return set1
+endfunction
+
+#1, return 1
+function array_get_byte(ss array,sd pos)
+    add array pos
+    return array#
+endfunction
+
+
+function array_byte_setAtXY(ss array,sd value,sd x,sd y,sd rowstride)
+    mult rowstride y
+    add rowstride x
+    add array rowstride
+    set array# value
+endfunction
+
+function array_set_byte_off(ss array,sd value,sd offset)
+    add array offset
+    set array# value
+endfunction
+
+function array_set_byte_offsets(ss array,sd value,sd off1,sd off2)
+    add array off1
+    add array off2
+    set array# value
+endfunction
+
+#1, return 4
+
+function structure_get_int(sd struct,sd pos)
+    add struct pos
+    return struct#
+endfunction
+
+#2
+function array_get_word(ss array,sd pos)
+    mult pos 2
+    add array pos
+    sd result
+    set result array#
+    inc array
+    sd highword
+    set highword array#
+    mult highword 0x100
+    or result highword
+    return result
+endfunction
+
+function array_get_int16(ss array,sd pos)
+    mult pos 2
+    add array pos
+    sd result
+    set result array#
+    inc array
+    sd highword
+    set highword array#
+    mult highword 0x100
+    or result highword
+#
+    setcall result short_to_int(result)
+#
+    return result
+endfunction
+function array_get_int16_bi(ss array,sd set1,sd set1_size,sd set2)
+    sd pos
+    setcall pos array_bi_index(set1,set1_size,set2)
+    sd value
+    setcall value array_get_int16(array,pos)
+    return value
+endfunction
+
+function array_set_word_off(sd array,sd value,sd offset)
+#off * 2
+    mult offset 2
+    add array offset
+
+    sd P^value
+
+    call cpymem(array,P,2)
+endfunction
+
+function array_set_word_bi(sd array,sd set1,sd set1_size,sd set2,sd value)
+    mult set1 set1_size
+    mult set1 2
+    add array set1
+    call array_set_word_off(array,value,set2)
+endfunction
+function array_set_word_offsets(sd array,sd value,sd off1,sd off2)
+    mult off1 2
+    add array off1
+    call array_set_word_off(array,value,off2)
+endfunction
+
+#4
+function array_get_int(sd array,sd pos)
+    mult pos 4
+    add array pos
+    return array#
+endfunction
+function array_set_int(sd array,sd pos,sd value)
+    mult pos 4
+    add array pos
+    set array# value
+endfunction
+
+function array_set_4value_offsets(sd struct,sd value,sd off1,sd off2)
+#offsets are mult with 4
+    mult off1 4
+    mult off2 4
+    add struct off1
+    add struct off2
+    set struct# value
+endfunction
+
+#mathings
+
+#pos/-1
+function int_in_set(sd int,sd set,sd set_count)
+    if set_count=0
+        return -1
+    endif
+    sd start
+    set start set
+    while set#!=int
+        add set (DWORD)
+        dec set_count
+        if set_count=0
+            return -1
+        endif
+    endwhile
+    sub set start
+    div set (DWORD)
+    return set
+endfunction
+
+
+#others
+
+#x                   known_denom
+#unknown_nom         known_nom
+function numbers_proportion(sd unknown_nom,sd known_denom,sd known_nom)
+    mult known_denom unknown_nom
+    div known_denom known_nom
+    return known_denom
+endfunction
+
+
+
+
--- ovideo-1.orig/src/util/numbers.s
+++ /dev/null
@@ -1,578 +0,0 @@
-
-
-format elfobj
-
-
-include "../_include/include.h"
-
-import "getoneax" getoneax
-##math
-#low
-function mult64(sd a,sd *b,sd *ptrhigh)
-    sd pointer^a
-    call getoneax(pointer)
-    #ecx eax
-    hex 0x8b,ecx*to_regopcode|mod_reg|eax
-    #edx [eax+4]
-    hex 0x8b,edx*to_regopcode|mod_disp8|eax,4
-    #eax [eax]
-    hex 0x8b,0
-    #imul,edx
-    hex 0xf7,5*to_regopcode|mod_reg|edx
-    #[ecx] eax
-    hex 0x89,ecx
-    #eax [ecx+8]
-    hex 0x8b,mod_disp8|ecx,8
-    #[eax] edx
-    hex 0x89,edx*to_regopcode
-    #
-    return a
-endfunction
-#highint
-function mult64_highint_rounded(sd A,sd B)
-    sd value
-    sd p_value^value
-    sd low
-    setcall low mult64(A,B,p_value)
-    if low<0
-        inc value
-    endif
-    return value
-endfunction
-
-#return neg(nr)
-Function neg(data nr)
-        Data negative#1
-        Set negative nr
-        Sub nr negative
-        Sub nr negative
-        Return nr
-EndFunction
-
-
-
-function foreach_dword(sd size,sd vars,sd forward,sd data)
-    sd last
-    set last vars
-    add last size
-
-    data dw=4
-    sd e
-    data noe=noerror
-    while vars!=last
-#e
-        setcall e forward(vars,data)
-        if e!=noe
-            return e
-        endif
-        add vars dw
-    endwhile
-endfunction
-
-
-
-#bool numeric
-Function numeric(char c)
-        char zero="0"
-        char nine="9"
-        Data false=FALSE
-        Data true=TRUE
-        If c<zero
-                Return false
-        ElseIf c>nine
-                Return false
-        EndElseIf
-        Return true
-EndFunction
-
-#bool
-Function memtoint(str content,data size,data outvalue)
-    set outvalue# 0
-    if size==0
-        return (FALSE)
-    endif
-    sd minusbool=FALSE
-    char negsign="-"
-    If content#==negsign
-        Inc content;Dec size
-        If size==0
-            Return (FALSE)
-        EndIf
-        set minusbool (TRUE)
-    EndIf
-    sd b;setcall b memtoint_add(content,size,outvalue,minusbool)
-    if minusbool==(TRUE)
-        if outvalue#>0
-#will go also at 4.294.967.296-6.442.450.943
-#                8.589.934.592-9.999.999.999
-#the truncations will be the user mistake
-            mult outvalue# -1
-        endif
-    endif
-    return b
-EndFunction
-#bool
-Function memtoint_add(str content,data size,data outvalue,data minusbool)
-#add at outvalue
-    Data number#1
-    data multx#1
-    set multx 1
-    Add content size
-    While size!=0
-        Dec content;Dec size
-
-        Data bool#1
-        char byte#1
-        Set byte content#
-        SetCall bool numeric(byte)
-        If bool==(FALSE)
-            Return (FALSE)
-        EndIf
-        Sub byte (_0)
-        Set number byte
-
-        sd adding;set adding number;mult adding multx
-        sd value;set value outvalue#
-        add outvalue# adding
-
-        const bil_1=1000*1000*1000
-        const bil_2=2*bil_1
-        const max_int=0x80*0x100*0x100*0x100
-        const max_int_bil_2_rest=max_int-bil_2
-        if multx==(bil_1)
-            if size!=0
-                #(...)x xxx xxx xxx
-                while size!=0
-                    Dec content;Dec size
-                    if content#!=(_0)
-                        return (FALSE)
-                    endif
-                endwhile
-            endif
-            if number>2
-                #3 xxx xxx xxx-9 xxx xxx xxx
-                return (FALSE)
-            elseif number==2
-                if value>(max_int_bil_2_rest)
-                    #2 147 483 649-2 999 999 999
-                    return (FALSE)
-                elseif value==(max_int_bil_2_rest)
-                    if minusbool==(FALSE)
-                        #2 147 483 648 is the first positive overflow
-                        return (FALSE)
-                    endif
-                endelseif
-            endelseif
-        endif
-        mult multx 10
-    EndWhile
-    Return (TRUE)
-EndFunction
-
-import "slen" slen
-
-#bool
-function strtoint(sd str,sd ptrout)
-    sd sz
-    setcall sz slen(str)
-    sd bool
-    setcall bool memtoint(str,sz,ptrout)
-    return bool
-endfunction
-
-import "texter" texter
-
-#bool
-function strtoint_positive(ss str,sd ptr_out)
-    sd bool
-    setcall bool strtoint(str,ptr_out)
-    str posint="Positive integer number expected"
-    if bool==0
-        call texter(posint)
-        return 0
-    endif
-    if ptr_out#<0
-        call texter(posint)
-        return 0
-    endif
-    return 1
-endfunction
-
-#bool
-function strtoint_positive_not_zero(ss str,sd ptr_out)
-    sd bool
-    setcall bool strtoint_positive(str,ptr_out)
-    if bool==0
-        return 0
-    elseif ptr_out#==0
-        str notzero="Unexpected 0(zero) number"
-        call texter(notzero)
-        return 0
-    endelseif
-    return 1
-endfunction
-
-#bool
-function strtoint_positive_twoorgreater(ss str,sd ptr_out)
-    sd bool
-    setcall bool strtoint_positive(str,ptr_out)
-    if bool==0
-        return 0
-    elseif ptr_out#<2
-        str errnr="A number equal or greater than 2 expected"
-        call texter(errnr)
-        return 0
-    endelseif
-    return 1
-endfunction
-
-#bool
-function strtoint_positive_N_or_Greater(ss str,sd ptr_out,sd n)
-    sd bool
-    setcall bool strtoint_positive(str,ptr_out)
-    if bool==0
-        return 0
-    elseif ptr_out#<n
-        import "strdworddisp" strdworddisp
-        str errnr="Expecting a number equal or greater than "
-        call strdworddisp(errnr,n)
-        return 0
-    endelseif
-    return 1
-endfunction
-
-function word_reverse(sd word,ss dest)
-    #256=0x01 00
-    ss src^word
-
-    #01
-    inc dest
-    set dest# word
-    dec dest
-
-    #00
-    inc src
-    set dest# src#
-endfunction
-
-function dword_reverse(sd value)
-    sd al
-    sd ah
-    sd third
-    sd last
-
-    set al value
-    and al 0xff
-
-    set ah value
-    and ah 0xff00
-
-    set third value
-    and third 0xff0000
-
-    set last value
-    and last 0xff000000
-
-    mult al 0x1000000
-    mult ah 0x100
-    div third 0x100
-    div last 0x1000000
-    #for negative division, the number can be negative
-    and last 0xff
-
-    or al ah
-    or al third
-    or al last
-    return al
-endfunction
-
-function rule3(sd knownA,sd knownB,sd unknownB)
-    #kA       x
-    #kB       uB
-    sd x
-    set x unknownB
-    mult x knownA
-    div x knownB
-    return x
-endfunction
-
-function rule3_offset(sd knownA,sd knownB,sd x_off,sd unknownB)
-#kA    kB
-#x ukB-off
-#x+off
-    sd x
-    sub unknownB x_off
-    setcall x rule3(knownA,knownB,unknownB)
-    add x x_off
-    return x
-endfunction
-
-function rule3_two_offsets(sd k_off,sd knownA,sd knownB,sd x_off,sd unknownB)
-#kA-k_off  kB-k_off
-#x      ukB-off
-#x+off
-    sub knownA k_off
-    sub knownB k_off
-    sd x
-    setcall x rule3_offset(knownA,knownB,x_off,unknownB)
-    return x
-endfunction
-
-#width,height in p_height
-function rectangle_fit_container_rectangle(sd width,sd height,sd c_width,sd c_height,sd p_height)
-    #get the fit width and height
-    sd value
-    #get the width if the height is like container
-    setcall value rule3(width,height,c_height)
-
-    if value<c_width
-        #width is lower and is ok, height is like container
-        set c_width value
-    else
-        #width is higher and like container is returned,get the width
-        setcall c_height rule3(height,width,c_width)
-    endelse
-
-    set p_height# c_height
-    return c_width
-endfunction
-
-#a-(a/b*b)
-function rest(sd a,sd b)
-    sd trunc
-    set trunc a
-    div trunc b
-    mult trunc b
-    sub a trunc
-    return a
-endfunction
-
-function multiple_of_nr(sd value,sd nr)
-    sd result
-    set result value
-    div value nr
-    mult value nr
-    if value==result
-        return result
-    endif
-    div result nr
-    inc result
-    mult result nr
-    return result
-endfunction
-
-
-function centered(sd line,sd part)
-    sub line part
-    div line 2
-    return line
-endfunction
-
-
-function get_lower(sd A,sd B)
-    if A<B
-        return A
-    else
-        return B
-    endelse
-endfunction
-function get_higher(sd A,sd B)
-    if A>B
-        return A
-    else
-        return B
-    endelse
-endfunction
-
-##char,short,int
-
-function char_to_int(sd char)
-    sd test
-    set test char
-    and test 0x80
-    sd result=0
-    if test!=0
-        set result 0xffFFff00
-    endif
-    or result char
-    return result
-endfunction
-function short_to_int(sd short)
-    sd test
-    set test short
-    and test 0x8000
-    sd result=0
-    if test!=0
-        set result 0xffFF0000
-    endif
-    or result short
-    return result
-endfunction
-import "cpymem" cpymem
-function short_get_to_int(sd short)
-    sd value=0
-    sd p_value^value
-    call cpymem(p_value,short,2)
-    setcall value short_to_int(value)
-    return value
-endfunction
-function int_into_short(sd int,sd p_short)
-    sd p_int^int
-    call cpymem(p_short,p_int,2)
-endfunction
-
-##structs/arrays
-
-function array_bi_index(sd set1,sd set1_size,sd set2)
-    mult set1 set1_size
-    add set1 set2
-    return set1
-endfunction
-
-#1, return 1
-function array_get_byte(ss array,sd pos)
-    add array pos
-    return array#
-endfunction
-
-
-function array_byte_setAtXY(ss array,sd value,sd x,sd y,sd rowstride)
-    mult rowstride y
-    add rowstride x
-    add array rowstride
-    set array# value
-endfunction
-
-function array_set_byte_off(ss array,sd value,sd offset)
-    add array offset
-    set array# value
-endfunction
-
-function array_set_byte_offsets(ss array,sd value,sd off1,sd off2)
-    add array off1
-    add array off2
-    set array# value
-endfunction
-
-#1, return 4
-
-function structure_get_int(sd struct,sd pos)
-    add struct pos
-    return struct#
-endfunction
-
-#2
-function array_get_word(ss array,sd pos)
-    mult pos 2
-    add array pos
-    sd result
-    set result array#
-    inc array
-    sd highword
-    set highword array#
-    mult highword 0x100
-    or result highword
-    return result
-endfunction
-
-function array_get_int16(ss array,sd pos)
-    mult pos 2
-    add array pos
-    sd result
-    set result array#
-    inc array
-    sd highword
-    set highword array#
-    mult highword 0x100
-    or result highword
-#
-    setcall result short_to_int(result)
-#
-    return result
-endfunction
-function array_get_int16_bi(ss array,sd set1,sd set1_size,sd set2)
-    sd pos
-    setcall pos array_bi_index(set1,set1_size,set2)
-    sd value
-    setcall value array_get_int16(array,pos)
-    return value
-endfunction
-
-function array_set_word_off(sd array,sd value,sd offset)
-#off * 2
-    mult offset 2
-    add array offset
-
-    sd P^value
-
-    call cpymem(array,P,2)
-endfunction
-
-function array_set_word_bi(sd array,sd set1,sd set1_size,sd set2,sd value)
-    mult set1 set1_size
-    mult set1 2
-    add array set1
-    call array_set_word_off(array,value,set2)
-endfunction
-function array_set_word_offsets(sd array,sd value,sd off1,sd off2)
-    mult off1 2
-    add array off1
-    call array_set_word_off(array,value,off2)
-endfunction
-
-#4
-function array_get_int(sd array,sd pos)
-    mult pos 4
-    add array pos
-    return array#
-endfunction
-function array_set_int(sd array,sd pos,sd value)
-    mult pos 4
-    add array pos
-    set array# value
-endfunction
-
-function array_set_4value_offsets(sd struct,sd value,sd off1,sd off2)
-#offsets are mult with 4
-    mult off1 4
-    mult off2 4
-    add struct off1
-    add struct off2
-    set struct# value
-endfunction
-
-#mathings
-
-#pos/-1
-function int_in_set(sd int,sd set,sd set_count)
-    if set_count==0
-        return -1
-    endif
-    sd start
-    set start set
-    while set#!=int
-        add set (DWORD)
-        dec set_count
-        if set_count==0
-            return -1
-        endif
-    endwhile
-    sub set start
-    div set (DWORD)
-    return set
-endfunction
-
-
-#others
-
-#x                   known_denom
-#unknown_nom         known_nom
-function numbers_proportion(sd unknown_nom,sd known_denom,sd known_nom)
-    mult known_denom unknown_nom
-    div known_denom known_nom
-    return known_denom
-endfunction
-
-
-
-
--- /dev/null
+++ ovideo-1/src/util/update.oc
@@ -0,0 +1,129 @@
+
+
+
+
+format elfobj
+
+include "../_include/include.h"
+
+
+
+#v
+function update_got_new(ss text)
+    vstr toupdate="Update available at site (to disable this notification uncheck 'Check for updates' from stage preferences). New version: "
+    data strtype=stringstring
+    import "strvaluedisp" strvaluedisp
+    call strvaluedisp(toupdate,text,strtype)
+endfunction
+
+import "move_to_share_v" move_to_share_v
+importx "_g_object_unref" g_object_unref
+importx "_g_idle_add" g_idle_add
+
+#void
+function update_async_callback(sd ses,sd msg) #,sd data
+	sd netmem
+	sd netsize
+	import "getSessionMessageBody" getSessionMessageBody
+	sd bool
+	setcall bool getSessionMessageBody(msg,#netmem,#netsize)
+	if bool=(TRUE)
+		call move_to_share_v()
+		sd mem
+		sd size
+		import "file_get_content" file_get_content
+		sd err
+		setcall err file_get_content("version.txt",#size,#mem)
+		if err=(noerror)
+			call update_got_netversion(mem,size,netmem,netsize)
+			importx "_free" free
+			call free(mem)
+		endif
+	endif
+	call g_idle_add(update_async_sync,ses) #unref session later, not in session callback
+endfunction
+
+#bool
+function update_async_sync(sd ses)
+	call g_object_unref(ses)
+	return (FALSE)
+endfunction
+
+#void
+function update_got_netversion(sd mem,sd size,sd netmem,sd netsize)
+    #forward to view if it is a new version
+    data compare#1
+    import "cmpmem_s" cmpmem_s
+    setcall compare cmpmem_s(netmem,netsize,mem,size)
+
+    data different=differentCompare
+    if compare=different
+        import "memtostrFw_s" memtostrFw_s
+        const safeversion=1+1+3+1 #hard coded, hard to remember
+        char newvers#safeversion
+        vstr newv^newvers
+        data sfsize=safeversion
+        vdata fw^update_got_new
+        call memtostrFw_s(netmem,netsize,newv,sfsize,fw)
+    endif
+endfunction
+
+function update()
+	sd up
+	setcall up update_get()
+	if up=(FALSE)
+		return (void)
+	endif
+
+	import "uri_queue_content" uri_queue_content
+	ss s="https://gist.github.com/colin-i/1c06e597689e204793a7e89fbcf2a481/raw"
+	#ss s="http://localhost/b.php"
+
+	call uri_queue_content(s,update_async_callback)
+endfunction
+
+function update_path()
+    str update_fname="update.data"
+    return update_fname
+endfunction
+function update_mem()
+    data mem#1
+    return #mem
+endfunction
+import "openfile" openfile
+importx "_fclose" fclose
+function update_set(sd value)
+    ss path
+    setcall path update_path()
+    sd err
+    sd file
+    setcall err openfile(#file,path,"wb")
+    if err!=(noerror)
+        return (void)
+    endif
+    import "file_write" file_write
+    call file_write(#value,4,file)
+    call fclose(file)
+    sd mem
+    setcall mem update_mem()
+    set mem# value
+endfunction
+#file_value
+function update_get()
+    ss path
+    setcall path update_path()
+    sd err
+    sd file
+    setcall err openfile(#file,path,"rb")
+    if err!=(noerror)
+        return (FALSE)
+    endif
+    import "file_get_dword" file_get_dword
+    sd value=0
+    call file_get_dword(file,#value)
+    call fclose(file)
+    sd mem
+    setcall mem update_mem()
+    set mem# value
+    return value
+endfunction
--- ovideo-1.orig/src/util/update.s
+++ /dev/null
@@ -1,129 +0,0 @@
-
-
-
-
-format elfobj
-
-include "../_include/include.h"
-
-
-
-#v
-function update_got_new(ss text)
-    vstr toupdate="Update available at site (to disable this notification uncheck 'Check for updates' from stage preferences). New version: "
-    data strtype=stringstring
-    import "strvaluedisp" strvaluedisp
-    call strvaluedisp(toupdate,text,strtype)
-endfunction
-
-import "move_to_share_v" move_to_share_v
-importx "_g_object_unref" g_object_unref
-importx "_g_idle_add" g_idle_add
-
-#void
-function update_async_callback(sd ses,sd msg) #,sd data
-	sd netmem
-	sd netsize
-	import "getSessionMessageBody" getSessionMessageBody
-	sd bool
-	setcall bool getSessionMessageBody(msg,#netmem,#netsize)
-	if bool==(TRUE)
-		call move_to_share_v()
-		sd mem
-		sd size
-		import "file_get_content" file_get_content
-		sd err
-		setcall err file_get_content("version.txt",#size,#mem)
-		if err==(noerror)
-			call update_got_netversion(mem,size,netmem,netsize)
-			importx "_free" free
-			call free(mem)
-		endif
-	endif
-	call g_idle_add(update_async_sync,ses) #unref session later, not in session callback
-endfunction
-
-#bool
-function update_async_sync(sd ses)
-	call g_object_unref(ses)
-	return (FALSE)
-endfunction
-
-#void
-function update_got_netversion(sd mem,sd size,sd netmem,sd netsize)
-    #forward to view if it is a new version
-    data compare#1
-    import "cmpmem_s" cmpmem_s
-    setcall compare cmpmem_s(netmem,netsize,mem,size)
-
-    data different=differentCompare
-    if compare==different
-        import "memtostrFw_s" memtostrFw_s
-        const safeversion=1+1+3+1 #hard coded, hard to remember
-        char newvers#safeversion
-        vstr newv^newvers
-        data sfsize=safeversion
-        vdata fw^update_got_new
-        call memtostrFw_s(netmem,netsize,newv,sfsize,fw)
-    endif
-endfunction
-
-function update()
-	sd up
-	setcall up update_get()
-	if up==(FALSE)
-		return (void)
-	endif
-
-	import "uri_queue_content" uri_queue_content
-	ss s="https://gist.github.com/colin-i/1c06e597689e204793a7e89fbcf2a481/raw"
-	#ss s="http://localhost/b.php"
-
-	call uri_queue_content(s,update_async_callback)
-endfunction
-
-function update_path()
-    str update_fname="update.data"
-    return update_fname
-endfunction
-function update_mem()
-    data mem#1
-    return #mem
-endfunction
-import "openfile" openfile
-importx "_fclose" fclose
-function update_set(sd value)
-    ss path
-    setcall path update_path()
-    sd err
-    sd file
-    setcall err openfile(#file,path,"wb")
-    if err!=(noerror)
-        return (void)
-    endif
-    import "file_write" file_write
-    call file_write(#value,4,file)
-    call fclose(file)
-    sd mem
-    setcall mem update_mem()
-    set mem# value
-endfunction
-#file_value
-function update_get()
-    ss path
-    setcall path update_path()
-    sd err
-    sd file
-    setcall err openfile(#file,path,"rb")
-    if err!=(noerror)
-        return (FALSE)
-    endif
-    import "file_get_dword" file_get_dword
-    sd value=0
-    call file_get_dword(file,#value)
-    call fclose(file)
-    sd mem
-    setcall mem update_mem()
-    set mem# value
-    return value
-endfunction
--- /dev/null
+++ ovideo-1/src/util/util.oc
@@ -0,0 +1,83 @@
+
+format elfobj
+
+include "../_include/include.h"
+
+
+import "texter" texter
+
+##display
+
+#void
+function strvaluedisp(str text,data part2,data formattype)
+    str int="%s%i"
+    str uint="%s%u"
+    str str="%s%s"
+
+    data si=stringinteger
+    data su=stringUinteger
+
+    const infomax=200
+    char disp#infomax
+    str display^disp
+
+    import "slen" slen
+    data max=infomax
+    data truncation#1
+    data notruncation=0
+    data dword=4
+    char truncdata="..."
+    data truncdots^truncdata
+
+    set truncation notruncation
+
+    str format#1
+    if formattype=si
+        set format int
+    elseif formattype=su
+        set format uint
+    else
+        set format str
+
+        data sz#1
+        setcall sz slen(text)
+        addcall sz slen(part2)
+        if sz>=max
+            set truncation display
+            add truncation max
+            sub truncation dword
+        endif
+    endelse
+
+    import "c_snprintf_strvaluedisp" c_snprintf_strvaluedisp
+    call c_snprintf_strvaluedisp(display,max,format,text,part2)
+
+    if truncation!=notruncation
+        set truncation# truncdots#
+    endif
+
+    call texter(display)
+endfunction
+
+function strstrdisp(str text,str part2)
+    data ss=stringstring
+    call strvaluedisp(text,part2,ss)
+endfunction
+
+function strdworddisp(str text,sd part2)
+    data sd=stringUinteger
+    call strvaluedisp(text,part2,sd)
+endfunction
+
+
+function content_size(sd ptrdata1,sd ptrdata2)
+    set ptrdata2# ptrdata1#
+    data dw=4
+    add ptrdata1 dw
+    add ptrdata2 dw
+    set ptrdata2# ptrdata1#
+endfunction
+
+
+
+
--- ovideo-1.orig/src/util/util.s
+++ /dev/null
@@ -1,83 +0,0 @@
-
-format elfobj
-
-include "../_include/include.h"
-
-
-import "texter" texter
-
-##display
-
-#void
-function strvaluedisp(str text,data part2,data formattype)
-    str int="%s%i"
-    str uint="%s%u"
-    str str="%s%s"
-
-    data si=stringinteger
-    data su=stringUinteger
-
-    const infomax=200
-    char disp#infomax
-    str display^disp
-
-    import "slen" slen
-    data max=infomax
-    data truncation#1
-    data notruncation=0
-    data dword=4
-    char truncdata="..."
-    data truncdots^truncdata
-
-    set truncation notruncation
-
-    str format#1
-    if formattype==si
-        set format int
-    elseif formattype==su
-        set format uint
-    else
-        set format str
-
-        data sz#1
-        setcall sz slen(text)
-        addcall sz slen(part2)
-        if sz>=max
-            set truncation display
-            add truncation max
-            sub truncation dword
-        endif
-    endelse
-
-    import "c_snprintf_strvaluedisp" c_snprintf_strvaluedisp
-    call c_snprintf_strvaluedisp(display,max,format,text,part2)
-
-    if truncation!=notruncation
-        set truncation# truncdots#
-    endif
-
-    call texter(display)
-endfunction
-
-function strstrdisp(str text,str part2)
-    data ss=stringstring
-    call strvaluedisp(text,part2,ss)
-endfunction
-
-function strdworddisp(str text,sd part2)
-    data sd=stringUinteger
-    call strvaluedisp(text,part2,sd)
-endfunction
-
-
-function content_size(sd ptrdata1,sd ptrdata2)
-    set ptrdata2# ptrdata1#
-    data dw=4
-    add ptrdata1 dw
-    add ptrdata2 dw
-    set ptrdata2# ptrdata1#
-endfunction
-
-
-
-
--- ovideo-1.orig/version.txt
+++ ovideo-1/version.txt
@@ -1 +1 @@
-1.188
\ No newline at end of file
+1.189
\ No newline at end of file
--- ovideo-1.orig/win_make_objects.bat
+++ ovideo-1/win_make_objects.bat
@@ -2,96 +2,96 @@
 ::use Makefile
 exit
 
-o.exe "_dif/dif~win.s"
-o.exe "_exec/ostream.s"
-o.exe "_exec/start.s"
-o.exe "_exec/mainhandles.s"
-o.exe "_exec/uri.s"
-o.exe "_exec/uristream.s"
-o.exe "_exec/capture/save.s"
-o.exe "_exec/mediainfo.s"
-o.exe "_prepare/view.s"
-o.exe "_prepare/pipe.s"
-o.exe "_prepare/sel.s"
-o.exe "_prepare/prevw.s"
-o.exe "_prepare/paint.s"
-o.exe "_prepare/stagempeg.s"
-o.exe "_prepare/output/all.s"
-o.exe "_prepare/output/stagefileoptions.s"
-o.exe "_prepare/output/sound.s"
-o.exe "_prepare/output/avi.s"
-o.exe "_prepare/output/mkv.s"
-o.exe "_prepare/frame/frame.s"
-o.exe "_prepare/frame/add.s"
-o.exe "_prepare/frame/remove.s"
-o.exe "_prepare/frame/frametime.s"
-o.exe "_prepare/frame/imagetools.s"
-o.exe "_prepare/frame/scale.s"
-o.exe "_prepare/frame/crop.s"
-o.exe "_prepare/frame/pencil.s"
-o.exe "_prepare/frame/screenshot.s"
-o.exe "_prepare/frame/brightness.s"
-o.exe "_prepare/frame/overlay.s"
-o.exe "_prepare/frame/rotate.s"
-o.exe "_prepare/effect/base.s"
-o.exe "_prepare/effect/fade.s"
-o.exe "_prepare/effect/move.s"
-o.exe "_prepare/effect/scale_effect.s"
-o.exe "_prepare/effect/reveal.s"
-o.exe "_prepare/effect/reveal_shape.s"
-o.exe "_prepare/effect/reveal_diagonal.s"
-o.exe "_search/dialog.s"
-o.exe "_search/dialog_fns.s"
-o.exe "_search/parse.s"
-o.exe "_search/previews.s"
-o.exe "_exec/mix.s"
-o.exe "_exec/help.s"
-o.exe "_capture/capture.s"
-o.exe "util/util.s"
-o.exe "util/update.s"
-o.exe "util/numbers.s"
-o.exe "util/floating.s"
-o.exe "util/lists.s"
-o.exe "util/asm.s"
-o.exe "media/audiovideo.s"
-o.exe "media/jpeg.s"
-o.exe "media/jpeg_enc.s"
-o.exe "media/mpeg.s"
-o.exe "media/mpeg_init.s"
-o.exe "media/mpeg_enc.s"
-o.exe "media/mpeg_pred.s"
-o.exe "media/mpeg_code.s"
-o.exe "media/mpeg_interframe.s"
-o.exe "media/mp4.s"
-o.exe "media/mp4_data.s"
-o.exe "media/mpeg-avc_data.s"
-o.exe "media/mpeg-avc_wrap.s"
-o.exe "media/mpeg-avc_bs.s"
-o.exe "media/mpeg-avc_encode.s"
-o.exe "media/mpeg-avc_mb.s"
-o.exe "media/mpeg-avc_block.s"
-o.exe "media/mpeg-avc_action.s"
-o.exe "media/mpeg-mp3_data.s"
-o.exe "media/mpeg-mp3_tables.s"
-o.exe "media/mpeg-mp3_wrap.s"
-o.exe "media/mpeg-mp3_bs.s"
-o.exe "media/mpeg-mp3_huffman.s"
-o.exe "media/mpeg-mp3_input.s"
-o.exe "media/mpeg-mp3_mdct.s"
-o.exe "media/mpeg-mp3_encode.s"
-o.exe "media/mpeg-mp3_iteration.s"
-o.exe "media/mpeg-mp3_iteration_code.s"
-o.exe "obj/containers.s"
-o.exe "obj/items.s"
-o.exe "obj/tool.s"
-o.exe "obj/images.s"
-o.exe "str/str.s"
-o.exe "mem/alloc.s"
-o.exe "mem/op.s"
-o.exe "net/net-base.s"
-o.exe "err/err.s"
-o.exe "event/event.s"
-o.exe "file-folder/file-base.s"
-o.exe "file-folder/folder-base.s"
-o.exe "interface/buttons.s"
-o.exe "gnu/gst.s"
+o.exe "_dif/dif~win.oc"
+o.exe "_exec/ostream.oc"
+o.exe "_exec/start.oc"
+o.exe "_exec/mainhandles.oc"
+o.exe "_exec/uri.oc"
+o.exe "_exec/uristream.oc"
+o.exe "_exec/capture/save.oc"
+o.exe "_exec/mediainfo.oc"
+o.exe "_prepare/view.oc"
+o.exe "_prepare/pipe.oc"
+o.exe "_prepare/sel.oc"
+o.exe "_prepare/prevw.oc"
+o.exe "_prepare/paint.oc"
+o.exe "_prepare/stagempeg.oc"
+o.exe "_prepare/output/all.oc"
+o.exe "_prepare/output/stagefileoptions.oc"
+o.exe "_prepare/output/sound.oc"
+o.exe "_prepare/output/avi.oc"
+o.exe "_prepare/output/mkv.oc"
+o.exe "_prepare/frame/frame.oc"
+o.exe "_prepare/frame/add.oc"
+o.exe "_prepare/frame/remove.oc"
+o.exe "_prepare/frame/frametime.oc"
+o.exe "_prepare/frame/imagetools.oc"
+o.exe "_prepare/frame/scale.oc"
+o.exe "_prepare/frame/crop.oc"
+o.exe "_prepare/frame/pencil.oc"
+o.exe "_prepare/frame/screenshot.oc"
+o.exe "_prepare/frame/brightness.oc"
+o.exe "_prepare/frame/overlay.oc"
+o.exe "_prepare/frame/rotate.oc"
+o.exe "_prepare/effect/base.oc"
+o.exe "_prepare/effect/fade.oc"
+o.exe "_prepare/effect/move.oc"
+o.exe "_prepare/effect/scale_effect.oc"
+o.exe "_prepare/effect/reveal.oc"
+o.exe "_prepare/effect/reveal_shape.oc"
+o.exe "_prepare/effect/reveal_diagonal.oc"
+o.exe "_search/dialog.oc"
+o.exe "_search/dialog_fns.oc"
+o.exe "_search/parse.oc"
+o.exe "_search/previews.oc"
+o.exe "_exec/mix.oc"
+o.exe "_exec/help.oc"
+o.exe "_capture/capture.oc"
+o.exe "util/util.oc"
+o.exe "util/update.oc"
+o.exe "util/numbers.oc"
+o.exe "util/floating.oc"
+o.exe "util/lists.oc"
+o.exe "util/asm.oc"
+o.exe "media/audiovideo.oc"
+o.exe "media/jpeg.oc"
+o.exe "media/jpeg_enc.oc"
+o.exe "media/mpeg.oc"
+o.exe "media/mpeg_init.oc"
+o.exe "media/mpeg_enc.oc"
+o.exe "media/mpeg_pred.oc"
+o.exe "media/mpeg_code.oc"
+o.exe "media/mpeg_interframe.oc"
+o.exe "media/mp4.oc"
+o.exe "media/mp4_data.oc"
+o.exe "media/mpeg-avc_data.oc"
+o.exe "media/mpeg-avc_wrap.oc"
+o.exe "media/mpeg-avc_bs.oc"
+o.exe "media/mpeg-avc_encode.oc"
+o.exe "media/mpeg-avc_mb.oc"
+o.exe "media/mpeg-avc_block.oc"
+o.exe "media/mpeg-avc_action.oc"
+o.exe "media/mpeg-mp3_data.oc"
+o.exe "media/mpeg-mp3_tables.oc"
+o.exe "media/mpeg-mp3_wrap.oc"
+o.exe "media/mpeg-mp3_bs.oc"
+o.exe "media/mpeg-mp3_huffman.oc"
+o.exe "media/mpeg-mp3_input.oc"
+o.exe "media/mpeg-mp3_mdct.oc"
+o.exe "media/mpeg-mp3_encode.oc"
+o.exe "media/mpeg-mp3_iteration.oc"
+o.exe "media/mpeg-mp3_iteration_code.oc"
+o.exe "obj/containers.oc"
+o.exe "obj/items.oc"
+o.exe "obj/tool.oc"
+o.exe "obj/images.oc"
+o.exe "str/str.oc"
+o.exe "mem/alloc.oc"
+o.exe "mem/op.oc"
+o.exe "net/net-base.oc"
+o.exe "err/err.oc"
+o.exe "event/event.oc"
+o.exe "file-folder/file-base.oc"
+o.exe "file-folder/folder-base.oc"
+o.exe "interface/buttons.oc"
+o.exe "gnu/gst.oc"
